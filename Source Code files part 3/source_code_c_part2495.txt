tedTarget->ContainsTarget(pTarget))
				continue;

			g_BldSysIFace.GetFileSetName(hFileSet, strFileSet, hBld);

			m_subprojects.AddItem(strFileSet, FALSE, hFileSet, NULL);
		}
	}
}

////////////////////////////////////////////////////////////////////////////

void CProject::OnSubprojects()
{
	// Is project window active?
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	BOOL bActive = pProjSysIFace->IsWindowActive() == S_OK;

	HBUILDER hBld = ACTIVE_BUILDER; // default

	// use selection if possible
	if	(bActive)
	{
		CMultiSlob *	pMultiSlob = NULL;
		
		// Find the current selection.
		pProjSysIFace->GetSelectedSlob(&pMultiSlob);

		if( (pMultiSlob != NULL) && (pMultiSlob->GetContentList()->GetCount() > 0) )
		{
			
			CSlob * pSlob = pMultiSlob->GetDominant();
			if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)))
				pSlob = ((CBuildViewSlob *)pSlob)->GetBuildSlob();
			else if (!pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
				pSlob = NULL;
			
			if (pSlob != NULL)
			{
				hBld = (HBUILDER)((CBuildSlob *)pSlob)->GetProjItem()->GetProject();
			}
		}
	}

	// Show the dialog.
	CSubprojectsDlg dlg(g_BldSysIFace.GetFileSet(hBld, ACTIVE_TARGET));
	dlg.DoModal();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\dirsdlg.cpp ===
// DIRSDLG.CPP
// -----------
// Implements the Directories dialog.
//
// History
// =======
// 26-Aug-93	mattg		Created
// 30-Sep-93	marklam		Disabled toolbox opts, changed directory options to a combo.
// 25-Oct-93	marklam		Changed Add edit box to use a dir picker
// 30-Nov-93	karlsi		ADD at the current selection, "undo", and other enhancements
// 14-Jan-94	colint		Added Platform combo-box and reenabled toolsets.

////////////////////////////////////////////////////////////
// Include files

#include "stdafx.h"
#pragma hdrstop
#include "dirsdlg.h"
#include "dirmgr.h"
#include "resource.h"
#include "projcomp.h"
#include <dlgbase.h>
#include <ids.h>

// Convenient way of identifying the directory options selection
#define DIRS_OPTIONS_EXECUTABLE	(0)
#define DIRS_OPTIONS_INCLUDE	(1)
#define DIRS_OPTIONS_LIB		(2)
#define DIRS_OPTIONS_SOURCE     (3)

// the resource string IDs for the directory sets
// N.B. this should match the above order
static UINT rguDirSetText[] = 
{
	IDS_DIRS_EXECUTABLE,
	IDS_DIRS_INCLUDE,
	IDS_DIRS_LIB,
	IDS_DIRS_SOURCE,
};

static UINT rguDirTypes [] =
{
	DIRLIST_PATH,
	DIRLIST_INC,
	DIRLIST_LIB,
	DIRLIST_SOURCE
};

// the resource string IDs for the directory sets for Java
// N.B. this should match the above order
static UINT rguJavaDirSetText[] = 
{
	IDS_DIRS_EXECUTABLE,
	IDS_DIRS_CLASSES,
	IDS_DIRS_SOURCE
};

static UINT rguJavaDirTypes [] =
{
	DIRLIST_PATH,
	DIRLIST_INC,	// CLASSPATH replaces INCLUDE
	DIRLIST_SOURCE
};
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

////////////////////////////////////////////////////////////
// CDirsGrid
CDirsGrid::CDirsGrid()
	: CStringListGridWnd(GRIDLIST_ELLIPSE)
{
}

////////////////////////////////////////////////////////////
// Constructors, destructors

CDirsOptDlg::CDirsOptDlg()
	: CDlgTab(IDDP_OPTIONS_DIRECTORIES, IDS_DIRECTORIES)
{
	m_DirGrid.m_pDlg = this;
	m_pDirs = NULL;
	m_bDeleteDirs = FALSE;
	m_bAlreadyWarnedOfBuild = FALSE;	
	m_nJavaPlatform = -1;

#ifdef _DEBUG
	// shouldn't invoke this dialog with no platform toolsets
	// the dialog is not operational without *at least one* platform
	CDirMgr * pDirMgr = GetDirMgr();
	ASSERT(pDirMgr != (CDirMgr *)NULL);
	ASSERT(pDirMgr->GetNumberOfToolsets() > 0);
#endif
}

CDirsOptDlg::~CDirsOptDlg
(
)
{
	INT			nToolSet, type, nMaxToolsets;
	CObList *	pList;

	CDirMgr * pDirMgr = GetDirMgr();

	if (m_bDeleteDirs)
	{
		nMaxToolsets = pDirMgr->GetNumberOfToolsets();

		for (type=0 ; type<C_DIRLIST_TYPES ; ++type)
		{
			for (nToolSet=0 ; nToolSet<nMaxToolsets; ++nToolSet)
			{
				if ((pList = m_pDirs[nToolSet][(DIRLIST_TYPE)type]) != NULL)
				{
					POSITION	pos = pList->GetHeadPosition();

					while (pos != NULL)
						delete pList->GetNext(pos);

					delete pList;
				}
			}
		}
	}

	delete [] m_pDirs;
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::Activate

BOOL CDirsOptDlg::Activate
(
	CTabbedDialog *	ptd,
	CPoint			cp
)
{
	INT		nToolset, type;
	INT		nMaxToolsets;

	// Set up the arrays of dirlists and clone the existing
	// ones from the CDirMgr object.

	CDirMgr * pDirMgr = GetDirMgr();
	nMaxToolsets = pDirMgr->GetNumberOfToolsets();

	if (!m_bDeleteDirs)		// ignore extra call generated by BrowseDirectories()
	{
		m_pDirs = new CObList* [nMaxToolsets][(int)C_DIRLIST_TYPES];
		
		for (type=0 ; type<C_DIRLIST_TYPES ; ++type)
			for (nToolset=0 ; nToolset<nMaxToolsets ; ++nToolset)
				m_pDirs[nToolset][type] =
				  pDirMgr->CloneDirList((DIRLIST_TYPE)type, nToolset);

		m_bDeleteDirs = TRUE;
	}

	// Make sure that the actual activation occurs!
	return CDlgTab::Activate( ptd, cp );
}


BOOL CDirsOptDlg::ValidateTab()
{
	if (!m_DirGrid.AcceptControl())
	{
 		return FALSE;
	}

	return TRUE;
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::PosFromListboxIndex

POSITION CDirsOptDlg::PosFromListboxIndex
(
	INT	nIndex
)
{
	CObList *	pList;

	pList = m_pDirs[m_nToolset][m_type];

	return pList->FindIndex(nIndex);
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::SetListboxSel

VOID CDirsOptDlg::SetListboxSel
(
	INT		nSel
)
{
	m_DirGrid.SetCurSel(nSel);
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::OnInitDialog

BOOL CDirsOptDlg::OnInitDialog
(
)
{
	INT nSel, nToolset;
	CString strDirsOpt, strToolsetName;
	CComboBox *pDirsOptCombo = (CComboBox *)GetDlgItem(IDC_DIRS_OPTIONS);
	CComboBox *pDirsToolsetCombo = (CComboBox *)GetDlgItem(IDC_DIRS_TOOLSETS);
	CDirMgr * pDirMgr = GetDirMgr();

	m_nToolset = pDirMgr->GetCurrentToolset();

	// Set the platform list type combo.
	INT nMaxToolsets = pDirMgr->GetNumberOfToolsets();
	for (nToolset = 0; nToolset < nMaxToolsets; nToolset++)
	{
		strToolsetName = pDirMgr->GetToolsetName(nToolset);

		// Convert the "Official" platform name to the
		// UI description.
		CPlatform * pPlatform;
		CString strUIName;

		g_prjcompmgr.LookupPlatformByOfficialName(strToolsetName, pPlatform);
		if (pPlatform)
		{
			strUIName = *(pPlatform->GetUIDescription());
			nSel = pDirsToolsetCombo->AddString(strUIName);
			if (pPlatform->GetUniqueId () == java)
				m_nJavaPlatform = nToolset;
		}
	}
	pDirsToolsetCombo->SetCurSel(m_nToolset);

	// Set the directory list type combo.
	m_type = DIRLIST_INC;

	// And the list itself.
	FillOptionsList ();
	pDirsOptCombo->SetCurSel (DIRS_OPTIONS_INCLUDE); // HACK this works because both Java and normal index 2 is include/classes

	// Create the dir grid
	VERIFY(m_DirGrid.ReplaceControl(this,
									IDC_PLACEHOLDER2, IDC_DIRS_LIST,
									WS_VISIBLE | WS_CHILD | WS_VSCROLL | WS_TABSTOP,
									WS_EX_CLIENTEDGE, GRIDWND_TB_ALL));

	// Establish the listbox contents.  This will also disable
	// any buttons which depend on a selection in the listbox.
	ResetListbox();

	// Nothing has changed (yet)
	m_bModified = FALSE;
    
    return(TRUE);
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::CheckForBuildAndWarn
void CDirsOptDlg::CheckForBuildAndWarn ()
{
	if (m_bAlreadyWarnedOfBuild) return;
	m_bAlreadyWarnedOfBuild = TRUE;
	// If there is a build in process, then warn the user that changes
	// to the directories will not take effect until the next build:

	if (g_Spawner.SpawnActive ())
	{
		MsgBox ( Information, IDS_DIR_CHANGE_IN_BUILD );
	}
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::FillOptionsList
void CDirsOptDlg::FillOptionsList ()
{
	UINT		iCurSel, iDirOptCounter, iDirOptMax, *pStrId, *pDirListTypes;
	CComboBox	*pDirsOptCombo = (CComboBox *)GetDlgItem(IDC_DIRS_OPTIONS);
	CComboBox	*pDirsToolsetCombo = (CComboBox *)GetDlgItem(IDC_DIRS_TOOLSETS);
	CString		strDirsOpt;

	iCurSel = pDirsOptCombo->GetCurSel ();
	pDirsOptCombo->SetRedraw (FALSE);
	pDirsOptCombo->ResetContent();

	if ((m_nJavaPlatform != -1) && (pDirsToolsetCombo->GetCurSel () == m_nJavaPlatform))
	{
		pStrId = rguJavaDirSetText;
		pDirListTypes = rguJavaDirTypes;
		iDirOptMax = sizeof (rguJavaDirSetText) / sizeof (rguJavaDirSetText [0]);
	}
	else
	{
		pStrId = rguDirSetText;
		pDirListTypes = rguDirTypes;
		iDirOptMax = sizeof (rguDirSetText) / sizeof (rguDirSetText [0]);
	}

	for (iDirOptCounter = 0; iDirOptCounter < iDirOptMax ; iDirOptCounter++)
	{
		strDirsOpt.LoadString(pStrId[iDirOptCounter]);
		INT i = pDirsOptCombo->AddString(strDirsOpt);
		pDirsOptCombo->SetItemData (i, pDirListTypes [iDirOptCounter]);
	}

	pDirsOptCombo->SetRedraw (TRUE);
	
	if (iCurSel == CB_ERR)
		return;

	if (iCurSel < iDirOptMax)
		pDirsOptCombo->SetCurSel (iCurSel);
	else
		pDirsOptCombo->SetCurSel (iDirOptMax - 1);

	OnSelChangeDirOptions ();
}





////////////////////////////////////////////////////////////
// CDirsOptDlg::ResetListbox
void CDirsOptDlg::ResetListbox
(
	BOOL bSetSelection /* = TRUE */
)
{
	POSITION	pos;
	CObList *	pList;

	m_DirGrid.SetRedraw(FALSE);
	m_DirGrid.ResetContent();

	pList = m_pDirs[m_nToolset][m_type];
	pos = pList->GetHeadPosition();

	while (pos != NULL)
		m_DirGrid.AddString((const TCHAR *)*(CDir *)pList->GetNext(pos));

	// Set the current selection in the directories list to
	// be the first one.
	if (bSetSelection)
		m_DirGrid.SetCurSel(0);

	m_DirGrid.SetRedraw(TRUE);
	m_DirGrid.Invalidate(FALSE);
}

////////////////////////////////////////////////////////////
// CDirsOptDlg::CommitTab

void CDirsOptDlg::CommitTab()
{
	if (GetSafeHwnd() == NULL)
		return;

	m_DirGrid.AcceptControl();

	INT		nToolset, type;
	INT		nMaxToolsets;

	// Set up the arrays of dirlists and clone the existing
	// ones from the CDirMgr object.

	CDirMgr * pDirMgr = GetDirMgr();
	nMaxToolsets = pDirMgr->GetNumberOfToolsets();

	for (type=0 ; type<C_DIRLIST_TYPES ; ++type)
		for (nToolset=0 ; nToolset<nMaxToolsets ; ++nToolset)
			pDirMgr->SetDirList((DIRLIST_TYPE)type, nToolset, m_pDirs[nToolset][type]);

	pDirMgr->SetCurrentToolset(m_nToolset);

	m_bDeleteDirs = FALSE;

  	// Send the package notification only if something was tweaked
	if (m_bModified)
		theApp.NotifyPackages (PN_DIRECTORIES_CHANGED);

}

////////////////////////////////////////////////////////////
// Button-clicked handlers

BEGIN_MESSAGE_MAP(CDirsOptDlg, CDlgTab)
	//{{AFX_MSG_MAP(CDirsOptDlg)
	ON_CBN_SELCHANGE(IDC_DIRS_OPTIONS,OnSelChangeDirOptions)
	ON_CBN_SELCHANGE(IDC_DIRS_TOOLSETS, OnSelChangeDirToolset)

	ON_ELLIPSE(IDC_DIRS_LIST, OnBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

static BOOL fIgnoreChange = FALSE;

VOID CDirsOptDlg::OnSelChangeDirOptions()
{
	if (!m_DirGrid.AcceptControl())
	{
		// Set focus to the grid		
		m_DirGrid.SetFocus();
		// Restore previous selection 
		
		// jimsc 10-02-96 Removed the following for java classes support
		/*
		UINT nID;
		switch (m_type)
		{
			case DIRLIST_PATH:
				nID = DIRS_OPTIONS_EXECUTABLE;
 				break;

			case DIRLIST_INC:
				nID = DIRS_OPTIONS_INCLUDE;
 				break;

			case DIRLIST_LIB:
				nID = DIRS_OPTIONS_LIB;
 				break;

			case DIRLIST_SOURCE:
				nID = DIRS_OPTIONS_SOURCE;
 				break;

			default:
				ASSERT(FALSE);
		}
		*/
		((CComboBox*)GetDlgItem(IDC_DIRS_OPTIONS))->SetCurSel(m_nCurTypeSel);
        return;
	}
	CComboBox *pCombo = (CComboBox*)GetDlgItem(IDC_DIRS_OPTIONS);
	m_nCurTypeSel = pCombo->GetCurSel ();
	m_type = (DIRLIST_TYPE) pCombo->GetItemData (m_nCurTypeSel);

	// jimsc  10-02-96 Removed the following for java classes support
	/*
	switch ( ((CComboBox*)GetDlgItem(IDC_DIRS_OPTIONS))->GetCurSel() )
	{
		case DIRS_OPTIONS_EXECUTABLE:
			m_type = DIRLIST_PATH;
			break;
		case DIRS_OPTIONS_INCLUDE:
			m_type = DIRLIST_INC;
			break;
		case DIRS_OPTIONS_LIB:
			m_type = DIRLIST_LIB;
			break;
		case DIRS_OPTIONS_SOURCE:
			m_type = DIRLIST_SOURCE;
			break;
		default:
			ASSERT(FALSE);
	}
	*/							  	

 	ResetListbox();
	SetListboxSel(0);

}

VOID CDirsOptDlg::OnSelChangeDirToolset()
{
	CComboBox *	pComboBox;
	pComboBox = (CComboBox *)GetDlgItem(IDC_DIRS_TOOLSETS);

	if (!m_DirGrid.AcceptControl())
	{
		// Set focus to the grid
		m_DirGrid.SetFocus();

		// Restore previous selection
		pComboBox->SetCurSel(m_nToolset);

        return;
	}

	INT		nSel;

	nSel = pComboBox->GetCurSel();
	m_nToolset = nSel;

	FillOptionsList ();
	ResetListbox();
	SetListboxSel(0);
}

BOOL CDirsOptDlg::OnAddDir(int nIndex)
{
	CString strNewEntry;
	CDir dir;

	VERIFY(m_DirGrid.GetText(nIndex, strNewEntry));

	strNewEntry.TrimLeft();
	if (strNewEntry.IsEmpty())
	{
		m_DirGrid.DoDelete();
		return FALSE;
	}

	if (dir.CreateFromString(strNewEntry))
	{
		CString strMsg;
		if (!dir.ExistsOnDisk() && (MsgBox(Question, MsgText(strMsg,
				IDS_DIR_NOT_EXIST,  (const TCHAR *)dir), 
				MB_YESNO | MB_DEFBUTTON2) != IDYES))
		{
			return FALSE;
		}
	}
	else
	{
		MsgBox(Information, IDS_BAD_DIR_SPEC);

		return FALSE;
	}

	// Get the correct list
	CObList* pList = m_pDirs[m_nToolset][m_type];

	// Check that the directory is not already in the list
	BOOL bAlreadyExists = FALSE;
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL && !bAlreadyExists)
	{
		CDir* pOldDir = (CDir *)pList->GetNext(pos);
		if (*pOldDir == dir)
			bAlreadyExists = TRUE;
	}

	if (!bAlreadyExists)
	{
		// Create an instance of CDir to store in the list
		CDir *pDir = new CDir;
		*pDir = dir;

		// Add it to the tail
		ASSERT(nIndex == (m_DirGrid.GetCount()));
		pList->AddTail(pDir); // Insert at Current Position

		// make sure that absolute path is displayed
		fIgnoreChange = TRUE;
		m_DirGrid.SetRedraw(FALSE);
		m_DirGrid.SetText(nIndex, (const TCHAR *)*pDir);
		m_DirGrid.SetRedraw(TRUE);
		m_DirGrid.Invalidate(FALSE);
		CheckForBuildAndWarn();
        m_bModified = TRUE;
		return TRUE;
	}
	else
	{
		MsgBox(Information, IDS_DUPE_DIR_SPEC);
		return FALSE;
	}
}

BOOL CDirsOptDlg::OnDelDir(int nIndex)
{
	// Get the list of CDirs
	CObList* pList;
	pList = m_pDirs[m_nToolset][m_type];

	// Get the position of this entry
	POSITION pos = PosFromListboxIndex(nIndex);

	// Delete this entry
	ASSERT(pos != NULL);
	delete pList->GetAt(pos);
	pList->RemoveAt(pos);

 	CheckForBuildAndWarn();
    m_bModified = TRUE;
	return TRUE;
}

BOOL CDirsOptDlg::OnMoveDir(int nSrcIndex, int nDestIndex)
{
	// Get the list of CDirs
	CObList* pList;
	pList = m_pDirs[m_nToolset][m_type];

	// Get the current position of this entry
	POSITION pos = PosFromListboxIndex(nSrcIndex);
	ASSERT(pos != NULL);

	// Remove it
	CObject* pOb = pList->GetAt(pos);
	pList->RemoveAt(pos);

	// Get the target position
	pos = PosFromListboxIndex(nDestIndex);

	// and Insert it or Append if last item
	if (pos == (POSITION)NULL)
		pList->AddTail(pOb);
	else
		pList->InsertBefore(pos, pOb);

	CheckForBuildAndWarn();
   	m_bModified = TRUE;
	return TRUE;
}

BOOL CDirsOptDlg::OnChangeDir(int nIndex)
{
	if (fIgnoreChange)
	{
		fIgnoreChange = FALSE;
		return FALSE;
	}

	CString strNewEntry;
	CDir dir;

	VERIFY(m_DirGrid.GetText(nIndex, strNewEntry));

	strNewEntry.TrimLeft();
	if (strNewEntry.IsEmpty())
	{
		m_DirGrid.DoDelete();
       	m_bModified = TRUE;
		return TRUE;
	}

	if (dir.CreateFromString(strNewEntry))
	{
		CString strMsg;
		if (!dir.ExistsOnDisk() && (MsgBox(Question, MsgText(strMsg,
				IDS_DIR_NOT_EXIST,  (const TCHAR *)dir), 
				MB_YESNO | MB_DEFBUTTON2) != IDYES))
		{
			return FALSE;
		}
	}
	else
	{
		MsgBox(Information, IDS_BAD_DIR_SPEC);

		return FALSE;
	}

	// Get the current position of this entry
	POSITION posCurrent = PosFromListboxIndex(nIndex);
	ASSERT(posCurrent != NULL);

	// Get the correct list
	CObList* pList = m_pDirs[m_nToolset][m_type];

	// Check that the directory is not already in the list
	BOOL bAlreadyExists = FALSE;
	POSITION pos = pList->GetHeadPosition();
	while (pos != NULL && !bAlreadyExists)
	{
		// Ignore the current entry during the check
		if (pos == posCurrent)
		{
			pList->GetNext(pos);
			continue;
		}

		CDir* pOldDir = (CDir *)pList->GetNext(pos);

		if (*pOldDir == dir)
			bAlreadyExists = TRUE;
	}

	if (bAlreadyExists)
	{
		MsgBox(Information, IDS_DUPE_DIR_SPEC);
		return FALSE;
	}

	// Get a pointer to the current CDir object
	pos = PosFromListboxIndex(nIndex);
	ASSERT(pos != NULL);
	CDir* pDir = (CDir*) pList->GetAt(pos);

	// And set it to the new text
	*pDir = dir;

	// make sure that absolute path is displayed
	m_DirGrid.SetRedraw(FALSE);
	m_DirGrid.SetText(nIndex, (const TCHAR *)*pDir);
	m_DirGrid.SetRedraw(TRUE);
	m_DirGrid.Invalidate(FALSE);
	CheckForBuildAndWarn();
   	m_bModified = TRUE;
	return TRUE;
}

VOID CDirsOptDlg::OnBrowse()
{
	CDirChooser chooser;
	if (chooser.DoModal() == IDOK)
	{
		CString strDirectory = chooser.GetPathName();
		CEdit* pEdit = (CEdit*)m_DirGrid.GetDlgItem(1);

		ASSERT(pEdit != NULL);
		pEdit->SetWindowText(strDirectory);
		pEdit->SetSel(0, -1);
		pEdit->SetFocus();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\dirmgr.h ===
// DIRMGR.H
// --------
// Defines the directory manager, which manages the lists
// of directories for:
//
// - Executable files (traditionally the 'PATH' environment variable)
// - Include files ('INCLUDE')
// - Library files ('LIB')
// - Help files
//
// History
// =======
// 27-Aug-93	mattg		Created
// 10-Jan-93	colint		Added CToolset

#ifndef __DIRMGR_H__
#define __DIRMGR_H__

////////////////////////////////////////////////////////////
// Include files
										  
#ifndef __PATH_H__
#include <path.h>
#endif

class CDirMgr; // Forward defn.

////////////////////////////////////////////////////////////
// CToolset

class CToolset : public CObject
{
	friend class CDirMgr;

protected:
			CObList * m_Dirs[C_DIRLIST_TYPES];

			// Cache of the semi-colon seperated string representation
			// of this path. 
			CString   m_DirString[C_DIRLIST_TYPES];

			VOID RefreshAllCachedStrings( );

public:
			CToolset();
			~CToolset();

			CObList * GetDirList(DIRLIST_TYPE type);
				// Return a list of CDir objects.  The DIRLIST_TYPE argument
				// specifies which kind of list you want (DIRLIST_PATH,
				// DIRLIST_INC, etc.).   
				//
				// The returned list may be empty!
				//
				// PLEASE don't modify the list returned, as it's a pointer to
				// the actual list!

			VOID GetDirListString(CString &str, DIRLIST_TYPE type);

			VOID SetDirList(DIRLIST_TYPE type, CObList * pList);
				// Sets the specified list to the one passed in.  The 'original'
				// (existing) list is discarded, along with its contained objects.
};
 
////////////////////////////////////////////////////////////
// CDirMgr

class CDirMgr : public CObject
{
protected:
			CObList m_Toolsets;
				// List of CToolset objects, which contain arrays of lists of 
				// CDir objects for executable files,  include files, etc.
			INT	m_nCurrentToolset;
				// Index of the current toolset
			CStringList m_ToolsetNames;
				// List of the platform names for each toolset.

			CToolset * GetToolset(INT nToolset);
				// Useful helper function for retrieving a toolset.

public:
					CDirMgr();
	virtual			~CDirMgr();

			INT	GetCurrentToolset(); 
			VOID	SetCurrentToolset(INT nToolset);
				// Get or set the current toolset.

			INT		GetNumberOfToolsets();
				// Returns the number of toolsets currently stored in the
				// directories database

			INT		AddToolset(const CString & strPlatform);
				// Adds a new toolset to the directories database. The toolset
				// corresponds to the environment for a particular
				// platform, which is specified by the strTargetPlatform parameter.
			VOID		DeleteToolset(INT nToolset);
				// Deletes a toolset - this would be useful if the platforms supported
				// can change at run-time.
			
			const CObList * GetDirList(DIRLIST_TYPE type, INT nToolset = -1);
				// Return a list of CDir objects.  The DIRLIST_TYPE argument
				// specifies which kind of list you want (DIRLIST_PATH,
				// DIRLIST_INC, etc.).  The nToolSet argument specifies which list;
				// -1 means the 'current' list and is normally what you want.
				// If nToolSet is not -1, it must be in the range 0..CTOOLSETS-1
				// to specify a particular toolset.
				//
				// The returned list may be empty!
				//
				// PLEASE don't modify the list returned, as it's a pointer to
				// the actual list!

			VOID	GetDirListString(CString & str, DIRLIST_TYPE type, INT nToolset = -1);
				// Similar to GetDirList(), except returns (through the str
				// arg) a concatenated list of paths delimited by semicolon
				// characters (e.g., "C:\FOO;C:\BAR;C:\BIN").

			CObList * CloneDirList(DIRLIST_TYPE type, INT nToolset);
				// Clones the specified list and returns a pointer to the newly
				// created clone.  All CDir objects in the cloned list are also
				// created; that is, they are not simply copied from the 'original'
				// list.  It is the caller's responsibility to delete this list
				// and its contents (i.e., delete each element).  Typically,
				// however, this cloned list will later be used as an argument
				// to SetDirList(), in which case CDirMgr will take care of
				// eventually freeing it.

			VOID	SetDirList(DIRLIST_TYPE type, INT nToolset, CObList * pList);
				// Sets the specified list to the one passed in.  The 'original'
				// (existing) list is discarded, along with its contained objects.

			VOID	SetDirListFromString(DIRLIST_TYPE type, INT nToolset, const TCHAR * sz, BOOL fMustExist = FALSE);
				// Sets the specified list by parsing the string, which must
				// be of the form dir1;dir2;...
				// If 'fMustExist' then don't add a directory in this list if
				// it doesn't exist in the directory's file system.

			INT		GetPlatformToolset(const CString & strPlatform);
				// Returns the toolset number for a particular platform

			CString &	GetToolsetName(INT nToolset);
				// Returns the name of a toolset, this will be the name of a
				// platform that the toolset corresponds to.
};

// retrieve our single-instance of the directory manager for the shell
CDirMgr * GetDirMgr();

// Locate a header file and return the full path
BOOL FindFileOnPath(const CString& strName, CString& strFullPath,
	DIRLIST_TYPE dt = DIRLIST_INC, INT nToolset = -1);

#endif // __DIRMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\dllgrid.cpp ===
// varswnd.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop
#include "dllgrid.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


// Helper functions
int DrawPathText(CDC *pDC, LPCSTR sz, CRect rect, UINT nFormat);

// Global vars
CBitmap c_checkBitmap;
CSize c_checkSize;

#define cxCheckboxMargin	3

/////////////////////////////////////////////////////////////////////////////
// CDLLGridRow
#if 0 // moved to header
CDLLGridRow::CDLLGridRow(CDLLGridWnd *pGridWnd,
						 CDLLGridRow *pParent /*= NULL */)
	: CGridControlRow(pGridWnd)
{
	m_fPreload = TRUE;
	m_fDelete = FALSE;
}	
	
CDLLGridRow::~CDLLGridRow( )
{
	// We don't allocate any data dynamically.
}
#endif

void CDLLGridRow::Update( )
{
	// Sub-classes should provide interesting behavior if need be.
}

void CDLLGridRow::GetColumnText(int nCol, CString& rStr)
{
	switch (nCol)
	{
		case COL_LOCALNAME:
			rStr = m_strLocalName;
			rStr.MakeLower();
			if (!rStr.IsEmpty())
			{
				// If no extension specified, add .dll.
				TCHAR szExt[_MAX_EXT];
				_tsplitpath(rStr, NULL, NULL, NULL, szExt);
				if (*szExt == _T('\0'))
				{
					CString strDLLExt;
					VERIFY(strDLLExt.LoadString(IDS_DLL_EXT));
					rStr += strDLLExt;
				}
			}
			break;

		case COL_REMOTENAME:
			rStr = m_strRemoteName;
			break;

		default:
			ASSERT(FALSE);
			break;
	}		
}

void CDLLGridRow::AdjustForMargins(CRect& rect, int nColumn)
{
	if (nColumn == COL_PRELOAD)
	{
		rect.right -= cxCheckboxMargin;
		rect.left += cxCheckboxMargin;
		rect.InflateRect(0, -cyDefaultGridCellMargin);
	}
	else
	{
		CGridControlRow::AdjustForMargins(rect, nColumn);
	}
}

void CDLLGridRow::OnActivate(BOOL bActivate, int nColumn)
{
	if ( bActivate )
	{
		switch (nColumn)
		{
			case COL_PRELOAD:
				GetDLLGrid()->m_nControlColumn = COL_PRELOAD;
				break;

			case COL_LOCALNAME:
				GetDLLGrid()->m_bEnableEllipse = TRUE;
				CreateControl(edit, nColumn, ES_AUTOHSCROLL);
				break;

			case COL_REMOTENAME:
				GetDLLGrid()->m_bEnableEllipse = FALSE;
				CreateControl(edit, nColumn, ES_AUTOHSCROLL);
				break;

			case -1:
				// don't hilite any column
				break;

			default:
				ASSERT(FALSE);
				break;
		}
	}
	else
	{
		CreateControl(none, -1);
		// CreateControl would normally do this when deleting the previous
		// control, but it may be a checkbox, which the generic grid doesn't use
		GetDLLGrid()->m_nControlColumn = -1;
	}
}

BOOL CDLLGridRow::OnAccept(CWnd *pControlWnd)
{
	CString str;
	CDLLGridWnd *pGrid = GetDLLGrid();
	int nCol = pGrid->m_nControlColumn;

	if (pControlWnd != NULL)
	{
		switch ( pGrid->m_nControlColumn ) 
		{
			case COL_PRELOAD:
				GetDLLGrid()->SetFocus();
				break;

			case COL_LOCALNAME:
				pControlWnd->GetWindowText(str);
				m_strLocalName = str;
				break;

			case COL_REMOTENAME:
				pControlWnd->GetWindowText(str);
				m_strRemoteName = str;
				break;

			default:
				ASSERT(FALSE);
				break;
		}
	}

	// If the user has deleted both the local and remote name, remove the row
	// (but don't ever delete the last row - it's the "new" row)
	if (this != pGrid->GetLastRow() &&
		(nCol == COL_LOCALNAME || nCol == COL_REMOTENAME) &&
		(m_strRemoteName.IsEmpty() && m_strLocalName.IsEmpty()) 
	) {

		// only the current row will be selected
		GetDLLGrid()->DoDelete();
		return TRUE;
	}

	if (this == pGrid->GetLastRow()
			&& (nCol == COL_LOCALNAME || nCol == COL_REMOTENAME)
			&& !str.IsEmpty() ) {

		pGrid->AddRow(new CDLLGridRow(pGrid));
		// Make sure the new row is added at the tail
		ASSERT( pGrid->GetLastRow() != this );
	}

	return TRUE;
}																		 

int CDLLGridRow::GetNextControlColumn(int nColumn)
{
	int nColumnCount = GetDLLGrid()->GetColumnCount();

	if (!GetDLLGrid()->m_fShowRemoteCol)
		nColumnCount--;

	return nColumn == nColumnCount - 1 ? 0 : nColumn + 1;
}

int CDLLGridRow::GetPrevControlColumn(int nColumn)
{
	int nColumnCount = GetDLLGrid()->GetColumnCount();

	if (!GetDLLGrid()->m_fShowRemoteCol)
		nColumnCount--;

	return nColumn <= 0 ? nColumnCount - 1 : nColumn - 1;
}

BOOL CDLLGridRow::OnLButtonDown(UINT nFlags, CPoint point)
{
	// First let normal grid behavior happen
	CGridControlRow::OnLButtonDown(nFlags, point);

	CRect rect;
	GetColumnRect(COL_PRELOAD, rect);
	AdjustForMargins(rect, COL_PRELOAD);
	rect.bottom = rect.top + c_checkSize.cy;
	// Is the click on a checkbox?
	if (rect.PtInRect(point))
	{
		if (GetDLLGrid()->LooksSelected(this))
		{
			GetDLLGrid()->DoToggleCheck();
		}
		else
		{
			SetCheck(m_fPreload ? 0 : 1);
		}
		return TRUE;
	}

	return FALSE;
}

// DrawPathText - helper function that draws the path line by line, since
// DrawText won't split the string after backslashes like we want it to.
int DrawPathText(CDC *pDC, LPCSTR sz, CRect rect, UINT nFormat)
{
	LPSTR szDup = _ftcsdup(sz);
	LPSTR pchNextCharToDraw = szDup;
	int cbRemaining;
	int nMaxWidth = rect.Width();
	CRect rectRemaining = rect;
	int cy = 0;
	TEXTMETRIC tm;

	// Don't use this flag, we'll split the string our way (between slashes)
	ASSERT((nFormat & DT_WORDBREAK) == 0);

	pDC->GetTextMetrics(&tm);
	int cySingleLine = tm.tmHeight + tm.tmExternalLeading;

	while (*pchNextCharToDraw)
	{
		cbRemaining = _ftcslen(pchNextCharToDraw);

		while (TRUE)
		{
			//
			// We'll exit this loop when we know what to draw on the next line
			//
			LPCSTR p;
			int chTmp;
			CRect rectCurrent;

			pDC->DrawText(pchNextCharToDraw, cbRemaining, rectCurrent,
				DT_CALCRECT | DT_NOPREFIX);

			ASSERT(rectCurrent.Height() <= cySingleLine);

			// It fits!  Draw it.			
			if (rectCurrent.Width() <= nMaxWidth) {
				break;
			}

			// Temporarily end the string prematurely so _ftcsrchr finds the 
			// next backslash
			chTmp = pchNextCharToDraw[cbRemaining-1];
			pchNextCharToDraw[cbRemaining-1] = _T('\0');
			p = _ftcsrchr(pchNextCharToDraw, _T('\\'));
			pchNextCharToDraw[cbRemaining-1] = chTmp;

			if (p == NULL) {
				// can't shrink this string anymore, just print it
				break;
			}

			// Chop of the last dir and see if the remaining string fits
			cbRemaining = p - pchNextCharToDraw + 1;
		}

		if (nFormat & DT_CALCRECT) {
			cy += cySingleLine;
		} else {
			cy = pDC->DrawText(pchNextCharToDraw, cbRemaining, rectRemaining, DT_NOPREFIX);
			ASSERT(cy == cySingleLine);
			rectRemaining.top += cy;
		}

		pchNextCharToDraw += cbRemaining;
	}

	free(szDup);
	return cy;
}

// Need to override DrawCell because CGridControlRow will always call
// GetColumnText, which of course doesn't make sense for a checkbox.
// To move this functionality into grid.cpp we need need a virtual func
// GetColumnGridType that, given a column, returns the grid type.  That
// way DrawCell could find out what type the column is and call the correct
// GetColumn* (Text | Check | ?).
void CDLLGridRow::DrawCell(CDC *pDC, const CRect& cellRect, int nColumn)
{
	switch (nColumn)
	{
		case COL_PRELOAD:
		{
			// clear the background
			pDC->ExtTextOut(0,0, ETO_OPAQUE, cellRect, NULL, 0, NULL);

			// Hide the checkbox in the last row, unless the last row is being changed
			if (!(this == GetDLLGrid()->GetLastRow() &&
				(!GetDLLGrid()->LooksSelected(this) || !GetDLLGrid()->m_pActiveElement)))
			{
				CRect rect;
				GetColumnRect(COL_PRELOAD, rect);
				AdjustForMargins(rect, COL_PRELOAD);
				rect.bottom = rect.top + c_checkSize.cy;

				CDC bitmapDC;
				if (bitmapDC.CreateCompatibleDC(pDC))
				{
					int nCheck = GetCheck();
					CBitmap* pOldBitmap = bitmapDC.SelectObject(&c_checkBitmap);
					
					int xSrc, ySrc, xDest, yDest;
					if (theApp.m_bWin4)
					{
						xSrc = c_checkSize.cx * nCheck;
						ySrc = 0;
						xDest = 1;
						yDest = 0;
					}
					else
					{
						xSrc = c_checkSize.cx * nCheck;
						ySrc = 0;
						xDest = 1;
						yDest = 1;
					}
					
					pDC->BitBlt(rect.left + xDest, 
						rect.top + yDest /*+ max(0, (m_cyItem - c_checkSize.cy) / 2)*/, 
						c_checkSize.cx, c_checkSize.cy, 
						&bitmapDC, xSrc, ySrc, SRCCOPY);
					bitmapDC.SelectObject(pOldBitmap);
				}
			}
			break;
		}

		case COL_LOCALNAME:
		case COL_REMOTENAME:
		{
			CRect textRect = cellRect;
			CString str;

			GetColumnText(nColumn, str);
			AdjustForMargins(textRect, nColumn);

			// clear the background
			pDC->ExtTextOut(0,0, ETO_OPAQUE, cellRect, NULL, 0, NULL);

			// The value column can be multi-row if need be, but we need to 
			// split the rows manually after backslashes (since there
			// probably aren't any spaces).
			DrawPathText(pDC, str, textRect, 0);

			// Draw a focus rect in the local column of the last row
			if (this == GetDLLGrid()->GetLastRow() && nColumn == COL_LOCALNAME)
			{
				pDC->DrawFocusRect(textRect);
			}

			break;
		}

		default:
			CGridControlRow::DrawCell(pDC, cellRect, nColumn);
			break;
	}
}

void CDLLGridRow::ResetSize(CDC *pDC)
{
	//CWindowDC dc(NULL);	
	TEXTMETRIC tm;
	int nWidth;
	int nHeight;
	CRect rect;
	CString str;
	
	pDC->GetTextMetrics(&tm);
	m_cyHeight = tm.tmHeight + tm.tmExternalLeading + 3;

	// First do the Local DLL column
	nWidth = GetDLLGrid()->GetColumnWidth(COL_LOCALNAME) - 2 * cxDefaultGridCellMargin;
	rect.SetRect(0, 0, nWidth, 0);
	GetColumnText(COL_LOCALNAME, str);
	nHeight = 2 * cyDefaultGridCellMargin + DrawPathText(pDC, str, rect, DT_CALCRECT);
	m_cyHeight = max(m_cyHeight, nHeight);

	// Next do the Remote DLL column
	nWidth = GetDLLGrid()->GetColumnWidth(COL_REMOTENAME) - 2 * cxDefaultGridCellMargin;
	rect.SetRect(0, 0, nWidth, 0);
	GetColumnText(COL_REMOTENAME, str);
	nHeight = 2 * cyDefaultGridCellMargin + DrawPathText(pDC, str, rect, DT_CALCRECT);
	m_cyHeight = max(m_cyHeight, nHeight);
}

CSize CDLLGridRow::GetCellSize(CDC *, int) const
{
	CSize size;
	
	size.cy = m_cyHeight;
	// This row is flexible so we will not make any size demands.
	size.cx = 0;		

	return size;
}
					 	
void CDLLGridRow::SetCheck(int nCheck)
{
	m_fPreload = nCheck ? TRUE : FALSE;
	Invalidate();
}

/////////////////////////////////////////////////////////////////////////////
// CDLLGridWnd

CDLLGridWnd::CDLLGridWnd(int nColumns, BOOL bDisplayCaption)
	: CGridControlWnd(nColumns, bDisplayCaption)
{
	// DLL-like grids should not be sorted by other criterion.
	EnableSort(FALSE);
	EnableAutoSort(FALSE); 
	m_bNewRow = FALSE;
	m_bEnableEllipse = TRUE;

	m_bShowContextPopup = TRUE;

	// Get the size of the Preload checkbox
	if (c_checkBitmap.m_hObject == NULL)
	{
		BITMAP bitmap;

		VERIFY(c_checkBitmap.LoadOEMBitmap(OBM_CHECKBOXES));
		c_checkBitmap.GetObject(sizeof (BITMAP), &bitmap);
		c_checkSize.cx = bitmap.bmWidth / 4;
		c_checkSize.cy = bitmap.bmHeight / 3;
	}
	//AddRow(new CDLLGridRow(this));
}

CDLLGridWnd::~CDLLGridWnd()
{
	// The CGridWnd destructor deletes the rows so we don't
	// need to do the destruction.
}


BEGIN_MESSAGE_MAP(CDLLGridWnd, CDLLGridWnd::CBaseClass)
	//{{AFX_MSG_MAP(CDLLGridWnd)
	ON_WM_PAINT()
	ON_WM_DESTROY()
	ON_WM_GETDLGCODE()
	ON_WM_CREATE()
	ON_BN_CLICKED(ID_GRD_NEW, OnGridNew)
	ON_BN_CLICKED(ID_GRD_DELETE, OnGridDelete)

	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDLLGridWnd Attributes


/////////////////////////////////////////////////////////////////////////////
// CDLLGridWnd Operations

int CDLLGridWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CGridControlWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	CRect Rect;
	CString strHeader;
	int cxPreload, cx;

	// Set the column captions...
#if 0
	VERIFY(strHeader.LoadString(IDS_DLL_COL_PRELOAD));
	SetColumnCaption(COL_PRELOAD, strHeader);
	cxPreload = (int)GetMinColumnWidth(strHeader);
#else
	SetColumnCaption(COL_PRELOAD, "");

	// Make this column just big enough for the box and margins
	cxPreload = c_checkSize.cx + 2*cxCheckboxMargin;
#endif

	VERIFY(strHeader.LoadString(IDS_DLL_COL_LOCALNAME));
	SetColumnCaption(COL_LOCALNAME, strHeader);

	VERIFY(strHeader.LoadString(IDS_DLL_COL_REMOTENAME));
	SetColumnCaption(COL_REMOTENAME, strHeader);

	// Set the column widths (use the minimum for preload and split the
	// rest of the space between the local and remote columns)

	SetColumnWidth(COL_PRELOAD, cxPreload);
	GetCaptionRow()->SetColumnFixedWidth(COL_PRELOAD);

	GetCaptionRow()->GetRect(Rect);
	cx = Rect.Width() - cxPreload;
	SetColumnWidth(COL_LOCALNAME, cx/2);
	cx -= cx/2;
	SetColumnWidth(COL_REMOTENAME, cx);

	return 0;
}

BOOL CDLLGridWnd::SetCurSel(int nSelect)
{
	CDLLGridRow* pRow = (CDLLGridRow *)GetRow(nSelect);
	if (pRow != NULL)
	{
		Select(pRow);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

/****************************************************************************

	FUNCTION:	GetMinColumnWidth()

	PURPOSE:	Calculates the smallest possible column width based
				on the size of of the fixed font, so that they line up
				nicely with the text in the listbox.

****************************************************************************/
long CDLLGridWnd::GetMinColumnWidth(CString strCaption)
{
	HFONT hFont = (HFONT)GetCaptionFont()->m_hObject;
	HDC hdc = CreateIC("DISPLAY", NULL, NULL, NULL);
	SIZE size;

	ASSERT(hdc != NULL);
	SelectObject(hdc, (HGDIOBJ) hFont);

	GetTextExtentPoint32(hdc, strCaption, strCaption.GetLength(), &size);
	VERIFY(DeleteDC(hdc));
	return (size.cx + 6); // add back for some calls to InsetRect
}

CDLLGridRow * CDLLGridWnd::GetCurSel( )
{
	POSITION pos = GetHeadSelPosition();

	// We should have exactly one item selected.
	if ( pos != NULL &&  (GetNextSel(pos), pos == NULL))
		return GetRowAt(m_posCurRow);
	else
		return NULL;
}

						
CDLLGridRow * CDLLGridWnd::GetRow(int nIndex /* = -1*/ )
{
	if ( nIndex == -1 )
		return GetCurSel();
	else
		return (CDLLGridRow *)CGridControlWnd::GetRow(nIndex); 
}

void CDLLGridWnd::DoDelete()
{
	if (m_selection.IsEmpty())  // don't even try with empty grid
		return;

	POSITION posNewSel = NULL;
	while (!m_selection.IsEmpty())
	{
		POSITION posPrimary = GetHeadSelPosition();
		CDLLGridRow* pSelRow = (CDLLGridRow*) GetNextSel(posPrimary);

		if (pSelRow != GetLastRow())
		{
			// BLOCK: Pick the correct row to select
			{
				if (posPrimary != NULL)
				{
					CDLLGridRow* pSetSel = (CDLLGridRow*) m_selection.GetAt(posPrimary);
					posNewSel = m_rows.Find(pSetSel);
				}
				else
				{
					posNewSel = m_rows.Find(pSelRow);
					m_rows.GetNext(posNewSel);
				}
			}

			// Inform of the delete
			//int nIndex = GetRowIndex(pSelRow);
			//if (OnDeleteString(nIndex))
				RemoveRow(pSelRow); // Remove the primary selection
				delete pSelRow;
		}
		else
		{
			Deselect(pSelRow);
		}
	}

	// Redraw
	Invalidate(FALSE);
	ResetScrollBars();

	// Default to the last row
	if (posNewSel == NULL)
		posNewSel = m_rows.GetTailPosition();

	// Set the selection
	CDLLGridRow* pSelRow = (CDLLGridRow*) m_rows.GetAt(posNewSel);
	ASSERT((CGridRow*)pSelRow != (CGridRow*)GetCaptionRow());

	SetActiveElement(pSelRow);
	Select(pSelRow);
}

void CDLLGridWnd::DoToggleCheck()
{
	POSITION pos = GetHeadSelPosition();
	CDLLGridRow* pSelRow;
	BOOL fSomeChecked = FALSE;

	SetFocus();

	// Pass1: are any boxes checked?
	while (pos != NULL)
	{
		pSelRow = (CDLLGridRow*) GetNextSel(pos);
		if (pSelRow != GetLastRow())
		{
			// Toggle the checkbox
			fSomeChecked |= pSelRow->m_fPreload;
		}
	}

	// Pass2: set all selected checkboxes
	pos = GetHeadSelPosition();
	while (pos != NULL)
	{
		pSelRow = (CDLLGridRow*) GetNextSel(pos);
		if (pSelRow != GetLastRow())
		{
			pSelRow->SetCheck(fSomeChecked ? 0 : 1);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CDLLGridWnd diagnostics

#ifdef _DEBUG
void CDLLGridWnd::AssertValid() const
{
	// Sorted DLL control doesn't make sense.
	// ASSERT(m_nSortColumn == -1);
	CGridControlWnd::AssertValid();
}

void CDLLGridWnd::Dump(CDumpContext& dc) const
{
	CGridControlWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CDLLGridWnd message handlers


void CDLLGridWnd::OnPaint() 
{
	if (m_fEnabled) {
		CGridControlWnd::OnPaint();	// pass on to our base instance
	} else {
		
		CPaintDC dc(this);
		CGridRow* pRow;
		CRect rowRect;
		GetClientRect(rowRect);

		// Draw the captions first
		pRow = GetCaptionRow();
		rowRect.bottom = rowRect.top + pRow->GetRowHeight();
		if (dc.m_ps.rcPaint.top < rowRect.bottom)
		{
			CFont* pOldFont = dc.SelectObject(GetCaptionFont( ));
			pRow->Draw(&dc, rowRect);
			dc.SelectObject(pOldFont);
		}
	
		// Setup clip rect around the actual grid (client less captions)
		rowRect.top = rowRect.bottom;
		rowRect.bottom = dc.m_ps.rcPaint.bottom;

		dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
		dc.ExtTextOut(0, 0, ETO_OPAQUE, rowRect, NULL, 0, NULL);
		
	}
}


void CDLLGridWnd::OnDestroy() 
{
	CGridControlWnd::OnDestroy();
}


BOOL CDLLGridWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo) 
{

	// HACK begets HACK. CGridControlWnd bypasses command handlers
	// in the grid window if no control is enabled. We need to handle
	// commands even when no control is available. So directly
	// call CGridWnd's OnCmdMsg.	
	return CGridWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

afx_msg UINT CDLLGridWnd::OnGetDlgCode() 
{
	return CGridControlWnd::OnGetDlgCode() | DLGC_WANTARROWS | DLGC_WANTCHARS;
}

afx_msg void CDLLGridWnd::OnGridNew() 
{
	// activate the new row
	CDLLGridRow* pSelRow = GetLastRow();
	if (pSelRow != NULL)
	{
		Select(pSelRow);
		// Auto-activate the edit box in the Local Name column
		ActivateNextControl();
		ActivateNextControl();

	}	

	CGridControlWnd::OnGridNew();
}

afx_msg void CDLLGridWnd::OnGridDelete()
{
	if (m_pActiveElement == NULL)
	{
		DoDelete();
	}
	CGridControlWnd::OnGridDelete();
}


BOOL CDLLGridWnd::ProcessKeyboard(MSG* pMsg, BOOL bPreTrans /*= FALSE*/)
{
	switch (pMsg->message)
	{
	case WM_KEYDOWN:
		switch (pMsg->wParam)
		{
		case VK_DELETE:
			if (m_pActiveElement == NULL)
			{
				DoDelete();
				return TRUE;
			}
			break;
		case VK_F2:
			if (!m_pActiveElement && m_selection.GetCount())
			{
				// Auto-activate the edit box in the Local Name column
				ActivateNextControl();
				ActivateNextControl();

				// The Local Name cell should now be active
				ASSERT( m_pControlWnd->IsKindOf( RUNTIME_CLASS( CEdit ) ) );
				ASSERT(m_nControlColumn == COL_LOCALNAME);
				((CEdit *)m_pControlWnd)->SetSel( 0, -1 );

				// Don't use CGridControlWnd - it'll try to auto-activate
				return TRUE;
			}
			break;
		case VK_RETURN:
		case VK_ESCAPE:
			if (m_pActiveElement == NULL)
			{
				CWnd* pParent = GetParent();
				if (pParent != NULL)
				{
					ASSERT(bPreTrans); // If this ever fails, we need to re-send the message to hwndChild
					pMsg->hwnd = pParent->m_hWnd;
				}
				return CGridWnd::ProcessKeyboard(pMsg, bPreTrans); // must skip CGridControlWnd
			}
			break;

		case VK_TAB:
			// control-tab is mdi window switching
			if (GetKeyState(VK_CONTROL) < 0)
				break;

			// in a dialog tab pops us out of grid. Pretrans ignores, non pretrans cluses and posts
			if (m_pActiveElement == NULL && m_bParentIsDialog)
				break;

			if (!AcceptControl(FALSE))
				return TRUE;

			// BLOCK: Tab between elements, or dlg controls
			{
				CGridElement* pOldActive = m_pActiveElement;
				int nOldColumn = m_nControlColumn;

				BOOL bDoTabInDialog = m_bParentIsDialog;

				if (!bDoTabInDialog)
				{
					if (GetKeyState(VK_SHIFT) < 0)
						ActivatePrevControl();
					else
						ActivateNextControl();
				}

				if (bDoTabInDialog || (pOldActive == m_pActiveElement && nOldColumn == m_nControlColumn))
				{
					// We must be at the last (or first) element in the grid
					CloseActiveElement();

					CWnd* pParent = GetParent();
					if (pParent != NULL)
					{
						if (bPreTrans)
						{
							pMsg->hwnd = pParent->m_hWnd;
						}
						else
						{
						if (m_bParentIsDialog)
							{
								ASSERT(pParent->IsKindOf(RUNTIME_CLASS(CDialog)));
								if (GetKeyState(VK_SHIFT) < 0)
									((CDialog *)pParent)->PrevDlgCtrl();	
								else
									((CDialog *)pParent)->NextDlgCtrl();
							}
						else
							pParent->PostMessage(pMsg->message, pMsg->wParam, pMsg->lParam);
						}
					}
					return CGridWnd::ProcessKeyboard(pMsg, bPreTrans); // must skip CGridControlWnd
				}

				return TRUE;
			}

		case VK_UP:
		case VK_DOWN:
		case VK_RIGHT:
		case VK_LEFT:
			// Don't let the user "arrow" out of a checkbox
			if (m_nControlColumn == COL_PRELOAD)
			{
				ASSERT(m_pActiveElement);
				ASSERT(m_pControlWnd == NULL);
				return TRUE;
			}
		}
		break;

	case WM_CHAR:
		// We handle WM_CHAR to auto-activate the Local Name column
		// (default behavior would activate the Preload column).

		BOOL bEscape = (LOBYTE(pMsg->wParam) == VK_ESCAPE);
		BOOL bReturn = (LOBYTE(VkKeyScan(pMsg->wParam)) == VK_RETURN);
		BOOL bSpace =  (LOBYTE(pMsg->wParam) == VK_SPACE);

		// Auto-toggle the checkbox(es)
		if (bSpace && (!m_pActiveElement || m_nControlColumn == COL_PRELOAD))
		{
			DoToggleCheck();
			return TRUE;
		}

		// Auto activation
		if (!m_pActiveElement && m_selection.GetCount() == 1 && !bEscape && !bReturn)
		{
			// Auto-activate the edit box in the Local Name column
			ActivateNextControl();
			ActivateNextControl();

			// The Local Name cell should now be active
			ASSERT( m_pControlWnd->IsKindOf( RUNTIME_CLASS( CEdit ) ) );
			ASSERT(m_nControlColumn == COL_LOCALNAME);
			((CEdit *)m_pControlWnd)->SetSel( 0, -1 );
	
			HWND hwndChild = m_pControlWnd->m_hWnd;
			ASSERT(hwndChild);
			if (bPreTrans)
			{
				pMsg->hwnd = hwndChild;
			}
			else
			{
				::PostMessage(hwndChild, pMsg->message, pMsg->wParam, pMsg->lParam);
			}
			// Don't use CGridControlWnd - it'll try to auto-activate
			return CGridWnd::ProcessKeyboard(pMsg, bPreTrans);
		}
		break;
	}

	return CGridControlWnd::ProcessKeyboard(pMsg, bPreTrans);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\dirsdlg.h ===
// DIRSDLG.H
// ---------
// Exports from DIRSDLG.CPP.
//
// History
// =======
// 26-Aug-93	mattg		Created

#ifndef __DIRSDLG_H__
#define __DIRSDLG_H__

#ifndef __DLGBASE_H__
#include "dlgbase.h"
#endif

#ifndef __DIRMGR_H__
#include "dirmgr.h"
#endif

#ifndef __UTILCTRL_H__
#include "utilctrl.h"
#endif

////////////////////////////////////////////////////////////
// CDirsGrid
class CDirsGrid : public CStringListGridWnd
{
// Construction
public:
	CDirsGrid();

// Attributes
public:
	class CDirsOptDlg* m_pDlg;

// Overrides
protected:
	virtual inline BOOL OnChange(int nIndex);
	virtual inline BOOL OnAddString(int nIndex);
	virtual inline BOOL OnDeleteString(int nIndex);
	virtual inline BOOL OnMove(int nSrcIndex, int nDestIndex);
};

////////////////////////////////////////////////////////////
// CDirsOptDlg

class CDirsOptDlg : public CDlgTab
{
protected:
			BOOL	m_bDeleteDirs;
				// If TRUE, delete m_Dirs at destructor time
				// (else don't).

			INT		m_nToolset;
				// Current 'toolset' selected.

			INT		m_nJavaPlatform;
				// index in platform list of "Java VM" platform (-1 if not there)

			DIRLIST_TYPE m_type;
				// Current DIRLIST_TYPE selected.

			INT		m_nCurTypeSel;
				// Current selection index (Combo item corresponding to m_type)

			CObList* (*m_pDirs)[C_DIRLIST_TYPES];
				// Copy of the arrays of dirlists in the CDirMgr
				// object.

			BOOL m_bAlreadyWarnedOfBuild;
				// Have we already warned that a build is going on.

			CDirsGrid m_DirGrid;

			POSITION PosFromListboxIndex(INT nIndex);
				// Return the POSITION within the current list
				// of the item specified by nIndex.

			VOID	SetListboxSel(INT nSel);
				// Set the selection in the listbox and enable
				// and disable buttons appropriately.

			VOID	CheckForBuildAndWarn ();
				// Warn the use if there's a build going on that changes
				// in directories won't take effect.

			VOID FillOptionsList ();
				// Sets listbox entries to corrospond to the current type and toolset

            BOOL    m_bModified;
public:
					CDirsOptDlg();
					~CDirsOptDlg();

			void	ResetListbox(BOOL bSetSelection = TRUE);
				// Sets listbox entries to correspond to the
				// current type and toolset.

	virtual	BOOL	OnInitDialog();
	virtual	void	CommitTab();
	virtual BOOL	Activate(CTabbedDialog *, CPoint);
	virtual BOOL	ValidateTab();


	BOOL OnAddDir(int nIndex);
	BOOL OnDelDir(int nIndex);
	BOOL OnMoveDir(int nSrcIndex, int nDestIndex);
	BOOL OnChangeDir(int nIndex);

	//{{AFX_MSG(CDirsOptDlg)
//	afx_msg	VOID	OnClickToolset1(); TOOLSETS DISABLED
//	afx_msg	VOID	OnClickToolset2();
//	afx_msg	VOID	OnClickToolset3();
	afx_msg void OnSelChangeDirOptions();
	afx_msg void OnSelChangeDirToolset();
	afx_msg void OnBrowse();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};


////////////////////////////////////////////////////////////
// CDirsGrid inlines
inline BOOL CDirsGrid::OnChange(int nIndex)
{
	return m_pDlg->OnChangeDir(nIndex);
}

inline BOOL CDirsGrid::OnAddString(int nIndex)
{
	return m_pDlg->OnAddDir(nIndex);
}

inline BOOL CDirsGrid::OnDeleteString(int nIndex)
{
	return m_pDlg->OnDelDir(nIndex);
}

inline BOOL CDirsGrid::OnMove(int nSrcIndex, int nDestIndex)
{
	return m_pDlg->OnMoveDir(nSrcIndex, nDestIndex);
}


#endif // __DIRSDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\dirmgr.cpp ===
// DIRMGR.CPP
// ----------
// Implementation of CDirMgr and CToolset class.
//
// History
// =======
// 28-Aug-93	mattg		Created
// 10-Jan-94	colint		Added CToolset class
//
////////////////////////////////////////////////////////////
// Include files

#include "stdafx.h"
#pragma hdrstop

#include <bldapi.h>
#include <bldguid.h>

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#define new DEBUG_NEW
#endif

////////////////////////////////////////////////////////////
// Global variables

CDirMgr		g_theDirMgr;	// The one and only CDirMgr

CDirMgr * GetDirMgr() {return &g_theDirMgr;}

////////////////////////////////////////////////////////////
// Helper routines

static VOID DestroyListContents
(
	CObList *	pList
)
{
	POSITION	pos = pList->GetHeadPosition();

	while (pos != NULL)
		delete pList->GetNext(pos);

	pList->RemoveAll();
}

////////////////////////////////////////////////////////////
// CToolset Class

////////////////////////////////////////////////////////////
// Constructors, destructors

CToolset::CToolset
(
)
{
	INT			type;

	for (type=0; type<C_DIRLIST_TYPES ; ++type)
		m_Dirs[type] = new CObList;
}


CToolset::~CToolset
(
)
{
	INT 		type;
	CObList *	pList;

	for (type=0; type<C_DIRLIST_TYPES ; ++type)
	{
		if ((pList = m_Dirs[(DIRLIST_TYPE)type]) != NULL)
		{
			DestroyListContents(pList);
			delete pList;
		}	
	}
}

////////////////////////////////////////////////////////////
// CToolset::GetDirList

CObList * CToolset::GetDirList
(
	DIRLIST_TYPE	type
)
{
	ASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES));

	return (m_Dirs[type]);
}

/////////////////////////////////////////////////////////////
// CToolset::GetDirListString

VOID CToolset::GetDirListString
(
	CString&		str,
	DIRLIST_TYPE	type
)
{
	ASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES));

	str = m_DirString[type];
}

/////////////////////////////////////////////////////////////
// CToolset::RefreshAllCachedStrings

VOID CToolset::RefreshAllCachedStrings
(
)
{
	INT type;

	for ( type = 0; type < C_DIRLIST_TYPES ; ++type )
	{
		CString &str = m_DirString[type];
		CObList *pList = m_Dirs[type];

		str.Empty();

		if ( pList != NULL )
		{
			POSITION pos = pList->GetHeadPosition();
			while ( pos != NULL )
			{
				if (!str.IsEmpty())
					str += _T(';');
				
				str += (const TCHAR *)*(CDir *)pList->GetNext(pos);
			}
		}
	}
}

////////////////////////////////////////////////////////////
// CToolset::SetDirList

VOID CToolset::SetDirList
(
	DIRLIST_TYPE	type,
	CObList *		pListNew
)
{
	ASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES));
	ASSERT(pListNew != NULL);

	if (m_Dirs[type] != NULL)
	{
		DestroyListContents(m_Dirs[type]);
		delete m_Dirs[type];
	}

	m_Dirs[type] = pListNew;
	RefreshAllCachedStrings( );
}

////////////////////////////////////////////////////////////
// CDirMgr Class

////////////////////////////////////////////////////////////
// Constructors, destructors

CDirMgr::CDirMgr
(
)
{
	m_nCurrentToolset = 0;
}

CDirMgr::~CDirMgr
(
)
{
 	POSITION		pos;
	CToolset *		pToolset;

	pos = m_Toolsets.GetHeadPosition();
	while (pos != NULL)
	{
		pToolset = (CToolset *)m_Toolsets.GetNext(pos);
		delete pToolset;
	}
	m_Toolsets.RemoveAll();
}


////////////////////////////////////////////////////////////
// CDirMgr::GetCurrentToolset
//
// This returns the current toolset for the project, if
// one exists. If we don't have a project then we will
// return whatever m_nCurrentToolset was last set to.

INT CDirMgr::GetCurrentToolset
(
)
{
	INT	nToolset = m_nCurrentToolset;

	LPBUILDSYSTEM pInterface;
	theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pInterface);
	if (pInterface != NULL)
	{
		// GetBuilderToolset only changes nToolset if valid project
		pInterface->GetBuilderToolset(&nToolset, ACTIVE_BUILDER);
		pInterface->Release();
	}

	return nToolset;
}
 
////////////////////////////////////////////////////////////
// CDirMgr::SetCurrentToolset
VOID CDirMgr::SetCurrentToolset
(
	INT		nToolset
)
{ 
	if (nToolset >= 0 && nToolset < m_Toolsets.GetCount())
		m_nCurrentToolset = nToolset; 
}

////////////////////////////////////////////////////////////
// CDirMgr::GetNumberOfToolsets

INT CDirMgr::GetNumberOfToolsets
(
)
{
	return m_Toolsets.GetCount();
}

////////////////////////////////////////////////////////////
// CDirMgr::AddToolset

INT CDirMgr::AddToolset
(
	const CString & strTargetPlatform
)
{
	INT				nToolset;
	CToolset *		pToolset;

	nToolset = m_Toolsets.GetCount();
	pToolset = new CToolset;
	m_Toolsets.AddTail(pToolset);
	m_ToolsetNames.AddTail(strTargetPlatform);

	return nToolset;
}

////////////////////////////////////////////////////////////
// CDirMgr::DeleteToolset

VOID CDirMgr::DeleteToolset
(
	INT nToolset
)
{
	POSITION 	pos;
	CToolset *	pToolset;

	if (nToolset >= 0 && nToolset < m_Toolsets.GetCount())
	{
		pos = m_Toolsets.FindIndex(nToolset);
		pToolset = (CToolset *)m_Toolsets.GetAt(pos);
		delete pToolset;
		m_Toolsets.RemoveAt(pos);
		m_ToolsetNames.RemoveAt(pos);
	}
}

////////////////////////////////////////////////////////////
// CDirMgr::GetToolset

CToolset * CDirMgr::GetToolset
(
	INT 	nToolset
)
{
	POSITION pos = m_Toolsets.FindIndex(nToolset);
	if (pos != NULL)
		return (CToolset *) (m_Toolsets.GetAt(pos));
	else
		return NULL;

}

////////////////////////////////////////////////////////////
// CDirMgr::GetDirList

const CObList * CDirMgr::GetDirList
(
	DIRLIST_TYPE	type,
	INT		nToolset	/* = -1 */
)
{
	if (nToolset == -1)
		nToolset = GetCurrentToolset();

	ASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES));
	CToolset * pToolset = GetToolset(nToolset);
	if (pToolset != NULL)
		return(pToolset->GetDirList(type));
	else
		return NULL;
}

////////////////////////////////////////////////////////////
// CDirMgr::GetDirListString

VOID CDirMgr::GetDirListString
(
	CString &		strRet,
	DIRLIST_TYPE	type,
	INT				nToolset	/* = -1 */
)
{
	if (nToolset == -1)
		nToolset = GetCurrentToolset();
	
	ASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES));
	CToolset * pToolset = GetToolset(nToolset);
	if (pToolset != NULL)
		pToolset->GetDirListString(strRet, type);
	else
		strRet.Empty();
}

////////////////////////////////////////////////////////////
// CDirMgr::CloneDirList

CObList * CDirMgr::CloneDirList
(
	DIRLIST_TYPE	type,
	INT				nToolset
)
{
	POSITION	pos;
	CObList *	pListSrc;
	CObList *	pListDst;
	CDir *		pDirSrc;
	CDir *		pDirDst;

	ASSERT((type >= (DIRLIST_TYPE)0) && (type < C_DIRLIST_TYPES));

	pListSrc = GetToolset(nToolset)->GetDirList(type);
	pListDst = new CObList;

	pos = pListSrc->GetHeadPosition();

	while (pos != NULL)
	{
		pDirSrc = (CDir *)pListSrc->GetNext(pos);
		ASSERT(pDirSrc->IsKindOf(RUNTIME_CLASS(CDir)));
		pDirDst = new CDir(*pDirSrc);

		pListDst->AddTail(pDirDst);
	}

	return(pListDst);
}

////////////////////////////////////////////////////////////
// CDirMgr::SetDirList

VOID CDirMgr::SetDirList
(
	DIRLIST_TYPE	type,
	INT				nToolset,
	CObList *		pListNew
)
{
	CObList *		pList;
 
	ASSERT(pListNew != NULL);
	pList = GetToolset(nToolset)->GetDirList(type);
		
	GetToolset(nToolset)->SetDirList(type, pListNew);
}

////////////////////////////////////////////////////////////
// CDirMgr::SetDirListFromString

VOID CDirMgr::SetDirListFromString
(
	DIRLIST_TYPE	type,
	INT				nToolset,
	const TCHAR *	sz,
	BOOL			fMustExist /* FALSE */
)
{
	TCHAR *		pchCopy;
	TCHAR *		pchDir;
	CString		str = sz;
	CObList *	pList;
	CDir *		pDir;

	pList = GetToolset(nToolset)->GetDirList(type);

	if (pList == NULL)
		pList = new CObList;
	else
		DestroyListContents(pList);

	pchCopy = str.GetBuffer(1);
	pchDir = _tcstok(pchCopy, _T(";"));

	while (pchDir != NULL)
	{
		pDir = new CDir;
		if (!pDir->CreateFromString(pchDir))
		{
			ASSERT(FALSE);
			delete pDir;
			pchDir = _tcstok(NULL, _T(";"));

			continue;
		}

		// Check that the directory is not already
		// in the list. We do not add duplicates.
		BOOL fAddDir = TRUE;

 		POSITION pos = pList->GetHeadPosition();
 		while (pos != NULL)
		{
			CDir * pTempDir = (CDir *)pList->GetNext(pos);
			if (*pTempDir == *pDir)
			{
				fAddDir = FALSE;
				break;	// found, break-out
			}
		}

		// If we are to add this and it must exist, make
		// sure it does, otherwise don't add it
		if (fMustExist && fAddDir)
			fAddDir = pDir->ExistsOnDisk();

		// If the directory is not a duplicate then add it,
		// else de-allocate
		if (fAddDir)			
		 	pList->AddTail(pDir);
		else
			delete pDir;

		pchDir = _tcstok(NULL, _T(";"));
	}

	GetToolset(nToolset)->RefreshAllCachedStrings();

	str.ReleaseBuffer();
}

////////////////////////////////////////////////////////////
// CDirMgr::GetPlatformToolset

INT	CDirMgr::GetPlatformToolset
(
	const CString & strPlatform
)
{
	POSITION	pos;
	CString		strToolsetName;
	INT			nToolset = 0;

	pos = m_ToolsetNames.GetHeadPosition();
	while (pos != NULL)
	{
		strToolsetName = m_ToolsetNames.GetNext(pos);
		if (strToolsetName == strPlatform)
			return nToolset;
		nToolset++;
	}

	return -1;
}

////////////////////////////////////////////////////////////
// CDirMgr::GetToolsetName

CString	& CDirMgr::GetToolsetName
(
	INT nToolset
)
{
	POSITION pos = m_ToolsetNames.FindIndex(nToolset);
	ASSERT (pos != NULL);
	return m_ToolsetNames.GetAt(pos);
}

BOOL IsFileThere(const CString& strDir, const CString& strFName, CString& strFullPath)
{
	ASSERT(!strFName.IsEmpty());

	const TCHAR *pch = strFName;
	if ((strFName[0] != _T('\\')) &&
	    ((strFName.GetLength() < 2) || (*_tcsinc(pch) != _T(':'))))
	{
		if (strDir.IsEmpty())
			return FALSE;

		strFullPath = strDir;

		// Add a backslash between path and fname if needed
		// chauv - crystal 1529
		// can't use CString.Right(1).Compare("\\")) since this won't work with trailing backslash char in MBCS
		// if (strFullPath.Right(1).Compare("\\"))
		if ( _tcsrchr(strFullPath, '\\') != strFullPath.Right(1) )
			strFullPath += "\\";
	}

	strFullPath += strFName;

	if (_access(strFullPath, 04) == 0)	// check for read privs
		return TRUE;

	return FALSE;
}

BOOL FindFileOnPath(const CString& strName, CString& strFullPath,
	DIRLIST_TYPE dt /*=DIRLIST_INC*/, INT nToolset /*=-1*/)
{
	ASSERT(!strName.IsEmpty());
	CString strDir;

	// Check in project directory, if any
	LPBUILDSYSTEM pBldSysIFace;
	theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR *)&pBldSysIFace);
	if (pBldSysIFace)
	{
		if (pBldSysIFace->IsActiveBuilderValid() == S_OK)
		{
			CDir dir;
			LPCSTR pszPath;
			pBldSysIFace->GetBuilderFile(ACTIVE_BUILDER, &pszPath);
			if (dir.CreateFromPath(pszPath))
			{
				strDir = dir;
				ASSERT(!strDir.IsEmpty());
				if (IsFileThere(strDir, strName, strFullPath))
				{
					pBldSysIFace->Release();
					return TRUE;
				}
			}
		}
		pBldSysIFace->Release();
	}

	// Check in all the directories on the INCLUDE path
	CDirMgr* pDirMgr = GetDirMgr();
	ASSERT(pDirMgr);

	CDir* pDir;
	const CObList* pDirList = pDirMgr->GetDirList(dt, nToolset);
	POSITION pos = pDirList->GetHeadPosition();
	while (pos)
	{
		pDir = (CDir*) pDirList->GetNext(pos);
		strDir = *pDir;
		if (IsFileThere(strDir, strName, strFullPath))
			return TRUE;
	}

	// Check in current directory
	GetCurrentDirectory(_MAX_PATH, strDir.GetBufferSetLength(_MAX_PATH));
	strDir.ReleaseBuffer();
	if (IsFileThere(strDir, strName, strFullPath))
		return TRUE;

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\engine.cpp ===
// CBuildEngine
//
// Build engine.
//
// [matthewt]
//

#include "stdafx.h"
#pragma hdrstop

#include <utilbld_.h>	// environment
#include "engine.h"		// local header
#include "scanner.h"
#include "depgraph.h"	// dependency graph	
#include "bldslob.h"
#include "vwslob.h"
#include "toolcplr.h"
#include "mrdepend.h"

#include "toollink.h"

extern BOOL bJavaSupported, bJavaOnce; // defined in vproj.cpp
extern BOOL g_bHTMLLog;

IMPLEMENT_DYNAMIC(CActionSlobList, CObList);
IMPLEMENT_DYNAMIC(CBuildEngine, CObject);
IMPLEMENT_DYNAMIC(CActionSlob, CSlob);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
//
// Class that is used to compare the base configuration of 
// a ConfigurationRecord* or CProjItem*.
//
class BaseConfiguration
{
public:
	BaseConfiguration( const ConfigurationRecord* pcr )
	{
		if ( NULL == pcr )
			m_pBaseRecord = NULL;
		else
			m_pBaseRecord = pcr->m_pBaseRecord;
	}
	BaseConfiguration( CProjItem* pItem )
	{
		if ( NULL == pItem )
			m_pBaseRecord = NULL;
		else
			m_pBaseRecord = pItem->GetActiveConfig()->m_pBaseRecord;
	}

	const ConfigurationRecord* m_pBaseRecord;
};

BOOL SameBaseConfig( BaseConfiguration a, BaseConfiguration b)
{
	//
	// return true if either is NULL since this is usually within an ASSERT.
	// NULL conditions for a ProjItem* or ConfigurationRecord* should use a
	// separate assertion.
	//
	if ( NULL == a.m_pBaseRecord || NULL == b.m_pBaseRecord )
		return TRUE;
	else
		return a.m_pBaseRecord == b.m_pBaseRecord;
}
#endif

// Try to find a tool in an action in our list
POSITION CActionSlobList::Find(CBuildTool * pTool)
{
	POSITION pos = GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		POSITION posCurr = pos;
		CActionSlob * pAction = (CActionSlob *)GetNext(pos);
		if (pTool == pAction->BuildTool())
			return posCurr;
	}

	return (POSITION)NULL;
}


#ifdef _DEBUG
void CActionSlobList::Dump(CDumpContext & dc) const
{
	// dump our actions
	int i = 0;
	dc << "Action List:\n";

	if (IsEmpty())
	{
		dc << "\tEmpty\n";
	}
	else
	{
		POSITION pos = GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CActionSlob * pAction = (CActionSlob *)GetNext(pos); 
			CBuildTool * pTool = pAction->BuildTool();

			dc << "\t";
			dc << i;
			dc << " : ";
			dc << *pTool->GetUIName();
			dc << " (";
			dc << (DWORD)pAction;
			dc << ")\n";

			i++;
		}
	}
}
#endif

BEGIN_INTERFACE_MAP(CEnumActions,CCmdTarget)
	INTERFACE_PART(CEnumActions, IID_IEnumBSActions, EnumActions )
END_INTERFACE_MAP()

BEGIN_INTERFACE_MAP(CBSAction,CCmdTarget)
	INTERFACE_PART(CBSAction, IID_IBSAction, Action )
END_INTERFACE_MAP()

// Our global build regstry map
CMapPtrToPtr g_mapBldRegistry;

typedef struct tagMEMFILE
{
	HANDLE	        hFile;
	HANDLE	        hMap;
	const TCHAR *	pcFileMap;
} MEMFILE;			  

// our instance of the build engine
CBuildEngine AFX_DATA_EXPORT g_buildengine;

// List of target references that we want to AddRefFileItem on when
// reading in a makefile. We have to defer these till we have read in
// the entire makefile, as we need to be able to get the target files
// of all targets to do this (potentially).
CPtrList g_lsttargref;

const TCHAR CActionSlob::szDefVCFile[] = _TEXT("vc60");

// our action marker
WORD CActionSlob::m_wActionMarker = 0;
BOOL CActionSlob::s_bIgnoreCachedOptions = TRUE;

CActionSlob::CActionSlob(CProjItem * pItem, CBuildTool * pTool, BOOL fBuilder, ConfigurationRecord * pcr)
	: m_frsInput(37), m_frsOutput(7), m_frsSchmoozableOutput(7)
{
	ASSERT( SameBaseConfig( pcr, pItem ) );
	// ASSERT((fBuilder) || (!pItem->IsKindOf(RUNTIME_CLASS(CProjContainer))) || (!pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))));

	// default
	m_pIncludeList = (CIncludeEntryList *)NULL;
//	m_frsScannedDep = m_frsMissingDep = m_frsSourceDep = (CFileRegSet *)NULL;
	m_fBatchNotify = m_fInGenOutput = FALSE;
	m_wMark = 0; m_dwData = 0;

	// REVIEW: unused?
	m_dwEvent = 0; m_state = _Unknown;

	pCBSAction = NULL;
	pIAction = NULL;

	// associate
	m_pItem = pItem;
	// ASSERT(!pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)));
	m_pcrOur = pcr;

	m_pTool = m_pOldTool = (CBuildTool *)NULL;
	m_fBuilder = fBuilder;
	m_pTrgAction = (CActionSlob *)NULL;
	m_frhInput = (FileRegHandle)NULL;

	// registry & dep.graph??
	if (m_fBuilder && m_pcrOur != (ConfigurationRecord *)NULL)
	{
		m_pregistry = g_buildengine.GetRegistry(m_pcrOur);
		m_pdepgraph = g_buildengine.GetDepGraph(m_pcrOur);
	}
	else
	{
		m_pregistry = &g_FileRegistry;
		m_pdepgraph = (CFileDepGraph *)NULL;
	}

	// set up our input and output to use this target registry
#ifndef REFCOUNT_WORK
	m_frsInput.SetFileRegistry(m_pregistry);
	m_frsOutput.SetFileRegistry(m_pregistry);
#else
	m_frsSchmoozableOutput.SetFileRegistry(m_pregistry);
#endif

	// FUTURE: For now we don't care about the incr. update
	// of input and output properties, eg. timestamp, exist on disk etc.

	// This was the review comment but I don't really understand these sets
	// completely and there is no way in hell I am changing anything about this
	// two days before building the release candidate. I am changing this to FUTURE
	// and we should understand this review comment and fix if neccessary for 4.1

	// REVIEW: (KPerry) As agreed by KPerry, Brick B, and Bjoyce, this is an experiment to fix
	// V6.0 bug #22343, "deletion of outputs not being tracked".
	// Unlike the person above, I do understand these guys, and know that the
	// only ones that need tracking is the depgraph sets, not this one.
	m_frsOutput.CalcAttributes(TRUE);
	m_frsInput.CalcAttributes(FALSE);
#ifdef REFCOUNT_WORK
	m_frsSchmoozableOutput.CalcAttributes(FALSE);
#endif

	// bind to our tool?
	if (pTool != (CBuildTool *)NULL)
	{
		// inform of created action then perform bind
		pTool->OnActionEvent(ACTEVT_Create, this);
		Bind(pTool);
	}

	// assume that our settings are ok, but dirty
	m_fDirtyCommand = TRUE;
	m_fPossibleOptionChange = FALSE;

	m_wMarkRefCmdOpt = 0;

	m_LastDepUpdate.dwLowDateTime = 0;
	m_LastDepUpdate.dwHighDateTime = 0;
}

CActionSlob::~CActionSlob()
{
	// clean up our source, missing and scanned deps.
	ClearSourceDep();
	ClearMissingDep();
	ClearScannedDep();


	// unbind from the tool?
	if (m_pTool != (CBuildTool *)NULL)
	{
		// remember if we had a tool
		// so we can use this info. after UnBind()
		CBuildTool * pTool = m_pTool;

		// perform unbind then inform of destroyed action
		pTool->OnActionEvent(ACTEVT_Destroy, this);
		UnBind();
	}


	// delete any objects we may have alloc'd
#ifndef REFCOUNT_WORK
	if (m_pfrsSourceDep != (CFileRegSet *)NULL)
		m_pfrsSourceDep->ReleaseFRHRef();

	if (m_pfrsMissingDep != (CFileRegSet *)NULL)
		m_pfrsMissingDep->ReleaseFRHRef();

	if (m_pfrsScannedDep != (CFileRegSet *)NULL)
		m_pfrsScannedDep->ReleaseFRHRef();
#else
#endif
}

// Binding and un-binding to tools
void CActionSlob::Bind(CBuildTool * pTool)
{
	// Set our tool
	SetToolI((CBuildTool *)pTool);

	// update our output
	if (m_fBuilder && m_pcrOur != NULL)
		OnInform(m_pItem, P_ToolOutput, 0);
}

void CActionSlob::UnBind()
{
	// disable this as we may potential change *a lot* of outputs
	// (we don't want the feedback just yet anyway, it'll mess up our
	//  dependency graph as it is being constructed)
	BOOL g_oldFileRegDisableFC = g_FileRegDisableFC;
	g_FileRegDisableFC = TRUE;

	// un-bind our source deps
	ClearSourceDep();

	// nuke our other deps
	ClearScannedDep();
	ClearMissingDep();

	// clean up our input & output file/set references
	ClearOutput();
	ClearInput();

	// set our tool					   
	SetToolI((CBuildTool *)NULL);

	// ensure that our deps are using the global registry
	// ie. detach from the current action's target registry
#ifndef REFCOUNT_WORK
	if (m_pfrsSourceDep != (CFileRegSet *)NULL)
		m_pfrsSourceDep->SetFileRegistry(&g_FileRegistry);

	if (m_pfrsMissingDep != (CFileRegSet *)NULL)
		m_pfrsMissingDep->SetFileRegistry(&g_FileRegistry);

	if (m_pfrsScannedDep != (CFileRegSet *)NULL)
		m_pfrsScannedDep->SetFileRegistry(&g_FileRegistry);
#else
#if 0 // review(tomse): Useless code?
	// File sets no longer need registry.
	if (m_pfrsSourceDep != (CFileRegSet *)NULL)
		m_pfrsSourceDep->SetFileRegistry(NULL);

	if (m_pfrsMissingDep != (CFileRegSet *)NULL)
		m_pfrsMissingDep->SetFileRegistry(NULL);

	if (m_pfrsScannedDep != (CFileRegSet *)NULL)
		m_pfrsScannedDep->SetFileRegistry(NULL);
#endif
#endif

	// re-enable
	g_FileRegDisableFC = g_oldFileRegDisableFC;
}

// Notification of input or output changing
// Rx for file change events
void CActionSlob::OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint)
{
	// interested in this?
#ifndef REFCOUNT_WORK
	if (!(idChange == FRI_ADD || idChange == FRI_DESTROY || idChange == FRI_LCL_DESTROY))
#else
	if (!(idChange == FRI_ADD || idChange == FRI_DESTROY))
#endif
		return;	// no

	// ignore due to batching?
	if (m_fBatchNotify)
		return;	// yes
												
	// convert hint into a file registry handle
	FileRegHandle frhHint = (FileRegHandle)dwHint;
									    
	// must be concerning our 'possible' input!
	ASSERT(hndFileReg == m_frhInput);

	// valid input?
	if (m_pTool->m_fTargetTool && !ValidInput(frhHint))
		return;

	// add/remove these input dependencies to/from the graph
	if (m_pdepgraph != NULL)
		VERIFY(m_pdepgraph->ModifyDep(frhHint, this, DEP_Input, idChange == FRI_ADD /* add or remove? */));

	// FUTURE(briancr, sanjays): I've fixed this bug for now with this 3
	// line hack.
	// When a .def file is added/deleted to the project, we need to tell
	// the CActionSlob for the link step that the options
	// may have changed, since adding or removing a .def file changes the linker
	// options (something no other file addition/removal does). The CActionSlob
	// caches the command line options and will only update them if told they
	// may have changed.
	// There are some questions I have with this code:
	// - Is this the correct place to make the determination that the options are dirty?
	// - Will this mark all actions as dirty when a .def file is added (I assume so)?
	// olympus: 1256 (briancr)
	// addition/removal of def file changes options
	if (_tcsicmp((frhHint->GetFilePath())->GetExtension(), _T(".def")) == 0) {
		m_fPossibleOptionChange = TRUE;
	}

	// dirty input
	m_fDirtyInput = TRUE;

	// inform item dependents of input change
	m_pItem->InformDependants(P_ItemInput);

#ifdef _DEBUG
	// show graph dbg. info?
	if (m_pTool->m_dwDebugging & DBG_BT_NOT)
	{
		const TCHAR * pchConfigName = m_pcrOur ? (const TCHAR *)m_pcrOur->GetConfigurationName() : "<Unspecified>";
		const TCHAR * pchToolName = (const TCHAR *)*m_pTool->GetName();

		TRACE("\r\nBldSys : Tool '%s', config. '%s'", pchToolName, pchConfigName);

		if (idChange == FRI_ADD)
			TRACE(" add input");

		else
			TRACE(" delete input");

		TRACE("\r\n"); m_pregistry->GetRegEntry(frhHint)->Dump(afxDump);
	}
#endif
}

// Notification of output changing
// Rx for property change events, eg. we're interested in P_ToolOutput
void CActionSlob::OnInform(CSlob * pChangedSlob, UINT idChange, DWORD dwHint)
{
	// is this the output?
	// and does it affect us?
	if (idChange == P_ToolOutput || idChange == P_ItemExcludedFromBuild)	// output?
	{
		// us?
		BOOL fUs = FALSE;

		// HACK: if this is a tool then take the hint as to which is the changed slob
		if (pChangedSlob->IsKindOf(RUNTIME_CLASS(CBuildTool)))
			pChangedSlob = (CSlob *)dwHint;

		ASSERT(pChangedSlob->IsKindOf(RUNTIME_CLASS(CProjItem)));
		ASSERT(!pChangedSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));

		// is this us, or our target (in v3 settings on project)?
		fUs = ((CProjItem *)pChangedSlob == m_pItem ||
				(CProjItem *)pChangedSlob == m_pItem->GetTarget() ||
				(CProjItem *)pChangedSlob == m_pItem->GetProject()) &&
				((CProjItem *)pChangedSlob)->GetActiveConfig()->m_pBaseRecord == m_pcrOur->m_pBaseRecord;

		if (!fUs)
			return;	// not us ... so ignore

		// it's us so refresh output
		RefreshOutputI();
	}
	// is this the command-line?
	else if (idChange == P_ToolCommand)
	{
		// force a refresh of our command-line options
		// FOR NOW ignore m_pcrOur == NULL
		if (m_pcrOur != NULL)
		{
			m_fPossibleOptionChange = TRUE;
			
			BOOL fDummy;
			(void) RefreshCommandOptions(fDummy);

			m_fPossibleOptionChange = FALSE;
		}
	}
}

void CActionSlob::AddInput()
{
	// FOR NOW ignore m_pcrOur == NULL
	if (!m_fBuilder || m_pcrOur == NULL)
		return;

	// no tool, no input to add!
	if (m_pTool == (CBuildTool *)NULL)
		return;

	// create the input set or file
	if (m_pTool->m_fTargetTool)
	{
		// 'possible' input is a file filter
		CString strFilter;
		if (m_pTool->GetStrProp(P_ToolInput, strFilter) == valid)
		{
#ifndef REFCOUNT_WORK
			if ((m_frhInput = m_pregistry->LookupFileFilter((const CString *)&strFilter)) == (FileRegHandle)NULL)
				m_frhInput = m_pregistry->RegisterFileFilter((const CString *)&strFilter);		
			else
				m_pregistry->AddRegRef(m_frhInput);
#else
			m_frhInput = m_pregistry->RegisterFileFilter((const CString *)&strFilter);		
#endif

#ifdef _DEBUG_BLD
			TRACE("\r\nFile filter <%s>:%lx in %lx", (const TCHAR *)strFilter, m_frhInput, m_pregistry);
#endif // _DEBUG_BLD
		}
	}
	else
	{	
		const CPath * pPath;
		BOOL bIsProject = (m_pItem->IsKindOf(RUNTIME_CLASS(CProject)) || (m_pItem->IsKindOf(RUNTIME_CLASS(CTargetItem))));

		// 'possible' input is the file itself
		if (bIsProject)
		{
			pPath = m_pItem->GetProject()->GetTargetFileName();
		}
		else
		{
			pPath = m_pItem->GetFilePath();
		}

		if (pPath != (const CPath *)NULL)
		{
#ifndef REFCOUNT_WORK
			if ((m_frhInput = m_pregistry->LookupFile(*pPath)) == (FileRegHandle)NULL)
				m_frhInput = m_pregistry->RegisterFile(pPath);		
			else
				m_pregistry->AddRegRef(m_frhInput);
#else
			m_frhInput = m_pregistry->RegisterFile(pPath);		
#endif

#ifdef _DEBUG_BLD
			const TCHAR * pchFile = (const TCHAR *)*m_pregistry->GetRegEntry(m_frhInput)->GetFilePath();
			TRACE("\r\nInput <%s>:%lx in %lx", pchFile, m_frhInput, m_pregistry);
#endif // _DEBUG_BLD
		}

		if (bIsProject)
		{
			delete (CPath*)pPath;
		}
	}
}

void CActionSlob::RemoveInput()
{
	// FOR NOW ignore m_pcrOur == NULL
	if (!m_fBuilder || m_pcrOur == NULL)
		return;

	// no tool or no input to remove?
	if (m_pTool == (CBuildTool *)NULL || m_frhInput == (FileRegHandle)NULL)
		return;

	// clean up our 'possible' input file/set references
#ifndef REFCOUNT_WORK
	m_pregistry->ReleaseRegRef(m_frhInput);
#else
	if (m_frhInput->IsNodeType(nodetypeRegFile))
		m_pregistry->ReleaseRegRef(m_frhInput);
	else
		m_frhInput->ReleaseFRHRef();
#endif
}

BOOL CActionSlob::ValidInput(FileRegHandle frhIn)
{
	return !m_frsOutput.RegHandleExists(frhIn);	// ok?
}

// FUTURE: remove this
void CActionSlob::SetToolI(CBuildTool * pTool)
{
	COptionHandler * popthdlr;

	if (m_pTool != (CBuildTool *)NULL)
	{
		// remove ourselves as a dependent of
		// the outputs of this tool
		popthdlr = m_pTool->GetOptionHandler();
		while (popthdlr != (COptionHandler *)NULL)
		{
			CBuildTool * pTool = popthdlr->m_pAssociatedBuildTool;
			if (pTool != (CBuildTool *)NULL)
				pTool->RemoveDependant(this);
			popthdlr = popthdlr->GetBaseOptionHandler();
		}

		// make sure we *don't* get input change events
		if (m_frhInput != (FileRegHandle)NULL)
			m_frhInput->RemoveNotifyRx(this);

		// remove the input for the old tool
 		RemoveInput();
	}
								   
	// add our input for this new tool?
	m_pOldTool = m_pTool;
	if ((m_pTool = pTool) != (CBuildTool *)NULL)
	{
		AddInput();

		// make sure we get 'possible' input and output change events
		if (m_frhInput != (FileRegHandle)NULL)
			m_frhInput->AddNotifyRx(this);

		// make ourselves a dependent on
		// the outputs of this tool
		popthdlr = m_pTool->GetOptionHandler();
		while (popthdlr != (COptionHandler *)NULL)
		{
			CBuildTool * pTool = popthdlr->m_pAssociatedBuildTool;
			if (pTool != (CBuildTool *)NULL)
				pTool->AddDependant(this);
			popthdlr = popthdlr->GetBaseOptionHandler();
		}
	}

	// input and output is dirty
	m_fDirtyInput = TRUE;
	m_fDirtyOutput = TRUE;
}


void CActionSlob::Serialize(CArchive & ar)
{
	// don't bother with base-class
	// FUTURE: if we are interested in CSlob
	// archiving we may do this.
	 
	// storing?
	if (ar.IsStoring())
	{
#if 0			// NEVER do this anymore
		// unknown tool?
		if (m_pTool->IsSupported())
		{
			ar << ((BYTE)TRUE); // yes

#if 0			// NEVER do this anymore
			// dirty command-line?
			if (!m_fDirtyCommand)
			{
				ar << ((BYTE)FALSE); // no

				// possible option change + current command-line
				ar << ((BYTE)m_fPossibleOptionChange);
				ar << m_strOptions;
			}
			else
#endif
			{
				ar << ((BYTE)TRUE); // yes
			}
		}
		else
		{
			ar << ((BYTE)FALSE); // no
		}
#endif
	}
	else
	{
		// unknown tool?
		BOOL fIsSupported = FALSE;
		ar >> ((BYTE &)fIsSupported);

		// skip can we read this?
		if (!fIsSupported)
		{
			CString strDummy;
			BOOL fDummy = FALSE;

			ar >> ((BYTE &)fDummy);
			ar >> strDummy;
		}
		else if (fIsSupported)
		{
			// dirty command-line?
			BOOL fDirtyCommand = FALSE;
						
			ar >> ((BYTE &)fDirtyCommand);

			if (!s_bIgnoreCachedOptions)
				m_fDirtyCommand = fDirtyCommand;

			if (!fDirtyCommand)
			{
				// possible option change + current command-line
				m_fCmdOptChanged = TRUE;
				BOOL fPossibleOptionChange = FALSE;
				ar >> ((BYTE &)fPossibleOptionChange);

				if (s_bIgnoreCachedOptions)
				{
					CString strDummy;
					ar >> strDummy;
				}
				else 
				{
					m_fPossibleOptionChange = fPossibleOptionChange;
					ar >> m_strOptions;
				}
			}
		}
	}
}

BOOL CActionSlob::LoadFromArchiveVCP(CArchive & ar)
{
	//return TRUE;	// do nothing, buggy still!
	
	ASSERT(!ar.IsStoring());	// sanity check

	// get the builder
	CProject * pProject = g_pActiveProject;
	ASSERT(pProject != (CProject *)NULL);

	TRY
	{
		// get our old configuration
		ConfigurationRecord * pcrOld = pProject->GetActiveConfig();
		CProject * pProjectOld = pProject;
		
		// action slob list
		CActionSlobList * pActions;
		CActionSlob * pAction;
		POSITION posAction; 

		CString strTargetName, strFileName;
		CTargetItem * pTarget;

		// read in our target names
		ar >> strTargetName;
		while (!strTargetName.IsEmpty())
		{	
			// get the target for this
			// UNDONE: this isn't valid for subprojects on conversion:
			pTarget = pProject->GetTarget(strTargetName);
			if (pTarget == (CTargetItem *)NULL)
			{
				pTarget = (CTargetItem *)g_BldSysIFace.GetFileSetFromTargetName(strTargetName, NO_BUILDER);
				if (pTarget != NULL)
				{
					pProject = pTarget->GetProject();
				}
				else
				{
					return FALSE;	// problem! <- target item not found
				}
			}

			// shouldn't have unknown project types
			CProjType * pProjType = pTarget->GetProjType();
			if (!pProjType->IsSupported())
				return FALSE;	// problem! <- unknown target found

			// get the target's file registry
			CFileRegistry * pRegistry = pTarget->GetRegistry();
			ASSERT(pRegistry != NULL);

			// set us in the right config.
			CProjTempConfigChange projTempConfigChange(pProject);
			projTempConfigChange.ChangeConfig(strTargetName);

			// read in 'project-level'
			pActions = pProject->GetActiveConfig()->GetActionList();
			WORD cActions;
			ar >> (WORD)cActions;    // number of actions to read
			posAction = pActions->GetHeadPosition();
			while (cActions && posAction != (POSITION)NULL)
			{
				pAction = (CActionSlob *)pActions->GetNext(posAction);
				// ignore unknown tool
				if (pAction && pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
					continue;
				pAction->Serialize(ar);
				cActions--;
			}

			// get the files for this
			ar >> strFileName;
			while (!strFileName.IsEmpty())
			{
				CProjItem * pItem = NULL;

				// get the file for this

				// check to see if the file is in the target
				FileRegHandle frh = pRegistry->LookupFile(strFileName);
				if (frh == NULL)
					return FALSE;	// problem! <- not in target!

				// the file is there, so now get the associated list of
				// file items for this file reg entry, and if there is
				// no list then this item is not really part of the target
				// (i.e. it is a dependency, or an intermediate target)
				CObList * oblist = g_FileRegistry.GetRegEntry(frh)->plstFileItems;
				if (oblist == NULL)
					return FALSE;	// problem! <- no file-items

				POSITION pos = oblist->GetHeadPosition();
				while (pos != NULL)
				{
					// Get the file item and its parent
					CFileItem * pFile = (CFileItem *)oblist->GetNext(pos);
					CTargetItem * pContainer = (CTargetItem *)pFile->GetContainer();

					// Is this file item in our target, if so we've found the file
					if (pContainer == pTarget)
					{
						pItem = pFile;
						break;
 					}
				}

				// found file?
				if (pItem == (CProjItem *)NULL)
					return FALSE;	// problem! <- no file-item

#if 0
				// read in 'file-level'
				pActions = pItem->GetActiveConfig()->GetActionList();
				posAction = pActions->GetHeadPosition();
				
				while (posAction != (POSITION)NULL)
				{
					pAction = (CActionSlob *)pActions->GetNext(posAction);
					pAction->Serialize(ar);
				}
#else
				// assume exactly one action (could fail if none)
				CActionSlob tempAction(NULL, NULL, FALSE, NULL);
				tempAction.Serialize(ar);
#endif

				// next file
				ar >> strFileName;
			}

			// next target
			ar >> strTargetName;
 		}

	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE; // ok
}

BOOL CActionSlob::LoadFromArchive(CArchive & ar)
{
	//return TRUE;	// do nothing, buggy still!
	
	ASSERT(!ar.IsStoring());	// sanity check

	// get the builder
	CProject * pProject = g_pActiveProject;
	ASSERT(pProject != (CProject *)NULL);

	TRY
	{
		// get our old configuration
		ConfigurationRecord * pcrOld = pProject->GetActiveConfig();
		
		// action slob list
		CActionSlobList * pActions;
		CActionSlob * pAction;
		POSITION posAction; 

		CString strTargetName, strFileName;
		CTargetItem * pTarget;

		// read in our target names
		ar >> strTargetName;
		while (!strTargetName.IsEmpty())
		{	
			// get the target for this

			HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strTargetName, ACTIVE_BUILDER);
			pProject = (CProject*)g_BldSysIFace.GetBuilder(hTarget);
			if (pProject == (CProject *)NULL)
				return FALSE;	// problem! <- target item not found
			pTarget = pProject->GetTarget(strTargetName);
			if (pTarget == (CTargetItem *)NULL)
				return FALSE;	// problem! <- target item not found

			// get the target's file registry
			CFileRegistry * pRegistry = pTarget->GetRegistry();
			ASSERT(pRegistry != NULL);

			// set us in the right config.
			CProjTempConfigChange projTempConfigChange(pProject);
			projTempConfigChange.ChangeConfig(strTargetName);

			// shouldn't have unknown project types
			CProjType * pProjType = pTarget->GetProjType();
			if (!pProjType->IsSupported())
				return FALSE;	// problem! <- unknown target found

			// read in 'project-level'
			pActions = pProject->GetActiveConfig()->GetActionList();
			WORD cActions;
			ar >> (WORD)cActions;    // number of actions to read
			posAction = pActions->GetHeadPosition();
			while (cActions && posAction != (POSITION)NULL)
			{
				pAction = (CActionSlob *)pActions->GetNext(posAction);
				// ignore unknown tool
				if (pAction && pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
					continue;
				pAction->Serialize(ar);
				cActions--;
			}

			// get the files for this
			ar >> strFileName;
			while (!strFileName.IsEmpty())
			{
#if 0
				if (strFileName.GetLength() < 2)
				{
					ASSERT(0);
					ar >> strFileName;
					continue;  // skip junk
				}
#endif

				CProjItem * pItem = NULL;

				// get the file for this

				// check to see if the file is in the target
				FileRegHandle frh = pRegistry->LookupFile(strFileName);
				if (frh == NULL)
				{
					// break;
					return FALSE;	// problem! <- not in target!
				}

				// the file is there, so now get the associated list of
				// file items for this file reg entry, and if there is
				// no list then this item is not really part of the target
				// (i.e. it is a dependency, or an intermediate target)
				CObList * oblist = g_FileRegistry.GetRegEntry(frh)->plstFileItems;
#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
				if (oblist == NULL)
					return FALSE;	// problem! <- no file-items

				POSITION pos = oblist->GetHeadPosition();
				while (pos != NULL)
				{
					// Get the file item and its parent
					CFileItem * pFile = (CFileItem *)oblist->GetNext(pos);
					CTargetItem * pContainer = pFile->GetTarget();

					// Is this file item in our target, if so we've found the file
					if (pContainer == pTarget)
					{
						pItem = pFile;
						break;
 					}
				}

				// found file?
				if (pItem == (CProjItem *)NULL)
					return FALSE;	// problem! <- no file-item

				// read in 'file-level'
				pActions = pItem->GetActiveConfig()->GetActionList();
				posAction = pActions->GetHeadPosition();
				while (posAction != (POSITION)NULL)
				{
					pAction = (CActionSlob *)pActions->GetNext(posAction);
					pAction->Serialize(ar);
				}

				// next file
				ar >> strFileName;
			}

			// next target
			ar >> strTargetName;
 		}

	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE; // ok
}

#if 0
BOOL CActionSlob::SaveToArchive(CArchive & ar)
{
	//return TRUE;	// do nothing, buggy still!

	ASSERT(ar.IsStoring());	// sanity check

	// get the builder
	CProject * pProject = g_pActiveProject;
	ASSERT(pProject != (CProject *)NULL);

	TRY
	{
		// get our old configuration
		CProjTempConfigChange projTempConfigChange(pProject);

		// action slob list
		CActionSlobList * pActions;
		CActionSlob * pAction;
		POSITION posAction; 

		CString strTargetName;
		CTargetItem * pTarget;

		CString str;

		// loop through all projects (CTargetItem) of the builder (CProject)
		pProject->InitTargetEnum();
		while (pProject->NextTargetEnum(strTargetName, pTarget))
		{
			// set us in the right config.
			projTempConfigChange.ChangeConfig(strTargetName);

			// ignore unknown project types
			CProjType * pProjType = pTarget->GetProjType();
			if (!pProjType->IsSupported())
				continue;	// don't write these out

			// write out the target name
			ar << strTargetName;


			// write out 'project-level'
			pActions = pProject->GetActiveConfig()->GetActionList();
			WORD cActions = pActions->GetCount();
			// find out actual count, ignoring unknown tool
			posAction = pActions->GetHeadPosition();
			while (posAction != (POSITION)NULL)
			{
				pAction = (CActionSlob *)pActions->GetNext(posAction);
				// ignore unknown tool
				if (pAction && pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
					cActions--;					
			}
			ar << (WORD) cActions;
			posAction = pActions->GetHeadPosition();
			
			while (posAction != (POSITION)NULL)
			{
				pAction = (CActionSlob *)pActions->GetNext(posAction);
				// ignore unknown tool
				if (pAction && pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
					continue;
				// BOOL fChanged;
				// pAction->RefreshCommandOptions(fChanged);
					pAction->Serialize(ar);
			}

			// enumerate files in this target
			CObList * plstContent;
			CObList lstContent;
			pTarget->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups));
			plstContent = &lstContent;

			POSITION pos = plstContent->GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				CProjItem * pItem = (CProjItem *)plstContent->GetNext(pos);

				// file item?
				if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
				{
					// write out the file-item name
					str = (const TCHAR *)*pItem->GetFilePath();
					ar << str;

					// write out 'file-level'
					pActions = pItem->GetActiveConfig()->GetActionList();
					posAction = pActions->GetHeadPosition();
					while (posAction != (POSITION)NULL)
					{
						pAction = (CActionSlob *)pActions->GetNext(posAction);
						// ignore unknown tool
						if ((!pAction) || (pAction->m_pTool==NULL) || (pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool))))
							continue;
						BOOL fExcluded;
						// pAction->RefreshCommandOptions(fChanged);
						if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
							pAction->Serialize(ar);
					}
				}
			}

			// empty file name is end of files marker
			str = _TEXT("");
			ar << str;
		}
		

		// empty target name is end of targets marker
		str = _TEXT("");
		ar << str;

	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE; // ok
}

#endif



void CActionSlob::BindActions
(
	CProjItem * pTheItem,
	CPtrList * plstSelectTools /* = NULL */,
	ConfigurationRecord * pcr /* = (ConfigurationRecord *)NULL */,
	BOOL fBindContained /* = TRUE */
)
{
	ASSERT(pTheItem != NULL);
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProjTempConfigChange projTempConfigChange(pTheItem->GetProject());

	if (pcr != (ConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else {
		pcr = pTheItem->GetProject()->GetActiveConfig();
	}

	// valid?
	if (pTarget == (CTargetItem *)NULL || pTarget->GetActiveConfig()->IsValid())
	{
		CProjType * pProjType = pTarget->GetProjType();

		// Buildable project type?
		BOOL fBuildableProjType = !pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeUnknown));

		// Get the target type tools list
		CPtrList * plstTools = plstSelectTools == (CPtrList *)NULL ? pProjType->GetToolsList() : plstSelectTools;

		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups));
		plstContent = &lstContent;

		POSITION posItem = fBindContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;
		while (pItem != (CProjItem *)NULL)
		{
 			// don't do this for dependency files or folders!
			if (!pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)) &&
				!pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)) &&
                !pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency))
			   )
			{
				BOOL bItemIgnoreDefaultTool = FALSE;
				BOOL bIsFileItem = (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
#ifndef REFCOUNT_WORK
				// If binding 'en masse' then make file itself part of the
				// dependency graph
				if (plstSelectTools == (CPtrList *)NULL)
				{
					// included in build?
					BOOL fExcluded;
					if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
						AddRefFileItem(pItem);
				}
				BOOL fIgnoreTool;
				bItemIgnoreDefaultTool = (pItem->GetIntProp(P_ItemIgnoreDefaultTool, fIgnoreTool) == valid && fIgnoreTool);
#else
				if (bIsFileItem)
				{
					if (NULL==plstSelectTools)
					{
						BOOL fExcluded;
						if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
						{
							ASSERT( NULL!=pcr );
							// Add to dependency graph as possible input to schmooze tool.
							CFileRegistry *preg = g_buildengine.GetRegistry(pcr);
							ASSERT(NULL!=preg);
							FileRegHandle frh = pItem->GetFileRegHandle();
							ASSERT(NULL!=frh);
							preg->AddRegRef(frh);
//							frh->ReleaseFRHRef();
						}
					}
					BOOL fIgnoreTool;
					bItemIgnoreDefaultTool = (pItem->GetIntProp(P_ItemIgnoreDefaultTool, fIgnoreTool) == valid && fIgnoreTool);
				}
#endif

				FileRegHandle frh = pItem->GetFileRegHandle();

				// Get the list of actions
				// Put these actions on the project if it's a target
				CProjItem * pItemActions = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;
				CActionSlobList * pActions = pItemActions->GetActiveConfig()->GetActionList();
				BOOL fActionsChange = FALSE;

				// Go through them and bind any tools to this item that want to be

				CActionSlob * pAction = NULL;

				CBuildTool * pTool;
				POSITION pos = plstTools->GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					pTool = (CBuildTool *)plstTools->GetNext (pos);

					// Ignore unknown tools
					if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
						continue;
					
					// skip default action if custom build tool specified
					if (bItemIgnoreDefaultTool && (!pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))))
						continue;

					// Allocate a 'building' action to to list?
					if (pTool->AttachToFile(frh, pItem))
					{
						// Do we already have an 'old' action for this tool in our list?
						POSITION pos = pActions->GetHeadPosition();
						BOOL fFound = FALSE;
						while (pos != (POSITION)NULL)
						{
							pAction = (CActionSlob *)pActions->GetNext(pos);

							if (pTool == pAction->m_pOldTool)
							{
								fFound = TRUE;
								break;
							}
						}

						// Re-bind?
						if (fFound)
						{
							// Set our config.
							ASSERT(pAction);
							pAction->m_pcrOur = pcr;
							ASSERT( pAction->m_pItem == pItemActions );
							ASSERT( SameBaseConfig( pcr, pItemActions ) );

							// Re-bind
							pAction->Bind(pTool);
						}
						// Assign!
						else
						{
							// check for multiple assignment
							ASSERT(!pActions->Find(pTool));

							pAction = new CActionSlob(pItem, pTool, fBuildableProjType, pcr);
							pActions->AddTail(pAction);
							fActionsChange = TRUE;
						}
					}
					else
						continue;	// ignore
				}

				// Delete any actions not re-bound to
				pos = pActions->GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					POSITION posAction = pos;
					pAction = (CActionSlob *)pActions->GetNext(pos);

					// Are we bound to a tool?
					if (pAction->m_pTool == (CBuildTool *)NULL)
					{
						// Remove from list and de-allocate
						pActions->RemoveAt(posAction);
						fActionsChange = TRUE;
						delete pAction;
					}
				}

				// Actions changed?
				if (fActionsChange)
				{
					// inform item dependents of output change
					pItem->InformDependants(P_ItemTools);
#ifdef _DEBUG
					if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
					{
						ASSERT(pActions->GetCount() <= 1);
					}
#endif
				}
			}

				do {
					pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
				} while (pItem == pTheItem); // don't process pTheItem twice!!
		}
	}

/* 
R.I.P. for v4.0 with VBA?
	// We've done it for our regular tools, now global custom tools...?
	if (plstSelectTools == (CPtrList *)NULL)
		CActionSlob::BindActions(pTheItem,
								   g_prjcompmgr.GetCustomToolList(),
								   (ConfigurationRecord *)NULL, fBindContained);
*/

}

void CActionSlob::UnBindActions
(
	CProjItem * pTheItem,
	CPtrList * plstSelectTools /* = NULL */,
	ConfigurationRecord * pcr /* = (ConfigurationRecord *)NULL*/,
	BOOL fUnbindContained /* TRUE */  
)
{
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProjTempConfigChange projTempConfigChange(pTheItem->GetProject());

	if (pcr != (ConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else
	{
		pcr = pTheItem->GetProject()->GetActiveConfig();
	}

	// valid?
	if (pTarget == (CTargetItem *)NULL || pTarget->GetActiveConfig()->IsValid())
	{
		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups));
		plstContent = &lstContent;

		POSITION posItem = fUnbindContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;
		while (pItem != (CProjItem *)NULL)
		{
 			// don't do this for dependency files or folders!
			if (!pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)) &&
				!pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer))
			   )
			{
#ifndef REFCOUNT_WORK
				// If unbinding 'en masse' then make file itself part of the
				// dependency graph
				if (plstSelectTools == (CPtrList *)NULL)
				{
					// included in build?
					BOOL fExcluded;
					if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
						ReleaseRefFileItem(pItem);
				}
#else
				if (NULL==plstSelectTools && pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
				{
					BOOL fExcluded;
					if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
					{
						// Remove from dependency graph as possible input to schmooze tool.
						ASSERT( NULL!=pcr );
						// Add to dependency graph as possible input to schmooze tool.
						CFileRegistry *preg = g_buildengine.GetRegistry(pcr);
						ASSERT(NULL!=preg);
						FileRegHandle frh = pItem->GetFileRegHandle();
						ASSERT(NULL!=frh);
						preg->ReleaseRegRef(frh);
//						frh->ReleaseFRHRef();
					}
				}
#endif

				FileRegHandle frh = pItem->GetFileRegHandle();

				// Get the list of actions
				// Put these actions on the project if it's a target
				CProjItem * pItemActions = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;
				CActionSlobList * pActions = pItemActions->GetActiveConfig()->GetActionList();

				// If unbinding 'en masse' then clear up our output files
				// FUTURE: remove this
				if (plstSelectTools == (CPtrList *)NULL)
					pItemActions->GetActiveConfig()->FreeOutputFiles();

				// Go through them and unbind them from the tools
				// for their owner target

				CActionSlob * pAction;

				POSITION pos = pActions->GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					pAction = (CActionSlob *)pActions->GetNext(pos);

					// Un-bind from the tool?
					if (plstSelectTools != (CPtrList *)NULL && !plstSelectTools->Find(pAction->m_pTool))
						continue;	// no, it's not in our list

					pAction->UnBind();

					// Clear our config.
					pAction->m_pcrOur = pcr;
					ASSERT( pAction->m_pItem == pItemActions );
					ASSERT( SameBaseConfig( pcr, pItemActions ) );
				}
			}
			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
 		}
	}

/*
	// We've done it for our regular tools, now global custom tools...?
	if (plstSelectTools == (CPtrList *)NULL)
		CActionSlob::UnBindActions(pTheItem,
								   g_prjcompmgr.GetCustomToolList(),
								   (ConfigurationRecord *)NULL, fUnbindContained);
*/

}
	
void CActionSlob::AssignActions
(
	CProjItem * pTheItem,
	CPtrList * plstSelectTools /* = NULL */,
	ConfigurationRecord * pcr /* = NULL */,
	BOOL fAssignContained /* = TRUE */,
	BOOL fAssignContainedOnly /* = FALSE */
)
{
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProject * pProject = pTheItem->GetProject();
	CProjTempConfigChange projTempConfigChange(pProject);
	if (pcr != (ConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else
	{
		pcr = pProject->GetActiveConfig();
	}

	// valid?
	if (pTarget->GetActiveConfig()->IsValid())
	{
		CProjType * pProjType = pTarget->GetProjType();

		// Buildable project type?
		BOOL fBuildableProjType = !pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeUnknown));

		// Get the target type tools list
		CPtrList * plstTools = (plstSelectTools == (CPtrList *)NULL) ? pProjType->GetToolsList() : plstSelectTools;

		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups | CProjItem::flt_ExcludeProjDeps));
		plstContent = &lstContent;

		POSITION posItem = fAssignContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;

		if (fAssignContainedOnly)
		{
			//
			// Skip parent item and go to first item in its contents or NULL.
			//
			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
		}

		while (pItem != (CProjItem *)NULL)
		{
 			// don't do this for dependency files or folders!
			if (!pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)) &&
				!pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)) &&
                !pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency))
 			   )
			{
				BOOL bItemIgnoreDefaultTool = FALSE;
				BOOL bIsFileItem = (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)));

#ifndef REFCOUNT_WORK
				// If assigning 'en masse' then make file itself part of the
				// dependency graph
				if (plstSelectTools == (CPtrList *)NULL)
				{
					// included in build?
					BOOL fExcluded;
					if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
					{
						AddRefFileItem(pItem);
					}

				}
				BOOL fIgnoreTool;
				bItemIgnoreDefaultTool = (pItem->GetIntProp(P_ItemIgnoreDefaultTool, fIgnoreTool) == valid && fIgnoreTool);
#else
				if (bIsFileItem)
				{
					if (NULL==plstSelectTools)
					{
						BOOL fExcluded;
						if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
						{
							ASSERT( NULL!=pcr );
							// Add to dependency graph as possible input to schmooze tool.
							CFileRegistry *preg = g_buildengine.GetRegistry(pcr);
							ASSERT(NULL!=preg);
							FileRegHandle frh = pItem->GetFileRegHandle();
							ASSERT(NULL!=frh);
							preg->AddRegRef(frh);
//							frh->ReleaseFRHRef();

						}
					}
					BOOL fIgnoreTool;
					bItemIgnoreDefaultTool = (pItem->GetIntProp(P_ItemIgnoreDefaultTool, fIgnoreTool) == valid && fIgnoreTool);
				}
#endif

				// stored on the project...even though attach to target
				FileRegHandle frh = pItem->GetFileRegHandle();

				// Get the list of actions
				// Put these actions on the project if it's a target
				// or default to the project if no target
				BOOL fTarget = pTarget == (CTargetItem *)NULL || pTarget == pItem;

				CProjItem * pItemActions = fTarget ? pItem->GetProject() : pItem;
				CActionSlobList * pActions = pItemActions->GetActiveConfig()->GetActionList();
				BOOL fActionsChange = FALSE;

				// Go through them and attach any to this item that want to be
				CBuildTool * pTool;
				POSITION pos = plstTools->GetHeadPosition();

				// 	No need to loop through tools.
				if ((NULL==frh && !fTarget) || (bIsFileItem && (pActions->GetCount() > 0)))
					pos = NULL;

				while (pos != (POSITION)NULL)
				{
					pTool = (CBuildTool *)plstTools->GetNext (pos);
					
					// Ignore unknown tools
					if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
						continue;

					// skip default action if custom build tool specified
					if (bItemIgnoreDefaultTool && (!pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))))
						continue;

					CActionSlob * pAction;
					// allocate a 'building' + 'option' action to to list?

					// We are in bad shape if the active configuration of pItem doesn't match
					// pcr->m_pBaseRecord.
					ASSERT( SameBaseConfig( pcr, pItem ) );
					if (pTool->AttachToFile(frh, pItem))
					{
						pAction = new CActionSlob(pItem, pTool, fBuildableProjType, pcr);
					}
					// allocate an 'option' action if the item is a target?
					else if (fTarget)
					{
						pAction = new CActionSlob(pItem, pTool, FALSE, pcr);
					}
					else
						continue;	// ignore

					// check for multiple assignment
					ASSERT(!pActions->Find(pTool));

					pActions->AddTail(pAction);
					fActionsChange = TRUE;

					// cannot have multiple tools per-file for v3.0
					if (!fTarget && !pItem->IsKindOf(RUNTIME_CLASS(CProject)) )
						break;
				}

				// Actions changed?
				if (fActionsChange)
				{
					// inform item dependents of output change
					pItem->InformDependants(P_ItemTools);
#ifdef _DEBUG
					if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
					{
						ASSERT(pActions->GetCount() <= 1);
					}
#endif
				}
			}

			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
		}
	}

/* 
R.I.P. for v4.0 with VBA?
	// We've done it for our regular tools, now global custom tools...?
	if (plstSelectTools == (CPtrList *)NULL)
		CActionSlob::AssignActions(pTheItem,
								   g_prjcompmgr.GetCustomToolList(),
								   (ConfigurationRecord *)NULL, fAssignContained);
*/

}

void CActionSlob::UnAssignActions
(
	CProjItem * pTheItem,
	CPtrList * plstSelectTools /* = NULL */,
	ConfigurationRecord * pcr /* = NULL */,
	BOOL fUnassignContained /* = TRUE */
)
{
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProjTempConfigChange projTempConfigChange(pTheItem->GetProject());
	if (pcr != (ConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else
	{
		pcr = pTheItem->GetProject()->GetActiveConfig();
	}

	// valid?
	if (pTarget == (CTargetItem *)NULL || pTarget->GetActiveConfig()->IsValid())
	{
		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups | CProjItem::flt_ExcludeProjDeps));
		plstContent = &lstContent;

		POSITION posItem = fUnassignContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;
		while (pItem != (CProjItem *)NULL)
		{
 			// don't do this for dependency files or folders!
			if (!pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)) &&
				!pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)) &&
				!pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency))
			   )
			{
#ifndef REFCOUNT_WORK
				// If unassigning 'en masse' then make file itself part of the
				// dependency graph
				if (plstSelectTools == (CPtrList *)NULL)
				{
					// included in build?
					BOOL fExcluded;
					if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
						ReleaseRefFileItem(pItem);
				}
#else
				if (NULL==plstSelectTools && pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
				{
					BOOL fExcluded;
					if (pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)
					{
						// Remove from dependency graph as possible input to schmooze tool.
						ASSERT( NULL!=pcr );
						// Add to dependency graph as possible input to schmooze tool.
						CFileRegistry *preg = g_buildengine.GetRegistry(pcr);
						ASSERT(NULL!=preg);
						FileRegHandle frh = pItem->GetFileRegHandle();
						ASSERT(NULL!=frh);
						if( frh!=NULL)
							preg->ReleaseRegRef(frh);
//						frh->ReleaseFRHRef();
					}
				}
#endif
				
				FileRegHandle frh = pItem->GetFileRegHandle();

				// Get the list of actions
				// Put these actions on the project if it's a target
				CProjItem * pItemActions = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;
				CActionSlobList * pActions = pItemActions->GetActiveConfig()->GetActionList();
				BOOL fActionsChange = FALSE;

				// If unassigning 'en masse' then clear up our output files
				// FUTURE: remove this
				if (plstSelectTools == (CPtrList *)NULL)
					pItemActions->GetActiveConfig()->FreeOutputFiles();

				// Go through them and detach them 

				CActionSlob * pAction;
				POSITION pos = pActions->GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					POSITION posAction = pos;
					pAction = (CActionSlob *)pActions->GetNext (pos);

					// Remove from list and de-allocate?
					if (plstSelectTools != (CPtrList *)NULL && !plstSelectTools->Find(pAction->m_pTool))
						continue;	// no, it's not in our list
					pActions->RemoveAt(posAction);
					fActionsChange = TRUE;
					delete pAction;
				}

				// Actions changed?
				if (fActionsChange)
				{
					// inform item dependents of output change
					pItem->InformDependants(P_ItemTools);
				}
			}

			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
 		}
	}

/* 
R.I.P. for v4.0 with VBA?
	// We've done it for our regular tools, now global custom tools...?
	if (plstSelectTools == (CPtrList *)NULL)
		CActionSlob::UnAssignActions(pTheItem,
									 g_prjcompmgr.GetCustomToolList(),
									 (ConfigurationRecord *)NULL, fUnassignContained);
*/

}	    

void CActionSlob::ReleaseRefFileItem(CProjItem * pItem)
{
	ConfigurationRecord * pcr = pItem->GetActiveConfig();
	CFileRegistry * pRegistry = g_buildengine.GetRegistry(pcr);

	FileRegHandle frh;

	// Only do this for "real" items
	if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
	{
		// all target files
        ConfigurationRecord * pcrProjDep = ((CProjectDependency *)pItem)->GetTargetConfig();
        if (pcrProjDep != NULL)
        {
		    CFileRegSet * preg = (CFileRegSet *)pcrProjDep->GetTargetFiles(FALSE, TRUE);

            if (preg == NULL)
                return;

    		preg->InitFrhEnum();

	    	while ((frh = preg->NextFrh()) != (FileRegHandle)NULL)
			{
				// Speed:50: To fix Oly1951, in CActionSlob::AddRefFileItem
				// we didn't add the .sbr file to the main project's file registry.
				// So we should not remove these here as we end up deleting
				// the file reg items for the .sbr's too early.

 			    const CPath * pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();

#ifndef REFCOUNT_WORK
				if (_tcsicmp(pPath->GetExtension(), ".sbr") == 0)
					continue;

		    	pRegistry->ReleaseRegRef(frh);
#else
				if (_tcsicmp(pPath->GetExtension(), ".sbr") != 0)
			    	pRegistry->ReleaseRegRef(frh);

				frh->ReleaseFRHRef();
#endif
			}

			delete preg;
        }
 	}
#ifndef REFCOUNT_WORK
	else if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
 		frh = pItem->GetFileRegHandle();
		pRegistry->ReleaseRegRef(frh);
	}
#endif //#ifndef REFCOUNT_WORK
}

void CActionSlob::AddRefFileItem(CProjItem * pItem,CPtrList *lstOutputs )
{
	// Add in a whole bunch of refs that are not needed.
	// This is to fix olympus bug #5894
 
	ConfigurationRecord * pcr = pItem->GetActiveConfig();
	CFileRegistry * pRegistry = g_buildengine.GetRegistry(pcr);

	// Only do this for "real" items
	if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
	{
		// all target files
        ConfigurationRecord * pcrProjDep = ((CProjectDependency *)pItem)->GetTargetConfig();
        if (pcrProjDep != NULL)
        {
		    CFileRegSet * preg = (CFileRegSet *)pcrProjDep->GetTargetFiles(FALSE, TRUE);
    		FileRegHandle frh;

            if (preg == NULL)
                return;

	    	preg->InitFrhEnum();
		    while ((frh = preg->NextFrh()) != (FileRegHandle)NULL)
		    {
 			    const CPath * pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();

				// Oly1951: We don't want to add a subproject's sbr files to the
				// main project's registry.  What we are really trying to accomplish
				// here is just to make sure any implibs from dll subprojects are
				// linked into the main project.
#ifndef REFCOUNT_WORK
				if (_tcsicmp(pPath->GetExtension(), ".sbr") == 0)
					continue;

			    if (pPath != NULL)
		    	{
			    	FileRegHandle frhLcl;
				    if ((frhLcl = pRegistry->LookupFile((const TCHAR *)*pPath)) == (FileRegHandle)NULL)
					    (void)pRegistry->RegisterFile(pPath, FALSE, FALSE);	// Filter the file
				    else
					    pRegistry->AddRegRef(frhLcl);
			    }
#else
				if (_tcsicmp(pPath->GetExtension(), ".sbr") != 0)
				{
				    pRegistry->AddRegRef(frh);
					if( lstOutputs )
						lstOutputs->AddHead(frh);
				}
				frh->ReleaseFRHRef();
#endif
		    }
			delete preg;
        }
 	}
#ifndef REFCOUNT_WORK
	else if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
 		const CPath * pPath = pItem->GetFilePath();
		if (pPath != NULL)
		{
			FileRegHandle frhLcl;
			if ((frhLcl = pRegistry->LookupFile((const TCHAR *)*pPath)) == (FileRegHandle)NULL)
				(void)pRegistry->RegisterFile(pPath, FALSE, FALSE);	// Filter the file
			else
				pRegistry->AddRegRef(frhLcl);
		}
	}
#endif //#ifndef REFCOUNT_WORK
 }


CActionSlob * CActionSlob::GetTargetAction()
{
	// link it to the target-level action if we need to?
	if (m_pItem->GetTarget() != m_pItem)
	{
		// Get the target-level actions
		CActionSlobList * pTrgActions = m_pItem->GetProject()->GetActiveConfig()->GetActionList();

		// search for the tools' target-level action
		POSITION pos = pTrgActions->GetHeadPosition();
		m_pTrgAction = NULL;
		while (pos != (POSITION)NULL)
		{
			CActionSlob * pTrgAction = (CActionSlob *)pTrgActions->GetNext(pos);
			if (pTrgAction->m_pTool == m_pTool)
			{
				m_pTrgAction = pTrgAction;
				break;	// got one
			}
		}
	}

	return m_pTrgAction;
}

void CActionSlob::InformActions
(
	CProjItem * pTheItem,
	UINT idChange,
	ConfigurationRecord * pcr /* = NULL */,
	BOOL fInformContained /* = TRUE */
)
{
	if (pTheItem == (CProjItem *)NULL)
		return;

	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProjTempConfigChange projTempConfigChange(pTheItem->GetProject());

	if (pcr != (ConfigurationRecord *)NULL)
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);

	// valid?
	if (pTarget == (CTargetItem *)NULL || pTarget->GetActiveConfig()->IsValid())
	{
		// Content?
		CObList * plstContent;
		CObList lstContent;
//		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies | CProjItem::flt_ExcludeProjects | CProjItem::flt_ExcludeGroups));
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal));
		plstContent = &lstContent;

		POSITION posItem = fInformContained && (plstContent != (CObList *)NULL) ? plstContent->GetHeadPosition() : (POSITION)NULL;
		
		CProjItem * pItem = pTheItem;
		while (pItem != (CProjItem *)NULL)
		{
			// Get the list of actions
			// Put these actions on the project if it's a target
			CProjItem * pItemActions = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;
			// ASSERT( pItemActions->GetActiveConfig() );
			ConfigurationRecord *pcr = pItemActions->GetActiveConfig(TRUE);
			CActionSlobList * pActions = pcr->GetActionList();

			POSITION pos = pActions->GetHeadPosition();
			while (pos != (POSITION)NULL)
				// pass onto the action
				((CActionSlob *)pActions->GetNext(pos))->OnInform(pItem, idChange, 0);

			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
 		}
	}

}

void CActionSlob::RefreshInputI()
{
	// make our inputs dirty
	m_fDirtyInput = TRUE;
	(void) GetInput();
}

void CActionSlob::RefreshOutputI()
{
	// disable this as we may potential change *a lot* of outputs
	// (we don't want the feedback just yet anyway, it'll mess up our
	//  dependency graph as it is being constructed)
	BOOL g_oldFileRegDisableFC = g_FileRegDisableFC;
	g_FileRegDisableFC = TRUE;

	// is this item being excluded from the build?
	BOOL fExcluded;
	if (m_pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded) != valid)
		fExcluded = TRUE;	// assume yes

	if (fExcluded)
	{
		// clear our source dep. on the output
		ClearSourceDep();

		// clear the actual output
		ClearOutput();
	}
	else
	{
		// make our outputs dirty
		// so that we update the output
		m_fDirtyOutput = TRUE;
		(void) GetOutput();
	}

	// inform item dependents of output change
	m_pItem->InformDependants(P_ItemOutput);

	// re-enable
	g_FileRegDisableFC = g_oldFileRegDisableFC;
}

void CActionSlob::ClearOutput()
{
	// ignore FRN_LCL_DESTROY changes to input
	// that may occur because of removal
	// of 'input->output' deps. in graph
	m_fBatchNotify = TRUE;

	int i = 0;

#ifndef REFCOUNT_WORK
	const CPtrList * plstFrh = m_frsOutput.GetContent();
	POSITION pos = plstFrh->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		FileRegHandle frh = (FileRegHandle)plstFrh->GetNext(pos);

		// re-gen'ing the output?
		if (m_fInGenOutput)
		{
			// remember the old outputs...
			m_pfrsOldOutput->AddRegHandle(frh);
			m_paryOldOutputAttrib->Add(m_aryOutputAttrib.GetAt(i++));
 		}
		else
		{
			// remove this output dependency from the graph
			// FOR NOW ignore m_pcrOur == NULL
			if (m_fBuilder && m_pcrOur != NULL)
				if (m_pdepgraph != NULL)
					VERIFY(m_pdepgraph->ModifyDep(frh, this, DEP_Output, FALSE /* remove */));
		}

		// remove the entry in the registry if we created it in ::AddOutput()
		m_pregistry->ReleaseRegRef(frh);
	}
#else
	CFileRegSet* pregset = &m_frsOutput;
	FileRegHandle frh = NULL;
	pregset->InitFrhEnum();
	frh = pregset->NextFrh();
	while (frh != NULL)
	{

		// re-gen'ing the output?
		if (m_fInGenOutput)
		{
			// remember the old outputs...
			m_pfrsOldOutput->AddRegHandle(frh);
			m_paryOldOutputAttrib->Add(m_aryOutputAttrib.GetAt(i++));
 		}
		else
		{
			// remove this output dependency from the graph
			// FOR NOW ignore m_pcrOur == NULL
			if (m_fBuilder && m_pcrOur != NULL)
				if (m_pdepgraph != NULL)
					VERIFY(m_pdepgraph->ModifyDep(frh, this, DEP_Output, FALSE /* remove */));
		}

		// remove the entry in the registry if we created it in ::AddOutput()
		ASSERT( m_frsOutput.RegHandleExists(frh) );
		m_frsOutput.RemoveRegHandle(frh);

		if (m_frsSchmoozableOutput.RegHandleExists(frh))
		{
			m_frsSchmoozableOutput.RemoveRegHandle(frh);
		}

		// Next.
		frh->ReleaseFRHRef();
		frh = pregset->NextFrh();
	}
#endif

	// empty our output contents and assoc. attributes ...
#ifndef REFCOUNT_WORK
	m_frsOutput.EmptyContent();
#else
	ASSERT(m_frsOutput.IsEmpty());
	ASSERT(m_frsSchmoozableOutput.IsEmpty());
#endif
	m_aryOutputAttrib.RemoveAll();

	// take notice of all input changes....
	m_fBatchNotify = FALSE;
}

// retrieve our scanned dependencies
CFileRegSet * CActionSlob::GetScannedDep()
{
#if 0
	if (m_frsScannedDep == (CFileRegSet *)NULL)
	{
		m_frsScannedDep = new CFileRegSet; //(53);
#ifndef REFCOUNT_WORK
		m_frsScannedDep->AddFRHRef();	// prevent this from being auto-deleted
#endif
	}
#endif

	return &m_frsScannedDep;
}

// retrieve our missing dependencies
CFileRegSet * CActionSlob::GetMissingDep(BOOL bAlloc /*= TRUE*/)
{
#if 0
	if ( (m_frsMissingDep == (CFileRegSet *)NULL) && bAlloc )
	{
		m_frsMissingDep = new CFileRegSet;
#ifndef REFCOUNT_WORK
		m_frsMissingDep->AddFRHRef();	// prevent this from being auto-deleted
#endif
	}
#endif

	return &m_frsMissingDep;
}

// retrieve our source dependencies
CFileRegSet * CActionSlob::GetSourceDep()
{
#if 0
	if (m_frsSourceDep == (CFileRegSet *)NULL)
	{
		m_frsSourceDep = new CFileRegSet;
#ifndef REFCOUNT_WORK
		m_frsSourceDep->AddFRHRef();	// prevent this from being auto-deleted
#else
		//
		// Source deps should go into registry.
		//
		if (&g_FileRegistry!=m_pregistry)
			m_frsSourceDep->SetFileRegistry(m_pregistry);
#endif
	}
#endif

	return &m_frsSourceDep;
}

void CActionSlob::ClearDepI(UINT depType)
{
	// don't allow this for non-builders..
	if (!m_fBuilder)
		return;

	CFileRegSet * pfrsDep = NULL;
	if (depType == DEP_Scanned)
		pfrsDep = &m_frsScannedDep;

	else if (depType == DEP_Missing)
		pfrsDep = &m_frsMissingDep;

	else if (depType == DEP_Source)
		pfrsDep = &m_frsSourceDep;
	
	if (pfrsDep == (CFileRegSet *)NULL)
		return;	// nothing to do!

#ifndef REFCOUNT_WORK
	const CPtrList * plstFrh = pfrsDep->GetContent();
	POSITION pos = plstFrh->GetHeadPosition();
	while (pos != (POSITION)NULL)
		VERIFY(RemoveDepI(depType, (FileRegHandle)plstFrh->GetNext(pos)));
#else
	pfrsDep->InitFrhEnum();
	FileRegHandle frh = pfrsDep->NextFrh();
	while (frh != NULL)
	{
		VERIFY(RemoveDepI(depType, frh));
		frh->ReleaseFRHRef();
		frh = pfrsDep->NextFrh();
	}
#endif

	// empty our dependency contents...
	pfrsDep->EmptyContent();
}


void CActionSlob::SubScannedDep( FileRegHandle frh )
{
	// don't allow this for non-builders..
	if (!m_fBuilder)
		return;

	// Actually we don't know whether the dep was scanned or missing
	// so check in both.

	if ( m_frsScannedDep.RegHandleExists(frh) ) {
		RemoveDepI(DEP_Scanned, frh);
		m_frsScannedDep.RemoveRegHandle(frh);
	}
	else if ( m_frsMissingDep.RegHandleExists(frh) ){
		RemoveDepI(DEP_Missing, frh);
		m_frsMissingDep.RemoveRegHandle(frh);
	}

	return;	

}

BOOL CActionSlob::AddDepI(UINT depType, CString & strFile)
{
	// don't allow this for non-builders..
	if (!m_fBuilder)
		return TRUE;

	FileRegHandle frh;

	// if we're not a target tool try to form absolute
	// relative to source
	CPath pathFile;
	if (!m_pTool->m_fTargetTool)
	{
		const CPath * pPath = m_pregistry->GetRegEntry(m_frhInput)->GetFilePath();
		CDir dirFile;
		if (dirFile.CreateFromPath(*pPath) && 
			pathFile.CreateFromDirAndFilename(dirFile, strFile))
		{
			strFile = (const TCHAR *)pathFile;
		}
		else if (!pathFile.Create(strFile))
			return FALSE;
	}
	else if (!pathFile.Create(strFile))
		return FALSE;

	CFileRegistry * pregistry = depType == DEP_Source ? m_pregistry : &g_FileRegistry;

	// do we need to register this?
#ifndef REFCOUNT_WORK
	if ((frh = pregistry->LookupFile((const TCHAR *)pathFile)) == (FileRegHandle)NULL)
	{
		frh = pregistry->RegisterFile(&pathFile);	// incr. ref
	}
	else
		pregistry->AddRegRef(frh);	// incr. ref
#else
	frh = CFileRegFile::GetFileHandle(pathFile);	// incr. ref
#endif

	if (frh == (FileRegHandle)NULL)
		return FALSE;

#ifndef REFCOUNT_WORK
	return AddDepI(depType, frh);
#else
	BOOL bResult = AddDepI(depType,frh);
	frh->ReleaseFRHRef();
	return bResult;
#endif
}

BOOL CActionSlob::RemoveDepI(UINT depType, FileRegHandle frh)
{
	// don't allow this for non-builders..
	if (!m_fBuilder)
		return TRUE;

	CFileRegistry * pregistry = depType == DEP_Source ? m_pregistry : &g_FileRegistry;

	CFileRegSet * pfrsDep = NULL;
	if (depType == DEP_Scanned)
		pfrsDep = &m_frsScannedDep;

	else if (depType == DEP_Missing)
		pfrsDep = &m_frsMissingDep;

	else if (depType == DEP_Source)
		pfrsDep = &m_frsSourceDep;

	if (pfrsDep == (CFileRegSet *)NULL)
		return TRUE;	// nothing to do!

	if (depType == DEP_Scanned || depType == DEP_Missing)
	{
		// added as a source dep.?
		if (GetSourceDep()->RegHandleExists(frh))
			if (!RemoveSourceDep(frh))	// remove as a source dep. as well!
				return FALSE;
	}
	else if (depType == DEP_Source)
	{
		if (m_pdepgraph != NULL)
			// remove this source dependency from the graph now...
			VERIFY(m_pdepgraph->ModifyDep(frh, this, DEP_Source, FALSE /* remove */));
	}

#ifndef REFCOUNT_WORK
	pfrsDep->RemoveRegHandleI(frh);
	pregistry->ReleaseRegRef(frh);
#else
	if (pfrsDep->RegHandleExists(frh))
	{
		pfrsDep->RemoveRegHandleI(frh);
#if 0
		// This is done if pfrsDep is set to m_pregistry.
		pregistry->ReleaseRegRef(frh);
#endif
	}
#endif

	return TRUE;
}

BOOL CActionSlob::AddDepI(UINT depType, FileRegHandle frh)
{
	// is this a scanned dep. that should really be a source dep.?
	CDepGrNode * pgrnDep;

	CFileRegistry * pregistry = depType == DEP_Source ? m_pregistry : &g_FileRegistry;

	CFileRegSet * pfrsDep = NULL;
	if (depType == DEP_Scanned)
		pfrsDep = GetScannedDep();

	else if (depType == DEP_Missing)
		pfrsDep = GetMissingDep();

	else if (depType == DEP_Source)
		pfrsDep = GetSourceDep();

	else
		ASSERT(0);

	// must have a dependency set by this point
	ASSERT(pfrsDep != (CFileRegSet *)NULL);

	if (depType == DEP_Scanned)
	{
		// not found on disk?
		// so add as a missing dep.
		if ((g_pActiveProject != NULL) && (!pregistry->GetRegEntry(frh)->ExistsOnDisk()))
		{
#if 0
			return AddMissingDep(frh);
#else
			//
			// Add as a missing dep by changing depType and pfrsDep
			//
			depType = DEP_Missing;
			pfrsDep = GetMissingDep();

			// must have a dependency set by this point
			ASSERT(pfrsDep != (CFileRegSet *)NULL);
#endif
		}
	}

	if (depType == DEP_Scanned || depType == DEP_Missing)
	{
		// found this dep.?
		if (m_pdepgraph != NULL)
		{
			// make it a source dep. as well?
			if (m_pdepgraph->FindDep(frh, pgrnDep) && !AddSourceDep(frh))
				return FALSE;
		}
	}

	// add this source dependencies to the graph now...
	BOOL fOldInGenOutput = m_fInGenOutput;
	m_fInGenOutput = FALSE;

	if (depType == DEP_Source)
	{
		if (m_pdepgraph != NULL)
			VERIFY(m_pdepgraph->ModifyDep(frh, this, DEP_Source, TRUE /* add */));
	}
	
	m_fInGenOutput = fOldInGenOutput;
#ifndef REFCOUNT_WORK
	return pfrsDep->AddRegHandle(frh);
#else
	if (pfrsDep->RegHandleExists(frh))
	{
		// frh is already in pfrsDep.
		return TRUE;
	}
	else
	{
#if 0
		// This is done if pfrsDep is set to m_pregistry.
		if (!pfrsDep->RegHandleExists(frh))
			pregistry->AddRegRef(frh);
#endif

		// Assume that handle is *always* added!
		return pfrsDep->AddRegHandle(frh);
	}
#endif
}

// retrieve our input(s) (may be a file set)
CFileRegSet * CActionSlob::GetInput()
{
	// dirty?
	if (m_fDirtyInput)
	{
		if ((m_frhInput == NULL) && (m_pTool!=NULL) && (m_pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))) && (m_pItem->IsKindOf(RUNTIME_CLASS(CProjContainer))))
		{
			// HACK: try adding it now
			AddInput();
		}

		if (m_frhInput != NULL)
		{
			ClearInput();

			// initialize the input

			// just return our input?
			if (!m_pTool->m_fTargetTool)
			{
				m_frsInput.AddRegHandle(m_frhInput, FALSE);		// *don't* incr. ref.
			}
			// else validate our inputs
			else
			{
				CFileRegSet * psetInput = (CFileRegSet *)m_pregistry->GetRegEntry(m_frhInput);

				FileRegHandle frh;
				psetInput->InitFrhEnum();
				while ((frh = psetInput->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
					if (ValidInput(frh))
						m_frsInput.AddRegHandle(frh, FALSE);	// *don't* incr. ref.
#else
				{
					if (ValidInput(frh))
#if 0
#pragma message( "Check for library as input" )
					{
						if (frh->IsNodeType(CFileRegNotifyRx::nodetypeRegFile))
							ASSERT( 0 != _tcsicmp(frh->GetFilePath()->GetExtension(), ".lib" ) );
						m_frsInput.AddRegHandle(frh, FALSE);	// *don't* incr. ref.
					}
#else
						m_frsInput.AddRegHandle(frh, FALSE);	// *don't* incr. ref.
#endif
					frh->ReleaseFRHRef();
				}
#endif
			}

			m_fDirtyInput = FALSE;
		}
	}

	return &m_frsInput;
}

void CActionSlob::ClearInput()
{
	// clear our input
	// (perhaps a file set containing file sets so just remove files...)
#ifndef REFCOUNT_WORK
	const CPtrList * plstFrh = m_frsInput.GetContent();;
	POSITION pos = plstFrh->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		FileRegHandle frh = (FileRegHandle)plstFrh->GetNext(pos);
		
		m_frsInput.RemoveRegHandleI(frh, FALSE);	// *don't* decr. ref.
	}
#else

#if 0
	CFileRegSet* pregset = &m_frsInput;
	pregset->InitFrhEnum();
	FileRegHandle frh = pregset->NextFrh();
	while (frh != NULL)
	{
		m_frsInput.RemoveRegHandleI(frh, FALSE);	// *don't* decr. ref.
		frh->ReleaseFRHRef();
		frh = pregset->NextFrh();
	}
#else
	m_frsInput.EmptyContent();
#endif

#endif
}

// retrieve our list of outputs (list of file registr handles)
CFileRegSet * CActionSlob::GetOutput()
{
	// return old output if we're currently re-gen'ing new output...
	if (m_fInGenOutput)
		return m_pfrsOldOutput;

	// got dirty output?
	// FOR NOW ignore m_pcrOur == NULL
	if (m_fDirtyOutput && m_fBuilder && m_pcrOur)
	{

		// set up temporary regset and array until we are done generating outputs
		CFileRegSet	frsOldOutput;
		CWordArray	aryOldOutputAttrib;
		frsOldOutput.SetFileRegistry(m_pregistry);
	    frsOldOutput.CalcAttributes(FALSE);
		m_pfrsOldOutput = &frsOldOutput;
		m_paryOldOutputAttrib = &aryOldOutputAttrib;

		// the output is no longer dirty
		m_fDirtyOutput = FALSE;

		// we're currently re-gen'ing the output
		m_fInGenOutput = TRUE;
	
		// clear and remember the old output
		ClearOutput();

	 	// re-initialise the output

 		// set the project config.
		CProjTempConfigChange projTempConfigChange(m_pItem->GetProject());
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)m_pcrOur->m_pBaseRecord);

		CActionSlobList lstActions;
		lstActions.AddTail(this);
		if( !m_pTool->GenerateOutput(AOGO_Default, lstActions, g_DummyEC) ){
			m_fInGenOutput = FALSE;
			return &m_frsOutput;
		}

		// reset the project config.
		projTempConfigChange.Release();

		if (m_fInGenOutput)
		{
			//
			// modify the graph with any differences we detect
			//

#ifndef REFCOUNT_WORK
			POSITION pos;
#else
			FileRegHandle frh = NULL;
#endif
			int i = 0;

			// additions and same
#ifndef REFCOUNT_WORK
			const CPtrList * plstFrh = m_frsOutput.GetContent();
			pos = plstFrh->GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				FileRegHandle frh = (FileRegHandle)plstFrh->GetNext(pos);
#else
			CFileRegSet* pregset = &m_frsOutput;

			CFileRegSet Additions;
			CFileRegSet Deletions;
			CWordArray	AdditionsAttrib;

			pregset->InitFrhEnum();
			frh = pregset->NextFrh();
			while (frh != NULL)
			{
#endif
				WORD attrib = m_aryOutputAttrib.GetAt(i++);
				BOOL fWithAction = !!attrib;

				// found in our old outputs?
				if (!m_pfrsOldOutput->RegHandleExists(frh))
				{
					// new dep.
					// not found, so add this output dependencies to the graph
					Additions.AddRegHandle(frh);
					AdditionsAttrib.Add(fWithAction);
				}
				else
				{
					// same dep.
					m_pfrsOldOutput->RemoveRegHandleI(frh);
				}
#ifdef REFCOUNT_WORK
				// Next.
				frh->ReleaseFRHRef();
				frh = pregset->NextFrh();
#endif
			}

			// deletions
#ifndef REFCOUNT_WORK
			plstFrh = m_pfrsOldOutput->GetContent();
			pos = plstFrh->GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				FileRegHandle frh = (FileRegHandle)plstFrh->GetNext(pos);
#else
			pregset = m_pfrsOldOutput;
			pregset->InitFrhEnum();
			frh = pregset->NextFrh();
			while (frh != NULL)
			{
#endif

				// remove this output dependency from the graph
				Deletions.AddRegHandle(frh);

#ifdef REFCOUNT_WORK
				// Next.
				frh->ReleaseFRHRef();
				frh = pregset->NextFrh();
#endif
			}
			m_pfrsOldOutput->EmptyContent();

			if (m_pdepgraph != NULL)
			{
				pregset = &Additions;
				pregset->InitFrhEnum();
				frh = pregset->NextFrh();
				int iAdd = 0;
				while (frh != NULL)
				{
					VERIFY(m_pdepgraph->ModifyDep(frh, this, DEP_Output, TRUE /* add */, AdditionsAttrib.GetAt(iAdd)));

					// Next.
					frh->ReleaseFRHRef();
					frh = pregset->NextFrh();
					iAdd++;
				}

				pregset = &Deletions;
				pregset->InitFrhEnum();
				frh = pregset->NextFrh();
				while (frh != NULL)
				{
					VERIFY(m_pdepgraph->ModifyDep(frh, this, DEP_Output, FALSE /* remove */));

					// Next.
					frh->ReleaseFRHRef();
					frh = pregset->NextFrh();
				}
			}

			m_paryOldOutputAttrib->RemoveAll();

			// no longer re-gen'ing the output
			m_fInGenOutput = FALSE;
		}
	}

	return &m_frsOutput;
}

BOOL CActionSlob::AddOutputI(FileRegHandle frh, BOOL fWithAction)
{
	BOOL fRet = FALSE;

	m_fDirtyOutput = FALSE;
#ifndef REFCOUNT_WORK
	if (m_frsOutput.AddRegHandle(frh))
	{
		// re-gen'ing the output
		if (m_fInGenOutput)
		{
			m_aryOutputAttrib.Add((WORD)fWithAction);
		}
		else
		{
			// add this output dependencies to the graph
			// FOR NOW ignore m_pcrOur == NULL
			if (m_fBuilder && m_pcrOur != NULL)
				if (m_pdepgraph != NULL)
					VERIFY(m_pdepgraph->ModifyDep(frh, this, DEP_Output, TRUE /* add */, fWithAction));
		}

		fRet = TRUE;
	}
#else
	if (!m_frsOutput.RegHandleExists(frh))
	{
		m_frsOutput.AddRegHandle(frh);
	}

	// re-gen'ing the output
	if (m_fInGenOutput)
	{
		m_aryOutputAttrib.Add((WORD)fWithAction);
	}
	else
	{
		// add this output dependencies to the graph
		// FOR NOW ignore m_pcrOur == NULL
		if (m_fBuilder && m_pcrOur != NULL)
			if (m_pdepgraph != NULL)
				VERIFY(m_pdepgraph->ModifyDep(frh, this, DEP_Output, TRUE /* add */, fWithAction));
	}

	fRet = TRUE;
#endif

	return fRet;
}

BOOL CActionSlob::AddOutput(const CPath * pPath, BOOL fWithAction /* = TRUE */, BOOL fAllowFilter /* = TRUE */)
{
	FileRegHandle frh;
	BOOL fFilter = FALSE;

	CFileRegFile * pFileReg;

	// do we need to register this?
#ifndef REFCOUNT_WORK
	if ((frh = m_pregistry->LookupFile(*pPath)) == (FileRegHandle)NULL)
	{
		frh = m_pregistry->RegisterFile(pPath);	// incr. ref, no filter
		if (frh == (FileRegHandle)NULL)
			return FALSE;

		fFilter = fAllowFilter;
		pFileReg = (CFileRegFile *)m_pregistry->GetRegEntry(frh);

		// set default output dir type
		pFileReg->SetOutDirType(m_pTool->m_fTargetTool ? 1 : 2);

	}
	else
		m_pregistry->AddRegRef(frh);	// incr. ref

	BOOL fRet = AddOutputI(frh, fWithAction);
#else
	frh = CFileRegFile::GetFileHandle(*pPath);	// incr. ref, no filter

	if (NULL==frh)
		return FALSE;

	pFileReg = (CFileRegFile *)m_pregistry->GetRegEntry(frh);

	// set default output dir type
	pFileReg->SetOutDirType(m_pTool->m_fTargetTool ? 1 : 2);

	BOOL fRet = AddOutputI(frh, fWithAction);
	frh->ReleaseFRHRef();
#endif

	// we delayed the filtering until after it was in our output
	// now filter the file it	
#ifndef REFCOUNT_WORK
	if (fRet && fFilter)
		m_pregistry->FilterFile(frh);
#else
	if (fRet && fAllowFilter && !m_frsSchmoozableOutput.RegHandleExists(frh))
	{
		m_frsSchmoozableOutput.AddRegHandle(frh);
	}
#endif

	return fRet;
}
   
BOOL CActionSlob::AddOutput
(
	UINT			nFileNameId,
	const TCHAR *	pcDefExtension,
	const CDir *	pBaseDir,
	const TCHAR *	pcDefFilename, /* = NULL */
	UINT			nEnablePropId /* = -1 */,
	BOOL			fWithAction /* = TRUE */
)
{
	ASSERT (pBaseDir);

	// First check the enabling prop
	BOOL bVal;
	if (nEnablePropId != -1 && ((m_pItem->GetIntProp(nEnablePropId, bVal) != valid) || !bVal))
		return TRUE;

	BOOL fGotFileName = FALSE;

	// Output filename? 
	CString strFileName;
  	if (m_pItem->GetStrProp(nFileNameId, strFileName) == valid && !strFileName.IsEmpty())
	{
		// Try to substitute for $(INTDIR)
		if (!m_pItem->SubstOutDirMacro(strFileName, m_pItem->GetActiveConfig()))
		{
			// Try $(OUTDIR) if $(INTDIR) doesn't work
			m_pItem->GetProject()->SubstOutDirMacro(strFileName, m_pItem->GetProject()->GetActiveConfig());
		}

		// Okay, the item has an apperently non empty-name entry.  See if its
		// a directory by checking last character.  If it is,
		int len = strFileName.GetLength();
		const TCHAR * pc = (const TCHAR *) strFileName;
		pc = _tcsdec(pc, (TCHAR *)(pc+len));
	
		// need a filename?
		if (*pc != _T('/') && *pc != _T('\\'))
			fGotFileName = TRUE;	// no ... it doesn't appear to be a dir.
	}

	// got a filename?
	if (!fGotFileName)
	{
		// no, create a default..
		if (pcDefFilename)
			strFileName += pcDefFilename;
		else
			// just append and change extension later
			strFileName += m_pItem->GetFilePath()->GetFileName();
	}

	// create a path for this filename and add it as an output
	CPath tp;
	if (tp.CreateFromDirAndFilename(*pBaseDir, strFileName))
	{
		tp.ChangeExtension (pcDefExtension);

		return AddOutput((const CPath *)&tp, fWithAction);
	}

	return FALSE;
}

void CActionSlob::DirtyAllCommands
(
	CProjItem  * pTheItem,
	BOOL fPossibleChange /* = FALSE */,
	ConfigurationRecord * pcr /* = (ConfigurationRecord *)NULL */)
{
	CTargetItem * pTarget = pTheItem->GetTarget();
	if (pTarget == (CTargetItem *)NULL)
		return;

	// Set the project config.?
	CProjTempConfigChange projTempConfigChange(pTheItem->GetProject());
	if (pcr != (ConfigurationRecord *)NULL)
	{
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
	}
	else
	{
		pcr = pTheItem->GetProject()->GetActiveConfig();
	}

	// valid?
	if (pTarget == (CTargetItem *)NULL || pTarget->GetActiveConfig()->IsValid())
	{
		// Content?
		CObList * plstContent;
		CObList lstContent;
		pTheItem->FlattenSubtree(lstContent, (CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies));
		plstContent = &lstContent;

		POSITION posItem = plstContent != (CObList *)NULL ? plstContent->GetHeadPosition() : (POSITION)NULL;

		CProjItem * pItem = pTheItem;
		while (pItem != (CProjItem *)NULL)
		{
 			// don't do this for dependency files or folders!
			if (!pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)) &&
				!pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer))
			   )
			{
				// Get the list of actions
				// Put these actions on the project if it's a target
				// or default to the project if no target
				BOOL fTarget = pTarget == (CTargetItem *)NULL || pTarget == pItem;

				CProjItem * pItemActions = fTarget ? pItem->GetProject() : pItem;
				CActionSlobList * pActions = pItemActions->GetActiveConfig()->GetActionList();
				CActionSlob * pAction;

				POSITION pos = pActions->GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					pAction = (CActionSlob *)pActions->GetNext(pos);

					// possible command change
					if (fPossibleChange)
						pAction->m_fPossibleOptionChange = TRUE;
					else 
						pAction->DirtyCommand();
					
					// cannot have multiple tools per-file for v3.0
					if (!fTarget)
					{
						ASSERT(pos == NULL);
						break;
					}
				}
			}

			do {
				pItem = (CProjItem *)(posItem != (POSITION)NULL ? plstContent->GetNext(posItem) : NULL); 
			} while (pItem == pTheItem); // don't process pTheItem twice!!
		}
	}

}

BOOL CActionSlob::RefreshCommandOptions(BOOL & fChanged, BOOL fNoSet /* = FALSE */)
{
	BOOL fRet = TRUE;

	CActionSlob * pTrgAction = GetTargetAction();

	// dirty command-line?
	if (!m_fDirtyCommand)
	{
		// if we've already done this return whether we changed
		if (m_wMarkRefCmdOpt == CActionSlob::m_wActionMarker)
		{
			// what was the status of the last refresh?
			fChanged = m_fCmdOptChanged;
			return TRUE;
		}

		// don't if there's no possible change at our level
		if (!m_fPossibleOptionChange &&
			// and at the target-level if we are a file-level action
			(pTrgAction == (CActionSlob *)NULL ||
			 (!pTrgAction->m_fPossibleOptionChange && !pTrgAction->m_fDirtyCommand))
		   )
		{
			// no change....
			fChanged = FALSE;
			return TRUE;
		}
	}

	BOOL fCheckTargetAction = FALSE;

	// Should we check target action for command options?
	// Never if we are already the target action as in the case
	// of a CCustomBuildTool.
	if (this!=pTrgAction)
	{
		// are we a file-level action with no per-file options?
		COptionHandler * popthdlr = m_pTool->GetOptionHandler();
		popthdlr->SetSlob(m_pItem);

		fCheckTargetAction = pTrgAction != (CActionSlob *)NULL && 
							   !popthdlr->HasAnyOfOurProperties(m_pItem, TRUE);

		popthdlr->ResetSlob();
	}

	if (fCheckTargetAction)
	{
		// yes, so we can get them from the target level
		fRet = pTrgAction->RefreshCommandOptions(fChanged, fNoSet);
		
		if (fRet && !fNoSet)
			fRet = pTrgAction->GetCommandOptions(m_strOptions);
	}
	else
	{
		// no, so get them from the tool
		CString strOldOptions(m_strOptions);

		CProjTempConfigChange projTempConfigChange(m_pItem->GetProject());
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)m_pcrOur->m_pBaseRecord);
		
		// just make the check and not actually set the new command-line
		if (fNoSet)
		{
			// changed?

			// dirty command-line?
			if (m_fDirtyCommand)
			{
				fChanged = FALSE;
			}
			else
			{
				CString strDummyOptions; fRet = m_pTool->GetCommandOptions(this, strDummyOptions);
				fChanged = strDummyOptions != strOldOptions;
			}
		}
		else
		{
			// changed?
			m_strOptions = ""; fRet = m_pTool->GetCommandOptions(this, m_strOptions);

			// dirty command-line?
			if (m_fDirtyCommand)
			{
				fChanged = FALSE;
				m_fDirtyCommand = FALSE;	// we've got the command-line -> not dirty!
			}
			else
			{
				fChanged = m_strOptions != strOldOptions;
			}

		}

	}

	if (!fNoSet)
		m_fPossibleOptionChange = FALSE;

	// make sure we don't attempt to retrieve it again
	m_fCmdOptChanged = fChanged;
	m_wMarkRefCmdOpt = CActionSlob::m_wActionMarker;

	return fRet;
}

BOOL CActionSlob::AddScannedDep(int type, CString & strFile, int nLine, BOOL fScan)
{
	ASSERT(m_pIncludeList != DEP_None);

	// need to allocate our include entry list?
	if (m_pIncludeList == DEP_Empty)
	{
		if ((m_pIncludeList = new CIncludeEntryList(5)) == (CIncludeEntryList *)NULL)
			return FALSE;	// failure
	}

	// is this a system include? ignore?
	// Pass project if it exists.
	if (!g_SysInclReg.IsSysInclude(strFile, NULL==Item()? NULL : Item()->GetProject() ))
	{

#ifdef _KIP_PCH_
		// START KIP HACK
		BOOL b;

		if( m_pTool->IsKindOf( RUNTIME_CLASS(CCCompilerTool) ) ){
		 	if( (m_pItem->GetIntProp( m_pTool->MapLogical(P_PchUse), b ) == valid) && b ) {
				void *tmp;
				CString strTemp = strFile;
				strTemp.MakeLower();
				CMapStringToPtr *pPchMap = m_pItem->GetTarget()->GetPchMap();
		 		if( pPchMap->Lookup( strTemp, tmp ) ) {
		 			return TRUE;
				}
			}
		} 
		// STOP KIP HACK
#endif  // _KIP_PCH_

		// construct the include entry
		CIncludeEntry * pEntry = new CIncludeEntry;
		pEntry->m_EntryType = type;	  	
		pEntry->m_nLineNumber = nLine;
		pEntry->m_bShouldBeScanned = fScan;
		pEntry->m_FileReference = strFile;

		pEntry->CheckAbsolute();	// check the absoluteness of scanned dep.

		// add this to ourselves
		m_pIncludeList->AddTail(pEntry);

#ifdef _KIP_PCH_
		// START KIP HACK
		if( m_pTool->IsKindOf( RUNTIME_CLASS(CCCompilerTool) ) ) {
		 	if( (m_pItem->GetIntProp( m_pTool->MapLogical(P_PchCreate), b ) == valid) && b ) {
				CMapStringToPtr *pPchMap = m_pItem->GetTarget()->GetPchMap();
				CString strTemp = strFile;
				strTemp.MakeLower();
				pPchMap->SetAt( strTemp, NULL );
			}
		}
		// STOP KIP HACK
#endif  // _KIP_PCH_

	}

	return TRUE; // success
}

#ifdef _DEBUG
void CActionSlob::Dump(CDumpContext & dc) const
{
	const TCHAR * pchToolName = (const TCHAR *)*m_pTool->GetName();

	// dump the tool name followed by assoc. file?
	dc << pchToolName << "\r\n";
	if (m_fBuilder)
	{
		CFileRegEntry * pregentry;
		if (m_pTool->m_fTargetTool)
			pregentry = (CFileRegEntry *)&m_frsOutput;
		else
			pregentry = m_pregistry->GetRegEntry(m_frhInput);

		pregentry->Dump(afxDump);
	}
	dc << "\r\n";
}
#endif

void CActionSlob::FillToolLBox(CListBox * pLBox, CProjItem * pItem)
{
	// where are we getting the actions from?
	CProjItem * pItemActions = pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ? pItem->GetProject() : pItem;

	// get the action list for the active config. of this item
	CActionSlobList * plstActions = pItemActions->GetActiveConfig()->GetActionList();

	// empty the listbox.
	pLBox->ResetContent();

	// fill the listbox. with the tool name for each action
	// and assoc. the CActionSlob * as ptr. data
	POSITION pos = plstActions->GetHeadPosition();
	CString strTool;
	while (pos != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)plstActions->GetNext(pos);
		ASSERT(pAction != (CActionSlob *)NULL);

		// must be 'builder' action, not 'option' action
		if (!pAction->m_fBuilder)
			continue;

		// add it to the listbox
		VERIFY(pLBox->SetItemDataPtr(pLBox->AddString((LPCTSTR)*pAction->m_pTool->GetUIName()), (void *)pAction) != CB_ERR);
	}
}

CActionSlob * CActionSlob::GetToolLBoxAction(CListBox * pLBox)
{
	int isel = pLBox->GetCurSel();
	return isel != LB_ERR ? (CActionSlob *)pLBox->GetItemDataPtr(isel) : (CActionSlob *)NULL;
}

CFileRegEntry * CActionSlob::GetFileGridEntry(CListBox * pBox)
{
	int isel = pBox->GetCurSel();
	return isel != -1 ? (CFileRegEntry *)pBox->GetItemDataPtr(isel) : (CFileRegEntry *)NULL;
}

int CActionSlob::FillFileGridI(CActionSlob * pAction, CFileRegEntry * pEntry, CListBox * pBox, int istart)
{
	// anything to do?
	if (pEntry == (CFileRegEntry *)NULL)
		return 0;

	ASSERT(pAction != (CActionSlob *)NULL);

	// set?
	if (pEntry->IsKindOf(RUNTIME_CLASS(CFileRegSet)))
	{
		// yes

		istart = pBox->GetCount();
#ifndef REFCOUNT_WORK
		CPtrList * plstFrh = (CPtrList *)((CFileRegSet *)pEntry)->GetContent();
		POSITION pos = plstFrh->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			FileRegHandle frh =	(FileRegHandle)plstFrh->GetNext(pos);
			
			// recurse
			FillFileGridI(pAction, pAction->m_pregistry->GetRegEntry(frh), pBox, istart);
		}
#else
		CFileRegSet* pregset = (CFileRegSet *)pEntry;
		pregset->InitFrhEnum();
		FileRegHandle frh = pregset->NextFrh();
		while (frh != NULL)
		{
			// recurse
			FillFileGridI(pAction, pAction->m_pregistry->GetRegEntry(frh), pBox, istart);
			frh->ReleaseFRHRef();
			frh = pregset->NextFrh();
		}
#endif
	}
	else
	{
		// no

		const CPath * pPath = pEntry->GetFilePath();
		
		// get path relative to project directory
		CString strRelativePath;

		// add it to the grid with the registry entry as item ptr. data
		const TCHAR * pch;
		if (pPath->GetRelativeName(pAction->m_pItem->GetProject()->GetWorkspaceDir(), strRelativePath))
		 	pch = (const TCHAR *)strRelativePath;
		else
		 	pch = (const TCHAR *)*pPath;

		int insert = -1;	// where do we insert this? (default = at end)
		// use insertion sort		  
		CString strList;
		int index = istart, icount = pBox->GetCount();
		while (index < icount)
		{
			// get the text
			pBox->GetText(index, strList);

			// compare, can we insert?
			if (_tcsicmp(pch, (const TCHAR *)strList) <= 0)
			{
				// yes
				insert = index;
				break;
			}
			index++;
		}
	 	VERIFY(pBox->SetItemDataPtr(pBox->InsertString(insert, (const TCHAR *)pch), (void *)pEntry));

		// might need horz scrollbars
		CClientDC dc(pBox);
		int width = dc.GetTextExtent(pch, _tcslen(pch)).cx;
		if (width > pBox->GetHorizontalExtent())
			pBox->SetHorizontalExtent(width);
	}

	return pBox->GetCount();
}

void CActionSlob::FillFileGrid(CActionSlob * pAction, CListBox * pBox, UINT depType /* = DEP_Input */)
{ 
 	// disable the grid. if no viable action
	pBox->EnableWindow(pAction != (CActionSlob *)NULL);
	 
	// empty the grid.
	pBox->ResetContent();
	pBox->SetHorizontalExtent(0);

	if (pAction != (CActionSlob *)NULL)
	{
		// input, output or dependencies?
		if (depType == DEP_Input)
		{
			(void) FillFileGridI(pAction, pAction->GetInput(), pBox, 0);
		}
		else if (depType == DEP_Output)
		{
			(void) FillFileGridI(pAction, pAction->GetOutput(), pBox, 0);
		}
		else if (depType == DEP_Dependency)
		{
			int iend = FillFileGridI(pAction, pAction->GetSourceDep(), pBox, 0);
			(void) FillFileGridI(pAction, pAction->GetScannedDep(), pBox, iend);
		}
		else
			ASSERT(FALSE);	// not supported!
	}
}

//
// Update dependency stuff for CActionSlob
//
BOOL CActionSlob::IsDepInfoInitialized()
{
	return 0 != m_LastDepUpdate.dwLowDateTime || 0 != m_LastDepUpdate.dwLowDateTime;
}


BOOL CActionSlob::IsNewDepInfoAvailable()
{
	if (NULL!=m_pItem && m_pItem->IsKindOf( RUNTIME_CLASS(CFileItem) ) )
	{
		if (NULL != m_pTool && m_pTool->HasDependencies(m_pItem->GetActiveConfig()))
		{
			//
			// Dependency information from minimal rebuild engine.
			//	See if .obj date is newer than m_LastDepUpdate.
			//
			CFileRegSet* pRegSet = GetOutput();
			ASSERT(NULL!=pRegSet);
			if (NULL!=pRegSet)
			{
				FileRegHandle frh = pRegSet->GetFirstFrh();
				if (NULL!=frh)
				{
					FILETIME ftime;

					//
					// GetTimeProp will not return correct timestamp if closing project.
					//
					ASSERT(!g_bInProjClose);
					ASSERT(0==_tcsicmp(frh->GetFilePath()->GetExtension(),_T(".obj")));

					// Refresh attributes since file change notifications are disabled.
					frh->RefreshAttributes();

					VERIFY( frh->GetTimeProp(P_NewTStamp, ftime) );
					frh->ReleaseFRHRef();

#if 0
					//
					// Log time
					//
					SYSTEMTIME systime;
					FileTimeToSystemTime(&ftime,&systime);
					TRACE("File updated:");
					TRACE("%4d-%02d-%02d %02d:%02d:%02d.%04d\n",
						systime.wYear,systime.wMonth,systime.wDay,
						systime.wHour,systime.wMinute,systime.wSecond,systime.wMilliseconds );
					FileTimeToSystemTime(&m_LastDepUpdate,&systime);
					TRACE("Dep updated:");
					TRACE("%4d-%02d-%02d %02d:%02d:%02d.%04d\n",
						systime.wYear,systime.wMonth,systime.wDay,
						systime.wHour,systime.wMinute,systime.wSecond,systime.wMilliseconds );
#endif

					return ftime > m_LastDepUpdate;
				}
			}

		}
		else
		{
			//
			// Dependency information from scanner or NCB.
			//	See dependency file set date is later than m_LastDepUpdate.
			//
			FILETIME ftime;

			//
			// GetTimeProp will not return correct timestamp if closing project.
			//
			ASSERT(!g_bInProjClose);

			// Check self
			// Note: GetFileRegHandle() doesn't ref count...yet.
			FileRegHandle frh = m_pItem->GetFileRegHandle();
			ASSERT(NULL!=frh);
			VERIFY( frh->GetTimeProp(P_NewTStamp, ftime) );
			if (ftime > m_LastDepUpdate)
				return TRUE;

			// Check sources.
			VERIFY( GetSourceDep()->GetTimeProp(P_NewTStamp, ftime) );
			if (ftime > m_LastDepUpdate)
				return TRUE;

			// Check dependencies.
			VERIFY( GetScannedDep()->GetTimeProp(P_NewTStamp, ftime) );

			return ftime > m_LastDepUpdate;
		}
	}
	return FALSE;
}

//
// Update dependency information if new information is available.
// Set bForceUpdate = TRUE to force update if updating has been turned off
// minimal rebuild info is not available.
BOOL CActionSlob::UpdateDepInfo(BOOL bForceUpdate /* = FALSE */)
{
	// Not ready for bForceUpdate yet.
	ASSERT(!bForceUpdate);

	//
	// Don't update if new information is not availabe.
	//
	if ( !bForceUpdate && !IsNewDepInfoAvailable())
		return FALSE;

	if (NULL!=m_pItem && m_pItem->IsKindOf( RUNTIME_CLASS(CFileItem) ) )
	{
		if (m_pItem->ScanDependencies())
		{
			return TRUE;
		}
		else
		{
			return FALSE;
		}
	}
	return FALSE;
}

void CActionSlob::UpdateDepInfoTimeStamp()
{
	GetSystemTimeAsFileTime(&m_LastDepUpdate);
}

BEGIN_MESSAGE_MAP(CFileGridPage, CProjPage)
	//{{AFX_MSG_MAP(CFileGridPage)
	//}}AFX_MSG_MAP
	ON_LBN_SELCHANGE(IDC_TOOLS, OnToolsSelChange)
	ON_LBN_SELCHANGE(IDC_TOOL_FILES, OnFileGridSelChange)
END_MESSAGE_MAP()

CFileGridPage::CFileGridPage(UINT depType /* = DEP_Input */)
{
	m_depType = depType;
}

BOOL CFileGridPage::OnInitDialog()
{ 
	// call base-class first
	if (!CProjPage::OnInitDialog())
		return FALSE;

	return TRUE;
}

void CFileGridPage::InitPage()
{
	// call base-class
	CProjPage::InitPage();

	// setup our help id
	if (m_depType == DEP_Input)
		m_nIDHelp = IDDP_TOOL_INPUTS;

	else if (m_depType == DEP_Output)
		m_nIDHelp = IDDP_TOOL_OUTPUTS;

	else if (m_depType == DEP_Dependency)
		m_nIDHelp = IDDP_TOOL_DEPENDENCIES;

	// update our tools list
	OnPropChange(P_ItemTools);
}

BOOL CFileGridPage::OnPropChange(UINT nProp)
{
	// can we handle this?
	switch (nProp)
	{
		case P_ItemTools:
		{
			// fill listbox with our list of tools for this item
			CListBox * pLBox = (CListBox *)GetDlgItem(IDC_TOOLS);

			CProjItem * pItem;
			CBuildSlob * pBuildSlob = NULL;
			if (m_pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
				pBuildSlob = (CBuildSlob *)m_pSlob;
			if (m_pSlob->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)))
				pBuildSlob = ((CBuildViewSlob *)m_pSlob)->GetBuildSlob();

			if (pBuildSlob)
				pItem = pBuildSlob->GetProjItem();				
 			else
				pItem = (CProjItem *)m_pSlob;

			// Set the correct active config on the item
			if (pBuildSlob)
				pBuildSlob->FixupItem();

			CActionSlob::FillToolLBox(pLBox, pItem);

			// Reset the original active config for the item
			if (pBuildSlob)
				pBuildSlob->UnFixupItem();

			// set tools selection to first
			pLBox->SetCurSel(0);	
			OnToolsSelChange();

			// set grid selection to first
			CListBox * plboxFiles = (CListBox *)GetDlgItem(IDC_TOOL_FILES);
			plboxFiles->SetCurSel(0);
			OnFileGridSelChange();
			break;
		}

		case P_ItemInput:
		case P_ItemOutput:
		case P_ItemDependency:
		{
			// only update if interested
			if ((nProp == P_ItemInput && m_depType == DEP_Input) ||
				(nProp == P_ItemOutput && m_depType == DEP_Output) ||
				(nProp == P_ItemDependency && m_depType == DEP_Dependency)
			   )
			{
				// show outputs for the current action
				CListBox * plboxTools = (CListBox *)GetDlgItem(IDC_TOOLS);
				CListBox * plboxFiles = (CListBox *)GetDlgItem(IDC_TOOL_FILES);
				CActionSlob::FillFileGrid(CActionSlob::GetToolLBoxAction(plboxTools), plboxFiles, m_depType);
			}
			break;
		}

		default:
			// no, pass on to base-class
			return CProjPage::OnPropChange(nProp);
	}

	return TRUE;
}

void CFileGridPage::OnToolsSelChange()
{
	// update our settings/outputs
	if (m_depType == DEP_Input)
		OnPropChange(P_ItemInput);

	else if (m_depType == DEP_Output)
		OnPropChange(P_ItemOutput);

	else if (m_depType == DEP_Dependency)
		OnPropChange(P_ItemDependency);
}

void CFileGridPage::OnFileGridSelChange()
{
	// update our timestamp view
	CString strTimeStamp;
	CListBox * plboxFiles = (CListBox *)GetDlgItem(IDC_TOOL_FILES);
	CFileRegEntry * pEntry = CActionSlob::GetFileGridEntry(plboxFiles);
	if (pEntry != (CFileRegEntry *)NULL)
	{
		if (!pEntry->GetFileTime(strTimeStamp))
		{
			UINT idStr = 0;
			if (m_depType == DEP_Input)
				idStr = IDS_NO_TOOL_INPUT;

			else if (m_depType == DEP_Output)
				idStr = IDS_NO_TOOL_OUTPUT;

			else if (m_depType == DEP_Dependency)
				idStr = IDS_NO_TOOL_DEP;

			ASSERT(idStr);
			VERIFY(strTimeStamp.LoadString(idStr));
		}
	}


	// set the static text
	GetDlgItem(IDC_FILE_DATE)->SetWindowText(strTimeStamp);
}

CInputsPage g_InputsPage;
BEGIN_IDE_CONTROL_MAP(CInputsPage, IDDP_TOOL_FILES, IDS_INPUTS)
END_IDE_CONTROL_MAP()

COutputsPage g_OutputsPage;
BEGIN_IDE_CONTROL_MAP(COutputsPage, IDDP_TOOL_FILES, IDS_OUTPUTS)
END_IDE_CONTROL_MAP()

CDepsPage g_DepsPage;
BEGIN_IDE_CONTROL_MAP(CDepsPage, IDDP_TOOL_FILES, IDS_DEPENDENCIES)
END_IDE_CONTROL_MAP()

// our 
static TCHAR szRegKey[]		= _TEXT("Build System");

CBuildEngine::CBuildEngine()
{
#ifdef _DEBUG
	DWORD dwDbg = 0;

	// construct our registry key
	CString strKeyName(::GetRegistryKeyName());
	strKeyName += _TEXT("\\");
	strKeyName += szRegKey;

	HKEY hKey;
	// load the '\\Debugging' key
	if (RegOpenKeyEx(HKEY_CURRENT_USER, strKeyName, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType, dwValueSize = sizeof(DWORD);
		if (RegQueryValueEx(hKey, _TEXT("Debugging"), NULL, &dwType, (LPBYTE)&dwDbg, &dwValueSize) == ERROR_SUCCESS)
		{
		  	// make sure we get the value we expect
			ASSERT(dwType == REG_DWORD);
			ASSERT(dwValueSize == sizeof(DWORD));
		}

		RegCloseKey(hKey); // close the key we just opened
	} 

#endif

#ifdef _DEBUG
	m_dwDebugging = dwDbg;
#else // _DEBUG
	m_dwDebugging = 0;	// off
#endif // !_DEBUG

	// batching is off by default
	m_fBatchCmdLines = FALSE;

	// create our output window error context
	m_pECOutputWin = new COutputWinEC();
}

CBuildEngine::~CBuildEngine()
{
	ASSERT(m_MemFiles.IsEmpty());
	//ASSERT(m_mapBldInst.IsEmpty());         //??? add an extra HadBuildState call
	// ASSERT(m_slCmds.GetCount() == 0);

	// delete our output window error context
	delete m_pECOutputWin;
}

CMD CBuildEngine::FlushCmdLines()
{
	CMD cmd = CMD_Complete;

	// execute our currently batched commands
	cmd = ExecuteCmdLinesI
			(
				m_plCmds,
				m_dirLast,
				m_fLastCheckForComSpec, m_fLastIgnoreErrors,
				*m_pECLast
			);

	// flush
	m_plCmds.RemoveAll();

	return cmd;
}

void CBuildEngine::ClearCmdLines()
{
    // Clear out any batched cmds - important if we stop
    // a build in the middle.
    m_plCmds.RemoveAll();
}

CMD CBuildEngine::BatchCmdLines(BOOL fBatch /* = TRUE */)
{	
	CMD cmd = CMD_Complete;

	if (m_fBatchCmdLines != fBatch)
	{
		// set-it
		m_fBatchCmdLines = fBatch;

		// turning off batching?
		if (!fBatch)
			cmd = FlushCmdLines();
	}

	return cmd;
}

CMD CBuildEngine::ExecuteCmdLines
(
	CPtrList & plCmds,
	CDir & dir,
	BOOL fCheckForComSpec, BOOL fIgnoreErrors,
	CErrorContext & EC
)
{
	CMD cmd = CMD_Complete;

	// batching?
	if (m_fBatchCmdLines)
	{
		//
		// batching 
		//
		BOOL fRememberContext = FALSE;

		// need to flush current if context changhed?
		if (m_plCmds.GetCount() > 0)
		{
			if (dir != m_dirLast ||
				fCheckForComSpec != m_fLastCheckForComSpec ||
				fIgnoreErrors != m_fLastIgnoreErrors ||
				&EC != m_pECLast
			   )
			{
				// flush our currently batched commands
				cmd = FlushCmdLines();

				// remember this new context
				fRememberContext = TRUE;
			}
		}
		else
		{
			// initialise the context
			fRememberContext = TRUE;
		}

		// remember the last context?
		if (fRememberContext)
		{
			m_dirLast = dir;
			m_fLastCheckForComSpec = fCheckForComSpec;
			m_fLastIgnoreErrors = fIgnoreErrors;
			m_pECLast = &EC;
		}

		// perform batch
		m_plCmds.AddTail(&plCmds);

		// done
	}
	else
	{
		// 
		// perform build commands
		//
		cmd = ExecuteCmdLinesI(plCmds,dir, fCheckForComSpec, fIgnoreErrors, EC);
	}

	// Make sure cmd is set to a valid value.
	ASSERT(cmd == CMD_Canceled || cmd == CMD_Complete || cmd == CMD_Error);

	return cmd;
}

CMD CBuildEngine::ExecuteCmdLinesI
(
	CPtrList & plCmds,
	CDir & dir,
	BOOL fCheckForComSpec,
	BOOL fIgnoreErrors,
	CErrorContext & EC
)
{
	// perform the command
	int ret = g_Spawner.DoSpawn(plCmds, dir, fCheckForComSpec, fIgnoreErrors, EC);

	// The return value we've got now is  actually an int error code returned 
	// by NTSPAWN.  Translate it to one of our CMD_ values.
	if (ret != 0) 
	{
		if ( CMD_Canceled == (UINT)ret )
			return CMD_Canceled;
		else
			return CMD_Error;
	}

	return CMD_Complete;
}

void CBuildEngine::LogBuildError(UINT idError, void * pvContext, CErrorContext & EC)
{
	CString strError;
	BOOL fLogAsError = FALSE;

	// construct the error
	switch (idError)
	{
		case BldError_CantGetCmdLines:
			::MsgText(strError, idError, (const TCHAR *)*((CBuildTool *)pvContext)->GetName());
			fLogAsError = TRUE;
			break;

		case BldError_ScanError:
			::MsgText(strError, IDS_SCAN_ERROR, (const TCHAR *)*(CPath *)pvContext);
			break;
	}

	// display the error
	if (&EC == &g_DummyEC)
	{
		if (theApp.m_bInvokedCommandLine)
		{
			theApp.WriteLog(strError, TRUE);
		}
		else
		{
			g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strError, TRUE, TRUE);
			g_VPROJIdeInterface.GetOutputWindow()->ShowOutputWindow();
		}
	}
	else
		EC.AddString(strError);

	// log this as an error?
	if (fLogAsError)
		g_Spawner.m_dwProjError++;
}

BOOL CBuildEngine::OpenMemFile
(
	FileRegHandle frh,
	HANDLE & hMap,
	const TCHAR * & pcFileMap,
	DWORD & dwFileSize, CErrorContext & EC
)
{
	BOOL fRet = FALSE;	// success?
	HANDLE hFile;

	// pointer to memory mapped file (== (const TCHAR *)NULL if not available)
	pcFileMap = (const TCHAR *)NULL;	// default

	const CPath * pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();

	for	(;;)
	{
		hMap = NULL;
		pcFileMap = NULL;
		hFile = CreateFile(
				(LPCSTR) *pPath,
				GENERIC_READ,
				FILE_SHARE_READ,
				NULL,
				OPEN_EXISTING,
				FILE_ATTRIBUTE_NORMAL,
				NULL);
		if (hFile == INVALID_HANDLE_VALUE)
			break;	// failure

		DWORD dwFileSize2;
		dwFileSize = GetFileSize(hFile, &dwFileSize2);			

		if (dwFileSize == 0xffffffff)
			break;	// failure

		if (dwFileSize == 0)
		{
			CloseHandle(hFile);
			return TRUE;	// ignore
		}

		hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);

		if (hMap == NULL)
			break;	// failure

		pcFileMap = (const TCHAR *) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);

		break;			// break-out
	}

	if (pcFileMap == (const TCHAR *)NULL)
	{
	  	TCHAR errstring [256];
		DWORD dw = GetLastError();

		if (hMap != NULL)
			CloseHandle(hMap);

		if (hFile != INVALID_HANDLE_VALUE)
			CloseHandle (hFile);
				
		//	Try to get a text message for the error.  This fails if NT
		//	doesn't have its error resource:
		errstring[0] = 0;
	 	FormatMessage(
					  FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
					  0,		// ignored
					  dw,
					  LOCALE_USER_DEFAULT,
					  errstring,
					  256,
					  0		// ignored
					 );

		RemoveNewlines(errstring);

		CString strError;
		::MsgText(strError, IDS_OPEN_FOR_SCAN_FAILED, (const TCHAR *) *pPath, (const TCHAR *) errstring);
		/* 
		   // ignore this error for now, since we got file save notification on different thread, 
		   // we can get cases like this, we will let the scan dep to do scan again instead of output error.
		if (&EC == &g_DummyEC)
		{
			if (theApp.m_bInvokedCommandLine)
			{
				theApp.WriteLog(strError, TRUE);
			}
			else
			{
				g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strError, TRUE, TRUE);
				g_VPROJIdeInterface.GetOutputWindow()->ShowOutputWindow();
			}
		}
		else
			EC.AddString(strError);
		*/
	}
	else
	{
		fRet = TRUE;	// success
		MEMFILE * pMemFile = new MEMFILE;
		pMemFile->hFile = hFile;
		pMemFile->hMap = hMap;
		pMemFile->pcFileMap = pcFileMap;

		m_MemFiles.AddTail(pMemFile);
	}

	return fRet;
}

BOOL CBuildEngine::CloseMemFile(HANDLE & hMap, CErrorContext & EC)
{
	// Look for a memory mapped file entry in our list which has
	// the same mapping object handle
    MEMFILE * pMemFile; POSITION posCurr;
	POSITION pos = m_MemFiles.GetHeadPosition();
	while (pos != NULL)
	{
        posCurr = pos;
		pMemFile = (MEMFILE *) m_MemFiles.GetNext(pos);
		if (pMemFile->hMap == hMap)
		{
			// close this memory mapped file
			UnmapViewOfFile((LPVOID) pMemFile->pcFileMap);
			CloseHandle(pMemFile->hMap);
			CloseHandle(pMemFile->hFile);

            // Remove the MEMFILE entry from our list
            delete pMemFile;
            m_MemFiles.RemoveAt(posCurr);

			return TRUE;
		}		
	}

	// We failed to close the requested file	
	return FALSE;
}

BOOL CBuildEngine::DeleteFile(FileRegHandle frh, CErrorContext & EC)
{
	BOOL fRet = TRUE;	// default is success

	if (!g_FileRegistry.DeleteFile(frh))
	{
		DWORD dw;

		dw = GetLastError();
		if (dw !=  ERROR_FILE_NOT_FOUND && dw != ERROR_PATH_NOT_FOUND)
		{
			TCHAR buf[256]; buf[0] = _T('\0');

			// we get NO_ERROR sometimes!
			if (dw != NO_ERROR)
			{
				// place a ': ' between 'cannot delete' and system messages
				buf[0] = _T(':'); buf[1] = _T(' ');

				FormatMessage(
							  FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
							  0,		// ignored
							  dw,
							  LOCALE_USER_DEFAULT,
							  buf + 2,
							  (sizeof(buf) / sizeof(TCHAR)) - 2,
							  0		// ignored
						   	 );
				RemoveNewlines(buf);
			}

			CString strError;
			::MsgText(
					  strError,
				 	  IDS_PROJ_COULD_NOT_DELETE_FILE,
					  (const TCHAR *) *g_FileRegistry.GetRegEntry(frh)->GetFilePath(),
 					  buf
					 );

			if (&EC == &g_DummyEC)
			{
				if (theApp.m_bInvokedCommandLine)
				{
					theApp.WriteLog(strError, TRUE);
				}
				else
				{
					g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(strError, TRUE, TRUE);
					g_VPROJIdeInterface.GetOutputWindow()->ShowOutputWindow();
				}
			}
			else
			{
				EC.AddString(strError);
			}

			fRet = FALSE;	// failure
		}
	}

	return fRet;
}

#define MAX_CMD_LEN 256
// REVIEW: #define MAX_CMD_LEN 127

BOOL CBuildEngine::FormCmdLine(CString & strToolExeName, CString & strCmdLine, CErrorContext & EC, BOOL fRspFileOk)
{
	// is this line too long?
	if (strCmdLine.GetLength() + strToolExeName.GetLength() + 2 > MAX_CMD_LEN - 1)
	{
		CPath pathRsp;
		if (!fRspFileOk || !TmpMaker.CreateTempFileFromString(strCmdLine, pathRsp, EC)) 
			return FALSE;

		// quote response file path if necessary
		CString strRspPath = pathRsp;
		if (pathRsp.ContainsSpecialCharacters())
			strRspPath = _T('\"') + strRspPath + _T('\"');

		// use response file
		strCmdLine = (strToolExeName + _TEXT(" @")) + strRspPath;
	}
	else
	{
		// don't use response file

		// replace '\r\n\t' with spaces
		int cchLen = strCmdLine.GetLength();
		TCHAR * pch = (TCHAR *)(const TCHAR *)strCmdLine;
		for (int ich = 0; ich < cchLen;)
		{
			TCHAR ch = pch[ich];
			if (ch == _T('\r') || ch == _T('\n') || ch == _T('\t'))
				pch[ich] = _T(' ');

			ich += _tclen(pch + ich);
		}

		strCmdLine = (strToolExeName + _T(' ')) + strCmdLine;
	}
//	strCmdLine.AnsiToOem();  // BruceMa 10-15-97
	#ifdef PROJ_LOG
	CString strCommand;
	strCommand.LoadString(IDS_CREATING_COMMANDLINE); 
	PBUILD_TRACE ((const TCHAR *)strCommand, (const TCHAR *)strCmdLine );
	#endif

	return TRUE;	// success
}

BOOL CBuildEngine::FormBatchFile( CString & strCmdLine, CErrorContext & EC)
{
	// is this line too long?
	CPath pathRsp;

	strCmdLine.AnsiToOem();

	if ( !TmpMaker.CreateTempFileFromString(strCmdLine, pathRsp, EC, TRUE ) )
		return FALSE;

	// use response file
	strCmdLine = pathRsp;

	// quote path if necessary
	if (pathRsp.ContainsSpecialCharacters())
		strCmdLine = _T('\"') + strCmdLine + _T('\"');

	#ifdef PROJ_LOG
	CString strCommand;
	strCommand.LoadString(IDS_CREATING_COMMANDLINE); 
	PBUILD_TRACE((const TCHAR *)strCommand,(const TCHAR *)	strCmdLine );
	#endif

	return TRUE;	// success
}

CFileRegistry * CBuildEngine::GetRegistry(ConfigurationRecord * pcr)
{
	// get a build instance for the currently active config.
	SBldInst * pbldinst;

	// if one doesn't exist, create one on demand
	if (!m_mapBldInst.Lookup((void *)pcr->m_pBaseRecord, (void *&)pbldinst))
		pbldinst = AddBuildInst(pcr);

	return pbldinst->s_preg;
}

CFileDepGraph * CBuildEngine::GetDepGraph(ConfigurationRecord * pcr)
{
	// get a build instance for the currently active config.
	SBldInst * pbldinst;

	// if one doesn't exist, create one on demand
	if (!m_mapBldInst.Lookup((void *)pcr->m_pBaseRecord, (void *&)pbldinst))
		pbldinst =  AddBuildInst(pcr);

	return pbldinst->s_pgraph;
}

void CBuildEngine::SetGraphMode(UINT mode, CProject * pBuilder)
{
	const CPtrArray * pCfgArray = pBuilder->GetConfigArray();
	int isize = pCfgArray->GetSize();
	for (int i = 0; i < isize; i++)
		GetDepGraph((ConfigurationRecord *)pCfgArray->GetAt(i))->SetGraphMode(mode);
}

CBuildEngine::SBldInst * CBuildEngine::AddBuildInst(ConfigurationRecord * pcr)
{
	SBldInst * pbldinst;

	if (m_mapBldInst.Lookup((void *)pcr->m_pBaseRecord, (void *&)pbldinst))
		return pbldinst;	// already got one!

	// add a build instance for the currently active config.

	// allocate
	pbldinst = new SBldInst;
	pbldinst->s_preg = new CFileRegistry;
	pbldinst->s_pgraph = new CFileDepGraph(pbldinst->s_preg);

#ifndef REFCOUNT_WORK
	// allow global registry access to this
  	g_FileRegistry.AllowAccess(pbldinst->s_preg);
#endif

	// set in our lookup map
	m_mapBldInst.SetAt((void *)pcr->m_pBaseRecord, (void *)pbldinst);

	return pbldinst;
}

void CBuildEngine::RemoveBuildInst(ConfigurationRecord * pcr)
{
	// remove a build instance for the currently active config.
	SBldInst * pbldinst;
	VERIFY(m_mapBldInst.Lookup((void *)pcr->m_pBaseRecord, (void *&)pbldinst));

#ifndef REFCOUNT_WORK
	// dis-allow global registry access to this
	g_FileRegistry.DisallowAccess(pbldinst->s_preg);
#endif

	// de-allocate
	delete pbldinst->s_pgraph;
	delete pbldinst->s_preg;
	delete pbldinst;

	// remove from our lookup map
	m_mapBldInst.RemoveKey((void *)pcr->m_pBaseRecord);
}

BOOL CBuildEngine::HasBuildState
(
	ConfigurationRecord * pcrBuild,
	CPtrList & lstFrh,														  
	UINT statefilter /* = DS_OutOfDate */,
	FileRegHandle frhStart /* = (FileRegHandle)NULL*/
)
{
	// get our build dependency graph for this config.
	CFileDepGraph * pdepgraph = GetDepGraph(pcrBuild);

	// use a different action marker than the last time we did a build
	CActionSlob::m_wActionMarker++;

	// make sure we have the v.latest dep. graph state
	// so flush any possible file change notifications
	FileChangeDeQ();

	//and possible dep update
	// FileItemDepUpdateDeQ();

	// If this is a java project, then set frhStart to NULL to visit all nodes in the depgraph.
    if (!bJavaOnce)
	{
		bJavaOnce=TRUE;
		bJavaSupported = IsPackageLoaded(PACKAGE_LANGJVA);
	}
	if (bJavaSupported)
	{
		CString strFlavor, strName = pcrBuild->GetConfigurationName();

		VERIFY(g_BldSysIFace.GetFlavourFromConfigName(strName, strFlavor));

		int nSep = strName.Find (_T (" - "));
	    strName = strName.Mid(nSep);
		if (strName == " - Java Virtual Machine " + strFlavor)
            frhStart = NULL;
    }

	//
	// retrieve our actions
	//
	CActionSlobList lstActions;
	UINT aor = AOR_Recurse | AOR_ChkOpts | AOR_PreChk | AOR_ChkInp;
	UINT cmdRetRA = pdepgraph->RetrieveBuildActions(lstActions, lstFrh, g_DummyEC, frhStart, statefilter, aor);
	if (cmdRetRA != CMD_Complete)
	{
		// cannot retrive actions because of error or user cancel
		lstActions.RemoveAll();
		return TRUE;
	}

	return !lstActions.IsEmpty();
}

CMD CBuildEngine::DoBuild
(
	ConfigurationRecord * pcrBuild,																  
 	CErrorContext & EC,
	FileRegHandle frhStart /* = (FileRegHandle)NULL*/,
	DWORD aob /* = AOB_Default */,
	UINT type /* = TOB_Build */,
	BOOL fRecurse /* = TRUE */,
	BOOL fVerbose /* = TRUE */
)
{
	// get our build dependency graph and registry for this config.
	CFileDepGraph * pdepgraph = GetDepGraph(pcrBuild);
	CFileRegistry * pregistry = GetRegistry(pcrBuild);

	BOOL bPreLinkDone = FALSE;
	BOOL bPostBuildDone = FALSE;

	// environment of the build
	CEnvironmentVariableList bldenviron;

	// get the environment from the directories manager
	g_pActiveProject->GetEnvironmentVariables(&bldenviron);
	bldenviron.SetVariables();				// set it

	// what dependencies do we want to build?
	UINT stateFilter = DS_OutOfDate | DS_ForcedOutOfDate;

	/// if we're re-building or forcing a build then build 'everything'
	if (type == TOB_Clean || type == TOB_ReBuild || (aob & AOB_Forced))
		stateFilter |= (DS_Current | DS_DepMissing);

	// return value of the build
	// default is 'complete', assuming finish build passes without 'cancel' or 'error'
 	CMD cmdRet = CMD_Complete;

	// start the passes
	pdepgraph->StartPasses();

//
// perform the build passes
//

// pass number
WORD wPass = 0;

	//
	// retry these actions
	//
	CActionSlobList lstReTryActions;

	// Actions attempted in TOB_Stage.
	CActionSlobList lstStagedActions;


	CString strCommandLines;
	if( g_bHTMLLog )
	    strCommandLines.LoadString(IDS_HTML_COMMANDLINE);
	else
	    strCommandLines.LoadString(IDS_NORMAL_COMMANDLINE);
	    
	// LogTrace("<h3>Command Lines</h3>\n");
	LogTrace(strCommandLines);
PerformBuildPass:

	bPreLinkDone = FALSE;

	// increment our pass number
	wPass++;

	// state filter should get everything on a rebuild all.
	// so there is no need to lookup file changes or Deps.

	if (! (type == TOB_Clean || (aob & AOB_Forced)) ) {
		// make sure we have the v.latest dep. graph state
		// so flush any possible file change notifications
		FileChangeDeQ();
	
		//and possible dep update
		FileItemDepUpdateDeQAll();
	}

	//
	// retrieve our actions (prepend with our retry actions)
	//
	CActionSlobList lstActions;
	lstActions.AddTail(&lstReTryActions);
	lstReTryActions.RemoveAll();

	UINT aor = fRecurse ? AOR_Recurse : AOR_None;

	// check option changes and input changes on first pass
	if (wPass == 1)	aor |= (AOR_ChkOpts | AOR_ChkInp);

	// verbose?
	if (fVerbose)	aor |= AOR_Verbose;

	CPtrList lstFrh;
	UINT cNonDeferred = 0;
	

	CFileRegFile::AllowRetryFailedWatches(TRUE);

	UINT cmdRetRA = pdepgraph->RetrieveBuildActions(lstActions, lstFrh, EC, frhStart, stateFilter, aor);
	if (cmdRetRA != CMD_Complete)
	{
		// cannot retrive actions because of error or user cancel
		cmdRet = cmdRetRA;
		goto EndBuildPass;
	}

#ifdef _DEBUG
	// dump our actions before processing
	lstActions.Dump(afxDump);
#endif // _DEBUG

	//
	// post-process our actions
	//
	{
		// post-process stage 1.

		POSITION posSentinel = (POSITION)NULL;
		POSITION pos = lstActions.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			// get the next action and remember its position
			POSITION posOld = pos;
			CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(pos);
			
			if (posSentinel == posOld)
				break;	// we're done
			
			// o shove all deferred tools to the end
			if (pAction->m_pTool->m_fDeferredTool)
			{
				// remove in preparation for a replace
				lstActions.RemoveAt(posOld);

				DAB dab = pAction->m_pTool->DeferredAction(pAction);
				if (dab == dabDeferred || dab == dabNeverBuild)
				{
					// don't use this one, don't replace
					continue;
				}

				ASSERT (dab == dabNotDeferred);

				// replace at end
				POSITION posTmp = lstActions.AddTail(pAction);

				if (posSentinel == (POSITION)NULL)
					posSentinel = posTmp;
			}
			else
			{
				cNonDeferred++;	// no
			}
		} 

		// post-process stage 2.

		// don't do deferred tools until no-more non-deferred tools
		// and in this case move them to the re-try list from the current
		if (cNonDeferred != 0)
		{
			while (posSentinel != (POSITION)NULL)
			{
				POSITION posOld = posSentinel;
				// move to re-try
				lstReTryActions.AddTail(lstActions.GetNext(posSentinel));

				// remove from current
				lstActions.RemoveAt(posOld);
			}
		}

#if 0
		// post-process stage 3.
		POSITION schmoozePos = NULL;

		// pack together items with the same tool
		pos = lstActions.GetTailPosition();
		while (pos != (POSITION)NULL)
		{
			CBuildTool * pTool = ((CActionSlob *)lstActions.GetPrev(pos))->BuildTool();

			// last one
			if (pos == (POSITION)NULL)
				continue;

			// already packed?
			CBuildTool * pToolPrev = ((CActionSlob *)lstActions.GetAt(pos))->BuildTool();
			if (pToolPrev == pTool)
				continue;

			// don't re-order these custom-build steps
			if ( pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)) ){
					continue;
			}

			if ( pTool->IsKindOf(RUNTIME_CLASS(CSpecialBuildTool)) ){
					continue;
			}

			// after we have found the schmooze tool all custom-build steps
			// can be pushed to the front
			if (pTool->IsKindOf(RUNTIME_CLASS(CSchmoozeTool))){
				schmoozePos = pos;
			}
			

			POSITION posTest = pos;
			while (posTest != (POSITION)NULL)
			{
				POSITION posCurr = posTest;
				CActionSlob * pAction = (CActionSlob *)lstActions.GetPrev(posTest);

				if (pAction->BuildTool() == pTool && posCurr != pos)
				{
					lstActions.RemoveAt(posCurr);
					if ( pTool->IsKindOf(RUNTIME_CLASS(CCCompilerTool)) && schmoozePos )
						lstActions.InsertBefore(schmoozePos, pAction);
					else
						lstActions.InsertAfter(pos, pAction);
				}
			}
		}
#else	
		// put all actions in their positional buckets
		#define MAX_TOOL_BUCKET 7
		CObList bucket[MAX_TOOL_BUCKET];
		pos = lstActions.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CActionSlob *pAction = (CActionSlob *)lstActions.GetNext(pos);
			CBuildTool * pTool = pAction->BuildTool();
			CProjItem *pItem =pAction->Item();
			if( pItem->IsKindOf(RUNTIME_CLASS(CProject)) || pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)) ){
				bucket[1].AddTail(pAction);
			} else {
				bucket[pTool->GetOrder()].AddTail(pAction);
			}
		}
		// now clear the original list and join all the seperate lists together.
		lstActions.RemoveAll();
		for( int i=(MAX_TOOL_BUCKET-1); i>=0; i-- ){
			lstActions.AddTail( &(bucket[i]) );
		}
#endif
	}
	
#ifdef _DEBUG
	// dump our actions after processing
	lstActions.Dump(afxDump);
#endif // _DEBUG
		

	// anything still to do?
	if (lstActions.IsEmpty())
		goto EndBuildPass;

	//
	// perform the actions for each of our stages
	//
	{
		// TOB_Pre -> TOB_Stage -> TOB_Post
		UINT lastStage;
		if( type == TOB_Clean )
			lastStage = TOB_Pre;
		else
			lastStage = TOB_Post;

		for (UINT stage = TOB_Pre; stage <= lastStage; stage++)
		{
			// batch?
			if (stage == TOB_Stage)
			{
				// don't batch the defered ones
				if (cNonDeferred != 0)
					VERIFY(BatchCmdLines() == CMD_Complete);
			}

			CActionSlobList lstToolActions;
			POSITION pos = lstActions.GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				// collect together our actions for the same tool
				CBuildTool * pTool = (CBuildTool *)NULL;
				while (pos != (POSITION)NULL)
				{
					POSITION posOld = pos;
					CActionSlob * pAction = (CActionSlob *)lstActions.GetNext(pos);

					// o can we do this action now if errors encountered?
					if (cmdRet == CMD_Error && !pAction->m_pTool->m_fPerformIfAble)
						// no, so ignore
						continue;

					if (pTool == (CBuildTool *)NULL || pAction->m_pTool == pTool)
					{
						if (pTool == (CBuildTool *)NULL)
						{
							// init. our state
							lstToolActions.RemoveAll();
							pTool = pAction->m_pTool;
						}

						// add this to the tool's list of actions
						lstToolActions.AddTail(pAction);
					}
					else
					{
						// backtrack and breakout
						pos = posOld;
						break;
					}
				}

				// any tool to perform for this stage?
				if (pTool == (CBuildTool *)NULL)
					continue;

				if (TOB_Stage==stage && !bPreLinkDone && pTool->IsKindOf(RUNTIME_CLASS(CLinkerTool)))
				{
					cmdRet = DoSpecialCommandLines( pcrBuild->m_pOwner, TRUE, aob, EC );
					if ( CMD_Complete != cmdRet )
						goto EndBuildPass;

					bPreLinkDone =  TRUE;
				}

				// perform the stage of this build
				UINT actRet = pTool->PerformBuildActions(type, stage, lstToolActions, aob, EC);

				// Add lstToolActions to lstStagedActions.
				if (TOB_Stage==stage)
				{
					lstStagedActions.AddTail(&lstToolActions);
				}

				if (TOB_Stage==stage && ACT_Complete==actRet && !bPostBuildDone && NULL==pos && NULL==frhStart)
				{
					bPostBuildDone =  TRUE;
				}

				switch (actRet)
				{
					case ACT_Canceled:
						cmdRet = CMD_Canceled;
						// cancel whole build
						goto EndBuildPass;
						break;

					case ACT_Error:
						cmdRet = CMD_Error;
						// continue with the build passes in case any tools
						// can still 'Perform If Able' regardless of errors
						break;

					case ACT_Complete:
						// cmdRet = CMD_Complete;	// Don't set if already had an error
						break;

					default:
						ASSERT(FALSE);
						break;
				}
			}

			// flush batch?
			if (stage == TOB_Stage)
			{
				CString strOutputWindow;
				if( g_bHTMLLog )
					strOutputWindow.LoadString(IDS_HTML_OUTPUTWINDOW);
				else
					strOutputWindow.LoadString(IDS_NORMAL_OUTPUTWINDOW);
				LogTrace(strOutputWindow);
				if (cmdRet == CMD_Complete)
				{
			 		cmdRet = BatchCmdLines(FALSE);
				}
				else
				{
					// clear any still batched but not flushed cmd lines now
					ClearCmdLines();
				}
	
				if (cmdRet == CMD_Canceled)
				{
					// cancel whole build
					goto EndBuildPass;
				}
			}
		}
	}

	// now just do a build, as the first pass set us up for a rebuild
	stateFilter = DS_OutOfDate;

	goto PerformBuildPass;

//
// End the build passes
//
EndBuildPass:

	if (cmdRet == CMD_Complete && bPostBuildDone)
	{
		cmdRet = DoSpecialCommandLines( pcrBuild->m_pOwner, FALSE, aob, EC );
	}

	// Update dependencies
	if (g_bNewUpdateDepModel && !lstStagedActions.IsEmpty())
	{
		// Update files.
		FileChangeDeQ();

		IMreDependencies* pMreDepend = NULL;
		BOOL fRefreshDepCtr = FALSE;
		CActionSlob* pFirstAction = (CActionSlob*)lstStagedActions.GetHead();
		CProject * pOurProject = pFirstAction->m_pItem->GetProject();
		CPath pathIdb = pOurProject->GetMrePath(pFirstAction->m_pcrOur);
		if (!pathIdb.IsEmpty())
		{
			// Minimal rebuild dependency interface.
			pMreDepend = 
				IMreDependencies::GetMreDependenciesIFace((LPCTSTR)pathIdb);
		}

		// Update dependencies.
		// Set up a new cache for this target			
		g_ScannerCache.BeginCache();


		POSITION posCurrentAction = lstStagedActions.GetHeadPosition();

		while (NULL!=posCurrentAction)
		{
			CActionSlob* pCurrentAction = (CActionSlob*)lstStagedActions.GetNext(posCurrentAction);

			ASSERT(NULL!=pCurrentAction);

			fRefreshDepCtr = pCurrentAction->UpdateDepInfo() || fRefreshDepCtr;
			fRefreshDepCtr = TRUE;	// Always.
		}

		g_ScannerCache.EndCache();
		if (NULL!=pMreDepend)
			pMreDepend->Release();

		
// FAST_EXPORT
		const CPtrArray * pCfgArray = pOurProject->GetConfigArray();
		int i, isize = pCfgArray->GetSize();
		for (i = 0; i < isize; i++)
		{
			if (pcrBuild->m_pBaseRecord == (ConfigurationRecord *)pCfgArray->GetAt(i))
			{
				pOurProject->m_nScannedConfigIndex = i;
				break;
			}
		}
// FAST_EXPORT

		// Refresh dependency folder.
		if (NULL!=pFirstAction->m_pItem && fRefreshDepCtr)
			pFirstAction->m_pItem->GetTarget()->RefreshDependencyContainer();
	}

	// clear any still batched but not flushed cmd lines now
	ClearCmdLines();

	// nuke any temporary files created as a part of this build
	NukeTempFiles(EC);

	bldenviron.ResetVariables ();	// may do nothing

	// Force any failed file watches to be re-tried (we might have created the files
	// during the build).
	CFileRegFile::AllowRetryFailedWatches(TRUE);

	return cmdRet;
}

STDMETHODIMP_(ULONG) CBSAction::XAction::AddRef(){
	METHOD_PROLOGUE_EX(CBSAction, Action);
	return pThis->ExternalAddRef();
};

STDMETHODIMP_(ULONG) CBSAction::XAction::Release(){
	METHOD_PROLOGUE_EX(CBSAction, Action);
	return pThis->ExternalRelease();
};

STDMETHODIMP CBSAction::XAction::QueryInterface(REFIID iid, LPVOID far * ppvObj){
	METHOD_PROLOGUE_EX(CBSAction, Action);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
};


STDMETHODIMP CBSAction::XAction::GetInputs(LPBUILDFILESET *ppFileSet){
	METHOD_PROLOGUE_EX(CBSAction, Action);

	if( pThis->pAction ) {
		*ppFileSet = pThis->pAction->GetInput();
		return NOERROR;
	} else {
		*ppFileSet = NULL;
		return E_UNEXPECTED;
	}

};

STDMETHODIMP CBSAction::XAction::GetOutputs(LPBUILDFILESET *ppFileSet){
	METHOD_PROLOGUE_EX(CBSAction, Action);

	if( pThis->pAction ) {
		*ppFileSet = pThis->pAction->GetOutput();
		return NOERROR;
	} else {
		*ppFileSet = NULL;
		return E_UNEXPECTED;
	}

};

STDMETHODIMP CBSAction::XAction::GetCommandOptions(CString *pOptions){
	METHOD_PROLOGUE_EX(CBSAction, Action);

	if( pThis->pAction ) {
		CString strOptions;
		pThis->pAction->GetCommandOptions(strOptions);
		*pOptions = strOptions;
		return NOERROR;
	} else {
		return E_UNEXPECTED;
	}

};
STDMETHODIMP CBSAction::XAction::GetTool(LPBUILDTOOL *ppTool ){
	METHOD_PROLOGUE_EX(CBSAction, Action);

	if( pThis->pAction ){
		// get the IBuildTool from the real tool
		CBuildTool *pTool = pThis->pAction->BuildTool();
		*ppTool = pTool->GetToolInterface();
		return NOERROR;
	} else {
		*ppTool = NULL;
		return E_UNEXPECTED;
	}

};

STDMETHODIMP CBSAction::XAction::GetFile(LPBUILDFILE *ppFile){
	METHOD_PROLOGUE_EX(CBSAction, Action);
	if( pThis->pAction ){
		// *ppFile = pThis->pAction->GetFile();
		// FileRegHandle frh = pItem->GetFileRegHandle();
		return NOERROR;
	} else {
		*ppFile = NULL;
		return E_UNEXPECTED;
	}
};

STDMETHODIMP CBSAction::XAction::GetConfiguration(HCONFIGURATION *hCfg){
	METHOD_PROLOGUE_EX(CBSAction, Action);
	if( pThis->pAction ){
		// *hCfg = pThis->pAction->GetConfig();
		*hCfg = NULL;
		return NOERROR;
	} else {
		*hCfg = NULL;
		return E_UNEXPECTED;
	}
};

STDMETHODIMP CBSAction::XAction::AddOutput(const CPath *pPath){
	METHOD_PROLOGUE_EX(CBSAction, Action);

	if( pThis->pAction ){
		pThis->pAction->AddOutput( pPath );
		return NOERROR;
	} else {
		return E_UNEXPECTED;
	}
};


////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CEnumActions::XEnumActions::AddRef(){
	METHOD_PROLOGUE_EX(CEnumActions, EnumActions);
	return pThis->ExternalAddRef();
};

STDMETHODIMP_(ULONG) CEnumActions::XEnumActions::Release(){
	METHOD_PROLOGUE_EX(CEnumActions, EnumActions);
	return pThis->ExternalRelease();
};

STDMETHODIMP CEnumActions::XEnumActions::QueryInterface(REFIID iid, LPVOID far * ppvObj){
	METHOD_PROLOGUE_EX(CEnumActions, EnumActions);
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
};

////////////////////////////////////////////////////////////////////////////
// IEnumAction methods

STDMETHODIMP CEnumActions::XEnumActions::Next(THIS_ ULONG celt, IBSAction **rgelt, ULONG *pceltFetched){
	METHOD_PROLOGUE_EX(CEnumActions, EnumActions);
 	ULONG i = 0;
	if( pThis->pList ){
		while ( (pThis->pos != (POSITION)NULL) && (i < celt) )
		{
			CActionSlob *pAction = (CActionSlob *)pThis->pList->GetNext(pThis->pos);
			// this does an add ref on the action
			rgelt[i] = pAction->GetInterface();
			i++;
		}
		*pceltFetched = i;
		return NOERROR;
	}
	return E_UNEXPECTED;
};

STDMETHODIMP CEnumActions::XEnumActions::Skip(THIS_ ULONG celt){
	METHOD_PROLOGUE_EX(CEnumActions, EnumActions);
 	ULONG i = 0;
	if( pThis->pList ){
		while ( (pThis->pos != (POSITION)NULL) && (i < celt) )
		{
			pThis->pList->GetNext(pThis->pos);
			i++;
		}
		return NOERROR;
	}
	return E_UNEXPECTED;
};

STDMETHODIMP CEnumActions::XEnumActions::Reset(THIS){
	METHOD_PROLOGUE_EX(CEnumActions, EnumActions);
	if( pThis->pList ) {
		pThis->pos = pThis->pList->GetHeadPosition();
	}
	return NOERROR;
};

STDMETHODIMP CEnumActions::XEnumActions::Clone(THIS_ IEnumBSActions **ppenum){
	METHOD_PROLOGUE_EX(CEnumActions, EnumActions);
	return E_NOTIMPL;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\dllgrid.h ===
#ifndef __DLLGRID_H__
#define __DLLGRID_H__

#ifndef __UTILCTRL_H__
#include "utilctrl.h"
#endif

class CDLLGridRow;
class CDLLGridWnd;

enum {COL_PRELOAD , COL_LOCALNAME,  COL_REMOTENAME, WATCH_NUM_COLUMNS /* should be last */};

#ifndef EXPORTED
#define EXPORTED virtual
#endif

/////////////////////////////////////////////////////////////////////////////
// CDLLGridRow 
// A specialized grid row which can live in a DLL like Grid control.

class CDLLGridRow : public CGridControlRow 
{
public:
	inline CDLLGridRow(CDLLGridWnd *pGridWnd, CDLLGridRow *pParent = NULL )
		: CGridControlRow((CGridWnd *)pGridWnd)
	{
		CRect rect(0,0,0,0);
		m_fPreload = TRUE;	m_fDelete = FALSE;
	}

	typedef CGridControlRow  CBaseClass;

// Attributes	
public:
	virtual void GetColumnText(int nColumn, CString& rStr);
	virtual void OnActivate(BOOL bActivate, int nColumn);
	virtual BOOL OnAccept(CWnd *pControlWnd);
	virtual int GetNextControlColumn(int nColumn);
	virtual int GetPrevControlColumn(int nColumn);
	virtual void DrawCell(CDC *pDC, const CRect& cellRect, int nColumn);
	virtual void AdjustForMargins(CRect& rect, int nColumn);
	virtual void ResetSize(CDC *pDC);
	virtual CSize GetCellSize(CDC *pDC, int nColumn) const;
	inline CDLLGridWnd * GetDLLGrid()
	{	return (CDLLGridWnd *)GetGrid( ); }

	inline int GetCheck() { return m_fPreload ? 1 : 0; }
	void SetCheck(int nCheck);

	// Place holder for function to call if some external
	// state change should force the GridRow to update itself.
	virtual void Update( );
	virtual BOOL OnLButtonDown(UINT nFlags, CPoint point);

	BOOL m_fPreload;
	CString m_strLocalName;
	CString m_strRemoteName;
	BOOL m_fDelete;
};


/////////////////////////////////////////////////////////////////////////////
// CDLLGridWnd window
// A Grid Control with a DLL like hierarcichal structure.

class CDLLGridWnd : public CGridControlWnd
{
// Construction
public:
	CDLLGridWnd (int nColumns = 3, BOOL bDisplayCaption = TRUE);
	~CDLLGridWnd();
	typedef CGridControlWnd CBaseClass;

// Attributes
public:
	BOOL m_fEnabled;
	BOOL m_fShowRemoteCol;

// 
// Operations
public:
	long GetMinColumnWidth(CString strCaption);
	EXPORTED CDLLGridRow * GetRow(int nIndex = -1);

	inline CDLLGridRow *GetRowAt(POSITION pos)
	{	return (CDLLGridRow *)CGridControlWnd::GetRowAt(pos); }
	inline CDLLGridRow *GetLastRow( )	// returns the last row (the new row that can't be deleted)
	{	return GetRowAt(m_rows.GetTailPosition()); }

	CDLLGridRow *GetCurSel( );	// returns the row iff there is exactly 1 item selected, NULL otherwiase
	BOOL SetCurSel(int nSelect);

	virtual BOOL ProcessKeyboard(MSG* pMsg, BOOL bPreTrans = FALSE);
	void DoDelete();
	void DoToggleCheck();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDLLGridWnd)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	afx_msg UINT OnGetDlgCode();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_VIRTUAL

protected:
	BOOL m_bNewRow:1;

protected:

	// True if some row in the grid is selected.
	BOOL HasASelection() const
	{	return (GetHeadSelPosition() != NULL);	}

public:	
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	afx_msg void OnGridNew();			//  New button pressed 
	afx_msg void OnGridDelete();		//  Delete button pressed 
	
	// Generated message map functions
protected:
	//{{AFX_MSG(CDLLGridWnd)mber functions here.
	afx_msg void OnPaint();
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

#endif // __DLLGRID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\engine.h ===
// CBuildEngine
//
// Build engine.
//
// [matthewt]
//
				   
#ifndef _ENGINE_H_
#define _ENGINE_H_

#include "slob.h"		// CSlob
#include "bldapi.h"		// Interfaces
#include "bldguid.h"		// Interfaces

// definition of the CActionSlob class
class CProjItem;
class CBuildTool;
class CFileRegistry;
class CIncludeEntryList;

// Action Enumerator
class CEnumActions : public CCmdTarget {
protected:
	BEGIN_INTERFACE_PART(EnumActions, IEnumBSActions)
		INIT_INTERFACE_PART(CEnumActions, EnumActions)
		// IEnum style methods
		STDMETHOD(Next)(THIS_ ULONG celt, IBSAction **rgelt, ULONG *pceltFetched);
		STDMETHOD(Skip)(THIS_ ULONG celt);
		STDMETHOD(Reset)(THIS);
		STDMETHOD(Clone)(THIS_ IEnumBSActions **ppenum);
	END_INTERFACE_PART(EnumActions)

	DECLARE_INTERFACE_MAP()

public:
	void SetList( CActionSlobList *list ){ pList = list; }

	// convenience function. to get the interface ptr.
	LPENUMBSACTIONS GetInterface(){
		LPENUMBSACTIONS pIEnum;
		m_xEnumActions.QueryInterface( IID_IEnumBSActions, (void **)&pIEnum );
		return pIEnum;
	}

private:
	POSITION pos;
	CActionSlobList *pList;
};

// definition of the CActionSlobList class
class BLD_IFACE CActionSlobList : public CObList
{
	friend class CEnumActions;
	DECLARE_DYNAMIC(CActionSlobList)
	CActionSlobList():CObList( 3 ){
		enumActions = NULL;
		pIEnum = NULL;
	};

public:
	// find a tool and return the postion of the action
	POSITION Find(CBuildTool * pTool);

	// Get Interface and release interface are used to 
	// control the add ons ability to access the action list
	void ReleaseInterface( void ){
		if( pIEnum ) {
			enumActions->SetList( NULL );
			pIEnum->Release();
			pIEnum = NULL;
		}
	};

	LPENUMBSACTIONS GetInterface(void){
		if( pIEnum ) {
			pIEnum->AddRef();
		} else {
			enumActions = new CEnumActions;
			pIEnum = enumActions->GetInterface();
			enumActions->SetList(this);
		}
		return pIEnum;
	}

#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif
	// this should be co create instanced
	CEnumActions 	*enumActions;
	LPENUMBSACTIONS  pIEnum;
};

#pragma hdrstop
#include "depgraph.h"	// dep. graph

// creating and deleting a list of temporary files
class BLD_IFACE CTempMaker
{
public:
	// FUTURE: pick better size? (prime)
	CTempMaker() {m_Files.InitHashTable(17);}
	~CTempMaker();	

	BOOL CreateTempFile(CStdioFile * & pFile, CPath & rPath, CErrorContext & EC = g_DummyEC, BOOL fBatFile = FALSE );
	BOOL CreateTempFileFromString(CString & str, CPath & rPath, CErrorContext & EC=g_DummyEC, BOOL fBatFile = FALSE );

	// Remove all the files from disk:
	void NukeFiles(CErrorContext& EC = g_DummyEC);

private:
	CMapPathToOb m_Files;
	CDir m_DirTempPath;
};

// state of an action 
typedef enum ActionState
{
	_SrcMissing,		// source missing for action
	_SrcOutOfDate,		// output out of date wrt sources
	_DepsOutOfDate,		// source out of date wrt deps
	_Current,			// output is current wrt to output and deps
	_Unknown			// unknown action state
};

// Scanned source dependency list state
#define DEPSTATE	CIncludeEntryList *
#define DEP_Empty	((DEPSTATE)NULL)	// empty deps
#define DEP_None	((DEPSTATE)-1)		// forced to have no deps

// type and stage of the action to be performed

// action type
#define TOB_Build	0x0				// action must build output
#define TOB_ReBuild	0x1				// action must re-build output
#define TOB_Clean	0x2				// action must clean output

// action stage
#define TOB_Pre		0x0				// perform pre-action processing
#define TOB_Stage	0x1				// perform the action type
#define TOB_Post	0x2				// perform post-action processing

// attributes of a build
#define AOB_Default			0x0		// default build
#define AOB_IgnoreErrors	0x1		// 'ignore errors' build, eg. batched builds
#define AOB_Forced			0x2		// 'forced' build, eg. compile a single item

// action return status
#define ACT_Error		0x0			// error during action
#define ACT_Canceled	0x1			// canceled action
#define ACT_Complete	0x2			// completed action

// generation of output files
#define AOGO_Primary	0x1							// only those considered primary
#define AOGO_Other		0x2							// other output files
#define AOGO_All		AOGO_Primary | AOGO_Other	// all output files
#define AOGO_Default	AOGO_All					// default is top generate all output files



class CBSAction : public CCmdTarget {
protected:
	BEGIN_INTERFACE_PART(Action, IBSAction)
		INIT_INTERFACE_PART(CBSAction, Action)
		STDMETHOD(GetInputs)(LPBUILDFILESET *);
		STDMETHOD(GetOutputs)(LPBUILDFILESET *);
		STDMETHOD(GetTool)(LPBUILDTOOL *);
		STDMETHOD(GetFile)(LPBUILDFILE *);
		STDMETHOD(GetConfiguration)(HCONFIGURATION *);
		STDMETHOD(AddOutput)(const CPath *pPath);
		STDMETHOD(GetCommandOptions)(CString *);
	END_INTERFACE_PART(Action)

	DECLARE_INTERFACE_MAP()
public:
	void SetAction( CActionSlob *pAct ){ pAction = pAct; }

	LPBSACTION GetInterface( void ){
		LPBSACTION pIAction;
		m_xAction.QueryInterface( IID_IBSAction, (void **)&pIAction );
		return pIAction;
	}
private:
	CActionSlob *pAction;
};


class BLD_IFACE CActionSlob : public CSlob, public CFileRegNotifyRx
{
	DECLARE_DYNAMIC(CActionSlob)

	
public:
	// Associate this action to a particular project item. This project item's
	// configuration reocrd will be accessed to retrieve configuration specific
	// action information.
	// Associate this action with a particular tool. It will access the CBuildTool's
	// methods in order to modify the action's build information.
	CActionSlob() {};
	CActionSlob(CProjItem *, CBuildTool *, BOOL fBuilder = FALSE, ConfigurationRecord * pcr = (ConfigurationRecord *)NULL);
	~CActionSlob();

	LPBSACTION GetInterface(void){
		if( pCBSAction ) {
			pIAction->AddRef();
		} else {
			pCBSAction = new CBSAction;
			pIAction = pCBSAction->GetInterface();
			pCBSAction->SetAction(this);
		}
		return pIAction;
	}
	void ReleaseInterface(void) {
		if( pCBSAction ) {
			pCBSAction->SetAction(NULL);
			pIAction->Release();
		}
	}

	// Binding and un-binding to tools
	void Bind(CBuildTool * pTool);
	void UnBind();
	//
	// Assigning/unassigning of actions to project items (default is active config.)
	//
	static void AssignActions
	(
		CProjItem * pItem,
		CPtrList * plstSelectTools = (CPtrList *)NULL,
		ConfigurationRecord * pcr = (ConfigurationRecord *)NULL,
		BOOL fAssignContained = TRUE,
		BOOL fAssignContainedOnly = FALSE
	);
	static void UnAssignActions
	(
		CProjItem * pItem,
		CPtrList * plstSelectTools = (CPtrList *)NULL,
		ConfigurationRecord * pcr = (ConfigurationRecord *)NULL,
		BOOL fUnassignContained = TRUE
	);

	//
	// Adding/removing of actions to/from build instances (default is active config.)
	//
	static void BindActions
	(
		CProjItem * pItem,
		CPtrList * plstSelectTools = (CPtrList *)NULL,
		ConfigurationRecord * pcr = (ConfigurationRecord *)NULL,
		BOOL fBindContained = TRUE
	);
	static void UnBindActions
	(
		CProjItem * pItem,
		CPtrList * plstSelectTools = (CPtrList *)NULL,
		ConfigurationRecord * pcr = (ConfigurationRecord *)NULL,
		BOOL fUnbindContained = TRUE
	);

	//
	// Loading/storing from an archive
	//
	// FUTURE: 
	// Currently this will only load/save to an archive the
	// action command-lines and possible change flag.
	// If we ever 'export' .MAKs we can use this code to
	// serialize/deserialize the 'whole' builder (multiple projects)
	static BOOL LoadFromArchive(CArchive & ar);

	// old format compatible with 4.x and before
	static BOOL LoadFromArchiveVCP(CArchive & ar);
#if 0
	static BOOL SaveToArchive(CArchive & ar);
#endif
	static void IgnoreCachedOptions(BOOL bIgnore)  { s_bIgnoreCachedOptions = bIgnore; }
	static BOOL s_bIgnoreCachedOptions;

	// serialize/deserialize the action slob
	virtual void Serialize(CArchive & ar);

	// Assoc. target level action (iff we are not one ourselves)
	CActionSlob * GetTargetAction();

	//
	// Informing of all project actions for the specified config. (default is active config.)
	//
	static void InformActions
	(
		CProjItem * pItem,
		UINT idChange,
		ConfigurationRecord * pcr = (ConfigurationRecord *)NULL,
		BOOL fInformContained = TRUE
	);

	// 
	// Options at last perform etc.
	//

	
	__inline void DirtyCommand() {m_fDirtyCommand = TRUE;}

	// Retrieve and refresh the command-line options
	__inline BOOL GetCommandOptions(CString & strOptions) {strOptions = m_strOptions; return TRUE;}
	BOOL RefreshCommandOptions(BOOL & fChanged, BOOL fNoSet = FALSE);

	static void DirtyAllCommands
	(
		CProjItem * pItem,
		BOOL fPossibleChange = FALSE,
		ConfigurationRecord * pcr = (ConfigurationRecord *)NULL
	);

	//
	// Generate outputs
	//

	// Use when just a simple file reg. handle
	__inline BOOL AddOutput(FileRegHandle frh, BOOL fWithAction = TRUE)
		{frh->AddFRHRef(); return AddOutputI(frh, fWithAction);}

	static const TCHAR szDefVCFile[];

	// Used when path is already known
	BOOL AddOutput(const CPath * pPath, BOOL fWithAction = TRUE, BOOL fAllowFilter = TRUE);

	// Used for figuring out filenames controlled by option flags, e.g. /MAP:foo.map 
	// 'nPathId' is the path prop, may or may not return fullpath, might be dir. only
	// 'pcDefExtension' is the new extension to use
	// 'pBaseDir' is the directory to re-base the filename in
	// 'pcDefFilename' is the new filename (if none supplied from nPathId) (default is use filebase)
	// 'nEnablePropId' is the enabling prop., if FALSE then no output added
	// 'fWithAction' if TRUE will associate the output with an action in the graph
	BOOL AddOutput
	(
		UINT nPathId,
		const TCHAR *pcDefExtension,
		const CDir *pBaseDir,
		const TCHAR *pcDefFilename = (TCHAR *)NULL,
		UINT nEnablePropId = (UINT)-1,
		BOOL fWithAction = TRUE
	);

	// retrieve our 'actual' input(s)
	CFileRegSet * GetInput();
	__inline void DirtyInput(BOOL fDirty = TRUE) {m_fDirtyInput = fDirty;}
	void ClearInput();

	// retrieve our list of outputs (list of file registry handles)
	CFileRegSet * GetOutput();
	__inline CWordArray * GetOutputAttrib() {return m_fInGenOutput ? m_paryOldOutputAttrib : &m_aryOutputAttrib;}
	__inline void DirtyOutput(BOOL fDirty = TRUE) {m_fDirtyOutput = fDirty;}
	void ClearOutput();

	__inline CBuildTool * BuildTool()	{return m_pTool;}
	__inline CProjItem * Item()			{return m_pItem;}
	__inline BOOL FBuilder()			{return m_fBuilder;}

	//
	// Scanned dependencies
	//
	__inline CIncludeEntryList * GetIncludeDep() {return m_pIncludeList;}

	CFileRegSet * GetScannedDep();
	__inline void ClearScannedDep() {ClearDepI(DEP_Scanned);}
	void SubScannedDep(FileRegHandle frhDep);

	// add scanned dependency (unresolved)
	BOOL AddScannedDep(int type, CString & strFile, int nLine = 0, BOOL fScan = TRUE);

	// add/remove scanned dependency (resolved)
	__inline BOOL AddScannedDep(CString & strFile) {return AddDepI(DEP_Scanned, strFile);}
	__inline BOOL AddScannedDep(FileRegHandle frhDep) {return AddDepI(DEP_Scanned, frhDep);}
	__inline BOOL RemoveScannedDep(FileRegHandle frhDep) {return RemoveDepI(DEP_Scanned, frhDep);}

	//
	// Missing (scanned) dependencies
	//
	CFileRegSet * GetMissingDep(BOOL bAlloc = TRUE);
	__inline void ClearMissingDep() {ClearDepI(DEP_Missing);}
 	__inline BOOL AddMissingDep(CString & strFile) {return AddDepI(DEP_Missing, strFile);}
	__inline BOOL AddMissingDep(FileRegHandle frhDep) {return AddDepI(DEP_Missing, frhDep);}
	__inline BOOL RemoveMissingDep(FileRegHandle frhDep) {return RemoveDepI(DEP_Missing, frhDep);}

	//
	// Source dependencies
	//
	CFileRegSet * GetSourceDep();
	__inline void ClearSourceDep() {ClearDepI(DEP_Source);}

	// add/remove source dependency
 	__inline BOOL AddSourceDep(CString & strFile) {return AddDepI(DEP_Source, strFile);}
	__inline BOOL AddSourceDep(FileRegHandle frhDep) {return AddDepI(DEP_Source, frhDep);}
	__inline BOOL RemoveSourceDep(FileRegHandle frhDep) {return RemoveDepI(DEP_Source, frhDep);}

	__inline void SetDepState(DEPSTATE stateDep)
		{m_pIncludeList = stateDep;}

	//
	// Notification of input changing
	//
 
	// Rx for file change events
	virtual void OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint);

	// Batched notification?
	__inline void BatchNotify(BOOL fBatch) {m_fBatchNotify = fBatch;}

	//
	// Notification of output changing
	//

	// Rx for property change events, eg. we're interested in P_ToolOutput
 	virtual void OnInform(CSlob * pChangedSlob, UINT idChange, DWORD dwHint);

	//
	// User Interface helpers
	//

	// Fill a listbox with available tool names for the project item
	// Note, listbox ptr data is a CActionSlob * for each tool
	static void FillToolLBox(CListBox * pLBox, CProjItem * pItem);

	// Get the action for the currently selected tool
	static CActionSlob * GetToolLBoxAction(CListBox * pLBox);

	// Fill a grid with input or output for an action
	static void FillFileGrid(CActionSlob * pAction, CListBox * pLBox, UINT depType = DEP_Input);

	// Get the currently selected grid file registry entry
	static CFileRegEntry * GetFileGridEntry(CListBox * pLBox);
#ifdef _DEBUG
	virtual void Dump(CDumpContext & dc) const;
#endif

	// FUTURE: make private (currently used to Refresh() etc.)
	// Internal helper to set tool
	void SetToolI(CBuildTool *);

	// Helpers for add ref/release ref'ing file items when
	// doing an Assign/UnAssign action or Bind/Unbind action
	static void AddRefFileItem(CProjItem * pItem, CPtrList *frhList=NULL);
	static void ReleaseRefFileItem(CProjItem * pItem);

	// Current action mark to use
	static WORD m_wActionMarker;

	// Associated project item and tool (+ tool user-data)
	CProjItem * m_pItem;
	CBuildTool * m_pTool;
	CBuildTool * m_pOldTool;
	DWORD m_dwData;

	// Event data
	DWORD m_dwEvent;

	// The configuration this action is concerning.
	ConfigurationRecord * m_pcrOur;

	// Build process information
	CFileRegistry * m_pregistry;	// registry our build files are in
	CFileDepGraph * m_pdepgraph;	// build process graph

	//
	// Scanned source deps
	//
	ActionState m_state;	// state of this action

	// Used as mark during dep. graph analysis and build process
	WORD m_wMark;

	// Used during command-options refresh
	WORD m_wMarkRefCmdOpt;


	//  All bitfields are intentionally placed here to get best packing

	BOOL m_fPossibleOptionChange:1;
	// Used during command-options refresh
	BOOL m_fCmdOptChanged:1;

private:

	// Builder action? If not it'll be used just to store options at last build
	// for the target-level options.
	BOOL m_fBuilder:1;

	// Dirty input?
	BOOL m_fDirtyInput:1;

	// Dirty output?
	BOOL m_fDirtyOutput:1;

	// Dirty command-line?
	BOOL m_fDirtyCommand:1;

	// Batched input/output notify? .. ignore if TRUE
	BOOL m_fBatchNotify:1;

	// Updating output?
	BOOL m_fInGenOutput:1;

	// Assoc. target level action (iff we are not one ourselves)
	CActionSlob * m_pTrgAction;

	CString m_strOptions;

	// Input file or files (filter) 'possibly' consumed by this action
	FileRegHandle m_frhInput;

	// Temp. 'actual' input file set
	CFileRegSet m_frsInput;

	// Output files generated by this action
	CFileRegSet m_frsOutput;

#ifdef REFCOUNT_WORK
	// Output files that can be used as input to schmooze tools.
	CFileRegSet m_frsSchmoozableOutput;
#endif
	CFileRegSet *m_pfrsOldOutput;

	// Attributes of the output
	// Currently non-zero == 'has action', zero == 'no action'
	CWordArray m_aryOutputAttrib;
	CWordArray *m_paryOldOutputAttrib;

	// Scanned dependencies
	CIncludeEntryList * m_pIncludeList;		// unresolved
	CFileRegSet m_frsScannedDep;			// resolved (in the graph...)

	// Missing dependencies
	CFileRegSet m_frsMissingDep;

	// Source dependencies
	CFileRegSet m_frsSourceDep;			// resolved (in the graph...)

	//
	// Time of last dependency update on this CActionSlob.
	// Zero if uninitialized.
	//
	FILETIME m_LastDepUpdate;

public:
	//
	// Update dependency stuff.
	//
	BOOL IsDepInfoInitialized();
	BOOL IsNewDepInfoAvailable();

	//
	// Update dependency information if new information is available.
	// Set bForceUpdate = TRUE to force update if updating has been turned off
	// minimal rebuild info is not available.
	BOOL UpdateDepInfo(BOOL bForceUpdate = FALSE);

	void UpdateDepInfoTimeStamp();
private:

	
	// Internal helper for UI
	static int FillFileGridI(CActionSlob * pAction, CFileRegEntry * pEntry, CListBox * pLBox, int istart);

	// Internal dependency
	void ClearDepI(UINT depType);
	BOOL AddDepI(UINT depType, CString & strFile);
	BOOL AddDepI(UINT depType, FileRegHandle frh);
	BOOL RemoveDepI(UINT depType, FileRegHandle frh);

	// Internal input/output refreshers
	void RefreshInputI();
	void RefreshOutputI();

	// Internal add output (assumes ref. count is correct)
	BOOL AddOutputI(FileRegHandle frh, BOOL fWithAction = TRUE);

	// Add and remove the input (helpers)
	void AddInput();
	void RemoveInput();
	
	// Valid input file? ie. no in the output
	BOOL ValidInput(FileRegHandle frh);

	// COM support.
	CBSAction *pCBSAction;
	LPBSACTION pIAction;
};

// definition of the pages property used to view CActionSlob information
class CFileGridPage : public CProjPage
{
	DECLARE_MESSAGE_MAP()

public:
	CFileGridPage(UINT depType = DEP_Input);
	virtual ~CFileGridPage() {};

	virtual BOOL OnInitDialog();
	virtual void InitPage();
	virtual BOOL OnPropChange(UINT);

	// respond to selection changes in the tools listbox
	void OnToolsSelChange();

	// respond to selection changes in the file grid
	void OnFileGridSelChange();

private:
	// viewing what files?
	UINT m_depType;
};

class CInputsPage : public CFileGridPage
{	
	DECLARE_IDE_CONTROL_MAP();

public:
	CInputsPage() : CFileGridPage(DEP_Input) {}
};

class COutputsPage : public CFileGridPage
{
	DECLARE_IDE_CONTROL_MAP();

public:
	COutputsPage() : CFileGridPage(DEP_Output) {}
};

class CDepsPage : public CFileGridPage
{
	DECLARE_IDE_CONTROL_MAP();

public:
	CDepsPage() : CFileGridPage(DEP_Dependency) {}
};

extern CInputsPage g_InputsPage;
extern COutputsPage g_OutputsPage;
extern CDepsPage g_DepsPage;

// FUTURE - clean this CMD_ and ACT_ stuff up so the build engine is clearer.
// Make these enums (the type will then be int, which is what it should be anyway
// since that's what DoSpawn returns) and then update the return type on some of
// the build funcs (like ExecuteCmdLines)
// The same should be done to a lot of the #defines in this file.

// state of a command line execution
#define CMD				UINT
#define CMD_Canceled	(UINT)-2
#define CMD_Complete	(UINT)0	
#define CMD_Error		(UINT)1

// build engine errors

// can't get the command-line text for a command-line based tool
// -> context is a CBuildTool *
#define BldError_CantGetCmdLines	IDS_GET_COMMAND_LINE_FAILED
#define BldError_ScanError			IDS_SCAN_ERROR

// CBuildEngine debugging bits
#define DBG_BS_OFF		0x0		// (no debugging)
#define DBG_BS_GRP		0x1		// show graph ctor/dtor info

#define ENABLE_BS_GRP	0x10	// enable graph ctor/dtor 

// definition of the CBuildEngine class
class CFileDepGraph;
class COutputWinEC;

class BLD_IFACE CBuildEngine : public CObject
{
	DECLARE_DYNAMIC(CBuildEngine)

public:
	CBuildEngine();
 	virtual ~CBuildEngine();

	// \/ Command Tool Interface functions
	// Execute some command-lines
	CMD ExecuteCmdLines(CPtrList &, CDir &, BOOL fCheckForComSpec, BOOL fIgnoreErrors, CErrorContext & EC = g_DummyEC);

	// Batching command-lines
	// 1) FALSE->TRUE == start batching
	// 2) TRUE->FALSE == flush currently batched command-lines
	// Returns ExecuteCmdLines() error value if flushing command-lines in 2)
	CMD BatchCmdLines(BOOL fBatch = TRUE);
	CMD FlushCmdLines();
    void ClearCmdLines();

	// /\ Command Tool Interface functions 	
	
	// \/ Error Utilituy functions 	
	void LogBuildError(UINT idError, void * pvContext, CErrorContext & EC = g_DummyEC);
	// /\ Error Utility functions 	

	// \/ File Utility functions
	__inline BOOL CreateTempFile(CString str, CPath & path, CErrorContext & EC = g_DummyEC)
		{return TmpMaker.CreateTempFileFromString(str, path, EC);}

	__inline void NukeTempFiles(CErrorContext & EC)
		{TmpMaker.NukeFiles(EC);}

	// Return a character pointer to a memory mapped file (also close the file)
	BOOL OpenMemFile(FileRegHandle frh,
					 HANDLE & hMap,
					 const TCHAR * & pcFileMap, DWORD & dwFileSize,
					 CErrorContext & EC = g_DummyEC);

 	BOOL CloseMemFile(HANDLE & hMap, CErrorContext & EC = g_DummyEC);

	// Delete a file from the disk
	BOOL DeleteFile(FileRegHandle, CErrorContext & EC = g_DummyEC);

	// Form a command-line, may use a response file if too long
	BOOL FormCmdLine(CString & strToolExeName, CString & strCmdLine, CErrorContext & EC, BOOL fRspFileOk = TRUE);
	BOOL FormBatchFile(CString & strCmdLine, CErrorContext & EC);

	// /\ File Utility functions 

	// \/ Build instance (graph + registry) manipulation for items
	// Note, must have active config. set.
	CFileRegistry * GetRegistry(ConfigurationRecord *);
	CFileDepGraph * GetDepGraph(ConfigurationRecord *);

	// Set the graph mode for all dep graphs of this builder
	void SetGraphMode(UINT mode, CProject * pBuilder);

	// a build instance
	typedef struct
	{
		CFileRegistry * s_preg;		// registry
		CFileDepGraph * s_pgraph;	// dependency graph
	} SBldInst;

	SBldInst * AddBuildInst(ConfigurationRecord *);
	void RemoveBuildInst(ConfigurationRecord *);

	// /\ Build instance manipulation items

	// \/ Building of project
	//
	// 'pcrBuild' is the configuration of the build
	//
	// 'EC' is the destination of error messages during build
	//
	// 'frhStart' is the file to build (default is all target files in graph)
	//
	// 'aob' is the attributes of the build
	// o AOB_Default		- default
	// o AOB_IgnoreErrors	- ignore errors
	//
	// 'type' is the type of build
	// o TOB_Build			- build
	// o TOB_ReBuild		- rebuild
	//
	// 'statefilter' is the state to check for in BuildState()
	// 'lstFrh' is the list of files that match 'statefilter' approp.
	//
	// 'fVerbose' will cause the build to prompt, eg. 'settings changed' etc.
	BOOL HasBuildState
	(
		ConfigurationRecord * pcrBuild,	
		CPtrList & lstFrh,															  
		UINT statefilter = DS_OutOfDate,
		FileRegHandle frhStart = (FileRegHandle)NULL
	);

	CMD DoBuild
	(																  
		ConfigurationRecord * pcrBuild,
 		CErrorContext & EC,
		FileRegHandle frhStart = (FileRegHandle)NULL,
		DWORD aob = AOB_Default,
		UINT type = TOB_Build,
		BOOL fRecurse = TRUE,
		BOOL fVerbose = TRUE
	);
	// /\ Building of project

	__inline CErrorContext * OutputWinEC() {return (CErrorContext *)m_pECOutputWin;}

	// debugging options
	DWORD m_dwDebugging;

private:
	// internal
	CMD ExecuteCmdLinesI(CPtrList &, CDir &, BOOL fCheckForComSpec, BOOL fIgnoreErrors, CErrorContext & EC = g_DummyEC);

	// command-line interface batching
	// batched cmdline. lists
	CStringList		m_slCmds;
	CStringList		m_slDesc;

	CPtrList		m_plCmds;

	CDir			m_dirLast;
	BOOL			m_fLastCheckForComSpec;
	BOOL			m_fLastIgnoreErrors;
	BOOL			m_fBatchCmdLines;
	CErrorContext *	m_pECLast;

	// Build instance map
	CMapPtrToPtr m_mapBldInst;

	// an output window error context
	COutputWinEC * m_pECOutputWin;

	CTempMaker	TmpMaker;
	CPtrList	m_MemFiles;
};

// our *single* instance of the build engine
extern BLD_IFACE CBuildEngine g_buildengine;

extern BLD_IFACE CPtrList g_lsttargref;

typedef struct tagTARGREFINFO {
	CProjItem *	pTargRef;
	ConfigurationRecord *	pcr;
} TARGREFINFO;
 
#endif // _ENGINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\exevw.cpp ===
//
// Exe View Slob
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "resource.h"
#include "bldslob.h"
#include "bldnode.h"
#include "exevw.h"	// our local header

#ifdef _DEBUG
//#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#undef new
#endif

IMPLEMENT_SERIAL(CExeViewSlob, CProjSlob, 1)

#define theClass CExeViewSlob
BEGIN_SLOBPROP_MAP(CExeViewSlob, CProjSlob)
	STR_PROP(Title)
	BOOL_PROP(IsInvisibleNode)
END_SLOBPROP_MAP()
#undef theClass

CExeViewSlob::CExeViewSlob()
{
	m_bIsInvisibleNode = FALSE;

	m_pProject = g_pActiveProject;
}

CExeViewSlob::~CExeViewSlob()
{
	GetBuildNode()->RemoveNode(this);
}

void CExeViewSlob::Serialize(CArchive & ar)
{
	CProject * pProject = g_pActiveProject;

    if (ar.IsStoring())
    {
    }
    else
    {
 		if (pProject->IsExeProject())
		{
			SetIntProp(P_IsInvisibleNode, FALSE);
			GetBuildNode()->AddNode(this);
		}
		else
		{
			SetIntProp(P_IsInvisibleNode, TRUE);
		}
    }
}

void CExeViewSlob::GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds)
{
    // Not really much available for exe projects

    // FUTURE (colint): We may want to add useful commands
    // such as Debug, Stop debugging etc.. here

    // Build settings can be done for an exe project
    aCmds.Add(IDM_PROJECT_SETTINGS_POP);
}

BOOL CExeViewSlob::SetIntProp(UINT idProp, int val)
{
	BOOL bRetVal;

	switch (idProp)
	{
		case P_IsExpandable:
		case P_IsExpanded:
		case P_IsInvisibleNode:
			bRetVal = CSlob::SetIntProp(idProp, val);
			break;

		default:
			bRetVal = m_pProject->SetIntProp(idProp, val);
			break;
	}

	return bRetVal;
}

BOOL CExeViewSlob::SetStrProp(UINT idProp, const CString& val)
{
	// We should not be setting the title for a wrapper item
	ASSERT(idProp != P_Title);

	return m_pProject->SetStrProp(idProp, val);
}

GPT CExeViewSlob::GetIntProp(UINT idProp, int &val)
{
  	GPT gpt;
	
	switch (idProp)
	{
		case P_IsExpandable:
			val = FALSE;
			gpt = valid;
			break;

		case P_IsExpanded:
		case P_IsInvisibleNode:
			gpt = CSlob::GetIntProp(idProp, val);
			break;

		default:
			gpt = m_pProject->GetIntProp(idProp, val);
			break;
  	}

	return gpt;
}

GPT CExeViewSlob::GetStrProp(UINT idProp, CString &val)
{
 	if (idProp == P_Title)
	{
  		idProp = P_ProjItemName;
	}

	return m_pProject->GetStrProp(idProp, val);
}

BOOL CExeViewSlob::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	BOOL bRet = m_pProject->SetupPropertyPages(pNewSel, bSetCaption);

	CProjSlob::SetupPropertyPages(pNewSel, FALSE);

	return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\exevw.h ===
//
// CExeViewSlob
//
// Exe Project View Slob
//
// [colint]
//

#ifndef _INCLUDE_EXEVWSLOB_H
#define _INCLUDE_EXEVWSLOB_H

class CExeViewSlob : public CProjSlob
{
	DECLARE_SERIAL(CExeViewSlob)

public:
	CExeViewSlob();
	~CExeViewSlob();

	void SetFilterTarget(HBLDTARGET hTarget);

	virtual BOOL CanAct(ACTION_TYPE action)	{ return FALSE; }
 
	virtual CObList * GetContentList() { return NULL; }

	virtual BOOL SetIntProp(UINT idProp, int val);
	virtual BOOL SetStrProp(UINT idProp, const CString & val);
	virtual	GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetStrProp(UINT idProp, CString & val);

	// Property Window Interface
	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

    virtual void Serialize(CArchive & ar);

    virtual void GetCmdIDs(CWordArray& aVerbs, CWordArray& aCmds); 

private:
	CString m_strTitle;

	BOOL m_bIsInvisibleNode;

 	CProject * m_pProject;

	DECLARE_SLOBPROP_MAP();
};

#endif // _INCLUDE_EXEVWSLOB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\grview.cpp ===
//
// CGraphPainter, CGraphWnd, CGraphView, CGraphDialog
//
// definitions for CGraphView -- the graph viewer
//
// The graph viewer makes use of the CLayout object to position
// the nodes of a graph into rows and columns that nicely show
// the heirarchy.
// 
// The CLayout object in turn uses the CNidGraph protocol to determine
// the relations in the graph.  Based on this information it
// assigns logical rows and columns to each CGrNode.
//
// Responsiblity for painting the nodes is on the CGraphPainter object
// which can give the extent of any node and can paint it in any
// given position.
//
// The graph view makes use of the CGraphPainter to find out the size
// of each node from which it computes the physical size of each row
// and column.  With this information it can compute the physical
// position of every node.  It uses these positions to draw all of
// the rows which interconnect the nodes and to further instruct
// the CGraphPainter to paint each node at that position.
//
// [ricom] (modified by [matthewt])

#include "stdafx.h"
#pragma hdrstop

#ifdef DEPGRAPH_VIEW

#include "resource.h"	// resources header
#include "grview.h"		// local header

IMPLEMENT_DYNAMIC(CGraphLegend, CWnd)
IMPLEMENT_DYNAMIC(CGraphWnd, CWnd)
IMPLEMENT_DYNAMIC(CGraphDialog, CDialog)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define CX_LEFT_MARGIN 10

/////////////////////////////////////////////////////////////////////////////
// CGraphLegend

// RGBs to be used
#define RGB_BKG_OUTOFDATE		RGB_RED
#define RGB_BKG_DEPMISSING		RGB_BLUE
#define RGB_BKG_CURRENT			RGB_GREEN
#define RGB_BKG_FORCEDOUTOFDATE RGB_YELLOW

#define RGB_TXT_FILEEXISTS		RGB_BLACK
#define RGB_TXT_FILEMISSING		RGB_WHITE

#define RGB_TXT_DEPENDENCY		RGB_DARKMAGENTA

typedef struct _tagLgndEntry
{
	COLORREF clr;			// color	
/*
	UINT idType;			// UI usage
	UINT idText;			// meaning
*/
	const TCHAR * pchType;	// UI usage
	const TCHAR * pchText;	// meaning
} LgndEntry;

// legend to use
static const LgndEntry rgLgnds[] =
{
	RGB_BKG_CURRENT, "(Bkgnd)", "Current",
	RGB_BKG_OUTOFDATE, "(Bkgnd)", "Out of date",
    RGB_BKG_FORCEDOUTOFDATE, "(Bkgnd)", "Forced out of date",
	RGB_BKG_DEPMISSING, "(Bkgnd)", "Dependency missing",
	RGB_TXT_FILEEXISTS, "(Text)", "File exists",
	RGB_TXT_FILEMISSING, "(Text)", "File missing",
	RGB_TXT_DEPENDENCY, "(Text)", "Dependency File",
};

BEGIN_MESSAGE_MAP(CGraphLegend, CWnd)
	//{{AFX_MSG_MAP(CGraphLegend)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BOOL CGraphLegend::Create(UINT nID, CRect rect, CWnd * pParentWnd /* = NULL */)
{
	return CWnd::Create(NULL,						// class
						"GraphLgndWnd",				// window name
						WS_CHILD | WS_CLIPSIBLINGS,	// style
						(const RECT)rect,			// rect
						pParentWnd,					// parent window
						nID							// id
					   );
}

void CGraphLegend::OnPaint()
// paint the graph legend
//
{
	// get the window DC?
	CDC * pdc = GetDC();

	// use a small font
	pdc->SelectObject(GetStdFont(font_Italic));
	
	// legend (x,y)
	int x = 0, y = 0;

	TEXTMETRIC textmetric;
	VERIFY(pdc->GetTextMetrics(&textmetric));

	// cycle through legend
	for (int i = 0; i < sizeof(rgLgnds) / sizeof(LgndEntry); i++)
	{
		// paint legend color blob
		RECT rectBox = {x, y, x + textmetric.tmHeight, y + textmetric.tmHeight};
		// draw box
		pdc->MoveTo(rectBox.left, rectBox.top);
		pdc->LineTo(rectBox.right - 1, rectBox.top);
		pdc->LineTo(rectBox.right - 1, rectBox.bottom - 1);
		pdc->LineTo(rectBox.left, rectBox.bottom - 1);
		pdc->LineTo(rectBox.left, rectBox.top);

		// paint color 'usage' text
		pdc->SetBkColor(::GetSysColor(COLOR_BTNFACE));
		pdc->ExtTextOut(x + rectBox.right + 4, y, 0, NULL, rgLgnds[i].pchType, _tcslen(rgLgnds[i].pchType), NULL);

		rectBox.left++; rectBox.right--; rectBox.top++; rectBox.bottom--;
		pdc->SetBkColor(rgLgnds[i].clr);
		pdc->ExtTextOut(x + 1, y + 1, ETO_OPAQUE, &rectBox, NULL, 0, NULL);

		// move down a line of text + spacing
		y += (textmetric.tmHeight + 2);

		// paint color 'meaning' text
		pdc->SetBkColor(::GetSysColor(COLOR_BTNFACE));
		pdc->ExtTextOut(x, y, 0, NULL, rgLgnds[i].pchText, _tcslen(rgLgnds[i].pchText), NULL);

		// move down a line of text + spacing
		y += (textmetric.tmHeight + 4);
	}

	// call the base-class
	CWnd::OnPaint();
}

/////////////////////////////////////////////////////////////////////////////
// CGraphPainter

BOOL CGraphPainter::FInitGraphCDC(CDC * pdc, BOOL fErase)
{
	if (fErase)
		ASSERT(FALSE);	// FUTURE

	// make sure that this is MM_TEXT mapping mode
	pdc->SetMapMode(MM_TEXT);

	return TRUE;
}

void CGraphPainter::GetOffsets(CDC *, NID, NID, ET, int & cyOut, int & cyIn)
// return the offset from center for a lines going from the first NID arg
// to the second NID arg in cyOut and cyIn
//
{
	cyOut = 0;
	cyIn  = 0;
}

void CGraphPainter::GetSpacing
(
	CDC *,                
	int & cxMinTag,   
	int & cxEdgeSpace,
	int &  xLeftAbs,   
	int &  yTopAbs,    
	int & cyFakeHeight
)                     
// return the default spacing for a graph
//
{
	cxMinTag	 = 5;		// minimum length of straight line after label
	cxEdgeSpace  = 30;		// space allocated between nodes for drawing edges
	xLeftAbs	 = 10;		// x origin of the graph in standard position
	yTopAbs      = 2;		// y origin of the graph in standard position
	cyFakeHeight = 10;		// height allocated for fake nodes
}

void CGraphPainter::PaintAnchor(NID, int x, int y, int cx, int cy, CDC * pdc)
// default anchor is a box around the whole node
//
{
	pdc->InvertRect(CRect(x+1, y, cx-2, 1));		// Top
	pdc->InvertRect(CRect(x+1, y+cy-1, cx-2, 1));	// Bottom
	pdc->InvertRect(CRect(x, y, 1, cy));			// Left
	pdc->InvertRect(CRect(x+cx-1, y, 1, cy));		// Right
}

void CGraphPainter::PaintSelect(NID, int x, int y, int cx, int cy, CDC * pdc)
// invert entire xtnt by default
//
{
	pdc->InvertRect(CRect(x, y, cx, cy));
}			  

void CGraphPainter::PaintDeAnchor(NID, int x, int y, int cx, int cy, CDC * pdc)
// default anchor is a box around the whole node
//
{
	pdc->InvertRect(CRect(x+1, y, cx-2, 1));		// Top
	pdc->InvertRect(CRect(x+1, y+cy-1, cx-2, 1));	// Bottom
	pdc->InvertRect(CRect(x, y, 1, cy));			// Left
	pdc->InvertRect(CRect(x+cx-1, y, 1, cy));		// Right
}

void CGraphPainter::PaintDeSelect(NID, int x, int y, int cx, int cy, CDC * pdc)
// invert entire xtnt by default
//
{
	pdc->InvertRect(CRect(x, y, cx, cy));
}

/////////////////////////////////////////////////////////////////////////////
// CDepGraphPainter

BOOL CDepGraphPainter::FInitGraphCDC(CDC * pdc, BOOL fErase)
{
	// call base-class
	if (!CGraphPainter::FInitGraphCDC(pdc, fErase))
		return FALSE;

	pdc->SelectObject(GetStdFont(font_Small));

	return TRUE;	// ok
}

void CDepGraphPainter::GetNidSize(NID nid, CSize & size, CDC * pDC)
{
	size.cx = size.cy = 0;
	
	// get the node text
	CString strText;
	GetNidText(nid, strText);

	// calculate the size of the text
	const TCHAR * pchText = (const TCHAR *)strText;
	const TCHAR * pch = pchText;

	CSize sizeLine;
	while (*pch != _T('\0'))
	{
		while (*pch != _T('\0') && *pch != ('\n'))
			pch = _tcsinc(pch);

		// what is the size of text?
		sizeLine = pDC->GetTextExtent((LPCTSTR)pchText, pch - pchText);

		if (sizeLine.cx > size.cx)
			size.cx = sizeLine.cx;
		size.cy += (sizeLine.cy + 2);	// padding

		if (*pch == _T('\n'))
			pchText = ++pch;
	}

    size.cy += sizeLine.cy + 2; // Depstate as text

	size.cx += 4;
	size.cy += 4;
}

void CDepGraphPainter::PaintAt(NID nid, int x, int y, CDC * pdc)
{
	CSize size(0,0);

	// what is the size of text?
	GetNidSize(nid, size, pdc);

	// draw box
	pdc->MoveTo(x, y);
	pdc->LineTo(x + size.cx - 1, y);
	pdc->LineTo(x + size.cx - 1, y + size.cy - 1);
	pdc->LineTo(x, y + size.cy - 1);
	pdc->LineTo(x, y);

	CRect rect(x + 1, y + 1, x + size.cx - 1, y + size.cy - 1);

	// text fore + back colors?
	CFileRegEntry * preg = g_FileRegistry.GetRegEntry(((CDepGrNode *)nid)->Frh());
	COLORREF frClr = preg->ExistsOnDisk() ? RGB_TXT_FILEEXISTS : RGB_TXT_FILEMISSING , bkClr = ::GetSysColor(COLOR_BTNFACE);

	// what is the state of this node?
	UINT state = ((CDepGrNode *)nid)->Depstate();

    CString strDepState;
	
	// dependency missing
	if (state & DS_DepMissing)
	{
		bkClr = RGB_BKG_DEPMISSING;
	}
	// out of date
	else if (state & DS_OutOfDate)
	{
		bkClr = RGB_BKG_OUTOFDATE;
	}
    else if (state & DS_ForcedOutOfDate)
    {
        bkClr = RGB_BKG_FORCEDOUTOFDATE;
    }
	// current
	else if (state & DS_Current)
	{
		bkClr = RGB_BKG_CURRENT;
	}

    if (state & DS_DepMissing)
        strDepState += _T("M");
    if (state & DS_OutOfDate)
        strDepState += _T("O");
    if (state & DS_ForcedOutOfDate)
        strDepState += _T("F");
    if (state & DS_Current)
        strDepState += _T("C");

	// dependency set?
	if (preg->IsKindOf(RUNTIME_CLASS(CFileRegSet)))
	{
		frClr = RGB_TXT_DEPENDENCY;
	}

	pdc->SetTextColor(frClr);
	pdc->SetBkColor(bkClr);

	// paint the text

	// get the node text
	CString strText;
	GetNidText(nid, strText);

	const TCHAR * pchText = (const TCHAR *)strText;
	const TCHAR * pch = pchText;

	CSize sizeLine;
	while (*pch != _T('\0'))
	{
		while (*pch != _T('\0') && *pch != ('\n'))
			pch = _tcsinc(pch);

		// paint the text
		pdc->ExtTextOut(x + 2, y + 2, ETO_OPAQUE, rect, pchText, pch - pchText, NULL);

		// what is the size of text?
		sizeLine = pdc->GetTextExtent((LPCTSTR)pchText, pch - pchText);

		// move down a line
		rect.bottom += sizeLine.cy + 2;
		rect.top = rect.bottom;
		y += (sizeLine.cy + 2);	// padding

		if (*pch == _T('\n'))
			pchText = ++pch;
	}

	pchText = (const TCHAR *)strDepState;
    pdc->ExtTextOut(x + 2, y + 2, ETO_OPAQUE, rect, pchText, strDepState.GetLength(), NULL);
}

void CDepGraphPainter::GetNidText(NID nid, CString & strText)
{
	CDepGrNode * pgrn = (CDepGrNode *)nid;
	CFileRegEntry * preg = g_FileRegistry.GetRegEntry(pgrn->Frh());

	CString strFile;

	// get the node text
	if (preg->IsKindOf(RUNTIME_CLASS(CFileRegSet)))
	{
		// dependency set text
		CFileRegSet * pregset = (CFileRegSet *)preg;
		pregset->InitFrhEnum();

		// get an action 'edge'?
		if (pgrn->CParents() > 0)
		{
			CActionSlob * pAction = (CActionSlob *)pgrn->Parent(0)->Edge(0);

			// what kind of set?
			if (preg == pAction->GetScannedDep())
				strText = _T("<Scanned>\n");

			else if (preg == pAction->GetMissingDep())
				strText = _T("<Missing>\n");

			else if (preg == pAction->GetSourceDep())
				strText = _T("<Source>\n");
		}

		FileRegHandle frh;

		// show the names of each dep.
		while ((frh = pregset->NextFrh()) != (FileRegHandle)NULL)
		{
			preg = g_FileRegistry.GetRegEntry(frh);

			const CPath * pFile = preg->GetFilePath();
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif
			
			// display it relative to current directory
			if (!pFile->GetRelativeName(m_dirCur, strFile))
		 		strFile = (const TCHAR *)*pFile;	// failed, just use name

			// sep. lines
			if (!strText.IsEmpty())
				strText += _T('\n');

			strText += strFile;

		}
	}
	else
	{
		// file text is
		// 'name\ntimestamp' or 'name\n<not found>'
		const CPath * pFile = preg->GetFilePath();
		
		// display it relative to current directory
		if (!pFile->GetRelativeName(m_dirCur, strFile))
		 	strFile = (const TCHAR *)*pFile;	// failed, just use name

		strText += strFile;

		// prepare for next line
		strText += _T('\n');

		// append timestamp or '<not found>'
		CString strTime;
		if (preg->ExistsOnDisk() && preg->GetFileTime(strTime))
		{
			strText += strTime;
		}
		else
		{
			strText += "<not found>";
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CGraphWnd

BEGIN_MESSAGE_MAP(CGraphWnd, CWnd)
	//{{AFX_MSG_MAP(CGraphWnd)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CGraphWnd::CGraphWnd(CGraphPainter * ppainter, CNidGraphDoc * pdoc, BOOL fRev, USHORT usDepth)
{
	m_ppainter      = ppainter;
	m_pdoc			= pdoc;
	m_usDepth		= usDepth;
	m_irowVisMin 	= 0;
	m_icolVisMin  	= 0;
    m_icolMac  		= 0;
	m_crowsVis   	= 0;
    m_fReversed		= fRev;
    m_fPositioned	= FALSE;
	m_rgXRight		= NULL;
	m_rgXLeft		= NULL;
	m_rgYTop		= NULL;
	m_play			= NULL;
	m_ptOrig		= CPoint(0,0);
}

CGraphWnd::~CGraphWnd()
// free up all of the secondary allocations that we made on our way out
//
{
	if (m_play)		delete m_play;
	if (m_rgXRight)	delete [] m_rgXRight;
	if (m_rgXLeft)	delete [] m_rgXLeft;
	if (m_rgYTop)	delete [] m_rgYTop;
}

BOOL CGraphWnd::PreCreateWindow(CREATESTRUCT & cs)
{
	if (!CWnd::PreCreateWindow(cs))
		return FALSE;

	return CLayout__FCreate(m_play, m_pdoc, m_usDepth);
}

BOOL CGraphWnd::Create(UINT nID, CRect rect, CWnd * pParentWnd /* = NULL */)
{
	return CWnd::Create(NULL,						// class
						"GraphWnd",					// window name
						WS_CHILD | WS_BORDER | WS_CLIPSIBLINGS,		// style
						(const RECT)rect,			// rect
						pParentWnd,					// parent window
						nID							// id
					   );
}

BOOL CGraphWnd::RefreshGraph()
{
	ASSERT(m_play);
	delete m_play;

	// re-create layout and position nodes
	m_fPositioned = FALSE;
	if (!CLayout__FCreate(m_play, m_pdoc, m_usDepth))
		return FALSE;

	// re-paint
	Invalidate(FALSE);

	return TRUE;
}

void CGraphWnd::GetGraphSize(CSize & size)
{
	// need to position nodes?
	if (!m_fPositioned)
		PositionNodes();

	// size of the graph
	size = CSize(m_icolMac == 0 ? 0 : m_rgXRight[m_icolMac-1], m_irowMac == 0 ? 0 : m_rgYTop[m_irowMac]);
}

void CGraphWnd::SetGraphOrigin(int x, int y)
{
	// ensure within our size range!
	CSize sizeGraph;
	GetGraphSize(sizeGraph);
	
	ASSERT(0 <= x && x <= sizeGraph.cx);
	ASSERT(0 <= y && y <= sizeGraph.cy);

	// calculate our invalid screen areas

	// get our client coord.
	RECT rectInvalid;
	GetClientRect(&rectInvalid);

	int xdiff = x - m_ptOrig.x;
	int ydiff = y - m_ptOrig.y;

	// scroll the window
	if (xdiff || ydiff)
		ScrollWindow(-xdiff, -ydiff);

	// horiz. invalid part
	if (ydiff)
	{
		if (ydiff < 0)
			rectInvalid.bottom = rectInvalid.top - ydiff;
		else
			rectInvalid.top = rectInvalid.bottom - ydiff;

		InvalidateRect(&rectInvalid, FALSE);
	}

	// vert. invalid part
	if (xdiff)
	{
		if (xdiff < 0)
			rectInvalid.right = rectInvalid.left - xdiff;
		else
			rectInvalid.left = rectInvalid.right - xdiff;

		InvalidateRect(&rectInvalid, FALSE);
	}

	// set our origin
	m_ptOrig = CPoint(x, y);
}


void CGraphWnd::OnPaint()
// repaint the dirty portion of the graph
//
{
	// get the window DC?
	CDC * pdc = GetDC();

	// initialise this DC?
	if (pdc == (CDC * )NULL ||
		!m_ppainter->FInitGraphCDC(pdc, FALSE)
	   )
		return;	// failed to initialise

	// position the graph, reset our position based on this new layout
	if (!m_fPositioned)
		PositionNodes();

	// anything to paint?
	if (m_play->CNodesMac() == 0)
		return;	// no

	// set the viewport origin
	pdc->SetViewportOrg(-m_ptOrig.x, -m_ptOrig.y);

	USHORT i, iMac, j, jMac, k, kMac;

	CRect rectClient, rectInvalid;
	GetClientRect(rectClient);
	GetUpdateRect(&rectInvalid);
	rectInvalid.OffsetRect(m_ptOrig);

	pdc->FillRect(rectInvalid, GetSysBrush(COLOR_BTNFACE));

	// compute the number of visible rows
	
	iMac = m_irowMac;

	for (i=0; i<iMac; i++)
		if (m_rgYTop[i] >= rectClient.Height()) break;

	m_crowsVis = i - m_irowVisMin;

	// compute the range of rows which needs to be redrawn
							   
	for (i=m_irowVisMin; i<iMac; i++)
		if (m_rgYTop[i+1] >= rectInvalid.top) break;

	USHORT irowClipMin = i;

	for (; i<iMac; i++)
		if (m_rgYTop[i] > rectInvalid.bottom) break;

	USHORT irowClipMac = i;

	iMac = m_play->IColMac();

	for (i=0; i < iMac-1; i++)
		if (m_rgXLeft[i+1] > 0) break;

	m_icolVisMin = i;

	for (; i < iMac-1; i++)
		if (m_rgXLeft[i+1] >= rectInvalid.left) break;

	USHORT icolClipMin = i;

	for (; i<iMac; i++)
		if (m_rgXLeft[i] > rectInvalid.right) break;

	USHORT icolClipMac = i;

	// redraw all of the columns which are in the clipping rectangle

	for (i = icolClipMin; i < icolClipMac; i++)
	{
		jMac = m_play->CNodesCol(MapCol(i));
		for (j=0; j < jMac; j++)
		{
			CGrNode *pnode = m_play->PnodeAt(MapCol(i),j);
			USHORT row = pnode->IRow();
			NID nid = pnode->Nid();

			if (row < irowClipMin) continue;

			if (row >= irowClipMac) break;

			if (!pnode->FFake())
			{
				int y = (int)(YcoCenter(row) - (pnode->GetSize().cy / 2));
			    int x = m_rgXLeft[i];

				m_ppainter->PaintAt(nid, x, y, pdc);
			}
		}


		// no children for the last column
		if (i >= iMac-1)
			break;

		USHORT colParent = m_fReversed ? i+1 : i;

		jMac = m_play->CNodesCol(MapCol(colParent));

		for (j=0; j < jMac; j++)
		{
			CGrNode *pnode = m_play->PnodeAt(MapCol(colParent),j);
			USHORT row  = pnode->IRow();
			NID nid     = pnode->Nid();

			BOOL fLow  = pnode->IRow() <  irowClipMin;
			BOOL fHigh = pnode->IRow() >= irowClipMac;

			int	cxLen  = 0;

			kMac = pnode->CChildren();

			if (kMac == 0) continue;

			if (!pnode->FFake())
				cxLen = pnode->GetSize().cx;

			// this tests for overflow into the sign bit
			// otherwise our drawing code will try to draw large positive
			// y coordinates in the negative space
			
			// there is some slack here because the y coordinate might be
			// further offset by the painter

			long  lT = YcoCenter(row);
			int   cyBase;

			if (lT >= 0x7f00)
				cyBase = 0x7f00;
			else if (lT <= -0x7f00)
				cyBase = -0x7f00;
			else
				cyBase = (int)lT;

			for (k=0; k < kMac; k++)
			{
				CGrNode *pChild = pnode->Child(k);
				ET	  et	 = pnode->Edge(k);
				row = pChild->IRow();

				if (fLow  && row <  irowClipMin) continue;
				if (fHigh && row >= irowClipMac) continue;

				int cyIn  = 0;
				int cyOut = 0;

				m_ppainter->GetOffsets(pdc, nid, pChild->Nid(), et, cyOut, cyIn);

				int cyParent = cyBase + cyOut;

				// this tests for overflow into the sign bit
				// otherwise our drawing code will try to draw large positive
				// y coordinates in the negative space
				
				// there is some slack here because the y coordinate might be
				// further offset by the painter

				lT = YcoCenter(row);
				int cyChild;

				if (lT >= 0x7f00)
					cyChild = 0x7f00;
				else if (lT <= -0x7f00)
					cyChild = -0x7f00;
				else
					cyChild = (int)lT;

				cyChild += cyIn;

				int x1, x2, x3;
				int y1, y2;

				if (!m_fReversed)
				{
					x1 = m_rgXLeft[colParent] + cxLen;
					x2 = m_rgXRight[colParent];
					x3 = m_rgXLeft[colParent+1];
					y1 = cyParent;
					y2 = cyChild;
				}
				else
				{
					if (!pChild->FFake())
						cxLen = pChild->GetSize().cx;
					else
						cxLen = 0;

					x1 = m_rgXLeft[colParent-1] + cxLen;
					x2 = m_rgXRight[colParent-1];
					x3 = m_rgXLeft[colParent];
					y1 = cyChild;
					y2 = cyParent;
				}

				if (k + pnode->CReversed() >= kMac)
				{
					y1 += 4;
					y2 += 4;
					pdc->MoveTo(x1    , y1    );	
					pdc->LineTo(x1 + 2, y1 + 2);		// draw arrowhead	
					pdc->LineTo(x1 + 2, y1 - 2);
					pdc->LineTo(x1    , y1    );	
				}

				pdc->MoveTo(x1    , y1);
				pdc->LineTo(x2    , y1);
				pdc->LineTo(x3 - 1, y2);
				pdc->LineTo(x3    , y2);
			}
		}
	}

	CWnd::OnPaint();	// pass on to our base instance
}

void CGraphWnd::PositionNodes() 
// each CGrNode has now been placed in a column and assigned a position
// within that column.  Here we determine the widths of our columns
// and rows
//
{
	// got a painter?
	ASSERT(m_ppainter != (CGraphPainter *)NULL);

	// get the graph DC
	CDC * pdc = GetDC();
	ASSERT(pdc != (CDC * )NULL);

	if (!m_ppainter->FInitGraphCDC(pdc, FALSE))
		return;

	// origin point to position relative to
	CPoint pt(m_ptOrig);

	m_ppainter->GetSpacing(pdc, m_cxMinTag, m_cxEdgeSpace,
						  m_xLeftAbs, m_yTopAbs, m_cyFakeHeight);

	m_irowMac  = m_play->IRowMac();
    m_icolMac  = m_play->IColMac();

	pt.x = pt.y = 0;

	if (m_icolMac == 0)
		return;

	m_icolLim  = m_icolMac - 1;

	// FUTURE: place the construction of a wait cursor here

	if ((m_rgXRight = new int[m_icolMac]) == (int *)NULL)
		return;

	if ((m_rgXLeft = new int[m_icolMac]) == (int *)NULL)
		return;

	if ((m_rgYTop = new long[m_irowMac+1]) == (long *)NULL)
		return;

	// initialize out the YTop array
	USHORT i, iMac;
	iMac = m_irowMac+1;
	for (i=0; i<iMac; i++) m_rgYTop[i] = 0;

	USHORT xCur  = m_xLeftAbs;	
	int xNext    = m_xLeftAbs;	

	for (UINT iCol = 0; iCol < m_icolMac; iCol++)
	{
		m_rgXLeft[iCol] = xCur;

		iMac = m_play->CNodesCol(MapCol(iCol));

		for (i = 0; i < iMac; i++)
		{
			CGrNode  *pnode  = m_play->PnodeAt(MapCol(iCol),i);
	
			int xEnd = xCur;

			if (!pnode->FFake())
			{
				CSize size;

				m_ppainter->GetNidSize(pnode->Nid(), size, pdc);

				pnode->SetSize(size);	// cache node size

				if (size.cy > m_rgYTop[pnode->IRow()+1])
					m_rgYTop[pnode->IRow()+1] = size.cy;

				xEnd += size.cx;
			}
			else
			{
				// use metric for height of fake nodes

				if (m_cyFakeHeight > m_rgYTop[pnode->IRow()+1])
					m_rgYTop[pnode->IRow()+1] = m_cyFakeHeight;
			}

			if (xEnd > xNext) xNext = xEnd;
		}
	
		m_rgXRight[iCol] = xNext + m_cxMinTag;  // space after label
		xCur = xNext + m_cxEdgeSpace;		  // space between columns
	}

	m_rgYTop[0] = m_yTopAbs;

	for (USHORT irow = 1; irow <= m_irowMac; irow++)
		m_rgYTop[irow] += m_rgYTop[irow-1];

	// position view so that the correct nodes are initially visible

	CRect rect; GetClientRect(rect);
	int cxSize = rect.Width();

	if (m_fReversed && m_rgXRight[m_icolMac-1] > cxSize)
		pt.x = m_rgXRight[m_icolMac-1] - cxSize + 5;	// 5 is arb buffering

	// if there are any zero height rows at the end of the document, don't both visualizing them...
	// that will just make our scrolling look stupid

	while (m_irowMac > 1 && CyLine(m_irowMac-1) == 0)
		m_irowMac--;

	m_fPositioned = TRUE;
}

CGrNode * CGraphWnd::PnodeSearchBest(USHORT irow, USHORT icol, USHORT icolEnd)
// search for the node closest to the given irow starting from the given
// column and proceeding up to and including the End column
//
// returns only non fake nodes, return NULL if no appropriate node
// could be found
//
{
	CGrNode * pnodeBest = (CGrNode *)NULL;
	USHORT costBest  = 0xffff;

	int dcol = icolEnd > icol ? 1 : -1;

	while (pnodeBest == NULL)
	{
		USHORT inodeMac = m_play->CNodesCol(MapCol(icol));

		for (USHORT inode = 0; inode < inodeMac ; inode++)
		{
			CGrNode *pnodeT = m_play->PnodeAt(MapCol(icol), inode);

			if (!pnodeT->FFake())
			{
				USHORT cost = _abs(pnodeT->IRow() - irow);

				if (cost < costBest)
				{
					costBest  = cost;
					pnodeBest = pnodeT;
				}
			}
		}

		if (icol == icolEnd) break;

		icol += dcol;
	}

	return pnodeBest;
}

CGrNode * CGraphWnd::PnodeSearchCorner
(
	USHORT icolBeg,		// starting column	(cost zero if in this column)
	USHORT irowBeg,		// starting row		(cost zero if in this row)
	USHORT icolEnd,		// ending column
	USHORT irowEnd		// ending row
)
//
// search the graph for the node which is closest to icolBeg, irowBeg
// but the column doesn't exceed icolEnd and the row doesn't exceed irowEnd
// note that icolEnd might be less than icolBeg as can irowEnd
//
{
	// first convert the given beginning and end rows which may not be
	// in the correct order to irowStart and irowStop values which will be
	// sorted.  This allows easy comparison...

	USHORT irowStart, irowStop;

	if (irowBeg < irowEnd)
		{ irowStart = irowBeg; irowStop  = irowEnd; }
	else
		{ irowStart = irowEnd; irowStop  = irowBeg; }

	USHORT	icol = icolBeg;
	int    	dcol = icolBeg < icolEnd ? 1 : -1;
	CGrNode *pnodeBest = (CGrNode *)NULL;
	USHORT 	costBest  = 0xffff;

	for (;;)
	{
		if (_abs(icol - icolBeg) > costBest)
			break;

		USHORT inode;
		USHORT inodeMac = m_play->CNodesCol(MapCol(icol));

		for (inode = 0; inode < inodeMac; inode++)
		{
			CGrNode *pnodeT = m_play->PnodeAt(MapCol(icol), inode);

			if (pnodeT->FFake()) continue;

			USHORT irow = pnodeT->IRow();

			if (irow < irowStart) continue;

			if (irow > irowStop) break;

			USHORT costT = _abs((int)(m_rgYTop[irow] - m_rgYTop[irowBeg])) +
						   _abs(m_rgXLeft[icol] - m_rgXLeft[icolBeg]);

			if (costT < costBest)
			{
				pnodeBest = pnodeT;
				costBest = costT;
			}
		}

		if (icol == icolEnd) break;

		icol += dcol;
	}

	return pnodeBest;
}

USHORT CGraphWnd::IColVisLim()
// return the last visible column
//
{
	CRect rect; GetClientRect(rect);
	CPoint pt(0,0);	// = GetScrollPosition();	// FUTURE:

	USHORT iMac = m_icolMac;

	for (USHORT i = 0; i < iMac; i++)
		if (m_rgXLeft[i] > pt.x + rect.Width()) break;

	ASSERT(i > 0);
							
	return i-1;
}

void CGraphWnd::UpdateVisibleRows()
// compute the number of visible rows
{
	CPoint pt(0,0);	// = GetScrollPosition();	// FUTURE:

	USHORT i, iMac = m_irowMac;

	for (i=0; i<iMac; i++)
		if (m_rgYTop[i] >= pt.y) break;

	// check for bogus origin (pt.y)
	if (i >= iMac)
		return;

	m_irowVisMin = i;	// number of visible rows
}

/////////////////////////////////////////////////////////////////////////////
// CGraphWnd diagnostics

#ifdef _DEBUG
void CGraphWnd::AssertValid() const
{
	CWnd::AssertValid();
}

void CGraphWnd::Dump(CDumpContext& dc) const
{
	CWnd::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CGraphDialog

BEGIN_MESSAGE_MAP(CGraphDialog, CDialog)
	//{{AFX_MSG_MAP(CGraphDialog)
	ON_WM_CREATE()
	ON_WM_DESTROY()	
	ON_WM_HSCROLL()
	ON_WM_VSCROLL()
	ON_BN_CLICKED(IDC_GRAPH_SHOWDEPS, OnShowDeps)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CGraphDialog::CGraphDialog(CGraph * pgraph, CWnd * pParentWnd /* = NULL */) : CDialog(IDD_GRAPH_DIALOG, pParentWnd)
{
	// our graph document
	m_pgraph = pgraph;

	// disable FC
	g_FileRegDisableFC = TRUE;
}

CGraphDialog::~CGraphDialog()
{
	// re=enable FC
	g_FileRegDisableFC = FALSE;
}

BOOL CGraphDialog::OnInitDialog()
{
	if (!CDialog::OnInitDialog())
		return FALSE;	// failure

	// show and resize the graph legend window
	CRect rectPicture;
	GetDlgItem(IDC_GRAPH_LEGEND)->GetWindowRect(rectPicture);
	ScreenToClient(&rectPicture);

	m_pgraphlgnd->SetWindowPos(NULL,
							  rectPicture.left, rectPicture.top,
							  rectPicture.Width(), rectPicture.Height(),
							  SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOACTIVATE);

	// show and resize the graph window
	GetDlgItem(IDC_GRAPH_FRAME)->GetWindowRect(rectPicture);
	ScreenToClient(&rectPicture);
	m_pgraphwnd->SetWindowPos(NULL,
							  rectPicture.left, rectPicture.top,
							  rectPicture.Width(), rectPicture.Height(),
							  SWP_SHOWWINDOW | SWP_NOZORDER | SWP_NOACTIVATE);

	// calc. the scroll metrics
	CalcScrollMetrics();

	// hide show deps. check or init. it's state?
	if (m_pgraph->IsKindOf(RUNTIME_CLASS(CFileDepGraph)))
		((CButton *)GetDlgItem(IDC_GRAPH_SHOWDEPS))->SetCheck(((CFileDepGraph *)m_pgraph)->m_fShowDepSets);
	else
		GetDlgItem(IDC_GRAPH_SHOWDEPS)->ShowWindow(SW_HIDE);

	return TRUE;	// ok
}

int CGraphDialog::OnCreate(LPCREATESTRUCT lpcs)
{
	if (CDialog::OnCreate(lpcs) != 0)
		return -1;

	// get our painter
	m_ppainter = new CDepGraphPainter;

	// get our graph window
	m_pgraphwnd = new CGraphWnd(m_ppainter, m_pgraph, TRUE);
	if (!m_pgraphwnd->Create(16, CRect(0,0,0,0), this))
	{
		delete m_ppainter;
		return -1;
	}

	// get our graph legend
	m_pgraphlgnd = new CGraphLegend;
	if (!m_pgraphlgnd->Create(17, CRect(0,0,0,0), this))
	{
		delete m_ppainter;
		delete m_pgraphwnd;
		return -1;
	}

	return 0;	// ok
}

void CGraphDialog::OnDestroy()
{
	delete m_ppainter;
	delete m_pgraphwnd;
	delete m_pgraphlgnd;
}

void CGraphDialog::CalcScrollMetrics()
{
	// set the ranges for our scroll bars
	// and the line and page sizes
	m_pgraphwnd->GetGraphSize(m_sizeScroll);

	CRect rectPicture;
	GetDlgItem(IDC_GRAPH_FRAME)->GetWindowRect(rectPicture);

	m_line.cx = 16;
	m_line.cy = 32;
	m_page.cx = rectPicture.Width()- m_line.cx;
	m_page.cy = rectPicture.Height() - m_line.cy;
	
	((CScrollBar *)GetDlgItem(IDC_GRAPH_HSCRL))->SetScrollRange(0, m_sizeScroll.cx, FALSE);
	((CScrollBar *)GetDlgItem(IDC_GRAPH_VSCRL))->SetScrollRange(0, m_sizeScroll.cy, FALSE);
}

void CGraphDialog::OnShowDeps()
{
	// global/per-builder check state?
	ASSERT(m_pgraph->IsKindOf(RUNTIME_CLASS(CFileDepGraph)));
	((CFileDepGraph *)m_pgraph)->m_fShowDepSets = ((CButton *)GetDlgItem(IDC_GRAPH_SHOWDEPS))->GetCheck() != 0;

	// refresh the graph
	VERIFY(m_pgraphwnd->RefreshGraph());

	// re-calc. the scroll metrics
	CalcScrollMetrics();
}

void CGraphDialog::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar * pscrlbar)
{
	ASSERT(pscrlbar == GetDlgItem(IDC_GRAPH_HSCRL));
	OnScroll(MAKEWORD(nSBCode, -1), nPos);
}

void CGraphDialog::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar * pscrlbar)
{
	ASSERT(pscrlbar == GetDlgItem(IDC_GRAPH_VSCRL));
	OnScroll(MAKEWORD(-1, nSBCode), nPos);
}

void CGraphDialog::OnScroll(UINT nScrollCode, UINT nPos)
{
	// get current (x,y) position
	int x = ((CScrollBar *)GetDlgItem(IDC_GRAPH_HSCRL))->GetScrollPos();
	int y = ((CScrollBar *)GetDlgItem(IDC_GRAPH_VSCRL))->GetScrollPos();

	switch (LOBYTE(nScrollCode))
	{
		case SB_TOP: x = 0; break;
		case SB_BOTTOM: x = m_sizeScroll.cx; break;
		case SB_THUMBTRACK: x = nPos; break;
		case SB_LINEUP: x -= m_line.cx; break;
		case SB_LINEDOWN: x += m_line.cx; break;
		case SB_PAGEUP: x -= m_page.cx; break;
		case SB_PAGEDOWN: x += m_page.cx; break;
	}

	switch (HIBYTE(nScrollCode))
	{
		case SB_TOP: y = 0; break;
		case SB_BOTTOM: y = m_sizeScroll.cy; break;
		case SB_THUMBTRACK: y = nPos; break;
		case SB_LINEUP: y -= m_line.cy; break;
		case SB_LINEDOWN: y += m_line.cy; break;
		case SB_PAGEUP: y -= m_page.cy; break;
		case SB_PAGEDOWN: y += m_page.cy; break;
	}

	// ensure within bounds
	if (x < 0)
		x = 0;
	else if (x > m_sizeScroll.cx)
		x = m_sizeScroll.cx;

	if (y < 0)
		y = 0;
	else if (y > m_sizeScroll.cy)
		y = m_sizeScroll.cy;

	// perform scroll
	m_pgraphwnd->SetGraphOrigin(x, y);

	// set new (x,y) pos
	((CScrollBar *)GetDlgItem(IDC_GRAPH_HSCRL))->SetScrollPos(x);
	((CScrollBar *)GetDlgItem(IDC_GRAPH_VSCRL))->SetScrollPos(y);
}


#endif // DEPGRAPH_VIEW
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\grview.h ===
// CGraphPainter, CGraphWnd, CGraphDialog
//
// Graph viewer -- given basic information about the graph it causes
// the graph to be layed out and then renders it
//
// [ricom] (modified by [matthewt])

#ifndef _GRVIEW_H
#define _GRVIEW_H

#ifndef _INCLUDE_DEPGRAPH_H
#error Expected depgraph.h to be included before grview.h
#endif

#ifndef DEPGRAPH_VIEW
#error grview.h should only be used if DEPGRAPH_VIEW is defined.
#endif

#ifdef DEPGRAPH_VIEW

#include "layout.h"

////////////////////////////////////////
// CGraphLegend - graph legend window //
////////////////////////////////////////

class CGraphLegend : public CWnd
{
	DECLARE_DYNAMIC(CGraphLegend)
	DECLARE_MESSAGE_MAP()

public:
	CGraphLegend() {}
	virtual ~CGraphLegend() {}

	// create the graph legend
	virtual BOOL Create(UINT nID, CRect rect, CWnd * pParentWnd = (CWnd *)NULL);

protected:
	// message map for window
	//{{AFX_MSG(CGraphLegend)
	virtual	void	OnPaint();
	//}}AFX_MSG
};

/////////////////////////////////////////////////////////////////////////////////
// CGraphPainter - generic protocol for an object that paints nodes for a view //
/////////////////////////////////////////////////////////////////////////////////

class CGraphPainter
{
public:
	CGraphPainter() {}
	virtual ~CGraphPainter() {}

	virtual	BOOL FInitGraphCDC(CDC *, BOOL fErase);

	virtual void GetNidSize(NID, CSize &, CDC *) {}
	virtual void PaintAt(NID, int, int, CDC *) {}
	virtual void PaintAnchor(NID, int, int, int, int, CDC *);
	virtual void PaintSelect(NID, int, int, int, int, CDC *);
	virtual void PaintDeAnchor(NID, int, int, int, int, CDC *);
	virtual void PaintDeSelect(NID, int, int, int, int, CDC *);

	virtual void GetOffsets(CDC *,
							NID nidFrom,
						    NID nidTo,
							ET  et,
							int & cyFromOffset,
						    int & cyToOffset
							);

	virtual void GetSpacing(CDC *,
							int & cxMinTag,		// size of stub arrows go on
							int & cxEdgeSpace,  // space for edges
							int &  xLeftAbs,	// x origin of graph
							int &  yTopAbs,		// y origin of graph
							int & cyFakeHeight  // height of fake nodes
						   );
};

////////////////////////
// CDepGraphPainter   //
////////////////////////

class CDepGraphPainter : public CGraphPainter
{

public:
	CDepGraphPainter() {m_dirCur = g_pActiveProject->GetProjDir();}
	virtual ~CDepGraphPainter() {}

	virtual FInitGraphCDC(CDC *, BOOL);

	virtual void GetNidSize(NID, CSize &, CDC *);
	virtual void PaintAt(NID, int, int, CDC *);

private:
	void GetNidText(NID nid, CString & strText);

	// current directory
	CDir m_dirCur;
};

/////////////////
// CGraphWnd   //
/////////////////

__inline USHORT _abs(int a) {return (a>=0) ? a : -a;}

#define MapCol(col)	(m_fReversed ? (m_icolLim - (col)) : (col))

// return the center point of the given row
#define YcoCenter(row) ((m_rgYTop[(row)] + m_rgYTop[(row)+1])/2)
#define CyLine(irow) ((int)(m_rgYTop[irow+1] - m_rgYTop[(irow)]))

class CGraphWnd : public CWnd
{
	DECLARE_DYNAMIC(CGraphWnd)
	DECLARE_MESSAGE_MAP()

public:
	CGraphWnd(CGraphPainter *, CNidGraphDoc *, BOOL = FALSE, USHORT = 0);
	virtual ~CGraphWnd();

	// create the graph
	virtual BOOL Create(UINT nID, CRect rect, CWnd * pParentWnd = (CWnd *)NULL);

	// get the graph size
	void GetGraphSize(CSize & size);

	// set the origin of the graph
	void SetGraphOrigin(int x, int y);

	// refresh the graph
	BOOL RefreshGraph();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	// message map for window
	//{{AFX_MSG(CGraphWnd)
	virtual	void	OnPaint();
	//}}AFX_MSG

	USHORT			m_usDepth;
	CLayout * 		m_play;
	CGraphPainter *	m_ppainter;
	CNidGraphDoc *	m_pdoc;
	USHORT			m_irowVisMin;
	USHORT			m_icolVisMin;
	USHORT			m_icolMac;
	USHORT			m_icolLim;
	USHORT			m_irowMac;
	USHORT			m_crowsVis;
	BOOL			m_fPositioned;
	BOOL			m_fReversed;
	int				m_xLeftAbs;
	int				m_yTopAbs;
	int				m_cxMinTag;
	int				m_cxEdgeSpace;
	int				m_cyFakeHeight;
	int	*			m_rgXLeft;
	int	*			m_rgXRight;
	long *			m_rgYTop;

	virtual BOOL	PreCreateWindow(CREATESTRUCT & cs);

protected:
	virtual void		PositionNodes();
	virtual USHORT		IColVisLim();
	virtual CGrNode *	PnodeSearchBest(USHORT, USHORT, USHORT);
	virtual CGrNode *	PnodeSearchCorner(USHORT, USHORT, USHORT, USHORT);

private:
	void UpdateVisibleRows();

	// the graph origin
	CPoint m_ptOrig;
};

/////////////////////////////////////////////////////////////////////////////
// CGraphDialog

class CGraphDialog : public CDialog
{
	DECLARE_DYNAMIC(CGraphDialog)
	DECLARE_MESSAGE_MAP()

public:
	CGraphDialog(CGraph * pgraph, CWnd * pParentWnd = NULL);
	virtual ~CGraphDialog();

	virtual BOOL OnInitDialog();

protected:
	//{{AFX_MSG(CGraphDialog)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnDestroy();
	afx_msg void OnHScroll(UINT, UINT, CScrollBar *);
	afx_msg void OnVScroll(UINT, UINT, CScrollBar *);
	afx_msg void OnShowDeps();
	//}}AFX_MSG

	void OnScroll(UINT, UINT);

	// calculate the scroll metrics
	void CalcScrollMetrics();

private:
	// pointer to graph
	CGraph * m_pgraph;

	// window in which to paint graph
	CGraphWnd * m_pgraphwnd;

	// window in which to paint graph legend
	CGraphLegend * m_pgraphlgnd;

	// graph painter
	CGraphPainter * m_ppainter;

	// scroll range
	CSize m_sizeScroll;

	// page size
	CSize m_page;

	// line size
	CSize m_line;
};

#endif // DEPGRAPH_VIEW
#endif // _GRVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\exttarg.h ===
//
// External Target type
//
// [colint]
//
						
#ifndef _INCLUDE_EXTTARGET_H
#define _INCLUDE_EXTTARGET_H

// declare our project types
class CProjTypeExternalTarget : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeExternalTarget)

public:
	CProjTypeExternalTarget(DWORD bsc_id, int nOffset)
		: CProjType(szAddOnGeneric, BCID_ProjType_ExternalTarget + nOffset, /* id */
					IDS_EXTTARG_PROJTYPE, CProjType::exttarget, /* props */
					bsc_id) {} /* our project type platform */

	// create the list of tools we use
	BOOL FInit();

	// Set up the default target options for this project type
	BOOL SetDefaultDebugTargetOptions(CProject * pProject, CTargetItem * pTarget, BOOL fUseMFC);
	BOOL SetDefaultReleaseTargetOptions(CProject * pProject, CTargetItem * pTarget, BOOL fUseMFC);

#ifdef VB_MAKEFILES
	BOOL SetDefaultVBTargetOptions(CProject * pProject, CTargetItem * pTarget, int projType, VBInfo *pVBProj );
#endif

	// External targets have no tools whatsoever (not even the pass through tool!)
	virtual CBuildTool *PickTool(FileRegHandle) { return NULL; }

	int GetAttributes () {  return ImageExe | SubsystemWindows | TargetIsDebugable; }
};


#endif // _INCLUDE_EXTTARGET_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\htmlfile.h ===
//
// CHTMLPageFile
//   CHTMLPageFile represents an HTML file. It's based on CFile.
//   Use this class to perform operations on HTML files.
//				   

#ifndef __HTMLFILE_H__
#define __HTMLFILE_H__

//----------------------------------------------------------------
// CHTMLPageFile
//----------------------------------------------------------------
class CHTMLPageFile: public CFile
{
// ctor/dtor
public:
	CHTMLPageFile();
	~CHTMLPageFile();

// applet block operations
public:
	UINT ReadAppletBlock(LPCSTR pszClassFileName, CString& strAppletBlock);

// param block operations
public:
	UINT ReadParamBlock(LPCSTR pszClassFileName, CString& strParamBlock);

// internal functions
private:
	UINT ReadNextAppletBlock(CString& strHTML, CString& strAppletBlock);
	UINT ReadCodeFileName(CString& strAppletBlock, CString& strCodeFileName);
};

#endif // __HTMLFILE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\exttarg.cpp ===
//
// External Target type
//
// [colint]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "exttarg.h"	// our local header file

IMPLEMENT_DYNAMIC(CProjTypeExternalTarget, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// implementation

BOOL CProjTypeExternalTarget::FInit()
{
	// Tools that we can use.
	// NO TOOLS at all!
 
	return CProjType::FInit();
}

BOOL CProjTypeExternalTarget::SetDefaultDebugTargetOptions(CProject * pProject,  CTargetItem * pTarget, BOOL fUseMFC)
{
	CPath pathT;
	CPath pathTemp;
	CString strProjDir=_TEXT("");

	pathT = *(pProject->GetFilePath());
	pathTemp = pathT;

	// set up per target dir for all the properties
	if (!(pTarget->GetTargDir()).IsEmpty() )
	{
		CDir dirTarg; dirTarg.CreateFromString( pTarget->GetTargDir() );
		CPath path;
		path.CreateFromDirAndFilename( dirTarg,"t");
		strProjDir = GetRelativeName((TCHAR *)(const TCHAR *)path, (TCHAR *)(const TCHAR *)pProject->GetWorkspaceDir());
		strProjDir = strProjDir.Left( strProjDir.GetLength() - 1 );


		// remove the trailing or leading '\\'
		if (!strProjDir.IsEmpty())
		{
			if (strProjDir.GetAt(strProjDir.GetLength()-1) == _T('\\'))
			{
				strProjDir = strProjDir.Left(strProjDir.GetLength()-1);	
			}
			if (!strProjDir.IsEmpty() && strProjDir.GetAt(0) == _T('\\'))
			{
				strProjDir = strProjDir.Right(strProjDir.GetLength()-1);	
			}
		}
	}

	CString str;
	CString strFileName;

	// Set the default properties for the debug configuration:
	str = "NMAKE /f ";

	if (strProjDir.IsEmpty())
	{
		CString strFile = pathT.GetFileName();
		if( strFile.CompareNoCase(_TEXT("makefile")) ){
			pathT.ChangeExtension(".mak");	
		}
		strFileName = pathT.GetFileName();
	}
	else
	{
		strFileName = strProjDir + _TEXT(".mak");
	}

	if (ScanPathForSpecialCharacters(strFileName))
	{
		str += _T('\"');
		str += strFileName;
		str += _T('\"');
	}
	else
	{
		str += strFileName;
	}
	pProject->SetStrProp(P_Proj_CmdLine, str);

	str = "/a";
	pProject->SetStrProp(P_Proj_RebuildOpt, str);

	if (strProjDir.IsEmpty())
	{
 		pathTemp.ChangeExtension(".exe");
		str = pathTemp.GetFileName();
	}
	else
	{
		str = strProjDir + _TEXT("\\");
		str += strProjDir + _TEXT(".exe");
	}
 	pProject->SetStrProp(P_Proj_Targ, str);
	pProject->SetStrProp(P_Caller, str);

	if (strProjDir.IsEmpty())
	{
 		pathTemp.ChangeExtension(".bsc");
		str = pathTemp.GetFileName();
	}
	else
	{
		str = strProjDir + _TEXT("\\");
		str += strProjDir + _TEXT(".bsc");
	}
	pProject->SetStrProp(P_Proj_BscName, str);

	if (strProjDir.IsEmpty())
	{
 		pathTemp.ChangeExtension(".clw");
		str = pathTemp.GetFileName();
	}
	else
	{
		str = strProjDir + _TEXT("\\");
		str += strProjDir + _TEXT(".clw");
	}
	//pProject->SetStrProp(P_ProjClsWzdName, str);

	str = _T("");
	//pProject->SetStrProp(P_Proj_WorkingDir, str);
	pProject->SetStrProp(P_WorkingDirectory, str);
	pProject->SetStrProp(P_Args, str);
	pProject->SetIntProp(P_PromptForDlls, 1);
	pProject->SetStrProp(P_RemoteTarget, str);
 
	return TRUE;
}

BOOL CProjTypeExternalTarget::SetDefaultReleaseTargetOptions(CProject * pProject, CTargetItem * pTarget, BOOL fUseMFC)
{
	// Both debug and release options are equivalent at the moment.
	return SetDefaultDebugTargetOptions(pProject, pTarget, fUseMFC);
}

#ifdef VB_MAKEFILES
BOOL CProjTypeExternalTarget::SetDefaultVBTargetOptions(CProject * pProject,  CTargetItem * pTarget, int projType, VBInfo *pVBProj )
{
	CPath pathT;
	CPath pathTemp;
 	CPath pathOutput;
 
 	CString strProjDir=_TEXT("");

	pathOutput.Create(pVBProj->m_ExeName32);
	pathT = *(pProject->GetFilePath());
	pathTemp = pathT;

	// set up per target dir for all the properties
	if (!(pTarget->GetTargDir()).IsEmpty() )
	{
		CDir dirTarg; dirTarg.CreateFromString( pTarget->GetTargDir() );
		CPath path;
		path.CreateFromDirAndFilename( dirTarg,"t");
		strProjDir = GetRelativeName((TCHAR *)(const TCHAR *)path, (TCHAR *)(const TCHAR *)pProject->GetWorkspaceDir());
		strProjDir = strProjDir.Left( strProjDir.GetLength() - 1 );


		// remove the trailing or leading '\\'
		if (!strProjDir.IsEmpty())
		{
			if (strProjDir.GetAt(strProjDir.GetLength()-1) == _T('\\'))
			{
				strProjDir = strProjDir.Left(strProjDir.GetLength()-1);	
			}
			if (!strProjDir.IsEmpty() && strProjDir.GetAt(0) == _T('\\'))
			{
				strProjDir = strProjDir.Right(strProjDir.GetLength()-1);	
			}
		}
	}

	CString str;
	CString strFileName;

	// Set the default properties for the debug configuration:
	str = "VB5 /make ";

	CString strFile = pathT.GetFileName();
	strFileName = pathT.GetFileName();

	if (ScanPathForSpecialCharacters(strFileName))
	{
		str += _T('\"');
		str += strFileName;
		str += _T('\"');
	}
	else
	{
		str += strFileName;
	}
	pProject->SetStrProp(P_Proj_CmdLine, str);

	str = "";
	pProject->SetStrProp(P_Proj_RebuildOpt, str);

	if( projType == 0 ){
		if (strProjDir.IsEmpty())
		{
			pathTemp.ChangeExtension(".exe");
			if( !pVBProj->m_ExeName32.IsEmpty() )
				str = pathOutput.GetFileName();
			else
				str = pathTemp.GetFileName();
		}
		else
		{
			str = strProjDir + _TEXT("\\");
			str += strProjDir + _TEXT(".exe");
		}
	}
	else if ( projType == 1 ){
		pathTemp.ChangeExtension(".ocx");
		if( !pVBProj->m_ExeName32.IsEmpty() )
			str = pathOutput.GetFileName();
		else
			str = pathTemp.GetFileName();
	}
	else if ( projType == 2 ){
		pathOutput.ChangeExtension(".dll");
		// str = pathTemp.GetFileName();
		str = pathOutput.GetFileName();
	}

	pProject->SetStrProp(P_Proj_Targ, str);

	pProject->SetStrProp(P_Caller, str);


	str = _T("");
	//pProject->SetStrProp(P_Proj_WorkingDir, str);
	pProject->SetStrProp(P_WorkingDirectory, str);
	pProject->SetStrProp(P_Args, str);
	pProject->SetIntProp(P_PromptForDlls, 1);
	pProject->SetStrProp(P_RemoteTarget, str);
 
	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\htmlfile.cpp ===
//
// CHTMLPageFile
//   CHTMLPageFile represents an HTML file. It's based on CFile.
//   Use this class to perform operations on HTML files.
//				   

#include "stdafx.h"

#include "htmlfile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// REVIEW(briancr): some known limitations of this html parsing
// - escape character '\' (?) is not honored (i.e. \>): is this an issue?
// - comments are not honored, except when parsing for <applet>

//----------------------------------------------------------------
// CHTMLPageFile
//----------------------------------------------------------------

CHTMLPageFile::CHTMLPageFile()
{
}

CHTMLPageFile::~CHTMLPageFile()
{
}

UINT CHTMLPageFile::ReadAppletBlock(LPCSTR pszClassFileName, CString& strAppletBlock)
{
	ASSERT_VALID(this);
	// the file must be open in order to read from it
	ASSERT(m_hFile != (UINT)hFileNull);

	strAppletBlock.Empty();

	// read through the file, looking for applet tags
	// when an applet tag is found, check the code= tag for the
	// specified class file

	// read the HTML file into memory

	// get the length of the file
	DWORD dwLen = GetLength();

	// start at the beginning of the file
	SeekToBegin();

	// read the file
	CString strHTMLFile;
	Read(strHTMLFile.GetBuffer(dwLen), dwLen);
	strHTMLFile.ReleaseBuffer();

	// find each applet block and check it for the class file we want
	while (strAppletBlock.IsEmpty() && !strHTMLFile.IsEmpty()) {

		// get the next applet block
		CString strNextAppletBlock;
		ReadNextAppletBlock(strHTMLFile, strNextAppletBlock);

		// get the code file name
		CString strCodeFileName;
		ReadCodeFileName(strNextAppletBlock, strCodeFileName);
		strCodeFileName.MakeLower();

		// get the class file name we're looking for
		CString strClassFileName = pszClassFileName;
		strClassFileName.MakeLower();

		// is the class file name in the code file name?
		if (strCodeFileName.Find(strClassFileName) != -1)
			// copy the applet block
			strAppletBlock = strNextAppletBlock;
	}

	return strAppletBlock.GetLength();
}

UINT CHTMLPageFile::ReadParamBlock(LPCSTR pszClassFileName, CString& strParamBlock)
{
	ASSERT_VALID(this);
	// the file must be open in order to read from it
	ASSERT(m_hFile != (UINT)hFileNull);

	strParamBlock.Empty();

	// get the applet block for the specified class
	CString strAppletBlock;
	ReadAppletBlock(pszClassFileName, strAppletBlock);

	// find each param tag and enter it in the param block
	while (!strAppletBlock.IsEmpty()) {

		// find the next tag
		int nTagBeg = strAppletBlock.Find(_T('<'));
		if (nTagBeg == -1)
			nTagBeg = strAppletBlock.GetLength() - 1;

		// discard HTML up to tag
		strAppletBlock = strAppletBlock.Mid(nTagBeg);

		int nTagEnd = 0;

		// is this a param tag?
		CString strParam = strAppletBlock.Left(6);
		strParam.MakeLower();
		if (strParam == _T("<param")) {

			// find the end of the tag
			int nEndTag = strAppletBlock.Find(_T('>'));
			if (nEndTag == -1)
				nEndTag = strAppletBlock.GetLength() - 1;

			// copy the param block
			strParamBlock += strAppletBlock.Left(nEndTag + 1);
			// separate param tags by newlines
			strParamBlock += _T("\r\n");
		}
		// some other tag--skip it
		else {

			// find the end of the tag
			int nTagEnd = strAppletBlock.Find(_T('>'));
			if (nTagEnd == -1)
				nTagEnd = strAppletBlock.GetLength() - 1;
		}
		// discard HTML through the end of the tag
		strAppletBlock = strAppletBlock.Mid(nTagEnd + 1);
	}

	return strParamBlock.GetLength();
}

UINT CHTMLPageFile::ReadNextAppletBlock(CString& strHTML, CString& strAppletBlock)
{
	strAppletBlock.Empty();

	BOOL bAppletBlockFound = FALSE;
	// read until no more tags or applet block found
	while (!strHTML.IsEmpty() && !bAppletBlockFound) {

		// find the next tag
		int nTagBeg = strHTML.Find(_T('<'));
		if (nTagBeg == -1)
			nTagBeg = strHTML.GetLength() - 1;

		// discard HTML up to tag
		strHTML = strHTML.Mid(nTagBeg);

		// is this a comment tag?
		CString strComment = strHTML.Left(2);
		strComment.MakeLower();
		if (strComment == _T("<!--")) {

			// find the end of the comment
			int nTagEnd = strHTML.Find(_T("-->"));
			if (nTagEnd == -1)
				nTagEnd = strHTML.GetLength() - 1;
			else
				// skip "-->"
				nTagEnd += 3;

			// discard HTML through the end of the comment
			strHTML = strHTML.Mid(nTagEnd + 1);
		}
		// is this an applet tag?
		else {
			CString strApplet = strHTML.Left(7);
			strApplet.MakeLower();
			if (strApplet == _T("<applet")) {

				// find the end of the applet block
				int nTagEnd = 0;

				while (nTagEnd < strHTML.GetLength() - 1 && !bAppletBlockFound) {

					// try to find the end of the applet block
					int nNextTagEnd = strHTML.Mid(nTagEnd).Find(_T("</"));
					if (nNextTagEnd == -1)
						nTagEnd = strHTML.GetLength() - 1;
					else
						// skip "</"
						nTagEnd = nTagEnd + nNextTagEnd + 2;

					// skip white space
					while (nTagEnd < strHTML.GetLength() &&
						(strHTML[nTagEnd] == _T(' ') ||
						strHTML[nTagEnd] == _T('\t') ||
						strHTML[nTagEnd] == _T('\r') ||
						strHTML[nTagEnd] == _T('\n'))) {
						nTagEnd++;
					}

					// ensure we didn't read to the end of the string
					if (nTagEnd < strHTML.GetLength()) {

						// is this the </applet> tag?
						CString strAppletEnd = strHTML.Mid(nTagEnd, 6);
						strAppletEnd.MakeLower();
						if (strAppletEnd == _T("applet")) {

							// skip "applet"
							nTagEnd += 6;

							// find the true end of the applet block (the ">")
							int nTrueEnd = strHTML.Mid(nTagEnd).Find(_T('>'));
							if (nTrueEnd == -1)
								nTrueEnd = strHTML.Mid(nTagEnd).GetLength() - 1;

							// advance the end of the tag to the end
							nTagEnd += nTrueEnd;

							bAppletBlockFound = TRUE;
						}
					}
				}

				// copy the applet block
				strAppletBlock = strHTML.Left(nTagEnd + 1);

				// discard HTML through the end of the applet block
				strHTML = strHTML.Mid(nTagEnd + 1);

				bAppletBlockFound = TRUE;
			}
			// some other tag--skip it
			else {

				// find the end of the tag
				int nTagEnd = strHTML.Find(_T('>'));
				if (nTagEnd == -1)
					nTagEnd = strHTML.GetLength() - 1;
				
				// discard HTML through the end of the tag
				strHTML = strHTML.Mid(nTagEnd + 1);
			}
		}
	}

	return strAppletBlock.GetLength();
}

UINT CHTMLPageFile::ReadCodeFileName(CString& strAppletBlock, CString& strCodeFileName)
{
	strCodeFileName.Empty();

	// find the end of the applet tag ">"
	int nEndTag = strAppletBlock.Find(_T('>'));
	if (nEndTag == -1)
		nEndTag = strAppletBlock.GetLength() - 1;

	// copy the applet tag
	CString strTag = strAppletBlock.Left(nEndTag + 1);

	// lower case the applet tag
	strTag.MakeLower();

	// look for the "code" tag
	int nCodeTag = -1;
	BOOL bDone = FALSE;
	while (!bDone) {

		// look for the "code" tag
		nCodeTag = strTag.Find(_T("code"));

		// did we find the "code" tag?
		if (nCodeTag >= 0) {

			// skip "code"
			nCodeTag += 4;

			// discard applet tag through code tag
			strTag = strTag.Mid(nCodeTag);

			// trim white space
			strTag.TrimLeft();

			// expect '='
			if (strTag[0] == _T('=')) {

				// skip '='
				strTag = strTag.Mid(1);

				// trim white space
				strTag.TrimLeft();

				// we're done
				bDone = TRUE;
			}
		}
		else
			// we're done (and didn't find the code tag)
			bDone = TRUE;
	}

	// did we find a "code" tag?
	if (nCodeTag >= 0) {

		int nEndName;

		// is the name quoted?
		if (strTag[0] == _T('\"')) {

			// skip '"'
			strTag = strTag.Mid(1);

			// find ending quote
			nEndName = strTag.Find(_T('\"'));
			if (nEndName == -1)
				nEndName = strTag.GetLength();
		}
		else {
			// name is not quoted, find ending white space
			nEndName = strTag.FindOneOf(_T(" \r\n\t"));
			if (nEndName == -1)
				nEndName = strTag.GetLength();
		}

		strCodeFileName = strTag.Left(nEndName);
	}

	return strCodeFileName.GetLength();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\makefile.inc ===
!include $(IDE_ROOT)\makefile.inc

vproj.cpp: $(PACKVERCHECK)

$O\vproj.obj: vproj.cpp

$O\$(RCFILE).res: $(RCFILE).rc $(O)\bld.tlb
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\layout.h ===
//
// CLayout
//
// Self-laying out graph class
//
// [ricom] (modified by [matthewt]

#ifndef LAYOUT_H
#define LAYOUT_H

#ifndef _INCLUDE_DEPGRAPH_H
#error Expected depgraph.h to be included before layout.h.
#endif

#ifndef DEPGRAPH_VIEW
#error layout.h should only be used if DEPGRAPH_VIEW is defined.
#endif

#ifdef DEPGRAPH_VIEW

class CNidGraphDoc;
class CLayout
{
	friend BOOL CLayout__FCreate(CLayout * &, CNidGraphDoc *, USHORT);

public:
	CLayout() {}
	virtual ~CLayout();

private:
	CGrNode **		_rgRoots;		// array of root nodes for this graph
	USHORT			_cRoots;		// number of nodes in above array

	USHORT 			_iDepthConst;	// largest depth allowed by user
	USHORT 			_iDepthCur;		// current depth (used while assign depths)
	USHORT 			_iDepthMac;		// largest depth + 1
	USHORT 			_cNodesMac;		// total number of nodes
	USHORT			_iPosMac;		// largest row number
	CMapPtrToPtr 	_mapNodes;		// mapping from NID (ULONG cast to VOID *) to NODE *

	USHORT *		_rgcDepth;	  	// array of depth counts;
	CGrNode *** 	_rgrgNodeCol; 	// columns -- rgrgNodeCol[iDepth][iNode];

	USHORT *		_rgiDepth;	    // array of depth indices
	CNidGraphDoc *	_pngr;       	// graph document that is the source of nodes
	CGrNode **		_rgPnode;	    // main array of pointers to nodes
	CGrNode *		_pnodeHead;		// node at the head of the node list

	CGrNode *		WalkTree(NID);
	void			AdjustDepth(CGrNode *pnode, USHORT iDepth);
	void			InsertFakeNodes(CGrNode *pnode);
	void			CountDepth(CGrNode *pnode);
	void			GroupNodes(CGrNode *pnode);
	void			RegroupNodes(CGrNode *pnode);
	USHORT			Cost(CGrNode *pnode, USHORT iPos);
	void			AttachParents();
	BOOL			FImproveLayout();
	void			SortColumns();
	CGrNode *		PnodeNew(NID nid, USHORT cChildren, USHORT iDepth);
	CGrNode *		PnodeRemoveHead();
	void			ToHeadNode(CGrNode *);	

public:
	__inline USHORT 	IColMac()  				  	{return _iDepthMac;}
	__inline USHORT 	IRowMac()   				{return _iPosMac;}
	__inline USHORT 	CNodesMac() 				{return _cNodesMac;}
	__inline USHORT 	CNodesCol(USHORT col)		{return _rgcDepth[col];}
	__inline CGrNode *	PnodeAt(USHORT i, USHORT j)	{return _rgrgNodeCol[i][j];}
	__inline CGrNode *	PnodeAt(USHORT inode)		{return _rgPnode[inode];} 

	__inline CGrNode *	PnodeAtNid(NID nid)
		{CGrNode * pnode; return _mapNodes.Lookup((void *)nid, (void * &)pnode) ? pnode : (CGrNode *)NULL;}
											  	
	__inline BOOL 		FIncludesNid(NID nid)		{return PnodeAtNid(nid) != (CGrNode *)NULL;}

protected:
	BOOL		FInit(CNidGraphDoc *, USHORT usDepth);
};

#endif // DEPGRAPH_VIEW
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\javadbg.cpp ===
//
// CDebugJavaGeneralPage
//		The general debugger options page for Java projects. This page
//		lets the user enter the class file to debug, the HTML page
//		containing the applet, and/or the parameters to the applet/application.
//
// CParamGridWnd
//		The grid for entering applet parameters.
//				   

#include "stdafx.h"

#include "javadbg.h"
#include "htmlfile.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//----------------------------------------------------------------
// CDebugJavaGeneralPage: the page to handle the general options
//----------------------------------------------------------------

BEGIN_IDE_CONTROL_MAP(CDebugJavaGeneralPage, IDDP_JAVA_DEBUG_GENERAL, IDS_DEBUG_OPTIONS)
	MAP_EDIT(IDC_JAVA_CALLING_PROG, P_Java_ClassFileName)
	MAP_RADIO(IDC_JAVA_USE_BROWSER, IDC_JAVA_USE_STANDALONE, 1, P_Java_DebugUsing)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CDebugJavaGeneralPage, CDebugPageTab)
	//{{AFX_MSG_MAP(CDebugJavaGeneralPage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//----------------------------------------------------------------
// CDebugJavaGeneralPage::OnInitDialog
BOOL CDebugJavaGeneralPage::OnInitDialog()
{
	if ( !COptionMiniPage::OnInitDialog() ) {
		return FALSE;
	}

	return TRUE;
}

//----------------------------------------------------------------
// CDebugJavaGeneralPage::InitPage
void CDebugJavaGeneralPage::InitPage()
{
	COptionMiniPage::InitPage();
}

//----------------------------------------------------------------
// CDebugJavaGeneralPage::CommitPage
void CDebugJavaGeneralPage::CommitPage()
{
	// REVIEW(briancr): do we need to do anything here?
}

//----------------------------------------------------------------
// CDebugJavaGeneralPage::OnPropChange
BOOL CDebugJavaGeneralPage::OnPropChange(UINT idProp)
{
	// we want to enable/disable properties based on property changes

	switch (idProp) {
		case P_Java_ClassFileName: {

			OnChangeClassFileName();

			break;
		}
		case P_Java_DebugUsing: {

			OnChangeDebugUsing();

			break;
		}
	}

	// call our base-class
	return CDebugPageTab::OnPropChange(idProp);
}

//----------------------------------------------------------------
// CDebugJavaGeneralPage::Validate
BOOL CDebugJavaGeneralPage::Validate()
{
	return CDebugPageTab::Validate();
}

void CDebugJavaGeneralPage::OnChangeClassFileName()
{
	// we don't allow the user to enter a path or .class extension
	// (other extensions are allowed because we can't tell the
	// difference between the extension in java.lang.String and
	// an invalid extension)

	// get the class name
	CString strClassName;
	m_pSlob->GetStrProp(P_Java_ClassFileName, strClassName);

	// split the class name into parts
	// (and eliminate any path that's entered)
	TCHAR szFileName[_MAX_PATH];
	TCHAR szExt[_MAX_EXT];
	_tsplitpath(strClassName, NULL, NULL, szFileName, szExt);

	// remove the extension if it's .class
	CString strNewClassName;
	if (_tcscmp(szExt, _T(".class")) == 0) {

		strNewClassName = CString(szFileName);
	}
	else {

		strNewClassName = CString(szFileName) + CString(szExt);
	}

	// only set the class name prop if the new class name is different
	if (strNewClassName != strClassName) {

		// set the class name prop
		m_pSlob->SetStrProp(P_Java_ClassFileName, strNewClassName);
	}
}

void CDebugJavaGeneralPage::OnChangeDebugUsing()
{
	// when the user changes debug using (selects browser or stand-alone),
	// we need to set other properties

	// if debug using browser:
	//   - if P_Java_ParamSource is unknown:
	//       - if P_Java_HTMLPage contains a valid page:
	//           - set P_Java_ParamSource to Java_ParamSource_HTMLPage
	//             (get the params from the HTML page)
	//       - if P_Java_HTMLPage does not contain a page:
	//           - set P_Java_ParamSource to Java_ParamSource_User
	//             (get the params from the user)

	// get debug using
	int nDebugUsing = Java_DebugUsing_Unknown;
	GPT gptDebugUsing = m_pSlob->GetIntProp(P_Java_DebugUsing, nDebugUsing);

	if (gptDebugUsing != ambiguous && nDebugUsing == Java_DebugUsing_Browser) {

		// get the param source
		int nParamSource = Java_ParamSource_Unknown;
		GPT gptParamSource = m_pSlob->GetIntProp(P_Java_ParamSource, nParamSource);

		// only change P_Java_ParamSource if it's not ambiguous and is unknown
		if (gptParamSource != ambiguous && nParamSource == Java_ParamSource_Unknown) {

			// first, set the param source to be the HTML page
			m_pSlob->SetIntProp(P_Java_ParamSource, Java_ParamSource_HTMLPage);

			// get the HTML page
			CString strHTMLPage;
			m_pSlob->GetStrProp(P_Java_HTMLPage, strHTMLPage);

			// if the HTML page is empty, set the param source to be the param grid (user)
			if (strHTMLPage.IsEmpty()) {

				// set the param source
				m_pSlob->SetIntProp(P_Java_ParamSource, Java_ParamSource_User);
			}
		}
	}
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage: the page to handle the browser options
//----------------------------------------------------------------

BEGIN_IDE_CONTROL_MAP(CDebugJavaBrowserPage, IDDP_JAVA_DEBUG_BROWSER, IDS_JAVA_PAGE_BROWSER)
	MAP_EDIT(IDC_JAVA_BROWSER, P_Java_Browser)
	MAP_RADIO(IDC_JAVA_USE_HTML_PARAMS, IDC_JAVA_USE_USER_PARAMS, 1, P_Java_ParamSource)
	MAP_EDIT(IDC_JAVA_HTML_PAGE, P_Java_HTMLPage)
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CDebugJavaBrowserPage, CDebugPageTab)
	//{{AFX_MSG_MAP(CDebugJavaBrowserPage)
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
	ON_CONTROL(GN_CHANGE, IDC_JAVA_PARAMS, OnChangeParamGrid)
END_MESSAGE_MAP()

//----------------------------------------------------------------
// CDebugJavaBrowserPage::OnInitDialog
BOOL CDebugJavaBrowserPage::OnInitDialog()
{
	if ( !CDebugPageTab::OnInitDialog() ) {
		return FALSE;
	}

	// init grid
	m_pgridParams = new CParamGridWnd;
	BOOL fRet = m_pgridParams->ReplaceControl(this, IDC_JAVA_PARAMS_HOLDER, IDC_JAVA_PARAMS,
		WS_VISIBLE | WS_CHILD | WS_BORDER | WS_VSCROLL | WS_TABSTOP, 0, GRIDWND_TB_ALL, TRUE);

	return TRUE;
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::OnDestroy
void CDebugJavaBrowserPage::OnDestroy()
{
	delete m_pgridParams;
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::InitPage
void CDebugJavaBrowserPage::InitPage()
{
	CDebugPageTab::InitPage();

	// Show the grid
	m_pgridParams->ShowWindow(SW_SHOW);
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::CommitPage
void CDebugJavaBrowserPage::CommitPage()
{
	// REVIEW(briancr): do we need to do anything here?
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::OnPropChange
BOOL CDebugJavaBrowserPage::OnPropChange(UINT idProp)
{
	// we want to enable/disable properties based on property changes

	switch (idProp) {
		case P_Java_Browser: {

			OnChangeBrowser();

			break;
		}
		case P_Java_HTMLPage: {

			UpdateParamGrid();

			break;
		}
		// user has changed the param source
		case P_Java_ParamSource: {

			OnChangeParamSource();

			break;
		}
	}

	// call our base-class
	return CDebugPageTab::OnPropChange(idProp);
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::Validate
BOOL CDebugJavaBrowserPage::Validate()
{
	if (m_pgridParams->AcceptControl())
	{
		OnChangeParamGrid();
	}
	return CDebugPageTab::Validate();
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::OnChangeBrowser
void CDebugJavaBrowserPage::OnChangeBrowser()
{
	// remove any quotes around the browser name

	// get the browser's name
	CString strBrowser;
	if (m_pSlob->GetStrProp(P_Java_Browser, strBrowser) == valid) {

		CString strNewBrowser = strBrowser;

		// trim white space
		strNewBrowser.TrimLeft();
		strNewBrowser.TrimRight();

		// only look for quotes if the string is not empty
		if (!strNewBrowser.IsEmpty()) {

			// is the first character a quote?
			if (strNewBrowser[0] == _T('\"')) {

				// trim it
				strNewBrowser = strNewBrowser.Mid(1);
			}
			
			// is the last character a quote?
			int nLen = strNewBrowser.GetLength();
			if (strNewBrowser[nLen-1] == _T('\"')) {

				// trim it
				strNewBrowser = strNewBrowser.Left(nLen-1);
			}

			// only set the browser property if it's different
			if (strNewBrowser != strBrowser) {

				m_pSlob->SetStrProp(P_Java_Browser, strNewBrowser);
			}
		}
	}
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::OnChangeParamGrid
void CDebugJavaBrowserPage::OnChangeParamGrid()
{
	// we'll only set the arg properties if the param source is not ambiguous
	// and the current args are not ambiguous
	// this prevents the configuration b's args from overwriting configuration a's args

	// get the param source
	int nParamSource = Java_ParamSource_Unknown;
	GPT gptParamSource = m_pSlob->GetIntProp(P_Java_ParamSource, nParamSource);
	if (gptParamSource != ambiguous && nParamSource != Java_ParamSource_Unknown) {

		// get the args to find out if they're ambiguous
		CString strCurrentHTMLArgs;
		if (m_pSlob->GetStrProp(P_Java_HTMLArgs, strCurrentHTMLArgs) != ambiguous) {

			// get the args from the grid
			CString strHTMLArgs = m_pgridParams->GetParamsAsHTML();

			// set the HTML style args
			m_pSlob->SetStrProp(P_Java_HTMLArgs, strHTMLArgs);
		}
	}
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::OnChangeParamSource
void CDebugJavaBrowserPage::OnChangeParamSource()
{
	// enable/disable controls based on the param source

	// if the param source is unknown (only initially):
	//   - disable HTML page
	//   - disable param grid
	// if the param source is HTML page:
	//   - enable HTML page
	//   - enable and read-only param grid
	//   - read the HTML page and fill the grid
	// if the param source is user:
	//   - disable HTML page
	//   - enable param grid

	// get the param source
	int nParamSource = Java_ParamSource_Unknown;
	GPT gptParamSource = m_pSlob->GetIntProp(P_Java_ParamSource, nParamSource);

	// enable/disable HTML page
	CDebugPageTab::OnPropChange(P_Java_HTMLPage);
	CWnd* pControl = (CWnd*)GetDlgItem(IDC_JAVA_HTML_PAGE_TXT);
	ASSERT(pControl != NULL);
	pControl->EnableWindow(gptParamSource != ambiguous && nParamSource == Java_ParamSource_HTMLPage);

	// enable/disable param grid
	m_pgridParams->EnableWindow(gptParamSource != ambiguous && nParamSource != Java_ParamSource_Unknown);
	m_pgridParams->SetReadOnly(gptParamSource != ambiguous && nParamSource == Java_ParamSource_HTMLPage);
	m_pgridParams->Invalidate();

	// update the param grid
	UpdateParamGrid();
}

//----------------------------------------------------------------
// CDebugJavaBrowserPage::UpdateParamGrid
void CDebugJavaBrowserPage::UpdateParamGrid()
{
	// get the param source
	int nParamSource = Java_ParamSource_Unknown;
	GPT gptParamSource = m_pSlob->GetIntProp(P_Java_ParamSource, nParamSource);

	CString strParams;

	// only read the params from the HTML page, if the HTML page is the param source
	if (gptParamSource != ambiguous && nParamSource == Java_ParamSource_HTMLPage) {

		// read the params from the HTML page and fill the grid

		// get the HTML page
		CString strHTMLPage;
		m_pSlob->GetStrProp(P_Java_HTMLPage, strHTMLPage);
		if (!strHTMLPage.IsEmpty()) {

			// get the class file name
			CString strClassFileName;
			m_pSlob->GetStrProp(P_Java_ClassFileName, strClassFileName);

			// is there a class file specified?
			if (!strClassFileName.IsEmpty()) {

				// attempt to read params from the page
				CPath pathClass;
				pathClass.Create(strClassFileName);
				strClassFileName = pathClass.GetFileName();

				// open the HTML file
				CHTMLPageFile fileHTML;
				if (fileHTML.Open(strHTMLPage, CFile::modeRead)) {

					// read params from page
					fileHTML.ReadParamBlock(strClassFileName, strParams);

					fileHTML.Close();
				}
			}
		}
	}
	// otherwise fill the param grid from the props
	else if (gptParamSource != ambiguous && nParamSource == Java_ParamSource_User) {

		// get the params
		m_pSlob->GetStrProp(P_Java_HTMLArgs, strParams);
	}

	// fill the param grid
	m_pgridParams->SetParamsFromHTML(strParams);
}

//----------------------------------------------------------------
// CDebugJavaStandalonePage: the page to handle the stand-alone options
//----------------------------------------------------------------

BEGIN_IDE_CONTROL_MAP(CDebugJavaStandalonePage, IDDP_JAVA_DEBUG_STANDALONE, IDS_JAVA_PAGE_STANDALONE)
	MAP_EDIT(IDC_JAVA_STANDALONE, P_Java_Standalone)
	MAP_EDIT(IDC_JAVA_STANDALONE_ARGS, P_Java_StandaloneArgs)
	MAP_EDIT(IDC_JAVA_PROG_ARGS, P_Java_Args)
#ifdef STANDALONE_APPLET
	MAP_RADIO(IDC_JAVA_STANDALONE_APPLET, IDC_JAVA_STANDALONE_APP, 1, P_Java_DebugStandalone)
#endif
END_IDE_CONTROL_MAP()

BEGIN_MESSAGE_MAP(CDebugJavaStandalonePage, CDebugPageTab)
	//{{AFX_MSG_MAP(CDebugJavaStandalonePage)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//----------------------------------------------------------------
// CDebugJavaStandalonePage::OnInitDialog
BOOL CDebugJavaStandalonePage::OnInitDialog()
{
	if ( !CDebugPageTab::OnInitDialog() ) {
		return FALSE;
	}

	return TRUE;
}

//----------------------------------------------------------------
// CDebugJavaStandalonePage::InitPage
void CDebugJavaStandalonePage::InitPage()
{
	CDebugPageTab::InitPage();
}

//----------------------------------------------------------------
// CDebugJavaStandalonePage::CommitPage
void CDebugJavaStandalonePage::CommitPage()
{
	// REVIEW(briancr): do we need to do anything here?
}

//----------------------------------------------------------------
// CDebugJavaStandalonePage::OnPropChange
BOOL CDebugJavaStandalonePage::OnPropChange(UINT idProp)
{
	// we want to enable/disable properties based on property changes

	switch (idProp) {
		case P_Java_Standalone: {

			OnChangeStandalone();

			break;
		}
	}

	// call our base-class
	return CDebugPageTab::OnPropChange(idProp);
}

//----------------------------------------------------------------
// CDebugJavaStandalonePage::Validate
BOOL CDebugJavaStandalonePage::Validate()
{
	return CDebugPageTab::Validate();
}

//----------------------------------------------------------------
// CDebugJavaStandalonePage::OnChangeStandalone
void CDebugJavaStandalonePage::OnChangeStandalone()
{
	// remove any quotes around the stand-alone interpreter name

	// get the interpreter's name
	CString strStandalone;
	if (m_pSlob->GetStrProp(P_Java_Standalone, strStandalone) == valid) {

		CString strNewStandalone = strStandalone;

		// trim white space
		strNewStandalone.TrimLeft();
		strNewStandalone.TrimRight();

		// only look for quotes if the string is not empty
		if (!strNewStandalone.IsEmpty()) {

			// is the first character a quote?
			if (strNewStandalone[0] == _T('\"')) {

				// trim it
				strNewStandalone = strNewStandalone.Mid(1);
			}
			
			// is the last character a quote?
			int nLen = strNewStandalone.GetLength();
			if (strNewStandalone[nLen-1] == _T('\"')) {

				// trim it
				strNewStandalone = strNewStandalone.Left(nLen-1);
			}

			// only set the browser property if it's different
			if (strNewStandalone != strStandalone) {

				m_pSlob->SetStrProp(P_Java_Standalone, strNewStandalone);
			}
		}
	}

#ifdef STANDALONE_APPLET
	// update P_Java_DebugStandalone
	CDebugPageTab::OnPropChange(P_Java_DebugStandalone);
#endif
}

//----------------------------------------------------------------
// CDebugJavaAddlClasses: page for handling additional classes
//----------------------------------------------------------------

BEGIN_IDE_CONTROL_MAP(CDebugJavaAddlClassesPage, IDDP_JAVA_DEBUG_ADDL_CLASSES, IDS_JAVA_DEBUG_ADDL_CLASSES)
	MAP_CHECK(IDC_LOAD_DLL_PROMPT, P_PromptForDlls)
END_IDE_CONTROL_MAP()

//----------------------------------------------------------------
// CDebugJavaAddlClassesPage::OnInitDialog
BOOL CDebugJavaAddlClassesPage::OnInitDialog()
{
	CRect rc;
	HBLDTARGET hTarget;
	CString str;

	if ( !COptionMiniPage::OnInitDialog() ) {
		return FALSE;
	}

	// Get the correct location for the grid
	CWnd *pReplace = GetDlgItem(IDC_GRID_HOLDER);
	ASSERT(pReplace != NULL);

	// Init GridList
	g_BldSysIFace.InitTargetEnum();
	while ((hTarget = g_BldSysIFace.GetNextTarget(str)) != NO_TARGET)
	{
		GRIDINFO *pGI = new GRIDINFO;

		pGI->hTarget = hTarget;
		pGI->pGrid = new CAddlClassesGridWnd;
		BOOL fRet = pGI->pGrid->ReplaceControl(this, IDC_GRID_HOLDER, IDC_DLLS_LIST,
			WS_VISIBLE | WS_CHILD | WS_BORDER | WS_VSCROLL | WS_TABSTOP, 0, GRIDWND_TB_NEWDEL, FALSE);
		
		pGI->pGrid->AddRow(new CAddlClassesGridRow((CAddlClassesGridWnd*)pGI->pGrid));

		pGI->pGrid->ShowWindow(SW_HIDE);
		m_GridList.AddTail(pGI);
	}

	// HACK - If the project file is an exe, we won't get any targets
	if (m_GridList.IsEmpty())
	{
		ASSERT( ((CProxySlob *)m_pSlob)->IsSingle() );

		GRIDINFO *pGI = new GRIDINFO;
		hTarget = g_BldSysIFace.GetTarget(((CProxySlob *)m_pSlob)->GetBaseConfig()->GetConfigurationName(), ACTIVE_BUILDER);

		pGI->hTarget = hTarget;
		pGI->pGrid = new CAddlClassesGridWnd;
		
		BOOL fRet = pGI->pGrid->ReplaceControl(this, IDC_GRID_HOLDER, IDC_DLLS_LIST,
			WS_VISIBLE | WS_CHILD | WS_BORDER | WS_VSCROLL | WS_TABSTOP, 0, GRIDWND_TB_NEWDEL, FALSE);
		
		pGI->pGrid->AddRow(new CAddlClassesGridRow((CAddlClassesGridWnd*)pGI->pGrid));

		pGI->pGrid->ShowWindow(SW_HIDE);
		m_GridList.AddTail(pGI);
	}

	m_pGridActive = ((GRIDINFO *)m_GridList.GetHead())->pGrid;

	// Load info from src package (which got it from the vcp file)
	InitGrids();

	// and kill the holder window
	pReplace->DestroyWindow();

	return TRUE;
}

#if 0 // can't browse for .class files
//----------------------------------------------------------------
// CDebugJavaAddlClassesPage:: OnBrowse
void CDebugJavaAddlClassesPage::OnBrowse()
{
	// set up browse dialog
	CFileDialog dlg(TRUE);

	// browse dialog title
	CString strDlgTitle;
	VERIFY(strDlgTitle.LoadString(IDS_JAVA_BROWSE_CLASS));
	dlg.m_ofn.lpstrTitle = strDlgTitle;

	// browse dialog attributes
    dlg.m_ofn.Flags |= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY | OFN_NONETWORKBUTTON;

	// browse dialog filters
	CString strClassFilter;
	VERIFY(strClassFilter.LoadString(IDS_JAVA_FILTER_CLASS));
	CString strFilter;
	AppendFilterSuffix(strFilter, dlg.m_ofn, strClassFilter);
	dlg.m_ofn.lpstrFilter = strFilter;
	dlg.m_ofn.nFilterIndex = 1;

	// bring up the browse dialog
	if (dlg.DoModal() == IDOK) {

		// get the name of the class specified
		CString strLocalClass = dlg.GetPathName();

		// fill in the grid
		CEdit* pEdit = (CEdit*)m_pGridActive->GetDlgItem(1);
		ASSERT(pEdit != NULL);
		pEdit->SetWindowText(strLocalClass);
		pEdit->SetSel(0, -1);
		pEdit->SetFocus();
	}
}
#endif

//----------------------------------------------------------------
// CDebugJavaAddlClassesPage::InitGrids
void CDebugJavaAddlClassesPage::InitGrids()
{
	if (g_VPROJIdeInterface.Initialize()) 	// make sure we are initialised!
	{
		POSITION pos = m_GridList.GetHeadPosition();
		while (pos != NULL)
		{
			GRIDINFO *pGI = (GRIDINFO *)m_GridList.GetNext(pos);

			// Add blank rows to the grid for the src package to fill in.			
			int cRows;
			g_VPROJIdeInterface.GetDLLInfo()->GetDLLCount((ULONG)pGI->hTarget, &cRows);
			for (int i=0; i < cRows; i++)
			{
				pGI->pGrid->AddRow(new CAddlClassesGridRow((CAddlClassesGridWnd*)(pGI->pGrid)));
			}

			CPtrList listDLLs;
			// get the DLL info...
			g_VPROJIdeInterface.GetDLLInfo()->InitDLLList((ULONG)pGI->hTarget, listDLLs);

			int iRow = 0;
			POSITION pos = listDLLs.GetHeadPosition();
			while (pos != NULL)
			{
				DLLREC *pDLLRec = (DLLREC *)listDLLs.GetNext(pos);
				// The last row will always be a new row
				CDLLGridRow *pRow = (CDLLGridRow *)pGI->pGrid->GetRow(iRow++);
				pRow->m_fPreload		= pDLLRec->fPreload;
				pRow->m_strLocalName	= pDLLRec->strLocalName;
				pRow->m_strRemoteName	= pDLLRec->strRemoteName;
			}
		}
	}
}

//----------------------------------------------------------------
// CDebugJavaAddlClassesPage::InitPage
void CDebugJavaAddlClassesPage::InitPage()
{
	// call the base class's InitPage
	CDebugAdditionalDllPage::InitPage();

	// set the local name column to be a fixed full width
	// (i.e. hide remote name column)

	// figure out the width minus the preload column
	CRect rectCaptionRow;
	m_pGridActive->GetCaptionRow()->GetRect(rectCaptionRow);
	int cxName = rectCaptionRow.Width() - m_pGridActive->GetColumnWidth(COL_PRELOAD);

	// set the width of the local name column and fix it
	m_pGridActive->SetColumnWidth(COL_LOCALNAME, cxName);
	m_pGridActive->GetCaptionRow()->SetColumnFixedWidth(COL_LOCALNAME);

	// set the width of the remote name column
	m_pGridActive->SetColumnWidth(COL_REMOTENAME, 0);

	m_pGridActive->ResetSize();
	m_pGridActive->Invalidate(FALSE); // INEFFICIENT
	m_pGridActive->ResetScrollBars();
}

//----------------------------------------------------------------
// Java: grid control window for handling parameters
//----------------------------------------------------------------

IMPLEMENT_DYNAMIC(CParamGridWnd, CGridControlWnd)

BEGIN_MESSAGE_MAP(CParamGridWnd, CGridControlWnd)
	//{{AFX_MSG_MAP(CGridControlWnd)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_PAINT()
	ON_WM_KILLFOCUS()
	ON_WM_GETDLGCODE()
	ON_BN_CLICKED(ID_GRD_NEW, OnGridNew)
	ON_BN_CLICKED(ID_GRD_DELETE, OnGridDelete)
	ON_BN_CLICKED(ID_GRD_MOVEUP, OnGridMoveUp)
	ON_BN_CLICKED(ID_GRD_MOVEDOWN, OnGridMoveDown)
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	ON_WM_LBUTTONUP()
	ON_WM_KEYDOWN()
	ON_WM_SIZE()
	ON_WM_SYSKEYDOWN()
	ON_WM_MOUSEMOVE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//----------------------------------------------------------------
// CParamGridWnd::CParamGridWnd
CParamGridWnd::CParamGridWnd(int nColumns, BOOL bDisplayCaption)
: CGridControlWnd(nColumns, bDisplayCaption),
  m_bReadOnly(FALSE)
{
	// no sorting needed for params
	EnableSort(FALSE);
	EnableAutoSort(FALSE);

	// no multi selection
	EnableMultiSelect(FALSE);

	// enable drag n drop
	m_bEnableDragRow = TRUE;

	// set up read-only grid colors
	// (toggled by changing m_bSysDefaultColors)
	m_colorWindowText = GetSysColor(COLOR_WINDOWTEXT);
	m_colorWindow = GetSysColor(COLOR_BTNFACE);
	m_colorHighlight = GetSysColor(COLOR_HIGHLIGHT);
	m_colorHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);

	// add one row (the add row)
	AddRow(new CParamGridRow(this));
}

//----------------------------------------------------------------
// CParamGridWnd::~CParamGridWnd
CParamGridWnd::~CParamGridWnd()
{
	// CGridWnd's dtor destroys the rows
}

//----------------------------------------------------------------
// CParamGridWnd::OnGridNew
afx_msg void CParamGridWnd::OnGridNew()
{
	// only process this event if we're not read-only
	if (!m_bReadOnly) {
		// activate the new row
		CGridRow* pSelRow = GetTailRow();
		if (pSelRow != NULL) {
			Select(pSelRow);
			// Auto-activate the edit box in the Name column
			ActivateNextControl();
		}	

		CGridControlWnd::OnGridNew();
	}
}

//----------------------------------------------------------------
// CParamGridWnd::OnGridDelete
afx_msg void CParamGridWnd::OnGridDelete()
{
	// only process this event if we're not read-only
	if (!m_bReadOnly) {
		if (m_pActiveElement == NULL) {
			DoRowDelete();
		}
		CGridControlWnd::OnGridDelete();
	}
}

//----------------------------------------------------------------
// CParamGridWnd::OnGridMoveUp
afx_msg void CParamGridWnd::OnGridMoveUp()
{
	// only process this event if we're not read-only
	if (!m_bReadOnly) {
		// if either of these asserts fire, this function needs to be
		// fixed to deal with multiple selection
		ASSERT(m_selection.GetCount() == 1);

		DoRowMove(GetRowIndex((CParamGridRow*)GetRowAt(m_posCurRow)) - 1);
	}
}

//----------------------------------------------------------------
// CParamGridWnd::OnGridMoveDown
afx_msg void CParamGridWnd::OnGridMoveDown()
{
	// only process this event if we're not read-only
	if (!m_bReadOnly) {
		// if either of these asserts fire, this function needs to be
		// fixed to deal with multiple selection
		ASSERT(m_selection.GetCount() == 1);

		DoRowMove(GetRowIndex((CParamGridRow*)GetRowAt(m_posCurRow)) + 1);
	}
}

//----------------------------------------------------------------
// CParamGridWnd::OnCreate
afx_msg int CParamGridWnd::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CGridControlWnd::OnCreate(lpCreateStruct) == -1)
		return -1;

	// set the grid's captions
	CString strColCaption;
	VERIFY(strColCaption.LoadString(IDS_JAVA_PARAM_COL_NAME));
	SetColumnCaption(CParamGridRow::GRID_COL_NAME, strColCaption);
	VERIFY(strColCaption.LoadString(IDS_JAVA_PARAM_COL_VALUE));
	SetColumnCaption(CParamGridRow::GRID_COL_VALUE, strColCaption);

	// set the column width
	CRect rectGrid;
	GetCaptionRow()->GetRect(rectGrid);
	SetColumnWidth(CParamGridRow::GRID_COL_NAME, rectGrid.Width() / 2);
	SetColumnWidth(CParamGridRow::GRID_COL_VALUE, rectGrid.Width() / 2);

	// select the first row
	Select(GetRow(0));

	return 0;
}

//----------------------------------------------------------------
// CParamGridWnd::OnDestroy
afx_msg void CParamGridWnd::OnDestroy()
{
	CGridControlWnd::OnDestroy();
}

//----------------------------------------------------------------
// CParamGridWnd::OnPaint
void CParamGridWnd::OnPaint() 
{
	// do normal painting if we're enabled
	if (IsWindowEnabled()) {

		// if we're read-only, adjust the colors before painting
		if (m_bReadOnly) {
			// we set up the read-only colors at construction time
			// now we'll just use m_bSysDefaultColors to toggle
			// between the system colors and our read-only colors
			m_bSysDefaultColors = FALSE;
		}

		// paint
		CGridControlWnd::OnPaint();

		// if we're read-only, toggle back to system colors
		if (m_bReadOnly) {
			m_bSysDefaultColors = TRUE;
		}
	}
	else {

		// we're disabled or read-only

		CPaintDC dc(this);
		CGridRow* pRow;
		CRect rowRect;
		GetClientRect(rowRect);

		// Draw the captions first
		pRow = GetCaptionRow();
		rowRect.bottom = rowRect.top + pRow->GetRowHeight();
		if (dc.m_ps.rcPaint.top < rowRect.bottom)
		{
			CFont* pOldFont = dc.SelectObject(GetCaptionFont());
			pRow->Draw(&dc, rowRect);
			dc.SelectObject(pOldFont);
		}
	
		// Setup clip rect around the actual grid (client less captions)
		rowRect.top = rowRect.bottom;
		rowRect.bottom = dc.m_ps.rcPaint.bottom;

		dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
		dc.ExtTextOut(0, 0, ETO_OPAQUE, rowRect, NULL, 0, NULL);
	}
}

//----------------------------------------------------------------
// CParamGridWnd::DoDragDrop
void CParamGridWnd::DoDragDrop(CPoint point)
{
	// figure out where we're dropping the selected row(s)

	// convert the point to an element
	CGridElement* pElement = ElementFromPoint(point);
	// if the point doesn't convert, then drop after the last row
	if (pElement == NULL) {
		CGridRow* pRow = (CGridRow*)m_rows.GetTail();
		if (pRow == NULL)
			return;

		pElement = pRow->ElementFromPoint(point);
	}

	// at this point, the element must not be NULL
	ASSERT(pElement != NULL);

	// get the row from the element
	CGridRow* pRow = pElement->GetRow();

	// we can't insert in the caption row
	if (pRow == GetCaptionRow())
		return;

	// move the selected row(s) to the new position
	DoRowMove(GetRowIndex((CParamGridRow*)pRow));
}

//----------------------------------------------------------------
// CParamGridWnd::OnGetDlgCode
afx_msg UINT CParamGridWnd::OnGetDlgCode()
{
	return CGridControlWnd::OnGetDlgCode() | DLGC_WANTARROWS | DLGC_WANTCHARS;
}

//----------------------------------------------------------------
// CParamGridWnd::ProcessKeyboard
BOOL CParamGridWnd::ProcessKeyboard(MSG* pMsg, BOOL bPreTrans /*= FALSE*/)
{
	// determine the type of message
	switch (pMsg->message) {
		case WM_KEYDOWN: {
			// determine the key pressed
			switch (pMsg->wParam) {
				case VK_TAB: {
					// control-tab is mdi window switching
					if (GetKeyState(VK_CONTROL) < 0)
						break;

					// if there's no active element and we're in a dialog, don't do anything
					if (m_pActiveElement == NULL && m_bParentIsDialog)
						break;

					// we're finished with the current control
					if (!AcceptControl(FALSE))
						return TRUE;

					// tab to the next (prev) control
					if (GetKeyState(VK_SHIFT) < 0)
						ActivatePrevControl();
					else
						ActivateNextControl();

					return TRUE;
				}
				case VK_RETURN: {
					// if there's an active element, then accept the changes,
					// and select the next row
					if (m_pActiveElement != NULL && (GetKeyState(VK_CONTROL) >= 0)) {
						AcceptControl();
						// get the next row
						POSITION posNextRow = m_posCurRow;
						GetNextRow(posNextRow);
						// select the next row
						if (posNextRow != NULL) {
							Select(GetRowAt(posNextRow));
						}
						
						return TRUE;
					}
					break;
				}
				case VK_UP: {
					// Alt+Up moves the row up one
					if (GetKeyState(VK_MENU) < 0) {
						OnGridMoveUp();
						return TRUE;
					}
					break;
				}
				case VK_DOWN: {
					// Alt+Down moves the row down one
					if (GetKeyState(VK_MENU) < 0) {
						OnGridMoveDown();
						return TRUE;
					}
					break;
				}
			}

			break;
		}
	}

	return CGridControlWnd::ProcessKeyboard(pMsg, bPreTrans);
}

//----------------------------------------------------------------
// CParamGridWnd::OnCmdMsg
BOOL CParamGridWnd::OnCmdMsg(UINT nID, int nCode, void *pExtra, AFX_CMDHANDLERINFO *pHandlerInfo)
{
	return CGridControlWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

//----------------------------------------------------------------
// CParamGridWnd::OnKillFocus
void CParamGridWnd::OnKillFocus(CWnd* pNewWnd)
{
	// call the base class
	CGridControlWnd::OnKillFocus(pNewWnd);

	// send grid change notification
	GridChange();
}

//----------------------------------------------------------------
// CParamGridWnd::DoRowMove
void CParamGridWnd::DoRowMove(int nToIndex)
{
	// the index to move the selected rows to must be valid
	if (nToIndex >= GetRowCount() - 1)			// -1 because of new row
		nToIndex = GetRowCount() - 2;			// -2 because of new row

	if (nToIndex < 0)
		return;

	// Notify the grid window of these moves
	// the grid can cancel any or all of the row moves
	CParamGridRow** pMoveRows = new CParamGridRow*[m_selection.GetCount()];
	int cMove = 0;

	// go through all selected rows and notify the grid of the move
	int nDest = nToIndex;
	for (POSITION posSel = GetHeadSelPosition(); posSel != NULL; ) {

		// get the row to move
		CParamGridRow* pSelRow = (CParamGridRow*)GetNextSel(posSel);

		// don't move the new row
		if (pSelRow->IsNewRow()) {
			Deselect(pSelRow);
		}
		else {

			// get the index of the row to move
			int nSrcIndex = GetRowIndex(pSelRow);

			// notify the grid that this row is moving; if the grid
			// returns FALSE, don't move the row
			if (!OnRowMove(nSrcIndex, nDest++)) {
				Deselect(pSelRow);
				nDest--;
			}
			else {
				// store the row in our array of rows to move
				pMoveRows[cMove++] = pSelRow;
			}
		}
	}

	// remove the selected rows
	for (posSel = GetHeadSelPosition(); posSel != NULL; ) {

		// get the row to remove
		CParamGridRow* pSelRow = (CParamGridRow*)GetNextSel(posSel);

		// Remove the row from the grid
		POSITION pos = m_rows.Find(pSelRow);
		ASSERT(pos != NULL);

		// update m_posTopVisibleRow if the row we're about to delete is the
		// top visible row
		if (m_posTopVisibleRow == pos) {

			// make the previous row the top visible row
			GetPrevRow(m_posTopVisibleRow);

			// we don't want to make the caption row the visible row
			if (m_posTopVisibleRow != NULL && (GetRowAt(m_posTopVisibleRow) == GetCaptionRow())) {
				m_posTopVisibleRow = NULL;
				m_cyScroll = 0;
			}
		}

		// remove the row
		m_rows.RemoveAt(pos);
	}

	// move each row from our temp list into the grid's list of rows

	// figure the starting row to insert after
	POSITION posTarget = m_rows.FindIndex(nToIndex);
	ASSERT(posTarget != NULL);
	for (int iCur = 0; iCur < cMove; iCur++) {
		posTarget = m_rows.InsertAfter(posTarget, pMoveRows[iCur]);
	}

	// delete the array of moved rows
	delete [] pMoveRows;

	// repaint
	AdjustTopVisible();
	ResetSize(); // INEFFICIENT
	Invalidate(FALSE); // INEFFICIENT
	ResetScrollBars();

	// scroll the first row in the selection into view
	// get the first row in the selection list
	POSITION posSelHead = GetHeadSelPosition();
	CGridRow* pSelRow = (posSelHead == NULL) ? NULL : (CGridRow*) GetNextSel(posSelHead);
	if (pSelRow != NULL) {
		// scroll this row into view
		ScrollIntoView(pSelRow);
	}

	// if no rows are selected, select the "new" row
	if (m_selection.IsEmpty()) {
		CParamGridRow* pRow = GetTailRow();
		if (pRow != NULL)
			Select(pRow);
	}

	// send grid change notification
	GridChange();
}

//----------------------------------------------------------------
// CParamGridWnd::OnRowMove
BOOL CParamGridWnd::OnRowMove(int nSrcIndex, int nDestIndex)
{
	return TRUE;
}

//----------------------------------------------------------------
// CParamGridWnd::DoRowDelete
void CParamGridWnd::DoRowDelete()
{
	// don't try to delete anything with an empty selection list
	if (m_selection.IsEmpty())
		return;

	// figure out the row to select after the deletion is done: it should be
	// the row after the first element in the selection list
	POSITION posNewSel = NULL;

	// go through the selection list and delete all selected rows
	for (POSITION posSel = GetHeadSelPosition(); posSel != NULL; ) {

		// get the selected row
		CParamGridRow* pSelRow = (CParamGridRow*)GetNextSel(posSel);

		// if we're deleting the last selected row, the selected row should
		// be the row following the last selected node
		if (posSel == NULL) {
			posNewSel = m_rows.Find(pSelRow);
			m_rows.GetNext(posNewSel);
		}

		// don't delete the last row (the add row)
		if (!pSelRow->IsNewRow()) {

			// delete the row
			RemoveRow(pSelRow);
			delete pSelRow;
		}
		else {

			// deselect the last row, since you can't delete it
			Deselect(pSelRow);
		}
	}

	// Redraw
	Invalidate(FALSE);
	ResetScrollBars();

	// if there's no row to select, default to the last row in the grid
	if (posNewSel == NULL)
		posNewSel = GetTailRowPosition();

	// Set the selection
	CGridControlRow* pSelRow = (CGridControlRow*)GetRowAt(posNewSel);
	// this row should not be the caption row
	ASSERT((CGridRow*)pSelRow != (CGridRow*)GetCaptionRow());

	SetActiveElement(pSelRow);
	Select(pSelRow);

	// send grid change notification
	GridChange();
}

//----------------------------------------------------------------
// CParamGridWnd::GetCurSel
int CParamGridWnd::GetCurSel()
{
	// we should have exactly one item selected
	if (m_selection.GetCount() != 1)
		return -1;
	return GetRowIndex((CParamGridRow*)GetRowAt(m_posCurRow));
}

//----------------------------------------------------------------
// CParamGridWnd::GetRowIndex
int CParamGridWnd::GetRowIndex(const CParamGridRow* pRow) const
{
	// iterate through the rows until the one given is found
	int nIndex = 0;
	for (POSITION pos = GetHeadRowPosition(); pos != NULL; nIndex++) {
		if ((CParamGridRow*)GetNextRow(pos) == pRow)
			return nIndex;
	}

	return -1;
}

//----------------------------------------------------------------
// CParamGridWnd::SetReadOnly
inline void CParamGridWnd::SetReadOnly(BOOL bReadOnly)
{
	m_bReadOnly = bReadOnly;

	if (m_bReadOnly) {
		// no selection for a read-only grid
		// go through selection list and deselect everything
		for (POSITION posSel = GetHeadSelPosition(); posSel != NULL; ) {
			CParamGridRow* pSelRow = (CParamGridRow*)GetNextSel(posSel);
			Deselect(pSelRow);
		}
	}
}

//----------------------------------------------------------------
// CParamGridWnd::IsReadOnly
inline BOOL CParamGridWnd::IsReadOnly()
{
	return m_bReadOnly;
}

//----------------------------------------------------------------
// CParamGridWnd::GetTailRow
inline CParamGridRow* CParamGridWnd::GetTailRow() const
{
	if (m_rows.IsEmpty())
		return NULL;
	return (CParamGridRow*)m_rows.GetTail();
}

//----------------------------------------------------------------
// CParamGridWnd::GetTailRowPosition
inline POSITION CParamGridWnd::GetTailRowPosition() const
{
	return m_rows.GetTailPosition();
}

//----------------------------------------------------------------
// CParamGridWnd::GetTailSelPosition
inline POSITION CParamGridWnd::GetTailSelPosition() const
{
	return m_selection.GetTailPosition();
}

//----------------------------------------------------------------
// CParamGridWnd::SetParamsFromHTML
inline void CParamGridWnd::SetParamsFromHTML(LPCSTR pszHTMLParams)
{
	if (m_strHTMLParams != CString(pszHTMLParams)) {
		m_strHTMLParams = pszHTMLParams;
		SetGridFromHTML(m_strHTMLParams);
		CParamGridRow* pRow = (CParamGridRow*)GetRowAt(GetTailRowPosition());
		SetActiveElement(pRow);
		Select(pRow);
	}

	// send grid change notification
	GridChange();
}

//----------------------------------------------------------------
// CParamGridWnd::GetParamsAsHTML
inline CString CParamGridWnd::GetParamsAsHTML()
{
	m_strHTMLParams = GetHTMLFromGrid();
	return m_strHTMLParams;
}

//----------------------------------------------------------------
// CParamGridWnd::GetParamsAsCmdLine
inline CString CParamGridWnd::GetParamsAsCmdLine()
{
	return GetCmdLineFromGrid();
}

//----------------------------------------------------------------
// CParamGridWnd::DeleteAllRows
void CParamGridWnd::DeleteAllRows()
{
	// delete all rows (even the new row)

	for (POSITION posRow = GetHeadRowPosition(); posRow != NULL; ) {
		// get the row to delete
		CParamGridRow* pRow = (CParamGridRow*)GetNextRow(posRow);
		RemoveRow(pRow, FALSE);
	}
}

//----------------------------------------------------------------
// CParamGridWnd::SetGridFromHTML
void CParamGridWnd::SetGridFromHTML(LPCSTR pszParams)
{
	// this function expects the parameter string to be in the
	// HTML applet parameter format:
	// <param name="param name" value="param value">

	// delete everything in the grid
	DeleteAllRows();

	CString strParams = pszParams;
	CString strName;
	CString strValue;

	// read each param line from the string until there are no more
	BOOL bMore = TRUE;
	while (bMore) {

		// get a param line (<param ...>)
		bMore = GetParamLine(strParams, strName, strValue);

		// if either the name or value has a value, enter it in the grid
		if (!strName.IsEmpty() || !strValue.IsEmpty()) {

			// create a row for this param
			CParamGridRow* pNewRow = new CParamGridRow(this);
			pNewRow->SetColumnText(CParamGridRow::GRID_COL_NAME, strName);
			pNewRow->SetColumnText(CParamGridRow::GRID_COL_VALUE, strValue);

			// add this row
			AddRow(pNewRow);
		}
	}

	// add the new row
	AddRow(new CParamGridRow(this));
}

//----------------------------------------------------------------
// CParamGridWnd::GetHTMLFromGrid
CString CParamGridWnd::GetHTMLFromGrid()
{
	CString strParams;
	CString strFormat;
	strFormat.LoadString(IDS_JAVA_PARAMS_AS_HTML);

	// go through each row in the grid and generate params for it
	for (POSITION posRow = GetHeadRowPosition(); posRow != NULL; ) {

		CParamGridRow* pRow = (CParamGridRow*)GetNextRow(posRow);

		// don't generate params for the new row
		if (!pRow->IsNewRow()) {

			// get name and value for the row
			CString strName;
			CString strValue;
			pRow->GetColumnText(CParamGridRow::GRID_COL_NAME, strName);
			pRow->GetColumnText(CParamGridRow::GRID_COL_VALUE, strValue);

			// generate params
			CString strParam;
			strParam.Format(strFormat, strName, strValue);

			strParams += strParam;
		}
	}

	return strParams;
}

//----------------------------------------------------------------
// CParamGridWnd::GetCmdLineFromGrid
CString CParamGridWnd::GetCmdLineFromGrid()
{
	CString strParams;

	// go through each row in the grid and generate a command line from it
	for (POSITION posRow = GetHeadRowPosition(); posRow != NULL; ) {

		CParamGridRow* pRow = (CParamGridRow*)GetNextRow(posRow);

		// don't generate any cmd line args for the new row
		if (!pRow->IsNewRow()) {

			// get the name and value for the row
			CString strName;
			CString strValue;
			pRow->GetColumnText(CParamGridRow::GRID_COL_NAME, strName);
			pRow->GetColumnText(CParamGridRow::GRID_COL_VALUE, strValue);
			// trim white space from name and value
			strName.TrimLeft();
			strName.TrimRight();
			strValue.TrimLeft();
			strValue.TrimRight();

			// append the name
			strParams += strName;

			// if name and value are both not empty, put an equal
			// sign between them, so params are name=value format
			if (!strName.IsEmpty() && !strValue.IsEmpty()) {
				strParams += _T("=");
			}

			// append the value
			strParams += strValue;

			// add a space to separate params
			strParams += _T(" ");
		}
	}

	// trim trailing white space
	strParams.TrimRight();

	return strParams;
}

//----------------------------------------------------------------
// CParamGridWnd::GridChange
void CParamGridWnd::GridChange()
{
	// send a GN_CHANGE message to the parent
	WPARAM wParam = (WPARAM)MAKELONG(GetDlgCtrlID(), GN_CHANGE);
	ASSERT(LOWORD(wParam) != 0);
	LPARAM lParam = (LPARAM)GetSafeHwnd();
	ASSERT(lParam != 0);
	CWnd* pParent = GetParent();
	ASSERT(pParent != NULL);

	pParent->SendMessage(WM_COMMAND, wParam, lParam);
}

//----------------------------------------------------------------
// CParamGridWnd::GetParamLine
BOOL CParamGridWnd::GetParamLine(CString& strParams, CString& strName, CString& strValue)
{
	strName.Empty();
	strValue.Empty();

	CString strNameToken;
	CString strValueToken;

	// the param line is in the format:
	// <param name="name" value="value">

	// sets of tokens to skip while extracting the name and value
	TCHAR* pszSkipTokens1[] = { _T("<"), _T("param"), _T("name"), _T("="), NULL, _T("\""), NULL };
	TCHAR* pszSkipTokens2[] = { _T("value"), _T("="), NULL, _T("\""), NULL };
	TCHAR* pszSkipTokens3[] = { _T(">"), NULL };

	// skip all initial tokens
	if (SkipTokens(strParams, pszSkipTokens1)) {

		// get the name
		if (GetQuotedString(strParams, strNameToken)) {

			// skip all tokens between name and value
			if (SkipTokens(strParams, pszSkipTokens2)) {

				// get the value
				if (GetQuotedString(strParams, strValueToken)) {

					// skip all ending tokens
					if (SkipTokens(strParams, pszSkipTokens3)) {

						strName = strNameToken;
						strValue = strValueToken;

						return TRUE;
					}
				}
			}
		}
	}

	return FALSE;
}

//----------------------------------------------------------------
// CParamGridWnd::SkipTokens
BOOL CParamGridWnd::SkipTokens(CString& strString, TCHAR* pszSkipTokens[])
{
	// skip all tokens given
	for (int i = 0; pszSkipTokens[i] != NULL; i++) {

		// remove any leading white space
		strString.TrimLeft();

		// get the length of the expected token
		int nTokenLen = _tcslen(pszSkipTokens[i]);
		// extract what we expect to be the token
		CString strToken = strString.Left(nTokenLen);
		// lower case the token
		strToken.MakeLower();
		// is this the token we expect?
		if (strToken != pszSkipTokens[i]) {

			// token not found
			return FALSE;
		}

		// skip the token
		strString = strString.Mid(nTokenLen);
	}

	return TRUE;
}

//----------------------------------------------------------------
// CParamGridWnd::GetQuotedString
BOOL CParamGridWnd::GetQuotedString(CString& strString, CString& strValue)
{
	int nEndName = -1;

	// the string may or may not really be quoted
	if (strString[0] == _T('\"')) {

		// find ending quote
		// + 2 to include beginning and ending quote
		nEndName = strString.Mid(1).Find(_T('\"')) + 2;
		// if we didn't find the end of the value, assume
		// the end of the string is the end of the value
		if (nEndName < 2)
			nEndName = strString.GetLength();
	}
	else {
		// name is not quoted, find ending white space
		nEndName = strString.FindOneOf(_T(" \r\n\t>"));
		// if we didn't find the end of the value, assume
		// the end of the string is the end of the value
		if (nEndName == -1)
			nEndName = strString.GetLength();
	}

	// copy the value out of the string
	strValue = strString.Left(nEndName);

	// discard the value from the string
	strString = strString.Mid(nEndName);

	return TRUE;
}

void CParamGridWnd::OnRButtonDown(UINT nFlags, CPoint point)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		CGridControlWnd::OnRButtonDown(nFlags, point);
}

void CParamGridWnd::OnRButtonUp(UINT nFlags, CPoint point)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		CGridControlWnd::OnRButtonUp(nFlags, point);
}

void CParamGridWnd::OnLButtonDown(UINT nFlags, CPoint point)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		CGridControlWnd::OnLButtonDown(nFlags, point);
}

void CParamGridWnd::OnLButtonDblClk(UINT nFlags, CPoint point)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		CGridControlWnd::OnLButtonDblClk(nFlags, point);
}

void CParamGridWnd::OnLButtonUp(UINT nFlags, CPoint point)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		CGridControlWnd::OnLButtonUp(nFlags, point);
}

void CParamGridWnd::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		CGridControlWnd::OnKeyDown(nChar, nRepCnt, nFlags);
}

void CParamGridWnd::OnSize(UINT nType, int cx, int cy)
{
	// override OnSize to fix bug in CGridWnd::OnSize
	// the bug is that when SetActiveElement in CGridWnd::OnSize
	// is called, the column should be specified as m_nCurColumn.
	// Rather than make this change for all grids, which is slightly
	// risky, we'll just do it for the param grid

	CGridElement* pActiveElement = m_pActiveElement;

	SetActiveElement(NULL);
	
	// call the base class
	CGridControlWnd::OnSize(nType, cx, cy);

	if (pActiveElement != NULL)
		SetActiveElement(pActiveElement, m_nCurColumn);
}

void CParamGridWnd::OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		CGridControlWnd::OnSysKeyDown(nChar, nRepCnt, nFlags);
}

void CParamGridWnd::OnMouseMove(UINT nFlags, CPoint point)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		CGridControlWnd::OnMouseMove(nFlags, point);
}

BOOL CParamGridWnd::OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult)
{
	// only process this event if we're not read-only
	if (!m_bReadOnly)
		return CGridControlWnd::OnToolTipText(nID, pNMHDR, pResult);
	return FALSE;
}

//----------------------------------------------------------------
// CParamGridRow: row for handling parameters
//----------------------------------------------------------------

//----------------------------------------------------------------
// CParamGridRow::CParamGridRow
CParamGridRow::CParamGridRow(CParamGridWnd* pGrid)
: CGridControlRow(pGrid)
{
}

//----------------------------------------------------------------
// CParamGridRow::~CParamGridRow
CParamGridRow::~CParamGridRow()
{
}

//----------------------------------------------------------------
// CParamGridRow::DrawCell
// Need to override DrawCell in order to draw the focus rectangle in the
// name column of the last row (the "new" row)
void CParamGridRow::DrawCell(CDC *pDC, const CRect& cellRect, int nColumn)
{
	// let the base class actually draw the cell
	CGridControlRow::DrawCell(pDC, cellRect, nColumn);

	// only draw the focus rect if the grid is not read-only
	if (!((CParamGridWnd*)GetGrid())->IsReadOnly()) {
		// Draw a focus rect in the name column of the new row
		if (IsNewRow() && nColumn == GRID_COL_NAME) {
			// adjust the focus rect for margins
			CRect rectText = cellRect;
			AdjustForMargins(rectText, nColumn);

			pDC->DrawFocusRect(rectText);
		}
	}
}

//----------------------------------------------------------------
// CParamGridRow::OnActivate
void CParamGridRow::OnActivate(BOOL bActivate, int nColumn)
{
	// are we activating a column?
	if (bActivate && nColumn >= 0) {

		// create an edit control in the column
		CreateControl(edit, nColumn, ES_AUTOHSCROLL);
	}
	else {

		// deactivating: remove the control from the column
		CreateControl(none, -1);
	}
}

//----------------------------------------------------------------
// CParamGridRow::OnAccept
BOOL CParamGridRow::OnAccept(CWnd* pControlWnd)
{
	CParamGridWnd* pGrid = GetParamGrid();
	int nCol = pGrid->m_nControlColumn;

	// store the text the user entered into the column
	CString str;
	if (pControlWnd != NULL) {
		switch (pGrid->m_nControlColumn) {
			case GRID_COL_NAME:
				pControlWnd->GetWindowText(str);
				QuoteString(str);
				m_strName = str;
				break;

			case GRID_COL_VALUE:
				pControlWnd->GetWindowText(str);
				QuoteString(str);
				m_strValue = str;
				break;

			default:
				// should only be name or value columns
				ASSERT(FALSE);
				break;
		}
	}

	// If the user has deleted the name and value, remove the row
	// (but don't ever delete the last row - it's the "new" row)
	if (!IsNewRow() && (m_strName.IsEmpty() && m_strValue.IsEmpty())) {

		// only the current row will be selected, so DoDelete will
		// just delete one row
		GetParamGrid()->DoRowDelete();
		return TRUE;
	}

	// if the user has entered something in the last row (the "new" row),
	// create a new "new" row
	if (IsNewRow() && !str.IsEmpty()) {

		pGrid->AddRow(new CParamGridRow(pGrid));
		// Make sure the new row is added at the tail
		ASSERT(pGrid->GetTailRow() != this);
	}

	return TRUE;
}

//----------------------------------------------------------------
// CParamGridRow::ResetSize
void CParamGridRow::ResetSize(CDC* pDC)
{
	// get the text metrics
	TEXTMETRIC tm;
	pDC->GetTextMetrics(&tm);
	// set the row height
	m_cyHeight = tm.tmHeight + tm.tmExternalLeading + 3;
}

//----------------------------------------------------------------
// CParamGridRow::GetColumnText
void CParamGridRow::GetColumnText(int nColumn, CString& str)
{
	// get the text for given column
	switch (nColumn) {
		case GRID_COL_NAME:
			str = m_strName;
			break;
		case GRID_COL_VALUE:
			str = m_strValue;
			break;
		default:
			// should only be name or value columns
			ASSERT(FALSE);
	}
}

//----------------------------------------------------------------
// CParamGridRow::SetColumnText
void CParamGridRow::SetColumnText(int nColumn, LPCSTR pszValue)
{
	// set the text for the given column
	switch (nColumn) {
		case GRID_COL_NAME:
			m_strName = pszValue;
			break;
		case GRID_COL_VALUE:
			m_strValue = pszValue;
			break;
		default:
			// should only be name or value columns
			ASSERT(FALSE);
	}
}

//----------------------------------------------------------------
// CParamGridRow::GetParamGrid
inline CParamGridWnd* CParamGridRow::GetParamGrid()
{
	return (CParamGridWnd*)GetGrid();
}

//----------------------------------------------------------------
// CParamGridRow::IsNewRow
inline BOOL CParamGridRow::IsNewRow()
{
	return (GetParamGrid()->GetTailRow() == this);
}

//----------------------------------------------------------------
// CParamGridRow::QuoteString
void CParamGridRow::QuoteString(CString& str)
{
	// if the given string contains white space and is not quoted,
	// put quotes around it

	// search the string for white space
	if (str.FindOneOf(_T(" \t\n\r")) != -1) {

		// is the string already quoted?
		int nLen = str.GetLength();
		if (str[0] != _T('\"') || str[nLen-1] != _T('\"')) {

			// put quotes around the string
			str = _T("\"") + str + _T("\"");
		}
	}
}

//----------------------------------------------------------------
// CAddlClassesGridWnd: grid control window for handling addl classes
//----------------------------------------------------------------

// NOTE: there are really only two columns for the additional classes grid.
// Having three makes the derivation from CDLLGridWnd much simpler. We'll just
// fix the size of the second column so you never see the third.
CAddlClassesGridWnd::CAddlClassesGridWnd(int nColumns /*= 3*/, BOOL bDisplayCaption /*= TRUE*/)
: CDLLGridWnd(nColumns, bDisplayCaption)
{
	// No browsing for classes.
	m_bEnableEllipse = FALSE;
}

//----------------------------------------------------------------
// CAddlClassesGridRow: grid row for handling addl classes
//----------------------------------------------------------------

CAddlClassesGridRow::CAddlClassesGridRow(CAddlClassesGridWnd* pGridWnd, CAddlClassesGridRow* pParent /*= NULL*/)
: CDLLGridRow(pGridWnd, pParent)
{
}

void CAddlClassesGridRow::GetColumnText(int nColumn, CString& rStr)
{
	switch (nColumn) {
		case COL_LOCALNAME:
			rStr = m_strLocalName;
			// Remove path and .class extension.
			if (!rStr.IsEmpty()) {
				CString strClassExt;
				VERIFY(strClassExt.LoadString(IDS_JAVA_CLASS_EXT));
				TCHAR szFileName[_MAX_FNAME];
				TCHAR szExt[_MAX_EXT];
				_tsplitpath(rStr, NULL, NULL, szFileName, szExt);
				CString strExt = CString(szExt);
				strExt.MakeLower();
				if (strExt == strClassExt) {
					*szExt = _T('\0');
				}
				rStr = CString(szFileName) + CString(szExt);
			}
			break;

		default:
			CDLLGridRow::GetColumnText(nColumn, rStr);
			break;
	}		
}

void CAddlClassesGridRow::OnActivate(BOOL bActivate, int nColumn)
{
	if (bActivate) {
		switch (nColumn) {
			case COL_LOCALNAME:
				GetDLLGrid()->m_bEnableEllipse = FALSE;
				CreateControl(edit, nColumn, ES_AUTOHSCROLL);
				break;

			default:
				CDLLGridRow::OnActivate(bActivate, nColumn);
				break;
		}
	}
	else {
		CDLLGridRow::OnActivate(bActivate, nColumn);
	}
}

BOOL CAddlClassesGridRow::OnAccept(CWnd *pControlWnd)
{
	CString str;
	CAddlClassesGridWnd *pGrid = (CAddlClassesGridWnd*)GetDLLGrid();
	int nCol = pGrid->m_nControlColumn;

	if (pControlWnd != NULL)
	{
		switch ( pGrid->m_nControlColumn ) 
		{
			case COL_PRELOAD:
				GetDLLGrid()->SetFocus();
				break;

			case COL_LOCALNAME:
				pControlWnd->GetWindowText(str);
				m_strLocalName = str;
				break;

			case COL_REMOTENAME:
				pControlWnd->GetWindowText(str);
				m_strRemoteName = str;
				break;

			default:
				ASSERT(FALSE);
				break;
		}
	}

	// If the user has deleted both the local and remote name, remove the row
	// (but don't ever delete the last row - it's the "new" row)
	if (this != pGrid->GetLastRow() &&
		(nCol == COL_LOCALNAME || nCol == COL_REMOTENAME) &&
		(m_strRemoteName.IsEmpty() && m_strLocalName.IsEmpty()) 
	) {

		// only the current row will be selected
		GetDLLGrid()->DoDelete();
		return TRUE;
	}

	if (this == pGrid->GetLastRow()
			&& (nCol == COL_LOCALNAME || nCol == COL_REMOTENAME)
			&& !str.IsEmpty() ) {

		pGrid->AddRow(new CAddlClassesGridRow((CAddlClassesGridWnd*)pGrid));
		// Make sure the new row is added at the tail
		ASSERT( pGrid->GetLastRow() != this );
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\layout.cpp ===
//
// CLayout
// 
// simple minded layout code
//
// given an object from which we can get the "shape" of the tree
// we lay out each of the nodes in generic row column positions.
// The coordinates are generic, we only assume that any given column
// is of constant width and any given row of constant height (just
// like in a spreadsheet for instance)
// 
// the output is a row-column assignment for each node in the graph
// plus some dummy nodes which are introduce to make the graph look nicer
//
// [ricom] (modified by [matthewt]

#include "stdafx.h"
#pragma hdrstop

#ifdef DEPGRAPH_VIEW

#include "layout.h"	// local header file

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

BOOL CLayout__FCreate(CLayout * & playout, CNidGraphDoc * pngr, USHORT usDepth)
// create a CLayout object, defer initialization to FInit method
//
{
	if ((playout = new CLayout) == (CLayout *)NULL)
		return FALSE;

	if (playout->FInit(pngr, usDepth))
		return TRUE;

	delete playout;
	playout = (CLayout *)NULL;

	return FALSE;
}

BOOL CLayout::FInit(CNidGraphDoc * pngr, USHORT usDepthConst)
//
// create a tree structure from the given CNidGraphDoc and NID values
// -- setup items which are constant over the whole tree walk
// -- then do the walk itself
// -- group items into columns
// -- regroup items within their columns using parent information
// -- exchange items within columns to minimize the cost
//
{
	_pngr        = pngr;
	_iDepthConst = usDepthConst;
	_iDepthCur   = 0;
	_iDepthMac   = 0;
	_cNodesMac   = 0;
	_iPosMac     = 0;
	_rgcDepth    = NULL;
	_rgiDepth    = NULL;
	_rgrgNodeCol = NULL;
	_rgRoots     = NULL;
	_rgPnode     = NULL;
	_pnodeHead	 = NULL;

	BOOL fRet = FALSE;

	for (;;)	// this loop will not actually repeat
	{
		// FUTURE: put a CWaitCursor cursor CTOR here
		//

		if ((_cRoots	= _pngr->CRootsInitWalk()) == 0)
		{
			fRet = TRUE;
			break;
		}

#ifdef USE_LOCAL_BUILD_HEAP
		if ((_rgRoots = (CGrNode **)CGrNode::g_heapNodes.alloc(sizeof(CGrNode *) * _cRoots)) == (CGrNode **)NULL)
#else
		if ((_rgRoots = (CGrNode **)malloc(sizeof(CGrNode *) * _cRoots)) == (CGrNode **)NULL)
#endif
			break;

		NID nid = 0;
		USHORT iRoot = 0;

		for (iRoot = 0; _pngr->FNextRoot(nid); iRoot++)
			_rgRoots[iRoot] = (CGrNode *)nid;

		ASSERT(iRoot == _cRoots);

		USHORT cRoots = _cRoots;	// save this away because new (fake) roots
									// might be added during the walk

		for (iRoot = 0; iRoot < cRoots; iRoot++)
		{
			CGrNode *pRoot = WalkTree((NID)_rgRoots[iRoot]);
			_rgRoots[iRoot] = pRoot;
		}

		for (iRoot = 0; iRoot < _cRoots; iRoot++)
			InsertFakeNodes(_rgRoots[iRoot]);

#ifdef USE_LOCAL_BUILD_HEAP
		if ((_rgcDepth = (USHORT *)CGrNode::g_heapNodes.alloc(sizeof(USHORT) * _iDepthMac)) == (USHORT *)NULL)
			break;

		if ((_rgiDepth = (USHORT *)CGrNode::g_heapNodes.alloc(sizeof(USHORT) * _iDepthMac)) == (USHORT *)NULL)
			break;

		if ((_rgrgNodeCol = (CGrNode ***)CGrNode::g_heapNodes.alloc(sizeof(CGrNode **) * _iDepthMac)) == (CGrNode ***)NULL)
			break;

		if ((_rgPnode = (CGrNode **)CGrNode::g_heapNodes.alloc(sizeof(CGrNode *) * _cNodesMac)) == (CGrNode **)NULL)
			break;
#else
		if ((_rgcDepth = (USHORT *)malloc(sizeof(USHORT) * _iDepthMac)) == (USHORT *)NULL)
			break;

		if ((_rgiDepth = (USHORT *)malloc(sizeof(USHORT) * _iDepthMac)) == (USHORT *)NULL)
			break;

		if ((_rgrgNodeCol = (CGrNode ***)malloc(sizeof(CGrNode **) * _iDepthMac)) == (CGrNode ***)NULL)
			break;

		if ((_rgPnode = (CGrNode **)malloc(sizeof(CGrNode *) * _cNodesMac)) == (CGrNode **)NULL)
			break;
#endif

		UINT i;

		for (i=0; i<_iDepthMac; i++)
			_rgcDepth[i] = _rgiDepth[i] = 0;

		for (iRoot = 0; iRoot < _cRoots; iRoot++)
			CountDepth(_rgRoots[iRoot]);

		USHORT iNodeNext = 0;

		for (i=0; i<_iDepthMac; i++)
		{
			_rgrgNodeCol[i] = &_rgPnode[iNodeNext];
			iNodeNext += _rgcDepth[i];
		}

		for (iRoot = 0; iRoot < _cRoots; iRoot++)
			GroupNodes(_rgRoots[iRoot]);

#ifdef _DEBUG
		for (i = 0; i < _cNodesMac; i++)
			ASSERT(_rgPnode[i] != NULL);
#endif

		AttachParents();

		for (i=0; i<_iDepthMac; i++)
			_rgiDepth[i] = 0;

		for (iRoot = 0; iRoot < _cRoots; iRoot++)
			RegroupNodes(_rgRoots[iRoot]);

		for (i=0; i<_iDepthMac; i++)
			if (_rgiDepth[i] >= _iPosMac)
				_iPosMac = _rgiDepth[i]+1;

		// if there are too many nodes then we don't try to do any
		// smart formatting because it would take too long.

		if (CNodesMac() < 500)
			for (int cImp = 0; cImp < 10 && FImproveLayout(); cImp++);
		else
			SortColumns();	// minimally sort the columns by row

		fRet = TRUE;
		break;
	}

	return fRet;
}

CGrNode * CLayout::WalkTree(NID nidRoot)
// use the CNidGraphDoc implementation to return the nodes of the tree
{
	USHORT cChildren;

	if (_iDepthConst == 0 || _iDepthCur < _iDepthConst)
		cChildren = _pngr->CChildrenInitWalk(nidRoot);
	else
		cChildren = 0;

	CGrNode *pnode = PnodeNew(nidRoot, cChildren, _iDepthCur);
	if (pnode == (CGrNode *)NULL)
	{
		ASSERT(FALSE);
		return pnode;
	}
	
	// add node to NDX of known nodes
	_mapNodes.SetAt((void *)nidRoot, (void *)pnode);

	pnode->m_fVisited = TRUE;

	_iDepthCur++;

	ASSERT(pnode->m_cChildren == cChildren);

	// Here comes a slimey trick: to avoid a ton of memory fragmentation
	// we store the Nid's in place of the pointers until they've been
	// processed.  This also allows us to get all the children for a given
	// node at once which in turn gives us much better locality of
	// reference in the underlying graph structure

	USHORT ichild = 0;
	NID nid = 0;
	ET  et  = 0;

	while (ichild < cChildren)	// don't walk any children that might be added
	{
		VERIFY(_pngr->FNextNid(nid, et));

		if (nid != nidRoot)
		{
			pnode->m_rgEdges[ichild] = et;
			pnode->m_rgChildren[ichild++] = (CGrNode *)nid;
		}
		else
		{
			cChildren--;
			pnode->m_cChildren--;
			pnode->m_fRecursive = TRUE;
		}
	}

	ASSERT(pnode->m_cChildren == cChildren);

	// now do the actual walk by looking at the nids we got from the pointers
	// and converting them to real pointers as we go

	for (ichild = 0; ichild < cChildren; ichild++)
	{
		NID nidChild = (NID)pnode->m_rgChildren[ichild];

		// check if bob is already in tree
		if (FIncludesNid(nidChild))
		{
			CGrNode * pChild = PnodeAtNid(nidChild);

			// check for cycle
			if (pChild->m_fVisited)
			{
				// we've found a cycle	-- reverse this edge
				// but make a note of the reversal so we can fix
				// it when we draw the graph

				pnode->DelChild(ichild);
				pChild->AddChild(pnode);
				pChild->m_cReversed++;
				ichild--;
				cChildren--;
			}
			else
			{
				// if no cycle, connect to existing node and adjust depths
				//
				pnode->m_rgChildren[ichild] = pChild;
				pnode->m_fWorking = TRUE;
				AdjustDepth(pnode->m_rgChildren[ichild], _iDepthCur);
				pnode->m_fWorking = FALSE;
			}
		}
		else
			pnode->m_rgChildren[ichild] = WalkTree(nidChild);
	}

	_iDepthCur--;

	pnode->m_fVisited = FALSE;;

	return pnode;
}

void CLayout::AdjustDepth(CGrNode *pnode, USHORT iDepth)
// check to make sure the given node is at least the given depth and if not
// adjust it and its children
//
{
	if (pnode->m_iDepth >= iDepth || pnode->m_fWorking)
		return;

	pnode->m_fWorking = TRUE;
	pnode->m_iDepth = iDepth;

	if (iDepth >= _iDepthMac) _iDepthMac = iDepth+1;

	for (USHORT iChild = 0; iChild < pnode->m_cChildren; iChild++)
		AdjustDepth(pnode->m_rgChildren[iChild], iDepth+1);

	pnode->m_fWorking = FALSE;
}

void CLayout::InsertFakeNodes(CGrNode *pnode)
// check that all nodes have children that are at exactly one level
// deeper than their parents.  If this is not the case then insert
// fake nodes to make it so
//
{
	USHORT cChildren   = pnode->m_cChildren;
	USHORT iDepth      = pnode->m_iDepth;
	CGrNode ** rgChildren  = pnode->m_rgChildren;

	CGrNode * pnodeChild;

	USHORT iChild = 0;

	for (; iChild <cChildren; iChild++)
	{
		pnodeChild = rgChildren[iChild];

		if (pnodeChild->m_iDepth > iDepth+1)
		{
			// the child is more than one level away from us...
			// we need to introduce some fake nodes to span the gap from
			// the parent to the child

			// at this point we could use one fake node for all children
			// which are more than one level away from this parent

			// we can also use one fake node for all parents which are
			// more than one level away from the same child

			// search for an already created fake node that we can reuse

			CGrNode * pnodeNew = pnodeChild->m_pgrnAlias;
			BOOL fReverseEdge =	(iChild + pnode->CReversed() >= cChildren);
			ET   et = pnode->m_rgEdges[iChild];

			while (pnodeNew != (CGrNode *)NULL)
			{
				USHORT cRev;

				cRev  = pnodeNew->CReversed();

				ASSERT(pnodeNew->FFake());
				ASSERT(pnodeNew->CChildren() == 1);
				ASSERT(cRev == 0 || cRev == 1);

				if (pnodeNew->m_iDepth == iDepth+1 &&
					fReverseEdge == !!cRev &&
					pnodeNew->m_rgEdges[0] == et
				   )
				   break;

				pnodeNew = pnodeNew->m_pgrnAlias;
			}

			if (pnodeNew == (CGrNode *)NULL)
			{
				// must create a new fake node

				pnodeNew = PnodeNew(nidNil, 1, iDepth+1);
				pnodeNew->m_rgChildren[0] = pnodeChild;
				pnodeNew->m_rgEdges[0] = pnode->m_rgEdges[iChild];
				pnodeNew->m_pgrnAlias = pnodeChild->m_pgrnAlias;
				pnodeNew->m_fFake = TRUE;
				pnodeChild->m_pgrnAlias = pnodeNew;

				if (fReverseEdge)
					pnodeNew->m_cReversed = 1;
			}
				
			pnodeChild = rgChildren[iChild] = pnodeNew;
		}

		// no further work is required on this node, check the children

		if (pnodeChild->m_iDepth == iDepth+1 && pnodeChild->m_cChildren)
			InsertFakeNodes(pnodeChild);
	}
}

CGrNode * CLayout::PnodeNew(NID nid, USHORT cChildren, USHORT iDepth)
// Create a new node, keep track of the total number of nodes
// allocated and the maximum depth reached so far.
// Use the CGrNode constructor to initialize the node
//
{
	CGrNode * pnode = new CGrNode((CGraph *)NULL, nid, cChildren, iDepth);
	ASSERT(pnode != (CGrNode *)NULL);

	if (iDepth >= _iDepthMac)
		_iDepthMac = iDepth+1;

	_cNodesMac++;

	return pnode;
}

void CLayout::CountDepth(CGrNode *pnode)
// count the number of nodes at each level
// as each node is counted, its fWorking bit is set to TRUE
//
{
	if (pnode->m_fWorking) return;

	pnode->m_fWorking = TRUE;

	ASSERT(pnode->m_iDepth < _iDepthMac);

	_rgcDepth[pnode->m_iDepth]++;

	int iMac = pnode->m_cChildren;

	for (int i=0; i < iMac; i++)
		CountDepth(pnode->m_rgChildren[i]);
}

void CLayout::GroupNodes(CGrNode *pnode)
// put this node into its appropriate group
// as each node is placed in its column, its fWorking bit is reset to FALSE
//
// this initial grouping will allow us to conveniently walk all the nodes
// by just marching through the _rgPnode[] array.  A better grouping will
// be done by RegroupNodes
// 
{
	if (!pnode->m_fWorking) return;

	pnode->m_fWorking = FALSE;
	pnode->m_fVisited  = FALSE;

	USHORT depth = pnode->m_iDepth;
	pnode->m_iPos = 0xffff;

	_rgrgNodeCol[depth][_rgiDepth[depth]] = pnode;
	_rgiDepth[depth]++;

	int iMac = pnode->m_cChildren;

	for (int i=0; i < iMac; i++)
		GroupNodes(pnode->m_rgChildren[i]);
}

void CLayout::RegroupNodes(CGrNode *pnode)
// put this node into its appropriate group
// as each node is placed in its column, its fWorking bit is set to TRUE
//
// this grouping differs from the simple GroupNodes grouping in that:
//
// 		a) we traverse both child and parent links in order to get
//		   common parents of a child together as well as common children
//	       of a parent together
//
//      b) we assign a sensible position which is to allow for the
//	       actual amount of space that will probably be required
//		   by a node plus it's children
//
{
	while (pnode)
	{
		if (!pnode->m_fWorking)
		{
			int i = 0;

			pnode->m_fWorking = TRUE;

			USHORT depth = pnode->m_iDepth;
			pnode->m_iPos = _rgiDepth[depth];

			_rgiDepth[depth]++;

			// determine the number of "New" children that this node will
			// have and assign it a position which will center it amongst
			// these new children

			int iMac = pnode->m_cChildren;

			if (iMac && depth < _iDepthMac-1)
			{
				USHORT iNew = 0;

				for (i=0; i < iMac; i++)
					if (!pnode->m_rgChildren[i]->m_fWorking) iNew++;

				if (iNew)
				{
					if (_rgiDepth[depth+1] + iNew/2 < pnode->m_iPos)
					{
						_rgiDepth[depth+1] = pnode->m_iPos - iNew/2;
					}
					else if (pnode->m_iPos < _rgiDepth[depth+1] + (iNew-1)/2)
					{
						pnode->m_iPos = _rgiDepth[depth+1] + (iNew-1)/2;

						ASSERT(_rgiDepth[depth] < pnode->m_iPos+1);
						_rgiDepth[depth] = pnode->m_iPos+1;
					}
				}
			}

			// group any ungrouped parents of this node

			iMac = pnode->m_cParents;

			for (i=iMac; --i >= 0;)
				if (!pnode->m_rgParents[i]->m_fWorking)
					ToHeadNode(pnode->m_rgParents[i]);

			// group any ungrouped children of this node

			iMac = pnode->m_cChildren;

			for (i=iMac; --i >= 0;)
				if (!pnode->m_rgChildren[i]->m_fWorking)
					ToHeadNode(pnode->m_rgChildren[i]);
			}

		pnode = PnodeRemoveHead();
	}
}

USHORT CLayout::Cost(CGrNode *pnode, USHORT iPos)
// compute the cost of putting a given node at a certain position
//
{
	USHORT cMetric = 0, iDepthReqd, i;
	USHORT 	cParents  = pnode->m_cParents;
	CGrNode ** rgParents = pnode->m_rgParents;

	iDepthReqd = pnode->m_iDepth-1;

	for (i=0; i<cParents; i++)
	{
		CGrNode * pnodeParent = rgParents[i];

		// don't consider nodes at the wrong depth
		if (pnodeParent->m_iDepth != iDepthReqd) continue;

		// compute distance to the child

		int d = pnodeParent->m_iPos - iPos;
		if (d <0 ) d = -d;

		cMetric += d;
	}

	USHORT 	cChildren  = pnode->m_cChildren;
	CGrNode **	rgChildren = pnode->m_rgChildren;
	iDepthReqd = pnode->m_iDepth+1;

	for (i=0; i<cChildren; i++)
	{
		CGrNode *  pnodeChild = rgChildren[i];

		// don't consider nodes at the wrong depth
		if (pnodeChild->m_iDepth != iDepthReqd) continue;

		// don't consider leaf nodes with only one parent -
		//		-- they're easy to move

		// if (pnodeChild->m_cChildren == 0 && pnodeChild->m_cParents == 1)
		//	continue;

		// compute distance to the child

		int d = pnodeChild->m_iPos - iPos;
		if (d<0) d = -d;

		cMetric += d;
	}

	return cMetric;
}

BOOL CLayout::FImproveLayout()
// try to minimize the total "Cost()" of the graph
//
{
	CGrNode *	pnode, * pnode2;
	CGrNode **	mpPosNode;
	USHORT 	c1, c1T, c2, c2T, p1, p2, iNode, iDepth;

	BOOL fDidWork = FALSE;

#ifdef USE_LOCAL_BUILD_HEAP
	if ((mpPosNode = (CGrNode **)CGrNode::g_heapNodes.alloc(sizeof(CGrNode *) * _iPosMac)) == (CGrNode **)NULL)
#else
	if ((mpPosNode = (CGrNode **)malloc(sizeof(CGrNode *) * _iPosMac)) == (CGrNode **)NULL)
#endif
		return FALSE;

	for (iDepth=0; iDepth < _iDepthMac; iDepth++)
	{
		USHORT cNodes = _rgcDepth[iDepth];
		CGrNode ** rgNodes = _rgrgNodeCol[iDepth];

		for (iNode = 0; iNode < _iPosMac; iNode++)
			mpPosNode[iNode] = (CGrNode *)NULL;

		for (iNode=0; iNode<cNodes; iNode++)
		{
			pnode = rgNodes[iNode];
			mpPosNode[pnode->m_iPos] = pnode;
			pnode->m_cost = Cost(pnode, pnode->m_iPos);
		}

		USHORT cLimit = 10;
		BOOL fOptimal;
		do
		{
			fOptimal = TRUE;

			for (iNode=0; iNode < cNodes; iNode++)
			{
				pnode   = rgNodes[iNode];
				p1  	= pnode->m_iPos;
				c1  	= pnode->m_cost;

				if (c1 == 0) continue;

				ASSERT(mpPosNode[p1] == pnode);

				for (p2 = pnode->m_iPos + 1; p2 <_iPosMac; p2++)
				{
					c1T = Cost(pnode, p2);

					if (c1T == c1) goto endsearch;
					if (c1T > c1) break;

					pnode2 = mpPosNode[p2];

					if (pnode2 != NULL)
					{
						ASSERT(pnode2->m_iPos == p2);

						c2   = pnode2->m_cost;
						c2T  = Cost(pnode2, p1);

						int effect = c1T + c2T - c1 - c2;

						if (effect > 0) continue;

						if (effect == 0 &&
							pnode->m_cSiblings <= pnode2->m_cSiblings
						   )
						   continue;
					}

					// lower cost -- reposition node

					ASSERT(p1 != p2);

					mpPosNode[p2] = pnode;
					mpPosNode[p1] = pnode2;

					pnode->m_iPos = p2;
					pnode->m_cost = c1T;

					fOptimal = FALSE;
					fDidWork = TRUE;
			
					if (pnode2)
					{
						pnode2->m_iPos = p1; 
						pnode2->m_cost = c2T;
					}

					c1 = c1T;
					p1 = p2;

					if (c1 == 0) break;
				}

				for (p2 = pnode->m_iPos - 1; p2 < _iPosMac; p2--)
				{
					c1T = Cost(pnode, p2);

					if (c1T == c1) goto endsearch;
					if (c1T > c1) break;

					pnode2 = mpPosNode[p2];

					if (pnode2 != NULL)
					{
						ASSERT(pnode2->m_iPos == p2);

						c2   = pnode2->m_cost;
						c2T  = Cost(pnode2, p1);

						int effect = c1T + c2T - c1 - c2;

						if (effect > 0) continue;
						if (effect == 0 &&
							pnode->m_cSiblings <= pnode2->m_cSiblings
						   )
							continue;
					}

					// lower cost -- reposition node

					ASSERT(p1 != p2);

					mpPosNode[p2] = pnode;
					mpPosNode[p1] = pnode2;

					pnode->m_iPos = p2;
					pnode->m_cost = c1T;

					fOptimal = FALSE;
					fDidWork = TRUE;
			
					if (pnode2)
					{
						pnode2->m_iPos = p1; 
						pnode2->m_cost = c2T;
					}

					c1  = c1T;
					p1  = p2;
					if (c1 == 0) break;
				}

				endsearch:; 
			}

		} while (!fOptimal && --cLimit > 0);

		p1 = 0;

		for (iNode = 0; iNode < cNodes && p1 < _iPosMac; p1++)
		{
			pnode = mpPosNode[p1];
			if (pnode != (CGrNode *)NULL)
				rgNodes[iNode++] = pnode;
		}

		ASSERT(iNode == cNodes);
	}

#ifdef USE_LOCAL_BUILD_HEAP
	CGrNode::g_heapNodes.dealloc(mpPosNode);
#else
	free(mpPosNode);
#endif
	return fDidWork;
}

void CLayout::AttachParents()
// count every nodes parents and then allocate and fill in the parent
// array in each node.  We do this now so that artifically introduced
// nodes will be counted.
//
// at this time we also compute the number of "siblings" for each node
//
{
	USHORT iNode, iChild, cChildren;
	CGrNode *pnode, *pChild, **rgChildren;
	
	// this isn't pretty we have to:
	//	a) count the parents
	//	b) allocate memory for all the parents
	//	c) fill in the pointer values
	//  d) compute the number of "siblings"
	//
	// this requires four separate passes over all the nodes (eeek!)
	//
	// oh well...	-Rico

	// first we count all the parents
	for (iNode = 0; iNode < _cNodesMac; iNode++)
	{
		pnode = _rgPnode[iNode];

		cChildren  = pnode->m_cChildren;
		rgChildren = pnode->m_rgChildren;

		for (iChild = 0; iChild < cChildren; iChild++)
		{
			pChild = rgChildren[iChild];
			pChild->m_cParents++;
		}
	}

	// now allocate the memory
	for (iNode = 0; iNode < _cNodesMac; iNode++)
	{
		pnode = _rgPnode[iNode];

		if (pnode->m_cParents)
		{
#ifdef USE_LOCAL_BUILD_HEAP
			pnode->m_rgParents = (CGrNode **)CGrNode::g_heapNodes.alloc(sizeof(CGrNode *) * pnode->m_cParents);
#else
			pnode->m_rgParents = (CGrNode **)malloc(sizeof(CGrNode *) * pnode->m_cParents);
#endif
			ASSERT(pnode->m_rgParents != (CGrNode **)NULL);
		}
	}

	// finally, fill in the parent values
	for (iNode = 0; iNode < _cNodesMac; iNode++)
	{
		pnode = _rgPnode[iNode];

		cChildren  = pnode->m_cChildren;
		rgChildren = pnode->m_rgChildren;

		for (iChild = 0; iChild < cChildren; iChild++)
		{
			pChild = rgChildren[iChild];
			pChild->m_rgParents[pChild->m_iParent++] = pnode;
		}
	}

	// now compute the number of siblings for each node
	for (iNode = 0; iNode < _cNodesMac; iNode++)
	{
		USHORT cSibs = 0;
		pnode = _rgPnode[iNode];

		cChildren  = pnode->m_cChildren;
		rgChildren = pnode->m_rgChildren;

		for (iChild = 0; iChild < cChildren; iChild++)
			cSibs += rgChildren[iChild]->m_cParents;

		cChildren = pnode->m_cParents;
		rgChildren = pnode->m_rgParents;

		for (iChild = 0; iChild < cChildren; iChild++)
			cSibs += rgChildren[iChild]->m_cParents;

		pnode->m_cSiblings = cSibs;
	}
}

static int CmpNodes(void *n1, void *n2)
// compare two nodes -- use their row as the key
//
{
	USHORT p1 = (*(CGrNode **)n1)->IRow();
	USHORT p2 = (*(CGrNode **)n2)->IRow();

	if (p1 < p2)
		return -1;
	if (p1 == p2)
		return 0;
	else
		return 1;
}

void CLayout::SortColumns()
// sort the nodes in each column so that they are in increasing order
// of display position.  This helps us to do intelligent painting
//
{
	for (UINT iDepth = 0; iDepth < _iDepthMac; iDepth++)
	{
		USHORT cNodes    = _rgcDepth[iDepth];
		CGrNode **rgNodes = _rgrgNodeCol[iDepth];

		if (cNodes > 1)
			qsort(rgNodes, cNodes, sizeof(CGrNode *),
				(int (*)(const void *, const void *)) (int (*)(void *, void *))
				CmpNodes);
	}
}

CLayout::~CLayout()
// do a full cleanup
//
{
#ifdef USE_LOCAL_BUILD_HEAP
	if (_rgcDepth)    CGrNode::g_heapNodes.dealloc(_rgcDepth);
	if (_rgiDepth)    CGrNode::g_heapNodes.dealloc(_rgiDepth);
	if (_rgrgNodeCol) CGrNode::g_heapNodes.dealloc(_rgrgNodeCol);
	if (_rgRoots)     CGrNode::g_heapNodes.dealloc(_rgRoots);
#else
	if (_rgcDepth)    free(_rgcDepth);
	if (_rgiDepth)    free(_rgiDepth);
	if (_rgrgNodeCol) free(_rgrgNodeCol);
	if (_rgRoots)     free(_rgRoots);
#endif

	if (_rgPnode)
	{
		// free all the nodes

		for (USHORT i = 0; i<_cNodesMac; i++)
		{
#ifdef USE_LOCAL_BUILD_HEAP
			CGrNode::g_heapNodes.dealloc(_rgPnode[i]);
#else
			free(_rgPnode[i]);
#endif
			_rgPnode[i] = (CGrNode *)NULL;
		}

#ifdef USE_LOCAL_BUILD_HEAP
		CGrNode::g_heapNodes.dealloc(_rgPnode);
#else
		free(_rgPnode);
#endif
	}
}

void CLayout::ToHeadNode(CGrNode *pnode)
// if pnode is not in the queue, add it at the head 
//
// if pnode is elsewhere in the queue currently then move it to the head
// 
{
	if (pnode->m_fVisited)
	{
		// node is already in the queue

		if (pnode->m_pgrnPrev == (CGrNode *)NULL)
		{
			ASSERT(_pnodeHead == pnode);
			return;		// this is already at the head -- no work
		}

		pnode->m_pgrnPrev->m_pgrnNext = pnode->m_pgrnNext;

		if (pnode->m_pgrnNext)
			pnode->m_pgrnNext->m_pgrnPrev = pnode->m_pgrnPrev;
	}
	else
		pnode->m_fVisited = TRUE;

	pnode->m_pgrnPrev = (CGrNode *)NULL;
	pnode->m_pgrnNext = _pnodeHead;

	if (_pnodeHead)
	{
		ASSERT(_pnodeHead->m_pgrnPrev == (CGrNode *)NULL);
		_pnodeHead->m_pgrnPrev = pnode;
	}

	_pnodeHead = pnode;
}

CGrNode * CLayout::PnodeRemoveHead()
// remove the first node from the queue
// return NULL if no such node is available
//
{
	CGrNode *pnode;

	if (_pnodeHead == (CGrNode *)NULL)
		return  (CGrNode *)NULL;

	pnode = _pnodeHead;
	_pnodeHead = pnode->m_pgrnNext;
	pnode->m_pgrnNext = NULL;

	if (_pnodeHead)
	{
		ASSERT(_pnodeHead->m_pgrnPrev == pnode);
		_pnodeHead->m_pgrnPrev = (CGrNode *)NULL;
	}

	return pnode;
}

#endif // DEPGRAPH_VIEW
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\makread.cpp ===
//////////////////////////////////////////////////////////////////////
// MAKREAD.CPP
//
// Implementation of CMakFileReader and CMakFileWriter.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 30-May-93	mattg		Created
// 07-Jun-93	mattg		Added to VSHELL
// 13-Aug-93	mattg		Handle '\' continuation character
//							for directives
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Include files

#include "stdafx.h"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////
// IMPLEMENT_*
//
// These must be placed BEFORE the #ifdef _DEBUG stuff below

IMPLEMENT_DYNAMIC(CMakComment, CObject)
IMPLEMENT_DYNAMIC(CMakMacro, CObject)
IMPLEMENT_DYNAMIC(CMakDescBlk, CObject)
IMPLEMENT_DYNAMIC(CMakDirective, CObject)
IMPLEMENT_DYNAMIC(CMakError, CObject)
IMPLEMENT_DYNAMIC(CMakEndOfFile, CObject)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#define MW_MAXDISPLAYLEN 32

//////////////////////////////////////////////////////////////////////
// Common makefile strings:

const TCHAR *szMkLineIndent = _TEXT ("    ");
const TCHAR cMkContinuation = _T('\\');

//////////////////////////////////////////////////////////////////////
// Helper routines

static BOOL g_bIsDBCSUsed = 0;

VOID StripLeadingWhite
(
	CString &	str
)
{
	TCHAR *	pchStart;
	TCHAR *	pchCur;
	INT		ich;

	pchCur = pchStart = (TCHAR *)(const TCHAR *)str;

	while ((*pchCur == _T(' ')) || (*pchCur == _T('\t')))
		++pchCur;

	ich = pchCur - pchStart;

	str = str.Right(str.GetLength() - ich);
}

VOID StripTrailingWhite
(
	CString &	str
)
{
	TCHAR *	pchCur;
	TCHAR *	pchStart;
	TCHAR *	pchWhite = NULL;
	INT		ichWhite;

	pchCur = pchStart = (TCHAR *)(const TCHAR *)str;

	while (*pchCur != _T('\0'))
	{
		if ((*pchCur == _T(' ')) || (*pchCur == _T('\t')))
		{
			if (pchWhite == NULL)
				pchWhite = pchCur;

			++pchCur;
		}
		else
		{
			pchCur = _tcsinc(pchCur);

			pchWhite = NULL;
		}
	}

	if (pchWhite != NULL)
	{
		ichWhite = pchWhite - pchStart;
		str = str.Left(ichWhite);
	}
}

VOID StripLeadingAndTrailingWhite
(
	CString &	str
)
{

#if 0
	// UNDONE: try to avoid this copy!!!
	// check and copy in place in one pass

	TCHAR *	pchStart;
	TCHAR *	pchCur;
	TCHAR *	pchWhite = NULL;

	// copy into temp buffer so fast assignment works (below)
	CString strTemp = str;

	pchCur = (TCHAR *)(const TCHAR *)strTemp;

	while ((*pchCur == _T(' ')) || (*pchCur == _T('\t')))
		++pchCur;

	pchStart = pchCur;

	while (*pchCur != _T('\0'))
	{
		if ((*pchCur == _T(' ')) || (*pchCur == _T('\t')))
		{
			if (pchWhite == NULL)
				pchWhite = pchCur;

			++pchCur;
		}
		else
		{
			pchCur = _tcsinc(pchCur);

			pchWhite = NULL;
		}
	}

	if (pchWhite != NULL)
	{
		*pchWhite = _T('\0');
	}


	str = pchStart;
#else
	TCHAR *	pchStart;
	TCHAR *	pchCur;
	TCHAR *	pchTemp;
	TCHAR *	pchWhite = NULL;

	pchStart = pchCur = str.GetBuffer(0);

	// first check for leading whitespace and skip
	while ((*pchCur == _T(' ')) || (*pchCur == _T('\t')))
	{
		++pchCur;
	}

	// different code if leading whitespace
	int nLeadingWhite = (pchCur - pchStart);
	char c;

	if (nLeadingWhite != 0)
	{
		pchTemp = pchStart;
		while ((c = *pchCur) != _T('\0') )
		{
			if ((c == _T(' ')) || (c == _T('\t')))
			{
				if (pchWhite == NULL)
					pchWhite = pchCur; // we adjust this later
			}
			else
			{
				pchWhite = NULL;
				if ((g_bIsDBCSUsed) && (IsDBCSLeadByte(c)))
					*(pchTemp++) = *(pchCur++);	// extra copy if DBCS
			}
			*(pchTemp++) = *(pchCur++);
		}
	}
	else
	{
		if (g_bIsDBCSUsed)
		{
			while ((c = *pchCur) != _T('\0') )
			{
				if ((c == _T(' ')) || (c == _T('\t')))
				{
					if (pchWhite == NULL)
						pchWhite = pchCur;
					pchCur++;
				}
				else
				{
					pchWhite = NULL;
					pchCur = _tcsinc(pchCur);
				}
			}
		}
		else
		{
			for ( c = *pchCur; c != _T('\0'); c = *++pchCur )
			{
				if ((c == _T(' ')) || (c == _T('\t')))
				{
					if (pchWhite == NULL)
						pchWhite = pchCur;
				}
				else
				{
					pchWhite = NULL;
				}
			}
		}
	}

	if (pchWhite!=NULL)
	{
		pchCur = pchWhite; 	// reset pchCur to actual end of string
		*pchCur = _T('\0'); // and null terminate
	}
	str.ReleaseBuffer((pchCur - pchStart) - nLeadingWhite);
#endif
}

VOID SkipWhite
(
	const TCHAR * &	pch
)
{
	while (*pch && ((*pch == _T(' ')) || (*pch == _T('\t'))))
		++pch;
}

VOID SkipNonWhite
(
	const TCHAR * &	pch
)
{
	while (*pch && (*pch != _T(' ')) && (*pch != _T('\t')) )
		++pch;
}

int  GetMakToken(const TCHAR * pBase, const TCHAR *& pTokenEnd)
		// throw CFileException
{
	int r = 0;
	BOOL bInQuotes = FALSE;
	pTokenEnd = pBase;

	// Skip whitespace at beginning:
	while (*pTokenEnd 
			&& 
		   (*pTokenEnd == _T(' ') || *pTokenEnd == _T('\t') )
		   )
	{
		r++;
		pTokenEnd++;
	}
     
	while (*pTokenEnd)
	{
		if (  *pTokenEnd ==  _T('"') ) bInQuotes = ~bInQuotes;
		else if (*pTokenEnd == _T(' ') || *pTokenEnd == _T('\t')
			|| *pTokenEnd == _T('\r')
#ifdef _UNICODE
			|| *pTokenEnd == _T('\n')  // should always get \r before \n unless Unicode
#endif
			 )
		{
			if (!bInQuotes) break;
		}
		r++;

		pTokenEnd = _tcsinc ( (char *) pTokenEnd);
    }  
	#ifdef _DEBUG
	if (bInQuotes && !*pTokenEnd) TRACE ("Unmatched quotes in GetToken\n");
	#endif 

	return r;
}

BOOL GetQuotedString(const TCHAR *& pBase, const TCHAR *& pEnd)
{				
	ASSERT (pBase);

	while (*pBase && *pBase != _T('"'))
		 pBase=_tcsinc((TCHAR *)pBase);

	if (*pBase != _T('"'))
		return FALSE;

	pEnd = (pBase =_tcsinc((TCHAR *)pBase));		// Go past quote.

	while (*pEnd && *pEnd != _T('"'))
		pEnd=_tcsinc ( (TCHAR *) pEnd );

	if (pBase == pEnd || *pEnd != _T('"')) 
		return FALSE;

	return TRUE;
} 

//////////////////////////////////////////////////////////////////////
// CNameMunger class

#ifdef _MBCS
#define MAX_EXPANSION 4   
//#define MAX_EXPANSION 4 / 2
#else
#define MAX_EXPANSION 1
#endif

void CNameMunger::MungeName (const TCHAR *pszName, CString &strResult)
{
	// Take a string and convert it to something that can be put in
	// a make file as part of a macro name.  In the sbcs world we,
	// do this by taking the first 5 characters, converting any
	// bad characters to underscores, and then adding characters
	// until we no longer collide.  If we reach the end of the string,
	// we just start adding unique numbers until there's no collision.

	// In the mbcs world, we convert ASCII characters to underscores
	// and double byte charactes to there hex representation.

	TCHAR *pbase, *pcur, *pupcase;
	const TCHAR *pinbase;
	int i;
	void *pdum;
	CString *pcstr;

	// No one should be giving us an empty string:
    ASSERT ( _tcslen (pszName) > 0 );

	// Go for quick kill:  Have we seen the name before
	if (m_InMap.Lookup ( pszName, (void *&) pcstr))
	{
		strResult = *pcstr;
		return;
	}

	i = _tcslen (pszName);
	pinbase = pszName;
	// Get a buffer which we know will be big enough to hold the 
	// expanded name:
	pcur = pbase = strResult.GetBuffer 
							( i * MAX_EXPANSION + 9);

	pupcase = new TCHAR [i+1];
	// Try looking up upcased version of supplied string:
	_tcscpy (pupcase, pszName );
	_tcsupr (pupcase);
		if (m_InMap.Lookup ( pbase, (void *&) pcstr))
	{
		strResult = *pcstr;

		// Enter the base string for future reference:
		m_InMap.SetAt (pszName, (void *) pcstr);
		delete [] (pupcase);
		return;
	}
 

	for ( ;*pszName != _T('\0'); pszName = _tcsinc( (TCHAR *) pszName) )
	{
		// Copy the next character out of the source string and tranlate
		// it if nessesary:

		if ( *pszName == _T('_')
			||
			(*pszName >= _T('0') && *pszName <= _T('9'))
			||
			(*pszName >= _T('A') && *pszName <= _T('Z'))
			)
		{
			*pcur++ = *pszName;	
		}
		else if (*pszName >= _T('a') && *pszName <= _T('z'))
		{
			*pcur++ = *pszName -  (_T('a') - _T('A'));	// Upcase
		}
#ifdef _MBCS
		else if ( IsDBCSLeadByte ( (BYTE)*pszName))
		{
			_ultoa ( (LONG) *((UNALIGNED DWORD *) pszName), pcur, 16 );
			while (*pcur) pcur++;			 
		}
#endif
		else 
		{
			// Shave off leading weird characters:  Ignore if we haven't
			// advanced in the buffer.
			if (pcur > pbase) *pcur++ = _T('_');	
		}

		*pcur = _T('\0');				
		if ((pcur - pbase) < 5) continue;	// Alway use at least 5 if we can.

		if ( !m_ResMap.Lookup ( pbase, pdum)) break;
	}

	// If we reached the end of the input string and couldn't find an
	// unused name, then default to unique number type scheme.  If there
	// are no valid characters at all, start the name with an "M_":
	if (*pszName == _T('\0'))		    
	{
		if (pcur == pbase )
		{
			_tcscpy (pbase, "M_");
			pcur += 2;
		}

		i = m_InMap.GetCount();
		do 
		{
			_ultoa ( i, pcur, 16);
			i++;
		} while (m_ResMap.Lookup ( pbase, pdum));
	}

	strResult.ReleaseBuffer ();

	ASSERT (!m_ResMap.Lookup ( pbase, pdum));

	pcstr = m_ResMap.SetAtAndReturnStringAddress (strResult);
	m_InMap.SetAt (pinbase, (void *) pcstr);
	// Also save upcased version:
	m_InMap.SetAt (pupcase, (void *) pcstr);
	delete [] (pupcase);

}
//////////////////////////////////////////////////////////////////////
// Constructors, destructors for CMak* objects

CMakComment::~CMakComment(){}
CMakComment::CMakComment
(
	const TCHAR * pszText
)
{
	m_strText = pszText;
	StripLeadingAndTrailingWhite(m_strText);
}
#ifdef _DEBUG
 void CMakComment::Dump ( CDumpContext& dc ) const
{
	CObject::Dump (dc);
	dc << "m_strText: " << m_strText << "\n";
}
#endif
CMakMacro::~CMakMacro(){}
CMakMacro::CMakMacro
(
	const CString & strMacName,
	const CString & strMacValue
)
{
	m_strName = strMacName;
	m_strValue = strMacValue;
}
#ifdef _DEBUG
 void CMakMacro::Dump ( CDumpContext& dc ) const
{
	CObject::Dump (dc);
	dc << "m_strName: " << m_strName << " m_strValue: " << m_strValue <<"\n";
}
#endif

CMakDescBlk::~CMakDescBlk(){}
CMakDescBlk::CMakDescBlk
(
	const CString & strTargets,
	const CString & strDeps
)
{
	m_strTargets = strTargets;
	m_strDeps = strDeps;
}
#ifdef _DEBUG
 void CMakDescBlk::Dump ( CDumpContext& dc ) const
{
	CObject::Dump (dc);
	dc << "m_strTargets: " << m_strTargets << " m_strDeps: " << m_strDeps <<
			"Commands: \n";
	int n = dc.GetDepth ();
	dc.SetDepth (1);
	dc << m_listCommands;
	dc.SetDepth (n);
}
#endif

#define CDIRECTIVES 13

struct
{
	TCHAR *					szDirKeyword;
	int						nByteLen;
	CMakDirective::DTYP		dtyp;
}

#define DIRTEXT(x) _TEXT(x), (sizeof (x)-1) 

//  Note: in this table, longer items must come before items with
//  the same prefix (e.g. IFDEF before IF):

g_rgdirtbl[CDIRECTIVES] =
{
	{ DIRTEXT("CMDSWITCHES"),	CMakDirective::DTYP_CMDSWITCHES},
	{ DIRTEXT("ERROR"),			CMakDirective::DTYP_ERROR		},
	{ DIRTEXT("MESSAGE"),		CMakDirective::DTYP_MESSAGE		},
	{ DIRTEXT("INCLUDE"),		CMakDirective::DTYP_INCLUDE		},
	{ DIRTEXT("IFNDEF"),		CMakDirective::DTYP_IFNDEF		},
	{ DIRTEXT("IFDEF"),			CMakDirective::DTYP_IFDEF		},
	{ DIRTEXT("IF"),			CMakDirective::DTYP_IF			},
	{ DIRTEXT("ELSEIFNDEF"),	CMakDirective::DTYP_ELSEIFNDEF	},
	{ DIRTEXT("ELSEIFDEF"),		CMakDirective::DTYP_ELSEIFDEF	},
	{ DIRTEXT("ELSEIF"),		CMakDirective::DTYP_ELSEIF		},
	{ DIRTEXT("ELSE"),			CMakDirective::DTYP_ELSE		},
	{ DIRTEXT("ENDIF"),			CMakDirective::DTYP_ENDIF		},
	{ DIRTEXT("UNDEF"),			CMakDirective::DTYP_UNDEF		}
};

extern BOOL g_bConvDontTranslate;	// defined in project.cpp

CMakDirective::~CMakDirective(){}
CMakDirective::CMakDirective
(
	DTYP			dtyp,
	const CString & strRemOfLine
)
{
	m_dtyp = dtyp;
	m_strRemOfLine = strRemOfLine;

#if 0	// This doesn't always work correctly, so skip it
	// message strings may have been localized in v6.0 and beyond
	if ((dtyp == CMakDirective::DTYP_MESSAGE /* || dtyp == CMakDirective::DTYP_ERROR */) && (!g_bConvDontTranslate))
	{
		m_strRemOfLine.OemToAnsi();
	}
#endif
}
#ifdef _DEBUG
 void CMakDirective::Dump ( CDumpContext& dc ) const
{
	CObject::Dump (dc);
	dc << "m_dtyp " << g_rgdirtbl[m_dtyp].szDirKeyword << 
		" m_strRemOfLine: " << m_strRemOfLine <<"\n";
}
#endif

CMakError::~CMakError(){}
CMakError::CMakError(){}

CMakEndOfFile::~CMakEndOfFile(){}
CMakEndOfFile::CMakEndOfFile(){}

//////////////////////////////////////////////////////////////////////
// Constructors, destructors for CMakFileReader()
// How often to update the status bar:
const int CMakFileReader::nStatusBarUpdate = 16;
CMakFileReader::CMakFileReader() 
{
	m_pUngotElement = NULL;
	m_nFileSize = 0;
	m_nProgressGoal = 0;
	g_bIsDBCSUsed = (theApp.GetCP() != 0);
}

CMakFileReader::~CMakFileReader()
{
	if (m_pUngotElement) delete (m_pUngotElement);
	if (m_nFileSize && (m_iAttrib & MakRW_ShowStatus))
	{
		::StatusPercentDone(100);	// Let the user see this.
		::StatusEndPercentDone();
	}
}

//////////////////////////////////////////////////////////////////////
// CMakFileWriter::Abort
void CMakFileReader::Abort()
{
	m_file.Abort ();
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::Close
void CMakFileReader::Close()
{
	m_file.Close ();
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::FillBuf

VOID CMakFileReader::FillBuf
(
)
{
	UINT	cchRead;

	cchRead = m_file.Read(m_rgchBuf, (CCH_BUF - 1) * sizeof(TCHAR));
	m_cchFile += cchRead;

	if (cchRead == 0)
	{
		/* At end-of-file.  Put a MAK_EOF TCHAR at the first position and
		** set the m_fEOF flag.
		*/

		m_rgchBuf[0] = MAK_EOF;
		m_rgchBuf[1] = _T('\0');
		m_fEOF = TRUE;
	}
	else
	{
		/* Terminate the buffer with a '\0'.
		**
		** Note that in the UNICODE case, cchRead may be odd, in which
		** case the file is bogus (second byte of a UNICODE character
		** is absent).  Anyway, we simply ignore the "half character"
		** at EOF.
		*/

		m_rgchBuf[cchRead / sizeof(TCHAR)] = _T('\0');
	}

	m_ichBuf = 0;
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::GetLine

BOOL CMakFileReader::GetLine
(
	CString &	strRet
)
{
	TCHAR	ch;
	UINT bufmax = 256;
	UINT	cch = 0;

	// let's alloc a buffer to use up-front, this'll save allocs when 
	// we 'strRet += ch'. we assume that most lines in the makefikle
	// are going to be less than 256 bytes.
	char * pszRet = strRet.GetBuffer(bufmax);

	while (((ch = GetChar()) != _T('\r')) && ((ch != MAK_EOF) || (!m_fEOF)))
	{
		pszRet[cch++] = ch;

		/* We count how many characters we've accumulated to deal with the
		** case where we've been asked to read a binary file and a '\r' may
		** not be seen for a long time.  To avoid accumulating huge strings,
		** limit the length of the string artificially.  This may end up
		** splitting a line in a legitimate makefile, but as long as the
		** maximum line length is on the order of 1K bytes, it seems unlikely.
		**
		** Set ch to _T('\r') to make the code outside of this loop think that
		** we've encountered end-of-line.
		*/

		// make sure that if we reach allocation limit, we grow it efficiently
		if (cch >= bufmax)
		{
			if (cch >= ((256 * 16))) // make limit multiple of 256
			{
				ch = _T('\r');
				break;
			}

			bufmax += 256;
			(void) strRet.ReleaseBuffer(cch);	// set data length, and terminate
			pszRet = strRet.GetBuffer(bufmax);  // get new larger buffer
		}
		
	}

	pszRet[cch] = _T('\0'); // ensure nul-terminated

	(void) strRet.ReleaseBuffer(cch);	// set data length, and terminate
	
	if (ch == _T('\r'))
	{
		if (PeekChar() == _T('\n'))
			GetChar();

		return(TRUE);
	}

	return(FALSE);
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::ParseDirective

CObject * CMakFileReader::ParseDirective
(
	const CString &	strLine
)
{
	const TCHAR *	pch;
	INT				idir, cch;
	CString			strRemOfLine, strT;

	ASSERT(strLine[0] == _T('!'));

	pch = (const TCHAR *)strLine + 1;

	/* Skip any whitespace following the '!'.
	*/

	SkipWhite(pch);

	if (*pch == _T('\0'))
		return(new CMakError);

	/* Now search for a matching keyword.
	*/

	for (idir=0 ; idir<CDIRECTIVES ; ++idir)
		if (_tcsnicmp(	g_rgdirtbl[idir].szDirKeyword,
						pch,
						cch = _tcslen(g_rgdirtbl[idir].szDirKeyword)) == 0)
			break;

	if (idir == CDIRECTIVES)
		return(new CMakError);

	strRemOfLine = pch + cch;

	if (!((m_iAttrib & MakR_IgnLineCont) || strRemOfLine.IsEmpty()))
	{
		for (;;)
		{
			pch = strRemOfLine;

			if (*_tcsdec(pch, (TCHAR *)pch + _tcslen(pch)) != cMkContinuation)
				break;

			if (!GetLine(strT))
				return(new CMakError);

			strRemOfLine.SetAt(strRemOfLine.GetLength() - 1, _T(' '));
			strRemOfLine += strT;
		}
	}

	return(new CMakDirective(g_rgdirtbl[idir].dtyp, strRemOfLine));
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::ParseMacro

CObject * CMakFileReader::ParseMacro
(
	const CString &	strLine,
	INT				ichEq
)
{
	// UNDONE: requires further optimization for buffer allocation

	int len;
	const TCHAR *		pch;
	CString				strName, strValue, strT, strRawData;
	CMakMacro * pMacro;
	// alloc buffers to use up-front, this'll save allocs when 
	// we 'strRawData += ch'.  Note: this can be quite large! (4000+)
	strRawData.GetBuffer(4096);
	strValue.GetBuffer(4096);
	strRawData.ReleaseBuffer(0);
	strValue.ReleaseBuffer(0);

	strRawData += strLine;
	strRawData += _T("\r\n");

	/* Everything up to, but not including, the '=' is considered
	** to be the macro name.
	*/

	strName = strLine.Left(ichEq);
	strValue += (LPCTSTR(strLine) + (ichEq + 1));

	/* While the last character of the value string is '\', fetch
	** the next line and append it (line continuation).
	*/

	if (!((m_iAttrib & MakR_IgnLineCont) || strValue.IsEmpty()))
	{
		for (;;)
		{

			len = strValue.GetLength();
			pch = strValue;
			if (*_tcsdec(pch, (TCHAR *)(pch + len)) != cMkContinuation)
				break;

			if (!GetLine(strT))
				return(new CMakError);

			strRawData += strT;
			strRawData += _T("\r\n");

			strValue.SetAt(len-1, _T(' '));
			strValue += strT;
		}
	}

	/* Now strip leading and trailing whitespace from both the macro
	** name and macro value.
	*/

	StripLeadingAndTrailingWhite(strName);
	StripLeadingAndTrailingWhite(strValue);

	/* Return a new CMakMacro object.
	*/

	strValue.FreeExtra();
	strRawData.FreeExtra();
	pMacro = new CMakMacro(strName, strValue);
	pMacro->m_strRawData = strRawData;
	return pMacro;
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::ParseDescBlk

CObject * CMakFileReader::ParseDescBlk
(
	const CString &	strLine,
	INT				ichColon
)
{
	TCHAR			ch;
	const TCHAR *	pch;
	BOOL			fDoubleColon = FALSE, fFirstLine;
	INT				ich, ich1;
	CString			strLHS, strRHS, strT, strRawData;
	CMakDescBlk *	pmdb;
	(void)strRHS.GetBuffer(255);
	(void)strRHS.ReleaseBuffer(0);
	(void)strRawData.GetBuffer(511);
	(void)strRawData.ReleaseBuffer(0);

	strRawData += strLine;
	strRawData += _T("\r\n");	// record raw data incase needed later

	/* Split the line into its left-hand side (targets) and
	** right-hand side (dependents).
	*/

	if	(
		(ichColon != strLine.GetLength() - 1)
		&&
		(strLine[ichColon + 1] == _T(':'))
		)
		fDoubleColon = TRUE;

	strLHS = strLine.Left(ichColon);
	StripLeadingAndTrailingWhite(strLHS); // used for unique matches
	strRHS += strLine.Right(strLine.GetLength() - ichColon - (fDoubleColon ? 2 : 1));

	/* While the last character of the RHS string is '\', fetch
	** the next line and append it (line continuation).
	*/

	if (!strRHS.IsEmpty())
	{
		for (;;)
		{
			pch = strRHS;

			if (*_tcsdec(pch, (TCHAR *)pch + _tcslen(pch)) != cMkContinuation)
				break;

			if (!GetLine(strT))
				return(new CMakError);

			strRawData += strT;
			strRawData += _T("\r\n");
			strRHS.SetAt(strRHS.GetLength() - 1, _T(' '));
			strRHS += strT;
		}
	}

	strRHS.FreeExtra();
	pmdb = new CMakDescBlk(strLHS, strRHS);

	/* Now fetch all subsequent command lines, and add them to the object.
	*/

	fFirstLine = TRUE;

	for (;;)
	{
		/* First peek at the next character.  If it's not whitespace,
		** not a blank line, we'll break out of the loop, since this 
		** will end the list of command lines.
		** Note that this means that a comment will terminate a 
		** descritption block, which is not strictly NMAKE like, but
		** otherwise we will swallow potientially interesting comments:
		*/

		ch = PeekChar();

		if	(
			((ch == MAK_EOF) && (m_fEOF))
			||
				(
				(ch != _T(' '))
				&&
				(ch != _T('\t'))
				&&
				(ch != _T('\r'))
				)
			)
			break;

		/* Now fetch the next line.
		*/

		if (!GetLine(strRHS))
			break;

		strRawData += strRHS;
		strRawData += _T("\r\n");

		/* Check for an empty line.  This is permitted (and ignored)
		** unless it is the first line after the dependency line, in
		** which case it ends the description block.
		*/

		if (strRHS.IsEmpty())
		{
			if (fFirstLine)
				break;
			else
				continue;
		}

		fFirstLine = FALSE;

		/* Check to see if this line is a comment line (possible leading
		** whitespace followed by a comment) or all whitespace.  If so,
		** just ignore it and continue.
		*/

		pch = strRHS;

		SkipWhite(pch);

		if ((*pch == _T('\0')) || (*pch == _T('#')))
			continue;

		/* Check to see if this line contains an inline file specification.
		** If so, accumulate all successive lines up to and including the
		** terminating line.
		*/

		if	(((ich = strRHS.Find(_T('<'))) != -1) &&
			 (ich < strRHS.GetLength() - 1) &&
			 (strRHS[ich+1] == _T('<'))
			)
		{
			for (;;)
			{
				if (!GetLine(strT))
				{
					delete pmdb;
					return(new CMakError);
				}

				strRawData += strT;
				strRawData += _T("\r\n");

				strRHS += _T('\n');
				strRHS += strT;

				if	((strT.GetLength() >= 2) &&
					 (strT[0] == _T('<')) &&
					 (strT[1] == _T('<'))
					)
					break;
			}
		}

		/* Now accumulate command lines while each ends in '\'.
		*/

		if (!(m_iAttrib & MakR_IgnLineCont))
		{
			for (;;)
			{
				pch = strRHS;

				if (*_tcsdec(pch, (TCHAR *)pch + _tcslen(pch)) != cMkContinuation)
					break;

				if (!GetLine(strT))
				{
					delete pmdb;
					return(new CMakError);
				}

				strRawData += strT + _T("\r\n");

				strRHS.SetAt(strRHS.GetLength() - 1, _T(' '));
				strRHS += strT;
			}
		}

		if (pmdb->m_strTool.IsEmpty())
		{
			// if we don't already have a tool, try to find one: $(TOOL)
			ich = strRHS.Find(_T("$("));
			if (ich!=-1)
			{
				ich += 2;
				ich1 = strRHS.Find(_T(')'));
				if (ich < ich1)
				{
					pmdb->m_strTool = strRHS.Mid(ich, (ich1 - ich));
					StripLeadingAndTrailingWhite(pmdb->m_strTool);
				}
			}
		}

		/* Finally, add this string to the list of commands.
		*/

		strRHS.FreeExtra();
		pmdb->m_listCommands.AddTail(strRHS);
	}

	strRawData.FreeExtra();
	pmdb->m_strRawData = strRawData;
	return pmdb;
}

//////////////////////////////////////////////////////////////////////
// CMakFileReader::Open

BOOL CMakFileReader::Open
(
	const TCHAR *		szFilename,
	UINT				nOpenFlags,
	CFileException *	exc,
	UINT				iAttrib	/* = MakRW_Default | MakRW_ShowStatus */
)
{
	// preserve our attributes
	m_iAttrib = iAttrib;

	m_nLineNum = 1;
	m_rgchBuf[0] = _T('\0');
	m_ichBuf = 0;
	m_fEOF = FALSE;
	m_cchFile = 0;
	CString str;

	if (m_file.Open(szFilename, nOpenFlags, exc))
	{
		if (m_iAttrib & MakRW_ShowStatus)
		{
			TRY
			{
				m_nFileSize	= m_file.GetLength ();
			}
			CATCH_ALL (e)
			{
				ASSERT (m_nFileSize	== 0);
			}
			END_CATCH_ALL	

			if (m_nFileSize && (m_iAttrib & MakRW_ShowStatus))
			{
				VERIFY (str.LoadString ( IDS_READING_PROJECT ));
				CPath path;
				if (path.Create(szFilename))
				{
					CString strProject;
					path.GetBaseNameString(strProject);
					if (strProject.GetLength() <= MW_MAXDISPLAYLEN)
						str += strProject;
				}
				::StatusBeginPercentDone ( str);
				m_nObjectsRead = 0;
			}
		}
		return TRUE;
	}
	return FALSE;
}

//////////////////////////////////////////////////////////////////////
// ReOpen

void CMakFileReader::ReOpen()
{
	// seek to beginning of file
	(void)m_file.Seek(0, CFile::begin);

	m_nLineNum = 1;
	m_rgchBuf[0] = _T('\0');
	m_ichBuf = 0;
	m_fEOF = FALSE;
	m_cchFile = 0;

	// reset the number of objects read
	if (m_nFileSize && (m_iAttrib & MakRW_ShowStatus))
		m_nObjectsRead = 0;
}


//////////////////////////////////////////////////////////////////////
// GetNextElement

CObject * CMakFileReader::GetNextElement
(
)
{
	const TCHAR *		pch;
	const TCHAR *		pchT;
	BOOL				fInQuotes;
	CString				strLine;

	// Return the ungot element if there is one:
	if (m_pUngotElement)
	{
		ASSERT_VALID (m_pUngotElement);

		CObject *pUngotElement = m_pUngotElement;
		m_pUngotElement = NULL;
		return pUngotElement;
	}

	// Update the status bar if its time:
	if (m_nFileSize && (++m_nObjectsRead % nStatusBarUpdate) == 0)
	{
		DWORD dw;
		dw = m_file.GetPosition ();
		// This will fail with makefiles over 40 meg:
	 	dw = dw * 100 / m_nFileSize;
		if (dw >= m_nProgressGoal) // only update at most 20 times
		{
			::StatusPercentDone ( (int) dw);
			m_nProgressGoal += 5; // increment target by 5%
		}
	}

	for (;;)
	{
		/* Fetch the next line.
		*/

		if (!GetLine(strLine))
			return(new CMakEndOfFile);

		pch = (const TCHAR *)strLine;

		/* Find the first non-white character on the line, if any.
		*/

		SkipWhite(pch);

		/* Break out of the loop if this line is *not* entirely blank.
		** Otherwise, loop back to fetch another line.
		*/

		if (*pch != _T('\0'))
			break;
	}

	/* Check to see if the next character is '#'.  If so, the entire
	** line is a comment.
	*/

	if (*pch == _T('#'))
		return(new CMakComment(pch + 1));

	/* At this point, if there was any leading whitespace, an error ensues.
	*/

	if (pch != (const TCHAR *)strLine)
		return(new CMakError);

	/* If the first character is '!', process the directive.
	*/

	if (*pch == _T('!'))
		return(ParseDirective(strLine));

	/* This line must either be a macro definition or a dependency line
	** (the start of a description block).
	**
	** Look for ':' and '=' inside the string, ignoring any occurrences
	** inside double quotes.
	**
	** If a non-quoted '=' is found, this is a macro definition.
	**
	** If a non-quoted ':' is found, this is a dependency line as long
	** as it was preceded by whitespace or at least two non-whitespace
	** characters (this rule is necessary to permit filenames with drive
	** specifications, e.g., "c:\foo\bar\blix.c").
	**
	** If this line is neither a macro definition nor a dependency line,
	** return an error.
	*/

	fInQuotes = FALSE;

	while (*pch != _T('\0'))
	{
		if (*pch == _T('"'))
		{
			fInQuotes = !fInQuotes;
		}
		else if ((*pch == _T('=')) && (!fInQuotes))
		{
			break;
		}
		else if ((*pch == _T(':')) && (!fInQuotes))
		{
			pchT = pch;

			if (pchT == (const TCHAR *)strLine)
			{
				/* We found the ':' at the beginning of the line.
				** This is an error (no targets!).
				*/

				return(new CMakError);
			}

			/* Check previous character.
			*/

			pchT = _tcsdec((const TCHAR *)strLine, (TCHAR *)pchT);

			if ((*pchT == _T(' ')) || (*pchT == _T('\t')))
			{
				/* Previous character was whitespace.  This is a
				** legitimate separator.
				*/

				break;
			}

			/* The previous character was NOT whitespace.
			**
			** Check the character two characters back.  If it's
			** whitespace, or if it doesn't exist (i.e., the character
			** one character back is the first character of the string),
			** then this is NOT a legitimate separator.
			**
			** Thus, this is a legitimate separator only if the
			** previous character exists and is not whitespace.
			*/

			if (pchT != (const TCHAR *)strLine)
			{
				pchT = _tcsdec((const CHAR *)strLine, (TCHAR *)pchT);

				if ((*pchT != _T(' ')) && (*pchT != _T('\t')))
					break;
			}
		}

		++pch;

#ifdef _MBCS
		if (IsDBCSLeadByte(*(pch-1)))
			++pch;
#endif
	}

	if (*pch == _T('='))
	{
		return(ParseMacro(strLine, pch - (const TCHAR *)strLine));
	}
	else if (*pch == _T(':'))
	{
		return(ParseDescBlk(strLine, pch - (const TCHAR *)strLine));
	}
	else
		return(new CMakError);
}

void CMakFileReader::UngetElement (CObject *pUngotElement)
{
	// Only single depth:
	ASSERT_VALID (pUngotElement);
	ASSERT (m_pUngotElement == NULL );	
	m_pUngotElement = pUngotElement;
}
//////////////////////////////////////////////////////////////////////
//
// ------------------------ CMakFileWriter --------------------------
//
//////////////////////////////////////////////////////////////////////
// Constructors, destructors for CMakFileWriter()
const int CMakFileWriter::nLineLen = 1200;
const int CMakFileWriter::nStatusBarUpdate = 2;

CMakFileWriter::CMakFileWriter()
{
	m_CurrentPos = 0;
	m_bLastLineBlank = FALSE;
	m_nObjects = 0;
	m_bInit = FALSE;
	m_pFileSaver = NULL;
	m_nProgressGoal = 0;
	g_bIsDBCSUsed = (theApp.GetCP() != 0);
}

CMakFileWriter::~CMakFileWriter()
{
	if (m_pFileSaver)
	{
		delete m_pFileSaver;
		m_pFileSaver = NULL;
	}

	if (m_nObjects && (m_iAttrib & MakRW_ShowStatus))
	{
		::StatusPercentDone(100);	// Let the user see this.
		::StatusEndPercentDone();
	}
	m_bInit = FALSE;
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::Create

BOOL CMakFileWriter::Create
(
	const TCHAR *		szFilename,
	CFileException *	exc,
	int 				nObjects, /* = 0 */
	UINT				iAttrib	/* = MakRW_Default | MakRW_ShowStatus */
)
{
	ASSERT (m_CurrentPos == 0 );
	m_nCharCount = 0;

	// preserve our attributes
	m_iAttrib = iAttrib;

	ASSERT(m_pFileSaver==NULL);
	// use temporary file for write in case of error
	if (!m_pFileSaver)
		m_pFileSaver = new CFileSaver(szFilename);

	// verify file is writable
	if ((m_pFileSaver) && (!m_pFileSaver->CanSave()))
		{
		// N.B. This stuff does not really use file error support.
		exc->m_cause = CFileException::accessDenied;
		SetFileError(exc->m_cause);
		return FALSE;
		}

	if (m_File.Open(
				((m_pFileSaver)	? m_pFileSaver->GetSafeName()
								: szFilename), 
				CFile::modeCreate | CFile::modeWrite,
				exc))
	{
		m_nObjects = nObjects;
		if (m_nObjects && (m_iAttrib & MakRW_ShowStatus))
		{
			CString str;
			if (g_bWriteProject)
			{
				VERIFY(str.LoadString(IDS_WRITING_PROJECT));
			}
			else
			{
				ASSERT(g_bExportMakefile);
				VERIFY(str.LoadString(IDS_EXPORTING_MAKEFILE));
			}
			CPath path;
			if (path.Create(szFilename))
			{
				CString strProject;
				if (g_bWriteProject)
				{
					path.GetBaseNameString(strProject);
					if (strProject.GetLength() <= MW_MAXDISPLAYLEN)
						str += strProject;
				}
				else
				{
					strProject = path.GetFileName();
					if (strProject.GetLength() <= (MW_MAXDISPLAYLEN+4)) // +.mak
						str += strProject;
				}

			}
			::StatusBeginPercentDone(str);
		}
		m_nObjectsWritten = 0;
		m_bInit = TRUE;
		return TRUE;
	}
	return FALSE;
}
//////////////////////////////////////////////////////////////////////
const TCHAR* CMakFileWriter::GetFileName()
{
	return m_pFileSaver->GetRealName();
}
//////////////////////////////////////////////////////////////////////
void CMakFileWriter::WroteObject ()
{
	if (!m_nObjects || ((++m_nObjectsWritten % nStatusBarUpdate) != 0)
		|| ((m_iAttrib & MakRW_ShowStatus)==0))
		return;

		DWORD dw =  m_nObjectsWritten * 100 / m_nObjects;
		if (dw >= m_nProgressGoal) // only update at most 20 times
		{
			::StatusPercentDone ( (int) dw);
			m_nProgressGoal += 5; // increment target by 5%
		}
}			
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::Abort
void CMakFileWriter::Abort()
{
	m_File.Abort();
	m_bInit = FALSE;
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::Close
BOOL CMakFileWriter::Close()
{
	if (m_CurrentPos > 0)
	{
		ASSERT (m_File.m_hFile != (UINT) CFile::hFileNull);
		m_File.Write (m_buf, m_CurrentPos );
		m_CurrentPos = 0; 
	}

	if (m_File.m_hFile != (UINT) CFile::hFileNull) m_File.Close ();

	m_bInit = FALSE;

	if (m_pFileSaver)
		return m_pFileSaver->Finish();
	return TRUE;
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteBytes
void CMakFileWriter::WriteBytes ( const BYTE *pByte, int nBytes )
{
	// FUTURE: broken for UNICODE
	ASSERT (pByte);
	int i;
	
	if (nBytes > CCH_BUF)
	{
		m_File.Write (m_buf, m_CurrentPos);
		m_CurrentPos = 0;
		m_File.Write (pByte, nBytes);
		return;
	}

	
	if (m_CurrentPos + nBytes  > CCH_BUF)
	{						   
		i = CCH_BUF- m_CurrentPos;
		memcpy (m_buf + m_CurrentPos, pByte, i);
		m_File.Write (m_buf, CCH_BUF);
		pByte += i;
		nBytes -= i;
        m_CurrentPos = 0;
	}

	memcpy (m_buf + m_CurrentPos, pByte, nBytes);
    m_CurrentPos += nBytes;
}						  	
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteStringEx
void CMakFileWriter::WriteStringEx ( const TCHAR *pc )
{
	if (m_nCharCount > 0) EndLine ();

	if  (m_bLastLineBlank)	// strip leading CR/LF if redundent
	{
		if (*pc == _T('\r'))
			pc++;
		if (*pc == _T('\n'))
			pc++;
	}
	int len = _tcslen(pc);
	WriteBytes ( (BYTE *) pc, len * sizeof(TCHAR));

	m_nCharCount = 0;
	if (len >= 4)
		m_bLastLineBlank = (_tcscmp(pc + len - 4, _T("\r\n\r\n"))==0);
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteString
void CMakFileWriter::WriteString(const TCHAR *pc)
{
	const char *pEndOfToken, *pcTokenStart;
	int nTokenLen;

	// Check to see if there is a "\" as the last character
	BOOL fLastNotBackWhack =
		(!*pc || (pEndOfToken = pc + _tcslen (pc), pEndOfToken = \
		 _tcsdec (pc, (char *)pEndOfToken), *pEndOfToken != cMkContinuation));
				 
	while (*pc)
	{
		pcTokenStart = pc;
		// Look for a line break before the start of the next token:
		while (*pcTokenStart 
				&& 
		   		(*pcTokenStart == _T(' ') || *pcTokenStart == _T('\t') 
		    	|| *pcTokenStart == cMkContinuation || *pcTokenStart == _T('\r') 
		    	|| *pcTokenStart == _T('\n')
		    	) 
		   	  )
		{
			if (*pcTokenStart == _T('\r') || *pcTokenStart == _T('\n'))	
			{
				m_nCharCount = 0;
			}
			else m_nCharCount++;
			pcTokenStart++;
		}

		nTokenLen = GetMakToken	(pcTokenStart, pEndOfToken);
		if ( m_nCharCount + nTokenLen >= nLineLen )
		{
			// split line only if it doen't end with a return already -- fix 11534
			if ((m_nCharCount > 0) && (*pEndOfToken != _T('\r'))) SplitLine ();
		   	// If the token's too big for a line, write it anyway:
			m_nCharCount = nTokenLen;
		}
		else m_nCharCount += nTokenLen;
		
		WriteBytes ( (BYTE *) pc, pEndOfToken - pc);
		if (!fLastNotBackWhack)
			WriteBytes ( (BYTE *) _TEXT ( " "), sizeof (TCHAR));

		pc = pEndOfToken;
	}
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::EndLine
void CMakFileWriter::EndLine ()
{
	WriteBytes ( (BYTE *) _TEXT ( "\r\n"), sizeof (TCHAR) * 2); 
	m_bLastLineBlank = (m_nCharCount == 0);
	m_nCharCount = 0;
}
//////////////////////////////////////////////////////////////////////
void CMakFileWriter::InsureSpace ()
{
	if (!m_bLastLineBlank) EndLine ();
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::SplitLine
void CMakFileWriter::SplitLine ()
{
	WriteBytes ( (BYTE *) _TEXT ( "\\\r\n"), sizeof (TCHAR) * 3); 
	m_nCharCount = 0;
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::Indent
void CMakFileWriter::Indent ()
{
	ASSERT (m_nCharCount == 0);
	WriteBytes ( (BYTE *) szMkLineIndent, 
				sizeof (szMkLineIndent) - sizeof (TCHAR)
				); 
	m_nCharCount = sizeof (szMkLineIndent)/sizeof (TCHAR) - 1;
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteSeperatorString

void CMakFileWriter::WriteSeperatorString ()
{
	WriteBytes ( ( BYTE *) _TEXT (
					"########################################"
					"########################################"
					), sizeof (TCHAR) * 80);
	EndLine ();
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteComment

void CMakFileWriter::WriteComment(const TCHAR *pszText)
{
	CString str = pszText;
	StripTrailingWhite(str);

	if (m_nCharCount > 0) EndLine ();
	WriteBytes ( (BYTE *) _TEXT ( "# "), sizeof (TCHAR) * 2); 

 	WriteBytes ( (BYTE *)(const char *) str, str.GetLength());
	EndLine ();
	m_bLastLineBlank = FALSE;
}

void CMakFileWriter::WriteCommentEx(const TCHAR *pszFormat, ...)
{
	TCHAR szBuffer[1201];
	int nBuf;
	va_list args;
	va_start(args, pszFormat);
	
	if (m_nCharCount > 0) EndLine ();
	
	nBuf = _vsnprintf(szBuffer, 1201, pszFormat, args);
	szBuffer[1200] = 0;

	WriteBytes ( (BYTE *) _TEXT ( "# "), sizeof (TCHAR) * 2); 
 	WriteBytes ( (BYTE *) szBuffer, nBuf );
	EndLine ();
	m_bLastLineBlank = FALSE;
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteDirective
// everyone who calls WriteDirective with something that needs to be
// translated should use this version (not the char * version.
void CMakFileWriter::WriteDirective(CMakDirective::DTYP dtyp, CString &str )
{
	if (IsMakefile() && ((dtyp == CMakDirective::DTYP_MESSAGE) || (dtyp == CMakDirective::DTYP_ERROR)))
	{
		str.AnsiToOem();
	}

	WriteDirective( dtyp, (const TCHAR *)str );
}

void CMakFileWriter::WriteDirective(CMakDirective::DTYP dtyp, const TCHAR *pszText)
{
	ASSERT (dtyp >= 0 && dtyp < CDIRECTIVES );
	ASSERT (g_rgdirtbl[dtyp].dtyp == dtyp );  // Has enum been changed?
	ASSERT (g_rgdirtbl[dtyp].nByteLen + 4 < nLineLen); 

	if (m_nCharCount > 0) EndLine ();
	WriteBytes ( (BYTE *) _TEXT ( "!" ), sizeof ( TCHAR ));
	WriteBytes ( (BYTE *) g_rgdirtbl[dtyp].szDirKeyword, 
										g_rgdirtbl[dtyp].nByteLen );

	WriteBytes ( (BYTE *) _TEXT ( " " ), sizeof ( TCHAR ));

	m_nCharCount = g_rgdirtbl[dtyp].nByteLen + 2;

	if (pszText)
		WriteString(pszText);
	EndLine ();

}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteMacro
void CMakFileWriter::WriteMacro(const TCHAR *pszLeftSide, const TCHAR *pszRightSide)
{
	// ignore 'null' macro names!
	if (pszLeftSide[0] != _T('\0'))
	{
		if (m_nCharCount > 0) EndLine();

		WriteString(pszLeftSide);
		WriteString(_TEXT ( "=" ));
		WriteString(pszRightSide);

		EndLine();
	}
}
//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteDesc
void CMakFileWriter::WriteDesc(const TCHAR * pszTargets, const TCHAR * pszDependants)
{
	// ignore 'null' targets names!
	if (pszTargets[0] != _T('\0'))
	{
		if (m_nCharCount > 0) EndLine();
		InsureSpace ();

		WriteString(pszTargets);
		WriteString(_TEXT( " : " ));
		WriteString(pszDependants);

		EndLine ();
	}
}

//////////////////////////////////////////////////////////////////////
// CMakFileWriter::WriteDescAndAction
void CMakFileWriter::WriteDescAndAction
(
	const TCHAR * pszTargets,
	const TCHAR * pszDependants,
	const TCHAR * pszAction
)
{
	// multi-targets?
	// look for ','
	TCHAR * pch = (TCHAR *)pszTargets;
	BOOL fMultiTarg = FALSE;
	BOOL fMultiLine = FALSE;
	BOOL fHasAction = *pszAction != _T('\0');
	BOOL fWrittenCmds = FALSE;

	//
	// Only set fMultiTarg = TRUE if NOT writing a makefile.
	//
	if (IsProjectFile())
	{
		while (*pch != _T('\0'))
		{
			if (*pch == _T('\t'))
			{
				pch = _tcsinc(pch);
				if (*pch != _T('\0'))
					fMultiTarg = TRUE;
				break;
			}
			pch = _tcsinc(pch);
		}
	}

	pch = (TCHAR *)pszAction;
	while (*pch != _T('\0'))
	{
		if (*pch == _T('\t'))
		{
			pch = _tcsinc(pch);
			if (*pch != _T('\0'))
				fMultiLine = TRUE;
			break;
		}
		pch = _tcsinc(pch);
	}

	//
	// Just use "\t" delimted string "as is" when writing a makefile.
	//
	if (IsProjectFile())
		pch = _tcstok((TCHAR *)pszTargets, "\t");
	else
		pch = const_cast<TCHAR*>(pszTargets);

	while (pch != (TCHAR *)NULL)
	{
		// pad with line
		EndLine();

		// got multi?
		if (!fMultiTarg)
		{
			// write out desc.
			WriteDesc(pch, pszDependants);
		}

		// write out actions
		// as a $BuildCmd?

		if (fHasAction && !fWrittenCmds)
		{
			// write as a $BuildCmd?
			if (fMultiTarg)
			{
				WriteString(_TEXT("BuildCmds= \\\r\n\t"));	// end-line and indent here...
			} else {
				WriteString(_TEXT("\t"));	// add the tab
			}

			COptionList lstActions(_T('\t'), FALSE,TRUE);
			lstActions.SetString(pszAction);
			POSITION pos = lstActions.GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				const TCHAR * pcActionLine = lstActions.GetNext(pos);
				
				// write our action-line
				// if (!fMultiLine)
				//	Indent();	// indent here...
				
				WriteString(pcActionLine);

				if (fMultiLine){
					WriteString(_TEXT(" "));	// end-line and indent here...
					if (fMultiTarg){
						SplitLine();
						WriteString(_TEXT("\t"));	// end-line and indent here...
					}
					else
						WriteString(_TEXT("\r\n\t"));	// end-line and indent here...
				}
				else
					EndLine();							// end-line
			}

			fWrittenCmds = TRUE;
		}

		// got multi?
		if (fMultiTarg)
		{
			// write out desc. with $BuildCmds
			WriteDesc(pch, pszDependants);

			if (fHasAction)
			{	
				Indent();
				WriteString(_TEXT("$(BuildCmds)"));
			}
		}

		//
		// Just break from loop when writing a makefile since _tcstok is not being
		// used.
		//
		if (!IsProjectFile())
			break;
		else
			pch = _tcstok(NULL, "\t");
	}

	EndLine();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\macmgr.h ===
//////////////////////////////////////////////////////////////////////
// MACMGR.H
//
// Definition of CMacList.  The CMacList class defines a list of macros.
// CMacLists are used to maintain the macros read from a .MAK file, although
// the class is flexible enough to be used for other types of macros.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 22-May-93	mattg		Created
// 07-Jun-93	mattg		Added to VSHELL
//////////////////////////////////////////////////////////////////////

#ifndef __MACMGR_H__
#define __MACMGR_H__

#ifndef _SUSHI_PROJECT
// If you are encluding this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CMacList;

//////////////////////////////////////////////////////////////////////
// CMacList

class CMacList : public CObject
{
	DECLARE_DYNAMIC(CMacList)

protected:
	// Data
			CMapStringToString m_dict;
				// This is really the basis of the macro list -- a
				// collection which maps strings (macro names) to strings
				// (macro values).

public:
	// Constructors, destructors, initialization methods
	// FUTURE: tune for proper hash table size (must be prime)
	inline				CMacList() { m_dict.InitHashTable(97); }
	virtual				~CMacList();

	// Query methods
	inline	INT			GetMacCount() const
						{
							return(m_dict.GetCount());
						}
				// Return the number of macros currently in the list.

	inline	POSITION	GetFirstMacPosition() const
						{
							return(m_dict.GetStartPosition());
						}
				// Return the POSITION of the first macro in the list.

	inline	VOID		GetNextMac(POSITION & pos, CString & strMacName, CString & strMacVal) const
						{
							m_dict.GetNextAssoc(pos, strMacName, strMacVal);
						}
				// Get the next macro in the list.

			BOOL		IsMacDefined(const TCHAR *) const;
				// Return TRUE if the specified macro is defined, FALSE if not.

			const TCHAR * GetMacVal(const TCHAR *) const;
				// Return a pointer to the string representing the value of
				// the specified macro.  This method will ASSERT and return NULL
				// if the macro does not exist in this list.  If you are uncertain
				// whether the macro exists or not, call IsMacDefined() first.
				//
				// This method returns a pointer to internal data -- do not modify
				// this data!  If you require persistence of the resulting string,
				// make a copy of it.

	// Modification methods

	inline	VOID		SetMacVal(const TCHAR * szMacName, const TCHAR * szMacValue)
						{
							m_dict.SetAt(szMacName, szMacValue);
						}
				// Set the value of the macro specified by the szMacName parameter
				// to the value specified by the szMacValue parameter.  If the
				// specified macro is not already in the list, it is added; if it
				// is already in the list, its old value is replaced.

	inline	VOID		RemoveMac(const TCHAR * szMacName)
						{
							m_dict.RemoveKey(szMacName);
						}
				// Remove the macro specified by szMacName.

	// Miscellaneous methods

			VOID		ResolveString(CString &);
				// Resolves all macro references in the specified string.  This
				// occurs recursively, that is, if a macro resolves to more macros,
				// each of those macros is also resolved.  After this method is
				// invoked, the string will contain no macro references.
};

#endif // __MACMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\javadbg.h ===
//
// CDebugJavaGeneralPage
//		The general debugger options page for Java projects. This page
//		lets the user enter the class file to debug, the HTML page
//		containing the applet, and/or the parameters to the applet/application.
//
// CParamGridWnd
//		The grid for entering applet parameters.
//				   

#ifndef __JAVADBG_H__
#define __JAVADBG_H__

#include "prjoptn.h"
#include "optnui.h"		// CDebugPageTab

#include "resource.h"	// our resource IDs

// Classes defined in this file
class CDebugJavaGeneralPage;
class CParamGridWnd;
class CParamGridRow;
class CAddlClassesGridWnd;

//----------------------------------------------------------------
// CDebugJavaGeneralPage: the page to handle the general options
//----------------------------------------------------------------

class CDebugJavaGeneralPage: public CDebugPageTab
{
	DECLARE_IDE_CONTROL_MAP()
	DECLARE_MESSAGE_MAP()

// page operations
public:
	virtual void InitPage();
	virtual void CommitPage();
	virtual BOOL Validate();

public:
	virtual BOOL OnInitDialog();
	BOOL OnPropChange(UINT idProp);

// internal functions
private:
	void OnChangeClassFileName();
	void OnChangeDebugUsing();
};

//----------------------------------------------------------------
// CDebugJavaBrowserPage: the page to handle the browser options
//----------------------------------------------------------------

// private messages handled by the Java general debug page
#define GN_CHANGE WM_USER + 0xbc

class CDebugJavaBrowserPage: public CDebugPageTab
{
	DECLARE_IDE_CONTROL_MAP()
	DECLARE_MESSAGE_MAP()

// page operations
public:
	virtual void InitPage();
	virtual void CommitPage();
	virtual BOOL Validate();

public:
	virtual BOOL OnInitDialog();
	BOOL OnPropChange(UINT idProp);
	void OnDestroy();

// message handlers
protected:
	afx_msg void OnChangeParamGrid();

// internal functions
private:
	void OnChangeBrowser();
	void OnChangeParamSource();
	void UpdateParamGrid();

// internal data
private:
	// param grid
	CParamGridWnd *m_pgridParams;
};

//----------------------------------------------------------------
// CDebugJavaStandalonePage: the page to handle the stand-alone options
//----------------------------------------------------------------

class CDebugJavaStandalonePage: public CDebugPageTab
{
	DECLARE_IDE_CONTROL_MAP()
	DECLARE_MESSAGE_MAP()

// page operations
public:
	virtual void InitPage();
	virtual void CommitPage();
	virtual BOOL Validate();

public:
	virtual BOOL OnInitDialog();
	BOOL OnPropChange(UINT idProp);

// internal functions
private:
	void OnChangeStandalone();
};

//----------------------------------------------------------------
// CDebugJavaAddlClassesPage: the page to handle additional classes
//----------------------------------------------------------------

class CDebugJavaAddlClassesPage: public CDebugAdditionalDllPage
{
	DECLARE_IDE_CONTROL_MAP()

public:
	virtual void InitPage();
	virtual BOOL OnInitDialog();
	virtual void InitGrids();
};

//----------------------------------------------------------------
// CParamGridRow: row for handling parameters
//----------------------------------------------------------------

class CParamGridRow: public CGridControlRow
{
// columns
public:
	enum { GRID_COL_NAME, GRID_COL_VALUE, NUM_GRID_COLS /* should be last */ };

// ctor/dtor
public:
	CParamGridRow(CParamGridWnd* pGrid);
	~CParamGridRow();

// row operations
public:
	void DrawCell(CDC *pDC, const CRect& cellRect, int nColumn);
	BOOL IsNewRow();

// column operations
public:
	void OnActivate(BOOL bActivate, int nColumn);
	virtual BOOL OnAccept(CWnd* pControlWnd);
	virtual void GetColumnText(int nColumn, CString& str);
	void SetColumnText(int nColumn, LPCSTR pszValue);
	void ResetSize(CDC* pDC);

// grid access
public:
	CParamGridWnd* GetParamGrid();

// internal functions
private:
	void QuoteString(CString& str);

// internal data
private:
	CString m_strName;
	CString m_strValue;
};

//----------------------------------------------------------------
// CParamGridWnd: grid control window for handling parameters
//----------------------------------------------------------------

class CParamGridWnd: public CGridControlWnd
{
	DECLARE_DYNAMIC(CParamGridWnd)

// ctor/dtor
public:
	CParamGridWnd(int nColumns = CParamGridRow::NUM_GRID_COLS, BOOL bDisplayCaption = TRUE);
	~CParamGridWnd();
	
// row access
public:
	int GetCurSel();
	CParamGridRow* GetTailRow() const;
	POSITION GetTailRowPosition() const;
	POSITION GetTailSelPosition() const;

// row operations
public:
	void DoRowDelete();
	void DoRowMove(int nToIndex);
	BOOL OnRowMove(int nSrcIndex, int nDestIndex);
	int GetRowIndex(const CParamGridRow* pRow) const;

// toolbar button handlers
protected:
	afx_msg void OnGridNew();			//  New button pressed 
	afx_msg void OnGridDelete();		//  Delete button pressed 
	afx_msg void OnGridMoveUp();		//  Move Up button pressed 
	afx_msg void OnGridMoveDown();		//  Move Down button pressed 

// overrides
protected:
	virtual BOOL ProcessKeyboard(MSG* pMsg, BOOL bPreTrans = FALSE);
	virtual void DoDragDrop(CPoint point);
	afx_msg UINT OnGetDlgCode();

	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg BOOL OnToolTipText(UINT nID, NMHDR* pNMHDR, LRESULT* pResult);

// attributes
public:
	void SetReadOnly(BOOL bReadOnly);
	BOOL IsReadOnly();

// param string access
public:
	void SetParamsFromHTML(LPCSTR pszParams);
	CString GetParamsAsHTML();

	CString GetParamsAsCmdLine();

// message map functions
protected:
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void *pExtra, AFX_CMDHANDLERINFO *pHandlerInfo);
	afx_msg void OnDestroy();
	void OnPaint();
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnKillFocus(CWnd* pNewWnd);

	DECLARE_MESSAGE_MAP()

// internal functions
private:
	void DeleteAllRows();
	void SetGridFromHTML(LPCSTR pszParams);
	CString GetHTMLFromGrid();
	BOOL GetParamLine(CString& strParams, CString& strName, CString& strValue);
	BOOL SkipTokens(CString& strString, TCHAR* pszSkipTokens[]);
	BOOL GetQuotedString(CString& strString, CString& strValue);
	CString GetCmdLineFromGrid();
	void GridChange();

// internal data
private:
	// string of params to display in grid
	CString m_strHTMLParams;
	// flag for read only grid
	BOOL m_bReadOnly;
};

//----------------------------------------------------------------
// CAddlClassesGridRow: grid row for handling addl classes
//----------------------------------------------------------------
class CAddlClassesGridRow: public CDLLGridRow
{
// ctor/dtor
public:
	CAddlClassesGridRow(CAddlClassesGridWnd* pGridWnd, CAddlClassesGridRow* pParent = NULL);

// attributes
public:
	virtual void GetColumnText(int nColumn, CString& rStr);
	virtual void OnActivate(BOOL bActivate, int nColumn);
	virtual BOOL OnAccept(CWnd *pControlWnd);
};

//----------------------------------------------------------------
// CAddlClassesGridWnd: grid control window for handling addl classes
//----------------------------------------------------------------
class CAddlClassesGridWnd: public CDLLGridWnd
{
// ctor/dtor
public:
	CAddlClassesGridWnd(int nColumns = 3, BOOL bDisplayCaption = TRUE);
};

#endif // __JAVADBG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\macmgr.cpp ===
//////////////////////////////////////////////////////////////////////
// MACMGR.CPP
//
// Implementation of CMacList object
//
// History
// =======
// Date			Who			What
// ----			---			----
// 22-May-93	mattg		Created
// 07-Jul-93	mattg		Added to VSHELL
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Include files

#include "stdafx.h"
#pragma hdrstop
#include "macmgr.h"

//////////////////////////////////////////////////////////////////////
// IMPLEMENT_*
//
// These must be placed BEFORE the #ifdef _DEBUG stuff below

IMPLEMENT_DYNAMIC(CMacList, CObject)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// Constructors, destructors

CMacList::~CMacList
(
)
{
}

//////////////////////////////////////////////////////////////////////
// CMacList::IsMacDefined

BOOL CMacList::IsMacDefined
(
	const TCHAR *	szMacName
)
const
{
	CString	strUnused;

	return(m_dict.Lookup(szMacName, strUnused));
}

//////////////////////////////////////////////////////////////////////
// CMacList::GetMacVal

const TCHAR * CMacList::GetMacVal
(
	const TCHAR *	szMacName
)
const
{
	if (!IsMacDefined(szMacName))
	{
		ASSERT(FALSE);
		return(NULL);
	}

	// What follows is a little strange.  We want this method to be 'const'
	// since it doesn't modify this object.  However, CMapStringToString's
	// operator [] is NOT const, since it could conceivably modify the CMap-
	// StringToString object if an association with the specified key doesn't
	// yet exist (it will create one and add it to its map).  In this case,
	// we KNOW the association exists (by virtue of calling IsMacDefined()
	// above), so we don't have to worry about this case.
	//
	// Anyway, the end result is that we have to cast m_dict to a (CMapString-
	// ToString *) to avoid a compiler error message.
	//
	// So why is this method using CMapStringToString::operator []?  Because
	// that's the only method of CMapStringToString that gives us a reference
	// to the map's INTERNAL CString value, which is what we want.

	return(((CMapStringToString *)&m_dict)->operator[](szMacName));
}

//////////////////////////////////////////////////////////////////////
// CMacList::ResolveString

VOID CMacList::ResolveString
(
	CString &	str
)
{
	INT		ichStartMac, ichEndMac, cch = 0;
	CString	strMacName, strT;

	/* Continue looping until all macro references have been resolved.
	*/

	while (((ichStartMac = str.Find(_T('$'))) != -1) && (ichStartMac != cch - 1))
	{
		cch = str.GetLength();

		/* We've found a '$', indicating some sort of macro.  If the
		** next character is '(', then everything between that parenthesis
		** and the closing ')' parenthesis constitutes the macro name.
		** Otherwise, the macro name is the next character.
		*/

		if (str[ichStartMac + 1] == _T('('))
		{
			ichEndMac = ichStartMac + 2;

			while ((ichEndMac < cch) && (str[ichEndMac] != _T(')')))
			{
#ifdef _MBCS
				if (IsDBCSLeadByte(str[ichEndMac]))
					++ichEndMac;
#endif

				++ichEndMac;
			}

			if (ichEndMac >= cch)
			{
				/* Couldn't find the closing ')'.  Leave the string alone
				** and return.
				*/

				return;
			}

			strMacName = str.Mid(ichStartMac + 2, ichEndMac - ichStartMac - 2);
		}
		else
		{
			ichEndMac = ichStartMac + 1;

			strMacName = str[ichStartMac + 1];

#ifdef _MBCS
			if ((IsDBCSLeadByte(str[ichStartMac + 1]) && (ichStartMac + 1 < cch - 1)))
				strMacName += str[ichStartMac + 2];
#endif
		}

		/* Now make a copy of the current string so we can split it apart to form
		** the new string.
		*/

		strT = str;

		str.Empty();

		/* Add the part of the string BEFORE the macro from the copy to the string.
		*/

		str += strT.Left(ichStartMac);

		/* Add the macro's value, if any, to the string.
		*/

		if (IsMacDefined(strMacName))
			str += GetMacVal(strMacName);

		/* Now add the part of the string AFTER the macro from the copy to the string.
		*/

		str += strT.Right(cch - ichEndMac - 1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\memstat.cpp ===
#include "stdafx.h"

#ifdef DEBUG

#include <afx.h>
#include <stdio.h>
#include <stdlib.h>
#include <iostream.h>

#include <fstream.h>

#include "memstat.h"


class COriginInfo
{
public:
	ULONG m_cBlocks;
	ULONG m_cbTotal;
	CString m_strOrigin;
	COriginInfo() { m_cBlocks = m_cbTotal = 0; }
};

int compOrigin( const void *p1, const void * p2 ){
	COriginInfo *o1 = *(COriginInfo **)p1;
	COriginInfo *o2 = *(COriginInfo **)p2;
	if( o1->m_cbTotal < o2->m_cbTotal ) return 1;
	if( o1->m_cbTotal == o2->m_cbTotal ) return 0;
	return -1;
}

BOOL CMemStat::PrintMap( void )
{

	COriginInfo **array = new COriginInfo*[m_mapAlloc.GetCount()];

	int count=0;
	int i=0;
	COriginInfo *pinfo;

	for (POSITION pos = m_mapAlloc.GetStartPosition();
		 pos != NULL;
		 )
	{
		CString strOrigin;
   	    m_mapAlloc.GetNextAssoc(pos, strOrigin, (void *&)array[count]);
		count++;
	}
	qsort(array,count,sizeof(COriginInfo *),compOrigin);

	m_hfile = (HFILE)::CreateFile("\\heap.xls", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (m_hfile == (HFILE)INVALID_HANDLE_VALUE)
		return FALSE;

	static char szBuf[500];
	DWORD cbWritten;
	sprintf(szBuf, "Total=%u\t#new\tavg size\tlocation\tclass\n", cbTotalAlloc);
	WriteFile((HANDLE)m_hfile, szBuf, strlen(szBuf), &cbWritten, NULL);
	for (i=0;i<count;i++)
	{
   	    pinfo = array[i];
		sprintf(szBuf, "%u\t%u\t%u\t%s\n",
			   pinfo->m_cbTotal,
			   pinfo->m_cBlocks,
			   pinfo->m_cbTotal / pinfo->m_cBlocks,
			   LPCTSTR(pinfo->m_strOrigin));
		delete pinfo;
		WriteFile((HANDLE)m_hfile, szBuf, strlen(szBuf), &cbWritten, NULL);
	}
	::CloseHandle((HANDLE)m_hfile);
	delete array;
	return FALSE;
}


void CMemStat::Analize()
{

	ifstream ifs("\\heap.out");

	while (!ifs.eof())
	{
		char szOrigin[100];
		strcpy(szOrigin, "[unknown]");

		unsigned cb = 0;
		BOOL fAlloc = TRUE;

		char szLine[500];
		ifs.getline(szLine, 500);


		char szSeq[100];
		char szSubtype[100];
		char szAddr[100];
		char szBlockType[100];
		if (strncmp(szLine, "Detected", 8) == 0 ||
			strncmp(szLine, "Dumping", 7) == 0 ||
			strncmp(szLine, "Object dump", 11) == 0)
		{
			continue;	// ignore random header line
		}
		else if (szLine[0] == '\0')
		{
			continue;	// blank line
		}
		else if (szLine[0] == '{' &&	// balance: }
				 sscanf(szLine, "%s %s block at 0x%s %u bytes",
						szSeq, szBlockType, szAddr, &cb) == 4)
		{
		}
		else if (szLine[0] == '{' &&	// balance: }
				 sscanf(szLine, "%s %s block at 0x%s subtype %s %u bytes",
						szSeq, szBlockType, szAddr, szSubtype, &cb) == 5)
		{
		}
		else if (sscanf(szLine, "%s : %s %s block at %s %u bytes",
						szOrigin, szSeq, szBlockType, szAddr, &cb) == 5)
		{
		}
		else if (sscanf(szLine, "%s : %s %s block at %s subtype %s %u bytes",
						szOrigin, szSeq, szBlockType, szAddr, szSubtype, &cb) == 6)
		{
		}
		else if (sscanf(szLine, "*free* %s -- %u bytes long", szOrigin, &cb))
		{
			fAlloc = FALSE;
		}
		else
		{
			printf("unrecognized: \"%s\"\n", szLine);
			continue;
		}
	
		*(fAlloc ? &cbTotalAlloc : &cbTotalFree) += cb;
	
		// read the 2nd part of each block dump
		if (fAlloc)		// free lines have no 2nd part
		{
			ifs.getline(szLine, 500);
			if (strncmp(szLine, "a ", 2) == 0)
			{
				// got a name for the object type
				strcat(szOrigin, "\t");
				sscanf(szLine + 2, "%s", szOrigin + strlen(szOrigin));
			}
		}
	
		CMapStringToPtr &map = fAlloc ? m_mapAlloc : m_mapFree;
		COriginInfo *pinfo;
		if (!map.Lookup(szOrigin, (void *&)pinfo))
		{
			pinfo = new COriginInfo;
			map[szOrigin] = pinfo;
			pinfo->m_strOrigin = szOrigin;
		}
		pinfo->m_cBlocks += 1;
		pinfo->m_cbTotal += cb;
	}
}


CMemStat::CMemStat() {

	cbTotalAlloc = 0;
	cbTotalFree = 0;

}

void CMemStat::ReportInExcel()
{
	HFILE hfile = (HFILE)::CreateFile("\\heap.out", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hfile == (HFILE)INVALID_HANDLE_VALUE)
		return;

	{
		_HFILE hfilePrev = ::_CrtSetReportFile(_CRT_WARN, (_HFILE)hfile);
		int modePrev = ::_CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);

		::_CrtDumpMemoryLeaks();

		::_CrtSetReportFile(_CRT_WARN, hfilePrev);
		::_CrtSetReportMode(_CRT_WARN, modePrev);
	}

	// Dump all known freed blocks on the heap.
	// (There can only be known freed blocks if someone has set the _CRTDBG_DELAY_FREE_MEM_DF
	// flag.)
	_CrtMemState s;
	_CrtMemCheckpoint(&s);
	_CrtMemBlockHeader *poldblk;
	_CrtMemBlockHeader *pblk = poldblk = s.pBlockHeader;

	for ( pblk = s.pBlockHeader; pblk != NULL; pblk = pblk->pBlockHeaderNext)
	{
		if (pblk->nBlockUse != _FREE_BLOCK)
		{
			continue;	// ignore everything but free blocks
		}

		static char szBuf[300];
		if (pblk->szFileName != NULL)
		{
			sprintf(szBuf, "*free* %hs(%d) -- %u bytes long\n", pblk->szFileName, pblk->nLine,
					pblk->nDataSize);
		}
		else
		{
			sprintf(szBuf, "*free* [unknown] -- %u bytes long\n", pblk->nDataSize);
		}
		DWORD cbWritten;
		WriteFile((HANDLE)hfile, szBuf, strlen(szBuf), &cbWritten, NULL);
	}
	::CloseHandle((HANDLE)hfile);

	{
		Analize();
		PrintMap();
	}

	// Dump all CString.

	hfile = (HFILE)::CreateFile("\\strings.xls", GENERIC_WRITE, 0, 0, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);
	if (hfile == (HFILE)INVALID_HANDLE_VALUE)
		return;

	// (There can only be known freed blocks if someone has set the _CRTDBG_DELAY_FREE_MEM_DF
	// flag.)
	DWORD cbWritten;
	WriteFile((HANDLE)hfile, "String\tRefs\tSize\n", 18, &cbWritten, NULL);
	for ( pblk = poldblk; pblk != NULL; pblk = pblk->pBlockHeaderNext)
	{
		if (pblk->nBlockUse != _NORMAL_BLOCK)
		{
			continue;	// ignore everything but normal blocks
		}

		static char szBuf[1000]; // dont take any chances
		static char szBuf2[800]; // dont take any chances
		if ( pblk->szFileName != NULL && !strncmp( pblk->szFileName, "strcore", 7) )
		{
			CStringData *data = (CStringData *)(pblk+1);
			if( data->nAllocLength < 800 )
			{
				strcpy(szBuf2,data->data());
				int i=0;
				while( (szBuf2[i] != '\0') && (i<800) ){
					if(szBuf2[i]=='\t' || szBuf2[i]=='\n')
						szBuf2[i] = '~';
					i++;
				}
				sprintf(szBuf, "%s\t%d\t%d\n", szBuf2, data->nRefs, data->nAllocLength );
			} else {
				sprintf(szBuf, "%s\t%d\t%d\n", "string too long", data->nRefs, data->nAllocLength );
			}

			WriteFile((HANDLE)hfile, szBuf, strlen(szBuf), &cbWritten, NULL);
		}
	}
	::CloseHandle((HANDLE)hfile);
	ShellExecute(NULL,NULL,"\\strings.xls",NULL,NULL,0);
	ShellExecute(NULL,NULL,"\\heap.xls",NULL,NULL,0);

	return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\memstat.h ===
class CMemStat
{
public:
	HFILE m_hfile;
	unsigned cbTotalAlloc;
	unsigned cbTotalFree;
	CMemStat();
	CMapStringToPtr m_mapAlloc, m_mapFree;
	BOOL PrintMap( void );
	void Analize();
	void ReportInExcel();
};

// ****** WARNING *******
// The following is copied from CRT headers and may become out of date.
// (However this currently seems to be the only way to enumerate the free
// blocks in the heap.)
#define nNoMansLandSize 4
typedef struct _CrtMemBlockHeader
{
        struct _CrtMemBlockHeader * pBlockHeaderNext;
        struct _CrtMemBlockHeader * pBlockHeaderPrev;
        char *                      szFileName;
        int                         nLine;
        size_t                      nDataSize;
        int                         nBlockUse;
        long                        lRequest;
        unsigned char               gap[nNoMansLandSize];
        /* followed by:
         *  unsigned char           data[nDataSize];
         *  unsigned char           anotherGap[nNoMansLandSize];
         */
} _CrtMemBlockHeader;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\miscdlg.cpp ===
//
// Implementation for CRemoteTargetDlg and CCallingExeDlg classes
//
// History:
// Date				Who			What
// 03/23/94			colint			created
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"		// standard AFX include
#pragma hdrstop
#include "miscdlg.h"
#include "resource.h"
#include "msgboxes.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const char szDbgFilter[] =	"Executable Files (*.exe;*.com)\0*.exe;*.com\0All Files (*.*)\0*.*\0\0";

///////////////////////////////////////////////////////////////////////////////
// CRemoteTargetDlg implementation
///////////////////////////////////////////////////////////////////////////////

CRemoteTargetDlg::CRemoteTargetDlg(BOOL bBuild /* = FALSE */,
				   CWnd * pParent /* = NULL */)
	: C3dDialog(CRemoteTargetDlg::IDD, pParent)
{
	m_bBuild = bBuild;
}

BEGIN_MESSAGE_MAP(CRemoteTargetDlg, C3dDialog)
	//{{AFX_MSG_MAP(CRemoteTargetDlg)
		ON_EN_CHANGE(IDC_REMOTE_TARGET, OnNameChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
// BOOL CRemoteTargetDlg::OnInitDialog()
///////////////////////////////////////////////////////////////////////////////
BOOL CRemoteTargetDlg::OnInitDialog()
{
	CString strText;
	strText.LoadString(m_bBuild ? IDS_GET_REMTARG_BUILD : IDS_GET_REMTARG);	
	((CStatic *)GetDlgItem(IDC_REMOTE_TARGET_TXT))->SetWindowText(strText);
	((CEdit *)GetDlgItem(IDC_REMOTE_TARGET))->LimitText(255);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// void CRemoteTargetDlg::OnNameChange()
///////////////////////////////////////////////////////////////////////////////
void CRemoteTargetDlg::OnNameChange()
{
	BOOL bOK = ((CEdit *)GetDlgItem(IDC_REMOTE_TARGET))->LineLength() > 0;
	((CButton *)GetDlgItem(IDOK))->EnableWindow(bOK);
}

///////////////////////////////////////////////////////////////////////////////
// void CRemoteTargetDlg::OnOK()
///////////////////////////////////////////////////////////////////////////////
void CRemoteTargetDlg::OnOK()
{	
	CPlatform * pPlatform;
	CString str;
	BOOL bMacTarget;

	// Must have an active project!
	ASSERT(g_pActiveProject);
	pPlatform = g_pActiveProject->GetCurrentPlatform();
	bMacTarget = (pPlatform->GetUniqueId() == mac68k && pPlatform->IsSupported());

	if (bMacTarget)
	{
		// We must force macintosh path and file name
		// validation on the field as we have at least
		// one selected macintosh target in the tree
		// control.
		CString strRemote;
		BOOL bValidated = FALSE;
			
		CWnd * pWnd = GetDlgItem(IDC_REMOTE_TARGET);
		ASSERT(pWnd != (CWnd *)NULL);
		pWnd->GetWindowText(strRemote);

		if (!strRemote.IsEmpty())
		{
			// Must have a colon but cannot be the
			// first character in the string as this
			// indicates we have a relative pathname.
			int nPos = strRemote.Find(_T(':'));
			if (nPos == -1)
			{
				// No colon - must specify a volume
				// name
				InformationBox(IDS_MUST_SPECIFY_VOLUME_NAME, strRemote);
			}
			if (nPos == 0)
			{
				// Colon as first character - no
				// partial pathnames allowed.
				InformationBox(IDS_NO_PARTIAL_PATHNAMES, strRemote);
			}
			if (nPos > 0)
				// Pathname ok.
				bValidated = TRUE;
			
			if (!bValidated)
			{
				pWnd->SetFocus();
				((CEdit *)pWnd)->SetSel(0, -1);
				return;
			}
		}
	}

	((CEdit *)GetDlgItem(IDC_REMOTE_TARGET))->GetWindowText(str);

	// Must have an active project!
	ASSERT(g_pActiveProject);
	g_pActiveProject->SetStrProp(P_RemoteTarget, str);

	CDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////////
// void CRemoteTargetDlg::OnCancel()
///////////////////////////////////////////////////////////////////////////////
void CRemoteTargetDlg::OnCancel()
{
	CDialog::OnCancel();
}


///////////////////////////////////////////////////////////////////////////////
// CCallingExeDlg implementation
///////////////////////////////////////////////////////////////////////////////

CCallingExeDlg::CCallingExeDlg(BOOL bExecute /* = FALSE */,
			       CWnd * pParent /* = NULL */)
	: C3dDialog(CCallingExeDlg::IDD, pParent)
{
	m_bExecute = bExecute;
}

BEGIN_MESSAGE_MAP(CCallingExeDlg, C3dDialog)
	//{{AFX_MSG_MAP(CCallingExeDlg)
		ON_EN_CHANGE(IDC_CALLING_PROG, OnNameChange)
		ON_COMMAND(IDM_BROWSE_FOR_DEBUG_EXE, OnDebugBrowse)
		ON_COMMAND(IDM_USE_TESTCONTAINER, OnUseTestContainer)
		ON_COMMAND(IDM_USE_WEBBROWSER, OnUseWebBrowser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_POPUP_MENU(ExeFinder)
	MENU_ITEM(IDM_BROWSE_FOR_DEBUG_EXE)
	MENU_ITEM(IDM_USE_TESTCONTAINER)
	MENU_ITEM(IDM_USE_WEBBROWSER)
END_POPUP_MENU()

///////////////////////////////////////////////////////////////////////////////
// BOOL CCallingExeDlg::OnInitDialog()
///////////////////////////////////////////////////////////////////////////////
BOOL CCallingExeDlg::OnInitDialog()
{
	// call the base class
	C3dDialog::OnInitDialog();

	CString strText;
	strText.LoadString(m_bExecute ? IDS_GET_CALLING_PROG : IDS_GET_CALLING_PROG_DEBUG);
	((CStatic *)GetDlgItem(IDC_CALLING_PROG_TXT2))->SetWindowText(strText);

	if (!m_btnExeFinder.SubclassDlgItem(IDC_DEBUG_BROWSE, this))
		return FALSE;	// not ok

	m_btnExeFinder.SetPopup(MENU_CONTEXT_POPUP(ExeFinder));

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// void CCallingExeDlg::OnNameChange()
///////////////////////////////////////////////////////////////////////////////
void CCallingExeDlg::OnNameChange()
{
	BOOL bOK = ((CEdit *)GetDlgItem(IDC_CALLING_PROG))->LineLength() > 0;
	((CButton *)GetDlgItem(IDOK))->EnableWindow(bOK);
}

///////////////////////////////////////////////////////////////////////////////
// void CCallingExeDlg::OnOK()
///////////////////////////////////////////////////////////////////////////////
void CCallingExeDlg::OnOK()
{	
	CString str;

	((CEdit *)GetDlgItem(IDC_CALLING_PROG))->GetWindowText(str);

	CPath ExePath;
	CString strMsg;

	ExePath.Create(str);
	if(!FileExists(ExePath) && (MsgBox(Information, MsgText(strMsg,
				IDS_NO_DEBUG_EXE,  (const TCHAR *)ExePath))))
	{
		((CEdit *)GetDlgItem(IDC_CALLING_PROG))->SetFocus();
		return;
	}

	// Must have an active project!
	ASSERT(g_pActiveProject);
	g_pActiveProject->SetStrProp(P_Caller, str);

	CDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////////
// void CCallingExeDlg::OnCancel()
///////////////////////////////////////////////////////////////////////////////
void CCallingExeDlg::OnCancel()
{
	CDialog::OnCancel();
}

void CCallingExeDlg::OnDebugBrowse() 
{
	// TODO: Add your control notification handler code here
	CDbgBrowseDlg fDlg;

	if(fDlg.DoModal() == IDOK)
	{
		CEdit* ceBrowse = (CEdit *) GetDlgItem(IDC_CALLING_PROG);
		ceBrowse->SetWindowText(fDlg.GetFileName());
	}
}

void CCallingExeDlg::OnUseWebBrowser()
{
	CEdit* ceBrowse = (CEdit *) GetDlgItem(IDC_CALLING_PROG);
	ceBrowse->SetWindowText(CProject::s_strWebBrowser);
}

void CCallingExeDlg::OnUseTestContainer()
{
	CEdit* ceBrowse = (CEdit *) GetDlgItem(IDC_CALLING_PROG);
	ceBrowse->SetWindowText(CProject::s_strTestContainer);
}

////////////////////////////////////////////////////////////////////
// DebBrowse dialog class
// CDbgBrowseDlg
////////////////////////////////////////////////////////////////////

CDbgBrowseDlg::CDbgBrowseDlg() 
	: C3dFileDialog(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_SHOWHELP, NULL, 
		NULL, 0, 0)
{
	 m_szFileBuff[0] = _T('\0');
}

CDbgBrowseDlg::~CDbgBrowseDlg()
{
}

CString CDbgBrowseDlg::GetFileName()
{
	CString strFileName = m_szFileBuff;
	return strFileName;
}

int CDbgBrowseDlg::DoModal()
{
	CString	strTitle;

	strTitle.LoadString(IDS_DEBUG_BROWSE_TITLE);

	m_ofn.lpstrFilter = szDbgFilter;
	m_ofn.nMaxCustFilter = sizeof(szDbgFilter);
	m_ofn.lpstrTitle = strTitle;

	m_ofn.lpstrFile = m_szFileBuff;
	m_ofn.nMaxFile = MAX_PATH-1;
	m_ofn.lpstrFileTitle = NULL;
	m_ofn.nMaxFileTitle = 0;	 
	m_ofn.nFileOffset = 0;
	m_ofn.nFileExtension = 0;
	m_ofn.lpstrDefExt = NULL;

	return C3dFileDialog::DoModal(); 
}


///////////////////////////////////////////////////////////////////////////////
// CJavaDebugInfoDlg implementation
///////////////////////////////////////////////////////////////////////////////
CJavaDebugInfoDlg::CJavaDebugInfoDlg(BOOL bExecute /*= FALSE*/, CWnd * pParent /*= NULL*/)
: C3dDialog(CJavaDebugInfoDlg::IDD, pParent),
  m_bExecute(bExecute)
{
}

BEGIN_MESSAGE_MAP(CJavaDebugInfoDlg, C3dDialog)
	//{{AFX_MSG_MAP(CJavaDebugInfoDlg)
		ON_EN_CHANGE(IDC_JAVA_CLASS_FILE_NAME, OnChange)
		ON_BN_CLICKED(IDC_JAVA_USE_BROWSER, OnChangeDebugUsing)
		ON_BN_CLICKED(IDC_JAVA_USE_STANDALONE, OnChangeDebugUsing)
		ON_EN_CHANGE(IDC_JAVA_BROWSER, OnChange)
		ON_EN_CHANGE(IDC_JAVA_STANDALONE, OnChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
// CJavaDebugInfoDlg::DoDataExchange
void CJavaDebugInfoDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CJavaDebugInfoDlg)
	DDX_Control(pDX, IDC_JAVA_CLASS_FILE_NAME, m_editClassFileName);
	DDX_Control(pDX, IDC_JAVA_USE_BROWSER, m_btnBrowser);
	DDX_Control(pDX, IDC_JAVA_USE_STANDALONE, m_btnStandalone);
	DDX_Control(pDX, IDC_JAVA_BROWSER, m_editBrowser);
	DDX_Control(pDX, IDC_JAVA_STANDALONE, m_editStandalone);
	//}}AFX_DATA_MAP
}

///////////////////////////////////////////////////////////////////////////////
// CJavaDebugInfoDlg::OnInitDialog
BOOL CJavaDebugInfoDlg::OnInitDialog()
{
	// call the base class
	C3dDialog::OnInitDialog();

	// change title if we're executing instead of debugging
	// change description text if we're executing instead of debugging
	if (m_bExecute) {

		// change title
		CString strTitle;
		VERIFY(strTitle.LoadString(IDS_JAVA_CLASS_INFO_TITLE));
		SetWindowText(strTitle);

		// change group box text
		CWnd* pWnd = GetDlgItem(IDC_JAVA_DEBUGUSING_GRP);
		ASSERT(pWnd != NULL);
		if (pWnd != NULL) {
			CString strGroup;
			VERIFY(strGroup.LoadString(IDS_JAVA_CLASS_INFO_GRP_RUN));
			pWnd->SetWindowText(strGroup);
		}
	}

	// must have an active project
	ASSERT(g_pActiveProject != NULL);

	// load the class file name, if it's already set
	CString strClassFileName;
	if (g_pActiveProject->GetStrProp(P_Java_ClassFileName, strClassFileName) == valid)
		m_editClassFileName.SetWindowText(strClassFileName);

	// load debug using, if it's already set
	int nDebugUsing = Java_DebugUsing_Unknown;
	if (g_pActiveProject->GetIntProp(P_Java_DebugUsing, nDebugUsing) == valid) {
		switch (nDebugUsing) {
			case Java_DebugUsing_Browser:
				m_btnBrowser.SetCheck(1);
				m_btnStandalone.SetCheck(0);
				break;
			case Java_DebugUsing_Standalone:
				m_btnBrowser.SetCheck(0);
				m_btnStandalone.SetCheck(1);
				break;
		}
	}

	// load the browser, if it's already set
	CString strBrowser;
	g_pActiveProject->GetStrProp(P_Java_Browser, strBrowser);
	m_editBrowser.SetWindowText(strBrowser);

	// load the stand-alone interpreter, if it's already set
	CString strStandalone;
	g_pActiveProject->GetStrProp(P_Java_Standalone, strStandalone);
	m_editStandalone.SetWindowText(strStandalone);

	UpdateData(FALSE);

	// update the HTML viewer controls
	OnChangeDebugUsing();

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CJavaDebugInfoDlg::OnChangeDebugUsing
void CJavaDebugInfoDlg::OnChangeDebugUsing()
{
	UpdateData(TRUE);

	// enable/disable the browser edit control
	m_editBrowser.EnableWindow(m_btnBrowser.GetCheck() == 1);

	// enable/disable the stand-alone edit control
	m_editStandalone.EnableWindow(m_btnStandalone.GetCheck() == 1);

	// update the OK button
	OnChange();
}

///////////////////////////////////////////////////////////////////////////////
// CJavaDebugInfoDlg::OnChange
void CJavaDebugInfoDlg::OnChange()
{
	UpdateData(TRUE);

	BOOL bClassFileName = (m_editClassFileName.LineLength() > 0);
	BOOL bDebugUsing = (m_btnBrowser.GetCheck() == 1 || m_btnStandalone.GetCheck() == 1);
	BOOL bBrowser = (m_btnBrowser.GetCheck() == 0 || m_editBrowser.LineLength() > 0);
	BOOL bStandalone = (m_btnStandalone.GetCheck() == 0 || m_editStandalone.LineLength() > 0);

	// enable the OK button if a class file name, debug using, and browser and/or stand-alone
	// have been entered
	CButton* pBtn = (CButton*)GetDlgItem(IDOK);
	ASSERT(pBtn != NULL);
	pBtn->EnableWindow(bClassFileName && bDebugUsing && bBrowser && bStandalone);
}

///////////////////////////////////////////////////////////////////////////////
// CJavaDebugInfoDlg::OnOK
void CJavaDebugInfoDlg::OnOK()
{
	UpdateData(TRUE);

	// must have an active project
	ASSERT(g_pActiveProject != NULL);

	// set the class file name
	CString strClassFileName;
	m_editClassFileName.GetWindowText(strClassFileName);

	// we don't allow the user to enter a path or .class extension
	// (other extensions are allowed because we can't tell the
	// difference between the extension in java.lang.String and
	// an invalid extension)

	// split the class name into parts
	// (and eliminate any path that's entered)
	TCHAR szFileName[_MAX_PATH];
	TCHAR szExt[_MAX_EXT];
	_tsplitpath(strClassFileName, NULL, NULL, szFileName, szExt);

	// remove the extension if it's .class
	CString strNewClassFileName;
	if (_tcscmp(szExt, _T(".class")) == 0) {

		strNewClassFileName = CString(szFileName);
	}
	else {

		strNewClassFileName = CString(szFileName) + CString(szExt);
	}

	// set the class file name
	g_pActiveProject->SetStrProp(P_Java_ClassFileName, strNewClassFileName);

	// set debug using
	int nDebugUsing = (m_btnBrowser.GetCheck() == 1) ? Java_DebugUsing_Browser : Java_DebugUsing_Standalone;
	g_pActiveProject->SetIntProp(P_Java_DebugUsing, nDebugUsing);

	// set the browser
	CString strBrowser;
	m_editBrowser.GetWindowText(strBrowser);
	g_pActiveProject->SetStrProp(P_Java_Browser, strBrowser);

	// set the stand-alone interpreter
	CString strStandalone;
	m_editStandalone.GetWindowText(strStandalone);
	g_pActiveProject->SetStrProp(P_Java_Standalone, strStandalone);

	CDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////////
// CPlatformsDlg implementation
///////////////////////////////////////////////////////////////////////////////

CPlatformsDlg::CPlatformsDlg(CStringList * plstPlatforms, CWnd * pParent /* = NULL */)
	: C3dDialog(CPlatformsDlg::IDD, pParent)
{
	m_plstPlatforms = plstPlatforms;
}

BEGIN_MESSAGE_MAP(CPlatformsDlg, C3dDialog)
	//{{AFX_MSG_MAP(CPlatformsDlg)
 	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
// BOOL CPlatformsDlg::OnInitDialog()
///////////////////////////////////////////////////////////////////////////////
BOOL CPlatformsDlg::OnInitDialog()
{
	// Subclass the check listbox
	VERIFY(m_lbPlatforms.SubclassDlgItem(IDC_PLATFORMS, this));
	m_lbPlatforms.SetRedraw(FALSE);

	// call base class OnInitDialog
	C3dDialog::OnInitDialog() ;

	// Set the text to use the thin font
	GetDlgItem(IDC_PLATFORM_TEXT)->SetFont(GetStdFont(font_Normal));

	CPlatform * pPlatform;	CString strPlatformName;
	g_prjcompmgr.InitPlatformEnum();
	while (g_prjcompmgr.NextPlatform(pPlatform))
	{
        if (pPlatform->IsSupported() && pPlatform->GetBuildable())
        {
		    strPlatformName = *(pPlatform->GetUIDescription());
			if (pPlatform->GetUniqueId () == java)
				continue;

		    m_lbPlatforms.AddString(strPlatformName);
        }
	}

	// Check all the platforms as the default
	int nPlatforms = m_lbPlatforms.GetCount();
	for (int i = 0; i < nPlatforms; i++)
		m_lbPlatforms.SetCheck(i, TRUE);

	m_lbPlatforms.SetRedraw(TRUE);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// void CPlatformsDlg::OnOK()
///////////////////////////////////////////////////////////////////////////////
void CPlatformsDlg::OnOK()
{	
	// Construct the list of platforms
	int nItem, nPlatforms;

	// Construct a CStringList of the platforms
	m_plstPlatforms->RemoveAll();
	nPlatforms = m_lbPlatforms.GetCount();
	for (nItem = 0; nItem < nPlatforms; nItem++)
	{
		if (m_lbPlatforms.GetCheck(nItem))
		{	
			CString strPlatformName;

			m_lbPlatforms.GetText(nItem, strPlatformName);
			m_plstPlatforms->AddTail(strPlatformName);
		}
	}

	// We must have at least one platform selected.
	if (m_plstPlatforms->IsEmpty())
	{
		MsgBox(Information, IDS_BAD_PLATFORMS);
		return;
	}

	C3dDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////////
// void CPlatformsDlg::OnCancel()
///////////////////////////////////////////////////////////////////////////////
void CPlatformsDlg::OnCancel()
{
	C3dDialog::OnCancel();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\miscdlg.h ===
//
// miscdlg.h
//
// Defines CRemoteTargetDlg, and CCallingExeDlg classes, these are
// dialogs to obtain information that we don't have but need to complete
// a requested operation (e.g. updating remote target, or debugging)
//
// Implementation is in : miscdlg.cpp
//
// History:
// Date				Who			What
// 03/23/94			colint			created
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _MISCDLG_H_
#define _MISCDLG_H_

#include "resource.h"
#include "prjconfg.h"
#include <dlgbase.h>		// C3dDialog

///////////////////////////////////////////////////////////////////////////////
// CRemoteTargetDlg class
// definition for remote target dialog
///////////////////////////////////////////////////////////////////////////////

class CRemoteTargetDlg : public C3dDialog
{
// Construction
public:
	CRemoteTargetDlg (BOOL bBuild = FALSE, CWnd * pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CRemoteTargetDlg)
	enum { IDD = IDD_REMOTE_TARG_NAME };
	//}}AFX_DATA

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

public:
	//{{AFX_MSG(CRemoteTargetDlg)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	void OnNameChange();
	//}}AFX_MSG

// private data
private:
	BOOL m_bBuild;
};

///////////////////////////////////////////////////////////////////////////////
// CCallingExeDlg class
// definition for remote target dialog
///////////////////////////////////////////////////////////////////////////////

class CCallingExeDlg : public C3dDialog
{
// Construction
public:
	CCallingExeDlg (BOOL bExecute = FALSE, CWnd * pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CCallingExeDlg)
	enum { IDD = IDD_EXE_FOR_DEBUG };
	//}}AFX_DATA

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

public:
	//{{AFX_MSG(CCallingExeDlg)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	void OnNameChange();
	void OnDebugBrowse();
	void OnUseWebBrowser();
	void OnUseTestContainer();
	//}}AFX_MSG

// private data
private:
	BOOL m_bExecute;
	CMenuBtn m_btnExeFinder;
};

class CDbgBrowseDlg: public C3dFileDialog
{
// Construction
public:
	CDbgBrowseDlg();
	~CDbgBrowseDlg();

// Implementation
	int DoModal();
	CString GetFileName();

// private data
private:
	TCHAR m_szFileBuff[_MAX_PATH];
};


///////////////////////////////////////////////////////////////////////////////
// CJavaDebugInfoDlg class
// definition for Java debug info dialog
///////////////////////////////////////////////////////////////////////////////

class CJavaDebugInfoDlg: public C3dDialog
{
// Construction
public:
	CJavaDebugInfoDlg(BOOL bExecute = FALSE, CWnd * pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CJavaDebugInfoDlg)
	enum { IDD = IDD_JAVA_DEBUG_INFO };
	CButton m_btnBrowser;
	CButton m_btnStandalone;
	CEdit m_editClassFileName;
	CEdit m_editBrowser;
	CEdit m_editStandalone;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CJavaDebugInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

public:
	//{{AFX_MSG(CJavaDebugInfoDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	void OnChangeDebugUsing();
	void OnChange();
	//}}AFX_MSG

// private data
private:
	BOOL m_bExecute;
};

///////////////////////////////////////////////////////////////////////////////
// CPlatformsDlg class
// definition for platforms dialog
///////////////////////////////////////////////////////////////////////////////

class CPlatformsDlg : public C3dDialog
{
// Construction
public:
	CPlatformsDlg (CStringList * plstPlatforms, CWnd * pParent = NULL);

// Dialog Data
	//{{AFX_DATA(CPlatformsDlg)
	enum { IDD = IDD_PLATFORMS };
	//}}AFX_DATA

	CStringList	* m_plstPlatforms;

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

public:
	//{{AFX_MSG(CPlatformsDlg)
	virtual void OnOK();
	virtual void OnCancel();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

// private data
private:
	CCheckList m_lbPlatforms;
};

#endif // _MISCDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\mrdepend.cpp ===
//
// Implement minimal rebuild dependencies interface.
//
// [tomse]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "mrdepend.h"	// our local header file

#include <winver.h>
#include <mrengine.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

class EnumDepContext {
public:
	EnumDepContext() : 
		pstrList(NULL), 
		bRemovePchIncludes(FALSE), 
		bSourceFound(FALSE)
	{
	}
	CStringList* pstrList;
	BOOL bRemovePchIncludes;
	BOOL bSourceFound;
};

BOOL MRECALL
FEnumDepFile( PMREUtil pmre, EnumFile & ef, EnumType et )
{
	ASSERT(etDep==et);
	ASSERT(NULL!=ef.pvContext);
	EnumDepContext& context = *(EnumDepContext*)ef.pvContext;
	ASSERT(NULL!=context.pstrList);

	//
	// Don't add files that are included by precompiled header.
	//
	if (context.bRemovePchIncludes && ef.fiSrc.dwStatus & fsmInclByPch)
		return TRUE;

	//
	// Check for the slight possibility that ef.szFileSrc was not
	// updated.
	if (NULL!=ef.szFileSrc && ef.szFileSrc[0] != 0 )
		context.pstrList->AddTail(ef.szFileSrc);

	return TRUE;
}

BOOL MRECALL
FEnumSrcFile( PMREUtil pmre, EnumFile & ef, EnumType et )
{
	ASSERT(NULL!=ef.pvContext);
	EnumDepContext& context = *(EnumDepContext*)ef.pvContext;
	context.bSourceFound = TRUE;

	ASSERT(etSource==et);
	pmre->EnumDepFiles ( ef, FEnumDepFile );
	return TRUE;
}

typedef BOOL (MRECALL *FOpen_fnptr) (OUT PMREngine*	ppmre, SZC szPdb, EC& ec, 
	_TCHAR szErr[], BOOL fReproSig, BOOL fWrite );

class CMreDependencies : public IMreDependencies {
public:
	friend IMreDependencies* IMreDependencies::GetMreDependenciesIFace( LPCTSTR szIdbFile );
	virtual BOOL GetDependencies( LPCTSTR szPath, CStringList& strList, BOOL bUsePch );
	virtual BOOL Release();

private:
	CMreDependencies() : m_pMre(NULL), m_pMreUtil(NULL), m_cRef(0) {}
	unsigned m_cRef;
	PMREngine m_pMre;
	PMREUtil m_pMreUtil;
	static LPCTSTR szMspdbDll;
	static HINSTANCE s_hInstPdbDll;
	static FOpen_fnptr s_FOpen;

#if defined(_DEBUG)
public:
#endif
	// public for debug builds.
	static CMapStringToPtr m_OpenMreMap;
};

#if defined(_DEBUG)
// Make sure that CMreDependencies::m_OpenMreMap is empty when program is finished.
class CleanupMreDependencies {
public:
	~CleanupMreDependencies()
	{
		ASSERT(CMreDependencies::m_OpenMreMap.IsEmpty());
	}
};

CleanupMreDependencies tmpCleanup;
#endif

CMapStringToPtr CMreDependencies::m_OpenMreMap;
LPCTSTR CMreDependencies::szMspdbDll = _T("mspdb60.dll");
HINSTANCE CMreDependencies::s_hInstPdbDll = NULL;
FOpen_fnptr CMreDependencies::s_FOpen = NULL;

IMreDependencies* IMreDependencies::GetMreDependenciesIFace( LPCTSTR szIdbFile )
{
	CMreDependencies* pMreDepend = NULL;
	CString strKey = szIdbFile;
	strKey.MakeUpper();
	// Check map of open Mre files first.
	if (CMreDependencies::m_OpenMreMap.Lookup(strKey, (void*&)pMreDepend))
	{
		ASSERT(NULL!=pMreDepend);
		ASSERT(NULL!=pMreDepend->m_pMre);
		ASSERT(NULL!=pMreDepend->m_pMreUtil);
		ASSERT(0<pMreDepend->m_cRef);
		pMreDepend->m_cRef++;
	}
	else
	{
		pMreDepend = new CMreDependencies;
		PMREngine pMre;
		PMREUtil pMreUtil;
		TCHAR szErr[cbErrMax];
		EC ec;
		szErr[0] = 0;

		if (NULL!=pMreDepend)
		{
			if (CMreDependencies::m_OpenMreMap.IsEmpty())
			{
				ASSERT(NULL==CMreDependencies::s_hInstPdbDll);
				CMreDependencies::s_hInstPdbDll = LoadLibrary(CMreDependencies::szMspdbDll);
				ASSERT(NULL!=CMreDependencies::s_hInstPdbDll);

				if (NULL==CMreDependencies::s_hInstPdbDll)
					return NULL;

				ASSERT(NULL==CMreDependencies::s_FOpen);
				CMreDependencies::s_FOpen = (FOpen_fnptr)GetProcAddress(
					CMreDependencies::s_hInstPdbDll,
#if defined (_M_ALPHA)
					"?FOpen@MREngine@@SAHPAPAU1@PBDAAJQADHH@Z");
#else
					"?FOpen@MREngine@@SGHPAPAU1@PBDAAJQADHH@Z");
#endif

				ASSERT(NULL!=CMreDependencies::s_FOpen);

				if (NULL==CMreDependencies::s_FOpen)
				{
					VERIFY(FreeLibrary(CMreDependencies::s_hInstPdbDll));
					CMreDependencies::s_hInstPdbDll = NULL;
					return NULL;
				}
			}

			ASSERT(NULL!=CMreDependencies::s_hInstPdbDll);
			ASSERT(NULL!=CMreDependencies::s_FOpen);

            // n.b. Don't try to open .idb file unless it already exists
			if  ((_access(szIdbFile, 0) != -1) && ((*CMreDependencies::s_FOpen)( &pMre, szIdbFile, ec, szErr, FALSE, TRUE ) && pMre ))
			{
				pMre->QueryMreUtil(pMreUtil);
				ASSERT(NULL!=pMreUtil);
				pMreDepend->m_cRef = 1;
				pMreDepend->m_pMre = pMre;
				pMreDepend->m_pMreUtil = pMreUtil;
				CMreDependencies::m_OpenMreMap[strKey] = pMreDepend;
			}
			else
			{
				if (CMreDependencies::m_OpenMreMap.IsEmpty())
				{
					VERIFY(FreeLibrary(CMreDependencies::s_hInstPdbDll));
					CMreDependencies::s_hInstPdbDll = NULL;
					CMreDependencies::s_FOpen = NULL;
				}

				delete pMreDepend;
				pMreDepend = NULL;
			}
		}
	}

	return pMreDepend;
}

BOOL CMreDependencies::GetDependencies( LPCTSTR szPath, CStringList& strList, BOOL bUsePch )
{
	EnumDepContext context;
	context.bRemovePchIncludes = bUsePch;

	ASSERT(NULL!=m_pMre);
	ASSERT(NULL!=m_pMreUtil);
	strList.RemoveAll();

	context.pstrList = &strList;
	m_pMreUtil->EnumSrcFiles ( FEnumSrcFile, szPath, &context );

	return context.bSourceFound;
}

BOOL CMreDependencies::Release()
{
	BOOL bOk = 0 < m_cRef;

	ASSERT(NULL!=m_pMre);
	ASSERT(NULL!=m_pMreUtil);

	m_cRef--;
	if (0==m_cRef)
	{
		bOk = NULL!=m_pMreUtil && m_pMreUtil->FRelease() && bOk;
		bOk = NULL!=m_pMre && m_pMre->FClose (FALSE) && bOk;

		// Remove from map
		POSITION pos = m_OpenMreMap.GetStartPosition();
		ASSERT(pos!=NULL);
		while (NULL!=pos)
		{
			CString strFilename;
			CMreDependencies* pMreDepend;
			m_OpenMreMap.GetNextAssoc(pos,strFilename,(void*&)pMreDepend);
			ASSERT(NULL!=pMreDepend);
			if (this==pMreDepend)
			{
				VERIFY(m_OpenMreMap.RemoveKey(strFilename));
				if (m_OpenMreMap.IsEmpty())
				{
					ASSERT(NULL!=s_hInstPdbDll);
					if (NULL!=s_hInstPdbDll)
						VERIFY(FreeLibrary(s_hInstPdbDll));

					s_hInstPdbDll = NULL;
					s_FOpen = NULL;
				}

				break;
			}
		}
		delete this;
	}

	return bOk;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\mrdepend.h ===
//
// Declare minimal rebuild dependencies interface.
//
// [tomse]
//

#ifndef _INCLUDE_MRDEPEND_H
#define _INCLUDE_MRDEPEND_H

class IMreDependencies {
public:
	static IMreDependencies* GetMreDependenciesIFace( LPCTSTR szIdbFile );
	virtual BOOL GetDependencies( LPCTSTR szPath, CStringList& strList, BOOL bUsePch ) = 0;
	virtual BOOL Release() = 0;
};

#endif // _INCLUDE_MRDEPEND_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\newgrp.cpp ===
// newgrp.cpp : implementation file
//

#include "stdafx.h"
#pragma hdrstop

#include "newgrp.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;

#define new DEBUG_NEW
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewGroupDlg dialog

CNewGroupDlg::CNewGroupDlg(CWnd* pParent /*=NULL*/)
	: C3dDialog(IDD_NEW_PROJ_GRP, pParent)
{
	//{{AFX_DATA_INIT(CNewGroupDlg)
		m_strGroup = "";
		m_strGroupFilter = "";
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

void CNewGroupDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewGroupDlg)
		DDX_Text(pDX, IDC_GROUPNAME, m_strGroup);
		DDX_Text(pDX, IDC_GROUPFILTER, m_strGroupFilter);
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CNewGroupDlg, C3dDialog)
	//{{AFX_MSG_MAP(CNewGroupDlg)
	ON_EN_CHANGE(IDC_GROUPNAME, OnChangeGroup)
	ON_BN_CLICKED(IDOK, OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewGroupDlg message handlers

BOOL CNewGroupDlg::OnInitDialog()
{
	C3dDialog::OnInitDialog();
	CenterWindow();

	((CEdit *)GetDlgItem( IDC_GROUPNAME ))->LimitText( 30 );
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CNewGroupDlg::OnChangeGroup()
{
	// If there is text in the new group control, enable the OK button
	CString strGroup;
	ASSERT( GetDlgItem( IDC_GROUPNAME ) );
	GetDlgItem( IDC_GROUPNAME )->GetWindowText( strGroup );

	ASSERT( GetDlgItem( IDOK ) );
	GetDlgItem( IDOK )->EnableWindow( strGroup.GetLength() );
}

void CNewGroupDlg::OnOK()
{
	UpdateData();

	CString strExternalDeps; strExternalDeps.LoadString(IDS_EXT_DEPENDENCIES);
	StripLeadingAndTrailingWhite( m_strGroup );
	if (m_strGroup.IsEmpty())
	{
		MsgBox (Error, IDS_NO_EMPTY_GROUP) ;
		CEdit *pEdit = (CEdit *) GetDlgItem( IDC_GROUPNAME );

		pEdit->SetWindowText( "" );
		GotoDlgCtrl( pEdit );
	}
	else if (m_strGroup.CompareNoCase(strExternalDeps)==0)
	{
		
		CString	strError;

		MsgBox(Error, MsgText(strError, IDS_ERR_BAD_FOLDER, m_strGroup));
		CEdit *pEdit = (CEdit *) GetDlgItem( IDC_GROUPNAME );

		pEdit->SetWindowText( "" );
		GotoDlgCtrl( pEdit );
	}
	else
	{
		// UNDONE: validate filter
		C3dDialog::OnOK();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\makread.h ===
//////////////////////////////////////////////////////////////////////
// MAKREAD.H
//
// Definition of CMakFileReader and CMakFileWriter objects.
//
// History
// =======
// Date			Who			What
// ----			---			----
// 30-May-93	mattg		Created
// 07-Jun-93	mattg		Added to VSHELL
// 21-Jul-93    v-danwh     Added CNameMunger and CMakFileWriter
//
// Description
// ===========
// The CMakFileReader object will read in a .MAK file which has been
// written out by the IDE.  It accepts a subset of the NMAKE syntax.
//
// The CMakFileReader will read:
//
// - Blank lines
//		- Ignored
// - Lines containing only whitespace
//		- Ignored
// - Lines containing only a comment, possibly with leading whitespace
//		- Returns text of comment (remainder of line)
// - Macro definitions
//		- Returns name and value
//		- Handles value continuation with trailing '\'
//		- Does NOT handle any other special characters
//		- Does NOT check for invalid characters in macro name
// - Directives
//		- Recognizes all types of directives
//		- Returns type of directive
//		- Returns remainder of directive line
//			- CMakFileReader user is responsible for interpretation
// - Description blocks
//		- Accepts :: dependency lines (although no difference in handling)
//		- Returns left side (targets), right side (deps) and commands
//		- Handles deps continuation with trailing '\'
//		- Handles inline file specifications
//		- Does NOT handle any other special characters
//////////////////////////////////////////////////////////////////////

#ifndef __MAKREAD_H__
#define __MAKREAD_H__

#ifndef _SUSHI_PROJECT
// If you are encluding this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

#ifndef __UTIL_H__
#include "util.h"	// CMakFileWriter uses CFileSaver class
#endif

// standard include

//////////////////////////////////////////////////////////////////////
// Classes defined in this file

// CObject
	class CMakComment;
	class CMakMacro;
	class CMakDescBlk;
	class CMakDirective;
	class CMakError;
	class CMakEndOfFile;
	class CMakFileReader;
	class CMakFileWriter;
	class CNameMunger;
//////////////////////////////////////////////////////////////////////
// Helper routines

extern VOID		StripLeadingWhite(CString &);
	// Strip leading whitespace from the referenced string IN PLACE
	// (i.e., the string passed in is altered).  Whitespace is considered
	// to consist of spaces and tabs only.

extern VOID		StripTrailingWhite(CString &);
	// Strip trailing whitespace from the referenced string IN PLACE
	// (i.e., the string passed in is altered).  Whitespace is considered
	// to consist of spaces and tabs only.

extern VOID		StripLeadingAndTrailingWhite(CString &);
	// Strip leading AND trailing whitespace from the referenced string
	// IN PLACE (i.e., the string passed in is altered).  Whitespace is
	// considered to consist of spaces and tabs only.

extern VOID		SkipWhite(const TCHAR * &);
	// Skips to the next non-white character, where whitespace considered
	// to consist of tabs and spaces only.  On entry, the pointer points
	// to the first character to test; on exit, it will point to the first
	// non-white character (including possibly the '\0' string terminator).
extern VOID		SkipNonWhite(const TCHAR * &);
	// Opposite of above

extern int  GetMakToken(const TCHAR * pBase, const TCHAR *& pTokenEnd);
	// Fast forward to the end of the next token in the string at pBase.
	// Returns the number of _characters_ in the token.  Tokens are 
	// are delimetered by whitespace unless inside double quotes.  Quotes
	// Routine does not account for quotes inside quotes.

extern BOOL GetQuotedString(const TCHAR *& pBase, const TCHAR *& pEnd); 
	// Look through the string to find a quoted substring. On return
	// pBase points to first char after first pEnd points to last quote.
	// Return FALSE if < 2 quotes or 0 length substring.

//////////////////////////////////////////////////////////////////////
// CNameMunger class
//
// Takes names containing possibly nasty characters and produces
// a nice name (i.e. suitable as an NMAKE macro name) guranteed not
// to collide with any other names it produced/
class CNameMunger : public CObject
{

public:
	CNameMunger() { m_InMap.InitHashTable(179); m_ResMap.InitHashTable(197); }
	void MungeName (const TCHAR *, CString &);
private:

	// Special subclass of CMapStringToPtr  that returns a poitner
	// to the stored value when it sets a new element:
	class CMungeMapStringToPtr : public CMapStringToPtr
	{
	public:
		// Okay, the way this works is that the usua CMapXXXtoXXX
		// [] oparator returns a pointer to the key in the new
		// CAssoc it has created.  We calcualte the offset between
		// the key and the value and use that to get the address
		// of the value itself.  Yes, this is a GIGA-hack, but the
		// CSlob property bag stuff uses the same principle.  So sue me.
		 
		inline CString *GetStringAddressFromPtr ( void *& rvoid )
		{
		return (CString *) ( ( (BYTE *) &rvoid) - 
							 ( (BYTE *) &((CAssoc *) 0)->value )
	 						+( (BYTE *) &((CAssoc *) 0)->key   ) );
		}
		inline CString *SetAtAndReturnStringAddress (	
										const char* key 
										)
		{
		return GetStringAddressFromPtr ((*this)[key]);
		}

	};

	// We store the previosly seen names in a map which maps 
	// strings to pointers to void.  The void pointers are actually
	// pointers to CStrings which are values in anohter map which
	// contains Munged names we've previously used.  This allows
	// to quickly see if there is already a munged name for an
	// input string, and to see if a possible munged name has already
	// been used:
	CMapStringToPtr m_InMap;
	CMungeMapStringToPtr m_ResMap;

};

// CMak* builder component classes are declared here
#include "bldrcvtr.h"

//////////////////////////////////////////////////////////////////////
//
// Attributes of reading and writing of makefiles
#define MakRW_ShowStatus	0x1
#define MakR_IgnLineCont	0x2
#define MakW_Makefile		0x4
#define MakW_Depfile		0x8
#define MakRW_Default		MakRW_ShowStatus

//////////////////////////////////////////////////////////////////////
// CMakFileReader

#ifdef _UNICODE
#define MAK_EOF		((TCHAR)0xFFFF)
#else
#define MAK_EOF		((TCHAR)0xFF)
#endif

// Line prefix for indented lines ( e.g. "    " )
extern const TCHAR *szMkLineIndent;
extern const TCHAR cMkContinuation;

class BLD_IFACE CMakFileReader : public CObject
{
private:
	// Local types

	enum { CCH_BUF = 512 };
	// Data

			CFile		m_file;
				// Current open file.
			DWORD		m_nFileSize;

			UINT		m_nLineNum;
				// Current line number.

			TCHAR		m_rgchBuf[CCH_BUF];
				// Buffer for buffered I/O.

			UINT		m_ichBuf;
				// Index of next TCHAR in m_rgchBuf[].

			BOOL		m_fEOF;
				// TRUE if end-of-file has been reached, FALSE if not.

			UINT		m_cchFile;
				// Our count of chars through the file so far

			CObject	*	m_pUngotElement;

			int			m_nObjectsRead;

  			UINT		m_iAttrib;	// attributes of makefile reading

			UINT		m_nProgressGoal;
			static const int nStatusBarUpdate;

	// Read/write methods

			VOID		FillBuf();
				// Fills the buffer with up to CCH_BUF - 1 TCHARs from
				// the file.
				//
				// throw(CFileException)

	inline	TCHAR		GetChar()
						{
							if (m_rgchBuf[m_ichBuf] == _T('\0'))
								FillBuf();

							return(m_rgchBuf[m_ichBuf++]);
						}
				// Returns the next TCHAR.  If the TCHAR MAK_EOF is returned,
				// check m_fEOF to ensure an end-of-file condition.
				//
				// throw(CFileException)

	inline	TCHAR		PeekChar()
						{
							if (m_rgchBuf[m_ichBuf] == _T('\0'))
								FillBuf();

							return(m_rgchBuf[m_ichBuf]);
						}
				// Returns the next TCHAR without incrementing the index (i.e.,
				// a subsequent call to GetChar() will return the same TCHAR).
				// If the TCHAR MAK_EOF is returned, check m_fEOF to ensure an
				// end-of-file condition.
				//
				// throw(CFileException)

			BOOL		GetLine(CString &);
				// Fetches the next line into the referenced string.
				//
				// The resulting string does NOT have a trailing
				// carriage-return + linefeed pair.
				//
				// Returns TRUE if successful, FALSE at end-of-file.
				//
				// throw(CFileException)

			CObject *	ParseDirective(const CString &);
				// Parse the specified line as a directive and return
				// one of the following objects:
				//
				// CMakDirective
				// CMakError
				//
				// It is the caller's responsibility to free the object
				// returned.

			CObject *	ParseMacro(const CString &, int);
				// Parse the specified line as a macro definition and
				// return one of the following objects:
				//
				// CMakMacro
				// CMakError
				//
				// The INT parameter specifies the TCHAR offset within
				// the string of the '=' character which was found.
				//
				// It is the caller's responsibility to free the object
				// returned.
				//
				// throw(CFileException)

			CObject *	ParseDescBlk(const CString &, int);
				// Parse the specified line as the dependency line of a
				// description block and return one of the following
				// objects:
				//
				// CMakDescBlk
				// CMakError
				// CMakEndOfFile
				//
				// The INT parameter specifies the TCHAR offset within
				// the string of the ':' character which was found.
				//
				// It is the caller's responsibility to free the object
				// returned.
				//
				// throw(CFileException)

public:
	// Constructors, destructors

						CMakFileReader();
	virtual				~CMakFileReader();

	// Open and close methods

			BOOL		Open(
							 const TCHAR *, 
							 UINT, 
							 CFileException *,
							 UINT iAttrib = MakRW_Default
							);
				// Open the .MAK file for reading.  The first parameter
				// specifies the filename, and the second parameter specifies
				// the access mode as per the CFile constructor (e.g.,
				// CFile::modeRead).  The third parameter is a pointer to an
				// existing CFileException object, whose contents are meaningful
				// after the call only if this method returns FALSE.

				// Re-open the .MAK file for reading, ie. start reading from
				// beginning of file.
			void		ReOpen();

				// Attributes of makefile reading.
	__inline void		SetAttributes(UINT iAttrib) {m_iAttrib = iAttrib;}

				// Return the current line being read.
	__inline UINT		GetCurrentLine() {return m_nLineNum;}

				//  Abort after an exception:
			void		Abort(); 

			VOID		Close();

			CObject *	GetNextElement();
				// Get the next element of the .MAK file.  Returns one of:
				//
				// CMakComment
				// CMakMacro
				// CMakDescBlk
				// CMakDirective
				// CMakError
				// CMakEndOfFile
				//
				// cast to a CObject.  It is the caller's responbility to
				// free the resulting object.
				//
				// throw(CFileException)
			void UngetElement (CObject *);
				// Return an element to the read so that it will be 
				// used for the GetNextElementCall.  Depth is limited
				// to one.
};

//////////////////////////////////////////////////////////////////////
// CMakFileWriter

class BLD_IFACE CMakFileWriter : public CObject
{
private:
			int				m_nCharCount;

			CFile			m_File;
			CFileSaver *	m_pFileSaver;

			// Set this small for testing so we see all the buffer behavior,
			// large for release:
			#ifdef _DEBUG
			enum { CCH_BUF = 16 };  
			#else
			enum { CCH_BUF = 1024 };  
			#endif

			BYTE			m_buf[CCH_BUF];

			int 			m_CurrentPos;
				// Position within the file buffer.
			static const int nLineLen;
				// Desired maxmimum line length when writing out make file.
				// (Since we won't break up long items, we may go over this)

			BOOL	m_bLastLineBlank;

			UINT	m_iAttrib;	// attributes of makefile writing

			UINT		m_nProgressGoal;
			static const int nStatusBarUpdate;

			int		m_nObjects;
			int		m_nObjectsWritten;
			BOOL		m_bInit;

public:
	// Constructors, destructors

						CMakFileWriter();
	virtual				~CMakFileWriter();

	
	// Open and close methods
			BOOL		Create(
							   const TCHAR *,
							   CFileException *,
							   int = 0,
							   UINT iAttrib = MakRW_Default
							  );
			// The third paramter is the number of object we intend to
			// write out, and is used to upadate the status bar.

			// attributes of makefile writing
	__inline void		SetAttributes(UINT iAttrib) {m_iAttrib = iAttrib;}
	__inline BOOL	IsMakefile(void) { return ((m_iAttrib & MakW_Makefile)!=0); }
	__inline BOOL	IsDepFile(void) { return ((m_iAttrib & MakW_Depfile)!=0); }
	__inline BOOL	IsProjectFile(void) { return ((m_iAttrib & (MakW_Depfile|MakW_Makefile))==0); }
	__inline BOOL	IsInit(void) { return m_bInit; }

			const TCHAR* GetFileName();
			// Returns the name of the file that this MakeFile Writer
			// is writing to

			void		WroteObject ();
			// Call when your through writing an object.  Used to update
			// the status bar.

			//  Abort after an exception:
			void		Abort(); 
			//	Open the supplied for for writing, and write our header
			//  into it.
	 		BOOL		Close();
				// Close the .MAK file.

	// Basic output methods:
			void		WriteString ( const TCHAR * );
				// throw(CFileException)
				// Writes a string into the make file.  If the string
				// would make the line longer that nLineLen, we'll try
				// to break it in some reasonable way: Between words that
				// are not in quotes.

			void		WriteStringEx ( const TCHAR * );
				// throw(CFileException)
				// Writes a string into the make file.  No special formatting
				// is performed, making this very similar to WriteBytes
				// except it updates the various member variables properly.

			void 		WriteBytes ( const BYTE *pByte, int nBytes );
				// This should be treated as Private and not used unless
				// absolutely necessary.  Use WriteStringEx() instead.

			void 		EndLine ();
				// throw(CFileException)
				// Start a new line.				
		
			void 		InsureSpace ();
				// Starts a new line _unless_ the last line was blank.
				// Use to insure nive spacing.
			void 		SplitLine ();
				// throw(CFileException)
				// Write configuration character and start new line.				
			void 		Indent ();
				// Indent from begging of line (should only be called 
				// at start of line).

			void 		WriteSeperatorString ();
				// Writes a line of #'s
				 
	// High level output:

			void 		WriteComment (const TCHAR *pszFormat);
			void 		WriteCommentEx (const TCHAR *pszFormat, ...);
				//	Note: comment lines are not broken up to fit in nLineLen.

			void 		WriteDirective (CMakDirective::DTYP, CString &str );
			void 		WriteDirective (CMakDirective::DTYP, const TCHAR *pszText);
			void		WriteMacro (const TCHAR *pszLeftSide, const TCHAR *pszRightSide);
			void		WriteDesc (const TCHAR *pszTargets, const TCHAR *pszDependency);
			void		WriteDescAndAction
						(
							const TCHAR *pszTargets,
							const TCHAR *pszDependency,
							const TCHAR *pszActions
						);

};				// throw(CFileException)

#endif // __MAKREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnbsc.h ===
//
// Browser Database Make Tool Options
//
// [matthewt]
//

#ifndef _INCLUDE_OPTNBSC_H
#define _INCLUDE_OPTNBSC_H

#include "projprop.h"	// our option property ids
#include "prjoptn.h"	// macros used to decl/defn our tables
#include "optnbsc.h2"	// our option control IDs

#include "optncplr.h"	// our prop. ID for /Zn so we can link /Iu to it

//----------------------------------------------------------------
// our browser database make tool option property pages
//----------------------------------------------------------------

class CBscMakePageTab : public COptionMiniPage
{
	DECLARE_DYNCREATE(CBscMakePageTab)
public:
	virtual BOOL Validate();
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
};

//----------------------------------------------------------------
// our 'General' option property page
//----------------------------------------------------------------

class CBscMakeGeneralPage : public CBscMakePageTab
{
	DECLARE_DYNCREATE(CBscMakeGeneralPage)
	DECLARE_IDE_CONTROL_MAP()
};

//----------------------------------------------------------------
// our option property pages
//----------------------------------------------------------------

extern CRuntimeClass * g_bscTabs[];

//----------------------------------------------------------------
// our COMMON bscmake option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	BscMake, /* name */
	szAddOnGeneric, BCID_OptHdlr_BscMake, /* generic bscmake option handler */
	szAddOnGeneric, BCID_Tool_BscMake /* generic bscmake tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option page
	virtual UINT GetNameID() {return IDS_BSCMAKE;}
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_bscTabs;}

	// reset our 'deferred' props (eg. On demand bscmake)
 	virtual void ResetPropsForConfig(ConfigurationRecord * pcr);
 	virtual BOOL CanResetPropsForConfig(ConfigurationRecord * pcr);

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// return a 'fake' string/int prop
	virtual GPT GetDefStrProp(UINT idProp, CString & val);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// handle setting of option string props
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal);

	int GetTabDlgOrder()
		{ return 70; }

private:
	// form a 'fake' string prop
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);

END_OPTHDLR()

// bscmake tool properties
#define P_BscMakeUnknownOption				0x0000
#define P_BscMakeUnknownString				0x0001
#define P_BscMakeOutputFilename				0x0002
#define P_InclUnref							0x0003
#define P_BscMakeNoLogo						0x0004

// bscmake tool options (option ids)
#define IDOPT_BSCMAKE_OUTNAME				IDOPT_BASE + 0
#define IDOPT_BSCMAKE_INCUNREF				IDOPT_BASE + 1
#define IDOPT_BSCMAKE_NOLOGO				IDOPT_BASE + 2

#endif // _INCLUDE_OPTNBSC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnbsc.cpp ===
// 
// Browser Database Make Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "optnbsc.h"	// our local header file

BEGIN_OPTSTR_TABLE(BscMake, P_BscMakeUnknownOption, P_BscMakeUnknownString, P_BscMakeUnknownOption, P_BscMakeNoLogo, TRUE)
	IDOPT_BSCMAKE_NOLOGO,	"nologo%T1",		OPTARGS1(P_BscMakeNoLogo),				single,
	IDOPT_BSCMAKE_INCUNREF,	"Iu%T1",			OPTARGS1(P_InclUnref),					single,
	IDOPT_BSCMAKE_OUTNAME,	"o%1",				OPTARGS1(P_BscMakeOutputFilename),		single,
	IDOPT_UNKNOWN_OPTION,	"",					NO_OPTARGS,								single,
	IDOPT_UNKNOWN_STRING,	"",					NO_OPTARGS,								single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(BscMake)
	OPTDEF_PATH(BscMakeOutputFilename, "")
	OPTDEF_BOOL(InclUnref, FALSE)
	OPTDEF_BOOL(BscMakeNoLogo, FALSE)
END_OPTDEF_MAP()

IMPLEMENT_DYNCREATE(CBscMakePageTab, COptionMiniPage)
IMPLEMENT_DYNCREATE(CBscMakeGeneralPage, CBscMakePageTab)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// bscmake tool option default map 'faking'

BOOL OPTION_HANDLER(BscMake)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_BscMakeOutputFilename);
}

UINT OPTION_HANDLER(BscMake)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_BscMakeOutputFilename)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OPTION_HANDLER(BscMake)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	ASSERT(idPropL == P_BscMakeOutputFilename);

	CString strBase, strOutDir;

    CProjItem * pItem = ((CProjItem *)m_pSlob);
	CDir dirWorkspace = pItem->GetProject()->GetWorkspaceDir();
	CDir dirProject = pItem->GetProject()->GetProjDir(pItem->GetActiveConfig());
	CString strWorkspace = (const TCHAR *)dirWorkspace;
	CString strProject = (const TCHAR *)dirProject;

	if (strWorkspace.CompareNoCase(strProject) == 0)
	{
		const CPath * ppathProj = pItem->GetProject()->GetFilePath();
		ppathProj->GetBaseNameString(strBase);
	}
	else
	{
		// subproject
		ASSERT( (strProject.GetLength() > strWorkspace.GetLength()) );
		strBase = strProject.Right(strProject.GetLength()-strWorkspace.GetLength()-1);
	}

	// which output directory do we want to use?
	UINT idOutDirProp = GetFakePathDirProp(idProp);
	ASSERT(idOutDirProp != (UINT)-1);

	VERIFY(m_pSlob->GetStrProp(idOutDirProp, strOutDir) == valid);

	strVal = "";

	if (!strOutDir.IsEmpty())
	{
		TCHAR * pchStart;
		TCHAR * pchLast;

		strVal = strOutDir;

		// Ensure the copied output directory string ends in a backslash.
		pchStart = (TCHAR *)(const TCHAR *)strVal;
		pchLast = pchStart + strVal.GetLength();
		pchLast = _tcsdec(pchStart, pchLast);

		if (*pchLast != _T('/') && *pchLast != _T('\\'))
			strVal += _T('/');
	}

	strVal += strBase;
	strVal += _T(".bsc");
}

GPT OPTION_HANDLER(BscMake)::GetDefStrProp(UINT idProp, CString & val)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_BscMakeOutputFilename)
	{
		FormFakeStrProp(idProp, val);
		return valid;
	}

	return COptionHandler::GetDefStrProp(idProp, val);
}

void OPTION_HANDLER(BscMake)::ResetPropsForConfig(ConfigurationRecord * pcr)
{
	// do the base-class thing first
	COptionHandler::ResetPropsForConfig(pcr);

	// reset our 'deferred' prop.
	pcr->BagCopy(BaseBag, CurrBag, P_NoDeferredBscmake, P_NoDeferredBscmake, TRUE);
}

BOOL OPTION_HANDLER(BscMake)::CanResetPropsForConfig(ConfigurationRecord * pcr)
{
	// do the base-class thing first
	if (COptionHandler::CanResetPropsForConfig(pcr))
		return TRUE;	// no need to check anymore

	// check our 'deferred' prop.
	return !pcr->BagSame(BaseBag, CurrBag, P_NoDeferredBscmake, P_NoDeferredBscmake, TRUE);
}

void OPTION_HANDLER(BscMake)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// do we need special processing?
	if (idPropL == P_BscMakeOutputFilename)
	{
		CProjItem * pItem = (CProjItem *)m_pSlob;

		if (strVal.IsEmpty())
			pItem->GetPropBag()->RemovePropAndInform(idProp, m_pSlob);

		CProject * pProject = pItem->GetProject();
		if (pItem->UsePropertyBag() == CurrBag && pProject->m_bProjectComplete)
			// the user has potentially changed the .BSC name
			// (put other possible target changes here)
			theApp.NotifyPackages(PN_CHANGE_BSC);
	}
}

BOOL CBscMakePageTab::OnCommand(WPARAM wParam, LPARAM lParam)
{
	if (COptionMiniPage::OnCommand(wParam,lParam))
	{
		HWND hWndCtl = (HWND)(lParam);
		UINT nNotify = HIWORD(wParam);
		UINT nId = LOWORD(wParam);

		if (nId == IDC_BSCMAKE_NOTDEFERRED && IsDlgButtonChecked(IDC_BSCMAKE_NOTDEFERRED) )
		{
			//
			// Warn user if setting to build browse info file but compiler settings
			// do not build .sbr files.
			//
			CProjItem * pItem = ((CProjItem *)m_pSlob);
			CProject * pProject = pItem->GetProject();
			COptionHandler * popthdlr;
			VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler),
													 (CBldSysCmp *&)popthdlr));

			UINT idCompilerProp = popthdlr->MapLogical(P_GenBrowserInfo);
			int nCompilerGeneratesSbr = 0;

			if (m_pSlob->GetIntProp(idCompilerProp, nCompilerGeneratesSbr) != valid || 0==nCompilerGeneratesSbr)
			{
				//
				// Warn user.
				//
				AfxMessageBox( IDS_WRN_SETBROWSEINFO, MB_OK | MB_ICONWARNING );
			}
		}

		return TRUE;
	}
	return FALSE;
}


BOOL CBscMakePageTab::Validate()
{
	if (m_nValidateID == IDC_BSCOUTNAME)
	{
		if (!Validate_Destination(IDC_BSCOUTNAME, IDS_DEST_BSC,
							 	  "bsc",	// must be extension
								  FALSE,	// must be directory
							 	  TRUE))	// cant be directory
			return FALSE;
	}

	if (m_nValidateID == IDC_OPTSTR)
	{
		if (!Validate_DestinationProp(P_BscMakeOutputFilename, IDOPT_BSCMAKE_OUTNAME,
									  IDC_OPTSTR, IDS_DEST_BSC,
									  "bsc",	// must have extension
									  FALSE,	// must be directory
									  TRUE))	// cant be directory
			return FALSE;

		return TRUE;
	}

	return COptionMiniPage::Validate();
}

// bscmake tool option property page
CRuntimeClass * g_bscTabs[] = 
{
	RUNTIME_CLASS(CBscMakeGeneralPage),
	(CRuntimeClass *)NULL,
};

// bscmake tool option property page

BEGIN_IDE_CONTROL_MAP(CBscMakeGeneralPage, IDDP_PROJ_BSCMAKE, IDS_BSCMAKE)
	MAP_CHECK(IDC_BSCNOLOGO, P_BscMakeNoLogo)
	MAP_CHECK(IDC_BSCMAKE_NOTDEFERRED, P_NoDeferredBscmake)
	MAP_EDIT(IDC_BSCOUTNAME, P_BscMakeOutputFilename)
END_IDE_CONTROL_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optndlg.cpp ===
//
// CProjOptionDlg
//									

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "optndlg.h"	// our local header
#include "prjconfg.h"	// CConfigEnum
#include "optnui.h"		// COptionPageTab
#include "toolsdlg.h"	// the 'Custom Build' page
#include "projpage.h"	// the Tool 'General' page
#include "exttarg.h"	// the External target type
#include "depgraph.h"	// dep. graph
#include "javadbg.h"	// Java debugger support
#include "bldslob.h"
#include "bldnode.h"
#include "vwslob.h"
#include "vproj.hid"

#include <prjapi.h>
#include <prjguid.h>

IMPLEMENT_DYNCREATE(COptionTreeCtl, CTreeCtl)
IMPLEMENT_DYNAMIC(CProjOptionsDlg, CTabbedDialog)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CProjComponentMgr g_prjcompmgr;

// these are our 'pseudo' option handlers
// they can be put in the option handler list (m_listHdlrs)
// so that they are added as tabs to the 'mondo' dialog
// (ie. this is a hack so we can treat non-tool option pages
// just like the regular tool option pages returned from
// each handler)
#define OPTHDLR_TOOL_GENERAL		(COptionHandler *)0x0001
#define OPTHDLR_DEBUG				(COptionHandler *)0x0002
#define OPTHDLR_EXT_OPTS			(COptionHandler *)0x0003
#define OPTHDLR_EXTTARG_OPTS		(COptionHandler *)0x0004
#define OPTHDLR_CUSTOM_BUILD		(COptionHandler *)0x0005
#define OPTHDLR_PRELINK				(COptionHandler *)0x0006
#define OPTHDLR_DEBUG_JAVA			(COptionHandler *)0x0007
#define OPTHDLR_JAVA_TOOL_GENERAL	(COptionHandler *)0x0008
#define OPTHDLR_POSTBUILD			(COptionHandler *)0x0009

#define NEWCFG 1
#define MPROJ 1
void COptionTreeStore::Clear()
{
	POSITION pos = m_lstStates.GetHeadPosition();
	while (pos != (POSITION)NULL)
		delete (CNodeState *) m_lstStates.GetNext(pos);

	m_lstStates.RemoveAll();
}

BOOL COptionTreeStore::Serialize(CArchive & archive)
{
	TRY
	{
		// write out the # of nodes in the store
		int nCount = m_lstStates.GetCount();
		archive << ((WORD)nCount);

		POSITION pos = m_lstStates.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CNodeState * pNodeState = (CNodeState *)m_lstStates.GetNext(pos);

			// write out the node
			archive << pNodeState->m_str;
			archive << ((WORD)pNodeState->m_nLevel);
			archive << ((BYTE)pNodeState->m_fExpanded);
			archive << ((BYTE)pNodeState->m_fSelected);
		}
	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE;	// succeed
}

BOOL COptionTreeStore::Deserialize(CArchive & archive)
{
	// clear what we currently have
	Clear();

	CNodeState * pNodeState = NULL;
	TRY
	{
		// read in the # of nodes in the archived store
		int nCount = 0;
		archive >> ((WORD &)nCount);
		while (nCount > 0)
		{
			nCount--;	// next node from the archive
			pNodeState = new CNodeState;
			if (pNodeState == (CNodeState *)NULL)
				continue;	// don't abort, just ignore
		
			// read in the node
			archive >> pNodeState->m_str;
			pNodeState->m_nLevel = 0;
			archive >> ((WORD &)pNodeState->m_nLevel);
			pNodeState->m_fExpanded = pNodeState->m_fSelected = FALSE;
			archive >> ((BYTE &)pNodeState->m_fExpanded);
			archive >> ((BYTE &)pNodeState->m_fSelected);
			m_lstStates.AddTail(pNodeState);
		}
	}
	CATCH_ALL (e)
	{
		if (pNodeState)
			delete pNodeState;

		// failed
		return FALSE;
	}
 	END_CATCH_ALL

	return TRUE;	// succeed
}

BEGIN_MESSAGE_MAP(COptionTreeCtl, CTreeCtl)
	//{{AFX_MSG_MAP(COptionTreeCtl)
	ON_WM_CREATE()
	ON_WM_DESTROY()
	ON_WM_SETFOCUS()
	ON_WM_KILLFOCUS()
	ON_WM_VKEYTOITEM()
	//}}AFX_MSG_MAP
	ON_LBN_SETFOCUS(IDCW_TREELISTBOX, OnLbSetFocus)
	ON_LBN_KILLFOCUS(IDCW_TREELISTBOX, OnLbKillFocus)
	ON_LBN_SELCHANGE(IDCW_TREELISTBOX, OnLbSelChange)
END_MESSAGE_MAP()

COptionTreeStore COptionTreeCtl::sm_TreeState;	// our 'remembered' tree state

BOOL COptionTreeCtl::Create(CWnd *pParentWnd, CRect rect)
{
	if (!CWnd::Create(
			NULL,
			NULL,
			WS_CHILD | WS_TABSTOP | WS_VISIBLE | WS_CLIPSIBLINGS,
			rect,
			pParentWnd,
			IDC_OPTN_TREECTL,
			NULL
		)) 	return FALSE;
	return TRUE;
}

int COptionTreeCtl::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	// call our create on the base-class
	if (CTreeCtl::OnCreate(lpCreateStruct) == -1)
	{
		return -1;	// failed to create our tree control
	}

	m_ptrTrgNodes.RemoveAll();

	return 0;	// succeded in creating our option tree control
}

void COptionTreeCtl::OnDestroy()
{
	// remember the state of the tree-control?
	if (m_fDoStateStore)	SaveTreeState();

	// do this before we free all of the tree data (the m_ProxySlob refers to tree data)
	((CProjOptionsDlg *)GetParent())->m_ProxySlob.Clear(FALSE);

	// free-up the tree data
	FreeAllOptTreeNodes();

	CTreeCtl::OnDestroy();
}

void COptionTreeCtl::OnLbSetFocus()
{
	CTreeCtl::InvalSelection();

	// remove default style bit from default button in parent dialog
	// (Project.Settings)
	CProjOptionsDlg * pOptDlg = (CProjOptionsDlg *)GetParent();
	pOptDlg->SetDefButtonIndex(-1/*none*/);
}

void COptionTreeCtl::OnLbKillFocus()
{
	CTreeCtl::InvalSelection();

	// add default style bit to default button in parent dialog
	// (Project.Settings)
	CProjOptionsDlg * pOptDlg = (CProjOptionsDlg *)GetParent();
	pOptDlg->SetDefButtonIndex(0);
}

BOOL COptionTreeCtl::PreTranslateMessage(MSG* pMsg)
{
	// expand or contract?
	if (pMsg->message == WM_KEYDOWN && (char)pMsg->wParam == VK_RETURN)
	{
		OnPrimary();
		return TRUE;
	}

	return CTreeCtl::PreTranslateMessage(pMsg);
}

int COptionTreeCtl::InsertTargetNode(CProject * pProject, const TCHAR * szTarget)
{
	// construct our new OptTreeNode to insert
	// we'll destroy this in the virtual COptionTreeCtl::DeleteNode()
#ifdef NEWCFG
	int nValidConfigs = 0;
	OptTreeNodeList * pNewOptNodeList = new OptTreeNodeList;
	CString strTarget = pProject->GetTargetName();
	// ASSERT(strTarget.CompareNoCase(szTarget)==0);
	ConfigurationRecord * pcr;
	const CPtrArray * pCfgProject = pProject->GetConfigArray();
	int size = pCfgProject->GetSize();
	for (int i = 0; i < size; i++)
	{
		pcr = (ConfigurationRecord *)pCfgProject->GetAt(i);
		OptTreeNode * pNewOptNode = new OptTreeNode;
		pNewOptNode->pItem = pProject;	// root project item
		pNewOptNode->pcr = pcr;
		ASSERT(pcr != NULL);
		pNewOptNodeList->AddHead(pNewOptNode);
		if (pNewOptNode->IsValid())
			nValidConfigs++;
	}

	// Only add this Target if it has at least one valid config
	if (nValidConfigs==0)
	{
		pProject->SetOptionTreeCtl(NULL);
		pNewOptNodeList->RemoveContent();
		delete pNewOptNodeList;
		return LB_ERR;
	}
#else
	OptTreeNode * pNewOptNode = new OptTreeNode;
	pNewOptNode->pItem = pProject;	// root project item
	pNewOptNode->pcr = pProject->ConfigRecordFromConfigName(szTarget);	// our base config. for project
	ASSERT(pNewOptNode->pcr);
#endif

	// inform the project notify slob that our project 'view'
	// wants to be informed of project changes
	pProject->SetOptionTreeCtl(this);

	// insert this as a top-level node (un-expanded)
	CNode * pNodeDummy; int iNodeInserted;
#ifdef NEWCFG
	if (!InsertNode(NULL, -1, szTarget, (DWORD)pNewOptNodeList, pNodeDummy, iNodeInserted))
	{
		pNewOptNodeList->RemoveContent();
		delete pNewOptNodeList;
		return LB_ERR;
	}
#else
	if (!InsertNode(NULL, -1, szTarget, (DWORD)pNewOptNode, pNodeDummy, iNodeInserted))
	{
		delete pNewOptNode;
		return LB_ERR;
	}
#endif

	// remember this one
#ifdef NEWCFG
	m_ptrTrgNodes.AddTail((void *)pNewOptNodeList);
#else
	m_ptrTrgNodes.AddTail(pNewOptNode);
#endif

	return iNodeInserted;
}

void COptionTreeCtl::FreeTargetNode(OptTreeNode * pTargetNode)
{
	ASSERT(0);
	// delete the target, this will delete all of the children
	delete pTargetNode;

	// delete this one in our 'remembered' list
	POSITION pos = m_ptrTrgNodes.Find(pTargetNode);
	ASSERT(pos != (POSITION)NULL);
	m_ptrTrgNodes.RemoveAt(pos);
}

void COptionTreeCtl::FreeAllOptTreeNodes()
{
	// free each target that we remembered that we inserted
	while (!m_ptrTrgNodes.IsEmpty())
	{
		OptTreeNodeList * pOptNodeList = (OptTreeNodeList *) m_ptrTrgNodes.RemoveHead();
		pOptNodeList->RemoveContent();
		delete pOptNodeList;
	}
}

int COptionTreeCtl::FindTargetNode(const CString& strTargetName)
{
#ifdef NEWCFG
	int iIndex = 0;
	CNode* pNode;
	while ((pNode = GetNode(iIndex)) != (CNode *)NULL)
 	{
 		OptTreeNodeList * pOptTreeNodeList = (OptTreeNodeList *)pNode->m_dwData;
		CProjItem* pItem = pOptTreeNodeList->GetItem();
		if (pItem->IsKindOf(RUNTIME_CLASS(CProject)) &&
		    pItem->GetTargetName() == strTargetName)
			return iIndex;
		iIndex++;
	}
#else
	ASSERT(0);  // NYI
	ConfigurationRecord* pcr = m_pProject->ConfigRecordFromConfigName(strTargetName);

	int iIndex = 0;
	CNode* pNode;
	while ((pNode = GetNode(iIndex)) != (CNode *)NULL)
 	{
 		OptTreeNode * pOptTreeNode = (OptTreeNode *)pNode->m_dwData;
		CProjItem* pItem = pOptTreeNode->pItem;
		if (pOptTreeNode->pItem->IsKindOf(RUNTIME_CLASS(CProject)) &&
		    pOptTreeNode->pcr == pcr)
			return iIndex;
		iIndex++;
	}
#endif

	return LB_ERR;
}

void COptionTreeCtl::RefreshTargetNodes()
{
	// do this before we free all of the tree data (the m_ProxySlob refers to tree data)
	((CProjOptionsDlg *)GetParent())->m_ProxySlob.Clear(FALSE);

	// free-up the old option tree control nodes
	FreeAllOptTreeNodes();
	FreeAllTreeData();

		CProject * pProject = m_pProject;
		CString strTarget = pProject->GetTargetName();
#ifdef MPROJ
	// support multiple projects
	const CObList * pProjList = CProject::GetProjectList();
	POSITION pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif

#ifdef NEWCFG
			CString strTarget = pProject->GetTargetName();
			(void) InsertTargetNode(pProject, strTarget);
#else
		POSITION pos = g_theConfigEnum.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CEnumerator	* pEnum = g_theConfigEnum.GetNext(pos);
			if (pEnum->val)	// supported project type?
			{
				if (pProject->ConfigRecordFromConfigName(pEnum->szId, FALSE) != NULL)
					(void) InsertTargetNode(pEnum->szId);
			}
		}
#endif
#ifdef MPROJ
	}
#endif
}

void COptionTreeCtl::GetTreeCtlSelection(CTreeCtl * pTreeCtl, INT * & rgInt, int & nSelItems)
{
	if ((pTreeCtl->GetListBox()->GetStyle() & LBS_EXTENDEDSEL) != 0)
	{
		// multiple-select case

		nSelItems = pTreeCtl->GetSelCount();
		if (nSelItems != 0)
		{
			rgInt = new INT[nSelItems];
			// remember multiple-select
			if (rgInt != (INT *)NULL && pTreeCtl->GetSelItems(nSelItems, rgInt) == LB_ERR)
				nSelItems = 0;	// no selection
		}
	}
	else
	{
		// single-select case

		nSelItems = 1;	// single selection
		rgInt = new INT[nSelItems];	// single selection

		int iSel;
		// if we have a selection then select it
		if (rgInt != (INT *)NULL && (iSel = pTreeCtl->GetCurSel()) == LB_ERR)
			nSelItems = 0;	// no selection
		else
			rgInt[0] = iSel;	// remember single-select
	}
}

void COptionTreeCtl::CopyTreeCtlState(CSlob * pSelection)
{
	int iIndexTarget = LB_ERR;

	if (pSelection != NULL)
	{
		CBuildNode* pBldNode = GetBuildNode();
		CBuildViewSlob * pTargetSlob;
		pBldNode->InitBldNodeEnum();
		while (pBldNode->NextBldNodeEnum((void **)&pTargetSlob))
		{

			ASSERT(pTargetSlob->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)));
			CProjItem * pProjItem = (CProjItem *)pTargetSlob->GetBuildSlob()->GetProjItem();
			ASSERT((pProjItem->IsKindOf(RUNTIME_CLASS(CProject))) ||
				(pProjItem->IsKindOf(RUNTIME_CLASS(CTargetItem))));
			CString strTargetName = pProjItem->GetTargetName();
			iIndexTarget = FindTargetNode(strTargetName);

			// do we have a project tree-control whose state we want to copy?
			if (iIndexTarget == LB_ERR)
				continue;

			UINT fExpandedState = pTargetSlob->GetExpandedState(TRUE /* ignore deps */);
			// Expand node to match BuildView slob
			int iIndex;
			for (iIndex = iIndexTarget; fExpandedState != 0; iIndex++)
			{
				CNode * pNode = GetNode(iIndex);
				if (pNode == NULL) break;

				if (NodeIsExpandable(pNode))
				{
					if ((fExpandedState & 1) != 0)
					{
						Expand(iIndex);	// make sure we have the targ. offset
					}
					fExpandedState >>= 1;
				}
			}
		}
				
		// copy the selection state
		CString strDummy;
		int nSelection = 0;
		POSITION pos1 = pSelection->GetContentList()->GetHeadPosition();
		while (pos1 != NULL)
		{
			CProjItem * pProjItem = (CProjItem *)pSelection->GetContentList()->GetNext(pos1);
			// is this item valid?
			if ((!pProjItem->IsKindOf(RUNTIME_CLASS(CProjItem))) || (!IsValidOptTreeItem(pProjItem, strDummy)))
				continue;
			
			CNode * pNode = (CNode *)NULL;
			int iNode = 0;
			while ((pNode = GetNode(iNode)) != (CNode *)NULL)
			{
#ifdef NEWCFG
				OptTreeNodeList * pOptNodeList = (OptTreeNodeList *)pNode->m_dwData;
				// is this the one?
				if (pOptNodeList->GetItem() == (CProjItem *)pProjItem)
					break;	// yes
#else
				OptTreeNode * pOptNode = (OptTreeNode *)pNode->m_dwData;
				// is this the one?
				if (pOptNode->pcr == pcr && pOptNode->pItem == (CProjItem *)pProjItem)
					break;	// yes
#endif
				iNode++;	// next node to look
			}

			// found it?
			if (pNode != (CNode *)NULL)
			{
				ASSERT(iNode != LB_ERR);
				SetSel(iNode);
			}
		}
		m_fDoStateStore = FALSE;
	}
	else
	{
		// retrieve a selection
		RetrieveTreeState();
		m_fDoStateStore = TRUE;
	}

	// no selection yet, then select all supported target nodes!
	if (!GetSelCount())
	{
		if ((m_pProject==NULL) || (!m_pProject->m_bProjIsExe))
		{
			// go through looking for the targets ('roots')
			int iIndex = 0;
			CNode * pNode;
#ifndef NEWCFG
			CProjType * pprojtype;
#endif
			while ((pNode = GetNode(iIndex)) != (CNode *)NULL)
			{
				if (pNode->m_nLevels == 0)
				{
#ifndef NEWCFG
					// select all supported targets
					OptTreeNode * pOptTreeNode = (OptTreeNode *)pNode->m_dwData;
 					VERIFY(g_prjcompmgr.LookupProjTypeByName(pOptTreeNode->pcr->GetOriginalTypeName(), pprojtype));
			 		if (pprojtype->IsSupported())
#endif
					{
						SetSel(iIndex);	// select this target ('root') node
					}
				}
				iIndex++;
			}
		}
		else
		{
			// can do it the fast way if external project
			SetSel(-1);
		}
	}
}

// retrieve/save our state
void COptionTreeCtl::RetrieveTreeLevel(POSITION & pos, int iBaseIndex, int iBaseLevel)
{
	CNodeState * pState;

	// loop through nodes on this level
	while (pos != (POSITION)NULL)
	{
		POSITION posState = pos;
		pState = (CNodeState *) sm_TreeState.m_lstStates.GetNext(pos);

		// end of this level?
		if (pState->m_nLevel < iBaseLevel)
		{
			pos = posState;	// back-up
			return;
		}

		// search for this in our tree from our base
		CNode * pNode;
		int iIndex = iBaseIndex;
	 	BOOL fFound = FALSE;

		while (
			   // matching node not found already?
			   !fFound &&

			   // node found in actual?
			   ((pNode = GetNode(iIndex)) != (CNode *)NULL) &&

			   // gone through all children?
			   (pNode->m_nLevels >= pState->m_nLevel)
			  )
		{
			// match of actual with saved state?
			if (pState->m_nLevel == pNode->m_nLevels &&
				pState->m_str == pNode->m_szText)
			{
				// select and/or expand this?
				if (pState->m_fSelected)	SetSel(iIndex);
				if (pState->m_fExpanded)	Expand(iIndex);
				fFound = TRUE;
			}
			iIndex++;
		}

		// found this node?
		if (fFound)
		{
			// yes, get next node (if it exists) on this level (peek ahead in the list)
			if (pos != (POSITION)NULL)
			{
				pState = (CNodeState *) sm_TreeState.m_lstStates.GetAt(pos);
				// is this a child?
				if (pState->m_nLevel > iBaseLevel)
					// yes, retrieve the state of the tree for this child's branch
					RetrieveTreeLevel(pos, iIndex, iBaseLevel + 1);	// back-up
			}
		}
		else
		{
			// no, skip the next node(s) (if they exists) at all lower levels
			while (pos != (POSITION)NULL)
			{
				posState = pos;
				pState = (CNodeState *) sm_TreeState.m_lstStates.GetNext(pos);
				if (pState->m_nLevel <= iBaseLevel)
				{
					pos = posState;	// back-up
					break;
				}
			}
		}
	}
}

void COptionTreeCtl::RetrieveTreeState()
{
	if (sm_TreeState.m_lstStates.IsEmpty())
		return;	// tree-state store is clear

	POSITION pos = sm_TreeState.m_lstStates.GetHeadPosition();
	RetrieveTreeLevel(pos, 0, 0);
}

void COptionTreeCtl::SaveTreeState()
{
	// clear the old one
	sm_TreeState.Clear();

	// get the selection state first
	INT * rgInt = NULL;	// our selected item indexes
	int nSelItems;	// # of selected items
	GetTreeCtlSelection(this, rgInt, nSelItems);

	// make a note of the new expansion state
	CNode * pNode;
	int iIndex = 0, nSelection = 0;
	BOOL fSelected;
	while ((pNode = GetNode(iIndex)) != (CNode *)NULL)
	{	
		fSelected = FALSE;	// no selection by default

		if (nSelection < nSelItems)
			if (fSelected = (rgInt[nSelection] == iIndex))
				nSelection++;	// next selected item to look out for

		CNodeState * pState = new CNodeState(pNode->m_szText,
											 pNode->m_nLevels,
											 (pNode->m_nFlags & TF_EXPANDED) != 0,
											 fSelected
											);
		// this node state will get destroyed by the tree state store
		sm_TreeState.m_lstStates.AddTail(pState);
		iIndex++;
	}

	if (rgInt != (INT *)NULL)
		delete [] rgInt;
}

void COptionTreeCtl::OnSelect(int nIndex)
{
	// allow the tree control to select this node
	CTreeCtl::OnSelect(nIndex);

	// tree-control selection changes
	((CProjOptionsDlg *)GetParent())->OnTreeCtlSelChange();
}

int COptionTreeCtl::OnKey(UINT nKey)
{
	// is this the tab key?
	if (nKey == VK_TAB)
	{
		return -2;	// no further action
	}

	return -1;	// pass on to listbox
}

void COptionTreeCtl::OnLbSelChange()
{
	if (m_fIgnoreSelChange)
		return;	// ignore this selection change

	// do we need to validate the tab?
	if (!((CProjOptionsDlg *)GetParent())->ValidateCurrent())
	{
		// reset our selection to what is was before this sel change
		RememberSel();

		return;	// validation failed
	}

	// remember our selection
	NoteSel();
	CTreeCtl::OnLbSelChange();
}

void COptionTreeCtl::NoteSel()
{
	int iSelCount = GetSelCount();
	if (iSelCount == 0)	// no selection
	{
		// maintain at least a single-selection
		SetSel(m_rgLastGoodSel != (int *)NULL && m_cLastGoodSel != 0 ? m_rgLastGoodSel[0] : 0, TRUE);
		return;
	}

	if (m_rgLastGoodSel == (int *)NULL || iSelCount > m_cLastGoodSel)
	{
		if (m_rgLastGoodSel != (int *)NULL)
			delete [] m_rgLastGoodSel;

		m_rgLastGoodSel = new int[iSelCount];
	}
	if (m_rgLastGoodSel != (int *)NULL && GetSelItems(iSelCount, m_rgLastGoodSel) == LB_ERR)
		iSelCount = 0;	// flag, bad selection
	m_cLastGoodSel = iSelCount;	
}

void COptionTreeCtl::RememberSel()
{
	m_fIgnoreSelChange = TRUE;
	SetSel(-1, FALSE);
	for (int i = 0; i < m_cLastGoodSel; i++)
		SetSel(m_rgLastGoodSel[i], TRUE);
	m_fIgnoreSelChange = FALSE;
}

int COptionTreeCtl::OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex)
{
	// place addtional key-input (above and beyond standard CTreeCtl behaviour)
	// here for the option tree control
	return CTreeCtl::OnVKeyToItem(nKey, pListBox, nIndex);
}


BOOL COptionTreeCtl::NodeIsExpandable(CNode *pNode)
{
	CObList * pContent;
	ASSERT(pNode != NULL);

#ifdef NEWCFG
	CProjItem* pItem = ((OptTreeNodeList *)pNode->m_dwData)->GetItem();
#else
	CProjItem* pItem = ((OptTreeNode *)pNode->m_dwData)->pItem;
#endif
	if (pItem->IsKindOf(RUNTIME_CLASS(CProject)) && !((CProject *)pItem)->m_bProjIsExe)
	{
#ifdef NEWCFG
		pItem = pItem->GetTarget();
#else
		ConfigurationRecord* pcr = ((OptTreeNode *)pNode->m_dwData)->pcr;
		CString strTargetName = pcr->GetConfigurationName();
		pItem = m_pProject->GetTarget(strTargetName);
#endif
 	}
	
	pContent = pItem->GetContentList();

	// does this have a content (or an empty content)?
	if (pContent == (CObList *)NULL || pContent->IsEmpty())
		return FALSE;

	// make sure we either have a valid ref. or non ref. item
	CString strTemp;
	POSITION pos = pContent->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CProjItem * pChildItem = (CProjItem *)pContent->GetNext(pos);

		// Get the matching config of the child item for the nodes current
		if (!IsValidOptTreeItem(pChildItem, strTemp))
			continue;

		return TRUE;	// ok, is valid for the current target
	}

	return FALSE;
}

void COptionTreeCtl::GetNodeTitle(CNode *pNode, CString & strDesc)
{
	// for the project show the name of the configuration instead of the name of the makefile,
	// else get the "normal" name of the CProjItem.
#ifdef NEWCFG
	OptTreeNodeList * pOptNodeList = (OptTreeNodeList *)pNode->m_dwData;
	CProjItem * pItem = pOptNodeList->GetItem();
	if (pItem->IsKindOf(RUNTIME_CLASS(CProject)))
		strDesc = ((CProject *)pItem)->GetTargetName();
	else
		pItem->GetStrProp(P_ProjItemName, strDesc);
#else
	OptTreeNode * pOptNode = (OptTreeNode *)pNode->m_dwData;

 	UINT idDesc = pOptNode->pItem->IsKindOf(RUNTIME_CLASS(CProject)) ? P_ProjConfiguration : P_ProjItemName;
	pOptNode->GetStrProp(idDesc, strDesc, OBNone);
#endif
}

void COptionTreeCtl::GetDisplayText(CNode *pNode, CString & strDisplayText)
{
#ifdef NEWCFG
	OptTreeNodeList * pOptNodeList = (OptTreeNodeList *)pNode->m_dwData;
	CProjItem * pItem = pOptNodeList->GetItem();
	if (pItem->IsKindOf(RUNTIME_CLASS(CProject)))
		strDisplayText = ((CProject *)pItem)->GetTargetName();
	else
		pItem->GetStrProp(P_ProjItemName, strDisplayText);
#else
	// Are we updating the nodes at this moment
	OptTreeNode * pOptNode = (OptTreeNode *)pNode->m_dwData;

	// for the project show the name of the configuration instead of the name of the makefile,
	// else get the "normal" name of the CProjItem.
	if (pOptNode->pItem->IsKindOf(RUNTIME_CLASS(CProject)))
	{
		CProject * pProject = (CProject *)(pOptNode->pItem);
		CString strConfig, strTarget;
		VERIFY(pOptNode->GetStrProp(P_ProjConfiguration, strConfig, OBNone));

		// force this to use the option node's configuration
		CProjTempConfigChange projTempConfigChange(pProject);
		projTempConfigChange.ChangeConfig((ConfigurationRecord *)pOptNode->pcr->m_pBaseRecord);

#if 0
		if (pProject->IsExeProject() || pProject->IsExternalTarget())
		{
			CPath * pPath = pProject->GetTargetFileName();
			if (pPath)
			{
				strTarget = pPath->GetFileName();
				delete pPath;
			}
		}
		else
		{
			// try looking right at our actions
			// we may not have a dependency graph so enumerating it will not work
			ConfigurationRecord * pcr = pProject->GetActiveConfig();
			CActionSlobList * pActions = pcr->GetActionList();
			CActionSlobList lstActions;
			POSITION pos = pActions->GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos);

				// primary output tool?
				if (!pAction->BuildTool()->HasPrimaryOutput())
					continue;	// no

				lstActions.RemoveAll();

				CActionSlob action(pAction->Item(), pAction->BuildTool(), FALSE, pcr);
				lstActions.AddTail(&action);

				// we want the primary target for the cloned (the ones we're working on)
				// to be shown
				int idOldBag = pAction->Item()->UsePropertyBag(CloneBag);
				pAction->BuildTool()->GenerateOutput(AOGO_Primary, lstActions, g_DummyEC);
				pAction->Item()->UsePropertyBag(idOldBag);
									 
#ifndef REFCOUNT_WORK
				const CPtrList * plstFile = action.GetOutput()->GetContent();

				if (plstFile->GetCount())
				{
					const CPath * pPath = g_FileRegistry.GetRegEntry((FileRegHandle)plstFile->GetHead())->GetFilePath();
#else
				if (action.GetOutput()->GetCount())
				{
					FileRegHandle frh = action.GetOutput()->GetFirstFrh();
					const CPath * pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();
					frh->ReleaseFRHRef();
#endif
					if (pPath) strTarget = pPath->GetFileName();
					break;
				}
			}
		}
		strDisplayText = strConfig /* + _T(" (") + strTarget + _T(')') */;
#else
		strDisplayText = strConfig;
#endif

	}
	else
	{
		pOptNode->GetStrProp(P_ProjItemName, strDisplayText, OBNone);
	}
#endif
}

BOOL COptionTreeCtl::IsValidOptTreeItem(CProjItem * pItem, CString & str)
{
	// target node is always shown, synonymous with project node
	if (pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		return TRUE;

	// ignore this item
	// o if it is dependency folder or file
	// o if we can't get the proj item name
	// o if it is a target reference not valid for this target
#ifdef _DEBUG
	str = "<Invalid Item>";
#endif

	// ignore this item
	// o if it is dependency folder or file
	if (pItem->IsKindOf(RUNTIME_CLASS(CDependencyFile)) ||
		pItem->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		return FALSE;

	// ignore this item
	// o if we can't get the proj item name
	if (pItem->GetStrProp(P_ProjItemName, str) == invalid)
		return FALSE;

/*
	// ignore this item
 	// o if it is a file not in the build dep.graph, eg. .doc or .txt
	if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		CFileDepGraph * pdepgraph = g_buildengine.GetDepGraph(pcr);
		CGrNode * pgrn;
		if (!pdepgraph->LookupNode((NID)pItem->GetFileRegHandle(), pgrn))
			return FALSE;	// not in dep. graph -> not valid
	}
*/

	return TRUE;
}

// a project item's appearance has changed
void COptionTreeCtl::ProjItemChanged(CSlob * pProjItem, UINT uHint)
{
	// is this the ProxySlob? if so then we must use the content
	if (pProjItem->IsKindOf(RUNTIME_CLASS(CProxySlob)))
	{
		POSITION pos = ((CProxySlob *)pProjItem)->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			int iNode = FindNode((DWORD)((CProxySlob *)pProjItem)->GetNext(pos));

			// found it?
			if (iNode != -1)
			{
				// what is the hint?
				if ((uHint == P_ItemExcludedFromBuild) || (uHint == P_ItemIgnoreDefaultTool) || (uHint == P_ItemTools))
					// item excluded from state changes the item glyph
					InvalidateNode(iNode);
			}
		}
	}
	else
	{
		// search for this (config, projitem) pair
#ifndef NEWCFG
		ConfigurationRecord * pcr = (ConfigurationRecord *)((CProjItem *)pProjItem)->GetActiveConfig();
#endif

		CNode * pNode = (CNode *)NULL;
		int iNode = 0;
		while ((pNode = GetNode(iNode)) != (CNode *)NULL)
		{
#ifdef NEWCFG
			OptTreeNodeList * pOptNodeList = (OptTreeNodeList *)pNode->m_dwData;
			// is this the one?
			if (pOptNodeList->GetItem() == (CProjItem *)pProjItem)
				break;	// yes
#else
			OptTreeNode * pOptNode = (OptTreeNode *)pNode->m_dwData;
			// is this the one?
			if (pOptNode->pcr == pcr && pOptNode->pItem == (CProjItem *)pProjItem)
				break;	// yes
#endif
			iNode++;	// next node to look
		}

		// found it?
		if (pNode != (CNode *)NULL)
		{
			// what is the hint?
			if ((uHint == P_ItemExcludedFromBuild) || (uHint == P_ItemIgnoreDefaultTool) || (uHint == P_ItemTools))
			{
				// item excluded from state changes the item glyph
				InvalidateNode(iNode);
			}
			if (uHint == P_TargetName)
			{
				// target file name changes
				DirtyNode(iNode, TF_DIRTY_ITEM);
			}
		}
	}
}

BOOL COptionTreeCtl::InsertLevel(CNode *pParentNode, int nParentIndex, BOOL fExpandAll)
{
	CWaitCursor wc;
#ifdef NEWCFG
	OptTreeNodeList * pOptNodeList = (OptTreeNodeList *)pParentNode->m_dwData;	// get our tree node to expand
	CProjItem * pItem = pOptNodeList->GetItem();
	OptTreeNode * pOptNode = pOptNodeList->GetHead();
	OptTreeNode * pCurOptNode = NULL;
	OptTreeNodeList * pNewOptNodeList = NULL;
	int n = 0;
#else
	OptTreeNode * pOptNode = (OptTreeNode *)pParentNode->m_dwData;	// get our tree node to expand
	CProjItem * pItem = pOptNode->pItem;
#endif

	// is this a container?
	if (!pItem->GetContentList())
		return TRUE;	// don't expand
	
	// HACK ALERT - this code skips over the target node
	if (pItem->IsKindOf(RUNTIME_CLASS(CProject))
#ifdef _DEBUG
		&& !g_bProjDebugView
#endif
		)
	{
#ifdef NEWCFG
		pItem = pItem->GetTarget();
#else
		CString strTargetName = pOptNode->pcr->GetConfigurationName();
		pItem = ((CProject*)pItem)->GetTarget(strTargetName);
#endif
		ASSERT(pItem != NULL);
 	}

	// enumerate through our container or content if already valid
	POSITION pos = pOptNode->m_fValidContent ? pOptNode->m_Content.GetHeadPosition() : pItem->GetHeadPosition();

	// is this container empty?
	while (pos != NULL)
	{
		CString	cstr;
		
		// no
		OptTreeNode *	pNewOptNode;	// new option node
		CNode *			pNode;			// dummy argument
		int				iNode;			// dummy argument
		if (pOptNode->m_fValidContent)
		{
			// we've already created this set of nodes
			pNewOptNode = (OptTreeNode *)pOptNode->m_Content.GetNext(pos);
			if (pNewOptNode->pItem->GetStrProp(P_ProjItemName, cstr) != valid)
			{
				ASSERT(0);
				continue;	// don't add this one
			}
#ifdef NEWCFG
			CProjItem * pChildItem = pNewOptNode->pItem;
			pNewOptNodeList = pOptNodeList->GetDependentList(pChildItem);
			if (pNewOptNodeList == NULL)
			{
				pNewOptNodeList = pOptNodeList->AddDependentList();	  // does a smart alloc
				POSITION pos2 = pOptNodeList->GetHeadPosition();
				ASSERT(pos2);
				while (pos2 != NULL)
				{
					pCurOptNode = pOptNodeList->GetNext(pos2);
					POSITION pos3 = pCurOptNode->m_Content.FindIndex(n);
					ASSERT(pos3);
					pNewOptNode = (OptTreeNode *)pCurOptNode->m_Content.GetAt(pos3);
					ASSERT(pNewOptNode->pItem == pChildItem);
					pNewOptNodeList->AddHead(pNewOptNode);
				}
			}
			n++;

#endif
		}
		else
		{
			CProjItem * pChildItem = (CProjItem *)pItem->GetNext(pos);
			if (!IsValidOptTreeItem(pChildItem, cstr))
				continue;		

#ifdef NEWCFG
			// construct our new OptTreeNode to insert
			// we'll destroy this when we free the target it belongs to
			pNewOptNodeList = pOptNodeList->AddDependentList();	  // does a smart alloc
			POSITION pos2 = pOptNodeList->GetHeadPosition();
			ASSERT(pos2);
			while (pos2 != NULL)
			{
				pCurOptNode = pOptNodeList->GetNext(pos2);
				pNewOptNode = new OptTreeNode(pCurOptNode, pChildItem);
				ASSERT(pNewOptNode->pcr != NULL);
				pNewOptNodeList->AddHead(pNewOptNode);
			}
#else
			pNewOptNode = new OptTreeNode(pOptNode, pChildItem);
			ASSERT(pNewOptNode->pcr != NULL);
#endif
		}

		// insert this option node into the tree-control's concept of a node tree

#ifdef NEWCFG
		if (!InsertNode(pParentNode, nParentIndex, cstr, (DWORD) pNewOptNodeList, pNode, iNode))
#else
		if (!InsertNode(pParentNode, nParentIndex, cstr, (DWORD) pNewOptNode, pNode, iNode))
#endif
		{
			TRACE("CProjTreeCtl::InsertLevel: call to InsertNode failed!\n");
			return FALSE;
		}
		
		if (fExpandAll && !InsertLevel(pNode, iNode, TRUE))	return FALSE;
	}

	// the content of this node is now valid

#ifdef NEWCFG
	POSITION pos2 = pOptNodeList->GetHeadPosition();
	ASSERT(pos2);
	while (pos2 != NULL)
	{
		pCurOptNode = pOptNodeList->GetNext(pos2);
			pCurOptNode->m_fValidContent = TRUE;
	}
#else
	pOptNode->m_fValidContent = TRUE;
#endif

	return TRUE;
}

void COptionTreeCtl::DrawNodeGlyph
(
	CDC* pDC,
	CNode* pNode,
	BOOL bHighlight,
	CPoint pt
)
{
	extern CImageWell g_imageWell;
	
#ifdef NEWCFG
	OptTreeNodeList* pOptNodeList = (OptTreeNodeList *)pNode->m_dwData;
	OptTreeNode* pOptNode = pOptNodeList->GetFirstValidNode();
	CProjItem * pItem = pOptNodeList->GetItem();
#else
	OptTreeNode* pOptNode = (OptTreeNode *)pNode->m_dwData;
	CProjItem * pItem = pOptNode->pItem;
#endif
	CObList * pContent = pItem->GetContentList();
	// is this a folder?
	if ((pContent != NULL) && (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup))))
	{
		// Use default container glyphs...
		CTreeCtl::DrawNodeGlyph(pDC, pNode, bHighlight, pt);
		return;
	}
	
	// 0: part of build, 1: excluded from build; 2: not buildable
	// 6: project node
	int nGlyph = 2;
	if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		// make sure we get the source tool plus prop. from the node's config.
		if (pOptNode != NULL)
			((CFileItem*)pItem)->ForceConfigActive(pOptNode->pcr);
		BOOL bExcluded = TRUE;
		pItem->GetIntProp(P_ItemExcludedFromBuild, bExcluded);
		if (((CFileItem*)pItem)->GetSourceTool() != (CBuildTool *)NULL)
		{
			nGlyph = bExcluded ? 1 : 0;
		}
		else
		{
			nGlyph = bExcluded ? 1 : 2;
		}
		if (pOptNode != NULL)
			((CFileItem*)pItem)->ForceConfigActive();
	}
	// Display the right glyph for target references
	else if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)) ||
		 pItem->IsKindOf(RUNTIME_CLASS(CProject)) ||
		 pItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
	{
		CProject * pRefProject = NULL;
		if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		{
			// REVIEW: not quite right...
#ifndef NEWCFG
			((CTargetItem*)pOptNode->pItem)->ForceConfigActive(pOptNode->pcr);
#endif
			BOOL bExcluded = TRUE;
			pItem->GetIntProp(P_ItemExcludedFromBuild, bExcluded);
			nGlyph = bExcluded ? 10 : 7;

			CTargetItem * pRefTarget = ((CProjectDependency *)pItem)->GetProjectDep();
			if (pRefTarget != NULL)
				pRefProject = pRefTarget->GetProject();
#ifndef NEWCFG
			((CTargetItem*)pOptNode->pItem)->ForceConfigActive();
#endif
		}
		else
		{
			nGlyph = 4;
			if (pItem->IsKindOf(RUNTIME_CLASS(CProject)))
				pRefProject = (CProject *)pItem;
			else
				pRefProject = pItem->GetProject();
		}
		// different glyphs for different proj types
		if (pRefProject != NULL)
		{
			// need to get path from assoc. project for these
			nGlyph += pRefProject->GetGlyphIndex(); // 0, 1 or 2
		}
	}

	g_imageWell.DrawImage(pDC, pt, nGlyph);
}

void COptionTreeCtl::InvalidateNode (int iNode)
{
	CRect rect;
	GetListBox()->GetItemRect(iNode, rect);
	GetListBox()->InvalidateRect(rect);
}

int COptionTreeCtl::CompareData(const CNode* pNode1, const CNode* pNode2)
{

	if (pNode1 == pNode2)
		return 0;
	
	int ret = CompareData(pNode1->m_pParent, pNode2->m_pParent);
	
	if (ret == 0)
	{
#ifdef NEWCFG
		CProjItem * pItem1 = ((OptTreeNodeList *)pNode1->m_dwData)->GetItem();
		CProjItem * pItem2 = ((OptTreeNodeList *)pNode2->m_dwData)->GetItem();
#else
		CProjItem * pItem1 = ((OptTreeNode *)pNode1->m_dwData)->pItem;
		CProjItem * pItem2 = ((OptTreeNode *)pNode2->m_dwData)->pItem;
#endif

		ret = pItem1->IsKindOf(RUNTIME_CLASS(CDependencyContainer)) -
			  pItem2->IsKindOf(RUNTIME_CLASS(CDependencyContainer));

		if (ret) return ret;

		BOOL bIsGroup2 = pItem2->IsKindOf(RUNTIME_CLASS(CProjGroup));

		if (bIsGroup2)
			return 1;

		BOOL bIsGroup1 = pItem1->IsKindOf(RUNTIME_CLASS(CProjGroup));

		if (bIsGroup1)
			return -1;

		// Put subprojects at the start of this container
		if (pItem2->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			return 1;

		if (pItem1->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			return -1;

		CString strExt1, strExt2; 
		BOOL bIsFile2 = pItem2->IsKindOf(RUNTIME_CLASS(CFileItem));
		BOOL bIsFile1 = pItem1->IsKindOf(RUNTIME_CLASS(CFileItem));
		if (bIsFile2)
			strExt2 = pItem2->GetFilePath()->GetExtension();
		if (bIsFile1)
			strExt1 = pItem1->GetFilePath()->GetExtension();

		// Put .lib files last and don't sort them alphabetically
		if (bIsFile1 && (strExt1.CompareNoCase(".lib")==0))
			return 1;

		if (bIsFile2 && (strExt2.CompareNoCase(".lib")==0))
			return -1;

		// Put .obj files last and don't sort them alphabetically
		if (bIsFile1 && (strExt1.CompareNoCase(".obj")==0))
			return 1;

		if (bIsFile2 && (strExt2.CompareNoCase(".obj")==0))
			return -1;

		// default is to compare text
		ret = _tcsicmp(pNode1->m_szText, pNode2->m_szText);

		// as a tie breaker, use the absolute path to at least get consistency
		// with fileview
		if (ret == 0)
		{
			// should be CFileItems by this point
			ASSERT(pItem1->GetFilePath() != NULL);
			ASSERT(pItem2->GetFilePath() != NULL);
			ret = _tcsicmp((LPCTSTR)*pItem1->GetFilePath(), (LPCTSTR)*pItem2->GetFilePath());
		}

		// if we have a match then compare the data
		if (ret == 0 && (pNode1->m_dwData != 0 || pNode2->m_dwData != 0))
		{
			if (pNode1->m_dwData == pNode2->m_dwData)
				ret = 0;
			else
				ret = (int) (pNode1->m_dwData - pNode2->m_dwData);
		}
	}
	
	return ret;
}

UINT g_nActiveEdit = 0;

CMapStringToString CProjOptionsDlg::m_mapLastMiniPage;

CMapStringToPtr CProjOptionsDlg::m_mapActiveFlavours;

BEGIN_MESSAGE_MAP (CProjOptionsDlg, CTabbedDialog)
	//{{AFX_MSG_MAP (CProjOptionsDlg)
	ON_WM_CREATE()
	ON_WM_DESTROY()	
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_CTLCOLOR()
	ON_MESSAGE(WM_SELECT_ITEM, OnSelectItem)
	ON_CBN_SELCHANGE(IDC_TARGET_LISTCOMBO, OnSelChangeTarget)
	ON_EN_SETFOCUS(IDC_CUSTOM_CMDS, OnActivateEditCmds)
	ON_EN_SETFOCUS(IDC_CUSTOM_OUTPUT, OnActivateEditOutput)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP	()

//	ON_BN_CLICKED(IDC_CHANGE_TARGET, OnBtnChangeTarget)

//#pragma message("ALERT! : optndlg.cpp : Including Project.Options tree-control hooks for QA...")
int GetNodeLevel(CTreeCtl * pTree, int nLevel)
{
	// move up to a level ? node
	CNode * pNode;
	int iIndex = pTree->GetCurSel();
	while ((pNode = pTree->GetNode(iIndex)) != (CNode *)NULL)
	{
		// are we on a level ? node?
		if (pNode->m_nLevels == nLevel)
			return iIndex;

		iIndex++;
	}

	return -1;	// didn't find
}

int GetFirstChild(CTreeCtl * pTree, int iParent)
{
	if (!pTree->NodeIsExpandable(pTree->GetNode(iParent)))
		return -1;	// didn't find

	// make sure this node is expanded
	if (!pTree->IsExpanded(iParent))
		pTree->Expand(iParent, TRUE);

	// if this parent was expandable then
	// we must have the first child as parent index
	// plus 1
	return iParent + 1;

}

int SelectItem(CTreeCtl * pTree, int iSibling, CString & strTitle, UINT idProp)
{
	// which level are we searching on?
	CNode * pNode = pTree->GetNode(iSibling);
	int nLevel = pNode->m_nLevels;

	CString strNodeTitle;

	while ((pNode = pTree->GetNode(iSibling)) != (CNode *)NULL)
	{
		// desired level?
		if (pNode->m_nLevels == nLevel)
		{
			OptTreeNode * pOptTreeNode = ((OptTreeNodeList *)pNode->m_dwData)->GetHead();
			if (pOptTreeNode->GetStrProp(idProp, strNodeTitle, OBNone) == valid &&
				(strNodeTitle.CompareNoCase(strTitle) == 0))
			{
				pTree->SetSel(-1, FALSE);
				pTree->SetSel(iSibling, TRUE);
				return iSibling;
			}
		}
		iSibling++;
	}

	return -1;	// not found
}

void CProjOptionsDlg::OnActivateEditCmds()
{
	ASSERT(0);
	g_nActiveEdit = IDC_CUSTOM_CMDS;
}

void CProjOptionsDlg::OnActivateEditOutput()
{
	ASSERT(0);
	g_nActiveEdit = IDC_CUSTOM_OUTPUT;
}

void CProjOptionsDlg::UpdateConfigsFromDlg()
{
	OptTreeNode::ResetValidConfigMap();
	POSITION pos = m_mapActiveFlavours.GetStartPosition();
	ASSERT(pos);
	void * pVoid;
	CString strFlavour;
	while (pos != NULL)
	{
		m_mapActiveFlavours.GetNextAssoc(pos, strFlavour, pVoid);

		// iterate over all projects
		CProject * pProject = m_pProject;
		CString strTarget;
		// support multiple projects
#ifdef MPROJ
		const CObList * pProjList = CProject::GetProjectList();
		POSITION pos = pProjList->GetHeadPosition();
		while (pos != NULL)
		{
			pProject = (CProject *)pProjList->GetNext(pos);
			if ((pProject==NULL) || (!pProject->IsLoaded()))
				continue;
#endif

			//
			// Exe projects are not allowed in a multi-project workspace.  If allowed
			// the GetActiveTarget below will return a NULL and cause a crash.
			//
			ASSERT(!pProject->m_bProjIsExe);

			strTarget = pProject->GetTargetName();
			const CPtrArray * pCfgProject = pProject->GetConfigArray();
			int size = pCfgProject->GetSize();

			CString strConfigToMatch = strTarget + " - " + strFlavour;
			for (int i = 0; i < size; i++)
			{
				ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgProject->GetAt(i);
				if (strConfigToMatch.CompareNoCase(pcr->GetConfigurationName())==0)
				{
					ASSERT(pcr==pcr->m_pBaseRecord);
					ConfigurationRecord * pcrTarget = pProject->GetActiveTarget()->ConfigRecordFromBaseConfig(pcr);
					if ((pcrTarget!= NULL) && (pcrTarget->IsSupported()))
					{
						OptTreeNode::SetValidConfig(pcr);
					}
				}
			}
#ifdef MPROJ
		}
#endif
	}
}

BOOL CProjOptionsDlg::UpdateConfigsFromCombo()
{
	int index = m_cbConfigs.GetCurSel();
	if ((index != CB_ERR) && (index != m_nCurTargetSel))
	{
		m_nCurTargetSel = index;
		ConfigurationRecord * pcr;
		CString strFlavour, strConfigToMatch;
		OptTreeNode::ResetValidConfigMap();
		m_cbConfigs.GetLBText(index, strFlavour);
		BOOL bAll =  (strFlavour == m_strAllConfigs);
		CProjOptionsDlg::ResetActiveFlavours();
		
		// iterate over all projects
		CProject * pProject = m_pProject;
		BOOL bProjIsExe = ((m_pProject != NULL) && (m_pProject->m_bProjIsExe));
		CString strTarget;
#ifdef MPROJ
		// support multiple projects
		const CObList * pProjList = CProject::GetProjectList();
		POSITION pos = pProjList->GetHeadPosition();
		while (pos != NULL)
		{
			pProject = (CProject *)pProjList->GetNext(pos);
			if ((pProject==NULL) || (!pProject->IsLoaded()))
				continue;
#endif
			if (bProjIsExe)
			{
				bAll = TRUE;
			}
			else
			{
				strTarget = pProject->GetTargetName();
				strConfigToMatch = strTarget + " - " + strFlavour;
			}
			const CPtrArray * pCfgProject = pProject->GetConfigArray();
			int size = pCfgProject->GetSize();

			for (int i = 0; i < size; i++)
			{
				pcr = (ConfigurationRecord *)pCfgProject->GetAt(i);
				if ((bAll) || (strConfigToMatch.CompareNoCase(pcr->GetConfigurationName())==0))
				{
					ASSERT(pcr==pcr->m_pBaseRecord);
					ConfigurationRecord * pcrTarget = bProjIsExe?NULL:pProject->GetActiveTarget()->ConfigRecordFromBaseConfig(pcr);
					if (bProjIsExe || ((pcrTarget!= NULL) && (pcrTarget->IsSupported())))
					{
						OptTreeNode::SetValidConfig(pcr);
						if (bAll)
						{
							strFlavour  = pcr->GetConfigurationName();
							if (!bProjIsExe)
							{
								int index = strFlavour.Find(" - ");
								strFlavour = strFlavour.Mid(index + 3);
							}
						}
						CProjOptionsDlg::SetActiveFlavour(strFlavour);
					}
				}
			}
#ifdef MPROJ
		}
#endif
		return TRUE;
	}
	return FALSE;
}

void CProjOptionsDlg::OnSelChangeTarget()
{
	//
	// Validate current tab before allowing change.
	//
	if (m_nTabCur != -1)
	{
		CDlgTab* pTab = GetTab(m_nTabCur);
		if ((pTab==NULL) || (!pTab->ValidateTab()))
		{
			//
			// Previous selection.
			//
			m_cbConfigs.SetCurSel(m_nCurTargetSel);
			return;
		}
	}

	int indexMS = m_cbConfigs.FindStringExact(-1, m_strMultiConfigs);
	int index = m_cbConfigs.GetCurSel();
	if ((indexMS != CB_ERR) && (indexMS == index))
	{
		InvokeChangeTargetDlg();
	}
	else if (UpdateConfigsFromCombo())
	{
		m_ProxySlob.Clear(FALSE);
		RefreshTargets();
	}
}

#if 0
void CProjOptionsDlg::OnBtnChangeTarget()
{
	InvokeChangeTargetDlg();
}
#endif

BOOL CProjOptionsDlg::InvokeChangeTargetDlg()
{
	CConfigSelectDlg dlg;
	if ((dlg.DoModal() == IDOK) && (dlg.m_SelState != CConfigSelectDlg::same))
	{
		int index = m_cbConfigs.FindStringExact(-1, m_strMultiConfigs);
		if (dlg.m_SelState == CConfigSelectDlg::multi)
		{
			m_cbConfigs.SetCurSel(index);
			UpdateConfigsFromDlg();
			m_nCurTargetSel = index;

			m_ProxySlob.Clear(FALSE);
			RefreshTargets();
		}
		else
		{
			if (dlg.m_SelState == CConfigSelectDlg::all)
			{
				index = m_cbConfigs.FindStringExact(-1, m_strAllConfigs);
			}
			else
			{
				void * pVoid;
				ASSERT(dlg.m_SelState == CConfigSelectDlg::single);
				POSITION pos = m_mapActiveFlavours.GetStartPosition();
				CString strFlavour;
				m_mapActiveFlavours.GetNextAssoc(pos, strFlavour, pVoid);
				index = m_cbConfigs.FindStringExact(-1, strFlavour);
			}
			ASSERT(index != CB_ERR);
			m_cbConfigs.SetCurSel(index);
			if (UpdateConfigsFromCombo())
			{
				m_ProxySlob.Clear(FALSE);
				RefreshTargets();
			}
		}
		return TRUE;
	}
	m_cbConfigs.SetCurSel(m_nCurTargetSel);
	return FALSE;
}

void CProjOptionsDlg::RefreshTargets()
{
	// Review: could be mroe efficient about not deleting all nodes
	// 1. See if list of valid targets has actually changed (we should do this)
	// 2. Only delete/add the changed nodes (scary)
	m_OptTreeCtl.SaveTreeState();
	m_OptTreeCtl.RefreshTargetNodes();
	m_OptTreeCtl.CopyTreeCtlState(NULL);
	m_OptTreeCtl.NoteSel(); // remember this selection
	OnTreeCtlSelChange();
}

LRESULT CProjOptionsDlg::OnSelectItem(WPARAM type, LPARAM stratomTitle)
{
	if (m_bDirtyTabs)
	{
		// update option tabs here
		OnTreeCtlSelChange();
		m_bDirtyTabs = FALSE;
		return TRUE;
	}

	if (m_OptTreeCtl.m_hWnd == (HWND)NULL)
		return FALSE;	// no tree control

	CString strTitle, strNodeTitle;
	if (!GlobalGetAtomName(ATOM(stratomTitle), strTitle.GetBuffer(200), 200))
		return FALSE;	// can't get title string
	strTitle.ReleaseBuffer();

	int iIndex;

	// do we want to select a target?
	if (type == PRJW_TARGET)
	{	
		if ((iIndex = SelectItem(&m_OptTreeCtl, 0, strTitle, P_ProjConfiguration)) == -1)
			return FALSE;	// didn't find
	}
	// do we want to select a group?
	else if (type == PRJW_GROUP)
	{
		// move up to a level 0 node (target layer)	
		if ((iIndex = GetNodeLevel(&m_OptTreeCtl, 0)) == -1)
			return FALSE;	// didn't find

		if ((iIndex = GetFirstChild(&m_OptTreeCtl, iIndex)) == -1)
			return FALSE;	// didnt' find

		if ((iIndex = SelectItem(&m_OptTreeCtl, iIndex, strTitle, P_GroupName)) == -1)
			return FALSE;	// didn't find
	}
	else if (type == PRJW_FILE)
	{	
		// move up to a level 1 node (group layer)
		if ((iIndex = GetNodeLevel(&m_OptTreeCtl, 1)) == -1)
			return FALSE;	// didn't find

		if ((iIndex = GetFirstChild(&m_OptTreeCtl, iIndex)) == -1)
			return FALSE;	// didn't find

		if ((iIndex = SelectItem(&m_OptTreeCtl, iIndex, strTitle, P_ProjItemName)) == -1)
			return FALSE;	// didn't find
	}
	else
		ASSERT(FALSE);

	// update option tabs here
	OnTreeCtlSelChange();

	return TRUE;	// success
	
}

int CProjOptionsDlg::OnCreate(LPCREATESTRUCT lpcs)
{
	// create our options tree control
	// (we'll adjust the size/position in CProjOptionsDlg::OnSize())
	if (!m_OptTreeCtl.Create(this, CRect(0, 0, 0, 0)))
		return -1;	// failed to create the pane
	if (UseWin4Look())
		m_OptTreeCtl.ModifyStyleEx(0, WS_EX_CLIENTEDGE);

	// create our static text
	CString strTxt; strTxt.LoadString(IDS_SETTINGSFOR);
	CRect rectTxt; rectTxt.SetRectEmpty();
	m_txtSettingsFor.Create(strTxt, WS_CHILD | WS_VISIBLE, rectTxt, this);
	if (UseWin4Look())
		m_txtSettingsFor.SetFont(GetStdFont(font_Normal));
	else
		m_txtSettingsFor.SetFont(GetStdFont(font_Bold));

	CRect rectCB; rectCB.SetRect(0,0,200,200);
	m_cbConfigs.Create(CBS_DROPDOWNLIST | WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_VSCROLL | ES_AUTOHSCROLL | WS_TABSTOP, rectCB, this, IDC_TARGET_LISTCOMBO);
	m_cbConfigs.SetExtendedUI();

	if (UseWin4Look())
		m_cbConfigs.SetFont(GetStdFont(font_Normal));
	else
		m_cbConfigs.SetFont(GetStdFont(font_Bold));

	CString strCurrentFlavour;
	ConfigurationRecord * pcrCurrent = NULL;
	if (g_pActiveProject)
		pcrCurrent = g_pActiveProject->GetActiveConfig();

	CProject * pProject = m_pProject;

	// take active config from selection if appropriate
	if ((m_pSelectionSlob != NULL) && (!m_pSelectionSlob->GetContentList()->IsEmpty()))
	{
		CProjItem * pProjItem = ((CProjItem *)m_pSelectionSlob->GetContentList()->GetHead())->GetProject();
		pProject = pProjItem->GetProject();
		if (pProject != NULL && pProject->IsLoaded())
		{
			m_pProject = pProject;
			pcrCurrent = pProject->GetActiveConfig();
		}
	}

	BOOL bProjIsExe = ((m_pProject != NULL) && (m_pProject->m_bProjIsExe));

	CString strTarget;
#ifdef MPROJ
	// support multiple projects
	const CObList * pProjList = CProject::GetProjectList();
	POSITION pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		CString strFlavour;
		int nTargLen = 0;
		if (!bProjIsExe)
		{
			strTarget = pProject->GetTargetName();
			strTarget += " - ";
			nTargLen = strTarget.GetLength();
			ASSERT(nTargLen > 3);
		}

		POSITION pos = g_theConfigEnum.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CEnumerator	* pEnum = g_theConfigEnum.GetNext(pos);
			if (pEnum->val)	// supported project type?
			{
				CString strConfig = pEnum->szId;
				if ((bProjIsExe) || (strncmp(strTarget, strConfig, nTargLen)==0))
				{
					ConfigurationRecord * pcr = pProject->ConfigRecordFromConfigName(strConfig, FALSE);
					if (pcr != NULL)
					{
						strFlavour = strConfig.Mid(nTargLen);
						int index = CB_ERR;
						if ((index = m_cbConfigs.FindStringExact(-1, strFlavour))==CB_ERR)
						{
							index = m_cbConfigs.AddString(strFlavour);
							ASSERT(index != CB_ERR);
						}
						if (pcr == pcrCurrent)
						{
							strCurrentFlavour = strFlavour;
							m_cbConfigs.SetCurSel(index);
						}
					}
				}
			}
		}
#ifdef MPROJ
	}
#endif
	int x = 0; //default
	m_strAllConfigs.LoadString(IDS_ALL_CONFIGS);
	m_strMultiConfigs.LoadString(IDS_MULTI_CONFIGS);
	int count = m_cbConfigs.GetCount();
	if (bProjIsExe || (count <= 1))
	{
		m_cbConfigs.EnableWindow(FALSE);
	}
	else
	{
		x = m_cbConfigs.AddString(m_strAllConfigs);
		if (count > 2)
		{
			m_cbConfigs.AddString(m_strMultiConfigs);
		}
	}
	// int x1 = m_cbConfigs.FindStringExact(-1, pcrCurrent->GetConfigurationName());
	// if (x1 != CB_ERR) x = x1; // worst case, select all
	if (strCurrentFlavour.IsEmpty())
	{
		m_cbConfigs.SetCurSel(x);
		strCurrentFlavour = m_strAllConfigs;
	}

#if 0
	strTxt.LoadString(IDS_CONFIGS);
	m_bnConfigs.Create(strTxt, WS_CHILD | WS_VISIBLE | WS_TABSTOP, rectTxt, this, IDC_CHANGE_TARGET);
	if (UseWin4Look())
		m_bnConfigs.SetFont(GetStdFont(font_Normal));
	else
		m_bnConfigs.SetFont(GetStdFont(font_Bold));
#endif

	// create our 'No Common Properties' static text dlg
	m_dlgNoProps.Create(this);

	// no previous tab or handlers in the list
	m_listHdlrs.RemoveAll();
	m_strPrevTab.Empty();

	// initialise our options tree control
	// (this'll force a selection change, and tab creation)
	VERIFY(UpdateConfigsFromCombo());
	
	m_OptTreeCtl.RefreshTargetNodes();

    // Need to copy the tree ctl state from build view
#ifdef NEWCFG
	m_OptTreeCtl.CopyTreeCtlState(m_pSelectionSlob);
#else
	m_OptTreeCtl.CopyTreeCtlState(NULL);
#endif

	m_OptTreeCtl.NoteSel(); // remember this selection

#ifdef MPROJ
	// support multiple projects
	pProjList = CProject::GetProjectList();
	pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		// clone our current props into a store
		// we'll use to perform prop. ops until OK'ed
		(void) DoBagOpOverProject(pProject, CurrBag, CloneBag, BO_Copy | BO_UseDest);
#ifdef MPROJ
	}
#endif
	// hook the project option engine to us
 	g_prjoptengine.SetPropertyBag(&m_ProxySlob);

	// initialise the selection dependent stuff
	UpdateProxySlob(FALSE);	// don't need inform
	CacheOptionHandlers();
	UpdateOptionTabs();

	// be smart and select the 'tool' page if we were
	// brought up from the popup for a file,
   
	if (m_pSelectionSlob &&
		m_ProxySlob.IsSortOf(RUNTIME_CLASS(CFileItem)) &&	// files selected
		GetTabCount() == 2		// we have a second 'tool' tab
	  )
	  m_nTabCur = 1;	// select the 'tool' tab instead (second)

	if (CTabbedDialog::OnCreate(lpcs) == -1)
		return -1;	// failure

	m_OptTreeCtl.SetContextHelpID(HIDC_PROJBLD_SETTINGS_TREECTL);
	m_txtSettingsFor.SetWindowContextHelpId(HIDC_PROJBLD_SETTINGS_CFGTXT);
	m_cbConfigs.SetWindowContextHelpId(HIDC_PROJBLD_SETTINGS_CONFIGS);
	m_dlgNoProps.SetWindowContextHelpId(HIDC_PROJBLD_SETTINGS_NOPROPS);

	// show/don't show the 'No Common Properties' dlg. on whether common list hdlrs exists.
	m_dlgNoProps.ShowWindow(m_listHdlrs.IsEmpty() ? SW_SHOWNA : SW_HIDE);

	if (m_listHdlrs.IsEmpty())
	{
		// make sure the focus is not on the 'no common props dialog'
		m_OptTreeCtl.SetFocus();
	}

	// cache a pointer to the notify slob
#ifdef MPROJ
	// support multiple projects
	pProjList = CProject::GetProjectList();
	pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		// don't allow the project to be dirtied
		pProject->SetOkToDirtyProject(FALSE);
#ifdef MPROJ
	}
#endif

	// we don't allow the recording of props in a modal dialog!
	if (theUndoSlob.IsRecording()) 
	{
		// paause, and remember to re-enable, recording
		theUndoSlob.Pause();
		m_fResumeRecording = TRUE;
	}
	else
	{
		// no need to resume recording, we aren't currently
		m_fResumeRecording = FALSE;
	}

	return 0;	// succeed
}

void CProjOptionsDlg::OnDestroy()
{
	// resume recording?
	if (m_fResumeRecording)
		theUndoSlob.Resume();

	CProject * pProject = m_pProject;
#ifdef MPROJ
	// support multiple projects
	const CObList * pProjList = CProject::GetProjectList();
	POSITION pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		// don't want to have our project 'view' informed anymore
		pProject->SetOptionTreeCtl((COptionTreeCtl *)NULL);
#ifdef MPROJ
	}
#endif

#ifdef MPROJ
	pProjList = CProject::GetProjectList();
	pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		// do cleanup of clone prop. bags
		(void) DoBagOpOverProject(pProject, UINT(-1), CloneBag, BO_Clear);
		// pProject->SetOkToDirtyProject(TRUE);
#ifdef MPROJ
	}
#endif
}

void Draw3dRect(CDC * pDC, const CRect * prect, BOOL bInset)
{
	int cx = prect->Width()+1;
	int cy = prect->Height()+1;

	// top/left (inside) corner
	CBrush * pOldBrush = pDC->SelectObject(GetSysBrush(bInset ? COLOR_BTNTEXT : COLOR_BTNHIGHLIGHT));
	pDC->PatBlt(prect->left, prect->top, cx-1, 1, PATCOPY);
	pDC->PatBlt(prect->left, prect->top, 1, cy-1, PATCOPY);

	// bottom/right (inside) corner
	pDC->SelectObject(GetSysBrush(bInset ? COLOR_BTNFACE : COLOR_BTNSHADOW));
	pDC->PatBlt(prect->left, prect->bottom, cx, 1, PATCOPY);
	pDC->PatBlt(prect->right, prect->top, 1, cy, PATCOPY);

	// top/left (outside) corner
	pDC->SelectObject(GetSysBrush(bInset ? COLOR_BTNSHADOW : COLOR_BTNFACE));
	pDC->PatBlt(prect->left-1, prect->top-1, cx+1, 1, PATCOPY);
	pDC->PatBlt(prect->left-1, prect->top-1, 1, cy+1, PATCOPY);

	// bottom/right (outside) corner
	pDC->SelectObject(GetSysBrush(bInset ? COLOR_BTNHIGHLIGHT : COLOR_BTNTEXT));
	pDC->PatBlt(prect->left-1, prect->bottom+1, cx+2, 1, PATCOPY);
	pDC->PatBlt(prect->right+1, prect->top-1, 1, cy+2, PATCOPY);

	pDC->SelectObject(pOldBrush);
}

HBRUSH CProjOptionsDlg::OnCtlColor(CDC * pDC, CWnd * pWnd, UINT nCtlColor)
{
	if ((pWnd->m_hWnd == m_txtSettingsFor.m_hWnd) && (nCtlColor == CTLCOLOR_STATIC))
	{
		pDC->SetBkColor(GetSysColor(COLOR_BTNFACE)); // bkgnd text color
		return (HBRUSH)GetSysBrush(COLOR_BTNFACE)->m_hObject;	// bkgnd brush
	}

	return (HBRUSH)0L;
}

void CProjOptionsDlg::OnPaint()
{
	// call our base-class first, we'll paint our frames over it
	CTabbedDialog::OnPaint();	

	CDC * pDC = GetDC();
	ASSERT(pDC != (CDC *)NULL);

	// paint an inset rect around the tree-control
	CRect rect; m_OptTreeCtl.GetWindowRect(rect);
	ScreenToClient(&rect);
	rect.InflateRect(1, 1);
	rect.right--; rect.bottom--;	// fudge

	if (!UseWin4Look())
		Draw3dRect(pDC, &rect, TRUE);

	// paint an outset rect around the tree-control plus
	// static text label

	rect.InflateRect(CP_OUTER_BORDER, CP_OUTER_BORDER);
	rect.top = m_tabRow.GetRect().top;

	Draw3dRect(pDC, &rect, FALSE);

	VERIFY(ReleaseDC(pDC));
}

void CProjOptionsDlg::OnSize(UINT nType, int cx, int cy)
{
	// size our tabbed dialog first
	CTabbedDialog::OnSize(nType, cx, cy);

	// o move the static text
	// o move and size the tree control
	// o ensure the tabbing order is correct

	CRect rectTab; GetTabSize(rectTab);
	CRect rectTabRow = m_tabRow.GetRect();
	CClientDC dc(this);
	int nTabHeight = m_tabRow.DesiredHeight(&dc);
	
	CRect margins;
	CTabbedDialog::GetMargins(margins);

    // TitoM: BugFix DevStudio #11035
    // GetDC() returns a DC with default attributes for common classes, thus
    // GetTextExtent() returns an incorrect width for the text.  To get correct extend info
    // the lables font needs to be set into the DC used to query the extent
	CString strTxt; strTxt.LoadString(IDS_SETTINGSFOR);
    CDC   *pDC     = m_txtSettingsFor.GetDC();
    CFont *pfnt    = m_txtSettingsFor.GetFont();
    CFont *pfntOld = pDC->SelectObject(pfnt);
	ASSERT(pDC != (CDC *)NULL);
	CSize sizeText = pDC->GetTextExtent(strTxt);
    pDC->SelectObject(pfntOld);
	VERIFY(m_txtSettingsFor.ReleaseDC(pDC));
#if 0
	pDC = m_bnConfigs.GetDC();
	ASSERT(pDC != (CDC *)NULL);
	strTxt.LoadString(IDS_CONFIGS);
	CSize sizeButton = pDC->GetTextExtent(strTxt, strTxt.GetLength()) + CSize(4, 4); // borders
	ASSERT(sizeButton.cx <= (CX_TREECTL/2));
	ASSERT(sizeButton.cy <= (nTabHeight));
	VERIFY(ReleaseDC(pDC));
	int nEditOffset = ((1 + nTabHeight - sizeButton.cy) / 2);
	if (nEditOffset < 0)
		nEditOffset = 0;
	m_bnConfigs.SetWindowPos(NULL, margins.left + CP_OUTER_BORDER + 2, margins.top + 1 + nEditOffset, sizeButton.cx, sizeButton.cy, SWP_NOACTIVATE);
	int cbWidth = CX_TREECTL - sizeButton.cx - 1;
#else
	int nEditOffset = ((1 + nTabHeight - sizeText.cy) / 2);
	if (nEditOffset < 0)
		nEditOffset = 0;
	m_txtSettingsFor.SetWindowPos(NULL, margins.left + CP_OUTER_BORDER,
		margins.top + 1 + nEditOffset,
		sizeText.cx, sizeText.cy, SWP_NOACTIVATE);

	int cbWidth = CX_TREECTL - sizeText.cx;
#endif
	int cbHeight = rectTab.Height() - CP_OUTER_BORDER;
	m_cbConfigs.SetWindowPos(&m_txtSettingsFor, margins.left + CP_OUTER_BORDER /* + 1 */ + sizeText.cx, margins.top + nEditOffset - 1, cbWidth, cbHeight, SWP_NOACTIVATE);

	m_OptTreeCtl.SetWindowPos(&m_cbConfigs,
		margins.left + CP_OUTER_BORDER + 1, margins.top + nTabHeight + 1,
		CX_TREECTL, rectTab.Height() - CP_OUTER_BORDER, SWP_NOACTIVATE);

	// o centre the 'No Common Properties' dlg
	CRect rectNoProps;
	m_dlgNoProps.GetWindowRect(rectNoProps);
	ScreenToClient(rectTab);
	m_dlgNoProps.SetWindowPos(NULL,
		rectTabRow.left + (rectTab.Width() - rectNoProps.Width()) / 2,
		rectTabRow.top + (rectTab.Height() - rectNoProps.Height()) / 2,
		0, 0, SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);

}

void CProjOptionsDlg::ExitCleanup()
{
	// remember the current category state
	RememberCategories();

	CProject * pProject = m_pProject;
#ifdef MPROJ
	// support multiple projects
	const CObList * pProjList = CProject::GetProjectList();
	POSITION pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		pProject->SetOkToDirtyProject();
#ifdef MPROJ
	}
#endif

}

void CProjOptionsDlg::OnOK()
{
	// UNDONE: need to ignore private props and only look at public
	// indetermining r/o handling

	// do we need to validate the tab?
	if (!ValidateCurrent())
		return;	// failed validate

	ExitCleanup();

	BOOL bSettingsChanged = FALSE;

	CProject * pProject = m_pProject;
	CString strTarget = pProject->GetTargetName();
#ifdef MPROJ
	// support multiple projects
	const CObList * pProjList = CProject::GetProjectList();
	POSITION pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif

		pProject->m_bSettingsChanged = DoBagOpOverProject(pProject, CloneBag, CurrBag, BO_Same | BO_PrivateSpecial);
		bSettingsChanged = bSettingsChanged || pProject->m_bSettingsChanged;
#ifdef MPROJ
	}
#endif

	// Flush the undo buffer
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	VERIFY (SUCCEEDED (pProjSysIFace->FlushUndo ()));
	BOOL bCancel = FALSE;
	CStringArray files;
	CPtrList paths;
	const CPath * pPath;

	LPSOURCECONTROL pSccManager;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));

#ifdef MPROJ
	// support multiple projects
	pProjList = CProject::GetProjectList();
	pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()) || (pProject->m_bProjIsExe))
			continue;
#endif

		pPath = pProject->GetFilePath();
		if ((pProject->m_bSettingsChanged==1) && !pProject->IsDirty())
		{
			
			if (pPath->IsReadOnlyOnDisk())
			{
				paths.AddTail(new CPath(*pPath));
				if (pSccManager->IsControlled((const TCHAR *)*pPath) == S_OK)
				{
					files.Add((const TCHAR*)*pPath);
				}
			}
			if (g_bAlwaysExportMakefile)
			{
				CPath path = *pPath;
				path.ChangeExtension(_T(".mak"));
				if (path.IsReadOnlyOnDisk())
				{
					paths.AddTail(new CPath(path));
					if (pSccManager->IsControlled((const TCHAR *)path) == S_OK)
					{
						files.Add((const TCHAR*)path);
					}
				}
				path.ChangeExtension(_T(".dep"));
				if ((g_bAlwaysExportDeps) && path.IsReadOnlyOnDisk())
				{
					paths.AddTail(new CPath(path));
					if (pSccManager->IsControlled((const TCHAR *)path) == S_OK)
					{
						files.Add((const TCHAR*)path);
					}
				}
			}
		}
#ifdef MPROJ
	}
#endif
	BOOL bPossibleCheckOut = FALSE;
	if (files.GetSize() > 0)
	{
		bPossibleCheckOut = (pSccManager->CheckOutReadOnly(files, TRUE, FALSE) == S_OK);
	}

	int nCount = 0;
	CString strPaths;
	while (!paths.IsEmpty())
	{
		pPath = (const CPath *)paths.RemoveHead();
		if ((!bPossibleCheckOut) || pPath->IsReadOnlyOnDisk())
		{
			if (nCount++)
				strPaths += _T("\n");

			strPaths += *pPath;
		}
		delete pPath;
	}
	// now if nCount > 0, then we have some still read-only
	if (nCount)
	{
		UINT nID = (nCount == 1) ? IDS_WARN_PROJ_READ_ONLY : IDS_WARN_PROJS_READ_ONLY;
		CString strMsg;
				
		// give them a chance to attrib or cancel
		bCancel = (MsgBox(Error, MsgText(strMsg, nID, strPaths), MB_OKCANCEL) == IDCANCEL);
#ifdef MPROJ
		pos = pProjList->GetHeadPosition();
		while (pos != NULL)
		{
			pProject = (CProject *)pProjList->GetNext(pos);
			if ((pProject==NULL) || (!pProject->IsLoaded()) || (pProject->m_bProjIsExe))
				continue;
#endif
			if (bCancel)
			{
				pProject->SetOkToDirtyProject(FALSE);
			}
			else if (pProject->m_bSettingsChanged==1)
			{
				// if OK, dirty it silently (already prompted)
				pProject->m_bProjectComplete = FALSE;
				pProject->DirtyProjectEx();
				pProject->m_bProjectComplete = TRUE;
			}
#ifdef MPROJ
		}
#endif
	}

	pSccManager->Release();
	pSccManager = NULL;

	if (bCancel)
	{
		return;
	}

// REVIEW: may need to do something here before commiting changes

#if 0
	// do this here for efficiency before making changes
#ifdef MPROJ
	// support multiple projects
	pProjList = CProject::GetProjectList();
	pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		// allow the project to be dirtied
		// pProject->SetOkToDirtyProject();

		pProject->SetOptionTreeCtl((COptionTreeCtl *)NULL);
#ifdef MPROJ
	}
#endif
#endif

#ifdef MPROJ
	// support multiple projects
	pProjList = CProject::GetProjectList();
	pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		// we OKed so do the bag copy and inform deps. of any changes
		// as well as doing comparision to see if settings have changed
		if (pProject->m_bSettingsChanged)
		{
			(void)DoBagOpOverProject(pProject, CloneBag, CurrBag, BO_Inform | BO_Copy | BO_Same | BO_UseDest);

		}
		else
		{
			(void)DoBagOpOverProject(pProject, (UINT)-1, CurrBag, BO_UseDest);
		}
 
		ASSERT((pProject->m_bSettingsChanged != 1) || (pProject->IsDirty()));

#ifdef MPROJ
	}
#endif

 	//
	// KLUDGE ALERT, other ok semantics go here
	//
	// our messages
	if (m_idOnOKMsg != (UINT)-1)
		MsgBox(Information, m_idOnOKMsg);

	CTabbedDialog::OnOK();

	// clear the ProxySlob
	m_ProxySlob.Clear(FALSE);

#ifdef MPROJ
	// support multiple projects
	pProjList = CProject::GetProjectList();
	pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		// reinit the target include list
		pProject->m_listTargIncl.Init((HBUILDER)pProject);
#ifdef MPROJ
	}
#endif

	if (bSettingsChanged)
		theApp.NotifyPackages(PN_BLD_SETTINGS_CHANGED);
}

void CProjOptionsDlg::OnCancel()
{
 	ExitCleanup();

	// don't save the state of the tree-control
	m_OptTreeCtl.m_fDoStateStore = FALSE;

	CProject * pProject = m_pProject;
	CString strTarget = pProject->GetTargetName();
#ifdef MPROJ
	// support multiple projects
	const CObList * pProjList = CProject::GetProjectList();
	POSITION pos = pProjList->GetHeadPosition();
	while (pos != NULL)
	{
		pProject = (CProject *)pProjList->GetNext(pos);
		if ((pProject==NULL) || (!pProject->IsLoaded()))
			continue;
#endif
		// make sure we're using the old bag
		(void) DoBagOpOverProject(pProject, CloneBag, CurrBag, BO_UseDest);

#ifdef MPROJ
	}
#endif
	//
	// KLUDGE ALERT, other cancel semantics go here
	//

	CTabbedDialog::OnCancel();

	// clear the ProxySlob
	m_ProxySlob.Clear(FALSE);
}

void CProjOptionsDlg::OnSelectTab(int nTab)
{
	// update our notion of what the current tab title is
	m_strPrevTab = nTab == -1 ? "" : m_tabRow.GetTabString(nTab);
}

CButton* CProjOptionsDlg::GetButtonFromIndex(int index)
{
	// Default is either OK/Cancel/Targets/Help or Close/Targets/Help, depending on
	// commit model.  Derived classes may override this, of course.
	if (m_commitModel != commitOnOk && (index > 0))
		index++;

	switch (index)
	{
		case 0:
			return &m_btnOk;

		case 1:
			return &m_btnCancel;

		default:
			return NULL;
	}
}

void CProjOptionsDlg::OnTreeCtlSelChange()
{
	// ignore?
	if (m_fIgnoreSelChange)
		return;

	// update our notion of what the selection is
	if (!m_bDirtyTabs && !UpdateProxySlob(FALSE))
		return;	// no selection change

	// retrieve our new list of option handlers
	CacheOptionHandlers();

	// update our option tabs
	// and inform of the selection change if they
	// is no change in the #/type of option tabs
	if (!UpdateOptionTabs())
 		m_ProxySlob.InformDependants(SN_ALL);

	// show/don't show the 'No Common Properties' dlg. on whether common list hdlrs exists.
	m_dlgNoProps.ShowWindow(m_listHdlrs.IsEmpty() ? SW_SHOW : SW_HIDE);

	// preserve our tab selection
	// decide what the default is
	int nTab = GetTabCount() > 0 ? 0 : -1;

	if (nTab != -1)
	{
		// can we find old tab?
		int nGotTab = -1;
		for (int i = 0 ; i <= m_tabRow.MaxTab() ; i++)
		{
			if (m_strPrevTab == m_tabRow.GetTabString(i))
				nGotTab = i;
		}

		if (nGotTab != -1)
			nTab = nGotTab;	// found

		BOOL fTabNotActive = nTab != m_nTabCur;
		if (fTabNotActive)
		{
			// select this tab, and remember the tab title
			// (preserve focus in tree-control)	
			BOOL fTreeHadFocus = m_OptTreeCtl.HasFocus();

			m_tabRow.SetActiveTab(nTab);
			SelectTab(nTab);	// tab-row gets the focus

			if (fTreeHadFocus && !m_OptTreeCtl.HasFocus())
				m_OptTreeCtl.SetFocus();	// keep our original focus	
		}
		// update the state of the tab?
		// this happens in ActivateTab()
		else // !fTabNotActive
		{
			CDlgTab * pTab = GetTab(nTab);
			if (pTab->IsKindOf(RUNTIME_CLASS(CToolOptionTab)))
			{
				((CToolOptionTab *)pTab)->UpdateState();
			}
			else if (pTab->IsKindOf(RUNTIME_CLASS(CSlobPageTab)))
			{
				((CSlobPageTab *)pTab)->InitPage();
			}
		}
	}
}

void CProjOptionsDlg::CacheOptionHandlers()
{
	// empty our handler cache
	m_listHdlrsCache.RemoveAll();

	// UNDONE: need support for multiple projects
	if ((m_pProject==NULL) || (!m_pProject->m_bProjIsExe))
	{
		// internal target

		// get our available tools for the selection
		CPtrList * * rglistTools = (CPtrList * *)NULL;
		int nSelIndex, nSelCount = m_ProxySlob.m_ptrList.GetCount();

		if (nSelCount != 0)
		{
			if ((rglistTools = new CPtrList *[nSelCount]) == (CPtrList * *)NULL)
				return;

			POSITION pos = m_ProxySlob.m_ptrList.GetHeadPosition();
			nSelIndex = 0;
			while (pos != (POSITION)NULL)
			{
				rglistTools[nSelIndex] = new CPtrList;
				((OptTreeNode *)m_ProxySlob.m_ptrList.GetNext(pos))->GetViableBuildTools(*rglistTools[nSelIndex++]);
			}
		}

		// any handlers for selection?
		BOOL fAtLeastOneHdlr = FALSE;

		// get our common handlers across all of the tools
		// in the selection
		CPtrList m_listHdlrsScratch;
		for (nSelIndex = 0; nSelIndex < nSelCount; nSelIndex++)
		{
			m_listHdlrsScratch.RemoveAll();
			POSITION pos = rglistTools[nSelIndex]->GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				COptionHandler * popthdlr = ((CBuildTool *)rglistTools[nSelIndex]->GetNext(pos))->GetOptionHandler();
				if (popthdlr != (COptionHandler *)NULL)
				{ 
					// got at least one handler non custom tool opthdlr. in the selection?
					if (!popthdlr->m_pAssociatedBuildTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
						fAtLeastOneHdlr = TRUE;

					// is this a common handler or are we the first batch?
					if (nSelIndex == 0 || m_listHdlrsCache.Find(popthdlr))
					{
						ASSERT_VALID(popthdlr);
						m_listHdlrsScratch.AddTail(popthdlr);
					}
					// can we find a common base-option handler?
					// for cross-platform support
					else
					{
						BOOL fMatched = FALSE;
						
						// loop through handlers in cache
						POSITION pos = m_listHdlrsCache.GetHeadPosition();
						while (!fMatched && pos != (POSITION)NULL)
						{
							COptionHandler * popthdlrCache = (COptionHandler *)m_listHdlrsCache.GetNext(pos);
							// loop through base-handlers from cache
							while (!fMatched && popthdlrCache != (COptionHandler *)NULL)
							{
								// loop through base-handlers from current
								COptionHandler * popthdlrCurr = popthdlr;
								while (popthdlrCurr != (COptionHandler *)NULL)
								{
									if (popthdlrCurr == popthdlrCache)
									{
										ASSERT_VALID(popthdlrCurr);
										m_listHdlrsScratch.AddTail(popthdlrCurr);
										fMatched = TRUE;
										break;
									}
									popthdlrCurr = popthdlrCurr->GetBaseOptionHandler();
								}
								popthdlrCache = popthdlrCache->GetBaseOptionHandler();
							}
						}
					}
				}
			}

			// copy our scratch into our actual
			m_listHdlrsCache.RemoveAll();
			m_listHdlrsCache.AddTail(&m_listHdlrsScratch);
		}

		// determine if there's a common project type and if that
		// common project type is Java. If the common project is Java,
		// we'll show a different debug and general tab. If there is a
		// mix of Java and other project types, we won't show the
		// debug tab nor the general tab.
		// (note that this code follows the same model as that used to
		// determine whether to show the external project general tab)
		BOOL bSelectionContainsAtLeastOneJava = FALSE;
		BOOL bSelectionContainsGeneric = FALSE;
		BOOL bSelectionIsAllJava = TRUE;
		BOOL bAtLeastOne = FALSE;
		
		for (POSITION posNode = m_ProxySlob.GetHeadPosition(); posNode != NULL; )
		{
			bAtLeastOne = TRUE;

			// get each option tree node from the selection
			OptTreeNode* pNode = m_ProxySlob.GetNext(posNode);

			// get the project type
			CProjType* pProjType = pNode->GetProjType();

			// is the project type Java?
			if (pProjType != NULL && pProjType->GetUniquePlatformId() == java)
				// there's at least one Java project selected
				bSelectionContainsAtLeastOneJava = TRUE;
			else
				// the selection is not all Java
				bSelectionIsAllJava = FALSE;

			if (pProjType != NULL && pProjType->GetUniqueTypeId() == CProjType::generic)
				bSelectionContainsGeneric = TRUE;
		}
		if (!bAtLeastOne)
			bSelectionIsAllJava = FALSE;

		// determine if the selection is mixed (i.e. C++ and Java)
		BOOL bSelectionIsMixed = !bSelectionIsAllJava && bSelectionContainsAtLeastOneJava;

		// does it have the 'Debugging Options' page?
		if (m_ProxySlob.IsSortOf(RUNTIME_CLASS(CProject)))
		{
			// determine which debug tab will be displayed
			// (C++ or Java) based on the project nodes selected

			// if there is a mix of nodes (C++ and Java) selected,
			// no debug tab will be shown

			// is the selection mixed?
			if (!bSelectionIsMixed && bAtLeastOne)
			{
				// display the appropriate debug tab
				m_listHdlrsCache.AddHead(bSelectionIsAllJava ? OPTHDLR_DEBUG_JAVA : OPTHDLR_DEBUG);
			}
		}

		// Get the common projtype and if this is
		// an external target type then we have the
		// external target type general page
		bAtLeastOne = FALSE;
		BOOL bNotAllExternal = FALSE;
		
		CProjType * pProjType;
 		POSITION pos = m_ProxySlob.GetHeadPosition();
		while (pos)
		{
			OptTreeNode* pNode = m_ProxySlob.GetNext(pos);
			pProjType = pNode->GetProjType();
			if (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
				bAtLeastOne = TRUE;
			else
				bNotAllExternal = TRUE;
		}

		// does it have the Tool 'General' page or the
		// External project 'General' page
		if (m_ProxySlob.IsSortOf(RUNTIME_CLASS(CProject)))
		{
			// are only external projects selected?
			if (bAtLeastOne && !bNotAllExternal)
			{
				// if the selected projects are mixed (i.e. C++ and Java)
				// don't show any General tab
				if (!bSelectionIsMixed)
					// external target options - first tab
					m_listHdlrsCache.AddHead(OPTHDLR_EXTTARG_OPTS);
			}
			// are only internal projects selected?
			else if (!bAtLeastOne && bNotAllExternal)
			{
				// if the selected projects are mixed (i.e. C++ and Java),
				// don't show any General tab
				if (!bSelectionIsMixed)
					// internal target options - first tab
					m_listHdlrsCache.AddHead(bSelectionIsAllJava ? OPTHDLR_JAVA_TOOL_GENERAL : OPTHDLR_TOOL_GENERAL);

				// always have a custom build for the target
				// custom build - last tab

				if (!bSelectionIsMixed && !bSelectionIsAllJava && !bSelectionContainsGeneric)
					m_listHdlrsCache.AddTail(OPTHDLR_CUSTOM_BUILD);

				// internal target options - Pre-link, Post-build tab.
				if (!bSelectionIsMixed && !bSelectionIsAllJava && !bSelectionContainsGeneric)
					m_listHdlrsCache.AddHead(OPTHDLR_PRELINK);

				m_listHdlrsCache.AddHead(OPTHDLR_POSTBUILD);

			}
  		}
		// does it have the Tool 'General' and 'Custom Build' page?
		else if (m_ProxySlob.IsSortOf(RUNTIME_CLASS(CFileItem)) && !m_ProxySlob.IsSortOf(RUNTIME_CLASS(CProjectDependency)))
		{
			// if the selected projects are mixed (i.e. C++ and Java),
			// don't show any General tab
			if (!bSelectionIsMixed)
				// display the appropriate general tab
				m_listHdlrsCache.AddHead(bSelectionIsAllJava ? OPTHDLR_JAVA_TOOL_GENERAL : OPTHDLR_TOOL_GENERAL);

			// only have a custom build for a file if no
			// files in the selection have assoc. tools already
			// and this isn't an external target
			if (!fAtLeastOneHdlr && !bAtLeastOne && bNotAllExternal)
			{
				// custom build - last tab
				m_listHdlrsCache.AddTail(OPTHDLR_CUSTOM_BUILD);
			}
		}

		// delete our tool lists
		if (rglistTools)
		{
			for (nSelIndex = 0; nSelIndex < nSelCount; nSelIndex++)
				delete rglistTools[nSelIndex];
			delete [] rglistTools;
		}
	}
	else
	{
		// executable

		BOOL fDebugTarget = TRUE;	// can we debug this?

 		CString strUIDescription;

		CPlatform * pPlatform;
		if (m_ProxySlob.GetStrProp(P_ExtOpts_Platform, strUIDescription) == valid)
		{
			g_prjcompmgr.LookupPlatformByUIDescription(strUIDescription, pPlatform);

			// can only debug exes for supported platforms
			fDebugTarget = pPlatform->IsSupported();
		}

		if (fDebugTarget)
		{
			// determine which debug tab will be displayed
			// (C++ or Java) based on the platform
			ASSERT(m_pProject);
			ASSERT(m_pProject->GetCurrentPlatform() != NULL);
			if (m_pProject->GetCurrentPlatform()->GetUniqueId() == java)
			{
				// display the Java debug tab
				m_listHdlrsCache.AddHead(OPTHDLR_DEBUG_JAVA);
			}
			else
			{
				// display the C++ debug tab
				m_listHdlrsCache.AddHead(OPTHDLR_DEBUG);
			}
		}

		m_listHdlrsCache.AddTail(OPTHDLR_EXT_OPTS);
	}
}

void CProjOptionsDlg::ValidateContent(OptTreeNode * pNode)
{
	// then create the content
	if (!pNode->m_fValidContent)
	{
		OptTreeNode * pNewOptNode;
		CString cstr;
		POSITION pos = pNode->pItem->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CProjItem * pChildItem = (CProjItem *)pNode->pItem->GetNext(pos);
			if (!m_OptTreeCtl.IsValidOptTreeItem(pChildItem, cstr))
				continue;	// not valid, next!

			// construct our new OptTreeNode for this child item
			// we'll destroy this when we free the target it belongs to
			pNewOptNode = new OptTreeNode(pNode, pChildItem);
			ASSERT(pNewOptNode->pcr != NULL);
			// recurse if this is another group
			if (pChildItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
				ValidateContent(pNewOptNode);
		}

		// content is now valid
		pNode->m_fValidContent = TRUE;
	}
}

void CProjOptionsDlg::AddContent(OptTreeNode * pNode, CPtrList & lstSelectedNodes)
{
	// add this item's content to our selection (CProxySlob)
	POSITION pos = pNode->m_Content.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pChildNode = (OptTreeNode *)pNode->m_Content.GetNext(pos);
		CProjItem * pChildItem = (CProjItem *)pChildNode->pItem;

		if (pChildItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			// recurse if this is another group
			AddContent(pChildNode, lstSelectedNodes);
		}
		else
		{
			// add the child item, this is a file
			lstSelectedNodes.AddHead((void *)pChildNode);
		}
	}
}

BOOL CProjOptionsDlg::UpdateProxySlob(BOOL fInform)
{
	// selection change?
	BOOL fSelChange = FALSE;
	
	// update the Proxy Slob's selection (this may be multiple)
	int nSelCount = m_OptTreeCtl.GetSelCount();
	if (nSelCount == 0)
	{
		// no selection, definitely a selection change!
		m_ProxySlob.Clear(FALSE);
		fSelChange = TRUE;
	}
	else
	{
		// what is our new selection?
		POSITION pos;
		CPtrList lstSelectedNodes;

		INT * rgInt = new INT[nSelCount];
		if (rgInt != (INT *)NULL && m_OptTreeCtl.GetSelItems(nSelCount, rgInt) != LB_ERR)
		{
			for (int nSelItem = nSelCount; nSelItem > 0; nSelItem--)
			{
#ifdef NEWCFG
				OptTreeNodeList	* pNodeList = (OptTreeNodeList *) m_OptTreeCtl.GetData(rgInt[nSelItem-1]);
				int nConfigs = 0;
				POSITION pos1 = pNodeList->GetHeadPosition();
				ASSERT(pos1);
				while (pos1 != NULL)
				{
					OptTreeNode * pNode = pNodeList->GetNext(pos1);
#else
					OptTreeNode	* pNode = (OptTreeNode *) m_OptTreeCtl.GetData(rgInt[nSelItem-1]);
#endif
					// is this a project group, if so then add all of it's children and not itself
					if (pNode->pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
					{
						// make sure this item's content is valid, if it isn't
						// then create the content
						ValidateContent(pNode);

						if (!pNode->IsValid()) // only add the selected ones
							continue;

						// add this item's content to our selection (CProxySlob)
						AddContent(pNode, lstSelectedNodes);
					}
					else
					{
						if (!pNode->IsValid()) // only the selected ones
							continue;

						// add the item, this is a project or file
						lstSelectedNodes.AddTail((void *)pNode);
					}

#ifdef NEWCFG
					nConfigs++;
				}
				ASSERT(nConfigs > 0);
#endif
			}

			// now compare this selection with what we have currently
			fSelChange = lstSelectedNodes.GetCount() != m_ProxySlob.GetCount();
			pos = lstSelectedNodes.GetHeadPosition();
			while (!fSelChange && pos != (POSITION)NULL)
			{
				// currently selected?
				if (!m_ProxySlob.Selected((OptTreeNode *)lstSelectedNodes.GetNext(pos)))
					// no
					fSelChange = TRUE;
			}
		}
		else
		{
			ASSERT(FALSE);		// mem. alloc. or selection retrieve failure
			fSelChange = TRUE; 	// clr. just in case..;-)
		}

		if (rgInt != (INT *)NULL)
			delete [] rgInt;

		if (fSelChange)
		{
   			m_ProxySlob.Clear(FALSE);
			pos = lstSelectedNodes.GetHeadPosition();
			while (pos != (POSITION)NULL)
				m_ProxySlob.Add((OptTreeNode *)lstSelectedNodes.GetNext(pos), FALSE);
		}
	}
	
	// do we need to inform now?
	if (fInform && fSelChange)
		m_ProxySlob.InformDependants(SN_ALL);

	// any change in the selection?
	return fSelChange;
}

void CProjOptionsDlg::RememberCategories()
{
	int nMaxTab = GetTabCount();
	for (int nTab = 0; nTab < nMaxTab; nTab++)
	{
		CString strTitle;
		CDlgTab * pTab = GetTab(nTab);

		// Debug tab now has mini-pages
		if (pTab->IsKindOf(RUNTIME_CLASS(COptsDebugTab))) {
			if (((COptsDebugTab *)pTab)->GetCurrentMiniPage(strTitle))
				m_mapLastMiniPage.SetAt(*((COptsDebugTab *)pTab)->GetCaption(), strTitle);
		}

		if (!pTab->IsKindOf(RUNTIME_CLASS(CToolOptionTab)))
			continue;

		if (((CToolOptionTab *)pTab)->GetCurrentMiniPage(strTitle))
			m_mapLastMiniPage.SetAt(*((CToolOptionTab *)pTab)->GetCaption(), strTitle);
	}
}

void CProjOptionsDlg::GetMargins(CRect & rect)
{
	CTabbedDialog::GetMargins(rect);

	rect.left += CX_TREECTL + CX_TREE_BORDER + CP_OUTER_BORDER * 2;
}

class CDlgStandard : public CDialog
{
public:
	// use the Tool 'General' page as the 'standard' sized page
	CDlgStandard() : CDialog(IDDP_TOOL_GENERAL) {}
	__inline BOOL GetStandardRect(CRect & rect)
	{
		C3dDialogTemplate dt;
		if (dt.Load(m_lpszTemplateName))
			SetStdFont(dt);
		if (!CreateIndirect(dt.GetTemplate()))	// style is NOT VISIBLE
			return FALSE;
		GetWindowRect(rect);
		DestroyWindow();
		return TRUE;
	}
};

void CProjOptionsDlg::GetTabSize(CRect & rect)
{
	CDlgStandard dlg;
	if (!dlg.GetStandardRect(rect))
	{
		// we failed (this will at least provide 'blank'
		// space, I imagine other page tabs will fail creation)
		rect.top = rect.left = 0; rect.right = rect.bottom = 200;
	}
}

int CProjOptionsDlg::DoBagOpOverProject(CProject * pProject, UINT idSrcBag, UINT idDestBag, UINT bagop)
{																		
	// Take a snapshot of our project props
	// do this for all configs for all project items in the project
	CObList obList;
	pProject->FlattenSubtree(obList, CProjItem::flt_Normal | CProjItem::flt_ExcludeDependencies);

	// 0 = no change, 1 = public props change, 2 = only private props change
	int fSettingsChanged = FALSE;  // pseudo-boolean

	const CPtrArray * pCfgProject = pProject->GetConfigArray();
	int size = pCfgProject->GetSize();

	CProjTempConfigChange projTempConfigChange(pProject);
	ConfigurationRecord * pcrCurrent = pProject->GetActiveConfig();

	for (int i = 0; i <= size; i++)
	{
		ConfigurationRecord * pcrProject;

		// do the current pcr last
		if (i == size)
		{
			pcrProject = pcrCurrent;
		}
		else
		{
			pcrProject = (ConfigurationRecord *)pCfgProject->GetAt(i);

			// skip current pcr, we'll do it last
			if (pcrProject == pcrCurrent)
				continue;
		}

		// set the project's active config.
		projTempConfigChange.ChangeConfig(pcrProject);

		BOOL fTargetSetsChng = FALSE;
		if (bagop & BO_Same)
		{
			// have the target-level options changed?
			int retval = pcrProject->BagSame (idSrcBag, idDestBag, (UINT)-1, (UINT)-1, TRUE, ((bagop & BO_PrivateSpecial)==0));
			fTargetSetsChng = (retval == 0);
			if (fTargetSetsChng)
			{
				// target-level action options have possibly changed
				CActionSlobList * pActions = pcrProject->GetActionList();
				POSITION pos = pActions->GetHeadPosition();
				while (pos != (POSITION)NULL)
					((CActionSlob *)pActions->GetNext(pos))->m_fPossibleOptionChange = TRUE;

				// settings have changed
			}

			// REVIEW: make these compatible
			// convert from bagsame retval to actual
			if ((fSettingsChanged != 1) && (retval != 1))
			{
				if (fSettingsChanged == 0)
				{
					fSettingsChanged =  1 - retval;
				}
				else if (retval == 0)
				{
					ASSERT(fSettingsChanged==2);
					fSettingsChanged = 1;
				}
			}
		}

		POSITION pos = obList.GetHeadPosition();
		while (pos != NULL)
		{
			CProjItem * pItem = (CProjItem *)obList.GetNext(pos);
			CTargetItem * pTarget = pItem->GetTarget();

			// Ignore configs that don't pertain to the items target.
			if (pTarget != NULL )
			{
				const CPtrArray * pArrayCfg  = pTarget->GetConfigArray();
				int j ;
				ConfigurationRecord * pcr ;

				for ( j = 0 ; j < pArrayCfg->GetSize() ; j++)
				{
					pcr = (ConfigurationRecord *)pArrayCfg->GetAt(j);
					if (pcrProject->m_pBaseRecord == pcr->m_pBaseRecord)
						break;
				}

				if ( j == pArrayCfg->GetSize() || !pcr->IsValid())
					continue;
			}

			ConfigurationRecord * pcrItem = pItem->GetActiveConfig();
			ASSERT(pcrItem != (ConfigurationRecord *)NULL);
	
			if (bagop & BO_Same)
			{
				int retval = 1 - fSettingsChanged; // default
				if (fTargetSetsChng || !(retval = pcrItem->BagSame (idSrcBag, idDestBag, (UINT)-1, (UINT)-1, TRUE, ((bagop & BO_PrivateSpecial)==0))))
				{
					// item-level action options have possibly changed
					CActionSlobList * pActions = pcrItem->GetActionList();
					POSITION pos = pActions->GetHeadPosition();
					while (pos != (POSITION)NULL)
						((CActionSlob *)pActions->GetNext(pos))->m_fPossibleOptionChange = TRUE;

					// settings have changed
				}
				// REVIEW: make these compatible
				// convert from bagsame retval to actual
				if ((fSettingsChanged != 1) && (retval != 1))
				{
					if (fSettingsChanged == 0)
					{
						fSettingsChanged =  1 - retval;
					}
					else if (retval == 0)
					{
						ASSERT(fSettingsChanged==2);
						fSettingsChanged = 1;
					}
				}
			}

			if (bagop & BO_UseDest)
			{
				// have the item use the dest. bag as the current bag

				// special logic for Cancel:
				BOOL bOldNoTool = -1;
				if (bagop == BO_UseDest && idSrcBag == CloneBag)  // Cancel case
				{
					if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
					{
							// need to check the clone bag to see if it has been changed
							pItem->UsePropertyBag(idSrcBag);
							if (pItem->GetIntProp(P_ItemIgnoreDefaultTool, bOldNoTool) != valid)
							bOldNoTool = -1;
					}
				}

				pItem->UsePropertyBag(idDestBag);

				// more special logic for Cancel case
				if (bOldNoTool != -1)
				{
					BOOL bNoTool;
					if ((pItem->GetIntProp(P_ItemIgnoreDefaultTool, bNoTool) == valid) &&
						(bNoTool != bOldNoTool))
					{
						CActionSlob::UnAssignActions(pItem, NULL, pcrProject);
						CActionSlob::AssignActions(pItem, NULL, pcrProject);
					}
				}
			}

			if (bagop & BO_Copy)
			{	
				// copy into the dest. bag
				pcrItem->BagCopy(idSrcBag, idDestBag, (UINT)-1, (UINT)-1, bagop & BO_Inform);
			}

			if (bagop & BO_Clear)
			{
				// clear the dest. bag
				pcrItem->BagEmpty(idDestBag);
			}
		}
	}

	return fSettingsChanged;	// ok
}

BOOL CProjOptionsDlg::UpdateOptionTabs()
{
	POSITION pos;

	// has the number or type of handlers changed?
	BOOL fNoHdlrChange = m_listHdlrs.GetCount() == m_listHdlrsCache.GetCount();

	pos = m_listHdlrsCache.GetHeadPosition();
	while (fNoHdlrChange && (pos != (POSITION)NULL))
	{
		if (!m_listHdlrs.Find(m_listHdlrsCache.GetNext(pos)))
			// a change in type of handler
			fNoHdlrChange = FALSE;
	}

	// a change in number or type of tabs!
	if (fNoHdlrChange)
		return FALSE;	// no change

	// remember the state of all of our current tool option tabs
	RememberCategories();

	// remove all the tabs we currently have
	if (!ClearAllTabs())
		return FALSE;	// can't do this

	// add the new tabs we'll have (maybe none!)
	BOOL fOk = TRUE;

	pos = m_listHdlrsCache.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		// our tab to add into the 'mondo' dialog
		CDlgTab * pTab;

		// get the option handler
		COptionHandler * popthdlrTool = (COptionHandler *)m_listHdlrsCache.GetNext(pos);

		// is this a 'pseudo' option handler?
		if (popthdlrTool == OPTHDLR_TOOL_GENERAL)
		{	
			// Tool 'General' page
			pTab = (CDlgTab *) new CToolGeneralPage;
			((CSlobPageTab *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 10;
		}
		else if (popthdlrTool == OPTHDLR_CUSTOM_BUILD)
		{
			// 'Custom Build' page
			pTab = (CDlgTab *)new CCustomBuildPage;
			((CCustomBuildPage *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 95;	// always just before options pages
		}
		else if (popthdlrTool == OPTHDLR_DEBUG)
		{
			// Project debug options page
			pTab = (CDlgTab *) new COptsDebugTab;
			((CSlobPageTab *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 20;

			// add our 'General' tab to the tool tab
			COptionMiniPage * pPage = new CDebugGeneralPage;
			if (pPage == (CDebugGeneralPage *)NULL)	
				continue;
			pPage->SetupPage(&m_ProxySlob);
			((COptsDebugTab *)pTab)->AddOptionPage(pPage);

			// add our 'Additional Dlls' tab to the tool tab
			pPage = new CDebugAdditionalDllPage;
			if (pPage == (CDebugAdditionalDllPage *)NULL)	
				continue;
			pPage->SetupPage(&m_ProxySlob);
			((COptsDebugTab *)pTab)->AddOptionPage(pPage);
			
			// make it come up with the last mini-page it had when last created
			CString strCurrentMiniPage;
			if (m_mapLastMiniPage.Lookup(*((COptsDebugTab *)pTab)->GetCaption(), strCurrentMiniPage))
				((COptsDebugTab *)pTab)->SetCurrentMiniPage(strCurrentMiniPage);
		}
		// Java: show the Java debug tab
		else if (popthdlrTool == OPTHDLR_DEBUG_JAVA)
		{
			// Project debug options page
			pTab = (CDlgTab *) new COptsDebugTab;
			((CSlobPageTab *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 22;

			// Java: add the Java 'General' page
			COptionMiniPage* pPage = new CDebugJavaGeneralPage;
			if (pPage == (CDebugJavaGeneralPage*)NULL)
				continue;
			pPage->SetupPage(&m_ProxySlob);
			((COptsDebugTab*)pTab)->AddOptionPage(pPage);

			// add the Java browser page tab
			pPage = new CDebugJavaBrowserPage;
			if (pPage == (CDebugJavaBrowserPage*)NULL)
				continue;
			pPage->SetupPage(&m_ProxySlob);
			((COptsDebugTab*)pTab)->AddOptionPage(pPage);

			// add the Java stand-alone page tab
			pPage = new CDebugJavaStandalonePage;
			if (pPage == (CDebugJavaStandalonePage*)NULL)
				continue;
			pPage->SetupPage(&m_ProxySlob);
			((COptsDebugTab*)pTab)->AddOptionPage(pPage);

			// add the Java 'Additional classes' page to the debug tab
			pPage = new CDebugJavaAddlClassesPage;
			if (pPage == (CDebugJavaAddlClassesPage*)NULL)	
				continue;
			pPage->SetupPage(&m_ProxySlob);
			((COptsDebugTab*)pTab)->AddOptionPage(pPage);

			// make it come up with the last mini-page it had when last created
			CString strCurrentMiniPage;
			if (m_mapLastMiniPage.Lookup(*((COptsDebugTab*)pTab)->GetCaption(), strCurrentMiniPage))
				((COptsDebugTab*)pTab)->SetCurrentMiniPage(strCurrentMiniPage);
		}
		else if (popthdlrTool == OPTHDLR_EXT_OPTS)
		{
			// External project general options page
			pTab = (CDlgTab *) new CExtOptsPage;
			((CSlobPageTab *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 10;
		}
		else if (popthdlrTool == OPTHDLR_EXTTARG_OPTS)
		{
			// External project general options page
			pTab = (CDlgTab *) new CExtTargetOptsPage;
			((CSlobPageTab *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 10;
		}
		else if (popthdlrTool == OPTHDLR_PRELINK)
		{
			// 'Pre-link step' page
			pTab = (CDlgTab *)new CPreLinkPage;
			((CPreLinkPage *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 100;
		}
		else if (popthdlrTool == OPTHDLR_POSTBUILD)
		{
			// 'Post-build step' page
			pTab = (CDlgTab *)new CPostBuildPage;
			((CPostBuildPage *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 110;
		}
		else if (popthdlrTool == OPTHDLR_JAVA_TOOL_GENERAL)
		{	
			// Java tool 'General' page
			pTab = (CDlgTab *) new CJavaToolGeneralPage;
			((CSlobPageTab *)pTab)->SetupPage(&m_ProxySlob);
			pTab->m_nOrder = 10;
		}
		else
		{
#ifdef _DEBUG
			// make sure we don't miss any 'pseudo' pages
			AfxIsValidAddress(popthdlrTool, sizeof (COptionHandler));
#endif
			// construct our list of base-option handlers with option page tabs first
			CPtrList lstOptHdlr;
			COptionHandler * popthdlr = popthdlrTool;

			BOOL fUseBasePages = TRUE;	// default is used base pages
			while (fUseBasePages && popthdlr != (COptionHandler *)NULL)
			{
				CRuntimeClass * * rgTabs = popthdlr->GetOptionPages(fUseBasePages);

				// no tab-list OR empty tab-list?
				if (rgTabs != (CRuntimeClass * *)NULL && rgTabs[0] != (CRuntimeClass *)NULL)
					lstOptHdlr.AddHead((void *)popthdlr);

				popthdlr = popthdlr->GetBaseOptionHandler();
			}

			// any option page tabs?
			if (lstOptHdlr.IsEmpty())
				continue;	// no
	
			// create our tool tab
			pTab = (CDlgTab *) new CToolOptionTab(popthdlrTool->GetNameID());
			if (pTab == (CToolOptionTab *)NULL)
				continue;

			((CToolOptionTab *)pTab)->SetOptionHandler(popthdlrTool);

			CRuntimeClass * pTabClass;
			POSITION pos = lstOptHdlr.GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				popthdlr = (COptionHandler *)lstOptHdlr.GetNext(pos);

				// runtime classes of our option page tabs
				BOOL fDummy;
				CRuntimeClass * * rgTabs = popthdlr->GetOptionPages(fDummy);

				COptionMiniPage * pPage;
				for (int i = 0; (pTabClass = rgTabs[i]) != (CRuntimeClass *)NULL; i++)
				{
					// the CToolOptionTab will delete these
					if (pPage = (COptionMiniPage *)pTabClass->CreateObject())
					{
						// give the page the correct slob and option handler
						pPage->SetupPage(&m_ProxySlob, popthdlr);
						((CToolOptionTab *)pTab)->AddOptionPage(pPage);
					}
				}
			}

			// make it come up with the last mini-page it had when last created
			CString strCurrentMiniPage;
			if (m_mapLastMiniPage.Lookup(*((CToolOptionTab *)pTab)->GetCaption(), strCurrentMiniPage))
				((CToolOptionTab *)pTab)->SetCurrentMiniPage(strCurrentMiniPage);
		}

		// finally add this tool tab to the options 'mondo' dialog
		AddTab(pTab);
	}

	// remember this as the previous list
	m_listHdlrs.RemoveAll();
	m_listHdlrs.AddTail(&m_listHdlrsCache);

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CConfigSelect dialog

CConfigSelectDlg::CConfigSelectDlg(CWnd* pParent /*=NULL*/)
	: C3dDialog(CConfigSelectDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConfigSelectDlg)
	//}}AFX_DATA_INIT
}


void CConfigSelectDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfigSelectDlg)
	DDX_Control(pDX, IDC_TARGET_LIST, m_lbConfigs);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfigSelectDlg, C3dDialog)
	//{{AFX_MSG_MAP(CConfigSelectDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL CConfigSelectDlg::OnInitDialog() 
{
	VERIFY(m_lbConfigs.SubclassDlgItem(IDC_TARGET_LIST, this));
	m_lbConfigs.SetRedraw(FALSE);

	if (UseWin4Look())
		m_lbConfigs.SetFont(GetStdFont(font_Normal));
	else
		m_lbConfigs.SetFont(GetStdFont(font_Bold));

	CString strCurrentFlavour;
	POSITION pos = g_theConfigEnum.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CEnumerator	* pEnum = g_theConfigEnum.GetNext(pos);
		if (pEnum->val)	// supported project type?
		{
			CString strFlavour;
			// REVIEW: consider supporting multiple projects
			CString strConfig = pEnum->szId;
			int nTargetLen = strConfig.Find(" - ");
			ASSERT(nTargetLen > 0);
			strFlavour = strConfig.Mid(nTargetLen + 3);
			if (m_lbConfigs.FindStringExact(-1, strFlavour)==LB_ERR)
			{
				int index = m_lbConfigs.AddString(strFlavour);
				ASSERT(index != LB_ERR);
				if (CProjOptionsDlg::IsActiveFlavour(strFlavour))
				{
					m_lbConfigs.SetCurSel(index);
					m_lbConfigs.SetCheck(index, TRUE);
				}
			}
		}
	}

	m_lbConfigs.SetRedraw(TRUE);

	C3dDialog::OnInitDialog();  // do this last to avoid flashing listbox

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CConfigSelectDlg::OnOK()
{
	m_SelState = same; // default
	BOOL bSelChange = FALSE;
	BOOL bOldCheck = FALSE;
	int i, nConfigs = 0;
	CString strFlavour;
	int count = m_lbConfigs.GetCount();
	ASSERT(count);
	for (i = 0; i < count; i++)
	{
		if (!bSelChange)
		{
			m_lbConfigs.GetText(i, strFlavour);
			bOldCheck = (CProjOptionsDlg::IsActiveFlavour(strFlavour));
		}
		
		
		if (m_lbConfigs.GetCheck(i))
		{
			if ((!bSelChange) && !bOldCheck)
				bSelChange = TRUE;
			nConfigs++;
		}
		else if ((!bSelChange) && bOldCheck)
			bSelChange = TRUE;
	}
	if (nConfigs==0)
	{
		MsgBox(Error, IDS_NO_CONFIGS_SELECTED);
		m_lbConfigs.SetFocus();
		return;
	}
	if (bSelChange)
	{
		CProjOptionsDlg::ResetActiveFlavours();
		for (i = 0; i < count; i++)
		{
			if (m_lbConfigs.GetCheck(i))
			{
				m_lbConfigs.GetText(i, strFlavour);
				CProjOptionsDlg::SetActiveFlavour(strFlavour);
			}
		}
		if (nConfigs == 1)
			m_SelState = single;
		else if (nConfigs == count)
			m_SelState = all;
		else
			m_SelState = multi;
	}

	C3dDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\oletool.h ===
#ifndef _OLETOOL_H_
#define _OLETOOL_H_

#include "bldapi.h"

class CActionSlobList;
class CActionSlob;
class CPlat;
class CDeps;
class CDefaultConfig;
class CTool;
class CProj;
class CScanner;
class CIEnum;

#if 0
typedef CTool *LPBUILDTOOL;
typedef CIEnum *LPENUMBUILDTOOLS;

typedef CDefaultConfig* LPDEFAULTCONFIG;
typedef CIEnum *LPENUMDEFAULTCONFIGS;

typedef CIEnum *LPENUMOPTIONSTRINGS;
typedef CIEnum *LPENUMOPTIONTYPES;

typedef CProj *LPPROJTYPE;
typedef CIEnum *LPENUMPROJTYPES;

typedef CDeps		*LPDEPMANAGER;
typedef CScanner	*LPDEPSCANNER;

typedef CActionSlobList *LPENUMBSACTION;
typedef CActionSlob 	*LPACTION;

typedef CPath	*LPBUILDFILE;
typedef void	*LPBUILDFILESET;

typedef CPlat		*LPPLATFORM;
typedef CIEnum		*LPENUMPLATFORMS;
#endif


class CIEnum{
public:
	virtual void Next( void ) {};
	virtual void Clone( void ){};
	virtual void Reset( void ){};
	virtual void Skip( void ){};
};

class CBldAddOn{
public:
	virtual void GetName( void ) {};
	virtual void SetClient( LPBUILDSYSTEM ){};
	virtual void EnumBuildTools( LPENUMBUILDTOOLS *, LPBUILDTOOL * ){};
	virtual void EnumProjectTypes( LPENUMPROJECTTYPES *, LPPROJECTTYPE * ){};
	virtual void EnumPlatforms( LPENUMPLATFORMS *, LPPLATFORM * ){};
	virtual void ModifyProjectTypes( LPENUMPROJECTTYPES ){};
};

class CProj{
public:
	virtual void GetName( CString *str ){};
	virtual void GetType( UINT *id ){};
	virtual void GetPlatform( LPPLATFORM *){};
	virtual BOOL IsSupported(){ return FALSE; };

	virtual void PickTool( LPBUILDFILE pFile, LPBUILDTOOL *pBuildTool){};
	virtual void AddTool( LPBUILDTOOL pBuildTool){};
	virtual void EnumBuildTools( LPENUMBUILDTOOLS *, LPBUILDTOOL * ){};

//	virtual void EnumDefaultConfigs( LPENUMDEFAULTCONFIGS *, LPDEFAULTCONFIG * ){};
};

class CTool{
public:
	virtual BOOL IsCollectorTool(){return 0;};
	virtual BOOL Filter(LPBUILDFILE){return 0;};
	virtual void PerformBuild( int type, int stage,LPENUMBSACTIONS, int *result ){};
	virtual BOOL GenerateCommandLines( LPENUMBSACTIONS, CStringList &, CStringList & ){return 0;};
	virtual BOOL GenerateOutputs( LPENUMBSACTIONS ){return 0;};
	virtual BOOL GetDependencies( LPENUMBSACTIONS ){return 0;};
	virtual void EnumOptionStrings( LPENUMOPTIONSTRINGS * ){};
	virtual void EnumOptionTypes( LPENUMOPTIONTYPES * ){};
};

class CScanner{
public:
	virtual void PrepareForScan( HCONFIGURATION ){};
	virtual void ScanComplete( HCONFIGURATION ){};
	virtual BOOL GenerateDependencies( LPBSACTION ){return 0;};
};

class COptHandler {
	virtual void GetFakeStrProp( UINT PropID, LPCOLESTR * ){};
	virtual void SetFakeStrProp( UINT PropID, LPCOLESTR * ){};
};

class CDefaultConfig {
	virtual void GetName( LPCOLESTR * ){};
	virtual void GetOutDir( LPCOLESTR * ){};
	virtual void GetSettings( LPBUILDTOOL, LPCOLESTR * ){};
};

class CPlat {
	virtual void GetName( LPCOLESTR * ){};
	virtual BOOL IsSupported(){ return FALSE; };
	virtual void GetEnvPath( LPCOLESTR *, LPCOLESTR * ){};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\newgrp.h ===
// newgrp.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewGroupDlg dialog

class CNewGroupDlg : public C3dDialog
{
// Construction
public:
	CNewGroupDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CNewGroupDlg)
	CString m_strGroup;
	CString m_strGroupFilter;
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNewGroupDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewGroupDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeGroup();
	afx_msg void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optncplr.cpp ===
//
// Common Compiler Tool Options
//
// [matthewt]
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "optncplr.h"	// our local header file

IMPLEMENT_DYNCREATE(CCompilerPageTab, COptionMiniPage)
IMPLEMENT_DYNCREATE(CCompilerGeneralPage, CCompilerPageTab)
IMPLEMENT_DYNCREATE(CCompilerCustomPage, CCompilerPageTab)
IMPLEMENT_DYNCREATE(CCompilerCustomCppPage, CCompilerPageTab)
IMPLEMENT_DYNCREATE(CCompilerListfilePage, CCompilerPageTab)
IMPLEMENT_DYNCREATE(CCompilerPreprocessPage, CCompilerPageTab)
IMPLEMENT_DYNCREATE(CCompilerDebugOptPage, CCompilerPageTab)
IMPLEMENT_DYNCREATE(CCompilerPchPage, CCompilerPageTab)
IMPLEMENT_DYNCREATE(CCompilerOptimizePage, CCompilerPageTab)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


//----------------------------------------------------------------
// our COMMON compiler option strings
//----------------------------------------------------------------

BEGIN_OPTSTR_TABLE(CompilerCommon, P_CplrUnknownOption, P_CplrUnknownString, P_CplrNoLogo, P_Enable_dlp, TRUE)
	IDOPT_CPLRNOLOGO,		"nologo%T1",		OPTARGS1(P_CplrNoLogo),					single,
	IDOPT_DERIVED_OPTHDLR,	"",					NO_OPTARGS,								single,
	IDOPT_MSEXT,		"Z%{e|a}1",				OPTARGS1(P_MSExtension),				single,
	IDOPT_TURN_OFF_WARNINGS,	"w%<1>1",		OPTARGS1(P_WarningLevel),				single,
	IDOPT_WARN,			"W%{0|1|2|3|4}1",		OPTARGS1(P_WarningLevel), 				single,

	IDOPT_WARNASERROR,	"WX%T1",				OPTARGS1(P_WarnAsError),				single,
	IDOPT_ENABLE_MR,	"Gm%{-|}1",				OPTARGS1(P_Enable_MR),					single,
	IDOPT_ENABLE_INCR,	"Gi%{-|}1",				OPTARGS1(P_Enable_Incr),				single,
	IDOPT_PTRMBR1,		"vm%{b|g}1",			OPTARGS1(P_PtrMbr1),					single,
	IDOPT_PTRMBR2,		"vm%{v|s|m}1",			OPTARGS1(P_PtrMbr2),					single,
	IDOPT_VTORDISP,		"vd%{1|0}1",			OPTARGS1(P_VtorDisp),					single,
	IDOPT_ENABLE_RTTI,	"GR%{-|}1",				OPTARGS1(P_Enable_RTTI),				single,
/* temporarily reverse the logic for PDC (BamBam) 'cos the compiler default will be /GX- for this
** release .. ie. we need [X] Enable EH in the options dialog
	IDOPT_DISABLE_EH,	"GX%{|-}1",				OPTARGS1(P_Disable_EH),					single,
*/
	IDOPT_ENABLE_EH,	"GX%{-|}1",				OPTARGS1(P_Enable_EH),					single,
	IDOPT_DEBUGINFO,	"Z%{d|7|i|I}1",			OPTARGS1(P_DebugInfo),					single,
	IDOPT_OPTIMIZE,		"O%{d|2|1}1",			OPTARGS1(P_Optimize),					single,
	IDOPT_OPT_X,		"Ox%T1%<4>2",			OPTARGS2(P_Optimize_X, P_Optimize),		single,
	IDOPT_OPT_T,		"Ot%T1%<4>2",			OPTARGS2(P_Optimize_T, P_Optimize),		single,
	IDOPT_OPT_A,		"Oa%T1%<4>2",			OPTARGS2(P_Optimize_A, P_Optimize),		single,
	IDOPT_OPT_W,		"Ow%T1%<4>2",			OPTARGS2(P_Optimize_W, P_Optimize),		single,
	IDOPT_OPT_G,		"Og%T1%<4>2",			OPTARGS2(P_Optimize_G, P_Optimize),		single,
	IDOPT_OPT_I,		"Oi%T1%<4>2",			OPTARGS2(P_Optimize_I, P_Optimize),		single,
	IDOPT_OPT_S,		"Os%T1%<4>2",			OPTARGS2(P_Optimize_S, P_Optimize),		single,
	IDOPT_OPT_P,		"Op%{-|}1",				OPTARGS1(P_Optimize_P),					single,
	IDOPT_OPT_Y,		"Oy%{-|}1",				OPTARGS1(P_Optimize_Y),					single,
	IDOPT_INLINECTRL,	"Ob%{0|1|2}1",			OPTARGS1(P_InlineControl),				single,
	IDOPT_STRPOOL,		"Gf%T1",				OPTARGS1(P_StringPool),					single,
	IDOPT_INCLINK,		"Gy%T1",				OPTARGS1(P_IncLinking),					single,
	IDOPT_CPLRIGNINC,	"X%T1",					OPTARGS1(P_CplrIgnIncPath),				single,
	IDOPT_CPLRINCLUDES,	"I[ ]%1",				OPTARGS1(P_CplrIncludes),				multiple,
	IDOPT_FORCEINCLUDES,	"FI%1",				OPTARGS1(P_ForceIncludes),				multiple,
	IDOPT_UNDEFINE,		"u%T1",					OPTARGS1(P_Undefine),					single,
	IDOPT_MACROS,		"D[ ]%1",				OPTARGS1(P_MacroNames),					multiple,

// FUTURE (matthewt): how to handle this in the property page?
//	IDOPT_MACROS,		"D[ ]%1[=%2]",			OPTARGS2(P_MacroNames, P_MacroValues),	multiple,

	IDOPT_UNDEFMACROS,	"U[ ]%1",				OPTARGS1(P_UndefMacros),				multiple,
	IDOPT_LISTASM,		"FA%{%f1%f2|cs%t1%t2|c%t1%f2|s%f1%t2}3",	OPTARGS3(P_AsmListHasMC, P_AsmListHasSrc, P_ListAsm),						single,
	IDOPT_OUTDIR_COD,	"Fa%1",					OPTARGS1(P_OutputDir_Cod),				single,
	IDOPT_LISTBSCNOLCL,	"Fr%T1%t2[%3]",			OPTARGS3(P_GenBrowserInfo, P_GenBrowserInfoNoLcl, P_OutputDir_Sbr),	single,
	IDOPT_LISTBSC,		"FR%T1%f2[%3]",			OPTARGS3(P_GenBrowserInfo, P_GenBrowserInfoNoLcl, P_OutputDir_Sbr),	single,
	IDOPT_PCHNAME,		"Fp%1",					OPTARGS1(P_OutputDir_Pch),				single,
	IDOPT_AUTOPCH,		"YX%T1[%2]",			OPTARGS2(P_AutoPch, P_AutoPchUpTo),				single,
	IDOPT_PCHCREATE,	"Yc%T1[%2]",			OPTARGS2(P_PchCreate, P_PchCreateUptoHeader),	single,
	IDOPT_PCHUSE,		"Yu%T1[%2]",			OPTARGS2(P_PchUse, P_PchUseUptoHeader),			single,
	IDOPT_OUTDIR_OBJ,	"Fo%1",					OPTARGS1(P_OutputDir_Obj),				single,
	IDOPT_OUTDIR_PDB,	"Fd%1",					OPTARGS1(P_OutputDir_Pdb),				single,
	IDOPT_STACK_PROBE,	"Ge%T1",				OPTARGS1(P_StackProbe),					single,
	IDOPT_STACK_PROBE_THOLD,	"Gs%1",			OPTARGS1(P_StackProbeTHold),			single,
	IDOPT_MAXLEN_EXTNAME,		"H%1",			OPTARGS1(P_MaxLenExtNames),				single,
	IDOPT_USECHAR_AS_UNSIGNED,	"J%T1",			OPTARGS1(P_UseChasAsUnsigned),			single,
	IDOPT_EMBED_STRING,			"V%1",			OPTARGS1(P_EmbedString),				single,
	IDOPT_NO_DEFLIB_NAME,		"Zl%T1",		OPTARGS1(P_NoDefLibNameInObj),			single,
	IDOPT_PREP_COMMENTS,		"C%T1",			OPTARGS1(P_PrepPreserveComments),		single,
	IDOPT_PREPROCESS,			"E%T1",			OPTARGS1(P_Preprocess),					single,
	IDOPT_PREPROCESS_WO_LINES,	"EP%T1",		OPTARGS1(P_PreprocessWOLines),			single,
	IDOPT_ENABLE_FD,	"FD%{-|}1",				OPTARGS1(P_Enable_FD),					single,
	IDOPT_ENABLE_FC,	        "FC%T1",		        OPTARGS1(P_Enable_FC),			single,
	IDOPT_STACKSIZE,			"F%1",			OPTARGS1(P_StackSize),					single,
	IDOPT_ENABLE_DLP,			"dlp%{-|}1",	OPTARGS1(P_Enable_dlp),					single,
	IDOPT_PREPROCESS_TO_FILE,	"P%T1",			OPTARGS1(P_PrepprocessToFile),			single,
	IDOPT_GEN_FUNC_PROTO,		"Zg%T1",		OPTARGS1(P_GenFuncProto),				single,
	IDOPT_CHECK_SYNTAX,			"Zs%T1",		OPTARGS1(P_CheckSyntax),				single,
	IDOPT_UNKNOWN_OPTION,	"",					NO_OPTARGS,								single,
	IDOPT_UNKNOWN_STRING,	"",					NO_OPTARGS,								single,
	IDOPT_COMPILE_ONLY,	"c%T1",					OPTARGS1(P_CompileOnly),				single,
	IDOPT_TREATFILEAS_C,	"Tc%T1",			OPTARGS1(P_TreatFileAsC),				single,
	IDOPT_TREATFILEAS_CPP,	"Tp%T1",			OPTARGS1(P_TreatFileAsCPP),				single,	
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(CompilerCommon)
	OPTDEF_BOOL(CplrNoLogo, FALSE)
	OPTDEF_BOOL(MSExtension, FALSE)
	OPTDEF_BOOL(IncLinking, FALSE)
	OPTDEF_INT(WarningLevel, 2)
	OPTDEF_BOOL(WarnAsError, FALSE)
	OPTDEF_BOOL(StringPool, FALSE)
	OPTDEF_INT(PtrMbr1, 1)
	OPTDEF_INT(PtrMbr2, 1)
	OPTDEF_BOOL(VtorDisp, FALSE)
/* temporarily reverse the logic for PDC (BamBam) 'cos the compiler default will be /GX- for this
** release .. ie. we need [X] Enable EH in the options dialog
	OPTDEF_BOOL(Disable_EH, FALSE)
*/
	OPTDEF_BOOL(Enable_EH, FALSE)
	OPTDEF_BOOL(Enable_MR, FALSE)
	OPTDEF_BOOL(Enable_RTTI, FALSE)
	OPTDEF_BOOL(Enable_Incr, FALSE)
	OPTDEF_INT(DebugInfo, 0)
	OPTDEF_BOOL(AutoPch, FALSE)
	OPTDEF_PATH(AutoPchUpTo, "")
	OPTDEF_INT(Optimize, 0)
	OPTDEF_BOOL(Optimize_A, FALSE)
	OPTDEF_BOOL(Optimize_W, FALSE)
	OPTDEF_BOOL(Optimize_G, FALSE)
	OPTDEF_BOOL(Optimize_I, FALSE)
	OPTDEF_BOOL(Optimize_P, FALSE)
	OPTDEF_BOOL(Optimize_T, FALSE)
	OPTDEF_BOOL(Optimize_S, FALSE)
	OPTDEF_BOOL(Optimize_Y, FALSE)
	OPTDEF_BOOL(Optimize_X, FALSE)
	OPTDEF_INT(InlineControl, 1)
	OPTDEF_BOOL(Undefine, FALSE)
	OPTDEF_INT(ListAsm, 0)
	OPTDEF_BOOL(AsmListHasMC, FALSE)
	OPTDEF_BOOL(AsmListHasSrc, FALSE)
	OPTDEF_BOOL(GenBrowserInfoNoLcl, FALSE)
	OPTDEF_BOOL(GenBrowserInfo, FALSE)
	OPTDEF_BOOL(CplrIgnIncPath, FALSE)
	OPTDEF_LIST(MacroNames, "")
	OPTDEF_LIST(MacroValues, "")
	OPTDEF_LIST(UndefMacros, "")
	OPTDEF_LIST(CplrIncludes, "")
	OPTDEF_LIST(ForceIncludes, "")
	OPTDEF_PATH(OutputDir_Obj, "")
	OPTDEF_PATH(OutputDir_Pch, "")
	OPTDEF_PATH(OutputDir_Pdb, "")
	OPTDEF_PATH(OutputDir_Sbr, "")
	OPTDEF_PATH(OutputDir_Cod, "")
	OPTDEF_BOOL(PchCreate, FALSE)
	OPTDEF_PATH(PchCreateUptoHeader, "")
	OPTDEF_BOOL(PchUse, FALSE)
	OPTDEF_PATH(PchUseUptoHeader, "")
	OPTDEF_BOOL(TreatFileAsC, FALSE)
	OPTDEF_BOOL(TreatFileAsCPP, FALSE)
	OPTDEF_BOOL(CompileOnly, FALSE)
	// The following two props are not actually compiler flags, nor are they
	// accessible via the options dialogs.  They are present in the default
	// option table purely so that assumptions about these names are in one
	// place only.
	OPTDEF_PATH(PchDefaultName, "msvc.pch")
	OPTDEF_PATH(PdbDefaultName, "msvc.pdb")
	OPTDEF_BOOL(StackProbe, FALSE)
	OPTDEF_INT(StackProbeTHold, 4096)
	OPTDEF_INT(MaxLenExtNames, -1)
	OPTDEF_BOOL(UseChasAsUnsigned, FALSE)
	OPTDEF_STRING(EmbedString, "")
	OPTDEF_BOOL(NoDefLibNameInObj, FALSE)
	OPTDEF_BOOL(PrepPreserveComments, FALSE)
	OPTDEF_BOOL(Preprocess, FALSE)
	OPTDEF_BOOL(PreprocessWOLines, FALSE)
	OPTDEF_HEX(StackSize, -1)
	OPTDEF_BOOL(PrepprocessToFile, FALSE)
	OPTDEF_BOOL(GenFuncProto, FALSE)
	OPTDEF_BOOL(CheckSyntax, FALSE)
	OPTDEF_INT(PseudoPch, 1)
	OPTDEF_BOOL(Enable_FD, FALSE)
	OPTDEF_BOOL(Enable_FC, FALSE)
	// this option is an internal flag that is incompatible with /ZI
	OPTDEF_BOOL(Enable_dlp, FALSE)
END_OPTDEF_MAP()

BOOL OPTION_HANDLER(CompilerCommon)::AlwaysShowDefault(UINT idProp)
{
	return FALSE;
}

// COMMON compiler tool option default map 'faking'

BOOL OPTION_HANDLER(CompilerCommon)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (
			idPropL == P_OutputDir_Obj ||
			idPropL == P_OutputDir_Pch ||
			idPropL == P_OutputDir_Sbr ||
			idPropL == P_OutputDir_Pdb ||
			idPropL == P_OutputDir_Cod ||
			idPropL == P_PchDefaultName ||
			idPropL == P_PseudoPch
		   );
}

BOOL OPTION_HANDLER(CompilerCommon)::SetsFakePropValue(UINT idProp)
{
	ASSERT(IsFakeProp(idProp));

	UINT idPropL = MapActual(idProp);
	switch (idPropL)
	{
	case P_PchDefaultName:
	case P_OutputDir_Pch:
		return FALSE;		// never defined at file level (no multiple .pch support)

	case P_OutputDir_Obj:
	case P_OutputDir_Sbr:
	case P_OutputDir_Pdb:
	case P_OutputDir_Cod:
		// these are solely dependent on the output/target directory (which is checked
		// separately).
		return FALSE;
	}

	return TRUE;	// we don't know anything about this property
}

UINT OPTION_HANDLER(CompilerCommon)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	// our .pdb/.icc files are always in the target directory
	if (idPropL == P_OutputDir_Pdb)
		return P_OutDirs_Intermediate;

	// our .PCH files are always in the project-level intermediate directory
	// we'll make sure we use this level in ::FormFakeStrProp()
	else if (idPropL == P_OutputDir_Pch)
		return P_OutDirs_Intermediate;

	// all other files use the intermediate directory
	else if (idPropL == P_OutputDir_Obj || idPropL == P_OutputDir_Sbr || idPropL == P_OutputDir_Cod)
		return P_OutDirs_Intermediate;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OPTION_HANDLER(CompilerCommon)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	CPath pathFp, path;
	CDir dirFp;
	CString strDefName;

	// ASSERT this is a compiler 'fake' string prop?
	ASSERT(IsFakeProp(idProp));

	// handle our default props
	if (idPropL == P_PchDefaultName)
	{
		// do we have /Fp, if so then just return this
		if (m_pSlob->GetStrProp(MapLogical(P_OutputDir_Pch), strVal) == invalid)
			strVal = "";	// dep. check caused invalid, default ""

		// is this empty or a directory?
		if (!strVal.IsEmpty())
		{
			const TCHAR * pchFp = (const TCHAR *)strVal + strVal.GetLength();
			pchFp = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchFp);

			if (*pchFp == _T('/') || *pchFp == _T('\\'))
			{
				if (COptionHandler::GetDefStrProp(idProp, strDefName) == invalid)
					strDefName = "";	// dep. caused invalid, default ""

				strVal += strDefName;
			}
		}

		return;	// we're done
	}

	// which output directory do we want to use?
	UINT idOutDirProp = GetFakePathDirProp(idProp);
	ASSERT(idOutDirProp != (UINT)-1);

	// the rest are output directory related
	// find one somewhere in the hierarchy

	// make sure the project is in our config.
	CProjItem * pItem = (CProjItem *)m_pSlob;
	CProjTempConfigChange projTempConfigChange(pItem->GetProject());
	projTempConfigChange.ChangeConfig((ConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord);

	// .pch uses project-level intermediate directory...
	// we can't use file-level because we don't have
	// support for multiple .pchs
	if (idPropL == P_OutputDir_Pch)
		pItem = pItem->GetProject();

	GPT gpt = pItem->GetStrProp(idOutDirProp, strVal);
	while (gpt != valid)
	{
		pItem = (CProjItem *)pItem->GetContainer();
		ASSERT(pItem != (CSlob *)NULL);
		gpt = pItem->GetStrProp(idOutDirProp, strVal);
	}

	// reset the project config.
	projTempConfigChange.Release();

	// Make sure this ends in a slash.
	if (!strVal.IsEmpty())
	{
		TCHAR * pchStart = strVal.GetBuffer(1);
		TCHAR * pchT;

		pchT = pchStart + _tcslen(pchStart);	// point to nul terminator
		pchT = _tcsdec(pchStart, pchT);			// back up one char, DBCS safe

		if (*pchT != _T('\\') && *pchT != _T('/'))
		{
			strVal.ReleaseBuffer();
			strVal += _T('/');
		}
	}

	// if we are /Fp (.pch) or /Fd (.pdb/.icc) then tag on the basename of the project
	if (idPropL == P_OutputDir_Pch)
	{
		ASSERT(g_pActiveProject);
		CString strBase; 

        CProjItem * pItem = ((CProjItem *)m_pSlob);
		CDir dirWorkspace = pItem->GetProject()->GetWorkspaceDir();
		CDir dirProject = pItem->GetProject()->GetProjDir(pItem->GetActiveConfig());
		CString strWorkspace = (const TCHAR *)dirWorkspace;
		CString strProject = (const TCHAR *)dirProject;

		if (strWorkspace.CompareNoCase(strProject) == 0)
		{
			const CPath * ppathProj = pItem->GetProject()->GetFilePath();
			ppathProj->GetBaseNameString(strBase);
		}
		else
		{
			// subproject
			ASSERT( (strProject.GetLength() > strWorkspace.GetLength()) );
			strBase = strProject.Right(strProject.GetLength()-strWorkspace.GetLength()-1);
		}

		strVal += strBase;
		strVal += _TEXT(".pch");
	}
}

GPT OPTION_HANDLER(CompilerCommon)::GetDefStrProp(UINT idProp, CString & val)
{
	UINT idPropL = MapActual(idProp);
	BOOL fIgnoreFake = FALSE;

	// we don't have OutputDir_Pdb with no /Zi or /Gi or /FD
	if (idPropL == P_OutputDir_Pdb)
	{
		int nVal;
		// N.B. 3 == /Zi
		if ((m_pSlob->GetIntProp(MapLogical(P_DebugInfo), nVal) == invalid || nVal < DebugInfoPdb) &&
			(m_pSlob->GetIntProp(MapLogical(P_Enable_Incr), nVal) == invalid || !nVal) &&
			(m_pSlob->GetIntProp(MapLogical(P_Enable_FD), nVal) == invalid || !nVal))
		{
			fIgnoreFake = TRUE;	// not a faked prop in this context
		}
	}

	// just return the intermediate output directory for these 'fakes'
	if (IsFakeProp(idProp))
	{
		FormFakeStrProp(idProp, val);
		return valid;
	}

	return COptionHandler::GetDefStrProp(idProp, val);
}

void OPTION_HANDLER(CompilerCommon)::FormFakeIntProp(UINT idProp, int & nVal)
{
}

GPT OPTION_HANDLER(CompilerCommon)::GetDefIntProp(UINT idProp, int & val)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_Optimize_Y)
	{
		// default is /Oy with /Ox or /O2, and /Oy- otherwise
		int nVal;
		val = (m_pSlob->GetIntProp(MapLogical(P_Optimize_X), nVal) == valid && nVal) ||
			  (m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal) == valid && (nVal == 2));
		return valid;
	}
	else if (idPropL == P_Optimize_P)
	{
		// default is /Op with /Za, and /Op- otherwise
		int nVal;
		val = (m_pSlob->GetIntProp(MapLogical(P_MSExtension), nVal) == valid && nVal);
		return valid;
	}
	else if (idPropL == P_InlineControl)
	{
		// default is /Ob1 with /O2, /O1 and /Ox
		int nVal;
		val = (m_pSlob->GetIntProp(MapLogical(P_Optimize_X), nVal) == valid && nVal) ||
			  (m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal) == valid && (nVal == 2 || nVal == 3)) ? 2 : 1;
		return valid;
	}
	else if (idPropL == P_PseudoPch)
	{
		int nVal;
		if (m_pSlob->GetIntProp(MapLogical(P_PchCreate), nVal) == valid && nVal)
			val = 3;
		else if (m_pSlob->GetIntProp(MapLogical(P_PchUse), nVal) == valid && nVal)
			val = 4;
		else if (m_pSlob->GetIntProp(MapLogical(P_AutoPch), nVal) == valid && nVal)
			val = 2;
		else
			val = 1;

		return valid;
	}
	else if (idPropL == P_StringPool || idPropL == P_IncLinking)
	{
		// default is /Gy, /Gf for /O2 and /O1
		int nVal;
		val = (m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal) == valid && (nVal == 2 || nVal == 3));
		return valid;
	}

	return COptionHandler::GetDefIntProp(idProp, val);
}

void OPTION_HANDLER(CompilerCommon)::OnOptionIntPropChange(UINT idProp, int nVal)
{
	ASSERT(m_pSlob != (CSlob *)NULL);

	UINT idPropL = MapActual(idProp);
	int nCurrVal;

	// do we need special processing?
	switch (idPropL)
	{
		case P_ListAsm:
			// handle .asm file combinations
			m_pSlob->SetIntProp(MapLogical(P_AsmListHasMC), nVal == 2 || nVal == 3);
			m_pSlob->SetIntProp(MapLogical(P_AsmListHasSrc), nVal == 2 || nVal == 4);
			break;

		case P_PseudoPch:
			// ignore if the current property bag
			if (((CProjItem *)m_pSlob)->UsePropertyBag() != CurrBag)
			{
				// handle .pch weirdness with our radio group UI (P_PseudoPch)
				if (m_pSlob->GetIntProp(MapLogical(P_AutoPch), nCurrVal) != valid || (nCurrVal != (nVal == 2)))
					m_pSlob->SetIntProp(MapLogical(P_AutoPch), nVal == 2);

				if (m_pSlob->GetIntProp(MapLogical(P_PchCreate), nCurrVal) != valid || (nCurrVal != (nVal == 3)))
					m_pSlob->SetIntProp(MapLogical(P_PchCreate), nVal == 3);
				 
				if (m_pSlob->GetIntProp(MapLogical(P_PchUse), nCurrVal) != valid || (nCurrVal != (nVal == 4)))
					m_pSlob->SetIntProp(MapLogical(P_PchUse), nVal == 4);
			}

			// remove the pseudo-prop from this bag!
			m_pSlob->GetPropBag()->RemoveProp(idProp);
			break;

		default:
			break;
	}

	// DOLPHIN bug fix #12677
	// FUTURE (matthewt): fix this properly by writing individual props. into project file
	// make sure that properties that 'rely' on other
	// prop. values to be shown as an option have the 'other'
	// props. set (no need to do for non-file items)
	if (m_pSlob->GetContainer() != (CSlob *)NULL)
	{
		switch (idPropL)
		{
			case P_GenBrowserInfoNoLcl:
				// make sure we should be able to do this
				if (m_pSlob->GetIntProp(MapLogical(P_GenBrowserInfo), nCurrVal) == valid && nCurrVal)
					m_pSlob->SetIntProp(MapLogical(P_GenBrowserInfo), TRUE);
				break;

			case P_Optimize_X:
			case P_Optimize_T:
			case P_Optimize_A:
			case P_Optimize_W:
			case P_Optimize_G:
			case P_Optimize_I:
			case P_Optimize_S: 
				// make sure we should be able to do this
				if (m_pSlob->GetIntProp(MapLogical(P_Optimize), nCurrVal) == valid && (nCurrVal == 4))
					m_pSlob->SetIntProp(MapLogical(P_Optimize), 4);
				break;

			default:
				break;
		}
	}
}

void OPTION_HANDLER(CompilerCommon)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// DOLPHIN bug fix #12677
	// FUTURE (matthewt): fix this properly by writing individual props. into project file
	// make sure that properties that 'rely' on other
	// prop. values to be shown as an option have the 'other'
	// props. set (no need to do for non-file items)
	if (m_pSlob->GetContainer() != (CSlob *)NULL)
	{
		switch (idPropL)
		{
			case P_AutoPchUpTo:
				m_pSlob->SetIntProp(MapLogical(P_AutoPch), TRUE);
				break;
 
			case P_PchCreateUptoHeader:
				m_pSlob->SetIntProp(MapLogical(P_PchCreate), TRUE);
				break;

			case P_PchUseUptoHeader:
				m_pSlob->SetIntProp(MapLogical(P_PchUse), TRUE);
				break;

			case P_OutputDir_Sbr:
				m_pSlob->SetIntProp(MapLogical(P_GenBrowserInfo), TRUE);
				break;

			default:
				break;
		}
	}
}

BOOL OPTION_HANDLER(CompilerCommon)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fValid = TRUE;			// valid by default

	// placeholders for values
	int nVal;	

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// Incr. compilation and RTTI not available on all platforms
		case P_Enable_RTTI:
		{
			CPlatform * pPlatform = ((CProjItem *)m_pSlob)->GetProject()->GetCurrentPlatform();
			fValid = (pPlatform->GetAttributes() & PIA_Supports_RTTI) != 0;
			break;
		}

		case P_Enable_Incr:
		{
			CPlatform * pPlatform = ((CProjItem *)m_pSlob)->GetProject()->GetCurrentPlatform();
			fValid = (pPlatform->GetAttributes() & PIA_Supports_IncCplr) != 0;
			break;
		}

		case P_Enable_MR:
		{
			CPlatform * pPlatform = ((CProjItem *)m_pSlob)->GetProject()->GetCurrentPlatform();
			fValid = (pPlatform->GetAttributes() & PIA_Supports_MinBuild) != 0;

			// only valid for /Zi
			if (fValid)
			{
				(void) m_pSlob->GetIntProp(MapLogical(P_DebugInfo), nVal);
				fValid = (nVal >= DebugInfoPdb);
			}
			break;
		}

		// General-Purpose combo only enabled if PtrMbr1 is
		// 'general' representation
		case P_PtrMbr2:
			(void)m_pSlob->GetIntProp(MapLogical(P_PtrMbr1), nVal);
			fValid = (nVal == 2);	
			break;

		// Can't have these without 'Gen Browser Info' checked
		case P_GenBrowserInfoNoLcl:
		case P_OutputDir_Sbr:
			(void)m_pSlob->GetIntProp(MapLogical(P_GenBrowserInfo), nVal);
			fValid = !!nVal;
			break;

		// Can't name the listfile without setting listfile options
		case P_OutputDir_Cod:
			(void)m_pSlob->GetIntProp(MapLogical(P_ListAsm), nVal);
			fValid = !!nVal;
			break;

		// Can't have any custom optimizations without 'CustomOpt' on
		case P_Optimize_A:
		case P_Optimize_W:
		case P_Optimize_G:
		case P_Optimize_I:
		case P_Optimize_T:
		case P_Optimize_S:
		case P_Optimize_X:
			(void)m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal);
			fValid = (nVal == 4);
			break;

		// These are both enabled given /O2, there is no way to turn-off
		// ie. no /Gf- or /Gy-, on the command-line
		case P_IncLinking:
		case P_StringPool:
			(void)m_pSlob->GetIntProp(MapLogical(P_Optimize), nVal);
			fValid = !(nVal == 2);
			if (fValid) {
				// ZI forces /Gy and /Gf 
				// Let's disable and use helpid to inform user accordingly
				(void) m_pSlob->GetIntProp(MapLogical(P_DebugInfo), nVal);
				fValid = (nVal != DebugInfoENC);
			}
			break;

		// Precompiled headers mondo enable/disable
		case P_OutputDir_Pch:
		{
			// need /YX, /Yc or /Yu
			(void) m_pSlob->GetIntProp(MapLogical(P_AutoPch), nVal);
			if (!nVal)
			{
				(void) m_pSlob->GetIntProp(MapLogical(P_PchCreate), nVal);
				if (!nVal)
				{
					(void) m_pSlob->GetIntProp(MapLogical(P_PchUse), nVal);
					fValid = nVal;
					break;
				}
			}

			fValid = TRUE;
			break;
		}

		// Don't try to rename a .pdb/.icc directory if we are not generating one
		case P_OutputDir_Pdb:
		{
			// do we have /Zi or /Gi or /FD?
			(void) m_pSlob->GetIntProp(MapLogical(P_DebugInfo), nVal);
			fValid = (nVal >= DebugInfoPdb);
			if (!fValid)
			{
				(void) m_pSlob->GetIntProp(MapLogical(P_Enable_Incr), nVal);
				fValid = !!nVal;
				if (!fValid)
				{
					(void) m_pSlob->GetIntProp(MapLogical(P_Enable_FD), nVal);
					fValid = !!nVal;
				}
			}
			break;
		}

		case P_PchCreateUptoHeader:
		{
			UINT idProp = MapLogical(P_PchCreate);
			if (m_pSlob->GetIntProp(idProp, nVal) != valid)
				nVal = FALSE;
			fValid = nVal && CheckDepOK(idProp);
			break;
		}

		case P_PchUseUptoHeader:
		{
			UINT idProp = MapLogical(P_PchUse);
			if (m_pSlob->GetIntProp(idProp, nVal) != valid)
				nVal = FALSE;
			fValid = nVal && CheckDepOK(idProp);
			break;
		}

		case P_AutoPchUpTo:
		{
			UINT idProp = MapLogical(P_AutoPch);
			if (m_pSlob->GetIntProp(idProp, nVal) != valid)
				nVal = FALSE;
			fValid = nVal && CheckDepOK(idProp);
			break;
		}

		case P_PchCreate:
		case P_PchUse:
		case P_AutoPch:
		{
			UINT idPropC = MapLogical(P_PchCreate);
			UINT idPropU = MapLogical(P_PchUse);
			UINT idPropX = MapLogical(P_AutoPch);

			int nPriCreate = 0, nPriUse = 0, nPriAuto = 0;
			int nVal;

			// figure the precedence of these
			// using a value calc'd below
			// /Yc overrides /Yu overrides /YX

			// set initial priorities (use defaults)
			if (m_pSlob->GetIntProp(idPropC, nVal) == valid && nVal)
				nPriCreate = 3;	// /Yc >> /Yu >> /YX

			else if (m_pSlob->GetIntProp(idPropU, nVal) == valid && nVal)
				nPriUse = 2;	// /Yu >> /YX

			else if (m_pSlob->GetIntProp(idPropX, nVal) == valid && nVal)
				nPriAuto = 1;	// /YX >> (nothing)

			// though per-file /Y? overrides project-level /Y?
			if (m_pSlob->GetContainer() != (CSlob *)NULL)
			{
				OptBehaviour optbeh = ((CProjItem *)m_pSlob)->GetOptBehaviour();

				// turn-off inherit for per-file
				((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh & ~OBInherit);

				// get priorities
				if (m_pSlob->GetIntProp(idPropC, nVal) == valid && nVal)
					nPriCreate += 4;

				else if (m_pSlob->GetIntProp(idPropU, nVal) == valid && nVal)
					nPriUse += 4; 

				else if (m_pSlob->GetIntProp(idPropX, nVal) == valid && nVal)
					nPriAuto += 4; 

				// reset option behaviour
				((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh);
			}

			int nOur, nOther1, nOther2;
			if (idPropL == P_PchCreate)
			{
				nOur = nPriCreate;
				nOther1 = nPriUse; nOther2 = nPriAuto;
			}
			else if (idPropL == P_PchUse)
			{
				nOur = nPriUse;
				nOther1 = nPriCreate; nOther2 = nPriAuto;
			}
			else
			{
				nOur = nPriAuto;
				nOther1 = nPriUse; nOther2 = nPriCreate;
			}

			// valid only if our priority is greater or equal to the others
			fValid = nOur >= nOther1 && nOur >= nOther2;
			break;
		}

		default:
			break;
	}

	return fValid;
}

//----------------------------------------------------------------
// our compiler tool option property pages
//----------------------------------------------------------------

CRuntimeClass * g_cplrTabs[] =
{
	RUNTIME_CLASS(CCompilerGeneralPage),
	RUNTIME_CLASS(CCompilerPchPage),
	RUNTIME_CLASS(CCompilerOptimizePage),
	RUNTIME_CLASS(CCompilerCustomPage),
	RUNTIME_CLASS(CCompilerCustomCppPage),
	RUNTIME_CLASS(CCompilerPreprocessPage),
	RUNTIME_CLASS(CCompilerListfilePage),
	(CRuntimeClass *)NULL,
};

// our listbox entries

DEFINE_LOCALIZED_ENUM(WarnLevelEnum)
	LOCALIZED_ENUM_ENTRY(IDS_WarnLevel0 /*"None"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_WarnLevel1 /*"Level 1 *"*/, 2)
	LOCALIZED_ENUM_ENTRY(IDS_WarnLevel2 /*"Level 2"*/, 3)
	LOCALIZED_ENUM_ENTRY(IDS_WarnLevel3 /*"Level 3"*/, 4)
	LOCALIZED_ENUM_ENTRY(IDS_WarnLevel4 /*"Level 4"*/, 5)
END_LOCALIZED_ENUM_LIST()

DEFINE_LOCALIZED_ENUM(OptimizeEnum)
	LOCALIZED_ENUM_ENTRY(IDS_Optimize0 /*"Default"*/, 0)
	LOCALIZED_ENUM_ENTRY(IDS_Optimize1 /*"Disable (Debug)"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_Optimize2 /*"Maximize Speed"*/, 2)
	LOCALIZED_ENUM_ENTRY(IDS_Optimize3 /*"Minimize Size"*/, 3)
	LOCALIZED_ENUM_ENTRY(IDS_Optimize4 /*"Customize"*/, 4)
END_LOCALIZED_ENUM_LIST()

class CDebugInfoEnum : public CLocalizedEnum
{
public:
	CDebugInfoEnum() {dwAllowDbgFilter = 
		DbgNone | DbgLine | DbgC7 | DbgPdb | DbgENC;}

	virtual CLocalizedEnumerator* GetListL() {return &c_list[0];}
	virtual POSITION GetHeadPosition()
	{
		POSITION pos = CLocalizedEnum::GetHeadPosition(), posT;
		CLocalizedEnumerator * pEnum;																			  	
		posT = pos;
		while (!AllowEnum(posT, pEnum)) {pos = posT;}
		return pos;
	}

	virtual CLocalizedEnumerator* GetNextL(POSITION& pos)
	{
		CLocalizedEnumerator * pEnum, * pEnumT;
		pEnum = CLocalizedEnum::GetNextL(pos);

		POSITION posT = pos;
		// skip ones we don't recognise
 		while (!AllowEnum(posT, pEnumT)) {pos = posT;}
		return pEnum;
	}

	typedef enum {
		DbgNone	= 0x00000001, 
		DbgLine	= 0x00000002, 
		DbgC7	= 0x00000004,
		DbgPdb	= 0x00000008,
		DbgENC	= 0x00000010
	} AllowInc;

	BOOL AllowEnum(POSITION & pos, CLocalizedEnumerator * & pEnum);
	__inline void AllowDbg(DWORD dwAllow) {dwAllowDbgFilter = dwAllow;}

	static CLocalizedEnumerator c_list[];

private:
	DWORD dwAllowDbgFilter;
};

BOOL CDebugInfoEnum::AllowEnum(POSITION & pos, CLocalizedEnumerator * & pEnum)
{
	if (pos == (POSITION)NULL)	return TRUE;
	pEnum = CLocalizedEnum::GetNextL(pos);
	return ((pEnum->val == DebugInfoNone && (dwAllowDbgFilter & DbgNone) != 0) ||
			(pEnum->val == DebugInfoLine && (dwAllowDbgFilter & DbgLine) != 0) ||
			(pEnum->val == DebugInfoC7 && (dwAllowDbgFilter & DbgC7) != 0) ||
			(pEnum->val == DebugInfoPdb && (dwAllowDbgFilter & DbgPdb) != 0) ||
			(pEnum->val == DebugInfoENC && (dwAllowDbgFilter & DbgENC) != 0)
		   );	// filter
}

CDebugInfoEnum DebugInfoEnum;

BEGIN_LOCALIZED_ENUM_LIST(CDebugInfoEnum)
	LOCALIZED_ENUM_ENTRY(IDS_DebugInfo0 /*"None"*/, DebugInfoNone)
	LOCALIZED_ENUM_ENTRY(IDS_DebugInfo1 /*"Line Numbers Only"*/, DebugInfoLine)
	LOCALIZED_ENUM_ENTRY(IDS_DebugInfo2 /*"C7 Compatible"*/, DebugInfoC7)
	LOCALIZED_ENUM_ENTRY(IDS_DebugInfo3 /*"Program Database"*/, DebugInfoPdb)
	LOCALIZED_ENUM_ENTRY(IDS_DebugInfo4 /*"PDB - Edit & Continue"*/, DebugInfoENC)
END_LOCALIZED_ENUM_LIST()

DEFINE_LOCALIZED_ENUM(ListAsmEnum)
	LOCALIZED_ENUM_ENTRY(IDS_ListAsm0 /*"No Listing"*/, 0)
	LOCALIZED_ENUM_ENTRY(IDS_ListAsm1 /*"Assembly-Only Listing"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_ListAsm2 /*"Assembly, Machine Code, and Source"*/, 2)
	LOCALIZED_ENUM_ENTRY(IDS_ListAsm3 /*"Assembly with Machine Code"*/, 3)
	LOCALIZED_ENUM_ENTRY(IDS_ListAsm4 /*"Assembly with Source Code"*/, 4)
END_LOCALIZED_ENUM_LIST()

DEFINE_LOCALIZED_ENUM(InlineEnum)
	LOCALIZED_ENUM_ENTRY(IDS_Inline0 /*"Disable *"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_Inline1 /*"Only __inline"*/, 2)
	LOCALIZED_ENUM_ENTRY(IDS_Inline2 /*"Any Suitable"*/, 3)
END_LOCALIZED_ENUM_LIST()

DEFINE_LOCALIZED_ENUM(OptimizeOptEnum)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt0 /*"Assume No Aliasing"*/, P_Optimize_A)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt1 /*"Assume Aliasing Across Function Calls"*/, P_Optimize_W)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt2 /*"Global Optimizations"*/, P_Optimize_G)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt3 /*"Generate Intrinsic Functions"*/, P_Optimize_I)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt4 /*"Improve Float Consistency"*/, P_Optimize_P)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt5 /*"Favor Small Code"*/, P_Optimize_S)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt6 /*"Favor Fast Code"*/, P_Optimize_T)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt7 /*"Frame-Pointer Omission"*/, P_Optimize_Y)
	LOCALIZED_ENUM_ENTRY(IDS_OptimizeOpt8 /*"Full Optimization"*/, P_Optimize_X)
END_LOCALIZED_ENUM_LIST()

DEFINE_LOCALIZED_ENUM(PtrMbr1Enum)
	LOCALIZED_ENUM_ENTRY(IDS_PtrMbr10 /*"Best-Case Always *"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_PtrMbr11 /*"General-Purpose Always"*/, 2)
END_LOCALIZED_ENUM_LIST()

DEFINE_LOCALIZED_ENUM(PtrMbr2Enum)
	LOCALIZED_ENUM_ENTRY(IDS_PtrMbr20 /*"Point to Any Class *"*/, 1)
	LOCALIZED_ENUM_ENTRY(IDS_PtrMbr21 /*"Point to Single- and Multiple-Inheritance Classes"*/, 3)
	LOCALIZED_ENUM_ENTRY(IDS_PtrMbr22 /*"Point to Single-Inheritance Classes"*/, 2)
END_LOCALIZED_ENUM_LIST()


// N.B. we don't call the base-class Validate()
// 'cos IDC_OPTSTR is no in the control map, we are 'faking'
// control validation by setting explicitly m_nValidateID and
// PostMessage(WM_VALIDATE_REQ) in the base-class
BOOL CCompilerPageTab::Validate()
{
	if (m_nValidateID == IDC_OPTSTR)
	{
		ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
		
		int fExcludeLocals = FALSE;
		// we need to map through the root option handler
		m_pSlob->GetIntProp(m_popthdlr->GetRootOptionHandler()->MapLogical(P_GenBrowserInfoNoLcl),
						    fExcludeLocals); 
							 
		return Validate_DestinationProp(P_OutputDir_Sbr, fExcludeLocals ? IDOPT_LISTBSCNOLCL :IDOPT_LISTBSC,
										IDC_OPTSTR, IDS_DEST_SBR,
									    "sbr",										// must be extension
									    ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject)) ||
									    ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProjGroup)),	// must be directory
									    FALSE);										// cant be directory
	}
	else if(IDC_INCLUDE==m_nValidateID)
	{
		//
		// Strip quotes.
		//
		CString strOption;
		CWnd * pWnd = GetDlgItem(m_nValidateID);
		ASSERT(pWnd != (CWnd *)NULL);
		pWnd->GetWindowText(strOption);

		int index;

		while (-1 != (index=strOption.Find('"')) )
		{
			CString Left;
			CString Right;

			if (0!=index)
				Left = strOption.Left(index);

			if (index+1 < strOption.GetLength())
				Right = strOption.Mid(index+1);

			strOption = Left + Right;
		}

		pWnd->SetWindowText(strOption);
	}

	return COptionMiniPage::Validate();
}


BOOL IsLearningBox();

void CCompilerGeneralPage::InitPage(void)
{
	// Check what kind of debug info is allowed by platform
	CPlatform * pPlatform = ((CProjItem *)m_pSlob)->GetProject()->GetCurrentPlatform();
	DWORD dwAttrib = pPlatform->GetAttributes();
	BOOL fEnc = dwAttrib & PIA_Supports_ENC;
	DebugInfoEnum.AllowDbg(
		CDebugInfoEnum::DbgNone |
		CDebugInfoEnum::DbgLine |
		CDebugInfoEnum::DbgC7 |
		CDebugInfoEnum::DbgPdb |
		(fEnc  ? CDebugInfoEnum::DbgENC : 0)
		);

	CCompilerPageTab::InitPage();
}

BOOL CCompilerGeneralPage::OnPropChange(UINT idProp)
{
	if( IsLearningBox() )
	{
		GetDlgItem(IDC_OPTIMIZE)->EnableWindow(FALSE);
	}
	// call our base-class
	return CCompilerPageTab::OnPropChange(idProp);
}



BEGIN_IDE_CONTROL_MAP(CCompilerGeneralPage, IDDP_PROJ_COMPILER, IDS_COMPILER32)
	MAP_COMBO_LIST(IDC_OPTWARN, P_WarningLevel, WarnLevelEnum)
	MAP_CHECK(IDC_WARNASERR, P_WarnAsError)
	MAP_CHECK(IDC_LISTBSC, P_GenBrowserInfo)
	MAP_COMBO_LIST(IDC_OPTIMIZE, P_Optimize, OptimizeEnum)
	MAP_COMBO_LIST(IDC_DEBUG, P_DebugInfo, DebugInfoEnum)
	MAP_EDIT(IDC_MACROS, P_MacroNames)
END_IDE_CONTROL_MAP()


BEGIN_IDE_CONTROL_MAP(CCompilerCustomPage, IDDP_COMPILER_CUSTOM, IDS_CAT_CUSTOM)
	MAP_CHECK(IDC_OPTEXT, P_MSExtension)
	MAP_CHECK(IDC_OPTINCLINK, P_IncLinking)
	MAP_CHECK(IDC_STRPOOL, P_StringPool)
	MAP_CHECK(IDC_CPLRNOLOGO, P_CplrNoLogo)
	MAP_CHECK(IDC_ENABLE_GI, P_Enable_Incr)
	MAP_CHECK(IDC_ENABLE_MR, P_Enable_MR)
END_IDE_CONTROL_MAP()

BOOL CCompilerCustomPage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	// we want to enable/disable prop page items
	// - we'll enable/disable the static text
	// - OnPropChange() will enable/disable the rest
	switch (idPropL)
	{
		case P_Optimize:
			// O1, O2 alter the default for /Gf and /Gy
			CCompilerPageTab::OnPropChange(MapLogical(P_StringPool));
			CCompilerPageTab::OnPropChange(MapLogical(P_IncLinking));
			break;

		case P_Enable_Incr:
		case P_DebugInfo:
			// /Zi and /Gi alter /Gm
			CCompilerPageTab::OnPropChange(MapLogical(P_Enable_MR));
			break;

		default:
			break;
	}

	// call our base-class
	return CCompilerPageTab::OnPropChange(idProp);
}

BEGIN_IDE_CONTROL_MAP(CCompilerCustomCppPage, IDDP_COMPILER_CUSTOMCPP, IDS_CAT_CUSTOMCPP)
	MAP_COMBO_LIST(IDC_PTRMBR1, P_PtrMbr1, PtrMbr1Enum)
	MAP_COMBO_LIST(IDC_PTRMBR2, P_PtrMbr2, PtrMbr2Enum)
	MAP_CHECK(IDC_VTORDISP, P_VtorDisp)
/* temporarily reverse the logic for PDC (BamBam) 'cos the compiler default will be /GX- for this
** release .. ie. we need [X] Enable EH in the options dialog
	MAP_CHECK(IDC_DISABLE_EH, P_Disable_EH)
*/
	MAP_CHECK(IDC_ENABLE_EH, P_Enable_EH)
	MAP_CHECK(IDC_ENABLE_RTTI, P_Enable_RTTI)
END_IDE_CONTROL_MAP()

BOOL CCompilerCustomCppPage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	// we want to enable/disable prop page items
	// - we'll enable/disable the static text
	// - OnPropChange() will enable/disable the rest
	switch (idPropL)
	{
		case P_PtrMbr1:
		{
			int nVal;

			CCompilerPageTab::OnPropChange(MapLogical(P_PtrMbr2));

			GetDlgItem(IDC_TXT_PTRMBR2)->EnableWindow(m_pSlob->GetIntProp(MapLogical(P_PtrMbr2), nVal) != invalid);
			break;
		}

		default:
			break;
	}

	// call our base-class
	return CCompilerPageTab::OnPropChange(idProp);
}


BEGIN_IDE_CONTROL_MAP(CCompilerListfilePage, IDDP_COMPILER_LISTFILE, IDS_CAT_LISTFILE)
	MAP_CHECK(IDC_LISTBSC, P_GenBrowserInfo)
	MAP_CHECK(IDC_LISTLOCAL, P_GenBrowserInfoNoLcl)
	MAP_COMBO_LIST(IDC_LISTASM, P_ListAsm, ListAsmEnum)
	MAP_EDIT(IDC_LISTBSC_NME, P_OutputDir_Sbr)
	MAP_EDIT(IDC_LISTASM_NME, P_OutputDir_Cod)
END_IDE_CONTROL_MAP()

BOOL CCompilerListfilePage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fOldRefresh = m_pToolOptionTab->m_fRefresh;
	CString strVal;

	// we want to enable/disable prop page items
	// - we'll enable/disable the static text
	// - OnPropChange() will enable/disable the rest
	switch (idPropL)
	{
		case P_GenBrowserInfo:
		{
			// batch up these and then refresh on last one!
			m_pToolOptionTab->m_fRefresh = FALSE;
			CCompilerPageTab::OnPropChange(MapLogical(P_GenBrowserInfoNoLcl));
			m_pToolOptionTab->m_fRefresh = fOldRefresh;
			CCompilerPageTab::OnPropChange(MapLogical(P_OutputDir_Sbr));

			GetDlgItem(IDC_TXT_LISTBSC)->EnableWindow(m_pSlob->GetStrProp(MapLogical(P_OutputDir_Sbr), strVal) != invalid);
			break;
		}

		case P_ListAsm:
		{
			CCompilerPageTab::OnPropChange(MapLogical(P_OutputDir_Cod));

			GetDlgItem(IDC_TXT_LISTASM1)->EnableWindow(m_pSlob->GetStrProp(MapLogical(P_OutputDir_Cod), strVal) != invalid);
			break;
		}

		default:
			break;
	}

	// call our base-class
	return CCompilerPageTab::OnPropChange(idProp);
}

BOOL CCompilerListfilePage::Validate()
{
	if (m_nValidateID == IDC_LISTBSC_NME)
	{
		ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));

		if (!Validate_Destination(IDC_LISTBSC_NME, IDS_DEST_SBR,
								  "sbr",										// must be extension
							 	  ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProject)) ||
							 	  ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CProjGroup)),	// must be directory
							 	  FALSE))										// cant be directory
			return FALSE;
	}

	return CCompilerPageTab::Validate();
}


BEGIN_IDE_CONTROL_MAP(CCompilerPreprocessPage, IDDP_COMPILER_PREPROCESS, IDS_CAT_PREPROCESS)
	MAP_EDIT(IDC_MACROS, P_MacroNames)
	MAP_EDIT(IDC_UNDEFS, P_UndefMacros)
	MAP_CHECK(IDC_UNDEFINE, P_Undefine)
	MAP_EDIT(IDC_INCLUDE, P_CplrIncludes)
	MAP_CHECK(IDC_IGNINC, P_CplrIgnIncPath)
END_IDE_CONTROL_MAP()


BEGIN_IDE_CONTROL_MAP(CCompilerDebugOptPage, IDDP_COMPILER_DEBUG, IDS_CAT_DEBUGOPT)
	MAP_COMBO_LIST(IDC_DEBUG, P_DebugInfo, DebugInfoEnum)
END_IDE_CONTROL_MAP()


BEGIN_IDE_CONTROL_MAP(CCompilerPchPage, IDDP_COMPILER_PCH, IDS_CAT_PCH)
	MAP_RADIO(IDC_NOPCH, IDC_USEPCH, 1, P_PseudoPch)
	MAP_EDIT(IDC_AUTOPCHNAME, P_AutoPchUpTo)
	MAP_EDIT(IDC_CREATENAME, P_PchCreateUptoHeader)
	MAP_EDIT(IDC_USENAME, P_PchUseUptoHeader)
END_IDE_CONTROL_MAP()

BOOL CCompilerPchPage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fOldRefresh = m_pToolOptionTab->m_fRefresh;
	int nVal;

	// we want to enable/disable prop page items
	// - we'll enable/disable the static text
	// - OnPropChange() will enable/disable the rest
	switch (idPropL)
	{
		case P_PseudoPch:
		{
			if (m_pSlob->GetIntProp(idProp, nVal) != valid)
				nVal = 1;	// no selection

			m_pToolOptionTab->m_fRefresh = FALSE;

			// enable/disable text
			GetDlgItem(IDC_TXT_AUTOPCH)->EnableWindow(nVal == 2);
			GetDlgItem(IDC_TXT_CREATE)->EnableWindow(nVal == 3);
			GetDlgItem(IDC_TXT_USE)->EnableWindow(nVal == 4);

			CCompilerPageTab::OnPropChange(MapLogical(P_AutoPchUpTo));
			CCompilerPageTab::OnPropChange(MapLogical(P_PchCreateUptoHeader));

			m_pToolOptionTab->m_fRefresh = fOldRefresh;

			CCompilerPageTab::OnPropChange(MapLogical(P_PchUseUptoHeader));
		}

		default:
			break;
	}

	// call our base-class
	return CCompilerPageTab::OnPropChange(idProp);
}


BEGIN_IDE_CONTROL_MAP(CCompilerOptimizePage, IDDP_COMPILER_OPTIMIZE, IDS_CAT_OPTIMIZE)
	MAP_CHECK_LIST(IDC_OPTIMIZE, OptimizeOptEnum)
	MAP_COMBO_LIST(IDC_OPTIMIZE2, P_Optimize, OptimizeEnum)
	MAP_COMBO_LIST(IDC_INLINECTRL, P_InlineControl, InlineEnum)
END_IDE_CONTROL_MAP()


BOOL CCompilerOptimizePage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fOldRefresh = m_pToolOptionTab->m_fRefresh;
	if( IsLearningBox() )
	{
		GetDlgItem(IDC_OPTIMIZE2)->EnableWindow(FALSE);
		GetDlgItem(IDC_INLINECTRL)->EnableWindow(FALSE);
	}

	// we want to enable/disable prop page items
	// - we'll enable/disable the static text
	// - OnPropChange() will enable/disable the rest
	switch (idPropL)
	{
		case P_MSExtension:
			// Za alters default for /Op
			CCompilerPageTab::OnPropChange(MapLogical(P_Optimize_P));
			break;
		
		case P_Optimize_X:
			// Ox alters default for /Ob
			CCompilerPageTab::OnPropChange(MapLogical(P_InlineControl));

			// Ox alters default for /Oy
			CCompilerPageTab::OnPropChange(MapLogical(P_Optimize_Y));
			break;

		case P_Optimize:
		{
			// O1, /O2 alter default for /Ob
			CCompilerPageTab::OnPropChange(MapLogical(P_InlineControl));

			// Ox alters default for /Oy
			CCompilerPageTab::OnPropChange(MapLogical(P_Optimize_Y));

			// we'll use Optimize_A to determine the availability of the optimize check-list
			// make sure we update our text view of the options
			CCompilerPageTab::OnPropChange(MapLogical(P_Optimize_A));

			// they are collectively updated, bypass OnPropChange() for efficiency reasons
			GetDlgItem(IDC_OPTIMIZE)->Invalidate(FALSE);

			// they are collectively enabled/disabled
			int nVal;
			GetDlgItem(IDC_OPTIMIZE)->EnableWindow(m_pSlob->GetIntProp(MapLogical(P_Optimize_A), nVal) != invalid);
			break;
		}

		default:
			break;
	}

	// call our base-class
	return CCompilerPageTab::OnPropChange(idProp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optncplr.h ===
//
// Common Compiler Tool Options
//
// [matthewt]
//

#ifndef _INCLUDE_OPTNCPLR_CMN_H
#define _INCLUDE_OPTNCPLR_CMN_H

#include "projprop.h"	// our option property ids
#include "prjoptn.h"	// macros used to decl/defn our tables

//----------------------------------------------------------------
// our compiler tool option property pages
//----------------------------------------------------------------

class BLD_IFACE CCompilerPageTab : public COptionMiniPage
{
	DECLARE_DYNCREATE(CCompilerPageTab)
public:
	virtual BOOL Validate();
};

//----------------------------------------------------------------
// our 'General' option property page
//----------------------------------------------------------------

class CCompilerGeneralPage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerGeneralPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	virtual void InitPage();
	virtual BOOL OnPropChange(UINT);
};

//----------------------------------------------------------------
// our option property pages
//----------------------------------------------------------------

extern CRuntimeClass * g_cplrTabs[];

//----------------------------------------------------------------
// our COMMON compiler option data
//----------------------------------------------------------------

// COMMON compiler option handler
DEFN_OPTHDLR_COMMON
(
	CompilerCommon, /* name */
	szAddOnGeneric,	BCID_OptHdlr_Compiler, /* generic compiler option handler */
	szAddOnGeneric, BCID_Tool_Compiler /* generic compiler tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option pages
	virtual UINT GetNameID() {return IDS_COMPILER32;}
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_cplrTabs;}

	// should this be shown always?
	virtual BOOL AlwaysShowDefault(UINT idProp);

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);
	virtual BOOL SetsFakePropValue(UINT idProp);

 	// return a 'fake' string prop
	virtual GPT GetDefStrProp(UINT idProp, CString & val);
	virtual GPT GetDefIntProp(UINT idProp, int & val);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// handle setting of option int props
	virtual void OnOptionIntPropChange(UINT idProp, int nVal);
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal);

	// provide invalidation of option props
	virtual BOOL CheckDepOK(UINT idProp);

	int GetTabDlgOrder()
		{ return 30; }

private:
	// form a 'fake' string prop
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);

	// form a 'fake' integer prop
	virtual void FormFakeIntProp(UINT idProp, int & nVal);

END_OPTHDLR()

// COMMON compiler tool properties
#define P_CplrNoLogo 					0x0000
#define P_MSExtension				   	0x0001
#define P_IncLinking			   		0x0002
#define P_WarningLevel					0x0003
#define P_WarnAsError					0x0004
#define P_StringPool					0x0005
#define P_PtrMbr1						0x0006
#define P_PtrMbr2						0x0007
#define P_VtorDisp						0x0008
#define P_DebugInfo						0x0009
#define P_AutoPch						0x000a
#define P_AutoPchUpTo					0x000b
#define P_Optimize						0x000c
#define P_Optimize_A					0x000d
#define P_Optimize_W					0x000e
#define P_Optimize_G					0x000f
#define P_Optimize_I					0x0010
#define P_Optimize_P					0x0011
#define P_Optimize_T					0x0012
#define P_Optimize_S					0x0013
#define P_Optimize_Y					0x0014
#define P_Optimize_X					0x0015
#define P_InlineControl					0x0016
#define P_CplrIgnIncPath				0x0017
#define P_Undefine						0x0018
#define P_ListAsm						0x0019
#define P_AsmListHasMC					0x001a
#define P_AsmListHasSrc					0x001b
#define P_GenBrowserInfo				0x001c
#define P_MacroNames					0x001d
// 0x001e - Add P_MacroNames
// 0x001f - Subtract P_MacroNames
#define P_MacroValues					0x0020
// 0x0021 - Add P_MacroValues
// 0x0022 - Subtract P_MacroValues
#define P_UndefMacros					0x0023
// 0x0024 - Add P_UndefMacros
// 0x0025 - Subtract P_UndefMacros
#define P_CplrIncludes					0x0026
// 0x0027 - Add P_CplrIncludes
// 0x0028 - Subtract P_CplrIncludes
#define P_TreatFileAsC					0x0029
#define P_TreatFileAsCPP				0x002a
#define P_PchCreate						0x002b
#define P_PchCreateUptoHeader			0x002c
#define P_PchUse						0x002d
#define P_PchUseUptoHeader				0x002e
#define P_OutputDir_Obj					0x002f
#define P_OutputDir_Pch					0x0030
#define P_OutputDir_Sbr					0x0031
#define P_OutputDir_Pdb					0x0032
#define P_CompileOnly					0x0033
#define P_CplrUnknownOption				0x0034
#define P_CplrUnknownString				0x0035
#define P_PchDefaultName				0x0036
#define P_PdbDefaultName				0x0037
#define P_GenBrowserInfoNoLcl			0x0038
/* temporarily reverse the logic for PDC (BamBam) 'cos the compiler default will be /GX- for this
** release .. ie. we need [X] Enable EH in the options dialog
#define P_Disable_EH					0x0039
*/
#define P_Enable_EH						0x003a
#define P_OutputDir_Cod					0x003b
#define P_StackProbe					0x003c
#define P_StackProbeTHold				0x003d
#define P_MaxLenExtNames				0x003e
#define P_UseChasAsUnsigned				0x003f
#define P_EmbedString					0x0040
#define P_TurnOffWarnings				0x0041 
#define P_NoDefLibNameInObj				0x0042
#define P_PrepPreserveComments			0x0043
#define P_Preprocess					0x0044
#define P_PreprocessWOLines				0x0045
#define P_StackSize						0x0046
#define P_PrepprocessToFile				0x0047
#define P_GenFuncProto					0x0048
#define P_ForceIncludes					0x0049
// 0x004a - Add P_ForceIncludes
// 0x004b - Subtract P_ForceIncludes
#define P_CheckSyntax					0x004c
#define P_Enable_MR						0x004d
#define P_Enable_Incr					0x004e
#define P_Enable_RTTI					0x004f
#define P_PseudoPch						0x0050
#define P_Enable_FD						0x0051
#define P_Enable_FC						0x0052
#define P_Enable_dlp					0x0053

// Debug information constants
#define DebugInfoNone					0
#define DebugInfoLine					1
#define DebugInfoC7						2
// WARNING: DebugInfo constants greater than or
// equal to DebugInfoPdb assume the existence
// of a program database
#define DebugInfoPdb					3
#define DebugInfoENC					4

// COMMON compiler tool options (option ids)
#define IDOPT_CPLRNOLOGO				IDOPT_BASE + 0							
#define IDOPT_MSEXT						IDOPT_BASE + 4
#define IDOPT_INCLINK					IDOPT_BASE + 5
#define IDOPT_WARN						IDOPT_BASE + 6
#define IDOPT_WARNASERROR				IDOPT_BASE + 7
#define IDOPT_STRPOOL					IDOPT_BASE + 8
#define IDOPT_PTRMBR1					IDOPT_BASE + 9
#define IDOPT_PTRMBR2					IDOPT_BASE + 10
#define IDOPT_VTORDISP					IDOPT_BASE + 11
#define IDOPT_DEBUGINFO					IDOPT_BASE + 12
#define IDOPT_AUTOPCH					IDOPT_BASE + 13
#define IDOPT_OPTIMIZE					IDOPT_BASE + 14
#define IDOPT_OPT_A						IDOPT_BASE + 15
#define IDOPT_OPT_W						IDOPT_BASE + 16
#define IDOPT_OPT_G						IDOPT_BASE + 17
#define IDOPT_OPT_I						IDOPT_BASE + 18
#define IDOPT_OPT_P						IDOPT_BASE + 19
#define IDOPT_OPT_T						IDOPT_BASE + 20
#define IDOPT_OPT_S						IDOPT_BASE + 21
#define IDOPT_OPT_Y						IDOPT_BASE + 22
#define IDOPT_OPT_X						IDOPT_BASE + 23
#define IDOPT_INLINECTRL				IDOPT_BASE + 24
#define IDOPT_CPLRIGNINC				IDOPT_BASE + 25
#define IDOPT_UNDEFINE					IDOPT_BASE + 26
#define IDOPT_LISTASM					IDOPT_BASE + 27
#define IDOPT_LISTBSC					IDOPT_BASE + 28
#define IDOPT_MACROS					IDOPT_BASE + 31
#define IDOPT_UNDEFMACROS				IDOPT_BASE + 32
#define IDOPT_CPLRINCLUDES				IDOPT_BASE + 33
#define IDOPT_TREATFILEAS_C				IDOPT_BASE + 34
#define IDOPT_TREATFILEAS_CPP			IDOPT_BASE + 35
#define IDOPT_PCHNAME					IDOPT_BASE + 36
#define IDOPT_PCHCREATE					IDOPT_BASE + 37
#define IDOPT_PCHUSE					IDOPT_BASE + 38
#define IDOPT_OUTDIR_OBJ				IDOPT_BASE + 39
#define IDOPT_OUTDIR_PDB				IDOPT_BASE + 40
#define IDOPT_COMPILE_ONLY				IDOPT_BASE + 41
#define IDOPT_LISTBSCNOLCL				IDOPT_BASE + 42
/* temporarily reverse the logic for PDC (BamBam) 'cos the compiler default will be /GX- for this
** release .. ie. we need [X] Enable EH in the options dialog
#define IDOPT_DISABLE_EH				IDOPT_BASE + 43
*/
#define IDOPT_ENABLE_EH					IDOPT_BASE + 43
#define IDOPT_OUTDIR_COD				IDOPT_BASE + 44
#define IDOPT_STACK_PROBE				IDOPT_BASE + 45
#define IDOPT_STACK_PROBE_THOLD			IDOPT_BASE + 46
#define IDOPT_MAXLEN_EXTNAME			IDOPT_BASE + 47
#define IDOPT_USECHAR_AS_UNSIGNED		IDOPT_BASE + 48
#define IDOPT_EMBED_STRING				IDOPT_BASE + 49
#define IDOPT_TURN_OFF_WARNINGS			IDOPT_BASE + 50
#define IDOPT_NO_DEFLIB_NAME			IDOPT_BASE + 51
#define IDOPT_PREP_COMMENTS				IDOPT_BASE + 52
#define IDOPT_PREPROCESS				IDOPT_BASE + 53
#define IDOPT_PREPROCESS_WO_LINES		IDOPT_BASE + 54
#define IDOPT_STACKSIZE					IDOPT_BASE + 55
#define IDOPT_PREPROCESS_TO_FILE		IDOPT_BASE + 56
#define IDOPT_GEN_FUNC_PROTO			IDOPT_BASE + 57
#define IDOPT_FORCEINCLUDES				IDOPT_BASE + 58
#define IDOPT_CHECK_SYNTAX				IDOPT_BASE + 59
#define IDOPT_ENABLE_MR					IDOPT_BASE + 60
#define IDOPT_ENABLE_INCR				IDOPT_BASE + 61
#define IDOPT_ENABLE_RTTI				IDOPT_BASE + 62
#define IDOPT_ENABLE_FD					IDOPT_BASE + 63
#define IDOPT_ENABLE_FC					IDOPT_BASE + 64
#define IDOPT_ENABLE_DLP				IDOPT_BASE + 65

#include "optncplr.h2"	// our option control IDs

//
// compiler tool 'Advanced' option tabs
//

class CCompilerCustomPage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerCustomPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
};

class CCompilerCustomCppPage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerCustomCppPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
};

class CCompilerListfilePage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerListfilePage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
	virtual BOOL Validate();
};

class CCompilerPreprocessPage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerPreprocessPage)
	DECLARE_IDE_CONTROL_MAP()
};

class CCompilerOptimizePage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerOptimizePage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
};

class CCompilerDebugOptPage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerDebugOptPage)
	DECLARE_IDE_CONTROL_MAP()
};

class CCompilerPchPage : public CCompilerPageTab
{
	DECLARE_DYNCREATE(CCompilerPchPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
};

#endif // _INCLUDE_OPTNCPLR_CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optndlg.h ===
//
// CProjOptionsDlg
//
// Project Options 'mondo' dialog for setting options
// across one or more targets, and none or more files
// in those targets.
//
// [matthewt]
//				   

#ifndef _INCLUDE_OPTIONDLG_H										
#define _INCLUDE_OPTIONDLG_H

#ifndef _SUSHI_PROJECT
// If you are including this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

#include "resource.h"	// for the resource IDs
#include "prjoptn.h"	// our CProxySlob etc.
#include "project.h"	// ConfigurationRecord, CProjItem
#include <utilctrl.h>    // tree control
#include <dlgbase.h>	// C3dDialog

// testing hooks to allow a client
// to select items in the project tree control in
// this dialog using a SendMessage where
// WPARAM = type of node to select (enum)
// LPARAM = title of node to select (string atom)
// n.b. the selection is within the oontext
// of the current selection,
// ie. SendMessage(hwnd, WM_SELECT_ITEM, PRJW_FILE, 'foo.c')
// will select foo.c in the currently selected group.
#define WM_SELECT_ITEM	(WM_USER + 0)
#define PRJW_TARGET	0 
#define PRJW_GROUP	1
#define PRJW_FILE	2

class CNodeState
{
public:
	CNodeState() {}
	CNodeState(TCHAR * pchTitle, int nLevel, BOOL fExpanded, BOOL fSelected)
	{
		m_str = pchTitle; m_nLevel = nLevel;
		m_fExpanded = fExpanded; m_fSelected = fSelected;
	}

	CString m_str;
	int m_nLevel;
	BOOL m_fExpanded;
	BOOL m_fSelected;
};

class COptionTreeStore
{
public:
	COptionTreeStore() {};
	~COptionTreeStore() {Clear();}

	// clear the state (destroy the node states)
	void Clear();
	BOOL Serialize(CArchive & ar);
	BOOL Deserialize(CArchive & ar);

	CPtrList m_lstStates;
};

class COptionTreeCtl : public CTreeCtl
{
friend class CProject;

	DECLARE_DYNCREATE(COptionTreeCtl)
	DECLARE_MESSAGE_MAP()

public:
	// our default CTOR
	COptionTreeCtl() : CTreeCtl(TRUE, TRUE)
	{
		// cache a pointer to the current project
		m_pProject = g_pActiveProject; ASSERT(m_pProject != (CProject *)NULL);
		m_fIgnoreSelChange = FALSE; m_rgLastGoodSel = (int *)NULL;
	}

	// our default DTOR
	virtual ~COptionTreeCtl()
	{
		if (m_rgLastGoodSel != (int *)NULL)	delete [] m_rgLastGoodSel;
	}

	// our creation method (this overrides the super-class)
	BOOL Create(CWnd *pParentWnd, CRect rect);

	// process any messages before the tabbed-dialog if we have the focus
	// eg. VK_KEYDOWN should expand/contract the current selection, and
	// not invoke the default button command
 	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// retrieve/save our state
	void RetrieveTreeLevel(POSITION & pos, int iBaseIndex, int iBaseLevel);
	void RetrieveTreeState();
	void SaveTreeState();

	// is this CProjItem valid for display in the options tree-control?
	BOOL IsValidOptTreeItem(CProjItem * pItem, CString & strItemName);

	// a project item's appearance in the 'view' has changed
	__inline BOOL InterestedInPropChange(UINT uHint, CProjItem * pProjItem) {return uHint == P_ItemExcludedFromBuild || uHint == P_TargetName || uHint == P_ItemIgnoreDefaultTool || uHint == P_ItemTools;}
	void ProjItemChanged(CSlob * pProjItem, UINT uHint);

	// refresh so that the tree control shows the 
	// targets in the currently active project as root nodes
	// (can copy the state of another tree N.B. nodes must be identical)
	int InsertTargetNode(CProject * pProject, const TCHAR * szTarget);
	void RefreshTargetNodes();
#if 1
	void CopyTreeCtlState(CSlob * pSelection = NULL);
#else
	void CopyTreeCtlState(CTreeCtl * pTreeCtlToCopy = NULL);
#endif

	void FreeTargetNode(OptTreeNode *);		// free up a particular target node (plus children)
	void FreeAllOptTreeNodes();				// free-up the memory used by all OptTreeNodes

	// Find a node in the settings tree that corresponds to a particular
	// item in the real project tree
	int FindTargetNode(const CString& strTargetName);

	__inline BOOL HasFocus()
	{
		CWnd * pWndFocus = GetFocus();
		return pWndFocus != (CWnd *)NULL && GetListBox()->m_hWnd == pWndFocus->m_hWnd;  
	}

	// tree-state retrieval/store from an archive
	BOOL m_fDoStateStore;
	__inline static BOOL LoadOptTreeStore(CArchive & archive) {return sm_TreeState.Deserialize(archive);}
	__inline static BOOL SaveOptTreeStore(CArchive & archive) {return sm_TreeState.Serialize(archive);}

	// save/restore the tree-control state to memory
	void RememberSel();	// restore
	void NoteSel();		// save

protected:
	//{{AFX_MSG(COptionTreeCtl)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnDestroy();
	afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);
	//}}AFX_MSG
	afx_msg void OnLbSetFocus();
	afx_msg void OnLbKillFocus();
	afx_msg void OnLbSelChange();
	BOOL m_fIgnoreSelChange;				// ignore the selection change?
	int * m_rgLastGoodSel;					// last known good multiple selection
	int m_cLastGoodSel;						// # in this selection

	void GetTreeCtlSelection(CTreeCtl * pTreeCtl, INT * & rgInt, int & nSelItems);
	
	BOOL NodeIsExpandable(CNode *);			// is this a container node?
	void GetNodeTitle(CNode *, CString &);	// get the title text for this node
	void GetDisplayText(CNode *, CString &);// get the display text for this node
	BOOL InsertLevel(CNode *, int, BOOL);	// impl. of the retrieve nodes fn
	void OnSelect(int);						// item has been selected
	int  OnKey(UINT);						// used to trap user input
											// Overide so we can draw single items:
	void DrawNodeGlyph(CDC* pDC, CNode* pNode, BOOL bHighlight, CPoint pt);
	int CompareData(const CNode* pNode1, const CNode* pNode2);
	void InvalidateNode (int iNode);

	CPtrList m_ptrTrgNodes;					// list of target nodes in memory

	// tree-state store
 	static COptionTreeStore sm_TreeState;	// our 'remembered' tree state
	
private:
	CProject * m_pProject;					// cached pointer to project
};

// sizes of 'mondo' dialog frame controls
#define CX_TREE_BORDER	8
#define CY_TREE_BORDER	8
#define CX_TREECTL	240
#define CP_OUTER_BORDER	4

// the 'mondo' dialog frame
class CNoPropsDlg : public CDialog
{
public:
	BOOL Create(CWnd * pWndParent = (CWnd *)NULL)
	{
		return CDialog::Create(IDD_NO_CMN_OPTIONS, pWndParent);
	}
};

class CProjOptionsDlg : public CTabbedDialog
{
	DECLARE_DYNAMIC(CProjOptionsDlg)

	friend class COptionTreeCtl;

public:
	CProjOptionsDlg(CWnd * pwndParent = NULL, int iSelectTab = -1) :
		CTabbedDialog(IDS_PROJECT_OPTIONS, pwndParent, iSelectTab)
	{
        // FUTURE (colint): Fix to work with new build view
		// m_pProjTreeCtlToCopy = pProjTreeCtlToCopy;

		m_pSelectionSlob = NULL;

		m_fIgnoreSelChange = FALSE;

		// cache a pointer to the current project
		m_pProject = g_pActiveProject; ASSERT(m_pProject != (CProject *)NULL);
		m_idOnOKMsg = (UINT)-1;	// no OnOK() by default 

		m_nCurTargetSel = CB_ERR;
		m_bDirtyTabs = FALSE;
	}

	// handle the commit model for the tool options
	void ExitCleanup();
	void OnOK();
	void OnCancel();

	void SetSelection(CSlob * pSelection) { m_pSelectionSlob = pSelection; }

	// OnOK message hook hack for pages
	__inline void SetOnOKMessage(UINT idMsg) {m_idOnOKMsg = idMsg;}

	// validation
	__inline BOOL ValidateCurrent()
	{	return m_nTabCur == -1 || GetTab(m_nTabCur)->ValidateTab();}
	
	// handle tab selection changes
	void OnSelectTab(int nTab);

	CButton* GetButtonFromIndex(int index);

	// notification tree control selection has changed
	void OnTreeCtlSelChange();

	// retrieve into our cache the current set of option
	// handlers to use
	void CacheOptionHandlers();

	// update our tab pages to to show only tabs
	// relevant to the current selection in the 
	// option tree control
	BOOL UpdateOptionTabs();

	// update our proxy slob (inform of the selection change?)
	BOOL UpdateProxySlob(BOOL fInform = TRUE);
	void ValidateContent(OptTreeNode * pNode);
	void AddContent(OptTreeNode * pNode, CPtrList & lstSelectedNodes);
	BOOL UpdateConfigsFromCombo();
	void UpdateConfigsFromDlg();
	void RefreshTargets();

	// have any of the project props. changed?
	BOOL FProjectChanged(UINT idSrcBag, UINT idDestBag);

	// perform an operation on bags over the whole project (ie. all the items)
	// o do the 'copy clone->current' and 'copy current->clone' snapshots
	// o do 'clear clone' bags
	// o do 'inform of diffs' operation
	typedef enum {BO_Copy = 0x1, BO_Inform = 0x2, BO_Clear = 0x4, BO_Same = 0x8, BO_UseDest = 0x10, BO_PrivateSpecial = 0x20} BagOp;
	BOOL DoBagOpOverProject(CProject * pProject, UINT idSrcBag, UINT idDestBag, UINT bagop = BO_Copy);

	// remember the current state of our tool option tab categories
	void RememberCategories();

	virtual void GetMargins(CRect & rect);
	virtual void GetTabSize(CRect & rect);

	// our proxy slob to handle getting and setting props from and to the 
	// option tree control selection
	CProxySlob m_ProxySlob;

	// our option tree control in this tabbed dialog
	COptionTreeCtl m_OptTreeCtl;

	static CMapStringToPtr m_mapActiveFlavours;
	static BOOL IsActiveFlavour(CString & strFlavour) { void * pVoid; return m_mapActiveFlavours.Lookup(strFlavour, pVoid); }
	static void SetActiveFlavour(CString & strFlavour) { m_mapActiveFlavours.SetAt(strFlavour, NULL); }
	static void ResetActiveFlavours() { m_mapActiveFlavours.RemoveAll(); }
protected:
	DECLARE_MESSAGE_MAP()

	//{{AFX_MSG(CProjOptionsDlg)
	afx_msg int OnCreate(LPCREATESTRUCT);
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT, int, int);
	afx_msg void OnPaint();
	afx_msg HBRUSH OnCtlColor(CDC *, CWnd *, UINT);
	afx_msg LRESULT OnSelectItem(WPARAM, LPARAM);
	afx_msg void OnSelChangeTarget();
	afx_msg void OnActivateEditCmds();
	afx_msg void OnActivateEditOutput();
	//}}AFX_MSG

	// afx_msg void OnBtnChangeTarget();

	BOOL InvokeChangeTargetDlg();

private:
	CProject * m_pProject;					// cached pointer to project

	// our map of tab string to category string
	// we use to maintain the state of our CToolOptionTabs
	static CMapStringToString m_mapLastMiniPage;
	
	// the project tree control whose state we want to initialise with
    // FUTURE (colint): Fix to work with the new build view
	// CProjTreeCtl * m_pProjTreeCtlToCopy;

	CSlob * m_pSelectionSlob;

	// our '&Settings For:' static text
	CStatic m_txtSettingsFor;

#if 0
	// Configurations button / text
	CButton m_bnConfigs;
#endif

	// Configurations combo box
	CComboBox m_cbConfigs;
	
	CString m_strAllConfigs;
	CString m_strMultiConfigs;

	// our 'No Common Properties' dialog
	CNoPropsDlg m_dlgNoProps;

	// our current list of option tool handlers available for the selection
	CPtrList m_listHdlrs;

	// our cached (new) list of option handlers available for the new selection
	CPtrList m_listHdlrsCache;

	// our previous tab header
	CString m_strPrevTab;

	// ignore tree-control selection changes
	BOOL m_fIgnoreSelChange;

	// resume recording OnDestroy()?
	BOOL m_fResumeRecording;

	// OnOK messages
	UINT m_idOnOKMsg;

	// previous target selection
	int m_nCurTargetSel;

public:
	BOOL m_bDirtyTabs;
};

/////////////////////////////////////////////////////////////////////////////
// CConfigSelectDlg dialog

class CConfigSelectDlg : public C3dDialog
{
// Construction
public:
	CConfigSelectDlg(CWnd* pParent = NULL);   // standard constructor
	~CConfigSelectDlg(void) { }

// Dialog Data
	//{{AFX_DATA(CConfigSelectDlg)
	enum { IDD = IDD_SELECT_CONFIG };
	CCheckList m_lbConfigs;
	enum { same, single, multi, all } m_SelState;
	//}}AFX_DATA

protected:
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSccDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSccDlg)
	afx_msg void OnSelectAll();
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _INCLUDE_OPTIONDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnlib.h ===
//
// Library Manager Tool Options
//
// [matthewt]
//

#ifndef _INCLUDE_OPTNLIB_H
#define _INCLUDE_OPTNLIB_H

#include "projprop.h"	// our option property ids
#include "prjoptn.h"	// macros used to decl/defn our tables
#include "optnlib.h2"	// our option control IDs

//----------------------------------------------------------------
// our library manager tool option property pages
//----------------------------------------------------------------

class CLibPageTab : public COptionMiniPage
{
	DECLARE_DYNCREATE(CLibPageTab)
public:
	virtual BOOL Validate();
};

//----------------------------------------------------------------
// our 'General' option property page
//----------------------------------------------------------------

class CLibGeneralPage : public CLibPageTab
{
	DECLARE_DYNCREATE(CLibGeneralPage)
	DECLARE_IDE_CONTROL_MAP()
};

//----------------------------------------------------------------
// our option property pages
//----------------------------------------------------------------

extern CRuntimeClass * g_libTabs[];

//----------------------------------------------------------------
// our COMMON lib option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	Lib, /* name */
	szAddOnGeneric, BCID_OptHdlr_Lib, /* generic library manager option handler */
	szAddOnGeneric, BCID_Tool_Lib /* generic library manager tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option pages
	virtual UINT GetNameID() {return IDS_LIBMGR;}
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_libTabs;}

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// return a 'fake' string prop
	virtual GPT GetDefStrProp(UINT idProp, CString & strVal);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	int GetTabDlgOrder()
		{ return 40; }

private:
	// called whenever a prop has changed
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal);

	// form a 'fake' string prop
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);

END_OPTHDLR()

// lib tool properties

#include "optnlink.h"

#define P_LibUnknownString				0x0000
#define P_LibUnknownOption				0x0001
#define P_NoLogoLib						0x0002
#define P_OutNameLib					0x0003
#define P_DefNameLib					0x0004

// lib tool options (option ids)
#define IDOPT_OUTLIB					IDOPT_BASE + 0
#define IDOPT_DEFLIB					IDOPT_BASE + 1
#define IDOPT_LIBNOLOGO					IDOPT_BASE + 2

#endif // _INCLUDE_OPTNLIB_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnlink.cpp ===
// 
// Linker Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "optnlink.h"	// our local header file

BEGIN_OPTSTR_TABLE(LinkerCommon, P_LinkUnknownOption, P_LinkUnknownString, P_LinkNoLogo, P_LinkUnknownString, FALSE)
	IDOPT_UNKNOWN_STRING,	"",							NO_OPTARGS,								single,
	IDOPT_LINKNOLOGO,	"nologo%T1",					OPTARGS1(P_LinkNoLogo),					single,
	IDOPT_DERIVED_OPTHDLR,	"",							NO_OPTARGS,								single,
	IDOPT_LINKVERBOSE,	"verbose%T1",					OPTARGS1(P_LinkVerbose), 				single,
	IDOPT_DLLGEN,		"dll%T1",						OPTARGS1(P_GenDll),						single,
	IDOPT_PROFILE,		"profile%T1",					OPTARGS1(P_Profile),					single,
	IDOPT_USEPDBNONE,	"pdb:none%F1",					OPTARGS1(P_UsePDB),						single,
	IDOPT_INCREMENTALLINK, "incremental:%{no|yes}1",	OPTARGS1(P_IncrementalLink),			single,
	IDOPT_USEPDB,		"pdb:%T1%2",					OPTARGS2(P_UsePDB, P_UsePDBName),		single,
	IDOPT_MAPGEN,		"m[ap]%T1[:%2]",				OPTARGS2(P_GenMap, P_MapName), 			single,
	IDOPT_DEBUG,		"debug%T1",						OPTARGS1(P_GenDebug),					single,
	IDOPT_DEBUGTYPE,	"debugtype:%{cv|coff|both}1",	OPTARGS1(P_DebugType),					single,
	IDOPT_MACHINETYPE, 	"machine:%{I386|IX86|M68K|ALPHA|MPPC}1",	OPTARGS1(P_MachineType),	single,
	IDOPT_NODEFAULTLIB,	"nod[efaultlib]:%1",			OPTARGS1(P_NoDefaultLibs),			multiple,
	IDOPT_EXALLLIB,		"nod[efaultlib]%T1",			OPTARGS1(P_ExAllLibs),				single,
	IDOPT_INCLUDESYM,	"include:%1",					OPTARGS1(P_IncludeSym),					multiple,
	IDOPT_DEFNAME,		"def:%1",						OPTARGS1(P_DefName),					single,
	IDOPT_FORCE,		"force%T1",						OPTARGS1(P_Force),						single,
	IDOPT_OUT,			"out:%1",						OPTARGS1(P_OutName),					single,	
	IDOPT_IMPLIB,		"implib:%1",					OPTARGS1(P_ImpLibName),					single,
	IDOPT_LAZYPDB,		"pdbtype:%{sept|con}1",			OPTARGS1(P_LazyPdb),					single,
	IDOPT_LIBPATH,		"libpath:%1",					OPTARGS1(P_LibPath),					multiple,
	IDOPT_UNKNOWN_OPTION,	"",							NO_OPTARGS,								single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerCommon)
	OPTDEF_BOOL(LinkNoLogo, FALSE)
	OPTDEF_BOOL(LinkVerbose, FALSE)
	OPTDEF_BOOL(GenDll, FALSE)
	OPTDEF_BOOL(GenMap, FALSE)
	OPTDEF_PATH(MapName, "")
	OPTDEF_PATH(OutName, "")
	OPTDEF_BOOL(GenDebug, FALSE)
	OPTDEF_INT(DebugType, 1)
	OPTDEF_BOOL(ExAllLibs, FALSE) 
	OPTDEF_LIST(NoDefaultLibs, "")
	OPTDEF_LIST(IncludeSym, "")
	OPTDEF_PATH(DefName, "")
	OPTDEF_BOOL(UsePDB, TRUE)
	OPTDEF_BOOL(IncrementalLink, TRUE)
	OPTDEF_PATH(UsePDBName, "")
	OPTDEF_BOOL(Force, FALSE)
	OPTDEF_PATH(ImpLibName, "")
	OPTDEF_BOOL(Profile, FALSE)
	OPTDEF_INT(MachineType, 2)
	OPTDEF_INT(IgnoreExportLib, 0)
	OPTDEF_LIST(LibPath, "")
	OPTDEF_INT(LazyPdb, 0)
END_OPTDEF_MAP()

IMPLEMENT_DYNCREATE(CLinkerGeneralPage, CLinkerPageTab)
IMPLEMENT_DYNCREATE(CLinkerPageTab, COptionMiniPage)
IMPLEMENT_DYNCREATE(CLinkerDebugPage, CLinkerPageTab)
IMPLEMENT_DYNCREATE(CLinkerCustomPage, CLinkerPageTab)
IMPLEMENT_DYNCREATE(CLinkerInputPage, CLinkerPageTab)
IMPLEMENT_DYNCREATE(CLinkerWin32OutputPage, CLinkerPageTab)


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// linker tool option default map 'faking'
BOOL OPTION_HANDLER(LinkerCommon)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_MapName || idPropL == P_OutName ||
			idPropL == P_ImpLibName || idPropL == P_UsePDBName ||
			idPropL == P_DefName || idPropL == P_IgnoreExportLib ||
			idPropL == P_IncrementalLink);
}

UINT OPTION_HANDLER(LinkerCommon)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_MapName)
		return P_OutDirs_Intermediate;

	// .exe, .lib, .pdb use the target directory
	else if (idPropL == P_OutName || idPropL == P_ImpLibName || idPropL == P_UsePDBName)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OPTION_HANDLER(LinkerCommon)::OnOptionIntPropChange(UINT idProp, int nVal)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_GenDll)
		m_pSlob->InformDependants(MapLogical(P_OutName));

	else if (idProp == P_ItemExcludedFromBuild)
	{
		const CPath * pPath = ((CProjItem *)m_pSlob)->GetFilePath();
		CFileRegistry* pFileRegistry = ((CProjItem *)m_pSlob)->GetRegistry();

		CPtrList * pFileList;					  
		if (pPath != (CPath *)NULL &&	// ie. only for CFileItems

			// is this a .def file being included in the build??
			pFileRegistry->GetFileList(pPath, (const CPtrList * &)pFileList) &&
			pFileList == pFileRegistry->GetDEFFileList() &&	// is this a .def file?
			!nVal)	// included in build?
		{
			// start tracking /DEF: by removing the current prop. from the project-level
			const ConfigurationRecord * pcr = ((CProjItem *)m_pSlob)->GetActiveConfig();
			if (pcr == (const ConfigurationRecord *)NULL)
			{
				ASSERT(FALSE);
				return;
			}
			((ConfigurationRecord *)pcr->m_pBaseRecord)->GetPropBag(CurrBag)->RemoveProp(MapLogical(P_DefName));
		}
	}		
}

void OPTION_HANDLER(LinkerCommon)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{ 
	UINT idPropL = MapActual(idProp);

	// which prop. is this?
	switch (idPropL)
	{
		case P_UsePDBName:
			if (strVal.IsEmpty())
				m_pSlob->GetPropBag()->RemovePropAndInform(MapLogical(P_UsePDBName), m_pSlob);
			break;

		case P_OutName:
 			if (strVal.IsEmpty())
				m_pSlob->GetPropBag()->RemovePropAndInform(MapLogical(P_OutName), m_pSlob);
			m_pSlob->InformDependants(P_ProjItemFullPath);
			m_pSlob->InformDependants(P_TargetName);	// Inform the project item so that the project settings updates ok
			break;
 
		case P_DefName:
		{
			// we want to make sure this .DEF is included in the build
			CObList oblistDEFFile;
			const ConfigurationRecord * pcrBase, * pcr = ((CProjItem *)m_pSlob)->GetActiveConfig();
			if (pcr == (const ConfigurationRecord *)NULL)
			{
				ASSERT(FALSE);
				return;
			}
			pcrBase = pcr->m_pBaseRecord;

			CFileRegistry* pFileRegistry;
			CTargetItem * pTarget = NULL;

			pFileRegistry = ((CProjItem *)m_pSlob)->GetRegistry();
			pTarget = ((CProjItem *)m_pSlob)->GetTarget();

			if (pFileRegistry == NULL)
			{
				// no registry (so we probably have a CProxySlob)
				ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
				if (((CProxySlob*)m_pSlob)->IsSingle())
				{
					OptTreeNode* pOptNode = ((CProxySlob*)m_pSlob)->GetSingle();
					CString strTargetName = pOptNode->pcr->GetConfigurationName();
					pTarget =  g_pActiveProject->GetTarget(strTargetName);
					ASSERT(pTarget);
					pFileRegistry = pTarget->GetRegistry();
				}
			}
			ASSERT(pFileRegistry);
			
 			pFileRegistry->GetFileItemList(pTarget, pFileRegistry->GetDEFFileList(),
										   oblistDEFFile,
										   FALSE, pcrBase);
			if (oblistDEFFile.GetCount() == 0)	// none?
				break;

			// create a path for this def file
			CPath pathDEF;
			if (!pathDEF.CreateFromDirAndFilename((const CDir &)g_pActiveProject->GetProjDir(),
												  (TCHAR *)(const TCHAR *)strVal))
				break;							// can't create def path

			POSITION posDEF = (POSITION)NULL, pos = oblistDEFFile.GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				POSITION posCurr = pos;
				if (pathDEF == (const CPath &)*((CFileItem * )oblistDEFFile.GetNext(pos))->GetFilePath())
				{
					posDEF = posCurr;	// found a matching def file
					break;
				}
			}

			int nVal;

			// set all of the other defs to 'excluded from build'
			POSITION posT = oblistDEFFile.GetHeadPosition();
			while (posT != (POSITION)NULL)
			{
				BOOL fSkip = posT == posDEF;
				CFileItem * pItem =	(CFileItem * )oblistDEFFile.GetNext(posT);
				if (fSkip)	continue;	// skip our def we got		

				pItem->ForceBaseConfigActive((ConfigurationRecord *)pcrBase);
				if (pItem->GetIntProp(P_ItemExcludedFromBuild, nVal) != valid || !nVal)
					pItem->SetIntProp(P_ItemExcludedFromBuild, TRUE);
				pItem->ForceConfigActive();
			}

			if (posDEF != (POSITION)NULL)
			{
				// set this one to 'included in build' ?
				CFileItem * pItem =	(CFileItem * )oblistDEFFile.GetAt(posDEF);
				pItem->ForceBaseConfigActive((ConfigurationRecord *)pcrBase);
				if (pItem->GetIntProp(P_ItemExcludedFromBuild, nVal) != valid || nVal)
					pItem->SetIntProp(P_ItemExcludedFromBuild, FALSE);
				pItem->ForceConfigActive();
			}
			break;
		}

		default:
			break;
	}

	// change our outputs?
}

BOOL OPTION_HANDLER(LinkerCommon)::AlwaysShowDefault(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_UsePDB || idPropL == P_MachineType);
}

BOOL OPTION_HANDLER(LinkerCommon)::IsDefaultStringProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_OutName || idPropL == P_ImpLibName || idPropL == P_DefName)
	{
		CString strFake;
		if (idPropL == P_OutName || idPropL == P_ImpLibName)
			// both 'foobar.exe' and 'foobar.dll' are defaults!
			VERIFY(m_pSlob->GetIntProp(MapLogical(P_GenDll), m_fProjIsDll) == valid);

		FormFakeStrProp(idProp, strFake);
		if (strFake.CompareNoCase(strVal) == 0)
			return TRUE;

		if (idPropL == P_OutName)
		{
			m_fProjIsDll = !m_fProjIsDll;

			FormFakeStrProp(idProp, strFake);
			if (strFake.CompareNoCase(strVal) == 0)
				return TRUE;
		}

		// if we failed to match a faked prop, then is this a default in 
		// the 'default map'?
	}

	return COptionHandler::IsDefaultStringProp(idProp, strVal);
}

void OPTION_HANDLER(LinkerCommon)::FormFakeIntProp(UINT idProp, int & nVal)
{
	UINT idPropL = MapActual(idProp);

	// should not call this if it is not a fake property
	ASSERT (IsFakeProp (idProp));

	// the default value of Incremental Link depends whether
	// it is a 'debug' or 'release' mode
	if (idPropL == P_IncrementalLink)
		if (m_pSlob->GetIntProp(P_UseDebugLibs, nVal) != valid) 
			nVal = FALSE;

	if (idPropL == P_IgnoreExportLib){
		nVal = TRUE;
		if( m_pSlob->GetIntProp(P_Proj_IgnoreExportLib, nVal) == invalid ){
			if (m_pSlob->GetIntProp(MapLogical(P_GenDll), nVal) == invalid )	// /DLL must be set
				nVal = TRUE;
			else
				nVal = FALSE;
		}
	}
}

GPT OPTION_HANDLER(LinkerCommon)::GetDefIntProp(UINT idProp, int & nVal)
{
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefIntProp(idProp, nVal);

	FormFakeIntProp(idProp, nVal);
	return valid;
}

void OPTION_HANDLER(LinkerCommon)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// ASSERT this a Linker 'fake' string prop?
	ASSERT(IsFakeProp(idProp));

	// do we want to form /DEF:foobar.def ?
	if (idPropL == P_DefName)
	{	
		// do we have *one* 'buildable' .DEF in project?
		const ConfigurationRecord * pcrBase, * pcr = ((CProjItem *)m_pSlob)->GetActiveConfig();
		if (pcr == (const ConfigurationRecord *)NULL)
		{
			// no config. (perhaps CProxySlob multi-config)
			return;
		}
		pcrBase = pcr->m_pBaseRecord;

		CFileRegistry* pFileRegistry;
		CTargetItem* pTarget = NULL;

		pFileRegistry = ((CProjItem *)m_pSlob)->GetRegistry();
		pTarget = ((CProjItem *)m_pSlob)->GetTarget();

		if (pFileRegistry == NULL)
		{
			// no registry (so we probably have a CProxySlob)
			ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
			if (((CProxySlob*)m_pSlob)->IsSingle())
			{
				OptTreeNode* pOptNode = ((CProxySlob*)m_pSlob)->GetSingle();
				CString strTargetName = pOptNode->pcr->GetConfigurationName();
				pTarget = g_pActiveProject->GetTarget(strTargetName);
				ASSERT(pTarget);
				pFileRegistry = pTarget->GetRegistry();
			}
		}
		ASSERT(pFileRegistry);
 
		CObList oblistDEFFile;
		pFileRegistry->GetFileItemList(pTarget,
									   pFileRegistry->GetDEFFileList(),
									   oblistDEFFile,
									   TRUE, pcrBase);

		if (oblistDEFFile.GetCount() == 1)
		{
			CDir dirProj; 
			dirProj = ((CProjItem *)m_pSlob)->GetProject()->GetWorkspaceDir();

			// get the path of the *only* .DEF file in this list
			const CPath * pPath = ((CFileItem *)oblistDEFFile.GetHead())->GetFilePath();
			pPath->GetRelativeName(dirProj, strVal);	// relativizer this to project dir.
		}
		else
			strVal = "";	// no unique 'buildable' .DEF in project

		return;	// we're done
	}

	// form the other fake string props...

	// get the project base-name (ie. without extension)
	CString strBase;

    // If we are faking the output name then we use the projects base-name
    // (without extension) as the basis of the faked name.
    // If we are faking the map name, pdb name, or implib name then we
    // use the base of the output name as the basis of the faked name.
    if (idPropL == P_OutName)
	{
        CProjItem * pItem = ((CProjItem *)m_pSlob);
		CDir dirWorkspace = pItem->GetProject()->GetWorkspaceDir();
		CDir dirProject = pItem->GetProject()->GetProjDir(pItem->GetActiveConfig());
		CString strWorkspace = (const TCHAR *)dirWorkspace;
		CString strProject = (const TCHAR *)dirProject;

		if (strWorkspace.CompareNoCase(strProject) == 0)
		{
			const CPath * ppathProj = pItem->GetProject()->GetFilePath();
			ppathProj->GetBaseNameString(strBase);
		}
		else
		{
			// subproject
			ASSERT( (strProject.GetLength() > strWorkspace.GetLength()) );
			strBase = strProject.Right(strProject.GetLength()-strWorkspace.GetLength()-1);
		}
	}
    else
	{
		CString strPath;
		VERIFY(m_pSlob->GetStrProp(MapLogical(P_OutName), strPath) == valid);
	  	
		CPath path;
	 	if (path.Create(strPath))
			path.GetBaseNameString(strBase);
	}

	// which output directory do we want to use?
	UINT idOutDirProp = GetFakePathDirProp(idProp);
	ASSERT(idOutDirProp != (UINT)-1);

	CString strOut;
	VERIFY(m_pSlob->GetStrProp(idOutDirProp, strOut) == valid);

	const TCHAR * pchT;
	strVal = "";

	// If the output directory doesn't end in a forward slash
	// or a backslash, append one.
	if (!strOut.IsEmpty())
	{
		strVal = strOut;

		pchT = (const TCHAR *)strVal + strVal.GetLength();
		pchT = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchT);

		if (*pchT != _T('/') && *pchT != _T('\\'))
			strVal += _T('/');
	}

	// Add the base, and extension prefix
	strVal += strBase;
	strVal += _T('.');

	// Append the extension
	CString strExt;
	if (idPropL == P_MapName)
	{
		strExt = _TEXT("map");
	}
	else if (idPropL == P_OutName || idPropL == P_ImpLibName || idPropL == P_UsePDBName)
	{
		if (idPropL == P_ImpLibName)
		{
			strExt = _TEXT("lib");
		}
		else if (idPropL == P_UsePDBName)
		{
			strExt = _TEXT("pdb");
		}
		else
		{
			// can we get a supplied default target extension?
			if (!m_pSlob->GetStrProp(P_Proj_TargDefExt, strExt))
				strExt = (m_fProjIsDll ? _TEXT("dll") : _TEXT("exe"));	// no
		}
	}
	else	
	{
		ASSERT(FALSE);
	}

	strVal += strExt;
}

GPT OPTION_HANDLER(LinkerCommon)::GetDefStrProp(UINT idProp, CString & val)
{
	UINT idPropL = MapActual(idProp);

	BOOL fIgnoreFake = FALSE;

	// we don't have ImpLibName with no /DLL
	if (idPropL == P_ImpLibName)
	{
		int nVal;
		if (m_pSlob->GetIntProp(MapLogical(P_GenDll), nVal) == invalid || !nVal)	// /DLL must be set
			fIgnoreFake = TRUE;	// not a faked prop in this context
	}
	
	// can we ignore the output directories?
	if (fIgnoreFake || !IsFakeProp(idProp))
		return COptionHandler::GetDefStrProp(idProp, val);

	if (idPropL == P_OutName || idPropL == P_ImpLibName)
		VERIFY(m_pSlob->GetIntProp(MapLogical(P_GenDll), m_fProjIsDll) == valid);

	FormFakeStrProp(idProp, val);
	return valid;
}

BOOL OPTION_HANDLER(LinkerCommon)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	BOOL fValid = TRUE;			// valid by default
	
	// placeholders for values
	int nVal, nVal2;	
	CPlatform * pPlatform ;

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// Incremental not valid if request to generate a Map
		case P_IncrementalLink:
			pPlatform = g_pActiveProject->GetCurrentPlatform() ;
			if (pPlatform->GetAttributes() & PIA_Supports_IncLink)
			{
				(void) m_pSlob->GetIntProp(MapLogical(P_UsePDB), nVal) ;
				(void) m_pSlob->GetIntProp (MapLogical(P_Profile), nVal2) ;
				fValid = nVal && !nVal2;
			}
			else
				fValid = FALSE ;
			break;
		// Use PDB not valid if Profiling is checked 
		case P_UsePDB:
			(void) m_pSlob->GetIntProp (MapLogical(P_Profile), nVal) ;
			fValid = !nVal ;
			break ;

		// Generate Mapfile must be disabled if Profile is checked
		case P_GenMap:
			//(void)m_pSlob->GetIntProp (MapLogical(P_Profile), nVal) ;
			fValid = TRUE;
			break ;

		// Can only type map-name if generating a mapfile!
		case P_MapName:
			(void) m_pSlob->GetIntProp(MapLogical(P_GenMap), nVal);
			fValid = nVal;
			break;

		// Can't specify the debug info type if not gen. debug info
		case P_DebugType:
			(void) m_pSlob->GetIntProp(MapLogical(P_GenDebug), nVal);
			pPlatform = g_pActiveProject->GetCurrentPlatform() ;
			if (pPlatform->GetAttributes() & PIA_Enable_AllDebugType)
				fValid = nVal;
			else
				 fValid = FALSE;
			break;

		// Not allowed to type in a .PDB name without use PDB file
		case P_UsePDBName:
			VERIFY(m_pSlob->GetIntProp(MapLogical(P_UsePDB), nVal) == valid);
			(void) m_pSlob->GetIntProp(MapLogical(P_Profile), nVal2) ;
			fValid = nVal && !nVal2;
			break;
		// not allowed to select lazy pdb unless pdb in use
		case P_LazyPdb:
			VERIFY(m_pSlob->GetIntProp(MapLogical(P_UsePDB), nVal) == valid);
			(void) m_pSlob->GetIntProp(MapLogical(P_Profile), nVal2) ;
			fValid = nVal && !nVal2;
			break;
	/*
		case P_StubName:
			pPlatform = g_pActiveProject->GetCurrentPlatform();
			if (pPlatform->GetAttributes() & PIA_Enable_Stub)
				fValid = TRUE;
			else
				fValid = FALSE;
			break;
	*/
		default:
			break;
	}

	return fValid;
}

// linker tool option property page
CRuntimeClass * g_linkTabs[] = 
{
	RUNTIME_CLASS(CLinkerGeneralPage),
	RUNTIME_CLASS(CLinkerInputPage),
	RUNTIME_CLASS(CLinkerCustomPage),
	RUNTIME_CLASS(CLinkerDebugPage),
	(CRuntimeClass *)NULL,
};


BEGIN_IDE_CONTROL_MAP(CLinkerGeneralPage, IDDP_PROJ_LINKER, IDS_LINKCOFF)
	MAP_EDIT(IDC_LIBS, P_LinkUnknownString)
	MAP_CHECK(IDC_EXLIB, P_ExAllLibs)
	MAP_CHECK(IDC_MAPGEN, P_GenMap)
	MAP_CHECK(IDC_LNK_DBGFULL, P_GenDebug)
	MAP_EDIT(IDC_OUT, P_OutName)
	MAP_CHECK(IDC_INCLINK, P_IncrementalLink)
	MAP_CHECK(IDC_PROFILE, P_Profile)
	MAP_CHECK(IDC_IGNOREEXPORTLIB, P_IgnoreExportLib)
END_IDE_CONTROL_MAP()

BOOL IsLearningBox();

BOOL CLinkerGeneralPage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if( IsLearningBox() )
	{
		GetDlgItem(IDC_PROFILE)->EnableWindow(FALSE);
	}

	if (idPropL == P_Profile)
	{
		OnPropChange(MapLogical(P_GenMap));
		OnPropChange(MapLogical(P_UsePDB));
	}
	else if (idPropL == P_UsePDB)
	{
		OnPropChange(MapLogical(P_IncrementalLink));
	}
	else if (idPropL == P_IgnoreExportLib)
	{
		int nVal;
		m_pSlob->GetIntProp(idProp, nVal) ;
		m_pSlob->SetIntProp(P_Proj_IgnoreExportLib, nVal);
		BOOL fDll = m_pSlob->GetIntProp(MapLogical(P_GenDll), nVal) == valid && nVal;
		if( fDll ) 
			GetDlgItem(IDC_IGNOREEXPORTLIB)->ShowWindow(SW_SHOW);
		else
			GetDlgItem(IDC_IGNOREEXPORTLIB)->ShowWindow(SW_HIDE);
	}
	return CLinkerPageTab::OnPropChange(idProp);
}


BOOL CLinkerPageTab::Validate()
{
	if (m_nValidateID == IDC_OUT)
	{
		if (!Validate_Destination(IDC_OUT, IDS_DEST_TRG,
								  "",		// doesn't have extension
								  FALSE,	// must be directory
								  TRUE))	// cant be directory
			return FALSE;
	}

	if (m_nValidateID == IDC_OPTSTR)
	{
		if (!Validate_DestinationProp(P_OutName,
									  IDOPT_OUT,
									  IDC_OPTSTR, IDS_DEST_TRG,
									  "",		// doesn't have extension
									  FALSE,	// must be directory
									  TRUE))	// cant be directory
			return FALSE;

		return (Validate_DestinationProp(P_MapName,
										 IDOPT_MAPGEN,
										 IDC_OPTSTR, IDS_DEST_MAP,
								  		 "map",	// must have extension
								  		 FALSE,	// must be directory
								  		 TRUE));	// cant be directory
	}

	return COptionMiniPage::Validate();
}


BEGIN_IDE_CONTROL_MAP(CLinkerDebugPage, IDDP_LINKER_DEBUG, IDS_CAT_DEBUG)
	MAP_CHECK(IDC_MAPGEN, P_GenMap)
	MAP_EDIT(IDC_MAPNAME, P_MapName)
	MAP_CHECK(IDC_LNK_DBGFULL, P_GenDebug)
	MAP_CHECK(IDC_LAZYPDB, P_LazyPdb)
	MAP_RADIO(IDC_LNK_DBGCV, IDC_LNK_DBGBOTH, 1, P_DebugType)
END_IDE_CONTROL_MAP()


BOOL CLinkerDebugPage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	// we want to enable/disable prop page items
	// - we'll enable/disable the static text
	// - OnPropChange() will enable/disable the rest
	switch (idPropL)
	{
		case P_GenDebug:
		{
			CLinkerPageTab::OnPropChange(MapLogical(P_DebugType));
			break;
		}

		case P_GenMap:
		{
			int nVal;																			  

			CLinkerPageTab::OnPropChange(MapLogical(P_MapName));

			GetDlgItem(IDC_TXT_MAPNAME)->EnableWindow(m_pSlob->GetIntProp(MapLogical(P_GenMap), nVal) == valid && !!nVal);
			break;
		}
		case P_UsePDB:
		{
			int nVal = FALSE ;
			m_pSlob->GetIntProp(MapLogical(P_UsePDB), nVal) ;
			// GetDlgItem (IDC_TXT_PDBNAME)->EnableWindow(nVal) ;
			CLinkerPageTab::OnPropChange(MapLogical(P_LazyPdb));
		}
		default:
			break;
	}

	// call our base-class
	return CLinkerPageTab::OnPropChange(idProp);
}

BOOL CLinkerDebugPage::Validate()
{
	if (m_nValidateID == IDC_MAPNAME)
	{
		if (!Validate_Destination(IDC_MAPNAME, IDS_DEST_MAP,
								  "map",	// must have extension
								  FALSE,	// must be directory
							  	  TRUE))	// cant be directory
			return FALSE;
	}

	return CLinkerPageTab::Validate();
}


BEGIN_IDE_CONTROL_MAP(CLinkerCustomPage, IDDP_LINKER_CUSTOM, IDS_CAT_CUSTOMLINK)

	MAP_CHECK(IDC_USEPDB, P_UsePDB)
	MAP_EDIT(IDC_PDBNAME, P_UsePDBName)
	MAP_CHECK(IDC_INCLINK, P_IncrementalLink)
	MAP_CHECK(IDC_VERBOSE, P_LinkVerbose)
	MAP_CHECK(IDC_LINKNOLOGO, P_LinkNoLogo)
	MAP_CHECK(IDC_FORCE, P_Force)
	MAP_EDIT(IDC_OUT, P_OutName)
END_IDE_CONTROL_MAP()

BOOL CLinkerCustomPage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	// we want to enable/disable prop page items
	// - we'll enable/disable the static text
	// - OnPropChange() will enable/disable the rest
	switch (idPropL)
	{
		
		case P_UsePDB:
		{
			int nVal = FALSE ;
			m_pSlob->GetIntProp(MapLogical(P_UsePDB), nVal) ;
			GetDlgItem (IDC_TXT_PDBNAME)->EnableWindow(nVal) ; 
			CLinkerPageTab::OnPropChange(MapLogical(P_UsePDBName));
			CLinkerPageTab::OnPropChange(MapLogical(P_IncrementalLink));
			break;
		}

		// this is needed when the user type /PROFILE manually
		// in the option edit box.
		case P_Profile:
			OnPropChange(MapLogical(P_GenMap));
			OnPropChange(MapLogical(P_UsePDB));
			break;
		default:
			break;
	}

	// if our OnPropChange is because we are currently editing it, ignore
	// it .. we don't want the SlobPage updating the edit-control as we are
	// typing especially 'cos we do special stuff
	if ((idPropL == P_VersionMaj && m_nCurrentEditID == IDC_VERMAJOR) ||
		(idPropL == P_VersionMin && m_nCurrentEditID == IDC_VERMINOR))
	{
		m_pToolOptionTab->Refresh();		// option string update!
		return TRUE;	// no page update ... ok!
	}

	// call our base-class
	return CLinkerPageTab::OnPropChange(idProp);
}

BOOL CLinkerCustomPage::Validate()
{
	return CLinkerPageTab::Validate();
}


BEGIN_IDE_CONTROL_MAP(CLinkerInputPage, IDDP_LINKER_INPUT, IDS_CAT_INPUT)
	MAP_EDIT(IDC_LIBS, P_LinkUnknownString)
	MAP_CHECK(IDC_EXLIB, P_ExAllLibs)
	MAP_EDIT(IDC_IGNLIBS, P_NoDefaultLibs)
	MAP_EDIT(IDC_INCLSYM, P_IncludeSym)
	MAP_EDIT(IDC_LIBPATH, P_LibPath)
END_IDE_CONTROL_MAP()

void CLinkerInputPage::InitPage()
{
	COptionMiniPage::InitPage();
/*
	BOOL bEnableStubName = TRUE;
	((CProxySlob *)m_pSlob)->InitPlatformEnum();
	const CPlatform * pPlatform;
	while (bEnableStubName && (pPlatform = ((CProxySlob *)m_pSlob)->NextPlatform()) != (const CPlatform *)NULL)
		bEnableStubName = bEnableStubName && ((pPlatform->GetAttributes() & PIA_Enable_Stub) != 0);

	GetDlgItem (IDC_STUB)->EnableWindow (bEnableStubName);
	GetDlgItem (IDC_TXT_STUB)->EnableWindow (bEnableStubName);
 */
}

//------------------------------------------------------
// NT linker option handler
//------------------------------------------------------

BEGIN_OPTSTR_TABLE(LinkerNT, (UINT)NULL, (UINT)NULL, P_VersionMaj, P_SubSystem, FALSE)
	IDOPT_DERIVED_OPTHDLR,	"",							NO_OPTARGS,								single,
	IDOPT_EXE_BASE,		"base:%1",						OPTARGS1(P_BaseAddr),					single,
	IDOPT_VERSION,		"version:%1[.%2]",				OPTARGS2(P_VersionMaj, P_VersionMin),	single,
	IDOPT_STACK,		"st[ack]:%1[,%2]",				OPTARGS2(P_StackReserve, P_StackCommit),single,
	IDOPT_ENTRYPOINT,	"entry:%1",						OPTARGS1(P_EntryName),					single,
	IDOPT_SUBSYSTEM,	"subsystem:%{windows|console}1",OPTARGS1(P_SubSystem),					single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(LinkerNT)
	OPTDEF_INT(VersionMaj, -1)	// no default
	OPTDEF_INT(VersionMin, -1)	// no default
	OPTDEF_HEX(StackReserve, 0)
	OPTDEF_HEX(StackCommit, 0)
	OPTDEF_STRING(BaseAddr, "")
	OPTDEF_STRING(EntryName, "")
	OPTDEF_INT(SubSystem, -1)	// no default
END_OPTDEF_MAP()

BOOL OPTION_HANDLER(LinkerNT)::AlwaysShowDefault(UINT idProp)
{
	return FALSE;	// none
}

BOOL OPTION_HANDLER(LinkerNT)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fValid = TRUE;			// valid by default

	// placeholders for values
	int nVal;

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// Stack Commit only enabled if Reserve size set
		case P_StackCommit:
			(void) m_pSlob->GetIntProp(MapLogical(P_StackReserve), nVal);
			fValid = (nVal != 0);	
			break;

		// Version Minor only enabled if Major version set
		case P_VersionMin:
		{
			CString strVal;
			(void) m_pSlob->GetStrProp(MapLogical(P_VersionMaj), strVal);
			fValid = (strVal != "");
			break;
	   	}

		default:
			break;
	}

	return fValid;
}

// NT linker tool option property page
CRuntimeClass * g_linkNTTabs[] = 
{
	RUNTIME_CLASS(CLinkerWin32OutputPage),
	(CRuntimeClass *)NULL
};


BEGIN_IDE_CONTROL_MAP(CLinkerWin32OutputPage, IDDP_LINKER_WIN32_OUTPUT, IDS_CAT_WIN32_OUTPUT)
	MAP_AUTO_EDIT(IDC_STACKRESERVE, P_StackReserve)
	MAP_AUTO_EDIT(IDC_STACKCOMMIT, P_StackCommit)
	MAP_AUTO_EDIT(IDC_BASEADDR, P_BaseAddr)
	MAP_EDIT(IDC_ENTRYPOINT, P_EntryName)
	MAP_AUTO_EDIT(IDC_VERMAJOR, P_VersionMaj)
	MAP_AUTO_EDIT(IDC_VERMINOR, P_VersionMin)
END_IDE_CONTROL_MAP()

BOOL CLinkerWin32OutputPage::OnPropChange(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	// we want to enable/disable prop page items
	// - we'll enable/disable the static text
	// - OnPropChange() will enable/disable the rest
	switch (idPropL)
	{
		case P_StackReserve:
		{
			int nVal;

			CLinkerPageTab::OnPropChange(MapLogical(P_StackCommit));

			GetDlgItem(IDC_TXT_STK_COM)->EnableWindow(m_pSlob->GetIntProp(MapLogical(P_StackCommit), nVal) == valid);
			break;
		}

		case P_VersionMaj:
		{
			int nVal;

			CLinkerPageTab::OnPropChange(MapLogical(P_VersionMin));

			GetDlgItem(IDC_TXT_VERMIN)->EnableWindow(m_pSlob->GetIntProp(MapLogical(P_VersionMin), nVal) == valid);
			break;
		}

		default:
			break;
	}

	// if our OnPropChange is because we are currently editing it, ignore
	// it .. we don't want the SlobPage updating the edit-control as we are
	// typing especially 'cos we do special stuff
	if ((idPropL == P_StackReserve && m_nCurrentEditID == IDC_STACKRESERVE) ||
		(idPropL == P_StackCommit && m_nCurrentEditID == IDC_STACKCOMMIT) ||
		(idPropL == P_BaseAddr && m_nCurrentEditID == IDC_BASEADDR) ||
		(idPropL == P_VersionMaj && m_nCurrentEditID == IDC_VERMAJOR) ||
		(idPropL == P_VersionMin && m_nCurrentEditID == IDC_VERMINOR))
	{
		m_pToolOptionTab->Refresh();		// option string update!
		return TRUE;	// no page update ... ok!
	}

	// call our base-class
	return CLinkerPageTab::OnPropChange(idProp);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnlib.cpp ===
// 
// Library Manager Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "optnlib.h"	// our local header file

BEGIN_OPTSTR_TABLE(Lib, P_LibUnknownOption, P_LibUnknownString, P_LibUnknownString, P_DefNameLib, FALSE)
	IDOPT_UNKNOWN_STRING,	"",					NO_OPTARGS,								single,
	IDOPT_LIBNOLOGO,		"nologo%T1",		OPTARGS1(P_NoLogoLib),					single,
	IDOPT_DERIVED_OPTHDLR,	"",					NO_OPTARGS,								single,
	IDOPT_DEFLIB,			"def:%1", 			OPTARGS1(P_DefNameLib),					single,
	IDOPT_OUTLIB,			"out:%1",			OPTARGS1(P_OutNameLib),					single,	
	IDOPT_UNKNOWN_OPTION,	"",					NO_OPTARGS,								single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(Lib)
	OPTDEF_BOOL(NoLogoLib, FALSE);
	OPTDEF_PATH(DefNameLib, "")
	OPTDEF_PATH(OutNameLib, "")
END_OPTDEF_MAP()

IMPLEMENT_DYNCREATE(CLibPageTab, COptionMiniPage)
IMPLEMENT_DYNCREATE(CLibGeneralPage, CLibPageTab)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

void OPTION_HANDLER(Lib)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_OutNameLib)
	{
 		if (strVal.IsEmpty())
			m_pSlob->GetPropBag()->RemovePropAndInform(MapLogical(P_OutNameLib), m_pSlob);
		m_pSlob->InformDependants(P_ProjItemFullPath);
		m_pSlob->InformDependants(P_TargetName);
	}
}

// lib tool option default map 'faking'

BOOL OPTION_HANDLER(Lib)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_OutNameLib);
}

UINT OPTION_HANDLER(Lib)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_OutNameLib)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OPTION_HANDLER(Lib)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// ASSERT this a Library Manager 'fake' string prop?
	ASSERT(IsFakeProp(idProp));

	// get the project base-name (ie. without extension)
	CString strBase;
    CProjItem * pItem = ((CProjItem *)m_pSlob);
	CDir dirWorkspace = pItem->GetProject()->GetWorkspaceDir();
	CDir dirProject = pItem->GetProject()->GetProjDir(pItem->GetActiveConfig());
	CString strWorkspace = (const TCHAR *)dirWorkspace;
	CString strProject = (const TCHAR *)dirProject;

	if (strWorkspace.CompareNoCase(strProject) == 0)
	{
		const CPath * ppathProj = pItem->GetProject()->GetFilePath();
		ppathProj->GetBaseNameString(strBase);
	}
	else
	{
		// subproject
		ASSERT( (strProject.GetLength() > strWorkspace.GetLength()) );
		strBase = strProject.Right(strProject.GetLength()-strWorkspace.GetLength()-1);
	}

	strVal = "";

	// do we need to know about the target directory?
	if (idPropL == P_OutNameLib)
	{
		const TCHAR * pchT;
	 	CString strOut;

		// which output directory do we want to use?
		UINT idOutDirProp = GetFakePathDirProp(idProp);
		ASSERT(idOutDirProp != (UINT)-1);

		VERIFY(m_pSlob->GetStrProp(idOutDirProp, strOut) == valid);

		if (!strOut.IsEmpty())
		{
			strVal = strOut;

			// If the output directory doesn't end in a forward slash
			// or a backslash, append one.

			pchT = (const TCHAR *)strVal + strVal.GetLength();
			pchT = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchT);

			if (*pchT != _T('/') && *pchT != _T('\\'))
				strVal += _T('\\');
		}


		// Add the base, and extension prefix
		strVal += strBase;
		strVal += _T('.');

		// Append the extension
		// can we get a supplied default target extension?
		CString strExt;
		if (!m_pSlob->GetStrProp(P_Proj_TargDefExt, strExt))
			strExt = _TEXT("lib");	// no

		strVal += strExt;
	}
	else
	{
		ASSERT(FALSE);
	}
}

GPT OPTION_HANDLER(Lib)::GetDefStrProp(UINT idProp, CString & val)
{
	// can we ignore the output directories?
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefStrProp(idProp, val);

	FormFakeStrProp(idProp, val);
	return valid;
}

// lib tool option property page
CRuntimeClass * g_libTabs[] = 
{
	RUNTIME_CLASS(CLibGeneralPage),
	(CRuntimeClass *)NULL,
};

// lib tool option property page

BEGIN_IDE_CONTROL_MAP(CLibGeneralPage, IDDP_PROJ_LIB, IDS_LIBMGR)
	MAP_CHECK(IDC_LIBNOLOGO, P_NoLogoLib)
	MAP_EDIT(IDC_LIBOUT, P_OutNameLib)
END_IDE_CONTROL_MAP()

BOOL CLibPageTab::Validate()
{
	if (m_nValidateID == IDC_LIBOUT)
	{
		if (!Validate_Destination(IDC_LIBOUT, IDS_DEST_TRG,
							 	  "lib",	// must be extension
							 	  FALSE,	// must be directory
							  	  TRUE))	// cant be directory
			return FALSE;
	}

 	if (m_nValidateID == IDC_OPTSTR)
	{
		return Validate_DestinationProp(P_OutNameLib, IDOPT_OUTLIB,
										IDC_OPTSTR, IDS_DEST_TRG,
									    "lib",		// doesn't have extension
									    FALSE,	// must be directory
									    TRUE);	// cant be directory
	}

	return COptionMiniPage::Validate();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnmtl.h ===
// Make Type Library Tool Options
//
// [ignatius]
// everything is still bogus, just want to check if it works fine
// or not

#ifndef _INCLUDE_OPTNMTL_H
#define _INCLUDE_OPTNMTL_H

#include "projprop.h"  // our option property ids
#include "prjoptn.h" // macros used to decl/defn our tables
#include "optnmtl.h2" // our option control IDs

//----------------------------------------------------------------
// our make type library tool option property pages
//----------------------------------------------------------------

class CMkTypLibPageTab : public COptionMiniPage
{
	DECLARE_DYNCREATE(CMkTypLibPageTab)
public:
	virtual BOOL Validate();
};

//----------------------------------------------------------------
// our 'General' option property page
//----------------------------------------------------------------

extern CRuntimeClass * g_cplrTabs[];

class CMkTypLibGeneralPage : public CMkTypLibPageTab
{
	DECLARE_DYNCREATE(CMkTypLibGeneralPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	virtual void InitPage();
};

//----------------------------------------------------------------
// our option property pages
//----------------------------------------------------------------

extern CRuntimeClass * g_mtlTabs[];

//----------------------------------------------------------------
// our mktyplib option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	MkTypLib, /* name */
	szAddOnGeneric, BCID_OptHdlr_MkTypLib, /* generic mktyplib option handler */
	szAddOnGeneric, BCID_Tool_MkTypLib /* our generic associated mktyplib tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option page
	virtual UINT GetNameID() {return IDS_MKTYPLIB;}
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_mtlTabs;}

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp (UINT idProp);

	// return a 'fake' string prop
	virtual GPT GetDefStrProp (UINT idProp, CString & strVal);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// called whenever a prop has changed
	// we can use this to delete a prop if we want the fake prop instead
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal);

	// determine the validity of the property
	virtual BOOL CheckDepOK (UINT idProp);

	int GetTabDlgOrder() {return 60;}

private:
	// form a 'fake' string prop
	virtual void FormFakeStrProp (UINT idProp, CString & strVal);

END_OPTHDLR()

// MkTypLib properties
#define P_MTLNologo				0x0000
#define P_MTLIncludes			0x0001
// 0x0002 - P_MTLIncludes Add Part
// 0x0003 - P_MTLIncludes Substract Part
#define P_MTLMacros				0x0004
// 0x0005 - P_MTLMacros Add Part
// 0x0006 - P_MTLMacros Subtract Part
#define P_MTLOutputTlb			0x0007
#define P_MTLOutputInc			0x0008
#define P_MTLOutputUuid			0x0009
#define P_MTLOutputDir			0x000a
#define P_MTLMtlCompatible      0x000b
#define P_MTLOicf		    	0x000c
#define P_MTLNoClutter		    0x000d
#define P_MTLUnknownOption		0x000e
#define P_MTLUnknownString		0x000f

// MkTypLib options (option ids)				   
#define IDOPT_MTLNOLOGO			IDOPT_BASE + 0
#define IDOPT_MTLINCLUDES 		IDOPT_BASE + 1
#define IDOPT_MTLIGNINC			IDOPT_BASE + 2
#define IDOPT_MTLMACROS			IDOPT_BASE + 3
#define IDOPT_MTLOUTPUTTLB		IDOPT_BASE + 4
#define IDOPT_MTLOUTPUTINC		IDOPT_BASE + 5
#define IDOPT_MTLOUTPUTUUID		IDOPT_BASE + 6
#define IDOPT_MTLMTLCOMPATIBLE	IDOPT_BASE + 7
#define IDOPT_MTLOICF   		IDOPT_BASE + 8
#define IDOPT_MTLOUTPUTDIR		IDOPT_BASE + 9
#define IDOPT_MTLNOCLUTTER   	IDOPT_BASE + 10

#endif // _INCLUDE_OTPTNMTL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnrc.cpp ===
// 
// Resource Compiler Tool Options
//
// [matthewt]
//

#include "stdafx.h"	// our standard AFX include
#pragma hdrstop
#include "optnrc.h"	// our local header file

BEGIN_OPTSTR_TABLE(ResCompiler, P_ResUnknownOption, P_ResUnknownString, P_ResVerbose, P_ResUnknownString, FALSE)
	IDOPT_RESLANGID,		"l[ ]%1",	OPTARGS1(P_ResLangID),		single,
	IDOPT_DERIVED_OPTHDLR,		"",		NO_OPTARGS,					single,
	IDOPT_RESVERBOSE,		"v%T1",		OPTARGS1(P_ResVerbose),		single,
	IDOPT_RESIGNINC,		"x%T1",		OPTARGS1(P_ResIgnIncPath), 	single,
	IDOPT_OUTDIR_RES,		"fo%1",		OPTARGS1(P_OutNameRes),		single,
	IDOPT_RESINCLUDES,		"i[ ]%1",	OPTARGS1(P_ResIncludes),	multiple,
	IDOPT_RESMACROS,		"d[ ]%1",	OPTARGS1(P_ResMacroNames),	multiple,
	IDOPT_UNKNOWN_OPTION,	"",			NO_OPTARGS,					single,
	IDOPT_UNKNOWN_STRING,	"",			NO_OPTARGS,					single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(ResCompiler)
	OPTDEF_BOOL(ResVerbose, FALSE)
	OPTDEF_BOOL(ResIgnIncPath, FALSE)
	OPTDEF_PATH(OutNameRes, "")
	OPTDEF_DIR_LIST(ResIncludes, "")
	OPTDEF_LIST(ResMacroNames, "")
	OPTDEF_HEX(ResLangID, 0x00)
END_OPTDEF_MAP()

IMPLEMENT_DYNCREATE(CResCompilerPage, COptionMiniPage)
IMPLEMENT_DYNCREATE(CResCompilerGeneralPage, CResCompilerPage)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////
// string constant definitions
const TCHAR * CResCompilerPage::strOutputExtension = _TEXT("res");

////////////////////////////////////////////////////
// GetOutputExtension
//		returns the RC output extension, depending on the platform
//		(ie: MAC's is rsc and NT's is res
////////////////////////////////////////////////////
BOOL OPTION_HANDLER(ResCompiler)::AlwaysShowDefault(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_ResLangID);
}

BOOL OPTION_HANDLER(ResCompiler)::CheckDepOK(UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fValid = TRUE;			// valid by default

	// which prop are we checking the dep. for?
	switch (idPropL)
	{
		// only do this if language enabled for the item's platform
		case P_ResLangID:
		{
			CProjType * pProjType = ((CProjItem *)m_pSlob)->GetProjType();
			if (pProjType != (CProjType *)NULL)
			{
				const CPlatform * pPlatform = pProjType->GetPlatform();
				ASSERT (pPlatform != NULL);

				fValid = ((pPlatform->GetAttributes() & PIA_Enable_Language) != 0);
			}
			break;
		}

		default:
			break;
	}

	return fValid;
}

const CString  * OPTION_HANDLER(ResCompiler)::GetOutputExtension()
{
	CProjType * pProjType = ((CProjItem *)m_pSlob)->GetProjType();
	if (pProjType != (CProjType *)NULL)
	{
		const CPlatform * pPlatform = pProjType->GetPlatform();
		ASSERT (pPlatform != NULL);
		return &((pPlatform->GetToolInfo())->strRCExtension);
	}
	else
		return (const CString *)NULL;
}

// resource compiler tool option default map 'faking'
BOOL OPTION_HANDLER(ResCompiler)::IsFakeProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_OutNameRes || idPropL == P_ResIncludes || idPropL == P_ResLangID);
}

UINT OPTION_HANDLER(ResCompiler)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_OutNameRes)
		return P_OutDirs_Intermediate;

	if (idPropL == P_OutNameRes)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

void OPTION_HANDLER(ResCompiler)::FormFakeIntProp(UINT idProp, int & nVal)
{
	// ASSERT this is a Resource Compiler 'fake' string prop?
	ASSERT(IsFakeProp(idProp));

	nVal = GetUserDefaultLangID();
	return;
}

GPT OPTION_HANDLER(ResCompiler)::GetDefIntProp(UINT idProp, int & nVal)
{
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefIntProp(idProp, nVal);

	FormFakeIntProp(idProp, nVal);
	return valid;
}

void OPTION_HANDLER(ResCompiler)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_OutNameRes)
	{
		if (strVal.IsEmpty())
			m_pSlob->GetPropBag()->RemovePropAndInform(MapLogical(P_OutNameRes), m_pSlob);
	}		
}

void OPTION_HANDLER(ResCompiler)::FormFakeStrProp(UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// ASSERT this a Resource Compiler 'fake' string prop?
	ASSERT(IsFakeProp(idProp));

	if (idPropL == P_OutNameRes)
	{
		CProjItem * pItem = (CProjItem *)m_pSlob;
		
		// which output directory do we want to use?
		UINT idOutDirProp = GetFakePathDirProp(idProp);
		ASSERT(idOutDirProp != (UINT)-1);

		GPT gpt = pItem->GetStrProp(idOutDirProp, strVal);
		while (gpt != valid)
		{
			// *chain* the proper. config.
			CProjItem * pItemOld = pItem;
			pItem = (CProjItem *)pItem->GetContainerInSameConfig();
			if (pItemOld != m_pSlob)
				pItemOld->ResetContainerConfig();

			ASSERT(pItem != (CSlob *)NULL);
			gpt = pItem->GetStrProp(idOutDirProp, strVal);
		}

		// reset the last container we found
		if (pItem != m_pSlob)
			pItem->ResetContainerConfig();
	
		if (!strVal.IsEmpty())
		{
			TCHAR * pchStart = strVal.GetBuffer(1);
			TCHAR * pchT;

			pchT = pchStart + _tcslen(pchStart);	// point to nul terminator
			pchT = _tcsdec(pchStart, pchT);			// back up one char, DBCS safe

			if (*pchT != _T('\\') && *pchT != _T('/'))
				strVal += _T('/');

			strVal.ReleaseBuffer();
		}

		CString strProj, strBase;
		const CString * pstrExt = GetOutputExtension();

		CObList oblist;
		pItem->GetProject()->GetResourceFileList(oblist, TRUE,
												 (ConfigurationRecord *)pItem->GetActiveConfig()->m_pBaseRecord);

		// do we have exactly *one* buildable .RC file and a a valid extension?
		if (oblist.GetCount() != 1 || pstrExt == (const CString *)NULL)
		{
			// no .rc file in current config, so return empty string
			strVal.Empty();
			return;
		}

		// get the name of this .RC file
		VERIFY (((CProjItem *)oblist.GetHead())->GetStrProp(P_ProjItemName, strProj) == valid);
		CPath pathProj;
		VERIFY (pathProj.Create (strProj));
		pathProj.GetBaseNameString (strBase);
		strVal += strBase + _T('.') + *pstrExt;
	}
	else if (idPropL == P_ResIncludes && m_pSlob->IsKindOf (RUNTIME_CLASS(CFileItem)))
	{
		CFileItem * pFileItem = (CFileItem *)m_pSlob;

		const CPath * pPathRC = pFileItem->GetFilePath();
		CDir dirRC; dirRC.CreateFromPath(*pPathRC);

		CDir dirProj = pFileItem->GetProject()->GetWorkspaceDir();

		CString strProj = dirProj;
		strProj += _T('\\');
		
		if (dirRC != dirProj)
			strVal = GetRelativeName (dirRC, strProj);
		else
			strVal.Empty();

		// now we want to add target directory
		CString strTarget;

		strTarget.Empty();
		CProjItem * pItem = pFileItem;

		// which output directory do we want to use?
		UINT idOutDirProp = P_OutDirs_Target;	// note: hard-coded
		ASSERT(idOutDirProp != (UINT)-1);

		GPT gpt = pItem->GetStrProp(idOutDirProp, strTarget);
		while (gpt != valid)
		{
			// *chain* the proper. config.
			CProjItem * pItemOld = pItem;
			pItem = (CProjItem *)pItem->GetContainerInSameConfig();
			if (pItemOld != m_pSlob)
				pItemOld->ResetContainerConfig();

			ASSERT(pItem != (CSlob *)NULL);
			gpt = pItem->GetStrProp(idOutDirProp, strTarget);
		}

		// reset the last container we found
		if (pItem != m_pSlob)
			pItem->ResetContainerConfig();

		// file registry for this target?
		CFileRegistry * pregistry = pFileItem->GetRegistry();
		CTargetItem * pTarget = pFileItem->GetTarget();

		CObList obFilelist;
		pregistry->GetFileItemList(pTarget, pregistry->GetODLFileList(), obFilelist, TRUE, pItem->GetActiveConfig());

		if (gpt == valid && !strTarget.IsEmpty() && !obFilelist.IsEmpty())
		{
			if (!strVal.IsEmpty())
				strVal += _T(',');
			strVal += strTarget;
		}
	}

}

GPT OPTION_HANDLER(ResCompiler)::GetDefStrProp(UINT idProp, CString & val)
{
	// can we ignore the output directories?
	if (!IsFakeProp(idProp))
		return COptionHandler::GetDefStrProp(idProp, val);

	FormFakeStrProp(idProp, val);
	return valid;
}

// resource compiler option property page

DWORD rgLangID[] = 
{
	0x0401, 	0x0402, 	0x0403, 	0x0404,
	0x0804, 	0x0405, 	0x0406, 	0x0407,
 	0x0807, 	0x0408, 	0x0409, 	0x0809,
 	0x0c09, 	0x1009, 	0x040a, 	0x080a,
 	0x0c0a, 	0x040b, 	0x040c, 	0x080c,
	0x0c0c, 	0x100c, 	0x040d, 	0x040e,
 	0x040f, 	0x0410, 	0x0810, 	0x0411,
  	0x0412, 	0x0413, 	0x0813, 	0x0414,
	0x0814, 	0x0415, 	0x0416, 	0x0816,
	0x0417, 	0x0418, 	0x0419, 	0x041a,
 	0x081a, 	0x041b, 	0x041c, 	0x041d,
 	0x041e, 	0x041f, 	0x0420, 	0x0421
};
#define rgLangID_MAX (sizeof(rgLangID) / sizeof(DWORD))

CEnumLangID AFX_DATA_EXPORT LangIDEnum;

void CEnumLangID::FillComboBox(CComboBox* pWnd, BOOL bClear, CSlob* pSlob)
{
	ASSERT(pWnd != NULL);
	ASSERT(pSlob != NULL);
 
 	char sz [101];
 
	pWnd->SetRedraw(FALSE);

	if (bClear)
		pWnd->ResetContent();

	for (int i = 0 ; i < rgLangID_MAX ; i++)
	{
		VerLanguageName(rgLangID[i], sz, 100);
		pWnd->SetItemData(pWnd->AddString(sz), rgLangID[i]);
 	}

	pWnd->SetRedraw();
	pWnd->Invalidate();
}


//////////////////////////////////////////////////////
void CResCompilerGeneralPage::InitPage()
{
	COptionMiniPage::InitPage() ;

	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	if (!((CProxySlob *)m_pSlob)->IsSingle())
	{
		GetDlgItem (IDC_RESOUTNAME)->EnableWindow (FALSE) ;
		GetDlgItem (IDC_REST1)->EnableWindow (FALSE) ;
	}

	// (Use the CProxySlob platform enumeration in case of multi-selection)
	// This is to decide whether we want to hide the language option or not in the 
	// RC option page.
	// We should hide if any of the platform does not support the (/I) option
	BOOL bEnableLanguage = TRUE;	// multi-selection of items' platform supports the language option (/I)

	((CProxySlob *)m_pSlob)->InitPlatformEnum();
	const CPlatform * pPlatform;
	while ((pPlatform = ((CProxySlob *)m_pSlob)->NextPlatform()) != (const CPlatform *)NULL)
		bEnableLanguage = bEnableLanguage && ((pPlatform->GetAttributes() & PIA_Enable_Language) != 0);

	GetDlgItem (IDC_REST4)->ShowWindow (bEnableLanguage);
}

BOOL CResCompilerGeneralPage::OnPropChange (UINT idProp)
{	  
	UINT idPropL = MapActual(idProp);

	ASSERT (m_pSlob->IsKindOf (RUNTIME_CLASS (CProxySlob))) ;
	if (idPropL == P_OutNameRes)
		GetDlgItem (IDC_REST1)->EnableWindow (((CProxySlob *)m_pSlob)->IsSingle());

	return CResCompilerPage::OnPropChange(idProp);
}

BOOL CResCompilerPage::Validate()
{
	if (m_nValidateID == IDC_RESOUTNAME)
	{
		if (!Validate_Destination(IDC_RESOUTNAME, IDS_DEST_RES,
							  	  GetOutputExtension(),	// must have extension
							  	  FALSE,	// must be directory
							  	  TRUE))	// cant be directory
			return FALSE;
	}

	if (m_nValidateID == IDC_OPTSTR)
	{
		return Validate_DestinationProp(P_OutNameRes, IDOPT_OUTDIR_RES,
										IDC_OPTSTR, IDS_DEST_RES,
									    GetOutputExtension(),	// must have extension
									    FALSE,	// must be directory
									    TRUE);	// cant be directory
	}

	if (IDC_RESINCLUDES==m_nValidateID)
	{
		//
		// Strip quotes.
		//
		CString strOption;
		CWnd * pWnd = GetDlgItem(m_nValidateID);
		ASSERT(pWnd != (CWnd *)NULL);
		pWnd->GetWindowText(strOption);

		int index;

		while (-1 != (index=strOption.Find('"')) )
		{
			CString Left;
			CString Right;

			if (0!=index)
				Left = strOption.Left(index);

			if (index+1 < strOption.GetLength())
				Right = strOption.Mid(index+1);

			strOption = Left + Right;
		}

		pWnd->SetWindowText(strOption);
	}

	return COptionMiniPage::Validate();
}

// rc tool option property page
CRuntimeClass * g_rcTabs[] = 
{
	RUNTIME_CLASS(CResCompilerGeneralPage),
	(CRuntimeClass *)NULL,
};

BEGIN_IDE_CONTROL_MAP(CResCompilerGeneralPage, IDDP_PROJ_RESCOMPILE, IDS_RESCOMPILER32)
	MAP_CHECK(IDC_RESIGNPATH, P_ResIgnIncPath)
	MAP_EDIT(IDC_RESOUTNAME, P_OutNameRes)
	MAP_EDIT(IDC_RESINCLUDES, P_ResIncludes)
	MAP_EDIT(IDC_RESMACNAMES, P_ResMacroNames)
	MAP_COMBO_LIST(IDC_RESLANGID, P_ResLangID, LangIDEnum)
END_IDE_CONTROL_MAP()

BEGIN_OPTSTR_TABLE(ResCompilerNT, (UINT)NULL, (UINT)NULL, (UINT)NULL, (UINT)NULL, FALSE)
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP(ResCompilerNT)
END_OPTDEF_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnrc.h ===
//
// Resource Compiler Tool Options
//
// [matthewt]
//

#ifndef _INCLUDE_OPTNRC_H
#define _INCLUDE_OPTNRC_H

#include "projprop.h"	// our option property ids
#include "prjoptn.h"	// macros used to decl/defn our tables
#include "optnrc.h2"	// our option control IDs

//----------------------------------------------------------------
// our resource compiler tool option property pages
//----------------------------------------------------------------

class BLD_IFACE CResCompilerPage : public COptionMiniPage
{
	DECLARE_DYNCREATE(CResCompilerPage)
public:
	virtual BOOL Validate();
private:
	static const TCHAR *strOutputExtension ;
	
	// get the output extension
	virtual const TCHAR *GetOutputExtension() {return strOutputExtension;};

};

//----------------------------------------------------------------
// our 'General' option property page
//----------------------------------------------------------------

class BLD_IFACE CResCompilerGeneralPage : public CResCompilerPage
{
	DECLARE_DYNCREATE(CResCompilerGeneralPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	virtual void InitPage() ; 
	virtual BOOL OnPropChange(UINT nProp) ;
};

//----------------------------------------------------------------
// our option property pages
//----------------------------------------------------------------

extern CRuntimeClass * g_rcTabs[];

//----------------------------------------------------------------
// our COMMON resource compiler option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	ResCompiler, /* name */
	szAddOnGeneric, BCID_OptHdlr_RcCompiler, /* generic resource compiler option handler */
	szAddOnGeneric, BCID_Tool_RcCompiler /* generic resource compiler tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option pages
	virtual UINT GetNameID() {return IDS_RESCOMPILER32;}
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_rcTabs;}

	// check deps.
	virtual BOOL CheckDepOK(UINT idProp);

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// return a 'fake' string prop
	virtual GPT GetDefStrProp(UINT idProp, CString & strVal);

	// always show this?
	virtual BOOL AlwaysShowDefault(UINT idProp);

	// return a 'fake' int prop
	virtual GPT GetDefIntProp(UINT idProp, int & nVal);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// called whenever a prop has changed
	// we can use this to delete a prop if we want the fake prop instead
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal) ;

	// get the output extension
	const CString *GetOutputExtension();

	int GetTabDlgOrder()
		{ return 50; }
		
private:
	// form a 'fake' string prop
	virtual void FormFakeIntProp(UINT idProp, int & nVal);
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);

	BOOL m_fEnableLangID;

END_OPTHDLR()

// resource compiler properties
#define P_ResVerbose					 0x0000
#define P_ResIgnIncPath					 0x0001
#define P_ResIncludes					 0x0002
// 0x0003 - Add P_ResIncludes
// 0x0004 - Subtract P_ResIncludes
#define P_OutNameRes					 0x0005
#define P_ResMacroNames					 0x0006
// 0x0007 - Add P_ResMacroNames
// 0x0008 - Subtract P_ResMacroNames
#define P_ResLangID						 0x0009
#define P_ResUnknownOption				 0x000a
#define P_ResUnknownString				 0x000b

// resource compiler options (option ids)
#define IDOPT_RESVERBOSE				IDOPT_BASE + 0
#define IDOPT_RESIGNINC					IDOPT_BASE + 1
#define IDOPT_RESMACROS					IDOPT_BASE + 2
#define IDOPT_RESINCLUDES				IDOPT_BASE + 3
#define IDOPT_OUTDIR_RES				IDOPT_BASE + 4
#define IDOPT_RESLANGID					IDOPT_BASE + 5

class BLD_IFACE CEnumLangID : public CEnum
{
public:
	virtual void FillComboBox(CComboBox* pWnd, BOOL bClear = TRUE, CSlob* pSlob = NULL);
};

extern BLD_IFACE CEnumLangID LangIDEnum;

// option handler
DEFN_OPTHDLR_PLATFORM
(
	ResCompilerNT, /* name */
	szAddOnGeneric, BCID_OptHdlr_RcCompilerNT, /* generic NT resource compiler option handler */
	szAddOnGeneric, BCID_Tool_RcCompilerNT, /* generic NT resource compiler tool */
	szAddOnGeneric, BCID_OptHdlr_RcCompiler /* base generic resource compiler option handler */
)
	
	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()
 
END_OPTHDLR()

#endif // _INCLUDE_OPTNRC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnlink.h ===
//
// Linker Tool Options
//
// [matthewt]
//

#ifndef _INCLUDE_OPTNLINK_H
#define _INCLUDE_OPTNLINK_H

#include "projprop.h"	// our option property ids
#include "prjoptn.h"	// macros used to decl/defn our tables
#include "optnlink.h2"	// our option control IDs

//----------------------------------------------------------------
// our linker tool option property pages
//----------------------------------------------------------------

class BLD_IFACE CLinkerPageTab : public COptionMiniPage
{
	DECLARE_DYNCREATE(CLinkerPageTab)
public:
	virtual BOOL Validate();
};

//----------------------------------------------------------------
// our 'General' option property page
//----------------------------------------------------------------

class CLinkerGeneralPage : public CLinkerPageTab
{
	DECLARE_DYNCREATE(CLinkerGeneralPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
};

//----------------------------------------------------------------
// our option property pages
//----------------------------------------------------------------

extern CRuntimeClass * g_linkTabs[];

//----------------------------------------------------------------
// our COMMON linker option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_COMMON
(
	LinkerCommon, /* name */
	szAddOnGeneric, BCID_OptHdlr_Linker, /* generic linker option handler */
	szAddOnGeneric, BCID_Tool_Linker /* generic linker tool tool */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// our option pages
	virtual UINT GetNameID() {return IDS_LINKCOFF;}
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_linkTabs;}

	// is this a default of one of our 'fake' string props?
	// (we need special handling here)
	virtual BOOL IsDefaultStringProp(UINT idProp, CString & strVal);

	// is this a 'fake' prop?
	virtual BOOL IsFakeProp(UINT idProp);

	// should this be shown always?
	virtual BOOL AlwaysShowDefault(UINT idProp);

	// return a 'fake' string prop
	virtual GPT GetDefStrProp(UINT idProp, CString & strVal);
	virtual GPT GetDefIntProp(UINT idProp, int & nVal);

	// return a 'output dir' prop
	virtual UINT GetFakePathDirProp(UINT idProp);

	// provide invalidation of option props
	virtual BOOL CheckDepOK(UINT idProp);

	// called whenever a prop has changed
	// we can use this to delete a prop if we want the fake prop instead
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal);
	virtual void OnOptionIntPropChange(UINT idProp, int nVal);

	int GetTabDlgOrder()
		{ return 40; }
		
private:
	// form a 'fake' string prop
	virtual void FormFakeStrProp(UINT idProp, CString & strVal);
	virtual void FormFakeIntProp(UINT idProp, int & nVal) ;

	BOOL m_fProjIsDll;	// HACK: for /DLL munging of /OUT:

END_OPTHDLR()

#define P_LinkNoLogo			0x0000
#define P_LinkVerbose			0x0001
#define P_GenMap				0x0002
#define P_MapName				0x0003
#define P_GenDebug				0x0004
#define P_DebugType				0x0005
#define P_NoDefaultLibs			0x0006
// 0x0007 - Add P_NoDefaultLibs
// 0x0008 - Subtract P_NoDefaultLibs
#define P_DefName				0x0009
#define P_Force					0x000b
#define P_OutName				0x000c
#define P_IncludeSym			0x000d
// 0x000e - Add P_IncludeSym
// 0x000f - Subtract P_IncludeSym
#define P_ExAllLibs				0x0010
#define P_ImpLibName			0x0011
#define P_GenDll				0x0012
#define P_IncrementalLink		0x0013
#define P_UsePDB				0x0014
#define P_UsePDBName			0x0015
#define P_Profile				0x0016
#define P_MachineType			0x0017
#define P_IgnoreExportLib		0x0018
#define P_LazyPdb				0x0019
#define P_LibPath				0x001a
// 0x001b - Add P_LibPath				
// 0x001c - Subtract P_LibPath				
#define P_LinkUnknownOption		0x001d
#define P_LinkUnknownString		0x001e


// linker tool options (option ids)
#define IDOPT_LINKNOLOGO				IDOPT_BASE + 9
#define IDOPT_LINKVERBOSE				IDOPT_BASE + 0
#define IDOPT_MAPGEN					IDOPT_BASE + 1
#define IDOPT_DEBUG						IDOPT_BASE + 2
#define IDOPT_DEBUGTYPE					IDOPT_BASE + 3
#define IDOPT_EXALLLIB					IDOPT_BASE + 4
#define IDOPT_DEFNAME					IDOPT_BASE + 5
#define IDOPT_LIBPATH					IDOPT_BASE + 6
#define IDOPT_FORCE						IDOPT_BASE + 7
#define IDOPT_OUT						IDOPT_BASE + 8
#define IDOPT_NOLOGO					IDOPT_BASE + 9
#define IDOPT_NODEFAULTLIB				IDOPT_BASE + 10
#define IDOPT_INCLUDESYM				IDOPT_BASE + 11
#define IDOPT_IMPLIB					IDOPT_BASE + 12
#define IDOPT_DLLGEN					IDOPT_BASE + 13
#define IDOPT_INCREMENTALLINK			IDOPT_BASE + 14
#define IDOPT_USEPDB					IDOPT_BASE + 15
#define IDOPT_USEPDBLINK				IDOPT_BASE + 16
#define IDOPT_USEPDBNONE				IDOPT_BASE + 17
#define IDOPT_LAZYPDB					IDOPT_BASE + 18
#define IDOPT_PROFILE					IDOPT_BASE + 19
#define IDOPT_MACHINETYPE				IDOPT_BASE + 20
#define IDOPT_IGNOREEXPORTLIB			IDOPT_BASE + 21

//
// linker tool 'Advanced' option tabs
//

class CLinkerDebugPage : public CLinkerPageTab
{
	DECLARE_DYNCREATE(CLinkerDebugPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
	virtual BOOL Validate();
};

class CLinkerCustomPage : public CLinkerPageTab
{
	DECLARE_DYNCREATE(CLinkerCustomPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
	virtual BOOL Validate();
};

class CLinkerInputPage : public CLinkerPageTab
{
	DECLARE_DYNCREATE(CLinkerInputPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	virtual void InitPage();
};

//----------------------------------------------------------------
// our NT Linker property pages
//----------------------------------------------------------------

extern CRuntimeClass * g_linkNTTabs[];

//----------------------------------------------------------------
// our 'Win32 Output' option property page
//----------------------------------------------------------------

class CLinkerWin32OutputPage : public CLinkerPageTab
{
	DECLARE_DYNCREATE(CLinkerWin32OutputPage)
	DECLARE_IDE_CONTROL_MAP()
public:
	// special handling of property changes
	virtual BOOL OnPropChange(UINT);
};

//----------------------------------------------------------------
// out NT linker option data
//----------------------------------------------------------------

// option handler
DEFN_OPTHDLR_PLATFORM
(
	LinkerNT, /* name */
	szAddOnGeneric, BCID_OptHdlr_LinkerNT, /* generic NT linker option handler */
	szAddOnGeneric, BCID_Tool_LinkerNT, /* generic NT linker tool */
	szAddOnGeneric, BCID_OptHdlr_Linker /* base generic linker option handler */
)

	DECL_OPTSTR_TABLE()
	DECL_OPTDEF_MAP()

public:
	// out option pages
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return g_linkNTTabs;}

	// should this be shown always?
	virtual BOOL AlwaysShowDefault(UINT idProp);

	// provide invalidation of option props
	virtual BOOL CheckDepOK(UINT idProp);

END_OPTHDLR()

// NT linker tool properties
#define P_VersionMaj			0x1000
#define P_VersionMin			0x1001
#define P_StackReserve			0x1002
#define P_StackCommit			0x1003
#define P_BaseAddr				0x1004
#define P_EntryName				0x1005
#define P_SubSystem				0x1006

// NT linker tool options (option ids)
#define IDOPT_VERSION					IDOPT_BASE + 0
#define IDOPT_STACK						IDOPT_BASE + 1
#define IDOPT_EXE_BASE					IDOPT_BASE + 2
#define IDOPT_ENTRYPOINT				IDOPT_BASE + 3
#define IDOPT_SUBSYSTEM					IDOPT_BASE + 4

#endif // _INCLUDE_OPTN_LINK_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnmtl.cpp ===
//
// MkTypLib Tool Options
//
//

#include "stdafx.h" // standard AFX include
#pragma hdrstop
#include "optnmtl.h" // local header file

BEGIN_OPTSTR_TABLE (MkTypLib, P_MTLUnknownOption, P_MTLUnknownString, P_MTLNologo, P_MTLUnknownString, FALSE)
	IDOPT_MTLNOLOGO,		"nologo%T1",		OPTARGS1(P_MTLNologo),			single,
	IDOPT_MTLINCLUDES,		"I[ ]%1",			OPTARGS1(P_MTLIncludes),		multiple,
	IDOPT_MTLMACROS,		"D[ ]%1",			OPTARGS1(P_MTLMacros), 			multiple,
	IDOPT_MTLOUTPUTTLB,		"tlb[ ]%1",			OPTARGS1(P_MTLOutputTlb),		single,
	IDOPT_MTLOUTPUTINC,		"h[ ]%1",			OPTARGS1(P_MTLOutputInc),		single,
	IDOPT_MTLOUTPUTUUID,	"iid[ ]%1",			OPTARGS1(P_MTLOutputUuid),		single,
	IDOPT_MTLOUTPUTDIR,		"out[ ]%1",			OPTARGS1(P_MTLOutputDir),		single,
	IDOPT_MTLMTLCOMPATIBLE,	"mktyplib203%T1",	OPTARGS1(P_MTLMtlCompatible), 	single,
	IDOPT_MTLOICF,			"Oicf%T1",			OPTARGS1(P_MTLOicf), 		single,
	IDOPT_MTLNOCLUTTER,		"o[ ]%1",			OPTARGS1(P_MTLNoClutter), 		single,
	IDOPT_UNKNOWN_OPTION,		"",				NO_OPTARGS,						single,
	IDOPT_UNKNOWN_STRING,		"",				NO_OPTARGS,						single,
END_OPTSTRTBL()

BEGIN_OPTDEF_MAP (MkTypLib)
	OPTDEF_BOOL(MTLNologo, FALSE)
	OPTDEF_LIST(MTLIncludes, "")
	OPTDEF_LIST(MTLMacros, "") 
	OPTDEF_PATH(MTLOutputTlb, "")
	OPTDEF_PATH(MTLOutputInc, "")
	OPTDEF_PATH(MTLOutputUuid, "")
	OPTDEF_PATH(MTLOutputDir, "")
	OPTDEF_BOOL(MTLMtlCompatible, FALSE)
	OPTDEF_BOOL(MTLOicf, FALSE)
	OPTDEF_PATH(MTLNoClutter, "")
END_OPTDEF_MAP()

IMPLEMENT_DYNCREATE(CMkTypLibPageTab, COptionMiniPage)
IMPLEMENT_DYNCREATE(CMkTypLibGeneralPage, CMkTypLibPageTab)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////
BOOL OPTION_HANDLER(MkTypLib)::IsFakeProp (UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	return (idPropL == P_MTLOutputTlb);
}

//////////////////////////////////////////////////////////////
UINT OPTION_HANDLER(MkTypLib)::GetFakePathDirProp(UINT idProp)
{
	UINT idPropL = MapActual(idProp);

	if (idPropL == P_MTLOutputTlb)
		return P_OutDirs_Target;

	return COptionHandler::GetFakePathDirProp(idProp);
} 

//////////////////////////////////////////////////////////////
void OPTION_HANDLER(MkTypLib)::OnOptionStrPropChange(UINT idProp, const CString & strVal)
{
}

//////////////////////////////////////////////////////////////
void OPTION_HANDLER (MkTypLib)::FormFakeStrProp (UINT idProp, CString & strVal)
{
	UINT idPropL = MapActual(idProp);

	// ASSERT this is a MkTypLib 'fake' string prop ?
	ASSERT (IsFakeProp (idProp));
	
	// get the project base-name (ie. without extension)
	CString strProj, strBase;
	CPath pathProj;
	const TCHAR * pchT;

	if ((m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)) &&
	     ((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CFileItem)))
		||
		m_pSlob->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		if (idPropL == P_MTLOutputTlb)
		{
			VERIFY(m_pSlob->GetStrProp(P_ProjItemName, strProj) == valid);
			VERIFY(pathProj.Create(strProj));
			pathProj.GetBaseNameString(strBase);
	
			// which output directory do we want to use?
			UINT idOutDirProp = GetFakePathDirProp(idProp);
			ASSERT(idOutDirProp != (UINT)-1);

			CProjItem * pItem = (CProjItem *)m_pSlob;
			GPT gpt = pItem->GetStrProp(idOutDirProp, strVal);
			while (gpt != valid)
			{
				// *chain* the proper. config.
				CProjItem * pItemOld = pItem;
				pItem = (CProjItem *)pItem->GetContainerInSameConfig();
				if (pItemOld != m_pSlob)
					pItemOld->ResetContainerConfig();

				ASSERT(pItem != (CSlob *)NULL);
				gpt = pItem->GetStrProp(idOutDirProp, strVal);
			}

			// reset the last container we found
			if (pItem != m_pSlob)
				pItem->ResetContainerConfig();

			if (!strVal.IsEmpty())
			{
				// If the output directory doesn't end in a forward slash
				// or a backslash, append one.
				pchT = (const TCHAR *)strVal + strVal.GetLength();
				pchT = _tcsdec((const TCHAR *)strVal, (TCHAR *)pchT);

				if (*pchT != _T('/') && *pchT != _T('\\'))
					strVal += _T('/');
			}

			strVal += strBase + _TEXT(".tlb") ;
		}
		else ASSERT (FALSE) ;
	}
	else
		strVal.Empty() ;
}

/////////////////////////////////////////////////////////////////////////
GPT OPTION_HANDLER (MkTypLib)::GetDefStrProp(UINT idProp, CString & val)
{
	if (!IsFakeProp (idProp))
		return COptionHandler::GetDefStrProp(idProp, val) ;	

	FormFakeStrProp (idProp, val) ;
	return valid ;
}
/////////////////////////////////////////////////////////////////////////
BOOL OPTION_HANDLER (MkTypLib)::CheckDepOK (UINT idProp)
{
	UINT idPropL = MapActual(idProp);
	BOOL fValid = TRUE;

	if (idPropL == P_MTLOutputTlb || idPropL == P_MTLOutputInc|| idPropL == P_MTLOutputUuid)
	{
		fValid = m_pSlob->IsKindOf (RUNTIME_CLASS (CFileItem)) ||
				 (m_pSlob->IsKindOf (RUNTIME_CLASS (CProxySlob)) &&
				  ((CProxySlob *)m_pSlob)->IsSortOf (RUNTIME_CLASS (CFileItem)));
	}
	return fValid;
} 
		
// MkTypLib tool option property page
CRuntimeClass * g_mtlTabs[] = 
{
	RUNTIME_CLASS(CMkTypLibGeneralPage),
	(CRuntimeClass *)NULL,
};

// MkTypLib option property page

BEGIN_IDE_CONTROL_MAP (CMkTypLibGeneralPage, IDDP_PROJ_MKTYPLIB, IDS_MKTYPLIB)
	MAP_CHECK (IDC_MTLNOLOGO, P_MTLNologo)
	MAP_EDIT (IDC_MTLINCLUDES, P_MTLIncludes)
	MAP_EDIT (IDC_MTLMACROS, P_MTLMacros) 
	MAP_EDIT (IDC_MTLOUTPUTTLB, P_MTLOutputTlb)
	MAP_EDIT (IDC_MTLOUTPUTINC, P_MTLOutputInc)
	MAP_EDIT (IDC_MTLOUTPUTUUID, P_MTLOutputUuid)
	MAP_CHECK (IDC_MTLOICF, P_MTLOicf)
	MAP_CHECK(IDC_MTLCOMPATIBLE, P_MTLMtlCompatible)
END_IDE_CONTROL_MAP()

/////////////////////////////////////////////////////////////////
void CMkTypLibGeneralPage::InitPage()
{
	COptionMiniPage::InitPage();

	// we need to disable TLB and Include File dialog item
	// if we are not in CFileItem (ie. we have no container)
	ASSERT(m_pSlob->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	if (!((CProxySlob *)m_pSlob)->IsSortOf(RUNTIME_CLASS(CFileItem)) 
           )
	{
		GetDlgItem(IDC_MTLOUTPUTTLB)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_MTLOUTPUTINC)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_MTLOUTPUTUUID)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_MTLTEXT1)->EnableWindow(FALSE) ;
		GetDlgItem(IDC_MTLTEXT2)->EnableWindow(FALSE) ;
	}
}
/////////////////////////////////////////////////////////////////
BOOL CMkTypLibPageTab::Validate()
{
	if (m_nValidateID == IDC_MTLOUTPUTTLB)
	{
		if (!Validate_Destination (IDC_MTLOUTPUTTLB, // window ID
								IDS_DEST_TLB, // description stringID
								"tlb", 	// must have extension
								FALSE,	// must be directory
								TRUE))  // can't be directory
			return FALSE;
	}

	if (m_nValidateID == IDC_MTLOUTPUTINC)
	{
		if (!Validate_Destination (IDC_MTLOUTPUTINC, // window ID
								IDS_DEST_INCLUDE, // description string ID
								"h",	// must have extension
								FALSE, 	// must be directory
								TRUE)) // can't be directory
			return FALSE;
	}

	if (m_nValidateID == IDC_MTLOUTPUTUUID)
	{
		if (!Validate_Destination (IDC_MTLOUTPUTUUID, // window ID
								IDS_DEST_UUID, // description string ID
								"c",	// must have extension
								FALSE, 	// must be directory
								TRUE)) // can't be directory
			return FALSE;
	}

	if (m_nValidateID == IDC_OPTSTR)
	{
		// validate tlb file first, then check for include file as well
		if (!Validate_DestinationProp (MapLogical(P_MTLOutputTlb),
									IDOPT_MTLOUTPUTTLB,
									IDC_OPTSTR, IDS_DEST_TLB,
									"tlb", // must have extension
									FALSE, // must be directory
									TRUE)) // can't be directory
			return FALSE ;

		if (!Validate_DestinationProp (MapLogical(P_MTLOutputUuid),
									IDOPT_MTLOUTPUTUUID,
									IDC_OPTSTR, IDS_DEST_UUID,
									"c", // must have extension
									FALSE, // must be directory
									TRUE)) // can't be directory
			return FALSE ;

	// REVIEW: validate P_MtlOutputDir also?

		return Validate_DestinationProp (MapLogical(P_MTLOutputInc),

											IDOPT_MTLOUTPUTINC,
											IDC_OPTSTR, IDS_DEST_INCLUDE,
											"h", // must have extension
											FALSE, // must be directory
											TRUE); // can't be directory

	}
	return COptionMiniPage::Validate();
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\perftick.h ===
// CPerfTicker
// for performance timings

#ifndef __PERFTICK_H__
#define __PERFTICK_H__

#ifdef DOPERFTICK
class CPerfTicker
{
public:
	CPerfTicker(const char * pchMsg)
	{
		VERIFY(QueryPerformanceCounter((LARGE_INTEGER*)&m_liStart));
		m_pchMsg = pchMsg;
	}

	~CPerfTicker()
	{
		VERIFY(QueryPerformanceCounter((LARGE_INTEGER*)&m_liEnd));
		m_liDiff = m_liEnd - m_liStart; //LargeIntegerSubtract(m_liEnd, m_liStart);
		TRACE("CPerfTicker: '%s' is %lu ticks\n", m_pchMsg, (unsigned long)m_liDiff);
	}

private:
	__int64 m_liStart, m_liEnd, m_liDiff;
	//LARGE_INTEGER m_liStart, m_liEnd, m_liDiff;
	const char * m_pchMsg;
};
#else
class CPerfTicker
{
public:
	CPerfTicker(const char * pchMsg)
	{
	}

	~CPerfTicker()
	{
	}
};

#endif

#endif // __PERFTICK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnui.h ===
//
// COptionPage, COptionPageTab
//
// Option user interface.
//
// [matthewt]
//				   

#ifndef _INCLUDE_OPTIONUI_H										
#define _INCLUDE_OPTIONUI_H

#ifndef _SUSHI_PROJECT
// If you are including this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

#include "slob.h"		// CSlob and CPropBag def'n
#include "dlgbase.h"		// CDlgTab
#include "tabpage.h"	// CSlobPageTab
#include "dllgrid.h"	// CDLLGridWnd

#include "resource.h"	// our resource IDs

// our tool options tab for
// use as a frame for tool option property pages
// it'll also handle 
// o selection of pages
// o handling of set default
// o handling of direct editing of options string

class COptionMiniPage;
class CProxySlob;
class BLD_IFACE CToolOptionTab : public CDlgTab
{
	DECLARE_DYNAMIC(CToolOptionTab)

public:
	// supply the title of the tab, ie. 'C/C++ Compiler'
	CToolOptionTab(UINT nIDTitle) :
		CDlgTab(IDD_TOOL_OPTION_TAB, nIDTitle)
	{
		m_nCurrPage = UINT(-1); /* not active yet */
		m_popthdlr = (COptionHandler *)NULL;
		m_pcboMiniPage = (CComboBox *)NULL;
		m_pProxySlob = (CProxySlob *)NULL;
		m_fRefresh = TRUE;
	}

	~CToolOptionTab() {RemoveAllPages();}

	// page activation, deactivation and selection
	BOOL ActivatePage(UINT nPage);
	void DeactivatePage(UINT nPage);
	void SelectPage(UINT nPage);
	void Refresh();

	// remembering/seeting the current mini-page (category-page)
	BOOL SetCurrentMiniPage(CString & strTitle);
	BOOL GetCurrentMiniPage(CString & strTitle);

	// make sure the approp. controls are disabled/enabled etc.	
	void UpdateState();

	// the CToolOptionTab will delete these pages, client should create
	BOOL AddOptionPage(COptionMiniPage * pPage);

	void RemoveAllPages();
	__inline COptionMiniPage * GetOptionPage(UINT nPage)
	{
		ASSERT(0 <= (int)nPage && (int)nPage < m_rgPages.GetSize());
		return (COptionMiniPage *)m_rgPages[nPage];
	}

	// set the option handler to use while
	// this tab is up (doesn't need to be set)
	__inline void SetOptionHandler(COptionHandler * popthdlr) 
	{ m_popthdlr = popthdlr; m_nOrder = popthdlr->GetTabDlgOrder();}

	__inline COptionHandler * GetOptionHandler() {return m_popthdlr;}

	// return our caption
	__inline CString * GetCaption() {return &m_strCaption;}

	BOOL m_fRefresh;

protected:
	// make sure the page is a created Windows dialog
	COptionMiniPage * CreatePage(UINT nPage);

	DECLARE_MESSAGE_MAP()

	virtual BOOL OnInitDialog();
	virtual LRESULT OnOptStrEditPaint(WPARAM, LPARAM);

	//{{AFX_MSG(CToolOptionTab)
	afx_msg void OnDestroy();
	afx_msg void OnMiniPageSelect();
	afx_msg void OnSetDefault();
	afx_msg void Validate_Dest();
	afx_msg void Update();
	afx_msg void OnKeyDown(UINT, UINT, UINT);
	//}}AFX_MSG

	// CDlgTab methods
	virtual BOOL Activate(CTabbedDialog * pParentWnd, CPoint position);
	virtual void Deactivate(CTabbedDialog * pParentWnd);
	virtual BOOL ValidateTab();
	
	// our COptionHandler to use
	COptionHandler * m_popthdlr;
	
private:

	// our current mini page
	UINT m_nCurrPage;
	
	// category to init. the tab category listbox 
	CString m_strInitCategory;
	
	// our list of mini pages
	CObArray m_rgPages;

	// our comobo box control used to select a mini-page
	CComboBox * m_pcboMiniPage;

	// our parent's (a tabbed dialog) CProxySlob
	CProxySlob * m_pProxySlob;

	// top of al pages to be created
	int m_cyPageTop;

	// Refresh 	m_pcboMiniPage value to make sure it is valid.
	BOOL ValidateMiniPageComboBox()
	{ 
		m_pcboMiniPage = (CComboBox *)GetDlgItem(IDC_MINI_PAGE);
		return (NULL!=m_pcboMiniPage);
	}
};

// our tool options property page for
// any tool options, eg. output directories

class COptionWatcher : public CSlob
{
public:
	void OnInform(CSlob *, UINT, DWORD);
	COptionMiniPage * m_pOptionPage;
};

class COptsDebugTab;
class BLD_IFACE COptionMiniPage : public CDialog
{
friend class COptionWatcher;

	DECLARE_DYNAMIC(COptionMiniPage)
	DECLARE_IDE_CONTROL_MAP()
	DECLARE_MESSAGE_MAP()

public:
	COptionMiniPage();
	~COptionMiniPage();

	// mini-page creation
	// o requires parent dialog
	BOOL Create(CToolOptionTab * pParent);
	BOOL Create(COptsDebugTab * pParent);

	// setup our 
	// o CSlob
	// o associated option handler (if we have one) for init. control map
	BOOL SetupPage(CSlob * pSlob, COptionHandler * popthdlr = (COptionHandler *)NULL);

	// get our CSlob for this CSlobPageTab
	__inline CSlob * GetSlob() {return m_pSlob;}

	virtual BOOL OnInitDialog();

	// initialization and termination of the property page
	virtual void InitPage();
	virtual void TermPage();

	// hook into property value changing
	virtual BOOL OnCommand(UINT wParam, LONG lParam);
	virtual BOOL OnPropChange(UINT nProp);

	// contol map dialog id and name extraction
	int GetDlgID() {return GetControlMap()->m_nCtlID;}
	UINT GetNameID();
	void GetName(CString& strName);

	// property mapping
	__inline UINT MapLogical(UINT idProp) {return m_popthdlr->MapLogical(idProp);}
	__inline UINT MapActual(UINT idProp) {return m_popthdlr->MapActual(idProp);}

	// property value validation
	virtual BOOL Validate();
 	virtual BOOL Validate_DestinationProp
				(UINT idProp, UINT idOption, UINT idEditDest, UINT idMsg,
				 const TCHAR * pchExt, BOOL fMustBeDir, BOOL fCantBeDir);	
	virtual BOOL Validate_Destination
				(UINT idEditDest, UINT idMsg, const TCHAR * pchExt, BOOL fMustBeDir, BOOL fCantBeDir);	

	virtual BOOL PreTranslateMessage(MSG* pMsg);

	LONG OnValidateReq(UINT, LONG);
	int m_nValidateID;

	// control map searching
	CControlMap* FindControl(UINT nCtlID);
	CControlMap* FindProp(UINT nProp);

	// currently validating?
	BOOL m_isValidating;

	UINT m_nCurrentEditID;

private:
	virtual void OnOK();
	virtual void OnCancel();

protected:
	// Our Check-List we substitute by sub-classing
	// listboxes requiring a check-list in the prop. page
	CPropCheckList m_PropCheckList;
	
	// Our slob which is used to store/retrieve properties to/from
	// You'll need to handle the commit semantics yourself.
	// ie. On Cancel undo property changes to this CSlob, or
	// on OK commit changes from a tmp. CSlob (this one) into the actual one
	CSlob* m_pSlob;
																						
	// Our option 'watcher' CSlob
	COptionWatcher m_optionWatcher;

	// A cache of Check-List objects
	CPtrList m_listCheckList;

	CToolOptionTab * m_pToolOptionTab;
 	COptionHandler * m_popthdlr;

private:
	BOOL m_bIgnoreChange;
	BOOL m_bGotSlobHook;
};

//----------------------------------------------------------------
// our debug option property pages
//----------------------------------------------------------------
class CDebugPageTab : public COptionMiniPage
{
public:
	CDebugPageTab() { m_fPageInitialized = FALSE; }
	~CDebugPageTab() {}
	virtual BOOL Validate();
	virtual BOOL FCanResetPropsForConfig()	{ ASSERT (FALSE); return FALSE; }
	virtual void ResetPropsForConfig()  { ASSERT (FALSE); }
	virtual void CommitPage() = 0;

protected:
	BOOL m_fPageInitialized;
};

//----------------------------------------------------------------
// our 'General' option property page
//----------------------------------------------------------------

class CDebugGeneralPage : public CDebugPageTab
{
	DECLARE_IDE_CONTROL_MAP()
public:
	void InitPage();
	virtual BOOL Validate();
	virtual void CommitPage();

	virtual BOOL OnInitDialog();

	void OnDebugBrowse();
	void OnUseWebBrowser();
	void OnUseTestContainer();

// Implementation
protected:
	DECLARE_MESSAGE_MAP()

private:
	CMenuBtn m_btnExeFinder;
};

//----------------------------------------------------------------
// our 'Additional DLLs' option property page
//----------------------------------------------------------------

class CDebugAdditionalDllPage : public CDebugPageTab
{
	DECLARE_IDE_CONTROL_MAP()
	DECLARE_MESSAGE_MAP()
public:

	// special handling of property changes
	virtual void InitPage();
	virtual void TermPage();
	virtual BOOL OnInitDialog();
	virtual BOOL Validate();
	BOOL Validate_UpdateAdditionalDLLs(UINT &idMsg);
	virtual void CommitPage();
	virtual void OnBrowse();
	virtual void InitGrids();
	virtual void SaveGrids();

protected:
	afx_msg void OnDestroy();

protected:
	CPtrList m_GridList;	// GridList is a list of pointers to GRIDINFOs
	CDLLGridWnd *m_pGridActive;
};

typedef struct {
	HBLDTARGET hTarget;
	CDLLGridWnd *pGrid;
} GRIDINFO;



BOOL Validate_Destination(CDialog * pDlg, UINT idEditDest, UINT idMsg,
						  const TCHAR * pchExt, BOOL fMustBeDir, BOOL fCantBeDir);

#endif // _INCLUDE_OPTIONUI_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\optnui.cpp ===
//
// COptionPage, COptionPageTab
//									  

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "resource.h"
#include "prjoptn.h"	// our project option table
#include "optnui.h"		// our local class declaration
#include "optndlg.h"	// our CProjOptionsDlg
#include "projcomp.h"	// our spawner
#include "projprop.h"

// our tool options UI
#ifdef _MBCS
#include "mbctype.h"
#endif

#include "util.h"

#define MAX_TEXTLEN 8192		// normal edit controls

IMPLEMENT_DYNAMIC(CToolOptionTab, CDlgTab)
IMPLEMENT_DYNAMIC(COptionMiniPage, CDialog)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// our tool options dialog tab

BEGIN_MESSAGE_MAP(CToolOptionTab, CDlgTab)
	//{{AFX_MSG_MAP(CToolOptionTab)
	ON_WM_DESTROY()
	ON_BN_CLICKED(IDC_SET_DEFAULT, OnSetDefault)
	ON_CBN_SELCHANGE(IDC_MINI_PAGE, OnMiniPageSelect)
	ON_EN_UPDATE(IDC_OPTSTR, Update)
	ON_EN_KILLFOCUS(IDC_OPTSTR, Validate_Dest)
	ON_MESSAGE(WM_CTLCOLOREDIT, OnOptStrEditPaint)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CToolOptionTab::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
	CDlgTab::OnKeyDown(nChar, nRepCnt, nFlags);
}

BOOL CToolOptionTab::OnInitDialog()
{
	// call the base-class
	if (!CDlgTab::OnInitDialog())
		return FALSE;

 	// get our listbox
	ValidateMiniPageComboBox();
	ASSERT(m_pcboMiniPage != (CWnd *)NULL);
		
	// init. one-time stuff yet?
	if (!m_pProxySlob)
	{
		// remember our parent's CProxySlob
		m_pProxySlob = &((CProjOptionsDlg *)GetParent())->m_ProxySlob;

		// get the width/height of our tool option tan
		CRect rectTab; GetWindowRect(rectTab);

		// get the rects (relative to tab) of the 'Options:' static text plus
		// assoc. editbox
		CWnd * pWndTxt, * pWndBox; CRect rectTxt, rectBox;
		pWndTxt = GetDlgItem(IDC_OPTIONTXT); ASSERT(pWndTxt != (CWnd *)NULL);
		pWndTxt->GetWindowRect(rectTxt); ScreenToClient(&rectTxt);
		m_cyPageTop = rectTxt.top;
		
		pWndBox = GetDlgItem(IDC_OPTSTR); ASSERT(pWndBox != (CWnd *)NULL);
		pWndBox->GetWindowRect(rectBox); ScreenToClient(&rectBox);
		((CEdit*)pWndTxt)->LimitText(65000);

		// get the first page we looked at
		// and find it's size, make the tool option tab
		// big enough for this page plus the tool option tab
		// controls in the reserved 'top-half' of the tab
		
		// create the first page		
		COptionMiniPage * pPage = CreatePage(0);
		ASSERT(pPage != (COptionMiniPage *)NULL);

		CRect page; pPage->GetWindowRect(page);
		int cyPage = page.Height() - 1;
		SetWindowPos(NULL, 0, 0, max(rectTab.Width(), page.Width()), rectTab.Height() + cyPage, 
					 SWP_NOMOVE | SWP_NOACTIVATE);

		// move the 'Options:' static text plus assoc. editbox down
		pWndTxt->SetWindowPos(pPage, rectTxt.left, rectTxt.top + cyPage, 0, 0, 
					 		  SWP_NOSIZE | SWP_NOACTIVATE);
		pWndBox->SetWindowPos(pWndTxt, rectBox.left, rectBox.top + cyPage, 0, 0, 
					 		  SWP_NOSIZE | SWP_NOACTIVATE);
	}

	// sort entries and fill our listbox
	COptionMiniPage * pPage;
	CString strPageName;
	CObArray rgPages;

	int i, iUpper = m_rgPages.GetUpperBound();
	for (i = 0; i <= iUpper; i++)
	{
		// add the names of our mini-pages into the combo-box
		pPage = (COptionMiniPage *)m_rgPages[i];
		
		// first one is called 'General'
		if (i == 0)
		{
			// always goes first
			strPageName.LoadString(IDS_GENERAL);

			rgPages.Add((CObject *)pPage);	// no elements in array yet, so just add
			m_pcboMiniPage->InsertString(0 /*first*/, strPageName);
		}
		else
		{
			// insert sort
			pPage->GetName(strPageName);

			CString strNewPageName;
			int iInsert = 1;	// we should alread have one entry in list
			for (; iInsert <= rgPages.GetUpperBound(); iInsert++)
			{
				// get this name
				((COptionMiniPage *)rgPages[iInsert])->GetName(strNewPageName);

				// insert before?
				if (strPageName <= strNewPageName)
					break;
			}

			// insert either at end if we are alphabetically > all in current list, or insert
			// before insertion index found
			if (iInsert > rgPages.GetUpperBound())
				rgPages.Add((CObject *)pPage);	// put at end!
			else
				rgPages.InsertAt(iInsert, (CObject *)pPage);	// insert

			m_pcboMiniPage->InsertString(iInsert > rgPages.GetUpperBound() ? -1 : iInsert, strPageName);
		}
	}

	// we'll use this new order
	m_rgPages.RemoveAll();
	for (i = 0; i <= iUpper; i++)
		m_rgPages.Add(rgPages[i]);

	// do we need to hide or show the 'General' listbox?
	GetDlgItem(IDC_PAGE_CATEGORY)->ShowWindow(iUpper > 0 ? SW_SHOW : SW_HIDE);	// static text
	m_pcboMiniPage->ShowWindow(iUpper > 0 ? SW_SHOW : SW_HIDE);	// listbox
	
	return TRUE; // success
}

CBrush brBkGnd;

LRESULT CToolOptionTab::OnOptStrEditPaint(WPARAM wParam, LPARAM lParam)
{
	CWnd * pWndEdit = GetDlgItem(IDC_OPTSTR);
	if (pWndEdit == (CWnd *)NULL || pWndEdit->m_hWnd != (HWND)lParam)
		return (LRESULT)0;	// not processed by us

	// o set the background color to be button face for the description so
	//   that it looks like static text
	// o " ditto " if we have a multiple selection
	// o set the background color to be window background for regular option string
	// we must return a handle to a brush
	BOOL fGrayBkGnd = !m_pProxySlob->IsSingle() || m_pProxySlob->GetContainer() != (CSlob *)NULL;
	COLORREF clrBkGnd = ::GetSysColor(fGrayBkGnd ? COLOR_BTNFACE : COLOR_WINDOW);

	// delete the old brush if we have one
	if (brBkGnd.m_hObject != (HGDIOBJ)NULL)
		brBkGnd.DeleteObject();

	// create the new brush
	if (!brBkGnd.CreateSolidBrush(clrBkGnd))
		return (LRESULT)0;	// couldn't create brush, can't do

	// if we are disabled we'd like to gray our text
	// so we don't look quite so stupid when the whole prop. page
	// is disabled during a build
	(void) ::SetTextColor((HDC)wParam, ::GetSysColor(::IsWindowEnabled((HWND)lParam) ? COLOR_WINDOWTEXT : COLOR_GRAYTEXT));

	// set our text background color,
	// and return the paint background color
	(void) ::SetBkColor((HDC)wParam, clrBkGnd);

	return (LRESULT)(HBRUSH)brBkGnd.GetSafeHandle();
}

void CToolOptionTab::OnDestroy()
{
	// Should be auto-called in the CToolOptionTab::Deactivate() method by CTabbedDialog
	DeactivatePage(m_nCurrPage);

	// destroy any of the mini pages we created
	for (int i = 0; i <= m_rgPages.GetUpperBound(); i++)
	{
		// destroy the window
		COptionMiniPage * pPage = (COptionMiniPage *)m_rgPages[i];
		if (pPage->m_hWnd != (HWND)NULL)
			pPage->DestroyWindow();
	}
}

BOOL CToolOptionTab::AddOptionPage(COptionMiniPage * pPage)
{
	if (pPage == (COptionMiniPage *)NULL)
		return FALSE;	// no creation

	m_rgPages.Add(pPage);
	return TRUE;
}

void CToolOptionTab::RemoveAllPages()
{
	// remove any of the mini pages we created
	for (int i = 0; i <= m_rgPages.GetUpperBound(); i++)
	{
		// destroy the window
		delete (COptionMiniPage *)m_rgPages[i];
	}
}

BOOL CToolOptionTab::Activate(CTabbedDialog * pParentWnd, CPoint position)
{
	// call our base-class first
	if (!CDlgTab::Activate(pParentWnd, position))
		return FALSE;

	// m_pcboMiniPage should be valid.
	ASSERT( ValidateMiniPageComboBox() );

	if (NULL==m_pcboMiniPage)
		return FALSE;

	// find the category to select if first activation of this tab
	if (m_nCurrPage == -1)
		if ((m_nCurrPage = m_pcboMiniPage->FindStringExact(-1, m_strInitCategory)) == CB_ERR)
			m_nCurrPage = 0;	// if can't find category, default to first

	// select the page for this cateogyr in our listbox of pages
	m_pcboMiniPage->SetCurSel(m_nCurrPage);

	// make sure that while this tab is up 
	// the option parser/generator is using
	// the approp. COptionHandler
	if (m_popthdlr != (COptionHandler *)NULL)
		g_prjoptengine.SetOptionHandler(m_popthdlr);
 
	// make sure the ProxySlob knows about us
	((CProxySlob *)g_prjoptengine.GetPropertyBag())->SetOptionHandler(m_popthdlr);

	// activate our first page
	if (!ActivatePage(m_nCurrPage))
		return FALSE;
		
	// make sure our state is correct
	UpdateState();

	// ok
	return TRUE;
}

void CToolOptionTab::Deactivate(CTabbedDialog* pParentWnd)
{
	// call our base-class first
	CDlgTab::Deactivate(pParentWnd);

	// de-activate our current page
	DeactivatePage(m_nCurrPage);
}

BOOL CToolOptionTab::SetCurrentMiniPage(CString & strTitle)
{
	// have we activated a page yet?
	int iSel;

	// Make sure that m_pcboMiniPage is valid before using it.
	if (m_pcboMiniPage && ValidateMiniPageComboBox())
		if ((iSel = m_pcboMiniPage->FindStringExact(-1, strTitle)) == CB_ERR)
			return FALSE;
	
	if (m_nCurrPage == -1)
		m_strInitCategory = strTitle;	// prime before activation of tab
	else
		SelectPage(iSel); // select new page
	return TRUE;
}

BOOL CToolOptionTab::GetCurrentMiniPage(CString & strTitle)
{
	if (!m_pcboMiniPage  || !ValidateMiniPageComboBox())	return FALSE;

	int iSel;
	if ((iSel = m_pcboMiniPage->GetCurSel()) == CB_ERR)	return FALSE;

	// return the text of the current selection
	m_pcboMiniPage->GetLBText(iSel, strTitle);
	return TRUE;
}

COptionMiniPage * CToolOptionTab::CreatePage(UINT nPage)
{
	COptionMiniPage * pPage = GetOptionPage(nPage);

	// need to create?
	if (pPage->m_hWnd == (HWND)NULL)
	{
		// can we create?
		if (!pPage->Create(this))
			return (COptionMiniPage *)NULL;

		// show the page in the correct position
		// (we use the 'Options:' static text as the ref. point
		// the original 'Options:' static text plus edit-box
		// are moved down)
		CWnd * pwndReset = GetDlgItem(IDC_SET_DEFAULT); ASSERT(pwndReset != (CWnd *)NULL);
		pPage->SetWindowPos(pwndReset, 0, m_cyPageTop, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE);
	}

	return pPage;
}

BOOL CToolOptionTab::ActivatePage(UINT nPage)
{
	COptionMiniPage * pPage = CreatePage(nPage);
	if (pPage == (COptionMiniPage *)NULL)	return FALSE;

	// initialise the contents of the page
	pPage->InitPage();

	// show the page visible
	pPage->ShowWindow(SW_SHOWNOACTIVATE);	
	pPage->EnableWindow(TRUE);

	// Help will correspond to the currently active page
 	m_nIDHelp = pPage->GetDlgID();

	return TRUE;
}

void CToolOptionTab::DeactivatePage(UINT nPage)
{
	COptionMiniPage * pPage = GetOptionPage(nPage);

	// hide this page
	pPage->EnableWindow(FALSE);
	pPage->ShowWindow(SW_HIDE);

	// terminate
	pPage->TermPage();
}

void CToolOptionTab::UpdateState()
{
	// init. our font for option text
	//
	CWnd * pWnd;

	pWnd = GetDlgItem(IDC_OPTSTR);
	ASSERT(pWnd != (CWnd *)NULL);
	pWnd->SetFont(GetStdFont(font_Normal));

	// is the text read-only?
	BOOL fReadOnly = TRUE;

	// item label text to display?
	CString strText, strItem;
	
	BOOL fGenDescription = m_pProxySlob->GetContainer() != (CSlob *)NULL;
	strText.LoadString(IDS_OPTIONTXT);
	 
	// are we multiple selection?
	if (m_pProxySlob->IsSingle())
	{
	 	// change the per-item text
		if (m_pProxySlob->IsSortOf(RUNTIME_CLASS(CProject)))
			strItem.LoadString(IDS_PROJECT);
		else if (m_pProxySlob->IsSortOf(RUNTIME_CLASS(CProjGroup)))
			strItem.LoadString(IDS_GROUP);
		else if (m_pProxySlob->IsSortOf(RUNTIME_CLASS(CFileItem)))
			strItem.LoadString(IDS_FILEITEM);
		
		// descriptions are read-only
		fReadOnly = fGenDescription;
	}
	else
	{
		// we don't show per-file for a multiple selection!
		// for what it's worth show the regular text
		// with 'Common' prepended
		strItem.LoadString(IDS_COMMON);
	}

	pWnd = GetDlgItem(IDC_OPTIONTXT);
	ASSERT(pWnd != (CWnd *)NULL);
	// we want to show the right label 'context' + 'view'
	pWnd->SetWindowText(strItem + ' ' + strText);

	// make sure we show the correct option text window .. description or raw
	// the difference is we make sure that the Read-Only attributes are correct
	CEdit * pEdit = (CEdit *)GetDlgItem(IDC_OPTSTR);
	pEdit->SetReadOnly(fReadOnly);

	// refresh our options string to show the content of this new selection
	Refresh();
}

void CToolOptionTab::OnSetDefault()
{
	// give user a chance to bail...
	if (MsgBox(Question,IDS_WARN_RESET_DEFAULT_PROPERTIES, MB_YESNO) == IDNO)
		return;

	// we set to default by copying the prop bag from the base
	// prop bag to the current propbag
	POSITION pos = m_pProxySlob->GetHeadPosition();
	while (pos != (POSITION)NULL)
		m_popthdlr->ResetPropsForConfig(m_pProxySlob->GetNext(pos)->pcr);

	COptionMiniPage * pPage = GetOptionPage(m_nCurrPage); ASSERT(pPage != (COptionMiniPage *)NULL);
	pPage->InitPage();

	// the 'Reset...' button that had the focus should be disabled
	// (we just reset! so give the focus to the next tab item
	CWnd * pwndParent = pPage;
	CWnd * pwnd = pwndParent->GetWindow(GW_CHILD);
	if (pwnd != (CWnd *)NULL)	// got children in page?
	{
		// start search from one before first child
		pwnd = pwndParent->GetNextDlgTabItem(pwnd, TRUE);
	}

	if (pwnd == (CWnd *)NULL)	// got tabstop in page?
	{
		// start search from 'Reset...' button
		pwnd = GetDlgItem(IDC_SET_DEFAULT);
		pwndParent = this;
	}

	ASSERT(pwnd != (CWnd *)NULL);
	CWnd * pwndNext = pwndParent->GetNextDlgTabItem(pwnd);
	if (pwndNext != (CWnd *)NULL)
		pwndNext->SetFocus();

	Refresh();
}

void CToolOptionTab::OnMiniPageSelect()
{
	// Make sure that m_pcboMiniPage is valid.
	ASSERT( ValidateMiniPageComboBox() );
	if (NULL==m_pcboMiniPage) return;

	int iPage = m_pcboMiniPage->GetCurSel();
	ASSERT (iPage != CB_ERR);	// can't have no selection!
	SelectPage(iPage);
}

void CToolOptionTab::SelectPage(UINT nPage)
{
	// no-op if there is no current page change
	if (nPage == m_nCurrPage)
		return;

	COptionMiniPage * pPage = GetOptionPage(m_nCurrPage);

	// activate the new one
	if (!ActivatePage(nPage))
		return;

	// deactivate the old one
	DeactivatePage(m_nCurrPage);

	// this is now our current
	m_nCurrPage = nPage;
}

// our option 'watcher' CSlob for the COptionMiniPage

void COptionWatcher::OnInform(CSlob * pChangedSlob, UINT nIDProp, DWORD dwHint)
{
	// the option pages would like to know about these changes
	// -> they affect the value shown in the dialog controls

	m_pOptionPage->OnPropChange(nIDProp);
	m_pOptionPage->m_pToolOptionTab->Refresh();
}

// mini-page used to show option properties

BEGIN_MESSAGE_MAP(COptionMiniPage, CDialog)
	ON_MESSAGE(WM_USER_VALIDATEREQ, OnValidateReq)
END_MESSAGE_MAP()

BEGIN_IDE_CONTROL_MAP(COptionMiniPage, 0, IDS_GENERAL)
END_IDE_CONTROL_MAP()

COptionMiniPage::COptionMiniPage()
{
	// initialise our own data
	m_pSlob = (CSlob *)NULL;
	m_isValidating = FALSE;
	m_nValidateID = NULL;
	m_bIgnoreChange = FALSE;
	m_bGotSlobHook = FALSE;
	m_popthdlr = (COptionHandler *)NULL;

	// setup our option 'watcher'
	m_optionWatcher.m_pOptionPage = this;
}

COptionMiniPage::~COptionMiniPage()
{
}

BOOL COptionMiniPage::OnInitDialog()
{
	// currently editing this control
 	m_nCurrentEditID = 0;

	// remember our parent tab
	m_pToolOptionTab = (CToolOptionTab *)GetParent();
	
	// clear our cache of CHECK_LISTs
	m_listCheckList.RemoveAll();

	// sub-class any CHECK_LISTs we see in the dialog
	for (CControlMap * pCtlMap = GetControlMap() + 1;
		pCtlMap->m_nCtlType != CControlMap::null; pCtlMap += 1)
	{
		if (pCtlMap->m_nCtlType == CControlMap::checkList)
		{
			m_PropCheckList.SubclassDlgItem(pCtlMap->m_nCtlID, this);

			// put this in our cache
			m_listCheckList.AddHead((void *)pCtlMap);
		}
	}

	// call our base-class
	return CDialog::OnInitDialog();
}

BOOL COptionMiniPage::SetupPage(CSlob * pSlob, COptionHandler * popthdlr)
{
	// initialise our data
	m_pSlob = pSlob;
	ASSERT(m_pSlob != (CSlob *)NULL);

	// check-list looks at this CSlob
	m_PropCheckList.SetSlob(m_pSlob);

	// do we have an option handler?
	m_popthdlr = popthdlr;
	if (m_popthdlr == (COptionHandler *)NULL)
		return TRUE;	// done

	CControlMap * pCtlMap = GetControlMap(), * pCtlMapCtls = pCtlMap + 1;

	// convert all of our control map
	// logical to actual properties?
	BOOL fMapCtlMap;
	if (fMapCtlMap = (pCtlMap->m_nExtra == 0))
	{
		// remember the depth of option props in this control map
		if (pCtlMapCtls->m_nCtlType == CControlMap::null)
			pCtlMap->m_nExtra = (UINT)-1;
		else
		{
			// skip over any non-tool options
			while (pCtlMapCtls->m_nProp >= PROJ_BUILD_OPTION_PRIVATE_FIRST)
				pCtlMapCtls++;

			// FUTURE: handle if first control in map doesn't conform
			// to standard 'pCtlMap->m_nProp == property for control'
			ASSERT (pCtlMap->m_nCtlType != CControlMap::icon &&
					pCtlMap->m_nCtlType != CControlMap::checkList);
			pCtlMap->m_nExtra = OHGetDepth(pCtlMapCtls->m_nProp) + 1;
		}
	}

	// adjust option handler used to maybe use a base-one?
	// n.b. this will be needed when a page is returned
	// by a non-root option handler that uses base option props.
	if (pCtlMapCtls->m_nCtlType != CControlMap::null)
		while (m_popthdlr->GetDepth() != (pCtlMap->m_nExtra - 1) /* depth */)
			m_popthdlr = m_popthdlr->GetBaseOptionHandler();

	ASSERT(m_popthdlr != (COptionHandler *)NULL);

	// adjust the tool option props
	// have we already adjusted this static map?
	// (i.e. m_nExtra != 0)
	if (fMapCtlMap)
		while (pCtlMapCtls->m_nCtlType != CControlMap::null)
		{
			// should we bother to map this?
			if (pCtlMapCtls->m_nProp < PROJ_BUILD_OPTION_PRIVATE_FIRST)
			{
				// do something special for checklists
				if (pCtlMapCtls->m_nCtlType == CControlMap::checkList)
				{
					CLocalizedEnum* pEnum = NULL;
					if( (pCtlMapCtls->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_ENUM )
						pEnum = (CLocalizedEnum *)pCtlMapCtls->m_nExtra;
					// ONLY for CLocalizedEnums //
					// ASSERT(pEnum->IsKindOf(RUNTIME_CLASS(CLocalizedEnum)));

					// map our list of properties
					CLocalizedEnumerator * pList = pEnum->GetListL();
					while (pList->id != 0)
					{
						pList->val = MapLogical(pList->val);
						pList++;	// next one
					}
				}
				else
					// map our property
					pCtlMapCtls->m_nProp = MapLogical(pCtlMapCtls->m_nProp);
			}
  
			pCtlMapCtls++; // next control
		}

	return TRUE;
}

BOOL COptionMiniPage::Create(CToolOptionTab * pParent)
{
	C3dDialogTemplate dt;
	if (dt.Load(MAKEINTRESOURCE(GetDlgID())))
		SetStdFont(dt);

	return CreateIndirect(dt.GetTemplate(), pParent);
}

BOOL COptionMiniPage::Create(COptsDebugTab * pParent)
{
	C3dDialogTemplate dt;
	if (dt.Load(MAKEINTRESOURCE(GetDlgID())))
		SetStdFont(dt);
	return CreateIndirect(dt.GetTemplate(), pParent);
}

void COptionMiniPage::OnOK()
{
	// Overide for OK processing, but do NOT call EndDialog!
	
	// NB. don't use SendMessage here
	GetParent()->PostMessage(WM_COMMAND, IDOK);
}

void COptionMiniPage::OnCancel()
{
	// Overide for Cancel processing, but do NOT call EndDialog!
	
	// NB. don't use SendMessage here
	GetParent()->PostMessage(WM_COMMAND, IDCANCEL);
}

//
// OnValidateReq
//
// This responds to a "special" message which is posted when an edit
// loses focus, and validation of that edit's contents need to be
// done. It may change the focus back to the edit.
//

afx_msg LONG COptionMiniPage::OnValidateReq(UINT /* w */, LONG /* l */)
{
	// our parent's parent has the 'Cancel', ie. the CTabbedDialog frame
	CWnd * pWndParent = GetParent(); ASSERT(pWndParent != (CWnd *)NULL);
	pWndParent = pWndParent->GetParent(); ASSERT(pWndParent != (CWnd *)NULL);
	CWnd * pWnd = pWndParent->GetDlgItem(IDCANCEL);
	CWnd * pWndFocus = GetFocus();

	if (pWnd != (CWnd *)NULL && pWndFocus != (CWnd *)NULL &&
		pWndFocus->m_hWnd == pWnd->m_hWnd
	   )
		return TRUE;	// ignore, we're in a cancel

	BOOL fResult = TRUE;

	if (!m_isValidating)
	{
		m_isValidating = TRUE;
		fResult = Validate();
		m_isValidating = FALSE;
	}

	return TRUE;
}

void COptionMiniPage::TermPage()
{
	if (m_bGotSlobHook)
		m_pSlob->RemoveDependant(&m_optionWatcher);
	m_bGotSlobHook = FALSE;
}

//
// Validate
//
// This gets called when the user clicks on something that might change
// the property page.  This should make sure the property page is valid,
// and, if for some reason it isn't, bring up an error dialog, and set the
// focus back to the appropriate error location.
//
// Other windows (specifically, editor windows which contain objects that
// are viewed by the property page) should call this function before
// changing the selection.	This must not be called inside a setfocus or
// killfocus routine, and this function CAN fail.  If the function fails,
// it *will* have changed the windows focus back to the property sheet,
// in the field that failed..  It also may have put up a message box
// alerting the user to the problem.
//

BOOL COptionMiniPage::Validate()
{
	BOOL bValid = TRUE;
	CWnd* pCtl;

	// no we have an ID to validate, or is this the option string?
	// in the latter case accept, a derived class should override
	// COptionMiniPage::Validate() in order to do special validation.
	if (m_nValidateID == NULL || m_nValidateID == IDC_OPTSTR)
		return TRUE;

	ASSERT(m_pSlob != NULL);

	CControlMap* pCtlMap = FindControl(m_nValidateID);
	ASSERT(pCtlMap != NULL);

	pCtl = GetDlgItem(pCtlMap->m_nCtlID);
	ASSERT(pCtl != NULL);

	CString strBuf;
	pCtl->GetWindowText(strBuf);

	CString strCurVal;
	if (m_pSlob->GetStrProp(pCtlMap->m_nProp, strCurVal) == valid)
	{
		if (strCurVal == strBuf)
		{
			m_nValidateID = NULL;
			return TRUE;
		}
	}

	ASSERT(pCtlMap->m_nCtlType == CControlMap::comboText ||
		   pCtlMap->m_nCtlType == CControlMap::symbolCombo ||
		   pCtlMap->m_nCtlType == CControlMap::edit ||
		   pCtlMap->m_nCtlType == CControlMap::editInt ||
		   pCtlMap->m_nCtlType == CControlMap::editNum
		  );

	CMultiSlob* pSelection = NULL;
	CSlobWnd* pSlobWnd = m_pSlob->GetSlobWnd();
	if (pSlobWnd != NULL)
		pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
	if (pSelection != NULL && !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
		pSelection = NULL;

	// FUTURE: no property bag undo (for now?)
	// theUndoSlob.BeginUndo(IDS_UNDO_PROPEDIT);
	bValid = m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);
	// theUndoSlob.EndUndo();

	if (bValid)
		m_nValidateID = NULL;
	else
		pCtl->SetFocus();

	return bValid;
}

// Given a control (window) id, return the control map entry for it...
CControlMap* COptionMiniPage::FindControl(UINT nCtlID)
{
	CControlMap* pCtlEntry;

	for (pCtlEntry = GetControlMap() + 1;
		pCtlEntry->m_nCtlType != CControlMap::null; pCtlEntry += 1)
	{
		if (nCtlID >= pCtlEntry->m_nCtlID &&
			nCtlID <= pCtlEntry->m_nLastCtlID)
		{
			return pCtlEntry;
		}
	}

	return NULL;
}

// Handle a control notification from a property dialog.
BOOL COptionMiniPage::OnCommand(UINT wParam, LONG lParam)
{	
	CWnd * pwndFocus = GetFocus();

	if (HIWORD(wParam) == EN_CHANGE &&			// changing an edit-control?
		m_nCurrentEditID != LOWORD(wParam) &&	// not already noted?
		pwndFocus != (CWnd *)NULL && 			// somebody have focus?
		pwndFocus->GetDlgCtrlID() == LOWORD(wParam)	// only if we have focus!
	   )
		m_nCurrentEditID = LOWORD(wParam);

	else if (HIWORD(wParam) == EN_KILLFOCUS)
		m_nCurrentEditID = 0;					// no longer have focus in edit-control

	CControlMap* pCtlMap = FindControl(LOWORD(wParam));
	CString strBuf;
	int val;
	BOOL bString = FALSE;
	BOOL bSetProp = FALSE;
	BOOL bValidateReq = FALSE;

	if (m_pSlob == NULL || pCtlMap == NULL ||
		(m_nValidateID && LOWORD(wParam) != ((UINT) m_nValidateID) &&
		pCtlMap->m_nCtlType != CControlMap::check &&
		pCtlMap->m_nCtlType != CControlMap::radio))
	{
		// If the control is not found in the map, just pass this
		// message on for default processing...
		// Or if we have a validate ID already, this message is from
		// another control.
LDefault:
		return CDialog::OnCommand(wParam, lParam);
	}

#ifdef _WIN32
	HWND hWndCtl = (HWND)(lParam);
	UINT nNotify = HIWORD(wParam);
#else
	HWND hWndCtl = (HWND)LOWORD(lParam);
	UINT nNotify = HIWORD(lParam);
#endif

	ASSERT(m_pSlob != NULL);

	switch (pCtlMap->m_nCtlType)
	{
	default:
		goto LDefault;

	case CControlMap::check:
	{
		if (nNotify != BN_CLICKED)
			goto LDefault;

		val = (int)::SendMessage(hWndCtl, BM_GETCHECK, 0, 0);
		if (val == 2)
			val = FALSE;
		else
			val = !val;
		bSetProp = TRUE;
		break;
	}

	case CControlMap::list:
	case CControlMap::listText:
	{
		if (nNotify != LBN_SELCHANGE)
			goto LDefault;

		int isel = (int)::SendMessage(hWndCtl, LB_GETCURSEL, 0, 0);
		val = (int)::SendMessage(hWndCtl, LB_GETITEMDATA, isel, 0);
		bSetProp = TRUE;

		if (pCtlMap->m_nCtlType == CControlMap::listText)
		{
			((CListBox*)CWnd::FromHandle(hWndCtl))->GetText(val, strBuf);
			bString = TRUE;
		}
		break;
	}

	case CControlMap::comboList:
	{
		if (nNotify != CBN_SELCHANGE)
			goto LDefault;
		int isel = (int)::SendMessage(hWndCtl, CB_GETCURSEL, 0, 0);
		val = (int)::SendMessage(hWndCtl, CB_GETITEMDATA, isel, 0);
		bSetProp = TRUE;
		break;
	}

	case CControlMap::comboText:
	case CControlMap::symbolCombo:
		if ((nNotify == CBN_EDITCHANGE || nNotify == CBN_SELCHANGE) && !m_bIgnoreChange)
		{
			m_nValidateID = pCtlMap->m_nCtlID;
		}
		else if (nNotify == CBN_SELENDCANCEL || nNotify == CBN_SELENDOK)
		{
			m_nValidateID = pCtlMap->m_nCtlID;
			bValidateReq = TRUE;
		}
		break;

	case CControlMap::autoEdit:
		if (nNotify != EN_CHANGE || m_bIgnoreChange)
			goto LDefault;

		bSetProp = TRUE;
		CEdit::FromHandle(hWndCtl)->GetWindowText(strBuf);
		bString = TRUE;
		break;

	case CControlMap::editInt:
	case CControlMap::edit:
	case CControlMap::editNum:
		if (nNotify == EN_CHANGE && !m_bIgnoreChange)
			m_nValidateID = pCtlMap->m_nCtlID;
		else if (nNotify == EN_KILLFOCUS)
			bValidateReq = TRUE;
		break;

	case CControlMap::radio:
		if (nNotify != BN_CLICKED)
			goto LDefault;
		val = LOWORD(wParam) - pCtlMap->m_nCtlID + pCtlMap->m_nExtra;
		bSetProp = TRUE;
		break;
	}

	if (bSetProp)
	{
		ASSERT(!bValidateReq);

		CMultiSlob* pSelection = NULL;
		CSlobWnd* pSlobWnd = m_pSlob->GetSlobWnd();
		if (pSlobWnd != NULL)
			pSelection = (CMultiSlob*)pSlobWnd->GetSelection();
		if (pSelection != NULL && !pSelection->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
			pSelection = NULL;
		
		// FUTURE: no undo for property bags (for now?)
		// theUndoSlob.BeginUndo(IDS_UNDO_PROPEDIT);
		if (bString)
			m_pSlob->SetStrProp(pCtlMap->m_nProp, strBuf);
		else
			m_pSlob->SetIntProp(pCtlMap->m_nProp, val);
		// theUndoSlob.EndUndo();
	}
	else if (bValidateReq)
	{
		PostMessage(WM_USER_VALIDATEREQ);
		return CDialog::OnCommand(wParam, lParam);
	}

	return TRUE;
}


// Initialize the values of the controls in the property dialog.
// FUTURE:	The need to do this will be eliminated by simply having the
//			selection announce changes to all properties when the selected
//			object changes!

void COptionMiniPage::InitPage()
{
	// make ourself a dependant of the current CSlob?
	if (!m_bGotSlobHook)
	{
		m_pSlob->AddDependant(&m_optionWatcher);
		m_bGotSlobHook = TRUE;
	}
 
	CControlMap* pCtlMap;

	// If several slob types share the same page we may need to change
	// the help ID, so the context sensitive help can reflect the
	// correct slob type.
	//
	UINT nHelpID = GetControlMap()->m_nProp;
	if ( nHelpID )
		SetHelpID( nHelpID );

	for (pCtlMap = GetControlMap() + 1;
		pCtlMap->m_nCtlType != CControlMap::null; pCtlMap += 1)
	{
		CEnum* pEnum = NULL;
		if( (pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_ENUM )
			pEnum = (CEnum*)pCtlMap->m_nExtra;

		switch (pCtlMap->m_nCtlType)
		{
		case CControlMap::checkList:
			if (pEnum != NULL)
			{
				pEnum->FillCheckList((CPropCheckList*)GetDlgItem(pCtlMap->m_nCtlID),
					TRUE, m_pSlob);
			}
			goto LThinFont;
			break;

		case CControlMap::comboList:
		case CControlMap::comboText:
			if (pEnum != NULL)
			{
				pEnum->FillComboBox((CComboBox*)GetDlgItem(pCtlMap->m_nCtlID),
					TRUE, m_pSlob);
			}
			goto LThinFont;
			break;

		case CControlMap::list:
		case CControlMap::listText:
			if (pEnum != NULL)
			{
				pEnum->FillListBox((CListBox*)GetDlgItem(pCtlMap->m_nCtlID),
					TRUE, m_pSlob);
			}
			goto LThinFont;
			break;

		case CControlMap::editStrCap:
			ASSERT(FALSE);	// NOT SUPPORTED
			break;

		case CControlMap::edit:
		case CControlMap::editInt:
		case CControlMap::editNum:
		case CControlMap::autoEdit:
			((CEdit*)GetDlgItem(pCtlMap->m_nCtlID))->LimitText(
				pCtlMap->m_nExtra != 0 ? pCtlMap->m_nExtra : MAX_TEXTLEN);
			// FALL THROUGH

		case CControlMap::thinText:
		case CControlMap::pathText:
LThinFont:
			GetDlgItem(pCtlMap->m_nCtlID)->SetFont(GetStdFont(font_Normal));
			break;
		}

		OnPropChange(pCtlMap->m_nProp);
	}
}

// Given a property id, return the control map entry for it.
CControlMap* COptionMiniPage::FindProp(UINT nProp)
{
	CControlMap* pCtlEntry;

	for (pCtlEntry = GetControlMap() + 1;
		pCtlEntry->m_nCtlType != CControlMap::null; pCtlEntry += 1)
	{
		if (pCtlEntry->m_nProp == nProp)
			return pCtlEntry;
	}

	return NULL;
}

// Update the control that reflects a given property in the dialog.
// Called whenever any property of any of the selected objects changes.
BOOL COptionMiniPage::OnPropChange(UINT nProp)
{
	// have all the properties changed?
	if (nProp == SN_ALL)
	{
		// require a full update
		InitPage();
		return TRUE;
	}

	BOOL bChanged = TRUE;

	CControlMap* pCtlMap = FindProp(nProp);

	if (pCtlMap == NULL)
	{
		// not found in the control map, is this a Check-List?
		// if so look for the prop in each Check-List enum

		BOOL fFoundCheck = FALSE;
		POSITION pos = m_listCheckList.GetHeadPosition();
		while ((pos != (POSITION)NULL) && !fFoundCheck)
		{
			pCtlMap = (CControlMap*)m_listCheckList.GetNext(pos);
			ASSERT( (pCtlMap->m_dwFlags & CM_EXTRA_MASK) == CM_EXTRA_ENUM );
			CEnum* pEnum = (CEnum*)pCtlMap->m_nExtra;

			fFoundCheck	= pEnum->ContainsVal(nProp);
		}

		if (!fFoundCheck) pCtlMap = (CControlMap*)NULL;
	}

	if (pCtlMap == NULL)
	{
		if (nProp == P_QuoteName)
			pCtlMap = FindProp(P_ID);

		if (pCtlMap == NULL)
			return FALSE;
	}

	CWnd* pWndCtl = GetDlgItem(pCtlMap->m_nCtlID);

	if (pWndCtl == NULL)
	{
		TRACE1("Control %d is in the map but not the dialog!\n",
			pCtlMap->m_nCtlID);
		return FALSE;
	}

	int val;
	CString str;
	UINT id;

	switch (pCtlMap->m_nCtlType)
	{
		//
		// checkboxes
		//
		case CControlMap::check:
		{
			GPT gpt;
			gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);
			if (gpt == ambiguous)
				val = 2;	// indeterminate state
			else if (gpt == invalid)
				val = 0;	// disabled state

			((CButton*)pWndCtl)->SetCheck(val);
			pWndCtl->EnableWindow(gpt != invalid);
			break;
		}

	   	// 
		// check-lists
		//
		case CControlMap::checkList:
			// let the CPropCheckList handle everything
			((CPropCheckList*)pWndCtl)->OnPropChanged(nProp);
			break;

		//
		// edit-boxes
		//
		case CControlMap::editInt:
		case CControlMap::edit:
		case CControlMap::editNum:
		case CControlMap::autoEdit:
		case CControlMap::thinText:
		case CControlMap::thickText:
		case CControlMap::pathText:
		{
			GPT gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);

			if (pCtlMap->m_nCtlType == CControlMap::pathText)
			{
				// If this is a pathText then we may
				// truncate the text for display

				CRect rect;
				TEXTMETRIC tm;
				int MaxWidth = 0;
				CPath path;
				CString strPath;

				pWndCtl->GetWindowRect(&rect);

				CDC * pDC = pWndCtl->GetDC(); 
				ASSERT(pDC != (CDC *)NULL);
				pDC->GetTextMetrics(&tm);
				VERIFY(pWndCtl->ReleaseDC(pDC));

				MaxWidth = rect.Width() / tm.tmAveCharWidth;
				if (path.Create(str))
				{
					path.GetDisplayNameString(strPath, MaxWidth);
					str = strPath;
				}
			}

			CString strWindow;
			pWndCtl->GetWindowText(strWindow);

			if (gpt == invalid || gpt == ambiguous)
				str = "";	// invalid or indeterminate

			if (str != strWindow)
			{
				m_bIgnoreChange = TRUE;
				if (pCtlMap->m_nCtlType != CControlMap::thinText &&
					pCtlMap->m_nCtlType != CControlMap::thickText)
					((CEdit*)pWndCtl)->LimitText(0); // remove limit

				pWndCtl->SetWindowText(str);

				if (pCtlMap->m_nCtlType != CControlMap::thinText &&
					pCtlMap->m_nCtlType != CControlMap::thickText)
					((CEdit*)pWndCtl)->LimitText(pCtlMap->m_nExtra != 0 ? pCtlMap->m_nExtra : MAX_TEXTLEN);

				m_bIgnoreChange = FALSE;
			}
			else
			{
				bChanged = FALSE;
			}

			GetDlgItem(pCtlMap->m_nCtlID)->EnableWindow(gpt != invalid);
			break;
		}

		//
		// listboxes (selected by string prop)
		//
		case CControlMap::listText:
		case CControlMap::comboText:
		// PPMOVE SPECIAL: [matthewt]
		// Does this resource handling need to be moved back into VRES?
		case CControlMap::symbolCombo:
		{
			GPT gpt = m_pSlob->GetStrProp(pCtlMap->m_nProp, str);

			CString strWindow;
			pWndCtl->GetWindowText(strWindow);

			if (gpt == invalid || gpt == ambiguous)
				str = "";	// invalid or indeterminate

			if (str != strWindow)
			{
				int iCurSel;
				m_bIgnoreChange = TRUE;
				if (pCtlMap->m_nCtlType == CControlMap::listText)
				{
					iCurSel = str == "" ? LB_ERR : ((CListBox*)pWndCtl)->FindStringExact(-1, str);
					((CListBox*)pWndCtl)->SetCurSel(iCurSel);
				}
				else
				{
					iCurSel = str == "" ? CB_ERR : ((CComboBox*)pWndCtl)->FindStringExact(-1, str);
					((CComboBox*)pWndCtl)->SetCurSel(iCurSel);
				}

				pWndCtl->SetWindowText(str);
				m_bIgnoreChange = FALSE;
			}
			else
			{
				bChanged = FALSE;
			}

			GetDlgItem(pCtlMap->m_nCtlID)->EnableWindow(gpt != invalid);
			break;
		}

		//
		// radio-buttons
		//
		case CControlMap::radio:
		{
			GPT gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);

			if (gpt == invalid || gpt == ambiguous)
				val = -1;	// invalid or indeterminate

			CheckRadioButton(pCtlMap->m_nCtlID, pCtlMap->m_nLastCtlID,
				val == -1 ? val : pCtlMap->m_nCtlID + val - pCtlMap->m_nExtra);

			for (id = pCtlMap->m_nCtlID; id <= pCtlMap->m_nLastCtlID; id += 1)
				GetDlgItem(id)->EnableWindow(gpt != invalid);

			break;
		}

		// 
		// listboxes (selected by index)
		//
		case CControlMap::list:
		{
			GPT gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);

			if (gpt == invalid || gpt == ambiguous)
				val = -1;	// invalid or indeterminate

			if (val != -1)
			{
				int icnt = ((CListBox*)pWndCtl)->GetCount();
				for (int iitem = 0; iitem < icnt; iitem++)
				{
					int idata = ((CListBox*)pWndCtl)->GetItemData(iitem);
					if (val == idata)
					{
						val = iitem; break;
					}
				}
			}

			((CListBox*)pWndCtl)->SetCurSel(val);

			GetDlgItem(pCtlMap->m_nCtlID)->EnableWindow(gpt != invalid);
			break;
		}

		//
		// combo listboxes (selected by index)
		//
		case CControlMap::comboList:
		{
			GPT gpt = m_pSlob->GetIntProp(pCtlMap->m_nProp, val);

			if (gpt == invalid || gpt == ambiguous)
				val = -1;	// invalid or indeterminate

			if (val != -1)
			{
				int icnt = ((CComboBox*)pWndCtl)->GetCount();
				for (int iitem = 0; iitem < icnt; iitem++)
				{
					int idata = ((CComboBox*)pWndCtl)->GetItemData(iitem);
					if (val == idata)
					{
						val = iitem; break;
					}
				}
			}

			((CComboBox*)pWndCtl)->SetCurSel(val);

			GetDlgItem(pCtlMap->m_nCtlID)->EnableWindow(gpt != invalid);
			break;
		}
	}

	return bChanged;
}

UINT COptionMiniPage::GetNameID()
{
	return GetControlMap()->m_nLastCtlID;
}

void COptionMiniPage::GetName(CString & strName)
{
	if (!strName.LoadString(GetControlMap()->m_nLastCtlID))
		strName = "<No Name>";
}

//
// validation for the CToolOptionTab
//

BOOL Validate_D_Helper(CString & strDest, UINT idMsg, const TCHAR * pchExt, BOOL fMustBeDir, BOOL fCantBeDir)
{
 	// nothing to do?
	if (strDest.IsEmpty())	return TRUE;

	enum {fail, pass, neither} result = neither;
	CString strDestName;
	VERIFY(strDestName.LoadString(idMsg));

	TCHAR * pchStart = (TCHAR *)(const TCHAR *)strDest;
	TCHAR * pchT;

	pchT = pchStart + _tcslen(pchStart);	// point to nul terminator
	pchT = _tcsdec(pchStart, pchT);			// back up one char, DBCS safe

	BOOL fIsDir = (*pchT == _T('\\') || *pchT == _T('/'));

	// is this definately a directory ?
	if (fIsDir)
	{
		// yes
		if (fCantBeDir)
		{
			// can't be a directory!
			InformationBox(IDS_DEST_CANNOT_BE_DIR, (LPCSTR)strDestName);
			result = fail;
		}
		else
		{
			result = pass;
		}
	}
	else
	{
		CPath pathDest;
		if (pathDest.Create(strDest))
		{
			// no
			if (fMustBeDir)
			{
				// assume this a directory
				{
					// correct -> form a directory, append a '/'
					strDest += _T('/');
					result = pass;
				}
			}

			if (result == neither)			// still not determined?			
			{
				if ((*pchExt != _T('\0')) &&	// need to match extension?
					!FileNameMatchesExtension(&pathDest, pchExt) // match extension?
			   	   )
				{
					const TCHAR * pchDestExt = pathDest.GetExtension();
					if (!fCantBeDir && (*pchDestExt == _T('\0')))
					{
						// is this a directory?
						int iReply = QuestionBox(IDS_DEST_IS_DIR, MB_YESNO, strDestName);
						if (iReply == IDYES)
						{
							// correct -> form a directory, append a '/'
							strDest += _T('/');
							result = pass;
						}
					}

					// still not determined
					if (result == neither)
					{
						// must match extension if not a directory
						InformationBox(IDS_DEST_BAD_EXTENSION, (LPCSTR)strDestName, (LPCSTR)pchExt);

						// correct -> change the extension to the correct one

						// extent of path to keep?
						int cch = strDest.GetLength() + _tcslen(pchExt) - _tcslen(pchDestExt) + 1;
						pathDest.ChangeExtension(pchExt);

						strDest = (const TCHAR *)pathDest;
						strDest = strDest.Right(cch);

						result = pass;
					}
				}
				else
					result = pass;
			}
		}
		else
		{
			// bad path
			InformationBox(IDS_DEST_BAD_PATH, (LPCSTR)strDestName, (LPCSTR)strDest);
			result = fail;
		}
	}

	ASSERT(result != neither);

	return (result == pass);
}

BOOL Validate_DestinationP(CSlob * pSlob, UINT idProp, UINT idOption,
						   CDialog * pDlg, UINT idPropDest, UINT idMsg, BOOL * pfRefresh,
						   const TCHAR * pchExt, BOOL fMustBeDir, BOOL fCantBeDir)
{
	CString strDest;
	// an invalid destination can't be validated, and are valid by default
	if (pSlob->GetStrProp(idProp, strDest) != valid)	return TRUE;

	// remember our destination, it might be changed in order
	// to make it valid, eg. appending a '/' to make it a directory
	CString strOld = strDest;
	BOOL fReturn = Validate_D_Helper(strDest, idMsg, pchExt, fMustBeDir, fCantBeDir);

	// did we pass?
	if (fReturn)
	{
		// update (possibly) changed prop
		if (strDest != strOld)
			pSlob->SetStrProp(idProp, strDest);
	}
	else
	{
		// get the single option 
		CString strSglOption;

		g_prjoptengine.GenerateSingleOption(idOption, strSglOption, OBShowFake);

		// get the option string
		CString strOption;
		CWnd * pWnd = pDlg->GetDlgItem(idPropDest);
		ASSERT(pWnd != (CWnd *)NULL);
		pWnd->GetWindowText(strOption);

		// try to find the single option in the options string
		// if we find it, then try to figure the start and end
		// of the destination
		int ich, ichStart = 0, ichEnd = -1;
		ich = strOption.Find(strSglOption);
		if (ich != -1)
		{
			ich += strSglOption.Find(strDest);
			ichStart = ich; ichEnd = ichStart + strDest.GetLength();
			
			// if we finish on a '\' and the next chars. are
			// '\"' then incr. one char.
			if (ichEnd &&	// make sure that 'ichStart != ichEnd != 0'
				strOption[ichEnd-1] == _T('\\') &&
				strOption[ichEnd] == _T('\\') &&
				strOption[ichEnd+1] == _T('"')
			   )
				ichEnd++;
		}
		else
		{
			// we should find this option!
			ASSERT(FALSE);
		}

		// keep focus + select the prop string in the text
		pWnd->SetFocus();
		((CEdit *)pWnd)->SetSel(ichStart, ichEnd);
	} 

	return fReturn;
}

BOOL Validate_Destination(CDialog * pDlg, UINT idEditDest, UINT idMsg,
						  const TCHAR * pchExt, BOOL fMustBeDir, BOOL fCantBeDir)
{
	CWnd * pWnd = pDlg->GetDlgItem(idEditDest);
	ASSERT(pWnd != (CWnd *)NULL);
	CString strDest;
	pWnd->GetWindowText(strDest);

	BOOL fReturn = Validate_D_Helper(strDest, idMsg, pchExt, fMustBeDir, fCantBeDir);

	// Get pWnd again since it may have been deleted during OnIdle processing 
	// if Validate_D_Helper displayed a message.  (SPEED:4808)
	pWnd = pDlg->GetDlgItem(idEditDest);

	// did we pass?
	if (fReturn)
	{
		// update a (possibly) changed text
		pWnd->SetWindowText(strDest);
	}
	else
	{
		// keep focus + full-selection
		pWnd->SetFocus();
		((CEdit *)pWnd)->SetSel(0, -1);
	}

	return fReturn;
}

BOOL CToolOptionTab::ValidateTab()
{
	BOOL fValid;	// valid?

	// validate current COptionMiniPage
	COptionMiniPage * pPage = GetOptionPage(m_nCurrPage);

	if (!pPage->m_isValidating)
	{
		pPage->m_isValidating = TRUE;
		fValid = pPage->Validate();	// validate page
		pPage->m_isValidating = FALSE;	
	}
	else
		fValid = FALSE;	// can't do during validation

 	// reset 'to-do' validation if the we are valid
	if (fValid)
		pPage->m_nCurrentEditID = 0;

	return fValid;
}

void CToolOptionTab::Validate_Dest()
{
	// ignore if we have a description
	if (m_pProxySlob->GetContainer() != (CSlob  *)NULL)
		return;

	// we might have caused this due to a SetFocus in the
	// validation failure of other edits
	COptionMiniPage * pPage = (COptionMiniPage *)GetOptionPage(m_nCurrPage);
	if (!pPage->m_isValidating)
	{
		// force validation of the options string
		pPage->m_nValidateID = IDC_OPTSTR;
		Refresh();
		pPage->PostMessage(WM_USER_VALIDATEREQ);
	}
}

BOOL COptionMiniPage::Validate_DestinationProp
(
	UINT idProp,
	UINT idOption, 
	UINT idEditDest,
	UINT idMsg,
	const TCHAR * pchExt,
	BOOL fMustBeDir,
	BOOL fCantBeDir
)
{
	// we need to map the actual prop to a logical one
	// (do some cunning arithmetic so we know how deep to go)
	COptionHandler * popthdlr = m_popthdlr;
	UINT cStep = popthdlr->GetDepth() - OHGetDepth(idProp);  
	while (cStep--)
		popthdlr = popthdlr->GetBaseOptionHandler();

	UINT idPropL = popthdlr->MapLogical(idProp);
 
	BOOL fReturn = ::Validate_DestinationP(m_pSlob, idPropL, idOption,
										   (idEditDest == IDC_OPTSTR) ? (CDialog *)GetParent() : this,
										   idEditDest, idMsg, &(m_pToolOptionTab->m_fRefresh),
								  		   pchExt, fMustBeDir, fCantBeDir);

	// we're not using the standard page validation so do our
	// own setting of state vars here...:-(
	// clear the validation ID check!
	if (fReturn && (idEditDest == IDC_OPTSTR))
		m_nValidateID = NULL;
	return fReturn;
}

BOOL COptionMiniPage::Validate_Destination
(
	UINT idEditDest,
	UINT idMsg, 
	const TCHAR * pchExt,
	BOOL fMustBeDir,
	BOOL fCantBeDir
)
{
	BOOL fReturn = ::Validate_Destination(this, idEditDest, idMsg, pchExt, fMustBeDir, fCantBeDir);

	// we're not using the standard page validation so do our
	// own setting of state vars here...:-(
	// clear the validation ID check!
	if (fReturn && (idEditDest == IDC_OPTSTR))
		m_nValidateID = NULL;
	return fReturn;
}

void CToolOptionTab::Refresh()
{
	if (!m_fRefresh)	return;	// can't do this now
	
	CString strText; strText = "";

	CWnd * pWnd = GetDlgItem(IDC_OPTSTR);
	ASSERT(pWnd != (CWnd *)NULL);

	BOOL fEnableSetDefault;

	// are we generating an option string or a descriptive text?
	if (m_pProxySlob->GetContainer() == (CSlob *)NULL)
	{
		g_prjoptengine.GenerateString(strText, OBShowFake);

		// preserve the selection if we have the focus and we have full-select
		int nStartChar, nEndChar;
		((CEdit *)pWnd)->GetSel(nStartChar, nEndChar);
		CWnd * pwndFocus = GetFocus();
		BOOL fPreserveSel = (pwndFocus != (CWnd *)NULL) &&					// has focus
							(pWnd->m_hWnd == pwndFocus->m_hWnd) &&	// edit has focus
							(nStartChar == 0) &&			// full-select
							(nEndChar == pWnd->GetWindowTextLength());

		m_fRefresh = FALSE;
		pWnd->SetWindowText(strText);
		m_fRefresh = TRUE;

		// full-select, leave caret at end->start
		if (fPreserveSel)
			((CEdit *)pWnd)->SetSel(0, -1);
	}
	else
	{
		// are we multi-select?
		if (m_pProxySlob->IsSingle())
		{
			BOOL fDummy;
			g_prjoptengine.GenerateDescription(strText, fDummy);
		}
		else
			strText.LoadString(IDS_PEROPT_NA);
										 
		pWnd->SetWindowText(strText);
	}

	fEnableSetDefault = FALSE;	// by default, no
	POSITION pos = m_pProxySlob->GetHeadPosition();
	while (!fEnableSetDefault && (pos != (POSITION)NULL))
		fEnableSetDefault = m_popthdlr->CanResetPropsForConfig(m_pProxySlob->GetNext(pos)->pcr);

	// do we have a 'Set Defaults' button, if so enable/disable approp.
	if ((pWnd = GetDlgItem(IDC_SET_DEFAULT)) != (CWnd *)NULL)
		EnableButton(pWnd,fEnableSetDefault);
}

void CToolOptionTab::Update()
{
	// do we need to ignore this?
	if (!m_fRefresh)	return;

	m_fRefresh = FALSE;

	CString	strOption;

	ConfigurationRecord* pPcrBase = const_cast<ConfigurationRecord*>(m_pProxySlob->GetBaseConfig());
	CProject* pProject = m_pProxySlob->GetProject();

	ASSERT(NULL!=pProject);

	CProjTempConfigChange projTempConfigChange(pProject);

	if (NULL!=pPcrBase)
		projTempConfigChange.ChangeConfig(pPcrBase);

	// get our options string from the edit-item and parse it
	GetDlgItem(IDC_OPTSTR)->GetWindowText(strOption);
	g_prjoptengine.ParseString(strOption);

	m_fRefresh = TRUE;
}

BOOL COptionMiniPage::PreTranslateMessage(MSG* pMsg)
{
	// all tab events and accelerators are handled by the CTabbedDialog
	if (((CTabbedDialog*)m_pToolOptionTab->GetParent())->MessageStolenByTabbedDialog(pMsg))
		return TRUE;

	// call our base class
	return CDialog::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\prjconfg.cpp ===
//
// CProjComponentMgr, CProjType
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "prjoptn.h"	// our project options

#include "project.h"	// CProject class
#include "exttarg.h"	// The external target type

#include "resource.h"	// our Windows resource ids

#include "version.h"	// version info.

#ifdef PROJECT_CONFIGURE
IMPLEMENT_DYNAMIC(CProjectConfigureDialog, CDialog)	// C3dDialog is not dynamic.
#endif // PROJECT_CONFIGURE

IMPLEMENT_DYNCREATE(CBldSysCmp, CSlob)

IMPLEMENT_DYNCREATE(CPlatform, CBldSysCmp)

IMPLEMENT_DYNCREATE(CProjType, CBldSysCmp)

IMPLEMENT_DYNAMIC(COLEProjType, CProjType)

IMPLEMENT_DYNAMIC(CProjTypeUnknown, CProjType)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

// define the global tool option engine (parsing & generation)
COptionTable AFX_DATA_EXPORT g_prjoptengine;

// define the global project configuration manager
CProjComponentMgr g_prjcompmgr;

// This helper routine attempts to create a unique name for an output
// directory.  This is called when a new configuration is created in
// order to establish unique output directories for that new configuration.
// This routine only checks for collisions with other configurations at
// the CProject level -- if a group in some configuration uses an output
// directory with the same name we propose, this routine doesn't catch that.
// But checking the project level should work in 90%+ of cases since most
// users won't override at the group or file level anyway.
//
// This routine should probably be in some PROJUTIL.CPP file...
void GetNewOutputDirName(CProject * pProject, const CString & strNewConfig, CString & strResult)
{
			int			nNumCfgs, nCfg, nTweak;
			BOOL		bUnique, bDirValid;
	const	CPath *		pProjPath;
			CPath		path;
			CDir		dirProj;
			CProp *		pProp;
			CPropBag *	pPropBag;

	ASSERT(!strNewConfig.IsEmpty());

	strResult = strNewConfig;
	// Replace any non-alphanumeric characters with '_'.
	for (int i=0;i<strResult.GetLength();i++)
	{
		#ifdef _MBCS
		if (_ismbblead(strResult[i]))
			i++;	// ignore/allow DBCS characters
		else
		#endif
		if (!IsCharAlphaNumeric(strResult[i]))
		{
			strResult.SetAt(i, _T('_'));
		}
	}

	// Now check to see if the CProject node has this same output directory
	// name (either intermediate or final) for any other configuration.
	nNumCfgs = pProject->GetPropBagCount();
	nTweak = 0;
	pProjPath = pProject->GetFilePath();
	bDirValid = TRUE;
	dirProj = pProject->GetProjDir();

	for (;;)
	{
		bUnique = TRUE;		// Assume

		// First check to see if the name exists on disk -- if so, it's
		// a poor choice for an output directory name.
		if	(
			(bDirValid)
			&&
			(path.CreateFromDirAndFilename(dirProj, strResult))
			&&
			(path.ExistsOnDisk())
			)
		{
			bUnique = FALSE;
		}
		else
		{
			for (nCfg=0 ; nCfg<nNumCfgs ; ++nCfg)
			{
				pPropBag = pProject->GetPropBag(nCfg);

				VERIFY((pProp = pPropBag->FindProp(P_ProjConfiguration)) != NULL);
				ASSERT(pProp->m_nType == string);

				if (((CStringProp *)pProp)->m_strVal == strNewConfig)
					continue;	// Don't need to check just-created config

				if ((pProp = pPropBag->FindProp(P_OutDirs_Intermediate)) != NULL)
				{
					ASSERT(pProp->m_nType == string);
					if (((CStringProp *)pProp)->m_strVal == strResult)
					{
						bUnique = FALSE;
						break;
					}
				}

				if ((pProp = pPropBag->FindProp(P_OutDirs_Target)) != NULL)
				{
					ASSERT(pProp->m_nType == string);
					if (((CStringProp *)pProp)->m_strVal == strResult)
					{
						bUnique = FALSE;
						break;
					}
				}
			}
		}

		if (bUnique)
			break;

		// Tweak the last character of the name to see if that helps.
		// if our tweak digit is 9.
		if (nTweak == 10)
		{
			break;			// Ran out of tweak digits; the user gets what we've got!
		}
		if(nTweak != 0){
			// strip off the last charater. NOTE that it is a digit and so not mb
			strResult=strResult.Left(strResult.GetLength()-1);
		}
		strResult += _T('0'+nTweak); // add a digit
		nTweak++;
	}
}

// helper
LONG RegGetKey
(
	HKEY hKey,
	LPCTSTR lpctstr,
	PHKEY phkey,
	BOOL fCreate
)
{
	// either create or just try to open the key
	if (fCreate)
	{
		DWORD dwDisp;
		return RegCreateKeyEx(hKey, lpctstr, 0,
					   	   	   "", REG_OPTION_NON_VOLATILE,
					       	   KEY_ALL_ACCESS, NULL, phkey,
					       	   &dwDisp);
	}
	else
	{
		return RegOpenKeyEx(hKey, lpctstr, 0,
							 KEY_ALL_ACCESS, phkey);
	}
}

// implementation of the CBldSysCmp class

static TCHAR szRegKey[]			= _TEXT("Build System\\Components\\");
static TCHAR szPlatforms[]		= _TEXT("Platforms\\");
static TCHAR szTargets[]		= _TEXT("Targets\\");
static TCHAR szTools[]			= _TEXT("Tools\\");
static TCHAR szVersion[]		= _TEXT("Version");
static TCHAR szCustomList[]		= _TEXT("Custom");
static TCHAR szCustomSection[]	= _TEXT("Custom Tools");

const CString CBldSysCmp::g_strRegKey(szRegKey);

#define theClass CBldSysCmp
BEGIN_SLOBPROP_MAP(CBldSysCmp, CSlob)
	STR_PROP(CompName)
END_SLOBPROP_MAP()
#undef theClass

#define theClass CBldSysCmp
BEGIN_REGISTRY_MAP_P(CBldSysCmp)
END_REGISTRY_MAP()
#undef theClass

CBldSysCmp::CBldSysCmp()
{
	// restore out component's data from the registry
	// this is TRUE by default unless the "Version"
	// value shows an invalid component
	m_fRegRestore = TRUE;
	
	m_dwId = m_dwRelatedId = 0;
}

void CBldSysCmp::SetId(DWORD dwId)
{
	m_dwId = dwId;

	// create our 'default' name?
	if (m_strCompName.IsEmpty())
	{
		sprintf(m_strCompName.GetBuffer(32), "<Component 0x%x>", dwId);
		m_strCompName.ReleaseBuffer();
	}

	m_fCompRegKeyDirty = TRUE;	// our 'cached' key is now dirty
}

void CBldSysCmp::SetRelatedId(DWORD dwRelatedId)
{
	m_dwRelatedId = dwRelatedId;

	m_fCompRegKeyDirty = TRUE;	// our 'cached' key is now dirty
}

CSlob * CBldSysCmp::Clone()
{
	// clone CSlob part first
	CBldSysCmp * pcomp = (CBldSysCmp *)CSlob::Clone();
	if (pcomp != (CBldSysCmp *)NULL)
	{
		// clone the component ids
		pcomp->SetId(m_dwId);
		pcomp->SetRelatedId(m_dwRelatedId);
	}

	return pcomp;
}

BOOL CBldSysCmp::SynchronizeWithRegistry(BOOL fSaveBeforeLoad /* = TRUE */)
{
	const TCHAR * pchKey = GetCompRegKeyName();

	// make sure this key exists
	HKEY hKey;
	if (RegGetKey(HKEY_CURRENT_USER, pchKey, &hKey) != ERROR_SUCCESS)
		return FALSE;	// failed

	// check the version info.
	// major, minor and update version info.
	int iMaj = 0, iMin = 0, iUpd = 0;
	TCHAR * szVerFormat =
#ifndef _SHIP
		_TEXT("%1d.%02d.%04d");	// eg. '3.00.1234'
#else
		_TEXT("%1d.%02d");		// eg. '3.00'
#endif // _SHIP

	DWORD dwType = 0;		// type must be REG_SZ
	TCHAR szVerValue[10];
	DWORD cbData = sizeof(szVerValue) / sizeof(TCHAR);
	if (m_fRegRestore &&				// want to try to restore?
		(RegQueryValueEx(hKey, (LPTSTR)szVersion, NULL, &dwType,
				  		(LPBYTE)szVerValue, &cbData) == ERROR_SUCCESS) &&
		(dwType == REG_SZ) &&			// must be an REG_SZ
		(cbData == 5 || cbData == 10)	// must be '0.00' or '0.00.0000'
	   )
	{
		// got version info. so

#ifndef _SHIP
		// pad with an update version?
		if (cbData == 5)
			_tcscat(szVerValue, _TEXT(".0000"));
#endif

		// and then crack the args
		_stscanf(szVerValue, szVerFormat, &iMaj, &iMin, &iUpd);

		// version ok?
		// ok to restore from registry
		m_fRegRestore = TRUE;
	}

	// write out version info.?
	if (!m_fRegRestore)
	{
		// format the arg
		_stprintf(szVerValue, szVerFormat, rmj, rmm, rup);

		// write out this registry key
		(void) RegSetValueEx(hKey, (LPTSTR)szVersion, NULL, REG_SZ,
							 (LPBYTE)szVerValue, _tcslen(szVerValue) + 1);
	}

	// now write out our data for this component, base component data first
	CPtrList mapStack;	// map stack for remembering position in map
	CString strValue;	// name of value in registry
	CString strSubKey;	// name of possible sub-key

	BOOL fSaving = fSaveBeforeLoad;

	// two-pass, do all saves, then all loads
	DoSyncPass:

	const CRegistryMap * pregmap = GetRegistryMap();
	BOOL fEndOfMap = FALSE;
	while (!fEndOfMap)
	{
		// base map?
		if (pregmap->regType == CRegistryMap::MapBegin)
		{
			if (pregmap->pvData != (const void *)NULL)
			{
				mapStack.AddTail((void *)pregmap);
				pregmap = (const CRegistryMap *)pregmap->pvData;
				continue;	// run down this one
			}
		}
		else
		// end of map?
		if (pregmap->regType == CRegistryMap::MapEnd)
		{
			if (mapStack.IsEmpty())
				fEndOfMap = TRUE;
			else
				pregmap = (const CRegistryMap *)mapStack.RemoveTail();
		}
		else
		{
			HKEY hSubKey = hKey;	// initially subkey is this key!

			// do we have a sub-key?
			if (pregmap->szRegSubKey != NO_SUB_KEY)
			{
				// do we have this subkey resource?
				// VERIFY(strSubKey.LoadString(pregmap->nRegSubKeyId));

				//if (RegGetKey(hKey, (LPCTSTR)(const TCHAR *)strSubKey, &hSubKey) != ERROR_SUCCESS)
				if (RegGetKey(hKey, (LPCTSTR)pregmap->szRegSubKey, &hSubKey) != ERROR_SUCCESS)
					goto NextInRegMap;	// failed goto next one
			}

			// do we have this value resource?
			// VERIFY(strValue.LoadString(pregmap->nRegId));
			strValue = (LPCTSTR)pregmap->szRegField;

			LPBYTE lpbData = (LPBYTE)this + (DWORD)pregmap->pvData;
			
			// make sure we have valid data
			ASSERT(pregmap->regType == CRegistryMap::MapFData || AfxIsValidAddress(lpbData, pregmap->cbData));

			DWORD dwType, cbData;	// retrieved from registry using RegDataExists()
			if (m_fRegRestore && RegDataExists(pregmap, hSubKey, &strValue, &dwType, &cbData))
			{
				// yes, so load it?
				if (!fSaving)
				{
					VERIFY(LoadRegData(pregmap, hSubKey, &strValue, lpbData, cbData));
				}
  			}
			else
			{
				// no, so save it?
				if (fSaving)
				{
					cbData = pregmap->cbData; // size of the data arena to fill
					VERIFY(SaveRegData(pregmap, hSubKey, &strValue, lpbData, cbData));
				}
			}

			// do we have a sub-key to close?
			if (pregmap->szRegSubKey != NO_SUB_KEY)
				RegCloseKey(hSubKey);
		}

		NextInRegMap:

		// next reg. map entry
		pregmap++;
	}

	// do the loading pass?
	if (m_fRegRestore)
	{
		if (!(fSaving = !fSaving))
			goto DoSyncPass;
	}

	// close the key
	RegCloseKey(hKey);

	return TRUE;		// ok
}

BOOL CBldSysCmp::Serialize(TCHAR * pch, UINT & cch)
{
	CPtrList mapStack;	// map stack for remembering position in map
	const CRegistryMap * pregmap = GetRegistryMap();

	UINT cchBuf = cch;
	UINT cchLen;

	// write out the component name
	const CString * pstrName = GetName();
	cchLen = pstrName->GetLength();
	if (cchBuf < (cchLen + 1))	// incl. zero term.
		return FALSE;	// need more memory

	_tcscpy(pch, (const TCHAR *)*pstrName);
	pch += cchLen; cchBuf -= cchLen;
	*pch++ = _T('\0'); cchBuf--;

	BOOL fEndOfMap = FALSE;
	while (!fEndOfMap)
	{
		// base map?
		if (pregmap->regType == CRegistryMap::MapBegin)
		{
			if (pregmap->pvData != (const void *)NULL)
			{
				mapStack.AddTail((void *)pregmap);
				pregmap = (const CRegistryMap *)pregmap->pvData;
				continue;	// run down this one
			}
		}
		else
		// end of map?
		if (pregmap->regType == CRegistryMap::MapEnd)
		{
			if (mapStack.IsEmpty())
				fEndOfMap = TRUE;
			else
				pregmap = (const CRegistryMap *)mapStack.RemoveTail();
		}
		else
		{
			// sub-keys are not supported!
			ASSERT(pregmap->szRegSubKey == NO_SUB_KEY);
			
			// do we have this value resource?
			// VERIFY(strValue.LoadString(pregmap->nRegId));
			CString strValue = pregmap->szRegField;

			// buffer has room for this value name + space sep.?
			cchLen = strValue.GetLength();
			if (cchBuf < (cchLen + 1))	// incl. space sep.
				return FALSE;	// need more memory

			_tcscpy(pch, (const TCHAR *)strValue);
			pch += cchLen; cchBuf -= cchLen;
			*pch++ = _T(' '); cchBuf--;

			// data to write-out
			LPBYTE lpbData = (LPBYTE)this + (DWORD)pregmap->pvData;
			
			// make sure we have valid data
			ASSERT(pregmap->regType != CRegistryMap::MapFData && AfxIsValidAddress(lpbData, pregmap->cbData));

			// what kind of data?
			switch (pregmap->dwType)
			{
				case REG_STRING:
				{
					// if we are using REG_STRING then we need to do some CString buffer magic
					// and fix up lpbData and cbData
					cchLen = ((CString *)lpbData)->GetLength();
					if (cchBuf < cchLen)
						return FALSE;	// need more memory

					// copy string value
					_tcscpy(pch, (const TCHAR *)*((CString *)lpbData));
					pch += cchLen; cchBuf -= cchLen;
					break;
				}

				case REG_DWORD:
				{
					TCHAR pchVal[10 + 1];
					cchLen = _tcslen(_itoa((unsigned long)(DWORD *)*lpbData, pchVal, 16));
					if (cchBuf < (cchLen + 2))	// allow for '0x'
						return FALSE;	// need more memory

					// copy hex. prefix
					_tcscpy(pch, "0x");
					pch += 2; cchBuf -= 2;

					// copy number value
					_tcscpy(pch, pchVal);
					pch += cchLen; cchBuf -= cchLen;
					break;
				}
			}

			// buffer has space for zero. term.?
			if (cchBuf < 1)
				return FALSE;	// need more memory

			*pch++ = _T('\0'); cchBuf--;
		}

		// next reg. map entry
		pregmap++;
	}

	// return chars. copied
	cch = cch - cchBuf;

	return TRUE;	// success
}

BOOL CBldSysCmp::Deserialize(TCHAR * pch, UINT cch)
{
	// FUTURE:
	return FALSE;
}

BOOL CBldSysCmp::RegGetDataKey(const CRegistryMap * pregmap, PHKEY phkey, BOOL fCreate)
{
	const TCHAR * pchKey = GetCompRegKeyName();

	// make sure the parent key exists
	HKEY hKey;
	if (RegGetKey(HKEY_CURRENT_USER, pchKey, &hKey, fCreate) != ERROR_SUCCESS)
		return FALSE;	// failed

	BOOL fRet = TRUE;	// success, unless get subkey fails
	*phkey = hKey;		// unless we have a subkey, this is the one we want

	// do we have a sub-key?
	if (pregmap->szRegSubKey != NO_SUB_KEY)
	{
		// do we have this subkey resource?
		// VERIFY(strSubKey.LoadString(pregmap->nRegSubKeyId));
		CString strSubKey = pregmap->szRegSubKey;	// name of possible sub-key

		fRet = RegGetKey(hKey, (LPCTSTR)(const TCHAR *)strSubKey, phkey, fCreate) == ERROR_SUCCESS;
		
		// always close the parent key
		RegCloseKey(hKey);
	}

	return fRet;	// success
}

BOOL CBldSysCmp::LoadRegData(UINT nRegId)
{
	const CRegistryMap * pregmap = GetRegMapEntry(nRegId);
	ASSERT(pregmap != (const CRegistryMap *)NULL);

	HKEY hDataKey;
	// n.b don't create key if doesn't exist already
	if (!RegGetDataKey(pregmap, &hDataKey, FALSE))
		return FALSE;

	// do we have this value resource?
	// VERIFY(strValue.LoadString(pregmap->nRegId));
	CString strValue = pregmap->szRegField;	// name of value in registry

	LPBYTE lpbData = (LPBYTE)this + (DWORD)pregmap->pvData;
	
	// make sure we have valid data
	ASSERT(pregmap->regType == CRegistryMap::MapFData || AfxIsValidAddress(lpbData, pregmap->cbData));

	DWORD dwType, cbData;	// retrieved from registry using RegDataExists()
	if (RegDataExists(pregmap, hDataKey, &strValue, &dwType, &cbData))
		VERIFY(LoadRegData(pregmap, hDataKey, &strValue, lpbData, cbData));

	// close the data key
	RegCloseKey(hDataKey);

	return TRUE;	// success
}

BOOL CBldSysCmp::SaveRegData(UINT nRegId)
{
	const CRegistryMap * pregmap = GetRegMapEntry(nRegId);
	ASSERT(pregmap != (const CRegistryMap *)NULL);

	HKEY hDataKey;
	// n.b. always create key
	if (!RegGetDataKey(pregmap, &hDataKey, TRUE))
		return FALSE;

	// do we have this value resource?
	// VERIFY(strValue.LoadString(pregmap->nRegId));
	CString strValue = pregmap->szRegField;	// name of value in registry

	LPBYTE lpbData = (LPBYTE)this + (DWORD)pregmap->pvData;
	
	// make sure we have valid data
	ASSERT(pregmap->regType == CRegistryMap::MapFData || AfxIsValidAddress(lpbData, pregmap->cbData));

	DWORD cbData;	// retrieved from registry using RegDataExists()
	cbData = pregmap->cbData; // size of the data arena to fill
	VERIFY(SaveRegData(pregmap, hDataKey, &strValue, lpbData, cbData));

	// close the data key
	RegCloseKey(hDataKey);

	return TRUE;	// success
}

const CRegistryMap * CBldSysCmp::GetRegMapEntry(UINT nRegId)
{
	CPtrList mapStack;	// map stack for remembering position in map
	const CRegistryMap * pregmap = GetRegistryMap();
	BOOL fEndOfMap = FALSE;
	while (!fEndOfMap)
	{
		// base map?
		if (pregmap->regType == CRegistryMap::MapBegin)
		{
			if (pregmap->pvData != (const void *)NULL)
			{
				mapStack.AddTail((void *)pregmap);
				pregmap = (const CRegistryMap *)pregmap->pvData;
				continue;	// run down this one
			}
		}
		else
		// end of map?
		if (pregmap->regType == CRegistryMap::MapEnd)
		{
			if (mapStack.IsEmpty())
				fEndOfMap = TRUE;
			else
				pregmap = (const CRegistryMap *)mapStack.RemoveTail();
		}
		else
		// found the registry entry we want?
		if (pregmap->nRegId == nRegId)
			//
			// FOUND registry entry
			return pregmap;

		// next reg. map entry
		pregmap++;
	}

	//
	// NO registry entry
	return (const CRegistryMap *)NULL;
}

BOOL CBldSysCmp::RegDataExists
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPDWORD pdwType, LPDWORD pcbData
)
{
	// data in registry?
	BOOL fRet = RegQueryValueEx(hKey, (LPTSTR)(const TCHAR *)*pstrValue, NULL, pdwType,
		   				        (LPBYTE)NULL, pcbData) == ERROR_SUCCESS;

	// make sure we have matching types if we succeeded
	ASSERT(!fRet || *pdwType == MapRegType(pregmap->dwType));
	return fRet;
}

BOOL CBldSysCmp::LoadRegData
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPBYTE lpbData, DWORD cbData
)
{
	ASSERT(lpbData != (BYTE *)NULL);	// forgot to implement 'special' override?

	DWORD dwType = pregmap->dwType;

	// if we are using REG_STRING then we need to do some CString buffer magic
	// and expand the buffer to the req. size
	CString * pstr = (CString *) (dwType == REG_STRING ? lpbData : NULL);
	if (pstr != (CString *)NULL)
	{
		(void) pstr->GetBuffer(cbData);
		lpbData = (LPBYTE)(const TCHAR *)*pstr;

		dwType = MapRegType(dwType);	// re-map to be a regualar system reg. type
	}

	// load the data
	if (RegQueryValueEx(hKey, (LPTSTR)(const TCHAR *)*pstrValue, NULL, &dwType,
				  		(LPBYTE)lpbData, &cbData) != ERROR_SUCCESS)
		return FALSE;	// failed

	// ensure that we adjust for the correct length (null-terminated string)
	if (pstr != (CString *)NULL)
		(void) pstr->ReleaseBuffer();

	return TRUE;	// ok
}

BOOL CBldSysCmp::SaveRegData
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPBYTE lpbData,
	DWORD cbData
)
{
	ASSERT(lpbData != (BYTE *)NULL);	// forgot to implement 'special' override?

	DWORD dwType = pregmap->dwType;

	// if we are using REG_STRING then we need to do some CString buffer magic
	// and fix up lpbData and cbData
	CString * pstr = (CString *) (dwType == REG_STRING ? lpbData : NULL);
	if (pstr != (CString *)NULL)
	{
		cbData = (DWORD)pstr->GetLength() + 1;
		lpbData = (LPBYTE)(const TCHAR *)*pstr;

		dwType = MapRegType(dwType);	// re-map to be a regualar system reg. type
	}

	// save the data
	if (RegSetValueEx(hKey, (LPTSTR)(const TCHAR *)*pstrValue, NULL, dwType,
			  			  lpbData, cbData) != ERROR_SUCCESS)
		return FALSE;	// failed

	return TRUE;	//ok
}

const TCHAR * CBldSysCmp::GetCompRegKeyName(BOOL fInclAppKey)
{
	if (m_fCompRegKeyDirty)
	{
		DWORD bsc_id = m_dwId;
		CBldSysCmp * pcomp;
		CString str;
	 	TCHAR * pchType;

		m_strCompRegKey.Empty();
		do
		{
			// get our component name
			if (g_prjcompmgr.LookupBldSysComp(bsc_id, pcomp))
				str = *pcomp->GetName();			// component name
			else
				{ASSERT(FALSE); return _TEXT("<Failed>");}		// failed!

			// get our component type
			if (pcomp->IsKindOf(RUNTIME_CLASS(CPlatform)))
				pchType = szPlatforms;

			else if (pcomp->IsKindOf(RUNTIME_CLASS(CProjType)))
				pchType = szTargets;

			else if (pcomp->IsKindOf(RUNTIME_CLASS(CBuildTool)))
				pchType = szTools;

			else if (pcomp->IsKindOf(RUNTIME_CLASS(COptionHandler)))
				ASSERT(FALSE);						// shouldn't be here!

			// concat. our component name to *front* of current key
			str += _TEXT("\\");
			str += m_strCompRegKey;

			// concat. our component type to *front* of component name
			m_strCompRegKey = pchType;
			m_strCompRegKey += str;

		} while ((bsc_id = pcomp->RelatedCompId()) != idAddOnGeneric);
		// 'break' out on bsc_id == idAddOnGeneric

		// append the BldSys key ro *front*
		m_strCompRegKey = *GetRegKeyName() + m_strCompRegKey;

		// append the Visual C++ key to *front*
		m_strFullCompRegKey = ::GetRegistryKeyName();
		m_strFullCompRegKey += _TEXT("\\");
		m_strFullCompRegKey += m_strCompRegKey;

		m_fCompRegKeyDirty = FALSE;	// not dirty anymore.
	}

 	return fInclAppKey ? (const TCHAR *)m_strFullCompRegKey : (const TCHAR *)m_strCompRegKey;
}

// implementation of the CProjComponentMgr class
void DefaultConfig(CProject * pProject, const CString & strPlatformUIDescription, UINT nIDMode, CString & strConfig)
{
	CString strName = pProject->GetFilePath()->GetFileName();
	int iDot = strName.ReverseFind(_T('.'));
	if (iDot > 0)
		strName = strName.Left(iDot);

	CString strMode;
	VERIFY(strMode.LoadString(nIDMode));
	strConfig =  strName + _T(" - ") + strPlatformUIDescription + _T(' ') + strMode;
}

CProjComponentMgr::CProjComponentMgr()
{
	// init. enumerator info.
	m_posProjType = (POSITION)NULL;				// no next projtype
	m_posTool = (POSITION)NULL;					// no next build tool

	m_idOptPropBase = PROJ_BUILD_OPTION_FIRST;	// our next option prop id.
	m_dwCustomBase = BCID_Custom_Component;		// our next custom component

	// FUTURE: remove this
	m_cSchmoozeTools = 0;						// no Schmooze tools initially registered

	m_nPropFirst = m_nPropLast = (UINT)-1;
	m_popthdlrCache = (COptionHandler *)NULL;

	// retrieve other information about the environment components might use
	CString strKeyName;
	HKEY hKey;

	// do we have ODBC installed?
	m_fODBCInstalled = TRUE;	// default is yes (error in favour of ODBC)

	// do we have MFC installed?
	m_fMFCInstalled = TRUE;		// default is yes (error in favour of MFC)

	strKeyName = GetRegistryKeyName();
	strKeyName += _TEXT("\\General");
	if (RegOpenKeyEx(HKEY_CURRENT_USER, strKeyName, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType, dwValue, dwValueSize = sizeof(DWORD);
		if (RegQueryValueEx(hKey, _TEXT("MFCInstalled"), NULL, &dwType, (LPBYTE)&dwValue, &dwValueSize) == ERROR_SUCCESS)
		{
			// make sure we get the value we expect
			ASSERT(dwType == REG_DWORD);
			ASSERT(dwValueSize == sizeof(DWORD));
			m_fMFCInstalled = dwValue != 0;
		}
		if (RegQueryValueEx(hKey, _TEXT("ODBCInstalled"), NULL, &dwType, (LPBYTE)&dwValue, &dwValueSize) == ERROR_SUCCESS)
		{
			// make sure we get the value we expect
			ASSERT(dwType == REG_DWORD);
			ASSERT(dwValueSize == sizeof(DWORD));
			m_fODBCInstalled = dwValue != 0;
		}
		RegCloseKey(hKey); // close the key we just opened
	}
	m_fInit = FALSE;
}

CProjComponentMgr::~CProjComponentMgr()
{
	// delete out unknown project objects
	POSITION pos = m_lstUnkProjObjs.GetHeadPosition();
	CObject * pobj;
	while (pos != (POSITION)NULL)
	{
		pobj = (CObject *)m_lstUnkProjObjs.GetNext(pos);
		ASSERT_VALID(pobj);
		delete pobj;	// delete the object
	}

	// delete our build system components for the packages

	// delete in this order
	CRuntimeClass * rgDTOROrder[] =
	{
		// project types next
		RUNTIME_CLASS(CProjType),

		// then everything else
		RUNTIME_CLASS(CObject)
	};

	CBldSysCmp * pcomp;
	void * rkey;
	UINT iDTOROrder = 0;

	while (iDTOROrder < sizeof(rgDTOROrder) / sizeof(CRuntimeClass *))
	{
		CRuntimeClass * pRC = rgDTOROrder[iDTOROrder];

		pos = m_mapBldSysCmps.GetStartPosition();
		while (pos != (POSITION)NULL)
		{
			m_mapBldSysCmps.GetNextAssoc(pos, rkey, (void *&)pcomp);
			if (pcomp->IsKindOf(pRC))
			{
				delete (CBldSysCmp *)pcomp; // delete the component
				m_mapBldSysCmps.RemoveKey(rkey); // remove this one
			}
		}

		iDTOROrder++;
	}
}

BOOL CProjComponentMgr::FInit()
{
	// first off, ask the packages to register their components
	// we'll need to arrange the list of packages ourselves
	CObList lstArngdPackages;
	lstArngdPackages.AddTail(&(theApp.m_packages));

	// Now create the OLE servers for NON package based ones
	POSITION pos;
	pos = lstArngdPackages.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);
		(void) pPackage->DoBldSysCompRegister(this, BLC_OleAddOn, m_dwRegisterId);
	}

	// first ask for generic components
	// o platforms
	// o tools not platform specific
	// o builder converters not product specific
	pos = lstArngdPackages.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		POSITION posCurr = pos;
		CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);

		m_dwRegisterId = idAddOnGeneric;	// general

		m_fRegPrimaryPlatform = FALSE;	// use this to check if registered a primary platform
		(void) pPackage->DoBldSysCompRegister(this, BLC_Platform, m_dwRegisterId);

		// registered a primary platform?
		if (m_fRegPrimaryPlatform)
		{
			// move package to head of list
			lstArngdPackages.RemoveAt(posCurr);
			lstArngdPackages.AddHead(pPackage);
		}

		(void) pPackage->DoBldSysCompRegister(this, BLC_Tool, m_dwRegisterId);
		(void) pPackage->DoBldSysCompRegister(this, BLC_OptionHdlr, m_dwRegisterId);
		(void) pPackage->DoBldSysCompRegister(this, BLC_BldrCnvtr, m_dwRegisterId);		
	}

	// Now register tools and platforms from the Ole Servers
	pos = m_AddOns.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		IEnumBuildTools *pToolEnum = NULL;

		LPBUILDSYSTEMADDON pAddOn = (LPBUILDSYSTEMADDON)m_AddOns.GetNext(pos);

		// Get the tools
		LPBUILDTOOL pTool = NULL;
		pAddOn->EnumBuildTools( &pToolEnum, &pTool );
		if( pTool ){
			UINT tool_id,pkg_id,bsc_id;
			pTool->GetID(&tool_id);
			pAddOn->GetID(&pkg_id);
			bsc_id = GenerateComponentId(pkg_id, tool_id);
			RegisterOleTool( pTool, bsc_id );
		} else if( pToolEnum ) { 
			LPBUILDTOOL pTools[10];
			ULONG nGot = 10;
			UINT pkg_id;
			pAddOn->GetID(&pkg_id);
			while( nGot == 10 ){
				pToolEnum->Next( 10, pTools, &nGot );
				ULONG i=0;
				while ( i < nGot ){
					// note that I am not releasing here
					UINT tool_id,bsc_id;
					pTool->GetID(&tool_id);
					bsc_id = GenerateComponentId(pkg_id, tool_id);
					RegisterOleTool( pTools[i], bsc_id );
					i++;
				}
			}
			pToolEnum->Release();
		}

		// Get the paltforms
		IPlatform *pPlat = NULL;
		IEnumPlatforms *pPlatEnum = NULL;
		pAddOn->EnumPlatforms( &pPlatEnum, &pPlat );
		if( pPlat != NULL ) {
			RegisterOlePlatform( pPlat, NULL/* bsc_id */ );
		} else if ( pPlatEnum != NULL ) { 
			LPPLATFORM pPlats[10];
			ULONG nGot = 10;
			while( nGot == 10 ){
				pPlatEnum->Next( 10, pPlats, &nGot );
				ULONG i=0;
				while ( i < nGot ){
					// note that I am not releasing here
					RegisterOlePlatform( pPlats[i], NULL/* bsc_id */ );
					i++;
				}
			}
		}

		// option handlers and bld converters here ?
	}


/*
R.I.P. for v4.0 with VBA?
	// retrieve our custom components
	if (!RetrieveGlobalCustomTool())
	{
		ASSERT(FALSE);	// FUTURE: error msg. goes here...
	}
*/

	// now ask each for any other components for each of these platforms
	// o tools
	// o target types (target types will bind to tools)
	// o builder converters
	CPlatform * pPlatform;
	InitPlatformEnum();
	while (NextPlatform(pPlatform))
	{
 		pos = lstArngdPackages.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);

			m_dwRegisterId = pPlatform->CompId();	// for each platform
			(void) pPackage->DoBldSysCompRegister(this, BLC_Tool, m_dwRegisterId);
			(void) pPackage->DoBldSysCompRegister(this, BLC_TargetType, m_dwRegisterId);
			(void) pPackage->DoBldSysCompRegister(this, BLC_BldrCnvtr, m_dwRegisterId);
		}
	}

	// Now register target types from the Ole Servers
	pos = m_AddOns.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		IEnumProjectTypes *pIEnum = NULL;
		IProjectType *pProj = NULL;
		LPBUILDSYSTEMADDON pAddOn = (LPBUILDSYSTEMADDON)m_AddOns.GetNext(pos);
		pAddOn->EnumProjectTypes( &pIEnum, &pProj );
		if( pProj != NULL ){
			 RegisterOleProjType( pProj, NULL/* bsc_id */ );
		} else if ( pIEnum != NULL ){
			LPPROJECTTYPE pProjs[10];
			ULONG nGot = 10;
			while( nGot == 10 ){
				pIEnum->Next( 10, pProjs, &nGot );
				ULONG i=0;
				while ( i < nGot ){
					// note that I am not releasing here
					RegisterOleProjType( pProjs[i], NULL/* bsc_id */ );
					i++;
				}
			}
		}
	}

	// ask for any tools that may wish to be a part of target type
	CProjType * pProjType;
	InitProjTypeEnum();
	while (NextProjType(pProjType))
	{
		// not for external targets!
 		if (pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
			continue;

		pos = lstArngdPackages.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);
			m_dwRegisterId = pProjType->CompId();	// for each target
			(void) pPackage->DoBldSysCompRegister(this, BLC_Tool, m_dwRegisterId);
		}
	}

	// Now we inform each add on that it can add additional tools to project types
	LPBUILDSYSTEM pInterface;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR*)&pInterface)));
	pos = m_AddOns.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		LPENUMPROJECTTYPES pIEnum = NULL;
		LPPROJECTTYPE pProj = NULL;

		// each add on gets their own copy and MUST release it.
		LPBUILDSYSTEMADDON pAddOn = (LPBUILDSYSTEMADDON)m_AddOns.GetNext(pos);
		pInterface->EnumProjectTypes( &pIEnum, &pProj );
		pAddOn->ModifyProjectTypes( pIEnum );

	}
	pInterface->Release();


	// now ask for the option handlers for each platform (option handlers will bind to tools)
 	InitPlatformEnum();
	while (NextPlatform(pPlatform))
	{
 		pos = lstArngdPackages.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CPackage * pPackage = (CPackage  *)lstArngdPackages.GetNext(pos);

			m_dwRegisterId = pPlatform->CompId();	// will bind to a tool
			(void) pPackage->DoBldSysCompRegister(this, BLC_OptionHdlr, m_dwRegisterId);
		}
	}

	int			nCountPlatforms = 0;
	BOOL		bFoundPrimary = FALSE;

	// create our hashed index into the platforms
	// and at the same time FInit() the platforms
	InitPlatformEnum();
	while (NextPlatform(pPlatform))
	{
		if (pPlatform->FInit())
		{
			m_mapPlatforms.SetAt(*(pPlatform->GetName()), pPlatform);

			// count many platforms
			++nCountPlatforms;

			// ensure only one primary platform
			if (pPlatform->IsPrimaryPlatform())
			{
				ASSERT(!bFoundPrimary);
				bFoundPrimary = TRUE;
			}
		}
	}

 	// make sure we have at least one supported platform
	//if ((nCountPlatforms == 0) || !bFoundPrimary)
	if (nCountPlatforms == 0)
	{
		// this is v.bad, the build system is disabled
		ErrorBox(IDS_ERROR_NO_PLATFORMS);
	}

	// HACK ALERT
	// FUTURE (colint)
	// This code rearranges our projtype list so that all the
	// external target types are at the end of the list. This
	// is so that whenever we display a list of the projtypes
	// the external target type is always at the end. This code
	// should be replaced by a general mechanism for ordering
	// the projtype list for UI purposes.
	CProjType* pprojtype;
	CPtrList lstExtTargets;
	POSITION posCurr;
	
	// First we cycle through the projtypes building up a list
	// of all the external target types, and removing them from
	// the master list
	pos = m_lstProjTypes.GetHeadPosition();
	while (pos)
	{
		posCurr = pos;
		pprojtype = (CProjType*) m_lstProjTypes.GetNext(pos);
		if (pprojtype->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
		{
			m_lstProjTypes.RemoveAt(posCurr);
			lstExtTargets.AddTail(pprojtype);
		}
	}

	// Next we add back the external target types at the end of
	// the master list.
	pos = lstExtTargets.GetHeadPosition();
	while (pos)
	{
		pprojtype = (CProjType*) lstExtTargets.GetNext(pos);
		m_lstProjTypes.AddTail(pprojtype);
	}
	// END OF HACK ALERT

	// create our hashed index into the project types
 	InitProjTypeEnum();
	while (NextProjType(pprojtype))
	{
		m_mapProjTypes.SetAt(*(pprojtype->GetName()), pprojtype);
	}

/*
R.I.P. for v4.0 with VBA?
	// register our builder file section to read/write custom tools
	m_bldsection.m_strName = szCustomSection;
	m_bldsection.m_pfn = &SerializeProjectCustomTool;
	VERIFY(GetBldSysIFace()->RegisterSection(&m_bldsection));
*/

	return TRUE;
}

void CProjComponentMgr::Term()
{
/*
R.I.P. for v4.0 with VBA?
	// store our custom components
	if (!StoreGlobalCustomTool())
	{
		ASSERT(FALSE);	// FUTURE: error msg. goes here...
	}

	// de-register our builder file section
	VERIFY(GetBldSysIFace()->DeregisterSection(&m_bldsection));
*/
}

WORD CProjComponentMgr::GenerateBldSysCompPackageId(const TCHAR * szPackageName)
{	
	// szAddOnGeneric is zero
	if (szPackageName == szAddOnGeneric)
		return 0;

	// do we have this package id already?
	int iAddOn = m_rgstrAddOns.GetSize();
	while (iAddOn > 0)
	{
		iAddOn--;
		if (_tcscmp((TCHAR *)(const TCHAR *)m_rgstrAddOns[iAddOn], (TCHAR *)szPackageName) == 0)
			return (WORD)iAddOn + 1;
	}

	// new package id
	return (WORD)m_rgstrAddOns.Add(szPackageName) + 1;	// zero is reserved
}

int CProjComponentMgr::GetSupportedPlatformCount()
{
	int count = 0;
	POSITION pos = m_lstPlatforms.GetHeadPosition();
	while (pos != NULL)
	{
		if (((CPlatform *)m_lstPlatforms.GetNext(pos))->IsSupported())
			count++;
	}
	return count;
}

BOOL CProjComponentMgr::RegisterBldSysComp(CBldSysCmp * pcomp, DWORD bsc_id)
{
	BOOL fInRegistry = TRUE, fSaveBeforeLoad = TRUE;

 	// set the id.?
	if (!pcomp->CompId() && bsc_id != (DWORD)-1)
		pcomp->SetId(bsc_id);

	DWORD type = BldSysCompType(pcomp);

	// set the related id.
	if (!pcomp->RelatedCompId())
	{
		// custom tools are always generic
		if (type == BLC_CustomTool)
			pcomp->SetRelatedId(idAddOnGeneric);
		else
			pcomp->SetRelatedId(m_dwRegisterId);
	}

	// make sure we don't already have this
	ASSERT(!LookupBldSysComp(pcomp->CompId(), pcomp));

	// depending on the type of component this is,
	// we'll register in different lists
	switch (type)
	{
		case BLC_Platform:
			RegisterPlatform((CPlatform *)pcomp);
			break;

		case BLC_TargetType:
			RegisterProjType((CProjType *)pcomp);
			break;

/*
R.I.P. for v4.0 with VBA?
		case BLC_CustomTool:
			RegisterCustomTool((CCustomTool *)pcomp);
			fSaveBeforeLoad = FALSE;	// only load from registry!
			break;
*/

		case BLC_Tool:
			RegisterBuildTool((CBuildTool *)pcomp);
			break;

		case BLC_BldrCnvtr:
			RegisterBuilderConverter((CBuilderConverter *)pcomp);
			fInRegistry = FALSE;		// not in registry!
			break;

		case BLC_OptionHdlr:
			RegisterOptionHandler((COptionHandler *)pcomp);
			fInRegistry = FALSE;		// not in registry!
			break;

		default:
			ASSERT(FALSE);	// unknown bldsys component
			return FALSE;	// failure
	}

	// for quick retrieval use a map of id->component
	m_mapBldSysCmps.SetAt((void *)pcomp->CompId(), pcomp);

	// make sure that the component and system registry are in sync.
	if (fInRegistry && !pcomp->SynchronizeWithRegistry(fSaveBeforeLoad))
		return FALSE;	// failed to sync. with registry

	return TRUE;	// success
}

// get a component type for a component with id, 'bsc_id', returns 'BLC_ERROR' if not found
DWORD CProjComponentMgr::BldSysCompType(DWORD bsc_id)
{
	CBldSysCmp * pcomp;
	// does this component exist in the registry?
	if (!LookupBldSysComp(bsc_id, pcomp))
		return BLC_ERROR;

	return BldSysCompType(pcomp);
}

// get a component type for a component with id, 'bsc_id', returns 'BLC_ERROR' if not found
DWORD CProjComponentMgr::BldSysCompType(CBldSysCmp * pcomp)
{
	// our component type
	DWORD type = BLC_ERROR;

	// depending on the type of component this is,
	// we'll register in different lists
	if (pcomp->IsKindOf(RUNTIME_CLASS(CPlatform)))
		type = BLC_Platform;

	else if (pcomp->IsKindOf(RUNTIME_CLASS(CProjType)))
		type = BLC_TargetType;

/*
R.I.P. for v4.0 with VBA?
	else if (pcomp->IsKindOf(RUNTIME_CLASS(CCustomTool)))
		type = BLC_CustomTool;
*/

	else if (pcomp->IsKindOf(RUNTIME_CLASS(CBuildTool)))
		type = BLC_Tool;

	else if (pcomp->IsKindOf(RUNTIME_CLASS(COptionHandler)))
		type = BLC_OptionHdlr;

	else if (pcomp->IsKindOf(RUNTIME_CLASS(CBuilderConverter)))
		type = BLC_BldrCnvtr;

	return type;	// return our type
}

// generic object removal
BOOL CProjComponentMgr::DeregisterComponent(CPtrList & lst, CObject * ptr)
{
	// remove it from our list
	POSITION pos = lst.Find(ptr);
	if (pos != (POSITION)NULL)
	{
		// remove
		lst.RemoveAt(pos);

		return TRUE;	// ok
	}

	return FALSE; // didn't find it
}

// platform management
void CProjComponentMgr::RegisterPlatform(CPlatform * pPlatform)
{
	ASSERT_VALID(pPlatform);
	if (!pPlatform->FInit())
		return;

	m_mapPlatforms.SetAt(*(pPlatform->GetName()), (void *)pPlatform);

	if (pPlatform->IsPrimaryPlatform())
	{
		m_lstPlatforms.AddHead(pPlatform);
		m_fRegPrimaryPlatform = TRUE;
	}
	else
	{
		m_lstPlatforms.AddTail(pPlatform);
	}
}

BOOL CProjComponentMgr::DeregisterPlatform(CPlatform * pPlatform)
{
	m_mapPlatforms.RemoveKey(*(pPlatform->GetName()));

	return DeregisterComponent(m_lstPlatforms, pPlatform);
}

BOOL CProjComponentMgr::LookupPlatformByOfficialName(const TCHAR * szOfficialName, CPlatform * & pPlatform)
{
	return m_mapPlatforms.Lookup(szOfficialName, (void * &)pPlatform);
}

BOOL CProjComponentMgr::LookupPlatformByUIDescription(const TCHAR * szUIDescription, CPlatform * & pPlatform)
{
	CPlatform *	pPlatformEnum;

	InitPlatformEnum();

	while (NextPlatform(pPlatformEnum))
	{
		if (_tcscmp((const TCHAR *)*(pPlatformEnum->GetUIDescription()), szUIDescription) == 0)
		{
			pPlatform = pPlatformEnum;
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CProjComponentMgr::LookupPlatformByUniqueId(UINT nUniqueId, CPlatform * & pPlatform)
{
	pPlatform = (CPlatform *)NULL;	// not found yet

	if (nUniqueId)	// don't match 'unknown' platforms
	{
		CPlatform *	pPlatformEnum;
		InitPlatformEnum();

		while (NextPlatform(pPlatformEnum))
		{
			// have we found a platform with our unique id?
			if (pPlatformEnum->GetUniqueId() == nUniqueId &&
				// do we have one yet, or can this override one 'not-named'
				// (created by unknown exe targets)
				(!pPlatform || (pPlatform->GetName()->CompareNoCase("<Unknown>") == 0))
			)
			{
				pPlatform = pPlatformEnum;
			}
		}
	}

	return pPlatform != (CPlatform *)NULL;
}

// [jimsc 7-16-96] Added the bAllowNonPrimary flag, which defaults to TRUE, to signal
// that if no platform explicitly marked "primary" is found, the first supported
// platform will be returned.  If FALSE, and no primary platforms are found, this
// will return NULL.

CPlatform * CProjComponentMgr::GetPrimaryPlatform(BOOL bAllowNonPrimary /* = TRUE */)
{
	CPlatform *	pPlatform;
	CPlatform *	pFirstSupported = NULL;

	InitPlatformEnum();

	while (NextPlatform(pPlatform))
	{
		if ((pFirstSupported == NULL) && (pPlatform->IsSupported()))
			pFirstSupported = pPlatform;
			
		if (pPlatform->IsPrimaryPlatform())
			return pPlatform;
	}

	// No primary guys were found, so return the first supported platform unless told not to
	return bAllowNonPrimary ? pFirstSupported : NULL;
}


UINT CProjComponentMgr::GetIdFromMachineImage(WORD wMachineImage)
{
	// This is a mapping function that maps from a NT image file
	// signature to our internal unique platform id's
	
	switch (wMachineImage)
	{
		case IMAGE_FILE_MACHINE_I386:
			return win32x86;

		case IMAGE_FILE_MACHINE_M68K:
			return mac68k;

		case IMAGE_FILE_MACHINE_ALPHA:
			return win32alpha;

		case IMAGE_FILE_MACHINE_MPPC_601:
			return macppc;
			
		case IMAGE_FILE_MACHINE_UNKNOWN:
		default:
			break;
	}

	// In case we didn't recognise the platform.
	return unknown_platform;
}

// project type management
void CProjComponentMgr::RegisterProjType(CProjType * pprojtype)
{
	ASSERT_VALID(pprojtype);

	if (!pprojtype->FInit())
		return;

	m_mapProjTypes.SetAt(*(pprojtype->GetName()), pprojtype);
	m_lstProjTypes.AddTail(pprojtype);
}

BOOL CProjComponentMgr::DeregisterProjType(CProjType * pprojtype)
{
	m_mapProjTypes.RemoveKey(*(pprojtype->GetName()));

	return DeregisterComponent(m_lstProjTypes, pprojtype);
}

BOOL CProjComponentMgr::GetProjTypefromProjItem(CProjItem * pProjItem, CProjType * & pProjType)
{
	CString strProjName;

	if (pProjItem->GetStrProp(P_ProjOriginalType, strProjName) != valid)
		return FALSE;	// can't find project type

	if (!LookupProjTypeByName(strProjName, pProjType))
		return FALSE;	// unrecognised project type

	return TRUE;	// ok
}

//
// build tool management
//
void CProjComponentMgr::RegisterBuildTool(CBuildTool * ptool)
{
	ASSERT_VALID(ptool);

	// initialise
	(void) ptool->FInit();

	// Put all the source tools at the head of the tool registry
	// Put all the schmooze tools at the tail of the tool registry
	if (ptool->IsKindOf(RUNTIME_CLASS(CSchmoozeTool)))
	{
		m_lstTools.AddTail(ptool);

		((CSchmoozeTool *) ptool)->SetMenuID
				(
					min(IDM_PROJECT_TOOL_CMD_LAST, (IDM_PROJECT_TOOL_CMD_FIRST + m_cSchmoozeTools))
				);
		m_cSchmoozeTools++;
	}
	else if (ptool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
	{
		// FUTURE: find a better way to handle this
		m_lstTools.AddTail(ptool);
	}
	else
		m_lstTools.AddHead(ptool);
}

//
// build tool management
//
void CProjComponentMgr::RegisterOleTool(IBuildTool * ptool, DWORD bsc_id )
{
	// Put all the source tools at the head of the tool registry
	// Put all the schmooze tools at the tail of the tool registry
	if ( ptool->IsCollectorTool() == S_OK )
	{

		// add the non schmooze tool to the front of the list.
		COLEBuildTool *pProxy = new COLEBuildTool( (LPUNKNOWN)ptool, 0 );
		m_lstTools.AddTail(pProxy);
		m_cSchmoozeTools++;
/*
		m_lstTools.AddTail(ptool);

		((CSchmoozeTool *) ptool)->SetMenuID
				(
					min(IDM_PROJECT_TOOL_CMD_LAST, (IDM_PROJECT_TOOL_CMD_FIRST + m_cSchmoozeTools))
				);
 */
	}
	else 
	{
		// add the non schmooze tool to the front of the list.
		COLEBuildTool *pProxy = new COLEBuildTool( (LPUNKNOWN)ptool, 0 );
		
		RegisterBldSysComp( pProxy, bsc_id );
	}
}

//
// build tool management
//
void CProjComponentMgr::RegisterOleAddOn( LPBUILDSYSTEMADDON pAddOn, DWORD bsc_id )
{
	m_AddOns.AddTail( pAddOn );

	LPBUILDSYSTEM pInterface;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_IBuildSystem, (LPVOID FAR*)&pInterface)));
	pAddOn->SetClient(pInterface);
}

//
// build tool management
//
void CProjComponentMgr::RegisterOleProjType(IProjectType * pProj, DWORD bsc_id )
{
	CString name;
	UINT type;
	pProj->GetName(&name);
	pProj->GetType(&type);
	// add the non schmooze tool to the front of the list.
	COLEProjType *pProxy = new COLEProjType( pProj, name, type );
	RegisterBldSysComp( pProxy, bsc_id );

}

//
// build tool management
//
void CProjComponentMgr::RegisterOlePlatform(IPlatform * pPlat, DWORD bsc_id )
{
	// add the non schmooze tool to the front of the list.
	COLEPlatform *pProxy = new COLEPlatform( pPlat);

	RegisterBldSysComp( pProxy, bsc_id );
}

/*
R.I.P. for v4.0 with VBA?
BOOL CProjComponentMgr::RegisterCustomTool(CCustomTool * ptool)
{
 	// generate a new custom tool id.
	// leave our related id. as zero (default)
	ptool->SetId(GenerateComponentId(idAddOnGeneric, m_dwCustomBase++));

	// initialise
	(void) ptool->FInit();

	// add to our list
	m_lstCustTools.AddTail(ptool);

	return TRUE;
}

#define CCH_ALLOC_BLOCK		256
BOOL CProjComponentMgr::SerializeProjectCustomTool(CBldrSection * pbldsect, UINT op)
{
	// read or write?
	switch (op)
	{
		case SECT_READ:
			// FUTURE:
			break;

		case SECT_WRITE:
		{
			TCHAR * pch;
			UINT cchAlloc = CCH_ALLOC_BLOCK;
			pch = (TCHAR *)calloc(cchAlloc + 1, sizeof(TCHAR));	// alloc. one for zero-term.
			if (pch == (TCHAR *)NULL)
				return FALSE;

			pbldsect->m_pch = pch;
			pbldsect->m_cch = 0;

			CCustomTool * pTool;
			g_prjcompmgr.InitCustomToolEnum();
			while (g_prjcompmgr.NextCustomTool(pTool))
			{
				// only write out project custom tools...
				//if (!pTool->m_bToolPerProject)
				//	continue;

			TryAgain:

				UINT cch = cchAlloc - pbldsect->m_cch;
				if (pTool->Serialize(pbldsect->m_pch + pbldsect->m_cch, cch))
				{
					// advance by actual bytes. copied
					pbldsect->m_cch += cch;
				}
				else
				{
					// re-alloc
					cchAlloc += CCH_ALLOC_BLOCK;
					pch = (TCHAR *)realloc(pbldsect->m_pch, sizeof(TCHAR) * (cchAlloc + 1));		// alloc. one for zero-term.
					if (pch == (TCHAR *)NULL)
					{
						free(pbldsect->m_pch);
						return FALSE;
					}

 					pbldsect->m_pch = pch;

					goto TryAgain;
				}
			}

			// zero-terminate
			*(pbldsect->m_pch + pbldsect->m_cch) = _T('\0');
			break;
		}

		case SECT_END:
		{
			// free our memory
			free(pbldsect->m_pch);
			break;
		}
	}

	return TRUE;	// ok
}

BOOL CProjComponentMgr::RetrieveGlobalCustomTool()
{
	// our custom tool list
	CString strKey = ::GetRegistryKeyName();
	strKey += _TEXT("\\");
	strKey += szRegKey;
	strKey += szTools;

	// make sure this key exists
	HKEY hKey;
	if (RegGetKey(HKEY_CURRENT_USER, (const TCHAR *)strKey, &hKey) != ERROR_SUCCESS)
		return TRUE;	// no tools, no parent key!

	DWORD dwType = 0;		// type must be REG_MULTI_SZ
	TCHAR * pszValue;
	DWORD cbData;
	// get the size of buffer we need
	if (RegQueryValueEx(hKey, (LPTSTR)szCustomList, NULL, &dwType,
				  		(LPBYTE)NULL, &cbData) != ERROR_SUCCESS)
		return TRUE;	// no tools, no key value

	if (dwType != REG_MULTI_SZ && dwType != REG_BINARY)
		return FALSE;	// no tools, wrong key value type -> error

	// get the data
	TCHAR * pch = new TCHAR[cbData];
	pszValue = pch;

	BOOL fRetVal = TRUE;

 	if (RegQueryValueEx(hKey, (LPTSTR)szCustomList, NULL, &dwType,
				  		(LPBYTE)pszValue, &cbData) == ERROR_SUCCESS)
	{
		// end of string block>
		while (*pszValue != _T('\0'))
		{
			// for each tool name in the tool list
			// register a build tool with the name and synchronize
			if (!RegisterBldSysComp(new CCustomTool(pszValue)))
			{
				fRetVal = FALSE;	// cannot create custom tools -> error
				break;
			}

			// move to the next name
			pszValue += _tcslen(pszValue);
			pszValue++;	// skip zero-terminator
		}
	}
	else
	{
		fRetVal = FALSE;
	}

	delete [] pch;

	return fRetVal;	// success
}

BOOL CProjComponentMgr::StoreGlobalCustomTool()
{
	// our custom tool list
	CString strKey = ::GetRegistryKeyName();
	strKey += _TEXT("\\");
	strKey += szRegKey;
	strKey += szTools;

	// make sure this key exists
	HKEY hKey;
	if (RegGetKey(HKEY_CURRENT_USER, (const TCHAR *)strKey, &hKey) != ERROR_SUCCESS)
		return TRUE;	// no tools, no parent key!

	// enumerate our list of custom tools
	// and write each out to the registry
	CStringList strlstValue;	// our 'Custom' value string list
	DWORD cbData = 1;			// size of our value string list (if empty we end with single '\0')

	CCustomTool * pTool;
	InitCustomToolEnum();
	while (NextCustomTool(pTool))
	{
		// don't write out per-project custom tools...
		if (pTool->m_bToolPerProject)
			continue;

		pTool->m_fRegRestore = FALSE;	// don't restore, just save
		if (pTool->SynchronizeWithRegistry())
		{
			// remember this tool
			const CString * pstrName = pTool->GetName();
			strlstValue.AddTail(*pstrName);
			cbData += pstrName->GetLength() + 1;	// incl. nul term.
		}
	}

	// allocate our registry 'Custom' value REG_MULTI_SZ
	TCHAR * pszValue = new TCHAR[cbData];
	TCHAR * psz = pszValue;

	POSITION pos = strlstValue.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		// copy into this buffer our name
		_tcscpy(psz, (const TCHAR *)strlstValue.GetNext(pos));
		psz += _tcslen(psz);

		// append with a '\0'
		*psz++ = _T('\0');
	}

	// finish with a '\0'

	*psz = _T('\0');

	// write out this registry key
	(void) RegSetValueEx(hKey, (LPTSTR)szCustomList, NULL, REG_MULTI_SZ,
						 (LPBYTE)pszValue, cbData);

	// free up our memory
	delete [] pszValue;

	return TRUE;
}
*/

// Find the tool whose prefix matches the pPrefix. nPrefixLen is the maximum
// number of characters to match up to.  pprojitem can be used to retrieve
// only the tools for the current configuration.
CBuildTool * CProjComponentMgr::GetToolFromCodePrefix(CProjItem * pItem, const TCHAR * pPrefix, int nPrefixLen)
{
	// Project type tool?
	if (pItem != (CProjItem *)NULL)
	{
		CProjType * pprojtype;
		if (!GetProjTypefromProjItem(pItem, pprojtype))
			return FALSE;

		return pprojtype->GetToolFromCodePrefix(pPrefix, nPrefixLen);
	}
	// In master-list or custom-tool list?
	else
	{
		CBuildTool * pTool;
/*
R.I.P. for v4.0 with VBA?
		CCustomTool * pCustTool;

		InitCustomToolEnum();
		while (NextCustomTool(pCustTool))
		{
			const TCHAR * pc = pCustTool->m_strToolPrefix;
			int len = _tcslen(pc);
			if (len && !_tcsnicmp(pPrefix, pc, min(nPrefixLen, len)))
				return pCustTool;
		}
*/

		InitBuildToolEnum();
		while (NextBuildTool(pTool))
		{
			const TCHAR * pc = pTool->m_strToolPrefix;
			int len = _tcslen(pc);
			if (len && !_tcsnicmp(pPrefix, pc, min(nPrefixLen, len)))
				return pTool;
		}
	}

	return (CBuildTool *)NULL;
}

// tool option management
void CProjComponentMgr::RegisterBuilderConverter(CBuilderConverter * pbldrcnvtr)
{
	m_lstBldrCnvtrs.AddTail(pbldrcnvtr);
}

BOOL CProjComponentMgr::DeregisterBuilderConverter(CBuilderConverter * pbldrcnvtr)
{
	return DeregisterComponent(m_lstBldrCnvtrs, pbldrcnvtr);
}

// tool option management
void CProjComponentMgr::RegisterOptionHandler(COptionHandler * popthdlr)
{
	popthdlr->SetOptPropBase(m_idOptPropBase);
	m_idOptPropBase += popthdlr->GetOptPropRange();

	// make sure we don't fall out of our range
	ASSERT(m_idOptPropBase < PROJ_BUILD_OPTION_PRIVATE_FIRST);
	m_lstOptionHandlers.AddTail(popthdlr);

	// initialise this option handler
	popthdlr->Initialise();
}

BOOL CProjComponentMgr::DeregisterOptionHandler(COptionHandler * popthdlr)
{
	return DeregisterComponent(m_lstOptionHandlers, popthdlr);
}

BOOL CProjComponentMgr::SetDefaultToolOptions(DWORD mode, CProject * pProject)
{
	// retrieve the string rep. of this proj. mode
	ASSERT(mode == MOB_Debug || mode == MOB_Release);
	CString strMode;
	VERIFY(strMode.LoadString(mode == MOB_Debug ? IDS_DEBUG_CONFIG : IDS_RELEASE_CONFIG));

	// retrieve the CProjType for the original project type for this project
	CProjType * pProjType;
	if (!GetProjTypefromProjItem((CProjItem *)pProject, pProjType))
		return FALSE;	// can't get the project type for this project item

	// preserve the option handler and current slob for 'option engine'
	COptionHandler * popthdlrOld = g_prjoptengine.GetOptionHandler();

	// enumerate through all of our known tools and then ask the project type
	// to provide the default option string
	// we'll then use the tools' option table to parse this string into
	// tool option properties
	CBuildTool * pBuildTool;
	POSITION pos;
	const CPtrList *pList = pProjType->GetToolsList ();

	for (pos = pList->GetHeadPosition (); pos != NULL;)	
	{
		pBuildTool = (CBuildTool *) pList->GetNext(pos);

		// ignore unknown tools
		if (!pBuildTool->IsSupported())
			continue;

		// ignore some tools, such as the pass through tool
		UINT bsc_id = pBuildTool->CompId();

		CString strOption; // don't move this line
		ASSERT(strOption.IsEmpty());

		// can the tool handle this?
		if (!pBuildTool->GetDefaultToolOptions(pProjType->CompId(), pProjType->GetAttributes(), mode, strOption))
			// no, so default to the target type - must be able to
			VERIFY(pProjType->GetDefaultToolOptions(bsc_id, strMode, strOption));

		// parse the default options into the property bag
		g_prjoptengine.SetOptionHandler(pBuildTool->GetOptionHandler());
		g_prjoptengine.SetPropertyBag(pProject);

		// clear before parse, behave as if we were reading from file ie.
		// we need "" to allow the setting of empty string props.
		VERIFY(g_prjoptengine.ParseString(strOption, OBClear | OBNeedEmptyString));
	}

	// reset current option handler
	g_prjoptengine.SetOptionHandler(popthdlrOld);

	return TRUE;	// success	
}

BOOL CProjComponentMgr::LookupProjTypeByUniqueId(UINT nUniqueId, CProjType * & pProjType)
{
	InitProjTypeEnum();
	while (NextProjType(pProjType))
	{
		if (nUniqueId==pProjType->GetUniqueId()) 
			return TRUE;
	}

	return FALSE;
}

BOOL CProjComponentMgr::LookupProjTypeByUIDescription(const TCHAR * pszUIDesc, CProjType * & pprojtype)
{
	// FUTURE: implement fast version of this?
	InitProjTypeEnum();
	while (NextProjType(pprojtype))	
	{
		if (!_tcscmp(pszUIDesc,LPCTSTR(*(pprojtype->GetUIDescription()))))
			return TRUE;
	}

	return FALSE;
}

CObList * CProjComponentMgr::GetMatchingProjTypes(const _TCHAR * pszPlatform, const _TCHAR * pszType, BOOL bUIDescription /* = FALSE */)
{
	CProjType * pprojtype;
	m_tmplstProjTypes.RemoveAll();

	if ((pszPlatform) && (pszType))	 // looking for specific match
	{
		if (bUIDescription)
		{
			if (!LookupProjTypeByName(pprojtype->MakeNameFromPlatformAndType(pszPlatform, pszType), pprojtype))
				return NULL;
		}
		else
		{
			if (!LookupProjTypeByUIDescription(pprojtype->MakeNameFromPlatformAndType(pszPlatform, pszType), pprojtype))
				return NULL;
		}
		if (!pprojtype->IsSupported())
			return NULL;
		m_tmplstProjTypes.AddTail(pprojtype);
	}
	else
	{
		LPCTSTR pszPlatformKey;
		LPCTSTR pszTypeKey;
		InitProjTypeEnum();
		while (NextProjType(pprojtype))
		{
			if (bUIDescription)
			{
				pszPlatformKey = LPCTSTR(*(pprojtype->GetPlatformUIDescription()));
				pszTypeKey     = LPCTSTR(*(pprojtype->GetTypeUIDescription()));
			}
			else
			{
				pszPlatformKey = LPCTSTR(*(pprojtype->GetPlatformName()));
				pszTypeKey     = LPCTSTR(*(pprojtype->GetTypeName()));
			}

			if (((!pszPlatform) || (!_tcscmp(pszPlatform, pszPlatformKey)))
				&&
				((!pszType) || (!_tcscmp(pszType, pszTypeKey))))
			{
				if (pprojtype->IsSupported())
					m_tmplstProjTypes.AddTail(pprojtype);
			}
		
		}
	}	

	return &m_tmplstProjTypes;
}

const CStringList * CProjComponentMgr::GetListOfProjTypes(const _TCHAR * pszPlatform /* = NULL */ , const _TCHAR * pszType /* = NULL */, BOOL bUIDescription /* = FALSE */)
{
	CProjType * pprojtype;
	CStringList * pList = (bUIDescription) ? &m_tmpUIDescList : &m_tmpNameList;
	pList->RemoveAll();

	if ((pszPlatform) && (pszType))	 // looking for specific match
	{
		if (bUIDescription)
		{
			if ((!LookupProjTypeByUIDescription(pprojtype->MakeNameFromPlatformAndType(pszPlatform, pszType), pprojtype))
				|| (!pprojtype->IsSupported()))
				return NULL;
			pList->AddTail(*(pprojtype->GetUIDescription()));
		}
		else
		{
			if ((!LookupProjTypeByName(pprojtype->MakeNameFromPlatformAndType(pszPlatform, pszType), pprojtype))
				|| (!pprojtype->IsSupported()))
				return NULL;
			pList->AddTail(*(pprojtype->GetName()));
		}
	}
	else
	{
		LPCTSTR pszPlatformKey;
		LPCTSTR pszTypeKey;
		InitProjTypeEnum();
		while (NextProjType(pprojtype))
		{	
		   	if (bUIDescription)
			{
				pszPlatformKey = LPCTSTR(*(pprojtype->GetPlatformUIDescription()));
				pszTypeKey     = LPCTSTR(*(pprojtype->GetTypeUIDescription()));
			}
			else
			{
				pszPlatformKey = LPCTSTR(*(pprojtype->GetPlatformName()));
				pszTypeKey     = LPCTSTR(*(pprojtype->GetTypeName()));
			}
			if (((!pszPlatform) || (!_tcscmp(pszPlatform, pszPlatformKey)))
				&&
				((!pszType) || (!_tcscmp(pszType, pszTypeKey))))
			{
				if (pprojtype->IsSupported())
					pList->AddTail((bUIDescription) ? *(pprojtype->GetUIDescription()) : *(pprojtype->GetName()));
			}
		}
	}	
	return pList;
}

extern BOOL g_bEnableAllPlatforms;

const CStringList * CProjComponentMgr::GetListOfPlatforms(const _TCHAR * pszType /* = NULL */, BOOL bUIDescription /* = FALSE */ )
{
	CProjType * pprojtype;
	CMapStringToPtr UniqueMap;
	const CString * pstrName;
	void * pTmp;
	LPCTSTR pszPlatformKey;
	LPCTSTR pszTypeKey;
	CStringList * pList = (bUIDescription) ? &m_tmpUIDescList : &m_tmpNameList;
	pList->RemoveAll();

	InitProjTypeEnum();
	while (NextProjType(pprojtype))
	{
		if (pprojtype->IsSupported() )
 		{
			if( pprojtype->GetPlatform()->GetBuildable() || g_bEnableAllPlatforms ){
				if (bUIDescription)
					pszTypeKey = LPCTSTR(*(pprojtype->GetTypeUIDescription()));
				else
					pszTypeKey = LPCTSTR(*(pprojtype->GetTypeName()));
		
				if ((!pszType) || (!_tcscmp(pszType, pszTypeKey)))
				{
					if (bUIDescription)
						pstrName = pprojtype->GetPlatformUIDescription();
					else
						pstrName = pprojtype->GetPlatformName();

					pszPlatformKey = LPCTSTR(*pstrName);
					if (!UniqueMap.Lookup(pszPlatformKey, pTmp)) // make sure platform not already in list	
					{
						// add platform name to uniqueness map and output list
						UniqueMap.SetAt(pszPlatformKey, this); /* value doesn't matter */
						pList->AddTail(*pstrName);
					}
				}
			}
		}
	}
	return pList;
}

const CStringList * CProjComponentMgr::GetListOfTypes(const _TCHAR * pszPlatform /* = NULL */, BOOL bUIDescription /* = FALSE */ )
{
	CProjType * pprojtype;
	CMapStringToPtr UniqueMap;
	const CString * pstrName;
	void * pTmp;
	LPCTSTR pszPlatformKey;
	LPCTSTR pszTypeKey;
	CStringList * pList = (bUIDescription) ? &m_tmpUIDescList : &m_tmpNameList;
	pList->RemoveAll();

	InitProjTypeEnum();
	while (NextProjType(pprojtype))
	{
		if (pprojtype->IsSupported())
 		{
			if (bUIDescription)
				pszPlatformKey = LPCTSTR(*(pprojtype->GetPlatformUIDescription()));
			else
				pszPlatformKey = LPCTSTR(*(pprojtype->GetPlatformName()));

			if ((!pszPlatform) || (!_tcscmp(pszPlatform, pszPlatformKey)))
			{
				if (bUIDescription)
					pstrName = pprojtype->GetTypeUIDescription();
				else
					pstrName = pprojtype->GetTypeName();

				pszTypeKey = LPCTSTR(*pstrName);
				if (!UniqueMap.Lookup(pszTypeKey, pTmp)) // make sure type not already in list	
				{
					// add type name to uniqueness map and output list
					UniqueMap.SetAt(pszTypeKey, this); /* value doesn't mater */
					pList->AddTail(*pstrName);
				}
			}
		}
	}
	return pList;
}

COptionHandler * CProjComponentMgr::FindOptionHandler(UINT idProp)
{
	// quick check to see if could be a tool option!
	if (idProp < PROJ_BUILD_OPTION_FIRST || idProp > PROJ_BUILD_OPTION_LAST)
		return (COptionHandler *)NULL;

	// try our cache first
	if (m_nPropFirst <= idProp && idProp <= m_nPropLast)
		return m_popthdlrCache;

	// look through our list of option handlers
	COptionHandler * popthdlr;	
	UINT nPropLast;

	InitOptHdlrEnum();
	while (NextOptHdlr(popthdlr))
	{
		// N.B. we know that these options are in an ordered list
		// such that they are in prop. id. block' order
		if (idProp <= (nPropLast = popthdlr->LastOptProp()))
		{
			// cache this
			m_nPropFirst = popthdlr->FirstOptProp();
			m_nPropLast = nPropLast;
			m_popthdlrCache = popthdlr;

			return popthdlr;
		}
	}

	return (COptionHandler *)NULL;	// no option handler found, not a tool option
}

#define theClass CPlatform
BEGIN_REGISTRY_MAP(CPlatform, CBldSysCmp)	
	// Symbol Handlers
	REGISTRY_DATA_ENTRY(IDS_REG_PLATCURRENTSH, IDS_REG_PLATSH,"Current SH","Symbol Handlers", REG_STRING, m_strSHName)

	// Expression Evaluators
	REGISTRY_DATA_ENTRY(IDS_REG_PLATCURRENTEE, IDS_REG_PLATEE,"Current EE","Expression Evaluators", REG_STRING, m_strEEName)

	// Execution Models
	REGISTRY_DATA_ENTRY(IDS_REG_PLATCURRENTEM, IDS_REG_PLATEM,"Current EM", "Execution Models", REG_STRING, m_strEMName)

	// Non-native Execution Models
	REGISTRY_FAKE_DATA_ENTRY(IDS_REG_PLATATTRIBNM, IDS_REG_PLATNM,"NM Attributes","Execution Models (non-native)", REG_DWORD)

	// Transports
	REGISTRY_FAKE_DATA_ENTRY(IDS_REG_PLATATTRIBTL, IDS_REG_PLATTL, "TL Attributes", "Transports", REG_DWORD)
	REGISTRY_FAKE_DATA_ENTRY(IDS_REG_PLATDESCTL, IDS_REG_PLATTL, "TL Description", "Transports", REG_STRING)

	REGISTRY_FAKE_DATA_ENTRY(IDS_REG_PLATCURRENTTL, IDS_REG_PLATTL, "Current TL", "Transports", REG_STRING)
END_REGISTRY_MAP()
#undef theClass

CPlatform::CPlatform(PlatformInfo * pInit)
{
	UINT	i;
	
	m_bSupported = TRUE;
	m_bBuildable = TRUE;

	m_nIDUIDesc = pInit->nIDUIDesc;
	m_nUniqueId = pInit->nUniqueId;
	m_nIDUIShortDesc = pInit->nIDUIShortDesc;
	m_nCountTLs = pInit->nCountTLs;
	m_nCountNMs = pInit->nCountNMs;

	m_rgIDTLDescs = new UINT[m_nCountTLs];
	m_rgTLFlags = new UINT[m_nCountTLs];

	// our component name
	m_strCompName = pInit->szName;

	// m_strUIDesc will be set up in FInit() method
	// m_strUIShortDesc will be set up in FInit() method if defined

	m_strEMName = pInit->szEMName;
	m_strSHName = pInit->szSHName;
	m_strEEName = pInit->szEEName;

	m_rgStrTLNames = new CString[m_nCountTLs];
	m_rgStrTLDescs = new CString[m_nCountTLs];

	for (i=0 ; i<m_nCountTLs ; ++i)
	{
		m_rgIDTLDescs[i] = pInit->rgTLInfo[i].nIDDesc;
		m_rgTLFlags[i] = pInit->rgTLInfo[i].nFlags;
		m_rgStrTLNames[i] = pInit->rgTLInfo[i].szName;
		VERIFY(m_rgStrTLDescs[i].LoadString(m_rgIDTLDescs[i]));
	}

	// default is the local TL
	if ((m_nCurrentTL = GetLocalTLIndex()) == -1)	m_nCurrentTL = 0;
	
	if (m_nCountNMs == 0)
	{
		m_rgStrNMNames = NULL;
		m_rgNMFlags = NULL;
	}
	else
	{
		m_rgStrNMNames = new CString[m_nCountNMs];
		m_rgNMFlags = new UINT[m_nCountNMs];
	
		for (i = 0; i < m_nCountNMs; i += 1)
		{
			m_rgStrNMNames[i] = pInit->rgNMInfo[i].szName;
			m_rgNMFlags[i] = pInit->rgNMInfo[i].nFlags;
		}
	}

	// initializing ToolInfo
	m_rgToolInfo.strRCExtension = pInit->szRCExtension;
	if (pInit->szPath)
		m_rgToolInfo.strPath = pInit->szPath;
	else
		m_rgToolInfo.strPath.Empty() ;
	if (pInit->szIncludePath)
		m_rgToolInfo.strIncludePath = pInit->szIncludePath;
	else
		m_rgToolInfo.strIncludePath.Empty() ;
	if (pInit->szLibPath)
		m_rgToolInfo.strLibPath = pInit->szLibPath;
	else
		m_rgToolInfo.strLibPath.Empty() ;
	if (pInit->szSourcePath)
		m_rgToolInfo.strSourcePath = pInit->szSourcePath;
	else
		m_rgToolInfo.strIncludePath.Empty() ;

	// our attributes
	m_dwAttributes = pInit->dwPlatformAttrib;

	// use MFC default
	m_nUseMFCDefault = pInit->nUseMFCDefault;

	ASSERT(m_nIDUIDesc);
	ASSERT(m_nUniqueId < 256);
	
	// load our platform description strings
	if (m_nIDUIDesc)
		VERIFY (m_strUICompName.LoadString(m_nIDUIDesc));

	if (m_nIDUIShortDesc)
		VERIFY (m_strUIShortDesc.LoadString(m_nIDUIShortDesc));
	else
		m_strUIShortDesc = m_strCompName.Left(5); // default

	// set up our default output directory
	if (pInit->szOutDirPrefix == (TCHAR *)NULL)
		m_strDefOutDirPrefix = m_strUICompName.Left(3);	// use TLA for default
	else
		m_strDefOutDirPrefix = pInit->szOutDirPrefix;
}

// Special constructor used for generating 'unknown' platforms dynamically
CPlatform::CPlatform(const _TCHAR * lpszName, UINT nUniqueId /* = unknown_platform */)
{
	// our component name
 	m_strCompName = lpszName;

	m_strUIShortDesc = m_strCompName.Left(5); // default
	// all other strings are "" for generic platforms

	m_nUniqueId = nUniqueId;
	// all other values are set to defaults (disabled)
	m_bSupported = FALSE;
	m_nIDUIDesc = 0;
	m_nIDUIShortDesc = 0;
	m_nCountTLs = 0;
	m_nCurrentTL = 0;
	m_rgIDTLDescs = NULL;
	m_rgTLFlags = NULL;
	m_rgStrTLNames = NULL;
	m_rgStrTLDescs = NULL;
	m_dwAttributes = 0;	
	m_nCountNMs = 0;
	m_rgStrNMNames = NULL;
	m_rgNMFlags = NULL;

 	// initializing ToolInfo
	m_rgToolInfo.strRCExtension.Empty() ;
	m_rgToolInfo.strPath.Empty() ;
	m_rgToolInfo.strIncludePath.Empty() ;
	m_rgToolInfo.strLibPath.Empty() ;
	m_rgToolInfo.strSourcePath.Empty() ;

	ASSERT(m_nUniqueId < 256);

	g_prjcompmgr.RegisterPlatform(this);
}

// Perform platform 'special' registry loading/saving
BOOL CPlatform::RegDataExists
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPDWORD pdwType, LPDWORD pcbData
)
{
	switch (pregmap->nRegId)
	{
		// Transport Layer values
		case IDS_REG_PLATDESCTL:
		case IDS_REG_PLATATTRIBTL:

		// Non-native Execution Models values
		case IDS_REG_PLATATTRIBNM:
		{
			UINT cDbgComp;
			FILETIME ft;
			DWORD dw;
			TCHAR rgchClass[1];	// we know the class to be "" ie. of length 1 byte
			DWORD cchClass = sizeof(rgchClass);
			// assume we need to fill in with defaults if this fails
			if (RegQueryInfoKey(hKey,
								rgchClass, &cchClass, NULL,
								(LPDWORD)&cDbgComp,
								&dw, &dw, &dw, &dw, &dw, &dw, // dummy values
								&ft) != ERROR_SUCCESS) cDbgComp = 0;

			// HACK: force the use of the const object's cbData for our data size ;-)
			((CRegistryMap *)pregmap)->cbData = cDbgComp;
			
			// HACK: toggle load/save
			BOOL fSave = !!((CRegistryMap *)pregmap)->pvData;
			((CRegistryMap *)pregmap)->pvData = (void *)!fSave;	// next time we load

			return fSave;
		}

		default:
			break;
	}

	// do the base-class thing
	return CBldSysCmp::RegDataExists(pregmap, hKey, pstrValue, pdwType, pcbData);
}

BOOL CPlatform::LoadRegData
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPBYTE lpbData, DWORD cbData
)
{
	BOOL fRet = TRUE;

	CString strFakedValue;
	DWORD dwFakedValue;
	switch (pregmap->nRegId)
	{
		case IDS_REG_PLATCURRENTTL:
			lpbData = (LPBYTE)&strFakedValue;
			break;

		// Non-native Execution Models values
		case IDS_REG_PLATATTRIBNM:
		{
			// we should have a NM count in data size(RegDataExists() did this for us!)
			UINT cNM = pregmap->cbData;

			// do the re-alloc.?
			if (cNM != m_nCountNMs)
			{
				delete [] m_rgStrNMNames;
			  	delete [] m_rgNMFlags;

				m_nCountNMs = cNM;
				m_rgStrNMNames = new CString[m_nCountNMs];
				m_rgNMFlags = new UINT[m_nCountNMs];
			}

			if (cNM == 0)
				return TRUE;	// nothing to load

			lpbData = (LPBYTE)&dwFakedValue;

			FILETIME ft;
			cNM = 0;	// count from zero->m_nCountNMs-1
			while (cNM < m_nCountNMs)
			{
				TCHAR rgchNMName[MAX_PATH+1];
				DWORD cch = sizeof(rgchNMName);
				if (RegEnumKeyEx(hKey,
								 (DWORD)cNM,
								 (LPTSTR)rgchNMName,
								 (LPDWORD)&cch,
								 NULL, NULL, NULL,
								 &ft) == ERROR_SUCCESS)
				{
					// make sure we have the name of this NM
					m_rgStrNMNames[cNM] = rgchNMName;

					// load into our internal representation the NM data
					HKEY hNMKey = (HKEY)NULL;
					BOOL fValueOk = FALSE;

					// open our subkey for the NM name
					if (RegGetKey(hKey, (LPCTSTR)rgchNMName, &hNMKey, FALSE) == ERROR_SUCCESS)
					{
						// load value
						DWORD dwType;
						if (CBldSysCmp::RegDataExists(pregmap, hNMKey, pstrValue, &dwType, &cbData))
							fValueOk = CBldSysCmp::LoadRegData(pregmap, hNMKey, pstrValue, lpbData, cbData);
					}

					m_rgNMFlags[cNM] = fValueOk ? dwFakedValue : 0;

					fRet = fRet && fValueOk;

					// close out sub-key?
					if (hNMKey)
						RegCloseKey(hNMKey);
				}

				cNM++;
			}

			return fRet;	// don't do base-class thing!
		}

		// Transport Layer values
		case IDS_REG_PLATDESCTL:
		case IDS_REG_PLATATTRIBTL:
		{
			// we should have a TL count in data size(RegDataExists() did this for us!)
			UINT cTL = pregmap->cbData;

			// need to re-map current index if reading new keys
			CString strTrackTL;
			if (m_nCurrentTL != (UINT)-1)
				strTrackTL = GetTLName(m_nCurrentTL);

			// do the re-alloc.?
			if (cTL != m_nCountTLs)
			{
				delete [] m_rgStrTLNames;
				delete [] m_rgStrTLDescs;
 			  	delete [] m_rgTLFlags;

				m_nCountTLs = cTL;
				m_rgStrTLNames = new CString[m_nCountTLs];
				m_rgStrTLDescs = new CString[m_nCountTLs];
 			  	m_rgTLFlags = new UINT[m_nCountTLs];
			}

			if (cTL == 0)
				return TRUE;	// nothing to load

			if (pregmap->nRegId == IDS_REG_PLATDESCTL)
				lpbData = (LPBYTE)&strFakedValue;
			else
				lpbData = (LPBYTE)&dwFakedValue;

			FILETIME ft;
			cTL = 0;	// count from zero->m_nCountTLs-1
			while (cTL < m_nCountTLs)
			{
				TCHAR rgchTLName[MAX_PATH+1];
				DWORD cch = sizeof(rgchTLName);
				if (RegEnumKeyEx(hKey,
								 (DWORD)cTL,
								 (LPTSTR)rgchTLName,
								 (LPDWORD)&cch,
								 NULL, NULL, NULL,
								 &ft) == ERROR_SUCCESS)
				{
					// make sure we have the name of this TL
					m_rgStrTLNames[cTL] = rgchTLName;

					// do we need to track?
					// is this the current TL we wish to track?
					if (strTrackTL.CompareNoCase(rgchTLName) == 0)
						m_nCurrentTL = cTL;

					// load into our internal representation the TL data
					HKEY hTLKey = (HKEY)NULL;
					BOOL fValueOk = FALSE;

					// open our subkey for the TL name
					if (RegGetKey(hKey, (LPCTSTR)rgchTLName, &hTLKey, FALSE) == ERROR_SUCCESS)
					{
						// load value
						DWORD dwType;
						if (CBldSysCmp::RegDataExists(pregmap, hTLKey, pstrValue, &dwType, &cbData))
							fValueOk = CBldSysCmp::LoadRegData(pregmap, hTLKey, pstrValue, lpbData, cbData);
					}

					if (pregmap->nRegId == IDS_REG_PLATDESCTL)
						m_rgStrTLDescs[cTL] = fValueOk ? strFakedValue : "<Error>";
					else
						m_rgTLFlags[cTL] = fValueOk ? dwFakedValue : 0;

					fRet = fRet && fValueOk;

					// close out sub-key?
					if (hTLKey)
						RegCloseKey(hTLKey);
				}

				cTL++;
			}

			return fRet;	// don't do base-class thing!
		}

		default:
			break;
	}

	fRet = CBldSysCmp::LoadRegData(pregmap, hKey, pstrValue, lpbData, cbData);

	switch (pregmap->nRegId)
	{
		case IDS_REG_PLATCURRENTTL:
			// set the name of our current TL
			m_nCurrentTL = GetTLIndex(strFakedValue, 0);
			break;

		default:
			break;
	}
	return fRet;	// ok?
}

BOOL CPlatform::SaveRegData
(
	const CRegistryMap * pregmap,
	HKEY hKey,
	CString * pstrValue,
	LPBYTE lpbData,
	DWORD cbData
)
{
	BOOL fRet = TRUE;

	CString strFakedValue;
	DWORD dwFakedValue;

	switch (pregmap->nRegId)
	{
		case IDS_REG_PLATCURRENTTL:
			// get the name of our current TL
			strFakedValue = GetTLName(GetCurrentTLIndex());
			lpbData = (LPBYTE)&strFakedValue;
			break;

		// Non-native Execution Models values
		case IDS_REG_PLATATTRIBNM:
		{
			HKEY hNMKey;

			BOOL fRegNMExists = !!pregmap->cbData;

			// we want to enumerate through our NM's and write out the description
			UINT cNM = 0;	// count from zero->m_nCountNMs-1
			while (cNM < m_nCountNMs)
			{
				// base our subkey name on the NM name
				// only try to create this if we have no NM subkeys
				if (RegGetKey(hKey, (LPCTSTR)GetNMName(cNM), &hNMKey, !fRegNMExists) != ERROR_SUCCESS)
					goto NoNMKeyOpen;	// failed goto next one

				// create this?	so we now have one
				if (!fRegNMExists)
					((CRegistryMap *)pregmap)->cbData++;

				// get our NM value
				dwFakedValue = GetNMFlags(cNM);

				// save it out (but only if we are filling in a hole!)
				DWORD dwType;
				if (!CBldSysCmp::RegDataExists(pregmap, hNMKey, pstrValue, &dwType, &cbData))
				{
					lpbData = (LPBYTE)&dwFakedValue;
					cbData = sizeof(DWORD);

					fRet = fRet && CBldSysCmp::SaveRegData(pregmap, hNMKey, pstrValue, lpbData, cbData);
				}

				// close out sub-key
				RegCloseKey(hNMKey);

				NoNMKeyOpen:

				cNM++;
			}

			return fRet;	// don't do base-class thing!
		}

		// Transport Layer values
		case IDS_REG_PLATDESCTL:
		case IDS_REG_PLATATTRIBTL:
		{
			HKEY hTLKey;

			BOOL fRegTLExists = !!pregmap->cbData;

			// we want to enumerate through our TL's and write out the description/attributes
			UINT cTL = 0;	// count from zero->m_nCountTLs-1
			while (cTL < m_nCountTLs)
			{
				// base our subkey name on the TL name
				// only try to create this if we have no TL subkeys
				if (RegGetKey(hKey, (LPCTSTR)GetTLName(cTL), &hTLKey, !fRegTLExists) != ERROR_SUCCESS)
					goto NoTLKeyOpen;	// failed goto next one

				// create this?	so we now have one
				if (!fRegTLExists)
					((CRegistryMap *)pregmap)->cbData++;

				// get our TL value
				if (pregmap->nRegId == IDS_REG_PLATDESCTL)
					strFakedValue = GetTLDescription(cTL);
				else
					dwFakedValue = GetTLFlags(cTL);

				// save it out (but only if we are filling in a hole!)
				DWORD dwType;
				if (!CBldSysCmp::RegDataExists(pregmap, hTLKey, pstrValue, &dwType, &cbData))
				{
					if (pregmap->nRegId == IDS_REG_PLATDESCTL)
						lpbData = (LPBYTE)&strFakedValue;
					else
					{
						lpbData = (LPBYTE)&dwFakedValue;
						cbData = sizeof(DWORD);
					}

					fRet = fRet && CBldSysCmp::SaveRegData(pregmap, hTLKey, pstrValue, lpbData, cbData);
				}

				// close out sub-key
				RegCloseKey(hTLKey);

				NoTLKeyOpen:

				cTL++;
			}

			return fRet;	// don't do base-class thing!
		}

		default:
			break;
	}

	fRet = CBldSysCmp::SaveRegData(pregmap, hKey, pstrValue, lpbData, cbData);

	return fRet;	// ok?
}

const UINT CPlatform::GetTLIndex(const TCHAR * pTLName, UINT nDefault)
{
	for (UINT i=0; i<m_nCountTLs ; i++)
	{
		if (m_rgStrTLNames[i].CompareNoCase (pTLName) == 0)
			return i;
	}
	return nDefault;
}

BOOL CPlatform::SupportsODBC() const
{
	return g_prjcompmgr.ODBCIsInstalled() && ((GetAttributes() & PIA_Allow_ODBC) != 0);
}

UINT CPlatform::GetUseMFCDefault()
{
	// FUTURE: remove this and just use the GetAttributes() & PIA_AllowMFCInDLL
	return g_prjcompmgr.MFCIsInstalled() ? m_nUseMFCDefault : NoUseMFC;
}

UINT CPlatform::GetLocalTLIndex() const
{
	for (UINT i=0; i<m_nCountTLs ; i++)
	{
		if (GetTLFlags(i) & TFL_LOCAL == TFL_LOCAL)
			return i;
	}

	return (const UINT)-1;
}

void CPlatform::SetCurrentTLIndex(UINT index)
{
	// remember the index of the current TL
	m_nCurrentTL = index;

	// save this state in our registry
	VERIFY (CBldSysCmp::SaveRegData(IDS_REG_PLATCURRENTTL));
}

BOOL CPlatform::FInit()
{
	if (!m_bSupported) // nothing to do for 'unknown' platforms
		return TRUE;

	// post-ctor initialise the platform here

	return TRUE;
}

CPlatform::~CPlatform()
{
	g_prjcompmgr.DeregisterPlatform(this);

	delete [] m_rgStrTLNames;
	delete [] m_rgStrTLDescs;
	delete [] m_rgIDTLDescs;
	delete [] m_rgTLFlags;
	delete [] m_rgStrNMNames;
	delete [] m_rgNMFlags;
}

const _TCHAR * CProjType::TypeNameFromId[] = {	_T("<unknown type>"),
						_T("Application"),
						_T("Dynamic-Link Library"),
						_T("Console Application"),
						_T("Static Library"),
						_T("ASLM Shared Library"),
						_T("External Target"),
						_T("QuickWin Application"),
						_T("Standard Graphics Application"),
						_T("Java Project"),
						_T("Generic Project")
						};

CProjType::CProjType(const TCHAR * szPkg, WORD id,
				     UINT nIDType, UINT nUniqTypeId,
			  		 const TCHAR * szPkgPlatform, WORD idPlatform)
{
	this->CProjType::CProjType(szPkg, id, nIDType, nUniqTypeId,
						 GenerateComponentId(g_prjcompmgr.GenerateBldSysCompPackageId(szPkgPlatform), idPlatform));
}

CProjType::CProjType(const TCHAR * szPkg, WORD id,
					   UINT nIDType, UINT nUniqTypeId,
					   DWORD bsc_id)
{
	// set our id.
	SetId(GenerateComponentId(g_prjcompmgr.GenerateBldSysCompPackageId(szPkg), id));

	ASSERT(nUniqTypeId < 256);

	// save the our name away
	VERIFY(m_nIDType = nIDType);
	m_nUniqueTypeId = nUniqTypeId & 255;
	ASSERT(m_nUniqueTypeId < 11);	// bump array size if this fires

	if (!g_prjcompmgr.LookupBldSysComp(bsc_id, (CBldSysCmp *&)m_pPlatform))
		ASSERT(FALSE);	// failed

	// make sure we got a valid platform
	ASSERT_VALID(m_pPlatform);
	ASSERT(m_pPlatform->IsKindOf(RUNTIME_CLASS(CPlatform)));

	m_strType = TypeNameFromId[m_nUniqueTypeId];

	// our component name
	m_strCompName = MakeNameFromPlatformAndType(*(m_pPlatform->GetName()), m_strType);
	m_pIProjType = NULL;
}

BEGIN_INTERFACE_MAP(CProjTypeInterface, CCmdTarget)
	INTERFACE_PART(CProjTypeInterface, IID_IProjectType, ProjType)
END_INTERFACE_MAP()

////////////////////////////////////////////////////////////////////////////
// IUnknown methods

STDMETHODIMP_(ULONG) CProjTypeInterface::XProjType::AddRef()
{
	// Delegate to our exported AddRef.
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType)
	return (ULONG)pThis->ExternalAddRef();
}

STDMETHODIMP_(ULONG) CProjTypeInterface::XProjType::Release()
{
	// Delegate to our exported Release.
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType)
	return (ULONG)pThis->ExternalRelease();
}

STDMETHODIMP CProjTypeInterface::XProjType::QueryInterface(REFIID iid, LPVOID far * ppvObj)
{
	// Delegate to our exported QueryInterface.
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType)
	return (HRESULT)pThis->ExternalQueryInterface(&iid, ppvObj);
}


STDMETHODIMP CProjTypeInterface::XProjType::GetName( CString *pStr )
{
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType );
	const CString *strName = pThis->m_pProjectType->GetTypeName();
	*pStr = *strName;
	return NOERROR;
}

STDMETHODIMP CProjTypeInterface::XProjType::GetType( UINT *pTypeID )
{
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType );
	*pTypeID = pThis->m_pProjectType->GetUniqueId();
	return NOERROR;
}

STDMETHODIMP CProjTypeInterface::XProjType::GetPlatform( LPPLATFORM *pPlatfrom )
{
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType );
	return NOERROR;
}

STDMETHODIMP CProjTypeInterface::XProjType::IsSupported( void )
{
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType );
	
	BOOL bSupported = pThis->m_pProjectType->IsSupported();
	
	if( bSupported ){
		return S_OK;
	}
	else {
		return S_FALSE;
	}
}

STDMETHODIMP CProjTypeInterface::XProjType::PickTool( LPBUILDFILE pFile, LPBUILDTOOL *pBuildTool )
{
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType );
	// CBuildTool * pTool;
	// pTool = pThis->PickTool((LPBUILDFILE)pFile );
	// convert from pTool to LPBUILDTOOL (impossible at the momment)
	return E_NOTIMPL;
}

STDMETHODIMP CProjTypeInterface::XProjType::AddTool( LPBUILDTOOL pBuildTool )
{
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType );

	UINT idTool,idPkg,bsc_id;
	pBuildTool->GetID(&idTool);
	pBuildTool->GetPkgID(&idPkg);
	CBuildTool * pTool;
	bsc_id = GenerateComponentId( idPkg,idTool);
	if (!g_prjcompmgr.LookupBldSysComp(bsc_id, (CBldSysCmp *&)pTool))
		ASSERT(FALSE);	// failed

	// now add it
	pThis->m_pProjectType->AddTool(pTool);

	return NOERROR;
}

STDMETHODIMP CProjTypeInterface::XProjType::EnumBuildTools( LPENUMBUILDTOOLS *, LPBUILDTOOL * )
{
	METHOD_PROLOGUE_EX(CProjTypeInterface, ProjType );
	return  E_NOTIMPL;
}

void CProjType::ReleaseInterface( void ){
	if( m_pIProjType != NULL ) {
		pCIProjType->SetThis( NULL );
		m_pIProjType->Release();
		m_pIProjType = NULL;
	}
};

LPPROJECTTYPE CProjType::GetInterface(void){
	if( m_pIProjType ) {
		m_pIProjType->AddRef();
	} else {
		pCIProjType = new CProjTypeInterface;
		m_pIProjType = pCIProjType->GetInterface();
		pCIProjType->SetThis(this);
	}
	return m_pIProjType;
}


// Useful for dynamic creation of CProjTypes
CProjType::CProjType(const _TCHAR * lpszTypeName, UINT nUniqueTypeId, CPlatform * pPlatform)
{
	ASSERT(nUniqueTypeId < 256);
	
	m_nIDType = 0;
	m_strType = lpszTypeName;
	m_strUIType = lpszTypeName;
	m_nUniqueTypeId = nUniqueTypeId & 255;
	m_pPlatform = pPlatform;
	m_pIProjType = NULL;


	// our component name
	m_strCompName = MakeNameFromPlatformAndType(*(m_pPlatform->GetName()), m_strType);

	// register ourselves with the config. manager
	g_prjcompmgr.RegisterProjType(this);
}

BOOL CProjType::FInit()
{
	BOOL retval = m_nIDType ? m_strUIType.LoadString(m_nIDType) : TRUE;
	if (retval)
		m_strUICompName = MakeNameFromPlatformAndType(*(m_pPlatform->GetUIDescription()), m_strUIType);

    AddTool(szAddOnGeneric, BCID_Tool_CustomBuild);   
    AddTool(szAddOnGeneric, BCID_Tool_SpecialBuild);   

	return retval;
}

void CProjType::AddTool(const TCHAR * szPckg, WORD idTool)
{
	CBuildTool * pTool;
	if (!g_prjcompmgr.LookupBldSysComp(GenerateComponentId(g_prjcompmgr.GenerateBldSysCompPackageId((TCHAR *)szPckg), idTool),
									   (CBldSysCmp *&)pTool))
		ASSERT(FALSE);	// failed

	// now add it
	AddTool(pTool);
}

void CProjType::AddTool(WORD pckg, WORD idTool)
{
	CBuildTool * pTool;
	if (!g_prjcompmgr.LookupBldSysComp(GenerateComponentId(pckg, idTool), (CBldSysCmp *&)pTool))
		ASSERT(FALSE);	// failed

	// now add it
	AddTool(pTool);
}

void CProjType::AddTool(CBuildTool * pTool)
{
	// make sure we got a valid tool
	ASSERT_VALID(pTool);
	ASSERT(pTool->IsKindOf(RUNTIME_CLASS(CBuildTool)));

	// don't add if already there
	if (m_ToolsList.Find(pTool) != (POSITION)NULL)
		return;

	// FUTURE: remove this ordering when it doesn't matter
	// ie. whe we have a dependency based build engine
	// for the old v2 build engine CSchmoozeTool's must be last

	if (pTool->IsKindOf(RUNTIME_CLASS(CSchmoozeTool)))
	{
		// Find location of CCustomBuildTool or CSpecialBuildTool
		POSITION posSpecial = m_ToolsList.GetHeadPosition();
		while (NULL!=posSpecial)
		{
			// Save posLast which will be the position of pSpecailTool.
			POSITION posLast = posSpecial;

			CBuildTool* pSpecialTool = (CBuildTool*)m_ToolsList.GetNext(posSpecial);
			ASSERT(NULL!=pSpecialTool);
			if (pSpecialTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)) ||
				pSpecialTool->IsKindOf(RUNTIME_CLASS(CSpecialBuildTool)) )
			{
				// Set posSpecial to position of pSpecialTool and exit loop.
				posSpecial = posLast;
				break;
			}
		}

		if (NULL!=posSpecial)
			m_ToolsList.InsertBefore(posSpecial,pTool);
		else
			m_ToolsList.AddTail(pTool);
	}
	else if (pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
	{
		m_ToolsList.AddTail(pTool);
	}
	else if (pTool->IsKindOf(RUNTIME_CLASS(CSpecialBuildTool)))
	{
		m_ToolsList.AddTail(pTool);
	}
	else
		m_ToolsList.AddHead((CObject *)pTool);
	// FUTURE:
}

CProjType::~CProjType()
{
	CBuildTool * pTool;
	// remove tools, deleting any dynamic ones
	while (!m_ToolsList.IsEmpty())
	{
		pTool = (CBuildTool *)m_ToolsList.RemoveHead();
		if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
			delete pTool;
	}

	// de-register ourselves with the config. manager
	g_prjcompmgr.DeregisterProjType(this);
	ReleaseInterface();
}

void CProjType::ClearUnknownTools()
{
	CBuildTool * pTool;
	// remove tools, deleting any dynamic ones
    POSITION posCurr;
    POSITION pos = m_ToolsList.GetHeadPosition();
    while (pos != NULL)
	{
        posCurr = pos;
        pTool = (CBuildTool *)m_ToolsList.GetNext(pos);
		if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
        {
			delete pTool;
            m_ToolsList.RemoveAt(posCurr);
        }
	}
}

BOOL CProjType::SetDefaultDebugTargetOptions(CProject* pProject, CTargetItem * pTarget, BOOL fUseMFC)
{
	pProject->SetIntProp(P_ProjAppWizUseMFC, FALSE);

	// use MFC by default, except console application
	// NOTE: must do this after set default tool option !
	int iUseMFC = fUseMFC ? GetUseMFCDefault() : NoUseMFC;
	pProject->SetIntProp(P_ProjUseMFC, iUseMFC);

	return TRUE;
}

BOOL CProjType::SetDefaultReleaseTargetOptions(CProject* pProject, CTargetItem * pTarget, BOOL fUseMFC)
{
	return SetDefaultDebugTargetOptions(pProject, pTarget, fUseMFC);
}

//	Get through the tools one at a time, looking for a match.  This is
//	slow if there are many tools, but there ain't.
CBuildTool * CProjType::PickTool(FileRegHandle frh)
{
	if (frh == (FileRegHandle)NULL)
		return NULL;

	CBuildTool * pTool;
	POSITION pos = m_ToolsList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		pTool = (CBuildTool *)m_ToolsList.GetNext (pos);

		if (pTool->m_fTargetTool)
			break;

		if (pTool->AttachToFile(frh))
			return pTool;
	}
	return NULL;
}


CBuildTool * CProjType::GetToolFromCodePrefix(const TCHAR * pPrefix, int nPrefixLen)
{
	CBuildTool * pTool;
/*
R.I.P. for v4.0 with VBA?
	CCustomTool * pCustTool;

	g_prjcompmgr.InitCustomToolEnum();
	while (g_prjcompmgr.NextCustomTool(pCustTool))
	{
		const TCHAR * pc = pCustTool->m_strToolPrefix;
		int len = _tcslen(pc);
		if (len && !_tcsnicmp(pPrefix, pc, min(nPrefixLen, len)))
			return pCustTool;
	}
*/

	POSITION pos = m_ToolsList.GetHeadPosition();
	while (pos != (POSITION)NULL)	
	{
		pTool = (CBuildTool *)m_ToolsList.GetNext(pos);

		const TCHAR * pc = pTool->m_strToolPrefix;
		int len = (int)_tcslen(pc);
		if (len && !_tcsnicmp(pPrefix, pc, min(nPrefixLen, len)))
			return pTool;
	}

	return (CBuildTool *)NULL;
}

void CProjType::PerformSettingsWizard(CProjItem * pItem, BOOL fUsingMFC)
{
	// ensure our configs are ok, ie. inform each tool
	// of this MFC state change

	// what is the config. mode?
	BOOL fDebug;

	pItem->GetIntProp(P_UseDebugLibs, fDebug);

	const CPtrList * plistTools = GetToolsList();
	
	// preserve the option handler and current slob for 'option engine'
	COptionHandler * popthdlrOld = g_prjoptengine.GetOptionHandler();
	CSlob * pslobOld = g_prjoptengine.GetPropertyBag();

	g_prjoptengine.SetPropertyBag(pItem);

	CBuildTool * pTool;
	for (POSITION pos = plistTools->GetHeadPosition(); pos != NULL;)
	{
		// tell each tool that whether or not we're using MFC
		pTool = (CBuildTool *)plistTools->GetNext(pos);
		COptionHandler * popthdlr = pTool->GetOptionHandler();
		if (popthdlr != (COptionHandler *)NULL)
			g_prjoptengine.SetOptionHandler(popthdlr);
		pTool->PerformSettingsWizard(pItem, fDebug, (BOOL)fUsingMFC);
	}		

	// reset
	g_prjoptengine.SetPropertyBag(pslobOld);
	g_prjoptengine.SetOptionHandler(popthdlrOld);
}

CString CProjType::MakeNameFromPlatformAndType(const CString & platform, const CString & type)
{
	return platform + _TCHAR(' ') + type;
}

CString CProjType::MakeNameFromPlatformAndType(const _TCHAR * platform, const _TCHAR * type)
{
	return (CString)platform + _TCHAR(' ') + type;
}

// COLEProjType
// ************

CPlatform * COLEProjType::GetPlatform() const {
	return m_pPlatform;
}

// Get Type name Get the project type name.
const CString * COLEProjType::GetTypeName(){
	ASSERT( m_pProj );
	if( m_pProj ){
		// TODO : change to LPOLESTR
		CString str;
		m_pProj->GetName( &str );
		m_strType = str;
	}
	return &m_strType;		// our target type name
}

// IsSupported - Add On should true if all components needed for 
//				 this project type are available.
BOOL COLEProjType::IsSupported() const {
	ASSERT( m_pProj );
	if( m_pProj ){
		return m_pProj->IsSupported();
	}
	return FALSE;
}

CBuildTool *COLEProjType::PickTool(FileRegHandle){
	ASSERT( m_pProj );
	if( m_pProj ){
		// Get the file handle from the pItem
		// m_pProj->PickTool( file handle, tool );
		// convert the ole tool to a CBuid tool
		// return pTool;
	}
	return NULL;
}

CPtrList * COLEProjType::GetToolsList() {
	return &m_ToolsList;
}

// CProjTypeUnknown
// ****************

CProjTypeUnknown::~CProjTypeUnknown()
{
}

BOOL CProjTypeUnknown::FInit()
{
	// Tools that we can use.  Tools are added later dynamically

	return CProjType::FInit();
}

// our tool option helper functions
void VPROJDeriveDefaultOptions(CString & strOption, UINT nIDCommon, UINT nIDMode, UINT nIDOption)
{
	CString	strPart;

	VERIFY(strOption.LoadString(nIDCommon));
	if (nIDMode != (UINT)-1)
	{
		VERIFY(strPart.LoadString(nIDMode));
		strOption += _T(' '); strOption += strPart;
	}
	if (nIDOption != (UINT)-1)
	{
		VERIFY(strPart.LoadString(nIDOption));
		strOption += _T(' '); strOption += strPart;
	}
}

////////////////////////////////////////////////////////////
// CConfigEnum

CConfigEnum g_theConfigEnum;	// The one and only CConfigEnum

CEnumerator * CConfigEnum::GetList()
{
	// FUTURE: this could be made a whole lot more efficient!

	int			nCfg, nNumCfgs, nCurCfg, nTotalCfgs;
	CProp *		pProp;

	// Free the last list returned, if any.
	if (m_prevListReturned != NULL)
		delete [] m_prevListReturned;

	nTotalCfgs = nCurCfg = 0;
	// Now form the new list and return it.
	CString strProject;
	CProject * pProject;
	CProject::InitProjectEnum();
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		nTotalCfgs += pProject->GetPropBagCount();
	}
	m_prevListReturned = new CEnumerator[nTotalCfgs + 1];

	CProject::InitProjectEnum();
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		nNumCfgs = pProject->GetPropBagCount();
		for (nCfg = 0 ; nCfg<nNumCfgs ; ++nCfg, ++nCurCfg)
		{
			CPropBag * pBag = pProject->GetPropBag(nCfg);
			VERIFY((pProp = pBag->FindProp(P_ProjConfiguration)) != (CProp *)NULL);
			ASSERT(pProp->m_nType == string);

			m_prevListReturned[nCurCfg].szId = (const char *)((CStringProp *)pProp)->m_strVal;

			// is this a 'native' supported config.?
			BOOL fSupported = TRUE;	// default is TRUE
		
			// FUTURE: Do we need this for exe projects at all!
			if (!pProject->m_bProjIsExe)	// exe projects *are* supported!
			{
				VERIFY((pProp = pBag->FindProp(P_ProjOriginalType)) != (CProp *)NULL);
				ASSERT (pProp->m_nType == string);

				CProjType * pprojtype;
				if (g_prjcompmgr.LookupProjTypeByName(((CStringProp *)pProp)->m_strVal, pprojtype))
					fSupported = pprojtype->IsSupported();
			}
			m_prevListReturned[nCurCfg].val = fSupported;	// supported?
		}
	}

	m_prevListReturned[nCurCfg].szId = NULL;	// terminate list
	m_prevListReturned[nCurCfg].val = 0;		// terminate list

	return m_prevListReturned;
}

////////////////////////////////////////////////////////////
// CConfigEnum

CProjectEnum g_theProjectEnum;	// The one and only CConfigEnum

CEnumerator * CProjectEnum::GetList()
{
	// FUTURE: this could be made a whole lot more efficient!

	// Free the last list returned, if any.
	if (m_prevListReturned != NULL) {
		delete [] m_prevListReturned;
		delete [] m_prevStrListReturned;
	}

	// Now form the new list and return it.
	CString strProject;
	CProject * pProject;
	int nTotalProjects=0;
	CProject::InitProjectEnum();
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		nTotalProjects++;
	}
	m_prevListReturned = new CEnumerator[nTotalProjects + 1];
	m_prevStrListReturned = new CString[nTotalProjects];

	int	nCurProj = 0;
	CProject::InitProjectEnum();
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		int nNumCfgs = pProject->GetPropBagCount();
		if( nNumCfgs ){
			CString strProjectName;
			VERIFY(pProject->GetStrProp(P_ProjItemName, strProjectName));

			int iDot = strProjectName.ReverseFind(_T('.'));
			if (iDot > 0)
				strProjectName = strProjectName.Left(iDot);

			m_prevStrListReturned[nCurProj] = (const char *)strProjectName;
			m_prevListReturned[nCurProj].szId = (const char *)m_prevStrListReturned[nCurProj];
			m_prevListReturned[nCurProj].val = TRUE;	// supported?
			nCurProj++;
		}
	}

	m_prevListReturned[nCurProj].szId = NULL;	// terminate list
	m_prevListReturned[nCurProj].val = 0;		// terminate list

	return m_prevListReturned;
}

CEnumerator * CProjConfigEnum::GetList()
{
	// FUTURE: this could be made a whole lot more efficient!

	int			nCfg, nNumCfgs, nCurCfg, nTotalCfgs;
	CProp *		pProp;

	// Free the last list returned, if any.
	if (m_prevListReturned != NULL){
		delete [] m_prevListReturned;
		delete [] m_prevStrListReturned;
	}

	nTotalCfgs = nCurCfg = 0;
	// Now form the new list and return it.

	CString strProject;
 	CProject * pProject = g_pActiveProject;
	nTotalCfgs += pProject->GetPropBagCount();
	nNumCfgs = pProject->GetPropBagCount();
	m_prevListReturned = new CEnumerator[nTotalCfgs + 1];
	m_prevStrListReturned = new CString[nTotalCfgs];


	for (nCfg = 0 ; nCfg<nNumCfgs ; ++nCfg, ++nCurCfg)
	{
		CPropBag * pBag = pProject->GetPropBag(nCfg);
		VERIFY((pProp = pBag->FindProp(P_ProjConfiguration)) != (CProp *)NULL);
		ASSERT(pProp->m_nType == string);

		CString strDescription = (const char *)((CStringProp *)pProp)->m_strVal;
		int nSep = strDescription.Find(_T(" - "));
		if( nSep != -1 )
			strDescription = strDescription.Right(strDescription.GetLength() - nSep - 3);

		m_prevStrListReturned[nCfg] = (const char *)strDescription;
		m_prevListReturned[nCfg].szId = (const char *)m_prevStrListReturned[nCfg];

		// is this a 'native' supported config.?
		BOOL fSupported = TRUE;	// default is TRUE 
	
		// FUTURE: Do we need this for exe projects at all!
		if (!pProject->m_bProjIsExe)	// exe projects *are* supported!
		{
			VERIFY((pProp = pBag->FindProp(P_ProjOriginalType)) != (CProp *)NULL);
			ASSERT (pProp->m_nType == string);

			CProjType * pprojtype;
			if (g_prjcompmgr.LookupProjTypeByName(((CStringProp *)pProp)->m_strVal, pprojtype))
				fSupported = pprojtype->IsSupported() && pprojtype->GetPlatform()->GetBuildable();
		}
		m_prevListReturned[nCurCfg].val = fSupported;	// supported?
	}
	

	m_prevListReturned[nCurCfg].szId = NULL;	// terminate list
	m_prevListReturned[nCurCfg].val = 0;		// terminate list

	return m_prevListReturned;
}

////////////////////////////////////////////////////////////
// CPlatformEnum

CPlatformEnum g_thePlatformEnum;	// The one and only CPlatformEnum

CEnumerator * CPlatformEnum::GetList()
{
	int			nPlatform, nCountPlatforms;
	CPlatform *	pPlatform;

	// Free the last list returned, if any.
	if (m_prevListReturned != NULL)
		delete [] m_prevListReturned;

	// Now form the new list and return it.
	nCountPlatforms = g_prjcompmgr.GetPlatformCount();
	m_prevListReturned = new CEnumerator[nCountPlatforms + 1];
	nPlatform = 0;

	g_prjcompmgr.InitPlatformEnum();
	while (g_prjcompmgr.NextPlatform(pPlatform))
	{
		if (!pPlatform->IsSupported()) continue;
		m_prevListReturned[nPlatform].szId = (const TCHAR *)*pPlatform->GetUIDescription();
		m_prevListReturned[nPlatform].val = nPlatform;

		++nPlatform;
	}
	m_prevListReturned[nPlatform].szId = NULL;	// terminate list
	m_prevListReturned[nPlatform].val = 0;		// terminate list

	return m_prevListReturned;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\pfilereg.h ===
/////////////////////////////////////////////////////////////////////////////
//
//	CFileRegEntry, CFileRegSet, CFileRegFilter, CFileRegFile, CProjFileRegistry
//
//	File registry database classes
//
//	History:
//	Date						Who						What
//	07/20/94					colint					Cleaned up existing
//														file registry and
//														added file filters.
/////////////////////////////////////////////////////////////////////////////

#ifndef __PFILEREG_H__
#define __PFILEREG_H__

// New reference count work.
#define REFCOUNT_WORK

#include <bldapi.h>
#include <gmap.h>

#if defined(_DEBUG) && defined(new)
#define _DO_DEBUG_NEW
#undef new
#endif

//
// inline replacement for ::CompareFileTime (takes references instead of pointers).
//
__inline int CompareFileTimes( const struct _FILETIME& ft1, const struct _FILETIME& ft2 )
{
	if ( ft1.dwHighDateTime == ft2.dwHighDateTime )
	{
		if ( ft1.dwLowDateTime == ft2.dwLowDateTime )
		{
			return 0;
		}
		else if (ft1.dwLowDateTime > ft2.dwLowDateTime)
		{
			return 1;
		}
		else
		{
			return -1;
		}
	}
	else if (ft1.dwHighDateTime > ft2.dwHighDateTime)
	{
		return 1;
	}
	else
	{
		return -1;
	}
}

__inline int FuzzyCompareFileTimes( const struct _FILETIME& ft1, const struct _FILETIME& ft2 )
{
	if ( ft1.dwHighDateTime == ft2.dwHighDateTime )
	{
		unsigned int fuzzy = 0;
		if( theApp.m_bWin95 ) fuzzy = 20000000;
		if ( ft1.dwLowDateTime > (ft2.dwLowDateTime+fuzzy))
		{
			return 1;
		}
		else
		{
			return -1;
		}
	}
	else if (ft1.dwHighDateTime > ft2.dwHighDateTime)
	{
		return 1;
	}
	else
	{
		return -1;
	}
}

/////////////////////////////////////////////////////////////////////////////
// Local heap

#ifdef USE_LOCAL_BUILD_HEAP
class CLclHeap
{
public:
	// constructor + destruct
	// 'cPages' is # of pages (4k) to initially alloc.
	// 'fCreate' is whether to create the heap at ctor time
	CLclHeap(USHORT cPages = 0, BOOL fCreate = FALSE);
	virtual ~CLclHeap();

	// create + destroy the heap
	BOOL Create();
	BOOL Destroy(); 

	// alloc. + dealloc.
	__inline void * alloc(size_t size, BOOL fZero = FALSE)
	{
#ifdef _DEBUG
		m_lAlloc += (ULONG)size;
#endif // _DEBUG 
		return ::HeapAlloc(m_hHeap, HEAP_NO_SERIALIZE, size);
	}

	enum FILL {zeroed = 0};
	__inline void * alloc(size_t size, FILL)
	{
#ifdef m_lAlloc
		lAlloc += (ULONG)size;
#endif // _DEBUG 
		return ::HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY | HEAP_NO_SERIALIZE, size);
	}

	__inline void dealloc(void * pv)
	{
		ASSERT(pv != (void *)NULL);	// don't allow de-alloc. NULL ptrs
#ifdef _DEBUG
		m_lAlloc -= (ULONG)::HeapSize(m_hHeap, HEAP_NO_SERIALIZE, pv);
#endif // _DEBUG
		VERIFY(::HeapFree(m_hHeap, HEAP_NO_SERIALIZE, pv));
	}

#ifdef _DEBUG
	// dump heap statistics
	virtual void Dump(CDumpContext & dc);
#endif // _DEBUG

private:
	// our heap
	HANDLE m_hHeap;

	// default pages in our heap
	USHORT m_cPages;

#ifdef _DEBUG
	// allocated data size?
	ULONG m_lAlloc;
#endif // _DEBUG
};
#endif // USE_LOCAL_BUILD_HEAP

class CFileRegEntry;
class CFileItem;
class ConfigurationRecord;
class FCItem;
class CFileRegistry;
class CTargetItem;

/////////////////////////////////////////////////////////////////////////////
// FileRegHandle definition. All access to file registry entries is done
// using a handle. Currently this handle is just a pointer to the entry
// but this may change and so EVERYONE should use handles to refer to
// file registry entries. The file registry has a function to map from
// a FileRegHandle to a real file registry entry.
typedef CFileRegEntry * FileRegHandle;

// Typed array of CFileRefFile pointers.
typedef CTypedPtrArray<CPtrArray,class CFileRegEntry *> CFRFPtrArray;

/////////////////////////////////////////////////////////////////////////////
// The file change notification function. This function is called whenever
// properties of a file registered with the file registry change on disk.
void BldSrcFileChangeCallBack(const FCItem* pfc, DWORD dwUser);

/////////////////////////////////////////////////////////////////////////////
// The asynchronous file-added funciton. This function is called when
// the file change thread has successfully added the file to it's file
// change notification list (asynchronously)
//
// #define _BLD_SRC_FC_ASYNC to enable this
//
// #define _BLD_SRC_FC_ASYNC
void BldSrcFileAddedCallBack(const FCItem* pfc);

/////////////////////////////////////////////////////////////////////////////
// The build system can cope without file change notifications and if this
// is the case then the build system will go to disk whenever it needs a
// property of a file, e.g. it stats the file. To turn off file change
// notifications just define _BLD_NO_FILE_CHNG
//
// #define _BLD_NO_FILE_CHNG to disable file change notifications

/////////////////////////////////////////////////////////////////////////////
// This enables file registry object history debugging. This is useful
// for tracking down problems where we have done one too many ReleaseRegRef's
// or one too many AddRegRef's.
//
// This is enabled by default in the debug build
//
// #define _BLD_REG_HISTORY to enable this

#ifdef _DEBUG
// This is VERY TIME INTENSIVE, so we don't do it for now!!!
// #define _BLD_REG_HISTORY     
#endif

#ifdef _BLD_REG_HISTORY

class CFRHHistory : public CObject
{
public:
	CFRHHistory(TCHAR * szFile, int nLine, BOOL bAddRef, CFRHHistory * pNext) 
		{ m_szFile = szFile; m_nLine = nLine; m_bAddRef = bAddRef; m_pNext = pNext; }
	~CFRHHistory() { if (m_pNext) delete m_pNext; }

#ifdef _DEBUG
	void Dump(CDumpContext &DC) const;
#endif

private:
	TCHAR *	        m_szFile;
	int		        m_nLine;
	CFRHHistory *	m_pNext;
	BOOL			m_bAddRef;
};

#endif

/////////////////////////////////////////////////////////////////////////////
// Queue and dequeue our file registry entry changes.

typedef struct 
{
	FileRegHandle	_frh;		// file registry handle
	BOOL			_fOk;		// ok?
	FILETIME		_filetime;	// last write time
	BOOL			_fExists;	// exists?
	BOOL			_fInSccOp;	// SCC op in progress at the time?
} S_ATTRIB;

extern void FileChangeQ(FileRegHandle frh, BOOL fInSccOp = FALSE);
extern int FileChangeDeQ();

/////////////////////////////////////////////////////////////////////////////
// Setting this flag to TRUE will prevent any further requests for file
// change notification, eg. it is used during builder creation
extern BOOL g_FileRegDisableFC;

/////////////////////////////////////////////////////////////////////////////
//
// The file registry uses its own notification system. Originally some
// thought was given as to whether the CSlob class could be used as the
// base class. However it was decided that the difference between the
// functionality of the file registry classes and the CSlob classes was
// large enough to warrant not using the CSlob class as the base class.
// 
// The notification mechanism is sufficient to provide notifications within
// the file registry. However if other classes outside of the file registry
// wish to be notified of changes in the "properties" of the file registry
// items then this will have to be added by hand.

/////////////////////////////////////////////////////////////////////////////
// Standard file registry notifications

#ifdef REFCOUNT_WORK

#define		FRN_ALL			0x2
#define		FRI_DESTROY		0x3
#define		FRI_ADD			0x4

#else

#define		FRN_DESTROY		0x0
#define		FRN_ADD			0x1
#define		FRN_ALL			0x2
#define		FRN_LCL_DESTROY	0x4
#define		FRN_LAST		FRN_LCL_DESTROY

/////////////////////////////////////////////////////////////////////////////
// Standard file registry informs

#define		INF_MASK		0x10

#define		FRI_DESTROY		(FRN_DESTROY | INF_MASK)
#define		FRI_ADD			(FRN_ADD | INF_MASK)
#define		FRI_ALL			(FRN_ALL | INF_MASK)
#define		FRI_LCL_DESTROY	(FRN_LCL_DESTROY | INF_MASK)

#endif

/////////////////////////////////////////////////////////////////////////////
// File registry property identifiers

#define		P_NewTStamp		11
#define		P_ExistsOnDisk	12

/////////////////////////////////////////////////////////////////////////////
//
//	CFileRegNotifyRx. This class provides support for file registry
//	notification receiving. Basically any class that is interested in
//	being able to receive notifications about changes in the file
//	registry should derive from this. NOTE: Multiple inheritance is
//	possible, for an example take a look at the CFileRegEntry class
//	below. 

class CFileRegNotifyRx
{
protected:
	DWORD	dwNodeType;

public:
	virtual void	OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint) = 0;
		// OnNotify is a pure virtual function, this should be overridden in
		// a derived class to handle notification from the file registry
		// about any changes

	// in order to know what type of node we have, we keep track locally so we don't
	// have to use IsKindOf which takes a bloody lot of time!
	enum
	{
		nodetypeRegNotifyRx = 0x1,
		nodetypeRegEntry = 0x2,
		nodetypeRegSet = 0x4,
		nodetypeRegFilter = 0x8,
		nodetypeRegFile = 0x10,
		nodetypeRegRegistry = 0x20,
#ifndef REFCOUNT_WORK
		nodetypeRegMax = 0x40
#else
		nodetypeRegFilterSet = 0x40,
		nodetypeRegMax = 0x80
#endif
	};
	CFileRegNotifyRx()
	{
		dwNodeType = nodetypeRegNotifyRx;
	}
	DWORD	NodeType() const { return dwNodeType; }
	BOOL	IsNodeType(DWORD dw)
	{
		ASSERT(dwNodeType &&
			dwNodeType > nodetypeRegNotifyRx &&
			dwNodeType < nodetypeRegMax);
		return (dw & NodeType()) != 0;
	}
};

// General-purpose class for storing a "small" set of pointers.
// This is used (& tuned) for keeping track of the dependants of a CFileRegEntry.
// For simplicity & tune-ability, it supports only the operations which are
// actually used by the dependency handling code.
//
class CSmallPtrSet : public CPtrArray
{
	// Implementation detail: POSITION is a 1-based index.
public:
	CSmallPtrSet()
		{}
	~CSmallPtrSet()
		{}
	POSITION AddTail(void* newElement)
	{
		// To prevent heap fragmentation, make the array double its size
		// whenever it needs to grow.
		if (m_nSize > 4)
		{
			m_nGrowBy = m_nSize;
		}
		return POSITION(Add(newElement) + 1);
	}
	POSITION GetHeadPosition()
	{
		return m_nSize == 0 ? POSITION(0) : POSITION(1);
	}
	POSITION Find(void const * const pItem);
	void* GetNext(POSITION& rPosition) const;
	void RemoveItem(void *pItem);
};

/////////////////////////////////////////////////////////////////////////////
//
//	CFileRegEntry. This class contains all information that the build
//	system will ever need to know about a specific file. The file registry
//	contains references to items of this class.

class BLD_IFACE CFileRegEntry : public CObject, public CFileRegNotifyRx
{
	DECLARE_DYNAMIC(CFileRegEntry);

public:
 
// Constructors/Destructors
  	CFileRegEntry();
	virtual ~CFileRegEntry();

#ifdef REFCOUNT_WORK
	//
	// Override SafeDelete if asynchronous access to map is possible.
	//
	virtual void SafeDelete(){ delete this; }
#endif

	// handle our own allocations
	// we'll use our own private Win32 heap
	// and place de-alloc'ed blocks into a 
	// global list
// can't override operator new if the "new" is already #defined to be
// DEBUG_NEW
#ifdef USE_LOCAL_BUILD_HEAP
#if defined(_DEBUG) && defined (new)
#define REDEF_NEW
#undef new
#endif
	__inline void * operator new(size_t size) {return g_heapEntries.alloc(size);}
	__inline void * operator new(size_t size, LPCSTR, int) {return g_heapEntries.alloc(size);;}
#ifdef REDEF_NEW
#undef REDEF_NEW
#define new DEBUG_NEW
#endif
	__inline void operator delete(void * p) {g_heapEntries.dealloc(p);}
#endif

// Update property functions 
	// return TRUE if actually performed refresh (ie. props were not current)
	virtual BOOL	RefreshAttributes() = 0;

// Notification support functions
 	virtual void	OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint);
 	virtual void	InformNotifyRxs(UINT idChange, DWORD dwHint = 0);
	void			AddNotifyRx(CFileRegNotifyRx* pfre);
	void			RemoveNotifyRx(CFileRegNotifyRx* pfre);

// Property access functions
  	virtual BOOL	GetTimeProp(UINT idProp, FILETIME& ftime) { return FALSE; }
	// FUTURE(karlsi): this doesn't need to be virtual
	virtual BOOL	GetIntProp(UINT idProp, int& nVal);
 	__inline BOOL 	ExistsOnDisk() { (void)UpdateAttributes(); return m_nExistsOnDisk; }
#if 0
	__inline BOOL	IsProjectFile() { return (m_nProjRefCount > 0); }
#endif
#ifndef REFCOUNT_WORK
	__inline BOOL	IsRelative() { return m_bRelative; }
#endif
	__inline BOOL	IsMatchCase() { return m_bMatchCase; }
	// FUTURE (colint): This will be needed when m_nProjRefCount becomes a simple bool
	//virtual void	SetProjectFile(BOOL bProjectFile) { m_bProjectFile = bProjectFile; }
#ifndef REFCOUNT_WORK
	virtual void	SetRelative(BOOL bRelative) { m_bRelative = bRelative; }
#else
	// Do nothing!
	virtual void	SetRelative(BOOL bRelative) {}
#endif
	virtual void	SetMatchCase(BOOL bMatchCase, BOOL bCaseApproved = FALSE) { m_bMatchCase = bMatchCase; }
 	virtual const CPath *	GetFilePath() { return NULL; }
 	virtual BOOL	GetFileTime(FILETIME& ft) { return FALSE; }
 	virtual BOOL	GetFileTime(CString& str) { return FALSE; }

    // Bring time stamp uptodate
    virtual BOOL    Touch() { return FALSE; }

// Reference counting functions
#ifndef REFCOUNT_WORK
 	__inline void 	AddFRHRef() { m_nRefCount++; }
	__inline void 	ReleaseFRHRef() { m_nRefCount--; if (m_nRefCount == 0) {InformNotifyRxs(FRN_DESTROY); delete this;} }
#else
#ifdef _DEBUG
	// Define in pfilereg.cpp instead of inline for easier debugging.
	void AddFRHRef();
	void ReleaseFRHRef();
#else
 	__inline void 	AddFRHRef() { m_nRefCount++; }
	__inline void 	ReleaseFRHRef() { m_nRefCount--; if (m_nRefCount == 0) {SafeDelete();} }
#endif
#endif
	__inline int	GetRefCount() { return m_nRefCount; }
 
// Helper function for comparing times
	__inline static long		MyCompareFileTime(FILETIME* pTime1, FILETIME* pTime2)
	{
		return CompareFileTimes(*pTime1, *pTime2);
	}

	__inline static long		MyFuzzyCompareFileTime(FILETIME* pTime1, FILETIME* pTime2)
	{
		return FuzzyCompareFileTimes(*pTime1, *pTime2);
	}
													 
// Helper function for registering this file reg entry with the file change
// notification system
	virtual BOOL	WatchFile() { return FALSE; }

//#ifndef REFCOUNT_WORK
// Support for mapping from file reg handles to CFileItems.
// FUTURE (colint): This will go away sometime in the future.
	void 			AssociateFileItem(CFileItem * pItem);
	BOOL			DisassociateFileItem(CFileItem * pItem);
//#endif // REFCOUNT_WORK

#if 0
	//
	// Note(tomse): This project reference count does not work with the new
	// multiple project model.  This functionality is now provided by the
	// CProject.
	//
// Support for project reference counting - this is only used for making
// sure that IsProjectFile gives the correct answer.
	__inline void	AddProjRef() { m_nProjRefCount++; }
	__inline void	ReleaseProjRef() { m_nProjRefCount--; }
	__inline int	GetProjRefCount() { return m_nProjRefCount; }
#endif


	// NOTE: plstFileItems should eventually be removed from CFileRegEntry. 
	CObList *		plstFileItems;		// == (CObList *)NULL if *not used* (empty)

// Helper function - updates the attributes if necessary
	// return TRUE if actually changed (ie. props were updated)
	virtual BOOL		UpdateAttributes();

// Should we refresh attributes? (default is only if we are dirty)
	virtual inline BOOL DoRefresh()	{ return m_bDirty && m_bUpdateAttribs; }
	__inline void MakeDirty()	{ if (!m_bDirty) { m_bDirty = TRUE; InformNotifyRxs(FRN_ALL);} }

// include file dep related funcitons
	__inline void SetFileFoundInIncPath() { m_bFoundInPath = TRUE;}
	__inline BOOL IsFileFoundInIncPath() { return m_bFoundInPath;}
	__inline void SetFileNameRelativeToProj() { m_bRelativeToProjName = TRUE;}
	__inline BOOL IsFileNameRelativeToProj() { return m_bRelativeToProjName;}
	__inline void SetIndexNameRelative(int ich) { m_ich = ich;}
	__inline int  GetIndexNameRelative() { return m_ich;}
	__inline void SetOrgName(const CString& strName) { if (m_pOrgName) {free(m_pOrgName);} m_pOrgName = _tcsdup((TCHAR *)(LPCTSTR)strName);}
	__inline TCHAR * GetOrgName() { return m_pOrgName;}

protected:
// Access methods for read-only properties. These methods can only be
// called from derived classes and friends
	virtual BOOL	SetTimeProp(UINT idProp, FILETIME ftime) { return FALSE; }
	// FUTURE(karlsi): this doesn't need to be virtual
	virtual BOOL	SetIntProp(UINT idProp, int nVal);

// Dependants list
	CSmallPtrSet	m_Dependants;

// Properties - NO dependency notifications occur on these props
 	unsigned	m_nRefCount;
#if 0
	unsigned	m_nProjRefCount;	
#endif
#ifndef REFCOUNT_WORK
	BOOL		m_bRelative:2;
#endif
	BOOL		m_bMatchCase:2;

// Are we currently refreshing the entry's properties. If we are we have
// to turn off the automatic update mechanism to avoid getting into
// an infinite loop
	BOOL		m_bUpdateAttribs:2;

// Do we need to refresh our attributes
	BOOL		m_bDirty:2;

// Used for include file dependency list
	BOOL		m_bFoundInPath:2;		// this file is on in -I/INCLUDE paths
	BOOL		m_bRelativeToProjName:2;// this file is on in -I/INCLUDE paths
	BOOL		m_bUseIntDir:2;
	BOOL		m_bUseOutDir:2;
	BOOL		m_bWantActualCase:2;

// Properties - Dependency notifications occur on these props
	BOOL		m_nExistsOnDisk:2;
	 	
	unsigned	m_ich;					// the include file name relative to path(just name without ..\)
	TCHAR *		m_pOrgName;				// keep the original include name if it contain ..\(relative path)

public:
// Diagnostics
#ifdef _DEBUG
	virtual void	Dump(CDumpContext& dc) const;
#endif
    virtual void    DeleteFromDisk() { return; }

#ifdef USE_LOCAL_BUILD_HEAP
	// our local file reg. entry heap
	static CLclHeap g_heapEntries;
#endif
};

#if 0 // REFCOUNT_WORK ??
class CFileRegFile;
class BLD_IFACE CFileRegRefSet : public CFileRegEntry
{
public:
	virtual BOOL AddRegRef(FileRegHandle hndFileReg);
	virtual BOOL ReleaseRegRef(FileRegHandle hndFileReg);

	BOOL HasReference(FileRegHandle hndFileReg);

// Search functions
	FileRegHandle	LookupFile(const CPath* pPath); 
	FileRegHandle	LookupFile(LPCTSTR lpszFile);

	FileRegHandle RegisterFileFilter(const CString* pstrFilter);

// Filter the file handle (only use if RegisterFile() with fNoFilter == TRUE)
	void FilterFile(FileRegHandle hndFileReg);

	// Stuff added just to get this running.
	__inline CFileRegEntry *	GetRegEntry(FileRegHandle hndFileReg) { return hndFileReg; }

protected:
	FileRegHandle	LookupFileFilter(const CString* pstrFilter);

// Maps to go quickly from a string to a FileRegHandle
	CMapStringToPtr	m_FileMap;
	CMapStringToPtr	m_FilterMap;
};

class BLD_IFACE CFileRegProjectSet : public CFileRegRefSet
{
public:
	virtual BOOL AddRegRef(FileRegHandle hndFileReg);
	virtual BOOL ReleaseRegRef(FileRegHandle hndFileReg);
	virtual BOOL	RefreshAttributes();

	__inline BOOL IsProjectFile(FileRegHandle hndFileReg){ return HasReference(hndFileReg); };
	BOOL RemoveFromProject(CProjItem * pItem, BOOL fRemoveContained = TRUE);
	BOOL RestoreToProject(CProjItem * pItem, BOOL fRestoreContained = TRUE);

 	BOOL GetFileItemList(const CPtrList* pFileList, CObList& pFileItemList, BOOL fOnlyBuildable = TRUE, const ConfigurationRecord* pcr = NULL);
	UINT GetFileCount(const CPtrList * pFileList, BOOL fOnlyBuildable = TRUE, const ConfigurationRecord * pcr = NULL);
  	BOOL GetFileList(const CPath* pPath, const CPtrList*& pFileList);

	__inline const CPtrList* GetODLFileList() const 	{ return (const CPtrList*) &m_filelistODL; }
 	__inline const CPtrList* GetRCFileList() const { return (const CPtrList*) &m_filelistRC; }
	__inline const CPtrList* GetDEFFileList() const { return (const CPtrList*) &m_filelistDEF; }

private:
	CPtrList m_filelistRC;
	CPtrList m_filelistDEF;
	CPtrList m_filelistODL;
};

#endif // REFCOUNT_WORK

/////////////////////////////////////////////////////////////////////////////
//
// CFileRegSet

class BLD_IFACE CFileRegSet : public CFileRegEntry
{
	friend class CFileRegEntry;

	DECLARE_DYNAMIC(CFileRegSet)

public:

// Constructors/Destructors
	CFileRegSet(int nHashSize = 37);
	virtual ~CFileRegSet();

// Containment (by reference) support functions
	virtual BOOL	AddRegHandle(FileRegHandle hndFileReg, BOOL bAddRef = TRUE, BOOL bFront = FALSE);
	virtual BOOL	RemoveRegHandle(FileRegHandle hndFileReg, BOOL bReleaseRef = TRUE);
	
// Exist?
#ifdef REGISTRY_FILEMAP
	BOOL	RegHandleExists(FileRegHandle hndFileReg) const;
#else
	BOOL CFileRegSet::RegHandleExists(FileRegHandle hndFileReg) const
	{
		WORD w;
		return m_pmapContents != NULL
			   ? m_pmapContents->Lookup((void *)hndFileReg, w)
			   : (BOOL)m_Contents.Find((void *)hndFileReg);
	}
#endif

// Return the contents list
#ifdef REFCOUNT_WORK
	// GetContents is no longer exposed.
	__inline BOOL IsEmpty() { return m_Contents.IsEmpty(); }
	__inline int GetCount() { return m_Contents.GetCount(); }
	__inline FileRegHandle GetFirstFrh()
	{
		FileRegHandle frh = NULL;
		if (!m_Contents.IsEmpty())
		{
			frh = (FileRegHandle)m_Contents.GetHead();
			ASSERT (NULL!=frh);
			frh->AddFRHRef();
		}
		return frh;
	}
	virtual void				EmptyContent(BOOL fReleaseRef = TRUE);

	// Friend access needed for m_Contents.
	friend BOOL QuickNDirtyRegSetCompare(CFileRegSet * pregSet, CFileRegSet * pregSet2);
	friend class CFileRegistry;

	// Reluctantly added since 
	friend class CFileDepGraph;
#else
	__inline const CPtrList *	GetContent() { return &m_Contents; }
	virtual void				EmptyContent(BOOL fReleaseRef = TRUE);
	virtual void				ReplaceContent(CPtrList *, BOOL fAddRef = TRUE);
#endif

// Update property functions 
	// return TRUE if actually performed refresh (ie. props were not current)
	virtual BOOL	RefreshAttributes();

// Should we refresh attributes? (ask each of our content in turn...)
	virtual BOOL	DoRefresh();

// Helper function - updates the attributes if necessary
	// return TRUE if actually changed (ie. props were updated)
	virtual BOOL	UpdateAttributes();

// Incr. update of properties?
	BOOL	CalcAttributes(BOOL fOn = TRUE);

// Notification support function
	virtual void	OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint);

// Property Access functions
   	virtual BOOL	GetTimeProp(UINT idProp, FILETIME& ftime);

// Touch contents of file set
    virtual BOOL    Touch();
	 
// Recursive enumerate containment and return non-sets
	void			InitFrhEnum();
	FileRegHandle 	NextFrh();

#ifndef REFCOUNT_WORK
// Set the file registry associated with this set
	__inline void	SetFileRegistry(CFileRegistry * pFileRegistry)
		{ m_pFileRegistry = pFileRegistry; }
#else
	// Works differently for new reference count model.
	void SetFileRegistry(CFileRegistry * pFileRegistry);
#endif

// Map providing a quick lookup into our content (also used by CFileRegistry objects
// to maintain ref. count).  This pointer is NULL if no map is being maintained.
	CMapPtrToWord	*m_pmapContents;
	enum { cMapThreshold = 8 };			// no map until there are at least # items

protected:

// Access methods for read-only properties. These methods can only be
// called from derived classes and friends
	virtual BOOL	SetTimeProp(UINT idProp, FILETIME ftime);

// Properties - Dependency notifications occur on these props
	FILETIME		m_NewTime;

// Internal helper function for finding the new/old times of the files
// in this set.  Also combines functionally of FindExists().
	// This function will ensure that all props. are updated
	// for each of our contents
	void 			FindTimeAndExists(UINT idProp, BOOL bFindExists = FALSE);

// Internal helper function for finding the number of files that exist
	// This function will ensure that all props. are updated
	// for each of our contents
	void			FindExists();

	enum { nContentsBlockSize = 10 };
 	CPtrList		m_Contents;			// Containment list
	unsigned short	m_nHashSizeMapContents;
	unsigned short	m_nNotExists;		// Numb. of contained items that do not exist on disk
	CFileRegistry *	m_pFileRegistry;	// The file registry associated with us.	

public:
// Diagnostics
#ifdef _DEBUG
	virtual void	Dump(CDumpContext& dc) const;
#endif

// Internal (no checks == faster)  internal equivalents
// RemoveRegHandleI() used by ::EmptyContent()
	virtual void RemoveRegHandleI(FileRegHandle hndFileReg, BOOL bReleaseRef = TRUE);

// Remove contents from disk
    virtual void    DeleteFromDisk();

// Calculate attributes?
	BOOL m_fCalcAttrib:2;

private:
	BOOL m_fInitSet:2;

	// Used by the enumerator
	POSITION m_posEnum;
};

/////////////////////////////////////////////////////////////////////////////
//
// CFileRegFilter

class BLD_IFACE CFileRegFilter : public CFileRegSet
{
public:

// Constructors/Destructors
	CFileRegFilter(CString strFilter);
	virtual ~CFileRegFilter();
 
// Property access functions
	__inline const CString *	GetFilter() { return &m_strFilter; }

// Containment (by reference) support functions
	virtual BOOL	AddRegHandle(FileRegHandle hndFileReg, BOOL bAddRef = TRUE);
	virtual BOOL	RemoveRegHandle(FileRegHandle hndFileReg, BOOL bReleaseRef = TRUE);

#ifdef REFCOUNT_WORK
	BOOL AddFilterHandle(FileRegHandle hndFileReg);
	BOOL RemoveFilterHandle(FileRegHandle hndFileReg);
#endif

protected:
// Internal pattern matching function
	BOOL			Filter(LPCTSTR pszText);

// Properties - NO dependency notifications occur on these props
	CString		m_strFilter;
	CString		m_strFilterLC;

public:
// Diagnostics
#ifdef _DEBUG
	virtual void	Dump(CDumpContext& dc) const;
#endif

	DECLARE_DYNAMIC(CFileRegFilter)
};

#ifdef REFCOUNT_WORK

/////////////////////////////////////////////////////////////////////////////
//
// CFileRegFilterSet
//		This class represents a compound filter that contains the union of 2 or more
//		CFileRegFilter's
//

class BLD_IFACE CFileRegFilterSet : CFileRegSet
{
public:
	CFileRegFilterSet();
	virtual ~CFileRegFilterSet();
	virtual void OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint);
	BOOL AddFilter( CFileRegFilter* pFilter );

private:
	// Keep track of contained CFileRegFilter's.
	CPtrList m_FilterList;

	DECLARE_DYNAMIC(CFileRegFilterSet)
};
#endif

/////////////////////////////////////////////////////////////////////////////
//
// CFileRegFile

class BLD_IFACE CFileRegFile : public CFileRegEntry
{
public:

// Constructors/Destructors
#ifdef REFCOUNT_WORK
private:
#endif
	CFileRegFile(const CPath* pPath, BOOL bMatchCase = FALSE, BOOL bFiltered = TRUE);
#ifdef REFCOUNT_WORK
public:
#endif
	virtual ~CFileRegFile();

#ifdef REFCOUNT_WORK
	//
	// Override SafeDelete if asynchronous access to map is possible.
	//
	virtual void SafeDelete();

	enum { MaxKeyLen = _MAX_PATH };
	static FileRegHandle GetFileHandle(LPCTSTR szFileName, LPTSTR szKeyname = NULL);
	static FileRegHandle LookupFileHandleByName(LPCTSTR szFileName, LPTSTR szKeyName = NULL);
	static FileRegHandle LookupFileHandleByKey(LPCTSTR szKeyName);
	class CInitMap {
	public:
		CInitMap(int nHashSize=17);
		~CInitMap();
	};
	friend class CInitMap;
#endif

// Retrieve and set the file attributes
	void			GetAttributes(S_ATTRIB *);
	void			SetAttributes(S_ATTRIB *);

// Property Access Functions
	const CPath*	GetFilePath()
	{
		ASSERT(0<_tcslen(m_Path.GetFullPath()));
		return &m_Path;
	}

	// only use this if you are 100% sure you know what you are doing
	void SetFilePath(const CPath * pPath)
	{
		ASSERT(pPath);
		ASSERT(m_Path.IsInit());

		m_Path = *pPath;
	}

 	virtual BOOL	GetFileTime(FILETIME& ft);
  	virtual BOOL	GetFileTime(CString& str);
 	virtual BOOL	GetTimeProp(UINT idProp, FILETIME& ftime);
	virtual void	SetMatchCase(BOOL bMatchCase, BOOL bCaseApproved = FALSE);
	BOOL IsActualCase() { return (m_bMatchCase || (!m_bWantActualCase)); }

	inline void SetOutDirType(UINT type) { ASSERT(type <= 2); m_bUseOutDir = (type==1); m_bUseIntDir = (type==2); }
	inline UINT GetOutDirType() { return m_bUseIntDir ? 2 : (m_bUseOutDir ? 1 : 0); }

    virtual BOOL    Touch();

// Update property functions 
	// return TRUE if actually performed refresh (ie. props were not current)
	virtual BOOL	RefreshAttributes();

// Helper function - updates the attributes if necessary
	// return TRUE if actually changed (ie. props were updated)
	virtual BOOL	UpdateAttributes();

// File change notification registration
	// fRefreshed is TRUE if actually performed refresh (ie. props were not current)
	BOOL			WatchFile(BOOL & fRefreshed);

// Are we watching this file or not
	BOOL			m_bFileWatch:2;

// Have we added this to file change yet?
// Pls. note, m_bFileWatch may be FALSE if asynchronous addition.
	BOOL			m_bFileAddedToFC:2;

#ifndef REFCOUNT_WORK
// Has this file been filtered?
	BOOL			m_bFiltered:2;
#endif

// Management of files for which AddWatch failed (usually because the directory is nonexistent).
// We want to re-try the watch periodically, but not too often (or our idle processing will be too slow).
//
// FCanWatch() tests whether AddWatch has never failed, or failed but not within the last "N" ticks.
// "ticks" are not realtime but are incremented by AllowRetryFailedWatches(), once per idle and at some
//		other times also (e.g. at filechange notifications).  AllowRetryFailedWatches() can also be used
//		to force reevaluation of all failed watches.

	ULONG			m_tickFailedWatch;	// non-zero if AddWatch has failed
	static ULONG	s_tickCurrent;		// incremented by AllowRetryFailedWatches

	enum { ctickRetryInterval = 32 };

	inline BOOL			FCanWatch()
		{ return m_tickFailedWatch == 0 ||
				 (s_tickCurrent - m_tickFailedWatch) >= ctickRetryInterval; }

	static void		AllowRetryFailedWatches(BOOL fForceAll);
#ifdef _DEBUG
	static ULONG	s_cFailedWatches;
#endif

protected:
// Access methods for read-only properties. These methods can only be
// called from derived classes and friends
	virtual BOOL	SetTimeProp(UINT idProp, FILETIME ftime);

// Properties - Dependency notifications occur on these props

	// REVIEW(karlsi): m_nSccStatus is no longer used
	// int		m_nSccStatus;
	FILETIME	m_FileTime;

// Properties - NO dependency notifications occur on these props
	CPath		m_Path;

public:
	virtual void	DeleteFromDisk();
// Diagnostics
#ifdef _DEBUG
	virtual void	Dump(CDumpContext& dc) const;
#endif

	DECLARE_DYNAMIC(CFileRegFile)

#ifdef REFCOUNT_WORK
private:
	static CGrowingMapStringToPtr* s_pFileNameMap;
	static CTestableSection g_sectionFileMap;
#endif
};

/////////////////////////////////////////////////////////////////////////////
//
// CFileRegEnum. 

#ifdef _BLD_REG_HISTORY
#define AddRegRef(frh)			AddRegRefI(frh, __FILE__, __LINE__)
#define ReleaseRegRef(frh)		ReleaseRegRefI(frh, __FILE__, __LINE__)
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	CFileRegistry. A file registry provides an indexed way to access
//	CFileRegEntry items.

class BLD_IFACE CFileRegistry : public CFileRegSet
{
public:
// Constructors/Destructors
	CFileRegistry(int nHashSize = 911);
	virtual ~CFileRegistry();
 
// Registration functions
	FileRegHandle	RegisterFile(const CPath* pPath, BOOL bMatchCase = FALSE, BOOL bNoFilter = TRUE);
	FileRegHandle	RegisterFileFilter(const CString* pstrFilter);

// Filter the file handle (only use if RegisterFile() with fNoFilter == TRUE)
	void 			FilterFile(FileRegHandle hndFileReg);
#ifdef REFCOUNT_WORK
	void 			UnFilterFile(FileRegHandle hndFileReg);
#endif

// Removal functions
 	BOOL			RemoveFileFilter(const CString* pstrFilter);
#ifndef REFCOUNT_WORK
	BOOL			RemoveFile(const CPath* pPath);
#endif

// Reference counting functions
#ifdef _BLD_REG_HISTORY
	void			AddRegRefI(FileRegHandle hndFileReg, TCHAR * szFile, int nLine);
	void			ReleaseRegRefI(FileRegHandle, TCHAR * szFile, int nLine);
#else
	void			AddRegRef(FileRegHandle hndFileReg);
	void			ReleaseRegRef(FileRegHandle hndFileReg);
#endif	

// Search functions
	FileRegHandle	LookupFile(const CPath* pPath); 
	FileRegHandle	LookupFile(LPCTSTR lpszFile);
	FileRegHandle	LookupFileFilter(const CString* pstrFilter);

// Map a FileRegHandle to a CFileRegEntry pointer
	__inline CFileRegEntry *	GetRegEntry(FileRegHandle hndFileReg) { return hndFileReg; }

// Notification support function
	virtual void	OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint);

#ifdef REFCOUNT_WORK
	virtual BOOL	AddRegHandle(FileRegHandle hndFileReg, BOOL bAddRef = TRUE, BOOL bFront = FALSE){ ASSERT(FALSE); return FALSE; }
	virtual BOOL	RemoveRegHandle(FileRegHandle hndFileReg, BOOL bReleaseRef = TRUE){ ASSERT(FALSE); return FALSE; }
#endif

#ifndef REFCOUNT_WORK
	void			AllowAccess(CFileRegistry* pfreg);
	BOOL			DisallowAccess(CFileRegistry* pfreg);
#endif

// Property Access functions
	void			RemoveFromProject(CProjItem * pItem, BOOL fRemoveContained = TRUE);
	void			RestoreToProject(CProjItem * pItem, BOOL fRestoreContained = TRUE);
#if 0
	//
	// Note(tomse): This functionality is now provide by CProject.
	//
	BOOL			IsProjectFile(FileRegHandle hndFileReg)	{return hndFileReg->IsProjectFile();}
#endif

// Deleting file function
 	BOOL			DeleteFile(FileRegHandle hndFileReg);


 	BOOL			GetFileItemList(const CTargetItem *pTargetFilter, const CPtrList* pFileList, CObList& pFileItemList, BOOL fOnlyBuildable = TRUE, const ConfigurationRecord* pcr = NULL);
	UINT			GetFileCount(const CTargetItem * pTargetFilter, const CPtrList * pFileList, BOOL fOnlyBuildable = TRUE, const ConfigurationRecord * pcr = NULL);
  	BOOL			GetFileList(const CPath* pPath, const CPtrList*& pFileList);

	__inline const CPtrList *	GetODLFileList() const 	{ return (const CPtrList*) &m_filelistODL; }
 	__inline const CPtrList *	GetRCFileList() const { return (const CPtrList*) &m_filelistRC; }
	__inline const CPtrList *	GetDEFFileList() const { return (const CPtrList*) &m_filelistDEF; }

// Critical section to ensure sequential access to the file maps
// between the main build sys. thread and the file change thread
#ifndef REFCOUNT_WORK
	static CTestableSection		g_sectionFileMap;
#endif

private:
// Maps to go quickly from a string to a FileRegHandle
#ifdef REGISTRY_FILEMAP
	CMapStringToPtr	m_FileMap;
#endif
	CMapStringToPtr	m_FilterMap;

// Internal File filter support functions
	void 			GetBasicFilters(const CString* pstrFilter, CStringList& strList);
	FileRegHandle	FindBasicFilter(const CString* pstrBasicFilter);

#ifdef REGISTRY_FILEMAP
// Other associated file registrys that we look in when searching
	CPtrList			m_LocalFileRegs;
#endif

//	Our 'remembered' files that we are particularly interested in during
//	project processing, eg. the resource files when we generate resource
//	compiler command-lines
	CPtrList m_filelistRC;
	CPtrList m_filelistDEF;
	CPtrList m_filelistODL;

	BOOL m_fCareAboutRCFiles;
	BOOL m_fCareAboutDefFiles;

#ifdef _BLD_REG_HISTORY
	// A map from frh pointers to pointers to CPtrLists containing the
	// reference counting history of that frh object.
	CMapPtrToPtr	m_mapFRHHistory;
#endif

public:
	// olympus 16 (briancr)
	// Provide mechanism for clearing file registry. Theoretically, this
	// shouldn't be needed, since each FRH is deleted when its ref count
	// gets to zero.
#ifndef REFCOUNT_WORK
	void DeleteAll(void);
#endif

public:
// Diagnostics
#ifdef _DEBUG
	virtual void	Dump(CDumpContext& dc) const;
	virtual void AssertValid() const;
#ifndef REFCOUNT_WORK
	BOOL IsLocalRegistryOf( CFileRegistry* pParent) const;
#endif
private:
	BOOL m_bAssertValidCalled;
#endif
 	
	DECLARE_DYNAMIC(CFileRegistry)

#ifdef REFCOUNT_WORK
private:
	BOOL AddRegistryHandle(FileRegHandle hndFileReg);
	BOOL RemoveRegistryHandle(FileRegHandle hndFileReg);
#endif
};

//This is used for queuing up the update dep lists
class BLD_IFACE CDepUpdateRec : public CObject
{
public:
	CFileItem * m_pFileItem;  //file item
	CPtrList * m_pdepList;    //changed dep list
	FileRegHandle m_frh;     //to cache changed rc file
	UINT m_hTarg;         // from parser
	CDepUpdateRec()
	{
		m_pdepList = NULL;
		m_pFileItem = NULL;
		m_hTarg = NULL;
	}
	~CDepUpdateRec()
	{
		if (m_pdepList)
			delete m_pdepList;
	}
};

void FileItemDepUpdateQ(CFileItem *pItem, CPtrList * depList, FileRegHandle frh, CObList &updateList, BOOL fRemove = FALSE, HBLDTARGET hTarg = NO_TARGET);
int FileItemDepUpdateDeQ();
void RemoveFromForceUpdateQueue(CDepUpdateRec *pdepRec);
void UpdateBeforeWriteOutMakeFile();
void RemoveItemsFromUpdateQueue(UINT hTarget);
void FileItemDepUpdateDeQAll();
BLD_IFACE void RemoveFileItemFromUpdateQ(CFileItem *pFileItem);
extern BLD_IFACE CObList g_FileDepUpdateListQ;
extern BLD_IFACE CObList g_FileForceUpdateListQ;

/////////////////////////////////////////////////////////////////////////////
//	The File global file registry. All files are registered in here. 

extern BLD_IFACE CFileRegistry	g_FileRegistry;


void BLD_IFACE ClearMQSCache();

void BLD_IFACE MakeQuotedString
( 
	CFileRegSet * pregset,
	CString & strOut,
	const CDir * pBaseDir = NULL, 
	BOOL bQuote = TRUE,
	BOOL (*pfn) (DWORD, FileRegHandle) = NULL,
	DWORD dwFuncCookie = NULL,
	const TCHAR * pSeperator = NULL,
	BOOL bOneOnly = FALSE,
	const CObList *plItems = NULL,	// if single item, then used for *all* handles
	BOOL bSort = FALSE
);

//
// Overload MakeQuotedString that takes a CFRFPtrArray * instead of
// a CFileRegSet *
//
void BLD_IFACE MakeQuotedString
( 
	CFRFPtrArray * pregarray,
	CString & strOut,
	const CDir * pBaseDir = NULL, 
	BOOL bQuote = TRUE,
	BOOL (*pfn) (DWORD, FileRegHandle) = NULL,
	DWORD dwFuncCookie = NULL,
	const TCHAR * pSeperator = NULL,
	BOOL bOneOnly = FALSE,
	const CObList *plItems = NULL,	// if single item, then used for *all* handles
	BOOL bSort = FALSE
);


//
// Global comparision operators for FILETIME
//
__inline BOOL operator == (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (0 == CompareFileTimes(ft1,ft2));
}
__inline BOOL operator < (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (-1 == CompareFileTimes(ft1,ft2));
}
__inline BOOL operator > (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (1 == CompareFileTimes(ft1,ft2));
}
__inline BOOL operator <= (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (1 != CompareFileTimes(ft1,ft2));
}
__inline BOOL operator >= (const struct _FILETIME& ft1, const struct _FILETIME& ft2)
{
	return (-1 != CompareFileTimes(ft1,ft2));
}

#ifdef _DO_DEBUG_NEW
#define new DEBUG_NEW
#endif

#endif // __PFILEREG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\prjconfg.h ===
//
// CProjComponentMgr, CProjType
//
// Project component management, ie. target types, tools and option tables
//
// [matthewt]
//

#ifndef _INCLUDE_PRJCONFG_H
#define _INCLUDE_PRJCONFG_H

#include "projprop.h"			// MFC usage ids
#include "dlgbase.h"
#include "oletool.h"

#include <bldapi.h>
#include <bldguid.h>

//
// Resource ID ranges for each of the tool packages.
//
// In the absence of a resource loading mechanism that understands the
// context (package) that is to be loaded we need to have unique resource ids
// for those resources belonging to each package. Build add_ons therefore
// have been allocated the following ranges. Additional add_ons should add a new
// range here,
//
// BASE - 0x3000 (12288), UPPER - 0x3fff (16383)
//
// Intelx86	0x3000
// Mac68k	0x3200
// Mips		0x3400
// Alpha	0x3600
// PowerMac	0x3800
// FORTRAN	0x3A00
// PowerPC	0x3B00

// declare our types used up-front
class CPlatform;			// platform (defined in 'prjconfg.h')
class CProjType;			// project type (defined in 'prjconfg.h')
class CProjItem;			// project item (defined in 'projitem.h')
class CBuildTool;			// build tool (defined in 'projtool.h')
class CProjTypeInterface;	// com interface on CProjType.
/*
R.I.P. for v4.0 with VBA?
class CCustomTool;			// custom build tool (defined in 'projtool.h')
*/
class CProject;				// project (defined in 'project.h')
class COptionHandler;		// tool option handler (defined in 'prjoptn.h')
class CBuilderConverter;	// builder (.mak) converter (defoned in 'prjconfg.h')

// Helper function -- probably belongs in some new module PROJUTIL.CPP / PROJUTIL.H.
void GetNewOutputDirName(CProject * pProject, const CString & strNewConfig, CString & strResult);

// declare the global tool option engine (parsing & generation)
class COptionTable;
extern BLD_IFACE COptionTable g_prjoptengine;

// functions to munge/extract the project mode from the configuration
void DefaultConfig(CProject * pProject, const CString & strPlatformName, UINT nIDMode, CString & strConfig);

// build system component registration

// component types
#define BLC_ERROR		0x0000
#define BLC_Platform	0x0001
#define BLC_Tool		0x0002
#define BLC_Scanner		0x0003
#define BLC_OptionHdlr	0x0004
#define BLC_TargetType	0x0005
#define BLC_BldrCnvtr	0x0006
#define BLC_CustomTool	0x0007
#define BLC_OleAddOn	0x0008

#define BLC_Start		BLC_Platform
#define BLC_End			BLC_OleAddOn

// mode of our tool options
#define MOB_Debug		0x1			// debug
#define MOB_Release		0x2			// release

// our CBldSysCmp class ... the base-class for all component manager objects
//
// provides:
// o storing/retrieving of component properties to the system registry 'Visual C++\Build System' key.
// (use REGISTRY_MAPS)

typedef struct
{
	enum {MapBegin, MapEnd, MapData, MapFData} regType;	// type of this registry entry
	UINT  nRegId;	// string resource ID for registry field
	UINT  nRegSubKeyId;	// string resource ID for sub-key
	const TCHAR *szRegField;	// string resource ID for registry field
	const TCHAR *szRegSubKey;	// string resource ID for sub-key
	DWORD dwType;			// type of data, eg. REG_SZ, REG_BINARY etc.
	const void * pvData;	// points to the data
	DWORD cbData;			// size of this data
} CRegistryMap;

// other registry entry type #defines for use by REGISTRY_ENTRY()
#define REG_STRING	(DWORD)(REG_NONE - REG_SZ)	// our own registry type for CStrings
#define REG_BOOL	(DWORD)REG_DWORD

#define NO_SUB_KEY NULL

#define DECLARE_REGISTRY_MAP() \
	static CRegistryMap m_registryMap[]; \
	virtual const CRegistryMap * GetRegistryMap() const {return &m_registryMap[0];}

#define BEGIN_REGISTRY_MAP(theClass, parentClass) \
	CRegistryMap theClass::m_registryMap[] = {\
	{CRegistryMap::MapBegin, 0, 0, NULL, NULL, NULL /* no type */, &parentClass::m_registryMap[0], 0},

#define BEGIN_REGISTRY_MAP_P(theClass) \
	CRegistryMap theClass::m_registryMap[] = {\
	{CRegistryMap::MapBegin, 0, 0, NULL, NULL, NULL /* no type */, NULL /* no base */, 0},

#define REGISTRY_DATA_ENTRY(regid, subkey, regstr, substr, t, var) \
	{CRegistryMap::MapData, regid, subkey, regstr, substr, t, &((theClass*)0)->var, sizeof(((theClass*)0)->var)},

#define REGISTRY_FAKE_DATA_ENTRY(regid, subkey, regstr, substr, t) \
	{CRegistryMap::MapFData, regid, subkey, regstr, substr, t, NULL, 0},

#define END_REGISTRY_MAP() \
	{CRegistryMap::MapEnd, 0, 0, NULL /* no type */, NULL}};

// helpers
LONG RegGetKey(HKEY, LPCTSTR, PHKEY, BOOL fCreate = TRUE);

// declare the global configuration manager
class CProjComponentMgr;
class BLD_IFACE CBldSysCmp : public CSlob
{
	friend class CProjComponentMgr;

	DECLARE_DYNCREATE(CBldSysCmp)
	DECLARE_SLOBPROP_MAP()
	DECLARE_REGISTRY_MAP()

public:
	CBldSysCmp();

	// get/set the component's and related component's id
	__inline DWORD CompId() {return m_dwId;}
	__inline DWORD RelatedCompId() {return m_dwRelatedId;}

	void SetId(DWORD dwId);
	void SetRelatedId(DWORD dwRelatedId);

	// cloning
	virtual CSlob * Clone();

	// storing and retrieving of component properties to system registry
	//
	// this will ensure that the component info. is in the registry,
	// any changes in the information in the registry will be copyed to
	// the component
	virtual BOOL SynchronizeWithRegistry(BOOL fSaveBeforeLoad = TRUE);

	// serialize component to character buffer (zero-term. EOL)
	virtual BOOL Serialize(TCHAR * pch, UINT & cch);

	// deserialize component from character buffer (zero-term. EOL)
	virtual BOOL Deserialize(TCHAR * pch, UINT cch);

	virtual BOOL RegDataExists(const CRegistryMap *, HKEY, CString *, LPDWORD, LPDWORD);
 	virtual BOOL LoadRegData(const CRegistryMap *, HKEY, CString *, LPBYTE, DWORD);
 	virtual BOOL SaveRegData(const CRegistryMap *, HKEY, CString *, LPBYTE, DWORD);

	// returns TRUE if this is a fully supported component,
	// FALSE if it is a fake one for compatibility (ie. unknown tools etc.)
	virtual BOOL IsSupported() const { return TRUE; }

	// helpers
	BOOL RegGetDataKey(const CRegistryMap *, PHKEY, BOOL fCreate = TRUE);

	BOOL LoadRegData(UINT nRegId);
	BOOL SaveRegData(UINT nRegId);

	// get our regular and 'UI' component name
	__inline const CString * GetName() const {return &m_strCompName;}
	__inline const CString * GetUIName() const {return &m_strUICompName;}

	// get component system registry 'parent' key
	__inline const CString * GetRegKeyName() const {return &g_strRegKey;}

	// get component system registry key
	const TCHAR * GetCompRegKeyName(BOOL fInclAppKey = TRUE);

	// map types (n.b. 32 is a hack, just a number greater than REG_* in winnt.h)
	__inline DWORD MapRegType(DWORD dwType) {return dwType < 32 ? dwType : (DWORD)REG_NONE - dwType;}

	// name of this comp.
	CString m_strCompName;

	// UI name of this comp.
	CString m_strUICompName;

	// restore out component's data from the registry
	// this is FALSE by default unless the "Version"
	// value shows a valid component
	BOOL m_fRegRestore;

protected:
	// retrieve the registry map entry for the entry with the id, 'nRegId'
	const CRegistryMap * GetRegMapEntry(UINT nRegId);

	// registry keys
	static const CString g_strRegKey;

	CString m_strCompRegKey;
	CString m_strFullCompRegKey;
	BOOL m_fCompRegKeyDirty;

	// id of this bld system component
	DWORD m_dwId;

	// id of the related bld system component
	DWORD m_dwRelatedId;
};

// our CProjComponentMgr class ... the  global project component manager

// generate a component id based on the package and component id (latter is unique to package only)
#define GenerateComponentId(idPackage, idComponent) ((idPackage << 16) | (idComponent & 0xffff))
#define PackageIdFromBscId(bsc_id) (bsc_id >> 16)
#define PkgCmpIdFromBscId(bsc_id) (bsc_id & 0xffff)

class BLD_IFACE CProjComponentMgr : public CObject
{
public:
	// create project component manager
	CProjComponentMgr();
	~CProjComponentMgr();

	// initialise (ask packages to register their components)
	BOOL FInit();
	void IsInit(BOOL b){m_fInit=b;};
	BOOL IsInit(){return m_fInit;};
	BOOL m_fInit;

	// terminate
	void Term();

	// build system component registration

	// generate package id using the package name
	WORD GenerateBldSysCompPackageId(const TCHAR * szPackageName);

	// package register component
	// pls. note that if no bsc_id passed in it is assumed the component
	// has pre-set it's id.
	BOOL RegisterBldSysComp(CBldSysCmp * pcomp, DWORD bsc_id = (DWORD)-1);

	// lookup a component
	__inline BOOL LookupBldSysComp(DWORD bsc_id, CBldSysCmp *& pcomp)
		{return m_mapBldSysCmps.Lookup((void *)bsc_id, (void *&)pcomp);}

	// get a component type, returns 'BLC_ERROR' if not found
	DWORD BldSysCompType(DWORD bsc_id);
 	DWORD BldSysCompType(CBldSysCmp * pcomp);

	// utility functions
	BOOL GetProjTypefromProjItem(CProjItem * pprojitem, CProjType * & pprojtype);

	//
	// our platform management
	//
	void RegisterPlatform(CPlatform *);
	BOOL DeregisterPlatform(CPlatform *);

	int GetPlatformCount() { return m_lstPlatforms.GetCount(); }
	int GetSupportedPlatformCount();

	const CPtrList *GetPlatforms() { return &m_lstPlatforms; }
	void InitPlatformEnum() { m_posPlatform = m_lstPlatforms.GetHeadPosition(); }
	BOOL NextPlatform(CPlatform * & pPlatform)
	{
		if (m_posPlatform == (POSITION)NULL)
			return FALSE;
		pPlatform = (CPlatform *)m_lstPlatforms.GetNext(m_posPlatform);
		return TRUE;
	}

	// duplicate functions to allow nested enumerations to happen (through interfaces)
	void InitPlatformEnumExport() { m_posPlatExp = m_lstPlatforms.GetHeadPosition(); }
	BOOL NextPlatformExport(CPlatform * & pPlatform)
	{
		if (m_posPlatExp == (POSITION)NULL)
			return FALSE;
		pPlatform = (CPlatform *)m_lstPlatforms.GetNext(m_posPlatExp);
		return TRUE;
	}

	BOOL LookupPlatformByOfficialName(const TCHAR * szOfficialName, CPlatform * & pPlatform);
	BOOL LookupPlatformByUIDescription(const TCHAR * szDescription, CPlatform * & pPlatform);
	BOOL LookupPlatformByUniqueId(UINT nUniqueId, CPlatform * & pPlatform);
	CPlatform * GetPrimaryPlatform(BOOL bAllowNonPrimary = TRUE);
	UINT GetIdFromMachineImage(WORD wMachineImage);

	//
	// our project type management
	//
	void RegisterProjType(CProjType * pprojtype);
	BOOL DeregisterProjType(CProjType * pprojtype);

	__inline BOOL LookupProjTypeByName( const TCHAR * pszName, CProjType * & pprojtype)
		{return m_mapProjTypes.Lookup((const TCHAR *) pszName, (void *&)pprojtype);}
	BOOL LookupProjTypeByUIDescription( const TCHAR * pszUIDesc, CProjType * & pprojtype);

	BOOL LookupProjTypeByUniqueId( UINT nUniqueId, CProjType * & pprojtype);
	__inline void InitProjTypeEnum() {m_posProjType = m_lstProjTypes.GetHeadPosition();}
	__inline BOOL NextProjType(CProjType * & pprojtype)
	{
		if (m_posProjType == (POSITION) NULL)	return FALSE;
		pprojtype = (CProjType *)m_lstProjTypes.GetNext(m_posProjType);
		return TRUE;
	}

	const CPtrList *GetProjTypes() { return &m_lstProjTypes; }

	CObList * GetMatchingProjTypes(const _TCHAR * pszPlatform, const _TCHAR * pszType, BOOL bUiDescription = FALSE);
	const CStringList * GetListOfProjTypes(const _TCHAR * pszPlatform = NULL, const _TCHAR * pszType = NULL, BOOL bUiDescription = FALSE);
	const CStringList * GetListOfPlatforms(const _TCHAR * pszType = NULL, BOOL bUIDescription = FALSE);
	const CStringList * GetListOfTypes(const _TCHAR * pszPlatform = NULL, BOOL bUiDescription = FALSE);

	//
	// our build tool management
	//
	__inline UINT GetBuildToolCount() {return m_lstTools.GetCount();}
	const CPtrList *GetTools() { return &m_lstTools; }
	__inline void InitBuildToolEnum() {m_posTool = m_lstTools.GetHeadPosition();}
	__inline BOOL NextBuildTool(CBuildTool * & ptool)
	{
		if (m_posTool == (POSITION) NULL)	return FALSE;
		ptool = (CBuildTool *)m_lstTools.GetNext(m_posTool);
		return TRUE;
	}

	void RegisterBuildTool(CBuildTool * ptool);
	__inline BOOL DeregisterBuildTool(CBuildTool * ptool)
		{return DeregisterComponent(m_lstTools, (CObject *)ptool);}

/*
R.I.P. for v4.0 with VBA?
	//
	// our global custom component management
	// (note *not* per-platform)
	//

	// custom tools
	static BOOL SerializeProjectCustomTool(CBldrSection * pbldsect, UINT op);
	BOOL RetrieveGlobalCustomTool();
	BOOL StoreGlobalCustomTool();

	__inline CPtrList * GetCustomToolList() {return &m_lstCustTools;}
	__inline void InitCustomToolEnum() {m_posCustTool = m_lstCustTools.GetHeadPosition();}
	__inline BOOL NextCustomTool(CCustomTool * & ptool)
	{
		if (m_posCustTool == (POSITION) NULL)	return FALSE;
		ptool = (CCustomTool *)m_lstCustTools.GetNext(m_posCustTool);
		return TRUE;
	}

	BOOL RegisterCustomTool(CCustomTool * ptool);
	__inline BOOL DeregisterCustomTool(CCustomTool * ptool)
		{return DeregisterComponent(m_lstCustTools, (CObject *)ptool);}
*/

	// Find the tool whose prefix matches the pPrefix. nPrefixLen is the maximum
	// number of characters to match up to.  pprojitem can be used to retrieve
	// only the tools for the current configuration.
	CBuildTool * GetToolFromCodePrefix(CProjItem * pprojitem, const TCHAR *pPrefix, int nPrefixLen);

	//
	// our tool option management
	//
	__inline void InitOptHdlrEnum() {m_posOptHdlr = m_lstOptionHandlers.GetHeadPosition();}
	__inline BOOL NextOptHdlr(COptionHandler * & popthdlr)
	{
		if (m_posOptHdlr == (POSITION) NULL)	return FALSE;
		popthdlr = (COptionHandler *)m_lstOptionHandlers.GetNext(m_posOptHdlr);
		return TRUE;
	}

	void RegisterOptionHandler(COptionHandler * popthdlr);
	BOOL DeregisterOptionHandler(COptionHandler * popthdlr);

	// given a property return the option handler
	// (cached for props belonging to same opt. hdlr)
	UINT m_nPropFirst, m_nPropLast;
	COptionHandler * m_popthdlrCache;
	COptionHandler * FindOptionHandler(UINT idProp);

	// given a property bag we'll set the defaults for the project mode
	// based on the original target type of the property bag
	__inline BOOL SetDefaultDebugToolOptions(CProject * pProject)
		{return SetDefaultToolOptions(MOB_Debug, pProject);}

	__inline BOOL SetDefaultReleaseToolOptions(CProject * pProject)
		{return SetDefaultToolOptions(MOB_Release, pProject);}

	//
	// our builder converter management
	//
	__inline void InitBuilderConverterEnum() { m_posBldrCnvtr = m_lstBldrCnvtrs.GetHeadPosition(); }
	__inline BOOL NextBuilderConverter(CBuilderConverter * & pBldrCnvtr)
	{
		if (m_posBldrCnvtr == (POSITION)NULL)
			return FALSE;
		pBldrCnvtr = (CBuilderConverter *)m_lstBldrCnvtrs.GetNext(m_posBldrCnvtr);
		return TRUE;
	}

	void RegisterBuilderConverter(CBuilderConverter * pBldrCnvtr);
	BOOL DeregisterBuilderConverter(CBuilderConverter * pBldrCnvtr);

	//
	// our unknown project object management
	// ie. unknown option handlers, target types, platforms, tools
	//
	// on destruction of the proj. component manager these will be
	// destroyed as well -> ie. use this to remember objects to clean-up
	// at project facility shutdown time
	__inline void RegisterUnkProjObj(CObject * punkobj)
		{ASSERT_VALID(punkobj); m_lstUnkProjObjs.AddTail(punkobj);}
	__inline BOOL DeregisterUnkProjObj(CObject * punkobj)
		{return DeregisterComponent(m_lstUnkProjObjs, punkobj);}

	// information components might use, such as is MFC or ODBC installed?
	__inline BOOL MFCIsInstalled() {return m_fMFCInstalled;}
	__inline BOOL ODBCIsInstalled() {return m_fODBCInstalled;}

protected:
	BOOL SetDefaultToolOptions(DWORD mode, CProject * pProject);

private:
	// generic component removal
	BOOL DeregisterComponent(CPtrList & plst, CObject * ptr);

	// component registration
	CStringArray	m_rgstrAddOns;
	CMapPtrToPtr	m_mapBldSysCmps;
	DWORD			m_dwRegisterId;		// current related id. when asking add-ons to register comps.
	DWORD			m_dwCustomBase;		// base of our custom components

	// CPlatform registry
	CMapStringToPtr	m_mapPlatforms;		// for quick-lookup -- HASHed on "official name"
	CPtrList		m_lstPlatforms;		// ordered list
	POSITION		m_posPlatform;		// current pos for InitPlatformEnum() / NextPlatform()
	POSITION		m_posPlatExp;		// current pos for InitPlatformEnumExport() / NextPlatformExport()

	// CProjType registry (public)
	CMapStringToPtr	m_mapProjTypes;		// for quick-lookup -- HASH order!
	CPtrList		m_lstProjTypes;		// ordered list
	POSITION		m_posProjType;		// current pos for InitProjTypeEnum() / NextProjType()
	CObList			m_tmplstProjTypes;
	CStringList		m_tmpNameList;
	CStringList		m_tmpUIDescList;

	// CBuildTool registry (public)
	POSITION		m_posTool, m_posCustTool;
	CPtrList		m_lstTools, m_lstCustTools;
	UINT			m_cSchmoozeTools;

	// COptionHandler registry (private)
	CPtrList		m_lstOptionHandlers;
	UINT			m_idOptPropBase;
	POSITION		m_posOptHdlr;

	// CBuilderConverter registry (private)
	CPtrList		m_lstBldrCnvtrs;
	POSITION		m_posBldrCnvtr;

	// unknown object registry
	CPtrList		m_lstUnkProjObjs;

	// information components might use
	BOOL			m_fODBCInstalled;	// ODBC Installed?
	BOOL			m_fMFCInstalled;	// MFC Installed?

	CBldrSection		m_bldsection;		// our custom tool builder file section

	// flags used during component registration
	BOOL			m_fRegPrimaryPlatform;

	CPtrList		m_AddOns;
public:
	void RegisterOlePlatform( IPlatform *plat, DWORD bscid );
	void RegisterOleTool( IBuildTool *tool, DWORD bscid );
	void RegisterOleProjType( IProjectType *proj, DWORD bscid );
	void RegisterOleAddOn( LPBUILDSYSTEMADDON pAddOn, DWORD bsc_id );
};

#ifdef _BLD_INTERNAL
extern CProjComponentMgr g_prjcompmgr;
#endif

#include "proppage.h"	// CEnumerator for property pages

// This class enumerates the configurations for the benefit of the prop page.
class CConfigEnum : public CEnum
{
private:
	CEnumerator *	m_prevListReturned;
	// Keep track of the previous list returned, if any,
	// so we can free it next time we're asked for the list.

public:
	CConfigEnum() { m_prevListReturned = NULL; }
	~CConfigEnum()  { delete [] m_prevListReturned; }

	virtual	CEnumerator *	GetList();
	// Return a pointer to an array of CEnumerators.
};

// This class enumerates the configurations for the benefit of the prop page.
class CProjectEnum : public CEnum
{
private:
	CEnumerator *	m_prevListReturned;
	CString *		m_prevStrListReturned;
	// Keep track of the previous list returned, if any,
	// so we can free it next time we're asked for the list.

public:
	CProjectEnum() { 
		m_prevListReturned = NULL; 
		m_prevStrListReturned = NULL; 
	}
	~CProjectEnum()  { 
		delete [] m_prevListReturned; 
		delete [] m_prevStrListReturned; 
	}

	virtual	CEnumerator *	GetList();
	// Return a pointer to an array of CEnumerators.
};


class CProjConfigEnum : public CEnum
{
private:
	CEnumerator *	m_prevListReturned;
	CString *		m_prevStrListReturned;
	// Keep track of the previous list returned, if any,
	// so we can free it next time we're asked for the list.

public:
	CProjConfigEnum() { 
		m_prevListReturned = NULL; 
		m_prevStrListReturned = NULL; 
	}
	~CProjConfigEnum()  { 
		delete [] m_prevListReturned; 
		delete [] m_prevStrListReturned; 
	}

	virtual	CEnumerator *	GetList();
	// Return a pointer to an array of CEnumerators.
};

// This class enumerates the platforms for the benefit of the prop page.
class CPlatformEnum : public CEnum
{
private:
	CEnumerator *	m_prevListReturned;
	// Keep track of the previous list returned, if any,
	// so we can free it next time we're asked for the list.

public:
	CPlatformEnum() { 
		m_prevListReturned = NULL; 
	}
	~CPlatformEnum() { 
		delete [] m_prevListReturned; 
	}

	virtual	CEnumerator *	GetList();
	// Return a pointer to an array of CEnumerators.
};

// The one and only instance of the CConfigEnum class.
extern CConfigEnum g_theConfigEnum;
extern CProjectEnum g_theProjectEnum;

 // The one and only instance of the CPlatformEnum class.
extern CPlatformEnum g_thePlatformEnum;

// The CPlatform class embodies a target platform -- an operating system and
// a CPU (e.g., Macintosh (680x0), Win32 (80x86), Win32 (MIPS, ALPHA), etc.
//
// All CPlatform instances in the system are static (i.e., exist even in the
// absence of a project) and register themselves with the CProjComponentMgr.
//
// The ToolInfo struct contains specific information needed for some of the tools
// supported by the platform.
// NOTE:
// It would have been nice if we can put this information in the appropriate
// OptionHandler. Unfortunately, for instance, RC name is defined in the
// Common Linker Option Handler but Mac and Intel have different default
// extensions. Until the OptionHandler supports inheritance, we have to
// settle w/ this ToolInfo struct soluntion.
//
// The PlatformInfo class is used to initialize (construct) a CPlatform object.
//
// Exactly one CPlatform object should be the "primary target platform" (set the
// bPrimaryPlatform field in the PlatformInfo struct to TRUE).  If, when checking
// the registry to find out which platforms are installed, we don't find ANY
// platforms, we will ensure that the "primary target platform" is installed
// anyway (and write information to the registry to indicate this).  Note that
// we will do this only if NO installed platforms are found, so the primary target
// platform is "automatically" installed only if no others are found.

// Bit fields for nFlags field of NMInfo struct.
//
//#define NFL_

// Bit fields for the Platform attributes.
// This is to hold information similar to PlatformInfo that would be
// wasteful to represent as a new method of CPlatform, ie. information
// of a similar type BOOL can be represented as a bit field value.

#define PIA_Primary_Platform	0x0001	// Is this the primary platform? ie. default platform
#define PIA_Supports_IncLink	0x0002	// Supports an incremental linker?
#define PIA_Allow_WorkingDir	0x0004	// Allow use of a working directory for 'Debug Options'
#define PIA_Enable_Language		0x0008  // Enable Language option for RC
#define PIA_Allow_MFCinDLL		0x0010	// Allow use of mfc in a dll
#define PIA_Supports_RemoteDbg	0x0020	// Supports remote debugging?
#define PIA_Allow_ODBC			0x0040	// Allow use of mfc ODBC
#define PIA_Allow_ProgArgs		0x0080	// Executable can use program arguments for Debug etc.
#define PIA_Enable_Stub			0x0100	// Allow dos stub
#define PIA_Enable_AllDebugType	0x0200	// Enable all debug options (otherwise enable only MS option
#define PIA_Supports_IncCplr	0x0400	// Supports an incremental compiler?
#define PIA_Supports_RTTI		0x0800	// C++ language implementation supports RTTI?
#define PIA_Supports_MinBuild	0x1000	// Support minimum build compiler
#define PIA_Supports_ENC		0x2000	// Support edit & continue

struct TLInfo						// Transport layer information
{
	TCHAR *		szName;				// Name of DLL (e.g., "TLN0LOC.DLL")
	UINT		nIDDesc;			// String ID of description of DLL
	UINT		nFlags;				// Flags describing transport layer (TFL_... above)
};

struct NMInfo
{
	TCHAR *		szName;				// Name of DLL
	UINT		nFlags;				// Flags describing NM (NFL_... above)
};

struct ToolInfo
{
	CString		strRCExtension;		// RC extension for specific platform (ie: .res or .rsc)
 	CString		strPath;
	CString		strIncludePath;
	CString		strLibPath;
	CString		strSourcePath;
};

struct PlatformInfo
{
	TCHAR *		szName;				// "Official" name of platform
	UINT		nUniqueId;			// Platform identifier (uniq_platform)
	UINT		nIDUIDesc;			// String ID of UI description of platform
	UINT		nIDUIShortDesc;		// String ID of abbreviated UI description
	TCHAR *		szEMName;			// Name of EM DLL
	TCHAR *		szSHName;			// Name of SH DLL
	TCHAR *		szEEName;			// Name of EE DLL
	UINT		nCountTLs;			// Number of TLs
	TLInfo *	rgTLInfo;			// Array of TLInfo structs (nCountTLs in number)
	UINT		nCountNMs;			// Number of NMs
	NMInfo *    rgNMInfo;			// Array of NMInfo structs (nCountNMs in number)
	TCHAR *		szRCExtension;		// RC extension for specific platform (ie: .res or .rsc)

 	TCHAR *		szPath;
	TCHAR *		szIncludePath;
	TCHAR *		szLibPath;
	TCHAR *		szSourcePath;

	DWORD		dwPlatformAttrib;	// The boolean attributes
	UINT		nUseMFCDefault;		// Default use of MFC
	TCHAR *		szOutDirPrefix;		// Default directory prefix
									// (if == NULL then first three chars of UI desc. used)
};


class BLD_IFACE CPlatform : public CBldSysCmp
{
	DECLARE_DYNCREATE(CPlatform)
 	DECLARE_REGISTRY_MAP()

private:
	BOOL			m_bSupported;		// is this platform actually supported?

	UINT			m_nUniqueId;		// Unique identifier from uniq_platform (0-255)
	UINT			m_nIDUIDesc;		// String ID of UI description string
	UINT			m_nIDUIShortDesc;	// String ID of abbreviated UI description
										// string (for loading later)
	UINT *			m_rgIDTLDescs;		// Array of string IDs describing transport layers
	UINT			m_nCurrentTL;		// Current transport layer (index into arrays)

	CString			m_strUIShortDesc;	// Abbreviated description for UI purposes
	CString			m_strEMName;		// Name of EM DLL
	CString			m_strSHName;		// Name of SH DLL
	CString			m_strEEName;		// Name of EE DLL

	UINT			m_nCountTLs;		// Number of TLs
	CString *		m_rgStrTLNames;		// Array of names of TL DLLs
	UINT *			m_rgTLFlags;		// Array of flag values for transport layers
	CString *		m_rgStrTLDescs;		// Array of strings describing transport layers

	UINT			m_nCountNMs;		// Number of NMs
	CString *		m_rgStrNMNames;		// Array of names of NM DLLs
	UINT *			m_rgNMFlags;		// Array of flag values for NMs

	ToolInfo		m_rgToolInfo;		// Tool Info structure

	DWORD			m_dwAttributes;		// Boolean attributes
	UINT			m_nUseMFCDefault;	// Default use of MFC

	CString			m_strDefOutDirPrefix;	// Default output directory prefix
	BOOL			m_bBuildable;

public:
	CPlatform() {};
	CPlatform(PlatformInfo *);
	CPlatform(const _TCHAR * lpszName, UINT nUniqueId = unknown_platform); //
	virtual ~CPlatform();

	// from -> CBldSysCmp
	virtual BOOL RegDataExists(const CRegistryMap *, HKEY, CString *, LPDWORD, LPDWORD);
 	virtual BOOL LoadRegData(const CRegistryMap *, HKEY, CString *, LPBYTE, DWORD);
 	virtual BOOL SaveRegData(const CRegistryMap *, HKEY, CString *, LPBYTE, DWORD);
	virtual BOOL IsSupported() const { return m_bSupported; }
		// Returns TRUE if this is a fully supported platform,
		// FALSE if it is a fake one for compatibility
	// <- CBldSysCmp

	__inline BOOL IsPrimaryPlatform() const { return (m_dwAttributes & PIA_Primary_Platform) != 0; }
		// Returns TRUE if this is the "primary" platform (see notes above),
		// FALSE if not.

	__inline void Disable() { m_bSupported = FALSE; }
		// Hook that allows us to permanently disable (mark as unsupported)
		// a platform, as an alternative to deregistering it completely

	__inline void SetBuildable(BOOL bCan) { m_bBuildable = bCan; }
	BOOL GetBuildable() { return m_bBuildable; }
		// Some "supported" paltforms may not be licensed for use.

	__inline const ToolInfo * GetToolInfo() const { return &m_rgToolInfo; }
		// returns a pointer to Tool Information that is specific to
		// the platform

	__inline DWORD GetAttributes() const { return m_dwAttributes; }

	BOOL SupportsODBC() const;

	UINT GetUseMFCDefault();
		// returns the default use of MFC for this platform

	const CString * GetDefOutDirPrefix() const { return &m_strDefOutDirPrefix; }

		// P_ComponentName
		//
		// Returns the "official" name of the platform.  This name is
		// used when:
		//
		//		- writing to the .MAK file
		//		- writing to the registry
		//
		// It is very important that this "official" name NOT be localized;
		// otherwise, localized versions lose compatibility with other .MAK
		// files.  This "official" name should therefore NOT be placed in
		// the .RC file.
		//
		// The form of this name is:
		//
		// "<operating_system> (<cpu>)"
		//
		// For example, "Macintosh (680x0)", "Win32 (80x86)", etc.

	UINT GetUniqueId() const { return (m_nUniqueId & 255); }
		// Returns the unique identifier (0-255) of this platform (see the
		// uniq_platform enum).

	const CString * GetUIDescription() const { return (m_nIDUIDesc) ? &m_strUICompName : &m_strCompName; }
		// Returns the name of the platform as it is represented in the UI
		// (for example, in dialogs).  This string *SHOULD* be placed in
		// the .RC file so it can be localized.  Needless to say, you should
		// be careful not to use this string instead of the "official" string
		// (GetName()).

	const CString * GetUIShortDescription() const
		{ return &m_strUIShortDesc; }
		// Returns an abbreviated version of the string returned by GetUIDescription().
		// It is recommended (although not guaranteed) that this abbreviated description
		// be 5 characters or fewer, since it is used when generating target names
		// and output directory names.

	const TCHAR * GetEMName() const { ASSERT(m_bSupported); return m_strEMName; }
	const TCHAR * GetSHName() const { ASSERT(m_bSupported); return m_strSHName; }
	const TCHAR * GetEEName() const { ASSERT(m_bSupported); return m_strEEName; }
		// Return the name of the EM DLL, the SH DLL or the EE DLL, respectively.

	UINT GetTLCount() const { return m_nCountTLs; }
		// Return the number of transport layers supported by this platform.

	UINT GetTLFlags(int index) const { ASSERT(m_bSupported); return m_rgTLFlags[index]; }
		// Return the flags value (TFL_... bits) for the transport layer
		// specified by the index (0 <= index <= GetTLCount()-1).

	UINT GetCurrentTLIndex() const { return m_nCurrentTL; }
	void SetCurrentTLIndex(UINT index);
		// Get or set the "current transport layer"
		// (where 0 <= index <= GetTLCount() - 1).

	UINT GetLocalTLIndex() const;
		// Returns the index of the local TL for this platform if
		// one exists, if there is no local TL then it returns -1.

	const TCHAR * GetTLName(int index) const { ASSERT(m_bSupported); return m_rgStrTLNames[index]; }
		// Get the name of the specified transport layer's DLL.

	const UINT GetTLIndex(const TCHAR * pTLName, UINT nDefault);
		// Get the index of a TL given its name, if the name does
		// not match any known TL name then return nDefault

	const TCHAR * GetTLDescription(int index) const { ASSERT(m_bSupported); return m_rgStrTLDescs[index]; }
		// Return the description of the specified transport layer.

	UINT GetNMCount() const { return m_nCountNMs; }
		// Return the number of NMs supported by this platform.

	const TCHAR * GetNMName(int index) const { ASSERT(m_bSupported); return m_rgStrNMNames[index]; }

		// Return the name of the specified NM's DLL.

	UINT GetNMFlags(int index) const { ASSERT(m_bSupported); return m_rgNMFlags[index]; }
		// Return the flag values (NFL_... bits) for the specified NM

	BOOL FInit();
		// Initialize this object -- specifically, load strings (which we
		// can't do at construction time since we don't have an instance
		// handle at that time).
};

class BLD_IFACE COLEPlatform : public CPlatform
{
public:
	COLEPlatform( LPPLATFORM  ):CPlatform(){};
};

// Our CProjType class ... contains information specific to a particular type of project,
// ie. project name, type of 'target generating' tool, tool option defaults etc.
class BLD_IFACE CProjType : public CBldSysCmp
{
	DECLARE_DYNCREATE(CProjType)

public:
	CProjType() { m_pIProjType = NULL; };
	CProjType(const TCHAR * szPkg, WORD id,
			  UINT nIDType, UINT nUniqTypeId,
			  const TCHAR * szPkgPlatform, WORD idPlatform);
	CProjType(const TCHAR * szPkg, WORD id,
			  UINT nIDType, UINT nUniqTypeId,
			  DWORD bsc_id);
	CProjType(const _TCHAR * lpszType, UINT nUniqTypeId, CPlatform * pPlatform);
	virtual ~CProjType();

	// Warning: these enums are defined in order to maintain projtype
	// compatibility between different drops and versions of the product
	// While you can change the names of these enums, the implementations
	// (could be #defines), or even projtype names, you must not change
	// the order or value of these values and their meaning.
	// Also, how they are packed into an int (type in low byte, platform
	// in 2nd byte), cannot be changed without breaking makefile compatibility.
	// new types can be added at the end, or you can use the unknown type.

	enum uniq_type
	{
		unknown_projtype = 0,
		application = 1,
		dynamiclib = 2,
		consoleapp = 3,
		staticlib = 4,
		sharedlib = 5,
		exttarget = 6,
		quickwin = 7,
		standardgraphics = 8,
		javaapplet = 9,
		generic = 10,
	 };

private:
	static const _TCHAR * TypeNameFromId[11];
public:

	// CBldSysComp related methods
	// ***************************

	// initialise
	virtual BOOL 	FInit();
	virtual int 	GetAttributes () { ASSERT(FALSE); return 0; }

	// Platform x ProjType Methods
	// ***************************

	static 	CString 		MakeNameFromPlatformAndType(const CString & platform, const CString & type);
	static 	CString 		MakeNameFromPlatformAndType(const _TCHAR * platform, const _TCHAR * type);

	// note that this is essentially GetPlatformUIDescription() + ' ' + GetTypeUIDescription()
	const CString * GetUIDescription() const { return &m_strUICompName; }
	UINT 			GetUniqueId() const { return GetUniqueTypeId() | (GetUniquePlatformId() << 8); }


	// Platform Related Methods
	// ************************

	virtual CPlatform * 	GetPlatform() const { return m_pPlatform; }
	virtual BOOL 				IsSupported() const { return m_pPlatform->IsSupported(); }

	const CString *		GetPlatformName() const { return m_pPlatform->GetName(); }
	const CString * 	GetPlatformUIDescription() const { return m_pPlatform->GetUIDescription(); }
	UINT 				GetUniquePlatformId() const { return (m_pPlatform->GetUniqueId()); }

	// Unique Type Related Methods
	// ***************************

 	// return the name of the type of target for this target type, eg. 'Application'
	virtual const CString * GetTypeName() { return &m_strType; }

	const CString * GetTypeUIDescription() const { return &m_strUIType; }
	UINT 			GetUniqueTypeId() const { return (m_nUniqueTypeId & 255); }

	// Tools List Related Methods
	// **************************

	// create the list of tools we use
	virtual void 		CreateToolsList() {/* default target type uses no tools*/}
	virtual CPtrList * 	GetToolsList() { return &m_ToolsList; }
	virtual CBuildTool *PickTool(FileRegHandle frh);

	void 		ClearUnknownTools();
	// Find the tool whose prefix matches the pPrefix. nPrefixLen is the maximum number
	// of characters to match up to.
	// pprojitem is used to retrieve the tools for the current configuration.
	CBuildTool * GetToolFromCodePrefix(const TCHAR *pPrefix, int nPrefixLen);
	// add a tool into our list of tool's
	void 		AddTool(const TCHAR * szPckg, WORD idTool);
	void 		AddTool(WORD pckg, WORD idTool);
	void 		AddTool(CBuildTool * pTool);

	// Settings Related Methods
	// ************************

	// default tool options for the target type
	virtual BOOL 	GetDefaultToolOptions(DWORD /*bsc_id*/, const CString & /*strMode*/, CString & /*strOption*/)
						{return FALSE;}	// FUTURE: ask the tool for the default options
	// default project level (i.e. target) options for the target type
	virtual BOOL 	SetDefaultDebugTargetOptions(CProject * pProject, CTargetItem * pTarget, BOOL fUseMFC);
	virtual BOOL 	SetDefaultReleaseTargetOptions(CProject * pProject, CTargetItem * pTarget, BOOL fUseMFC);
	// returns the default use of MFC for this target type (returns platform default use)
	virtual UINT 	GetUseMFCDefault() { return m_pPlatform->GetUseMFCDefault(); }
	//	Ensure that the tool will build an the project item (debug or release config. mode)
	//	Likely to entail doing such things as munging tool options, eg. the libs for linker
	// FUTURE: Use wizards to do this in v4.0?
	virtual void 	PerformSettingsWizard(CProjItem * pItem, BOOL fUsingMFC);
	

protected:
	CPtrList m_ToolsList;	// List of tools that can be used with us. Source tools are at the front.
							// Schmooze tools are in the back in the order in which they should be
							// invoked during build.
	UINT	m_nIDType;		// string resource ID for target type name
	CString	m_strType;		// our target type name
	CString m_strUIType;
	CPlatform * m_pPlatform;

private:
	UINT	m_nUniqueTypeId; // Unique identifier (see uniq_type enum)

public:
	virtual void ReleaseInterface( void );
	virtual LPPROJECTTYPE GetInterface(void);
	void RemoveInterface(void){ pCIProjType=NULL;}

private:
	LPPROJECTTYPE 		m_pIProjType;
	CProjTypeInterface *pCIProjType;
};

// This is the ole interface for use with old style project types
class CProjTypeInterface : public CCmdTarget{
public:
	LPPROJECTTYPE GetInterface(void){
		LPPROJECTTYPE pIProjType;
		m_xProjType.QueryInterface(IID_IProjectType, (void **)&pIProjType);
		return pIProjType;
	}

	void SetThis( CProjType *pProj ){ m_pProjectType = pProj; };
	CProjType *GetProjectType(){ return m_pProjectType; };
	~CProjTypeInterface(){ if( m_pProjectType ) m_pProjectType->RemoveInterface(); };


protected:
	BEGIN_INTERFACE_PART(ProjType, IProjectType)
		INIT_INTERFACE_PART(CProjTypeInterface, ProjectType)

		// IProjectType
		STDMETHOD(GetName)( CString *str );
		STDMETHOD(GetType)( UINT *id );
		STDMETHOD(GetPlatform)( LPPLATFORM *);
		STDMETHOD(IsSupported)(void);

		STDMETHOD(PickTool)( LPBUILDFILE pFile, LPBUILDTOOL *pBuildTool);
		STDMETHOD(AddTool)( LPBUILDTOOL pBuildTool);
		STDMETHOD(EnumBuildTools)( LPENUMBUILDTOOLS *, LPBUILDTOOL * );
	END_INTERFACE_PART(ProjType)

	DECLARE_INTERFACE_MAP()

private:
	CProjType *m_pProjectType;

};



// COLEProjType is the proxy object for add on defined project types
class COLEProjType : public CProjType
{
	DECLARE_DYNAMIC(COLEProjType)
public:
	COLEProjType( LPPROJECTTYPE pPrj, const char *szName, int type ):
		CProjType(szName,1,0,type,szName,1){ m_pProj = pPrj; };

	virtual CPlatform * 		GetPlatform() const ;
	virtual const CString * 	GetTypeName() ;
	virtual BOOL 				IsSupported() const ;
	virtual CBuildTool *		PickTool(FileRegHandle frh);
	virtual CPtrList * 			GetToolsList();

	virtual LPPROJECTTYPE GetInterface(){ m_pProj->AddRef(); return m_pProj;}

private:
	LPPROJECTTYPE m_pProj;		// the add ons project type
};



class CProjTypeUnknown : public CProjType
{
	DECLARE_DYNAMIC(CProjTypeUnknown)
public:
	CProjTypeUnknown(const _TCHAR * lpszType, UINT nUniqTypeId, CPlatform * pPlatform)
		: CProjType(lpszType, nUniqTypeId, pPlatform) {}

	~CProjTypeUnknown();

	// create the list of tools we use
	BOOL FInit();

	// from -> CBldSysCmp
	BOOL IsSupported() const { return FALSE; }
	// <- CBldSysCmp

	// old makefile (Caviar/Cuda) conversion
	int GetOldPROGTYPE(BOOL /*f32Bit*/ = TRUE) {return -1;}

	BOOL GetDefaultToolOptions(DWORD, const CString & , CString & ) { return FALSE; }
	int GetAttributes () {return TargetUnknown;}
};

// helper function used to derive tool options that show common part
void BLD_IFACE VPROJDeriveDefaultOptions(CString & strOption, UINT nIDCommon, UINT nIDMode, UINT nIDOption);

#endif // _INCLUDE_PRJCONFG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\pfilereg.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
//	CFileRegEntry, CFileRegSet, CFileRegFilter, CFileRegFile, CProjFileRegistry
//
//	File registry database classes
//
//	History:
//	Date						Who						What
//	07/20/94					colint					Cleaned up existing
//														file registry and
//														added file filters.
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#pragma hdrstop
#include "tchar.h"
#include "path.h"
#include "pfilereg.h"
#include "exttarg.h"

#include "fcntl.h"

#include <utilbld_.h>
#include <prjapi.h>
#include <prjguid.h>
#include <sys\types.h>
#include <sys\utime.h>
#include "oleref.h"

#ifdef _WIN32
#define _SUSHI_PROJECT
#include "project.h"
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#ifdef _DEBUG
#include <crtdbg.h>
#include "memstat.h"
#endif

#ifdef _BLD_REG_HISTORY
//#pragma message ("INFO : pfilereg.cpp : Using file registry history debugging")
#endif

extern BOOL g_fCreatingProject;

/////////////////////////////////////////////////////////////////////////////
// Local heap

#ifdef USE_LOCAL_BUILD_HEAP
CLclHeap::CLclHeap(USHORT cPages /* = 0 */, BOOL fCreate /* = FALSE */)
{
	m_hHeap = (HANDLE)NULL;	// not created yet
	m_cPages = cPages;

	// create now?
	if (fCreate) VERIFY(Create());
}

CLclHeap::~CLclHeap()
{
	// need to destroy?
	if (m_hHeap != (HANDLE)NULL) VERIFY(Destroy());
}

// create + destroy our heap
BOOL CLclHeap::Create()
{
	ASSERT(m_hHeap == (HANDLE)NULL);

	m_hHeap = ::HeapCreate(HEAP_NO_SERIALIZE, m_cPages * 4096, 0);
	return m_hHeap != (HANDLE)NULL;
}

BOOL CLclHeap::Destroy()
{
	ASSERT(m_hHeap != (HANDLE)NULL);

	BOOL fRet = ::HeapDestroy(m_hHeap);
	m_hHeap = (HANDLE)NULL;
	return fRet;
}

#ifdef _DEBUG
// dump heap statistics
void CLclHeap::Dump(CDumpContext & dc) 
{
	// show our heap information
	TCHAR buf[256];
	_stprintf(buf, "0x%lx", m_hHeap);
	 
	dc << "Heap : " << buf;
	dc << " has allocated " << (DWORD)m_lAlloc << " bytes\n";

	// get heap information
	PROCESS_HEAP_ENTRY infoHeap;
	infoHeap.lpData = NULL;	// initiate

	// accumulate info.
	DWORD cbData = 0, cbOverhead = 0, cbCommitted = 0, cbUnCommitted = 0;
	
	while (::HeapWalk(m_hHeap, &infoHeap))
	{
		ASSERT(!(infoHeap.wFlags & PROCESS_HEAP_ENTRY_DDESHARE));	// not supported!
		ASSERT(!(infoHeap.wFlags & PROCESS_HEAP_ENTRY_MOVEABLE));	// not supported!

		{
			if (infoHeap.wFlags & PROCESS_HEAP_REGION)
			{
				// accum. info. for this region
				cbCommitted += infoHeap.Region.dwCommittedSize;
				cbUnCommitted += infoHeap.Region.dwUnCommittedSize;
				cbOverhead += infoHeap.cbOverhead;
			}

			if (infoHeap.wFlags & PROCESS_HEAP_ENTRY_BUSY)
			{
				// accum. info. for this block
				cbData += infoHeap.cbData;
				cbOverhead += infoHeap.cbOverhead;
			}
		}
	}

	DWORD dw = ::GetLastError();
	if (dw == ERROR_NO_MORE_ITEMS)
	{
		dc << " Data size    : " << cbData << " bytes\n";
		dc << " Overhead     : " << cbOverhead << " bytes\n";
		dc << " Committed    : " << cbCommitted << " bytes (" << div(cbCommitted, 4096).quot << " pages)\n";
		dc << " UnCommitted  : " << cbUnCommitted << " bytes (" << div(cbUnCommitted, 4096).quot << " pages)\n";
	}
	else if (dw == ERROR_CALL_NOT_IMPLEMENTED)
	{
		dc << "Statistics unavailable Win32 API ::HeapWalk not implemented";
	}
	else
	{
		dc << "!! Error retrieving stats !!";
	}
}
#endif // _DEBUG
#endif // USE_LOCAL_BUILD_HEAP

#ifdef _BLD_REG_HISTORY
void CFRHHistory::Dump(CDumpContext &DC) const
{
    // Dump frh reference counting history here

    if (m_bAddRef)
        DC << "Add Ref\n";
    else
        DC << "Release Ref\n";

    DC << "File: " << m_szFile << "\n";
    DC << "Line: " << m_nLine << "\n";

    if (m_pNext)
        m_pNext->Dump(DC);
}
#endif

#ifdef _DEBUG
TCHAR *FRHToName( FileRegHandle  frh ) {
	TCHAR *pch = (TCHAR *)((CPath *)g_FileRegistry.GetRegEntry(frh)->GetFilePath())->GetFullPath();
	return pch;
}
#endif

/////////////////////////////////////////////////////////////////////////////
// Setting this flag to TRUE will prevent any further requests for file
// change notification, eg. it is used during builder creation
BOOL g_FileRegDisableFC = FALSE;
BOOL g_bFileDepULQInUse = FALSE;
BOOL g_bUpdateDep = FALSE;
BOOL g_bInProjLoad = FALSE;
BOOL g_bExcludedNoWarning = FALSE;

/////////////////////////////////////////////////////////////////////////////
// Our queue of file registry entry changes
class CSafeAttribList : public CPtrList {
public:
    ~CSafeAttribList(){
	while ( !IsEmpty() ) {
		S_ATTRIB * ptr = (S_ATTRIB *) GetHead();
#ifdef REFCOUNT_WORK
		ptr->_frh->ReleaseFRHRef();
#endif
		delete ptr;
		RemoveHead();
	}
    }
};

CSafeAttribList g_FileChangeQ;

//queue which has all the info needed for update dep
CObList g_FileDepUpdateListQ;
CObList AFX_DATA_EXPORT g_FileForceUpdateListQ;

CTestableSection g_sectionFileChangeQ;

CTestableSection g_sectionDepUpdateQ;

#ifndef REFCOUNT_WORK
CTestableSection CFileRegistry::g_sectionFileMap;
#else
CTestableSection CFileRegFile::g_sectionFileMap;
#endif

void FileChangeQ(FileRegHandle frh, BOOL fInSccOp /* = FALSE */)
{
	// q the file?
	if (frh != (FileRegHandle)NULL)
	{
		{
			// Ensure sequential access to file change Q
			CritSectionT cs(g_sectionFileChangeQ);
 
#ifndef REFCOUNT_WORK
			// Ensure sequential access to file map
			CritSectionT cs2(CFileRegistry::g_sectionFileMap);
 
			// find the registry entry?
			if (g_FileRegistry.LookupFile(frh->GetFilePath()) == frh)
			{
				// allocate and cache
				S_ATTRIB * pattrib = new S_ATTRIB;
				pattrib->_frh = frh;
				pattrib->_fInSccOp = fInSccOp;

				// add to our Q
				g_FileChangeQ.AddTail((void *)pattrib);

				// FUTURE: add ref.?
			}
#else
			// allocate and cache
			S_ATTRIB * pattrib = new S_ATTRIB;
			pattrib->_frh = frh;
			pattrib->_frh->AddFRHRef();
			pattrib->_fInSccOp = fInSccOp;

			// add to our Q
			g_FileChangeQ.AddHead((void *)pattrib);
#endif
		}


		// We are done.
		ASSERT(g_bNewUpdateDepModel);
		if (g_bNewUpdateDepModel)
			return;

#if 0	// Unused code.
		// figure out if this is non C syntax file, may change later		
		TCHAR *pch = (TCHAR *)frh->GetFilePath()->GetExtension();

		if (pch && ((_tcsicmp(pch, ".rc")==0) || (_tcsicmp(pch, ".r")==0) || (_tcsicmp(pch, ".odl")==0) ||
			(_tcsicmp(pch, ".f")==0) || (_tcsicmp(pch, ".for")==0) || (_tcsicmp(pch, ".f90")==0) ))
		{
			// not C-Syntax file, we need to update deps
			ASSERT(!g_bFileDepULQInUse);
			FileItemDepUpdateQ(NULL, NULL, frh, g_FileDepUpdateListQ);
		}
#endif
	}
}

int FileChangeDeQ()
{
	// this rc file
	NOTIFYINFO Notify;
	const CPath * pPath;

	Notify.hFileSet = (HFILESET)NULL;
	Notify.pPkgProject = NULL; // UNUSED

	BOOL fNotifyBldrFileChng = FALSE;
	BOOL fInSccOp = FALSE;
	CString strExt;

	{
		// Ensure sequential access to file change Q
		CritSectionT cs(g_sectionFileChangeQ);
 
#ifndef REFCOUNT_WORK
		// Ensure sequential access to file map
		CritSectionT cs2(CFileRegistry::g_sectionFileMap);
#endif

		// anything to do?
		POSITION pos = g_FileChangeQ.GetHeadPosition();
		if (pos != (POSITION)NULL)
		{
			// while de-q'ing don't let the registry try
			// to FAddFile() to the file change thread
			// its inefficient
			BOOL oldFileRegDisableFC = g_FileRegDisableFC;
			g_FileRegDisableFC = TRUE;

			// refresh attributes for q'd files
			while (pos != (POSITION)NULL)
			{
				S_ATTRIB * pattrib = (S_ATTRIB *)g_FileChangeQ.GetAt(pos);

				// remove this one
				g_FileChangeQ.RemoveAt(pos);

				FileRegHandle frh = pattrib->_frh;
				if (frh != NULL)
				{
					// set the current attributes
					if (((CFileRegFile *)g_FileRegistry.GetRegEntry(pattrib->_frh))->RefreshAttributes())
					{

						// only do this if it actually changed
						pPath = ((CFileRegFile *)g_FileRegistry.GetRegEntry(pattrib->_frh))->GetFilePath();
						strExt = pPath->GetExtension();
						// is this the builder?
						if (strExt.CompareNoCase(BUILDER_EXT)==0)
						{
							if (pPath->ExistsOnDisk())
							{
								Notify.lstFiles.AddTail((CPath *)pPath);
								fNotifyBldrFileChng = TRUE;
								// REVIEW: these could be different
								fInSccOp = fInSccOp || (pattrib->_fInSccOp != 0);
							}
							else
							{
								// REVIEW: warn user
								// dsp file has been deleted, so mark as dirty
								CObList * pList = g_FileRegistry.GetRegEntry(pattrib->_frh)->plstFileItems;
								if (pList != NULL)
								{
									ASSERT(pList->GetCount() == 1);
									CProject * pProject = (CProject *)pList->GetHead();
									ASSERT(pProject);
									if (pProject != NULL)
										pProject->DirtyProject();
								}
							}
						}
					}
#ifdef REFCOUNT_WORK
					frh->ReleaseFRHRef();
#endif
				}

				// de-allocate
				delete pattrib;

				// FUTURE: release ref.?

				// next...always use head, somebody may be deleting items
				// from us in ->SetAttributes() as above
				pos = g_FileChangeQ.GetHeadPosition();
			}

			g_FileChangeQ.RemoveAll();

			g_FileRegDisableFC = oldFileRegDisableFC;
		}
		else
		{
			return FALSE;
		}
	}

	// Notify of external builder file change?
	if (fNotifyBldrFileChng)
	{
		Notify.hFileSet = (HFILESET)fInSccOp;  // hack
		theApp.NotifyPackages(PN_EXTCHNG_PROJECT, (void *)&Notify);
	}

	return TRUE;
}

// add/remove to/from a list file items needed to upate deps
void FileItemDepUpdateQ
(
	CFileItem * pItem,
	CPtrList * pdepList,
	FileRegHandle frh,
	CObList & updateList,
	BOOL fRemove, /* = FALSE */
	HBLDTARGET hTarg /* = NO_TARGET */
)
{
	ASSERT(!g_bNewUpdateDepModel);
	ASSERT(NULL==pdepList);
	ASSERT((&updateList) == &g_FileForceUpdateListQ);

	CritSectionT cs(g_sectionDepUpdateQ);
	if ((&updateList) == &g_FileDepUpdateListQ)
	{
		ASSERT(!g_bFileDepULQInUse);
		g_bFileDepULQInUse = TRUE;
	}
	CDepUpdateRec * pdepRec;

	// remove?
	if (fRemove)
	{
		POSITION pos = updateList.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			POSITION posCurr = pos;
			pdepRec = (CDepUpdateRec *)updateList.GetNext(pos);
			if (pdepRec &&
				pdepRec->m_pFileItem == pItem)
			{
				updateList.RemoveAt(posCurr);
				delete pdepRec;
			}
		}	
	}
	// add...
	else
	{
		pdepRec = new CDepUpdateRec;
		pdepRec->m_pFileItem = pItem;
		pdepRec->m_pdepList = pdepList;
		pdepRec->m_frh = frh;
		pdepRec->m_hTarg = (UINT)hTarg;

		updateList.AddTail(pdepRec);
	}
	if ((&updateList) == &g_FileDepUpdateListQ)
	{
		g_bFileDepULQInUse = FALSE;
	}
}

BOOL ProcessDepUpdate(CDepUpdateRec *pdepRec, CProject *pActiveProject)
{
	// Should not reach this code when using new model.
	ASSERT(!g_bNewUpdateDepModel);

#if 0	// Unused code.

	if (pdepRec && 
		(pdepRec->m_pdepList != (CPtrList *)NULL) &&
		(pdepRec->m_pFileItem != (CFileItem *)NULL) &&
		(pdepRec->m_frh == (FileRegHandle)NULL)	)
	{
		// This is queued from the update dep calls from the parser
		// C syntax files only
		CProject * pProject = pdepRec->m_pFileItem->GetProject();
		if ((pProject != (CProject *)NULL) && (pProject == pActiveProject))
		{
			CString strTarget;
			g_BldSysIFace.GetTargetName((HBLDTARGET)pdepRec->m_hTarg, strTarget, (HBUILDER)pActiveProject);
			CTargetItem * pTarget = (CTargetItem *)g_BldSysIFace.CnvHTarget((HBUILDER)pActiveProject, (HBLDTARGET)pdepRec->m_hTarg);
			
			if (pTarget != (CTargetItem *)NULL)
			{
				ConfigurationRecord * pcrOld = pProject->GetActiveConfig();
				ConfigurationRecord *pcr = pTarget->ConfigRecordFromConfigName((const TCHAR *)strTarget);

				ASSERT(pcr);
		 		if (pcr->IsValid())
				{
					CProjTempConfigChange projTempConfigChange(pProject);
					projTempConfigChange.ChangeConfig((ConfigurationRecord*)pcr->m_pBaseRecord);

					pdepRec->m_pFileItem->UpdateDependencies(pdepRec->m_pdepList);
					pTarget->RefreshDependencyContainer();
				}
			}
		}
		else
		{
			// NOTE: This assert is really harmless.
			//ASSERT(FALSE);	// item removed from project and not de-Q'd?
		}

		// remove the depList
		pdepRec->m_pdepList->RemoveAll();

		delete pdepRec->m_pdepList;
		pdepRec->m_pdepList = NULL; // to avoid duplicate deletion
	}
	// following are non-C syntax files case
	else if (pdepRec && (pdepRec->m_pFileItem != (CFileItem *)NULL) &&
			 (pdepRec->m_frh != NULL) )
	{
		// we know the FileItem, we called from mirrored or file move into proj dep update
		CProject * pProject = pdepRec->m_pFileItem->GetProject();
		if (pProject != (CProject *)NULL && (pProject == pActiveProject) )
		{
			CTargetItem * pTarget = pdepRec->m_pFileItem->GetTarget();
			ASSERT(pTarget);

			CProjTempConfigChange projTempConfigChange(pProject);

			const CPtrArray * paryConfigs = pTarget->GetConfigArray();
			ASSERT(paryConfigs);

			int i = 0, iLast = paryConfigs->GetUpperBound();
		
			//Loop through all the configuration for this target, so all the deps updated
			g_ScannerCache.BeginCache();
			ConfigurationRecord *pcr;
			BOOL fReFreshDepCtr = FALSE;
			while (i <= iLast)
			{
				pcr = (ConfigurationRecord *) paryConfigs->GetAt(i++);	// get this one and advance
				ASSERT(pcr);

				if (pcr->IsValid())
				{
					projTempConfigChange.ChangeConfig((ConfigurationRecord*)pcr->m_pBaseRecord);
					if (!pdepRec->m_pFileItem->ScanDependencies())
					{
						// scan failed, wait for next round to do it again
						g_ScannerCache.EndCache();
						g_bFileDepULQInUse = FALSE;
						return FALSE;
					}
					fReFreshDepCtr = TRUE;
				}
			}

			g_ScannerCache.EndCache();
			projTempConfigChange.Release();

			if (fReFreshDepCtr)
				pTarget->RefreshAllMirroredDepCntrs();
		}
		else
		{
			ASSERT(FALSE);	// item removed from project and not de-Q'd?
		}
	}
	else if (pdepRec && (pdepRec->m_pFileItem == (CFileItem *)NULL) &&
			 (pdepRec->m_frh != NULL) )
	{
		// we are called from file save notification
		CObList *oblist;

		// Get current project
		CProject * pProject = pActiveProject;
		if (pProject != (CProject *)NULL)
		{
			CProjTempConfigChange projTempConfigChange(pProject);
					
			// Get file items for this frh
			// Is this right, it seems we are getting called repeated???
			oblist = g_FileRegistry.GetRegEntry(pdepRec->m_frh)->plstFileItems;
			if (oblist)
			{				
				POSITION pos = oblist->GetHeadPosition();		
				while (pos != (POSITION)NULL )
				{
					CFileItem *pItem = (CFileItem *)oblist->GetNext(pos);

					if (pItem)
					{
						// update for all project configurations
						CTargetItem * pTarget = pItem->GetTarget();
						
						if (pTarget != (CTargetItem *)NULL)
						{
							const CPtrArray * pArrayCfg = pTarget->GetConfigArray();
							ASSERT(pArrayCfg);

							int i=0, iLast = pArrayCfg->GetUpperBound();
							ConfigurationRecord *pcr;
							BOOL fReFreshDepCtr = FALSE;
							g_ScannerCache.BeginCache();
							while (i <= iLast)
							{
								pcr = (ConfigurationRecord *) pArrayCfg->GetAt(i++);	// get this one and advance
								ASSERT(pcr);

								if (pcr->IsValid())
								{
									projTempConfigChange.ChangeConfig((ConfigurationRecord*)pcr->m_pBaseRecord);
									if (!pItem->ScanDependencies())
									{
										// scan failed, wait for next round to do it again
										g_ScannerCache.EndCache();
										g_bFileDepULQInUse = FALSE;
										return FALSE;
									}
									fReFreshDepCtr = TRUE;
									//pTarget->RefreshDependencyContainer();
								}
							}
							g_ScannerCache.EndCache();
							if (fReFreshDepCtr)
								pTarget->RefreshAllMirroredDepCntrs();
						}
					}
				}
			}
		}
	}
#endif	// Unused code.
	return TRUE;
}

// update deps for the item on the list
// one at a time, to keep the other event respond time
int FileItemDepUpdateDeQ()
{
	ASSERT(g_bNewUpdateDepModel);
	if (g_bNewUpdateDepModel)
	{
		ASSERT(g_FileDepUpdateListQ.IsEmpty());
		return FALSE;
	}

#if 0	// Unused code.

	LPSOURCECONTROLSTATUS pInterface;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)));
	BOOL bIsSccOpInProgress = (pInterface->IsSccOpInProgress() == S_OK);
	pInterface->Release();
	if (bIsSccOpInProgress)
		return FALSE; // don't try this if we're in the middle of an scc op

	CDepUpdateRec *pdepRec = NULL;

	POSITION pos = g_FileDepUpdateListQ.GetHeadPosition();

	if (pos == (POSITION)NULL)
		return FALSE; // nothing to do

	CProject * pActiveProject = (CProject *)g_BldSysIFace.GetActiveBuilder();

	// This must be at top-level scope!!
	CProjDeferDirty deferDirty(pActiveProject);

	if (pos != (POSITION)NULL) // n.b. do not remove this test, it has a purpose!
	{
		CritSectionT cs(g_sectionDepUpdateQ);
		if (g_bFileDepULQInUse)
		{
			return TRUE; // avoid recursive OnIdle call!!!
		}
		else
			g_bFileDepULQInUse = TRUE;

		pos = g_FileDepUpdateListQ.GetHeadPosition(); // need to update pos after Crit

//		while (pos != (POSITION)NULL)
		if (pos != (POSITION)NULL)
		{
			pdepRec = (CDepUpdateRec *)g_FileDepUpdateListQ.GetNext(pos);
		}
		g_bFileDepULQInUse = FALSE;
	}

	// ProcessDepUpdate is called outside the critical section, since it may result
	// in the creation of new nodes which need dependencies.
	if (pdepRec != NULL && ProcessDepUpdate(pdepRec, pActiveProject))
	{
		CritSectionT cs(g_sectionDepUpdateQ);

		ASSERT(!g_bFileDepULQInUse);
		g_bFileDepULQInUse = TRUE;

		// Delete the item from the list (it should still be at the head).
		POSITION pos = g_FileDepUpdateListQ.GetHeadPosition();
		POSITION posNext = pos;
		if (pdepRec == (CDepUpdateRec *)g_FileDepUpdateListQ.GetNext(posNext))
		{
			g_FileDepUpdateListQ.RemoveAt(pos);
		}
		else
			ASSERT(FALSE);

		RemoveFromForceUpdateQueue(pdepRec);
		delete pdepRec;
		g_bFileDepULQInUse = FALSE;
	}
#endif // Unused code.

	return TRUE; // avoid recursive OnIdle call!!!
}

void RemoveFromForceUpdateQueue(CDepUpdateRec *pdepRec)
{
	//loop through g_FileForceUpdateListQ and remove the files updated from the list
	POSITION pos = g_FileForceUpdateListQ.GetHeadPosition();
	if (pos != (POSITION)NULL)
	{
		while (pos != (POSITION)NULL)
		{
			POSITION posPrev=pos;
			CDepUpdateRec *pdepRecTmp = (CDepUpdateRec *)g_FileForceUpdateListQ.GetNext(pos);
			//remove the record with same file item and target
			if (pdepRecTmp && pdepRec && (pdepRec->m_pFileItem == pdepRecTmp->m_pFileItem) )
				{
					delete pdepRecTmp;			
					g_FileForceUpdateListQ.RemoveAt(posPrev);
					break;
				}
		}
	}
}

// remove items with this target from the queue
void RemoveItemsFromUpdateQueue(UINT hTarget)
{
	//loop through g_FileForceUpdateListQ and remove the files updated from the list
	POSITION pos = g_FileDepUpdateListQ.GetHeadPosition();
	if (pos != (POSITION)NULL)
	{
		CritSectionT cs(g_sectionDepUpdateQ);
		if (g_bFileDepULQInUse)
			return;
		else
			g_bFileDepULQInUse = TRUE;

		pos = g_FileDepUpdateListQ.GetHeadPosition(); // must update after Crit
		while (pos != (POSITION)NULL)
		{
			POSITION posPrev=pos;
			CDepUpdateRec *pdepRecTmp = (CDepUpdateRec *)g_FileDepUpdateListQ.GetNext(pos);
			//remove the record with same file item and target
			if (pdepRecTmp && (pdepRecTmp->m_hTarg == hTarget) )
			{
				// remove the depList
				delete pdepRecTmp;
				g_FileDepUpdateListQ.RemoveAt(posPrev);
			}
		}
		g_bFileDepULQInUse = FALSE;
	}
}


//update the deps if there is any on the g_ForceUpdateListQ
void UpdateBeforeWriteOutMakeFile()
{
	CFileRegFile::AllowRetryFailedWatches(TRUE);

	if (g_FileForceUpdateListQ.GetHeadPosition() != NULL)
	{
		// Should not reach this code when using new model.
//		ASSERT(!g_bNewUpdateDepModel);

		CProject * pActiveProject = (CProject *)g_BldSysIFace.GetActiveBuilder();
		CProjTempConfigChange projTempConfigChange(pActiveProject);

		// Iterate over the list of targets
		CString strTargetName;
		CTargetItem *pTargetCurr;
		pActiveProject->InitTargetEnum();

		// If a file from the target is on the force list, we will ScanDependencies
		// on those files. It is important that we iterate target-wise, because
		// we can use the g_ScannerCache per target and this will speed this operation 
		// considerably.
		while (pActiveProject->NextTargetEnum(strTargetName, pTargetCurr))
		{

			g_ScannerCache.BeginCache( );

			ConfigurationRecord *pcr = pTargetCurr->ConfigRecordFromConfigName(strTargetName);
			ASSERT(pcr != NULL);
			ASSERT(pcr->IsValid());

			// Force this to be our active config.
			projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);

			//loop through g_FileForceUpdateListQ 
			POSITION pos = g_FileForceUpdateListQ.GetHeadPosition();
			BOOL fRefreshDepCtr = FALSE;

			while (pos != (POSITION)NULL)
			{	
				CDepUpdateRec *pdepRec = (CDepUpdateRec *)g_FileForceUpdateListQ.GetNext (pos);

				if (pdepRec && (pdepRec->m_pFileItem != (CFileItem *)NULL) )
				{
					CProject * pProject = pdepRec->m_pFileItem->GetProject();
					if ((pProject != (CProject *)NULL) && (pProject == pActiveProject))
					{
						CTargetItem *pTargetItem = pdepRec->m_pFileItem->GetTarget();
						ASSERT(pTargetItem);

						if (pTargetItem == pTargetCurr)	  // The file belongs to this target.
						{
							pdepRec->m_pFileItem->ScanDependencies();
							fRefreshDepCtr = TRUE;
							//refresh view
							//pTarget->RefreshDependencyContainer();
						}
					}
				}
			}

			if (fRefreshDepCtr)
				pTargetCurr->RefreshAllMirroredDepCntrs();

			g_ScannerCache.EndCache();
		}

		// Free up all the pdepRec here.
		POSITION pos = g_FileForceUpdateListQ.GetHeadPosition();
		while (pos != NULL)
		{
			CDepUpdateRec *pdepRec = (CDepUpdateRec *)g_FileForceUpdateListQ.GetNext(pos);
			delete pdepRec;
		}
 		g_FileForceUpdateListQ.RemoveAll();
	}

	// clean up the auto update queue if there is any
	POSITION pos = g_FileDepUpdateListQ.GetHeadPosition();
	if (pos != (POSITION)NULL)
	{
		// Should not reach this code when using new model.
		ASSERT(!g_bNewUpdateDepModel);

		CritSectionT cs(g_sectionDepUpdateQ);
		if (g_bFileDepULQInUse)
			return;
		else
			g_bFileDepULQInUse = TRUE;
		pos = g_FileDepUpdateListQ.GetHeadPosition(); // must update after Crit
		while (pos != (POSITION)NULL)
		{
			CDepUpdateRec *pdepRec = (CDepUpdateRec *)g_FileDepUpdateListQ.GetNext(pos);
			delete pdepRec;
		} //while

		// done these, remove them
		g_FileDepUpdateListQ.RemoveAll();
		g_bFileDepULQInUse = FALSE;
 	} //if
}

// update deps for the item on the list
void FileItemDepUpdateDeQAll()
{
	POSITION pos= g_FileDepUpdateListQ.GetHeadPosition();

	// Should not have any updates in queue when using new model.
	ASSERT(NULL==pos || !g_bNewUpdateDepModel);

	while (pos != (POSITION)NULL)
	{
		FileItemDepUpdateDeQ();
		pos = g_FileDepUpdateListQ.GetHeadPosition();
	}

    // Make sure anything on our forced list is scanned
    // before we build.
    UpdateBeforeWriteOutMakeFile();
}

void RemoveFileItemFromUpdateQ(CFileItem *pFileItem)
{
	{
		CritSectionT cs(g_sectionDepUpdateQ);

		//loop through g_FileForceUpdateListQ and remove the files updated from the list
		POSITION pos = g_FileForceUpdateListQ.GetHeadPosition();
		if (pos != (POSITION)NULL)
		{
			while (pos != (POSITION)NULL)
			{
				POSITION posPrev=pos;
				CDepUpdateRec *pdepRecTmp = (CDepUpdateRec *)g_FileForceUpdateListQ.GetNext(pos);
				//remove the record with same file item and target
				if (pdepRecTmp && pFileItem && (pFileItem == pdepRecTmp->m_pFileItem) )
				{
					delete pdepRecTmp;
					g_FileForceUpdateListQ.RemoveAt(posPrev);
					//break;
				}
			}
		}

		//loop through g_FileDepUpdateListQ and remove the files updated from the list
		pos = g_FileDepUpdateListQ.GetHeadPosition();
		if (pos != (POSITION)NULL)
		{
			while (pos != (POSITION)NULL)
			{
				POSITION posPrev=pos;
				CDepUpdateRec *pdepRecTmp = (CDepUpdateRec *)g_FileDepUpdateListQ.GetNext(pos);
				//remove the record with same file item and target
				if (pdepRecTmp && pFileItem && (pFileItem == pdepRecTmp->m_pFileItem) )
				{
					delete pdepRecTmp;
					g_FileDepUpdateListQ.RemoveAt(posPrev);
					//break;
				}
			}
		}
	}
}

void BldSrcFileChangeCallBack(const FCItem* pfc, DWORD dwUser)
{
	// Should always be FCItem::opFileChanged.
	ASSERT (pfc->_op == FCItem::opFileChanged);

	// Nothing to do..
	if (pfc->_op != FCItem::opFileChanged)
		return;

#ifndef REFCOUNT_WORK
	FileRegHandle frh = g_FileRegistry.LookupFile(pfc->_strFileName);
#else
	FileRegHandle frh = CFileRegFile::LookupFileHandleByName(pfc->_strFileName);
#endif

	// ignore any file-change we don't know about
	if (frh == (FileRegHandle)NULL)
		return;	// ignore

	// directory deleted?
	if (pfc->_fcb.fDirDel)
	{
		// directory has been deleted, and hence this file of course...
		// this is no longer under file-watch
		((CFileRegFile *)frh)->m_bFileWatch = FALSE;
		((CFileRegFile *)frh)->m_bFileAddedToFC = FALSE;
		((CFileRegFile *)frh)->m_tickFailedWatch = 0;

#if 0
		TRACE("\nDeleted directory of file '%s'", pfc->_strFileName);
#endif
	}
	else
	{
#if 0
		TRACE("\nFile change '%s'", pfc->_strFileName);
#endif
	}

#if 0
	// If this file has been deleted then we can release our ref on it.
	if (pfc->_op == FCItem::opDel)
	{
		// The file change thread has really stopped watching this file
		// so we can release our ref on it.
#ifdef REFCOUNT_WORK
		// Release 2 references, lookup at beginning of this function and file change thread.
 		frh->ReleaseFRHRef();
#endif
 		frh->ReleaseFRHRef();
		return;
	}
#endif
 
	// queue these for processing at a more convenient time
	// ie. when we're in the main thread ;-)

	// Scc doesn't care about mere attribute changes
	FCBits fcTest = pfc->_fcb;
	fcTest.fAttrs = 0; // clearing fAttrs allows quick test if anything else set
	
	// NB. Test for SccOp exactly equal to TRUE is a V4 HACK, since this can
	// be set to -1 in the case where we're saving the file and we want
	// don't want to treat this as an Scc-generated file-change
	ASSERT(NULL!=g_pSccManager);
	int nSccOpInProgress = g_pSccManager->IsOpInProgressValue();
	if (fcTest.fAll != 0) // ignore attribute-only changes
 		FileChangeQ(frh, (nSccOpInProgress==TRUE && (fcTest.fAll != 0)));

	// This is a good time to allow failed file watches to be re-tried.
	CFileRegFile::AllowRetryFailedWatches(FALSE);

#ifdef REFCOUNT_WORK
	// reference from lookup
	frh->ReleaseFRHRef();
#endif
}

#ifdef _BLD_SRC_FC_ASYNC
void BldSrcFileAddedCallBack(const FCItem* pfc)
{
	// Ensure sequential access to file change Q
	CritSectionT cs(g_sectionFileChangeQ);
 
#ifndef REFCOUNT_WORK
	// Ensure sequential access to file map
	CritSectionT cs2(CFileRegistry::g_sectionFileMap);
#endif

	// file reg handle
	S_ATTRIB attrib;
	attrib._frh = (FileRegHandle)pfc->_pvUser1;

#if 0
	TRACE("\nFile async. add attempt '%s'", pfc->_strFileName);
#endif

	// successful addition?
#ifndef REFCOUNT_WORK
	if (pfc->_fAsyncReturn &&	// passed
		g_FileRegistry.LookupFile(attrib._frh->GetFilePath()) == attrib._frh	// we still have it
	   )
#else
	if (pfc->_fAsyncReturn )
#endif
	{
		// got it, get the attributes from the FCItem
		attrib._fOk = TRUE;
		attrib._fExists = pfc->_statNew.dwAttrs != 0;
		attrib._filetime = pfc->_statNew.fcft.filetime;

		// under file-watch
		((CFileRegFile *)attrib._frh)->m_bFileWatch = TRUE;

		// set them
		((CFileRegFile *)g_FileRegistry.GetRegEntry(attrib._frh))->SetAttributes(&attrib);

#if 0
		TRACE(" .... ok!");
#endif
#ifdef REFCOUNT_WORK
		// reference from lookup
 		attrib._frh->ReleaseFRHRef();
#endif
	}
	else
	{
		// try to add assync. again
		((CFileRegFile *)attrib._frh)->m_bFileAddedToFC = FALSE;

		// Decrement file reg ref count, since we failed
		((CFileRegFile *)attrib._frh)->ReleaseFRHRef();

#if 0
		TRACE(" .... failed");
#endif
	}

	// This is a good time to allow failed file watches to be re-tried.
	CFileRegFile::AllowRetryFailedWatches(FALSE);
}
#endif // #ifdef _BLD_SRC_FC_ASYNC

///////////////////////////////////////////////////////////////////////////////
//
//	CFileRegEntry

// file reg. entry local heap
#ifdef USE_LOCAL_BUILD_HEAP
CLclHeap CFileRegEntry::g_heapEntries(20);
#endif

#ifdef REFCOUNT_WORK
static const int s_nRegSetRefCount = 1000;
#endif

IMPLEMENT_DYNAMIC(CFileRegEntry, CObject)

#ifdef REFCOUNT_WORK
#ifdef _DEBUG

// Defining PRESERVE_REGFILE causes CFileRegFile's to not be deleted until
// program exits.  This helps debugging reference count problems.
//#define PRESERVE_REGFILE
// AddFRHRef and ReleaseFRHRef are defined inline in pfilereg.h for non-debug builds.
void CFileRegEntry::AddFRHRef()
{
	m_nRefCount++;
}

void CFileRegEntry::ReleaseFRHRef()
{
	// Keep information around for CFileRegFile
	ASSERT(0!=m_nRefCount);
	if (0==m_nRefCount)
		return;

	m_nRefCount--;
#ifdef PRESERVE_REGFILE
	if (!IsNodeType(nodetypeRegFile))
	{
		if (m_nRefCount == 0)
			SafeDelete();
	}
#else
	if (m_nRefCount == 0)
		SafeDelete();
#endif
}
#endif // _DEBUG
#endif // REFCOUNT_WORK

CFileRegEntry::CFileRegEntry()
{
	// Set our node type
	dwNodeType |= nodetypeRegEntry;

	// Initialize the basic file registry entry properties
	m_nExistsOnDisk = FALSE;

	// Initialize the non informing properties
	m_nRefCount = 0;

#if 0
	// Removed from class.
	m_nProjRefCount = 0;
#endif

#ifndef REFCOUNT_WORK
	m_bRelative = TRUE;
#endif
	m_bMatchCase = FALSE;	
	m_bWantActualCase = FALSE;	
	m_bUseIntDir = FALSE;
	m_bUseOutDir = FALSE;

	// Initialize the update atrributes and dirty bit
	m_bDirty = FALSE;
	m_bUpdateAttribs = TRUE;

	m_bFoundInPath = FALSE;     
	m_bRelativeToProjName = FALSE;     
	m_ich = 0;
	plstFileItems = (CObList *)NULL;
	m_pOrgName = (TCHAR *)NULL;
}

CFileRegEntry::~CFileRegEntry()
{
#ifdef REFCOUNT_WORK
	ASSERT(0==m_nRefCount);
#endif

	// Delete our list of associated file items
	if (plstFileItems != (CObList*) NULL)
		delete plstFileItems;
	if (m_pOrgName)
		free(m_pOrgName);
}

void CFileRegEntry::OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint)
{
	ASSERT(FALSE);
}

void CFileRegEntry::InformNotifyRxs(UINT idChange, DWORD dwHint /* = 0 */)
{
#ifndef REFCOUNT_WORK
	// Inform dependants that we have changed in some way!

	// We must make a temporary copy of the dependant list.
	// This is an array if there are few dependants, otherwise it is a dynamically
	// allocated copy.
#define cpvLocal	8
	if (m_Dependants.GetSize() <= cpvLocal)
	{
		// Use an array as the holding area.
		void *rgpv[cpvLocal];
		int ipvLim = 0;
		for (POSITION posT = m_Dependants.GetHeadPosition(); posT != NULL; )
		{
			rgpv[ipvLim++] = m_Dependants.GetNext(posT);
		}
		ASSERT(ipvLim <= cpvLocal);

		for (int ipv = 0; ipv < ipvLim; ipv++)
		{
			CFileRegNotifyRx * pfrerx = (CFileRegNotifyRx*)rgpv[ipv];

			// *** warning: duplicated code ***
			// Handle FRN_LCL_DESTROY 'carefully' because rx's of 
			// may remove themselves from our dependency list!
			if (idChange != FRN_LCL_DESTROY || m_Dependants.Find(pfrerx) != (POSITION)NULL)
				pfrerx->OnNotify(this, idChange, dwHint);
		}
	}
	else
	{
		// Use a temporary copy of the set.
		CSmallPtrSet lstInform;		// used if !fUseArray
		lstInform.Copy(m_Dependants);

		for (POSITION pos = lstInform.GetHeadPosition(); pos != NULL; )
		{
			CFileRegNotifyRx * pfrerx = (CFileRegNotifyRx*) lstInform.GetNext(pos);

			// *** warning: duplicated code ***
			// Handle FRN_LCL_DESTROY 'carefully' because rx's of 
			// may remove themselves from our dependency list!
			if (idChange != FRN_LCL_DESTROY || m_Dependants.Find(pfrerx) != (POSITION)NULL)
				pfrerx->OnNotify(this, idChange, dwHint);
		}
	}
#else // ifndef REFCOUNT_WORK
	for (POSITION pos = m_Dependants.GetHeadPosition(); pos != NULL; )
	{
		CFileRegNotifyRx * pfrerx = (CFileRegNotifyRx*) m_Dependants.GetNext(pos);

		pfrerx->OnNotify(this, idChange, dwHint);
	}
#endif // ifndef REFCOUNT_WORK
}

void CFileRegEntry::AddNotifyRx(CFileRegNotifyRx* pfre)
{
	// Add a notification receiver to our dependency list
	ASSERT(pfre != this);
	POSITION pos = m_Dependants.Find(pfre);
	if (pos == NULL)
		m_Dependants.AddTail(pfre);

#ifdef REFCOUNT_WORK
	ASSERT(pos == NULL);
#endif
}

void CFileRegEntry::RemoveNotifyRx(CFileRegNotifyRx* pfre)
{
#ifdef REFCOUNT_WORK
//	ASSERT(NULL!=m_Dependants.Find(pfre));
#endif

	// Remove a notification receiver from our dependency list
	m_Dependants.RemoveItem(pfre);
}

BOOL CFileRegEntry::SetIntProp(UINT idProp, int nVal)
{
	// set an integer property value
	ASSERT(idProp == P_ExistsOnDisk);	// We only have one bool property

	int nOldVal = m_nExistsOnDisk;

	// any change?
	if (nOldVal != nVal)
	{
		m_nExistsOnDisk = nVal;

		if (!g_bInProjLoad) // skip this during project load
		{
			// notify our dependants that a integer property value has changed
			InformNotifyRxs(idProp, (UINT)nOldVal);
		}
	}

	return TRUE;
}

BOOL CFileRegEntry::GetIntProp(UINT idProp, int& nVal)
{
	// Get an integer property value
	(void)UpdateAttributes();
 	
	ASSERT(idProp == P_ExistsOnDisk);
	nVal = m_nExistsOnDisk;
	return TRUE;
}

#if 0
// inlined in pfilereg.h
long CFileRegEntry::MyCompareFileTime(FILETIME* pTime1, FILETIME* pTime2)
{
	if (pTime1->dwHighDateTime == pTime2->dwHighDateTime)
	{
		if (pTime1->dwLowDateTime == pTime2->dwLowDateTime)
			return 0;

		if (pTime1->dwLowDateTime < pTime2->dwLowDateTime)
			return -1;

		return 1;
	}

	if (pTime1->dwHighDateTime < pTime2->dwHighDateTime)
 		return -1;
	
	return 1;
}
#endif

//#ifndef REFCOUNT_WORK
void CFileRegEntry::AssociateFileItem (CFileItem * pItem)
{
	if (plstFileItems == (CObList *)NULL)
		if ((plstFileItems = new CObList) == (CObList *)NULL)
			return;

	// N.B. assumes no duplicates
	plstFileItems->AddTail(pItem);
}

BOOL CFileRegEntry::DisassociateFileItem (CFileItem * pItem)
{
	if (plstFileItems == (CObList *)NULL)
		return TRUE;	// not in here

	POSITION pos = plstFileItems->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		POSITION posCurr = pos;
		// N.B. assumes no duplicates
		if (pItem == (CFileItem*)plstFileItems->GetNext(pos))
		{
			plstFileItems->RemoveAt(posCurr);
			if (plstFileItems->IsEmpty())
			{
				delete plstFileItems;
				plstFileItems = (CObList *)NULL;
			}
			return TRUE;	// found it
		}
	}

	return FALSE;	// didn't find it
}
//#endif // ifndef REFCOUNT_WORK

BOOL CFileRegEntry::UpdateAttributes()
{
	BOOL fRefreshed = FALSE;
	if (CFileRegEntry::DoRefresh())
	{
		m_bUpdateAttribs = FALSE;
		fRefreshed = RefreshAttributes();
		m_bUpdateAttribs = TRUE;
	}

	return fRefreshed;
}

#ifdef _DEBUG
void CFileRegEntry::Dump(CDumpContext& dc) const
{
	dc << "{CFileRegEntry@" << (void*)this << ": ";
	dc << "RefCnt:" << m_nRefCount << ";";
	dc << "FileItems:" << (NULL!=plstFileItems?plstFileItems->GetCount():0) << ";";
	dc << "Dependants:" << m_Dependants.GetSize() << "}";
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
//	CFileRegSet

IMPLEMENT_DYNAMIC(CFileRegSet, CFileRegEntry)

CFileRegSet::CFileRegSet(int nHashSize)
	: CFileRegEntry(), m_Contents(nContentsBlockSize)
{
	// Set our node type
	dwNodeType |= nodetypeRegSet;
	m_pmapContents = NULL;			// no map yet
	m_nHashSizeMapContents = nHashSize;
	m_nExistsOnDisk = TRUE;

	// Set the default property values for an empty set
	FILETIME NewestTime;
	
	// Newest date
	NewestTime.dwLowDateTime = NewestTime.dwHighDateTime = 0;

	// If set is empty then it exists...
	SetIntProp(P_ExistsOnDisk, TRUE);
 
	// Set the default property values
	SetTimeProp(P_NewTStamp, NewestTime);

	// Initialize private cache helping members
	m_nNotExists = 0;

	// Calculate contents attribute changes
	// (off by default)
	m_fCalcAttrib = FALSE;

#ifndef REFCOUNT_WORK
	m_pFileRegistry = &g_FileRegistry;
#else
	m_pFileRegistry = NULL;

	// Set at s_nRegSetRefCount so it will never be deleted accidently.
	m_nRefCount = s_nRegSetRefCount;
#endif
}

CFileRegSet::~CFileRegSet()
{
	m_bUpdateAttribs = FALSE;	// don't attempt to update
 	m_fCalcAttrib = FALSE;		// don't re-calc attrib.

	POSITION pos = m_Contents.GetHeadPosition();
	POSITION lastPos;
	while (pos != NULL)
	{
		// WARNING: this code accessses the m_pFileRegistry member.  If the
		// current object is itself a CFileRegistry then this pointer is a
		// self-pointer, and we go into CFileRegistry methods after the
		// CFileRegistry destructor has been called!  This should be changed.
		lastPos = pos;
		FileRegHandle hndFileReg = (FileRegHandle) m_Contents.GetNext(pos);
#ifndef REFCOUNT_WORK
/*
		if( g_bInProjClose ){
			hndFileReg->RemoveNotifyRx(this);
			if ( hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegFilter)) )
				delete (CFileRegFilter *)hndFileReg;

			// in place of FRN_DESTROY doing this for us
			m_Contents.RemoveAt(lastPos);
		} 
		else {
*/
			RemoveRegHandleI(hndFileReg); // calling directly to level I function to avoid n^2 lookup
/*
		}
*/
		RemoveRegHandle(hndFileReg);
#else //#ifndef REFCOUNT_WORK
		RemoveRegHandleI(hndFileReg); // calling directly to level I function to avoid n^2 lookup
#endif //#ifndef REFCOUNT_WORK
	}

	if (m_pmapContents != NULL)
	{
		delete m_pmapContents;	// one has been allocated, so we must delete it
	}
#ifdef REFCOUNT_WORK
	// Unhook from registry.
	if (NULL!=m_pFileRegistry)
		SetFileRegistry(NULL);

	ASSERT(s_nRegSetRefCount==m_nRefCount);
	m_nRefCount=0;
#endif
}

void CFileRegSet::InitFrhEnum()
{
	// init. the enumerator
	m_posEnum = m_Contents.GetHeadPosition();
	m_fInitSet = TRUE;
}

FileRegHandle CFileRegSet::NextFrh()
{
TryAgain:

	// exhausted?
	if (m_posEnum == (POSITION)NULL)
		return (FileRegHandle)NULL;

	// is this a set?
	POSITION posEnum = m_posEnum;
	FileRegHandle frh = (FileRegHandle)m_Contents.GetNext(posEnum);
	if (((CFileRegEntry *)frh)->IsNodeType(nodetypeRegSet))
	{
		ASSERT(((CFileRegEntry *)frh)->IsKindOf(RUNTIME_CLASS(CFileRegSet)));
		// init. enumerator of this set?
		if (m_fInitSet)
		{
			// init. then remember that we have
			((CFileRegSet *)frh)->InitFrhEnum();
			m_fInitSet = FALSE;
		}

		// set got one?
		if ((frh = ((CFileRegSet *)frh)->NextFrh()) == (FileRegHandle)NULL)
		{
			// reset so that we init. next set
			m_fInitSet = TRUE;

			// advance...
			m_posEnum = posEnum;
			goto TryAgain;
		}
	}
	else
	{
		ASSERT(!(((CFileRegEntry *)frh)->IsKindOf(RUNTIME_CLASS(CFileRegSet))));
		// advance...
		m_posEnum = posEnum;

#ifdef REFCOUNT_WORK
		// The NextFrh() caller needs to ReleaseFRHRef.
		frh->AddFRHRef();
#endif
	}

	return frh;
}

#ifdef REGISTRY_FILEMAP
BOOL
CFileRegSet::RegHandleExists(FileRegHandle hndFileReg) const
{
	WORD w;
	// ASSERT((m_pmapContents==NULL) || ((UINT)m_pmapContents->GetCount() < ((UINT)m_pmapContents->GetHashTableSize() << 1))); // UNDONE
	return m_pmapContents != NULL
		   ? m_pmapContents->Lookup((void *)hndFileReg, w)
		   : (BOOL)m_Contents.Find((void *)hndFileReg);
}
#endif


BOOL CFileRegSet::AddRegHandle(FileRegHandle hndFileReg, BOOL bAddRef /* = TRUE */, BOOL bAddFront /* = FALSE */)
{
	ASSERT(hndFileReg);

#ifdef REFCOUNT_WORK
	// Shouldn't be adding again.
//	ASSERT( !RegHandleExists(hndFileReg) );
	ASSERT( !hndFileReg->IsNodeType(nodetypeRegRegistry) );
	ASSERT( !hndFileReg->IsNodeType(nodetypeRegFilter) );
#endif

	// Already exists in set....return
	if (RegHandleExists(hndFileReg))
		return TRUE;

#ifdef REFCOUNT_WORK
	// Reference held by this file set.
	hndFileReg->AddFRHRef();
#endif

	// This may result in new dependency update requests, so we must not be locking
	// the lists at this time.
	ASSERT(!g_sectionDepUpdateQ.FOwned());

	// Is the CFileRegEntry a CFileRegSet if so then we must
	// set up the associated file registry...
#ifndef REFCOUNT_WORK
	CFileRegSet * pFileRegSet = (CFileRegSet *)m_pFileRegistry->GetRegEntry(hndFileReg);
#else
	CFileRegSet * pFileRegSet = (CFileRegSet *)(NULL==m_pFileRegistry?g_FileRegistry.GetRegEntry(hndFileReg):m_pFileRegistry->GetRegEntry(hndFileReg));
#endif
	if (pFileRegSet->IsNodeType(nodetypeRegSet))
		pFileRegSet->SetFileRegistry(m_pFileRegistry);

	// Add the CFileRegEntry to the set
	if (bAddFront)
		m_Contents.AddHead(hndFileReg);
	else
		m_Contents.AddTail(hndFileReg);

	if (m_pmapContents == NULL && m_Contents.GetCount() >= cMapThreshold)
	{
		// We now have enough items to create a content map ... do so and fill it with
		// the items so far.
		m_pmapContents = new CMapPtrToWord;
		m_pmapContents->InitHashTable(m_nHashSizeMapContents);
		for (POSITION pos = m_Contents.GetHeadPosition(); pos != NULL; )
		{
			m_pmapContents->SetAt(m_Contents.GetNext(pos), 0);
		}
	}
	else if (m_pmapContents != NULL)
	{
		// ASSERT((UINT)m_pmapContents->GetCount() < ((UINT)m_pmapContents->GetHashTableSize() << 1)); // UNDONE
		m_pmapContents->SetAt(hndFileReg, 0);
	}

	// Increase the reference count on the CFileRegEntry item
#ifndef REFCOUNT_WORK
	if (bAddRef)
		m_pFileRegistry->AddRegRef(hndFileReg);
#endif
 
	// Add this set as a dependant of the item just added
	// and inform ourselves of this addition
 	hndFileReg->AddNotifyRx(this);
#ifndef REFCOUNT_WORK
	OnNotify(hndFileReg, FRN_ADD, 0);
#else
	if (m_fCalcAttrib)
	{
		FILETIME Time;
		FILETIME ChangedTime;

		// we're going to calculate attribs now, 
		// don't allow recursion
		m_fCalcAttrib = FALSE;

 		// Maintain our cache value of the number of items that
		// do not exist but are contained in us
		BOOL bExists;
		if (hndFileReg->GetIntProp(P_ExistsOnDisk, bExists))
		{
		// If this new file does not exist on disk then we
			// should not consider the file times it has set
			// as they don't mean anything!.
			if (bExists)
 			{
	 			if (!hndFileReg->GetTimeProp(P_NewTStamp, ChangedTime) || !GetTimeProp(P_NewTStamp, Time))
				{
					MakeDirty();
				}
				else
				{
					if (ChangedTime > Time)
						SetTimeProp(P_NewTStamp, ChangedTime);
				}
			}
			else
				m_nNotExists++; 

 			SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
		}
		else
		{
			MakeDirty();
		}

		m_fCalcAttrib = TRUE;
	}
	InformNotifyRxs(FRI_ADD, (DWORD)hndFileReg);
#endif
 	
	return TRUE;
}

BOOL CFileRegSet::RemoveRegHandle(FileRegHandle hndFileReg, BOOL bReleaseRef /* = TRUE */)
{
	ASSERT(hndFileReg);

	// Remove the CFileRegEntry from the set
	POSITION pos = m_Contents.Find(hndFileReg);
	if (pos != NULL)
		RemoveRegHandleI(hndFileReg, bReleaseRef);

	return TRUE;	// only return FALSE in error
}

void CFileRegSet::RemoveRegHandleI(FileRegHandle hndFileReg, BOOL bReleaseRef /* = TRUE */)
{
	// Remove us as a dependant of the item just removed
	hndFileReg->RemoveNotifyRx(this);

#ifndef REFCOUNT_WORK
	// Notify the container that we have removed the item.
	// This gives us a chance to update things like the
	// newest/oldest time and the exists on disk props.
	OnNotify(hndFileReg, FRN_DESTROY, 0);

	// Decrease the reference count on the CFileRegEntry item
	// NOTE: This must be the last reference in this function
	// to the hndFileReg, as this call may force its self
	// destruction
	if (bReleaseRef)
		m_pFileRegistry->ReleaseRegRef(hndFileReg);
#else

	POSITION pos = m_Contents.Find(hndFileReg);
	ASSERT(pos != (POSITION)NULL);
	if (pos != (POSITION)NULL)
		m_Contents.RemoveAt(pos);
	else
		return; /* FALSE */

	//
	// Notify dependents this handle is being destroyed.
	InformNotifyRxs(FRI_DESTROY, (DWORD)hndFileReg);

	// If the item being destroyed is still in us then remove it.
 	if (m_pmapContents != NULL)
	{
		VERIFY(m_pmapContents->RemoveKey(hndFileReg));
	}

	// calculate new attrib?
	if (m_fCalcAttrib)
	{
		FILETIME Time;
		FILETIME ChangedTime;

		// we're going to calculate attribs now, 
		// don't allow recursion
		m_fCalcAttrib = FALSE;

		// Maintain our cache value of the number of items that
		// do not exist but are contained in us
		BOOL bExists;
		if (hndFileReg->GetIntProp(P_ExistsOnDisk, bExists))
		{
			if (!bExists)
			{
				ASSERT(m_nNotExists > 0);
				m_nNotExists--;
			}
			else
			{
				// If the item being destroyed does not exist on
				// disk then it cannot influence our cached new and
				// old time stamps for the set.
				if (bExists && !g_bInProjClose )
				{		 			
					if (!GetTimeProp(P_NewTStamp, Time) || !hndFileReg->GetTimeProp(P_NewTStamp, ChangedTime))
					{
						MakeDirty();
					}
					else
					{
 						// If the item going away is currently our newest time stamped item
						// then we have to find a new newest time stamped item in our set
						if (ChangedTime==Time)
		 					FindTimeAndExists(P_NewTStamp);
					}
				}
			}

			SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
		}
		else
		{
 			MakeDirty();
		}


		m_fCalcAttrib = TRUE;
	}

	// Release reference held by this file set.
	hndFileReg->ReleaseFRHRef();

	return; /* TRUE */
#endif
}

// This routine cannot be called 
// during project destruction or it will assert.
void CFileRegSet::EmptyContent(BOOL bReleaseRef /* = TRUE */)
{
	// Empty our contents
	POSITION pos = m_Contents.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		POSITION posCurr = pos;
		FileRegHandle hndFileReg = (FileRegHandle)m_Contents.GetNext(pos);

#ifndef REFCOUNT_WORK
		// Do what we do for CFileRegSet::RemoveRegHandleI()
		// but don't have the container rx a FRN_DESTROY
		hndFileReg->RemoveNotifyRx(this);

		if (bReleaseRef)
			m_pFileRegistry->ReleaseRegRef(hndFileReg);

		// in place of FRN_DESTROY doing this for us
		m_Contents.RemoveAt(posCurr);
		if (m_pmapContents != NULL)
		{
			m_pmapContents->RemoveKey(hndFileReg);
		}
#else
		RemoveRegHandle(hndFileReg);
#endif
	}

	// Set the default property values for an empty set
	FILETIME NewestTime;
	
	// Newest date
	NewestTime.dwLowDateTime = 0;
	NewestTime.dwHighDateTime = 0;

	// Set is empty then it exists...
	SetIntProp(P_ExistsOnDisk, TRUE);
 
	// Set the default property values
	SetTimeProp(P_NewTStamp, NewestTime);

	//  Initialize private cache helping members
	m_nNotExists = 0;
}

#ifndef REFCOUNT_WORK
void CFileRegSet::ReplaceContent(CPtrList * plstContent, BOOL fAddRef /* = TRUE */)
{
}
#endif

BOOL CFileRegSet::CalcAttributes(BOOL fOn /* = TRUE */)
{
	BOOL fOldOn = m_fCalcAttrib;

	// different to old value?
	if (fOn != fOldOn)
	{
		// setting back on?
		if (!fOldOn)
			(void)RefreshAttributes();		// refresh our attributes if changed on

		m_fCalcAttrib = fOn;
	}

	return fOldOn;
}

BOOL CFileRegSet::DoRefresh()
{
	// updating?
	if ((!m_bUpdateAttribs) || (g_bInProjLoad))
		return FALSE;	// no

	// base-class refresh?
	if (CFileRegEntry::DoRefresh())
		return TRUE;	// yes

 	POSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
		if (((FileRegHandle)m_Contents.GetNext(pos))->DoRefresh())
			return TRUE;	// yes

	return FALSE;	// no
}

BOOL CFileRegSet::UpdateAttributes()
{
	if ( g_bInProjLoad )
		return TRUE;

	BOOL fRefreshed = FALSE;
 	POSITION pos = m_Contents.GetHeadPosition();
	while (pos != (POSITION)NULL)
		if (g_FileRegistry.GetRegEntry((FileRegHandle)m_Contents.GetNext(pos))->UpdateAttributes())
			fRefreshed = TRUE;
					 
	return TRUE;	// ok
}

BOOL CFileRegSet::RefreshAttributes()
{
	// No longer dirty
	m_bDirty = FALSE;
	
	// Refreshing the attributes on a set means updating,
	// ie. a refresh if dirty, the attributes of
	// all referenced CFileRegEntry items
	// contained, and then doing a sweep to find our 
	// accumulative attributes

	// Find the number that exist
	// Set both the oldest and newest timestamp props.
	// This function will ensure that all props. are updated
	// for each of our contents
	FindTimeAndExists(P_NewTStamp,TRUE);

	return TRUE;	// performed refresh
}

void CFileRegSet::FindTimeAndExists(UINT idProp, BOOL bFindExists)
{
	BOOL fOldOn = m_fCalcAttrib;
	m_fCalcAttrib = FALSE;

	BOOL fFindNew = idProp == P_NewTStamp;

	ASSERT(fFindNew);

	FILETIME NewTime, CurrentTime;
 	BOOL bExistsOnDisk = FALSE;
	unsigned nNotExists = 0;

	NewTime.dwLowDateTime = NewTime.dwHighDateTime = 0;

	POSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		FileRegHandle hndFileReg = (FileRegHandle)m_Contents.GetNext(pos);
		if (hndFileReg->GetIntProp(P_ExistsOnDisk, bExistsOnDisk))
		{
			if (bExistsOnDisk)
			{
				// is this a set?
				if (hndFileReg->IsNodeType(nodetypeRegSet))
				{	
					// for sets, figure out the oldest, newest times or both
					if (fFindNew &&
						hndFileReg->GetTimeProp(P_NewTStamp, CurrentTime) &&
						(MyCompareFileTime(&CurrentTime, &NewTime) > 0)
					   )
						NewTime = CurrentTime;
				}
				else
				{
					// for files new time == old time....
					if (!hndFileReg->GetTimeProp(P_NewTStamp, CurrentTime))
						continue;

					// figure out the oldest, newest times or both
					if (fFindNew &&
						(MyCompareFileTime(&CurrentTime, &NewTime) > 0)
					   )
 						NewTime = CurrentTime;
				}
			}
			else
			{
				nNotExists++;
			}
		}
		else
		{
			MakeDirty();
		} 
 	}

	m_fCalcAttrib = fOldOn;

	// set the oldest, newest times or both
	if (fFindNew)	SetTimeProp(P_NewTStamp, NewTime);

	//
	// Update "exists" attributes.
	if (bFindExists)
	{
		m_nNotExists = nNotExists;
		SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
	}
}

void CFileRegSet::FindExists()
{
	BOOL fOldOn = m_fCalcAttrib;
	m_fCalcAttrib = FALSE;

	unsigned nNotExists = 0;

	// get the prop. for each of our contents
 	POSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		FileRegHandle hndFileReg = (FileRegHandle) m_Contents.GetNext(pos);
	
		// This function will ensure that all props. are updated
		// for each of our contents
		BOOL bExists;
		VERIFY(hndFileReg->GetIntProp(P_ExistsOnDisk, bExists));
		if (!bExists)
			nNotExists++;
	}

	m_fCalcAttrib = fOldOn;

	// set whether all our contents exist or not
	m_nNotExists = nNotExists;
	SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
}

BOOL CFileRegSet::Touch()
{
	BOOL bRetVal = TRUE;

	// get the prop. for each of our contents
 	POSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		FileRegHandle hndFileReg = (FileRegHandle) m_Contents.GetNext(pos);
		bRetVal = bRetVal && hndFileReg->Touch();
	}

	return bRetVal;
}

void CFileRegSet::DeleteFromDisk()
{
	// get the prop. for each of our contents
 	POSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		FileRegHandle hndFileReg = (FileRegHandle) m_Contents.GetNext(pos);
		hndFileReg->DeleteFromDisk();
	}
}

void CFileRegSet::OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint)
{
	FILETIME Time;
	FILETIME ChangedTime;

	ASSERT(hndFileReg);

	// Handle notifications about content changes here
	switch (idChange)
	{
 		case P_NewTStamp:
 		{
			// calculate new attrib?
			if (!m_fCalcAttrib)
				break;	// no

			FILETIME * pPreviousTime = (FILETIME *)dwHint;
 
			if( !g_bInProjClose ){
				if (GetTimeProp(P_NewTStamp, Time) && hndFileReg->GetTimeProp(P_NewTStamp, ChangedTime))
				{
					// If the changed time is newer than the current newest time then set
					// the newest time to be the changed time
					// If the changed time is older than the current newest time and the
					// time that changed was the newest time then we have to search the
					// set to find the newest time
					if (MyCompareFileTime(&ChangedTime, &Time) >= 0)
						SetTimeProp(P_NewTStamp, ChangedTime);
	
					else if (MyCompareFileTime(pPreviousTime, &Time) == 0)
						FindTimeAndExists(P_NewTStamp);
				}
				else
				{ 
					MakeDirty();
				}
			}
 			break;
		}

		case P_ExistsOnDisk:
		{
			// calculate new attrib?
			if (!m_fCalcAttrib)
				break;	// no

			// find whether we exist
			FindExists();
			break;
		}

#ifndef REFCOUNT_WORK
		case FRN_LCL_DESTROY:

			// Only do a FRN_DESTROY if it a local destroy in us
			if ((CFileRegistry *)dwHint != m_pFileRegistry)
				return;	// ignore completely

			// Remove us as a dependant of the item just removed
			hndFileReg->RemoveNotifyRx(this);

		// Fall thru'

		case FRN_DESTROY:
		{
			// If the item being destroyed is still in us then remove it.
			POSITION pos = m_Contents.Find(hndFileReg);
			if (pos != (POSITION)NULL)
				m_Contents.RemoveAt(pos);
 
 			if (m_pmapContents != NULL)
			{
				VERIFY(m_pmapContents->RemoveKey(hndFileReg));
			}

			// calculate new attrib?
			if (!m_fCalcAttrib)
				break;	// no

			// we're going to calculate attribs now, 
			// don't allow recursion
			m_fCalcAttrib = FALSE;

			// Maintain our cache value of the number of items that
			// do not exist but are contained in us
			BOOL bExists;
			if (hndFileReg->GetIntProp(P_ExistsOnDisk, bExists))
			{
				if (!bExists)
				{
					ASSERT(m_nNotExists > 0);
					m_nNotExists--;
				}

				SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
			}
			else
			{
 				MakeDirty();
				goto End_FRN_DESTROY;
			}

			// If the item being destroyed does not exist on
			// disk then it cannot influence our cached new and
			// old time stamps for the set.
			if (bExists && !g_bInProjClose )
			{		 			
				if (!GetTimeProp(P_NewTStamp, Time) || !hndFileReg->GetTimeProp(P_NewTStamp, ChangedTime))
				{
					MakeDirty();
					goto End_FRN_DESTROY;
				}
 				
 				// If the item going away is currently our newest time stamped item
				// then we have to find a new newest time stamped item in our set
				if (MyCompareFileTime(&ChangedTime, &Time) == 0)
		 			FindTimeAndExists(P_NewTStamp);
			}

  		End_FRN_DESTROY:

			m_fCalcAttrib = TRUE;
			break;
		}

		case FRN_ADD:
		{
			// calculate new attrib?
			if (!m_fCalcAttrib)
				break;	// no

			// we're going to calculate attribs now, 
			// don't allow recursion
			m_fCalcAttrib = FALSE;

 			// Maintain our cache value of the number of items that
			// do not exist but are contained in us
			BOOL bExists;
			if (hndFileReg->GetIntProp(P_ExistsOnDisk, bExists))
			{
				if (!bExists)
					m_nNotExists++; 

 				SetIntProp(P_ExistsOnDisk, m_nNotExists == 0);
			}
			else
			{
				MakeDirty();
				goto End_FRN_ADD;
			}

			// If this new file does not exist on disk then we
			// should not consider the file times it has set
			// as they don't mean anything!.
			if (bExists)
 			{
	 			if (!hndFileReg->GetTimeProp(P_NewTStamp, ChangedTime) || !GetTimeProp(P_NewTStamp, Time))
				{
					MakeDirty();
					goto End_FRN_ADD;
				}

				if (MyCompareFileTime(&ChangedTime, &Time) > 0)
					SetTimeProp(P_NewTStamp, ChangedTime);
			}

		End_FRN_ADD:

			m_fCalcAttrib = TRUE;

 			break;
		}
#endif //ifndef REFCOUNT_WORK

 		case FRN_ALL:
		{
			MakeDirty();
			break;
		}
 	}

#ifndef REFCOUNT_WORK
	// propagate inform?
	if( m_Dependants.GetSize() ) {
		if (idChange & INF_MASK)
			InformNotifyRxs(idChange, dwHint);
		else if (idChange <= FRN_LAST) { // send as an inform?
			InformNotifyRxs(idChange | INF_MASK , (DWORD)hndFileReg);
		}
	}
#endif
}

BOOL CFileRegSet::GetTimeProp(UINT idProp, FILETIME& ftime)
{
	// Get a time property value
	if( g_bInProjClose ){
		ftime.dwLowDateTime = 0xffffffff;
		ftime.dwHighDateTime = 0x7fffffff;
		return TRUE;
	}
	
	(void)UpdateAttributes();
 
	switch (idProp)
	{
		case P_NewTStamp:
			ftime = m_NewTime;
			break;

		default:
			TRACE1("Unhandled GetTimeProp(%d)!\n", idProp);
			return FALSE;
	}

	return TRUE;
}

BOOL CFileRegSet::SetTimeProp(UINT idProp, FILETIME ftime)
{
 	// Set a time property value
 	FILETIME oldtime;
 	switch (idProp)
	{
		case P_NewTStamp:
			oldtime = m_NewTime;
			m_NewTime = ftime;
			break;

		default:
			TRACE1("Unhandled SetTimeProp(%d)!\n", idProp); 
			return FALSE;
	}

	// any change?
	if (oldtime.dwLowDateTime != ftime.dwLowDateTime ||
		oldtime.dwHighDateTime != ftime.dwHighDateTime
	   )
		if (!g_bInProjLoad) // skip this during project load
		{
			// notify our dependants that a time property value has changed
			InformNotifyRxs(idProp, (DWORD)&oldtime);
		}

	return TRUE;
}

#ifdef _DEBUG
void CFileRegSet::Dump(CDumpContext& dc) const
{
	// Call our base class first
	CFileRegEntry::Dump(dc);

	// Now do the stuff for our specific class
	dc << "{CFileRegSet:";
	if (m_Contents.IsEmpty())
	{
		dc << "m_Contents is <empty>";
	}
	else
	{
		dc << "m_Contents list:";

		int i = 0;

		// Dump the contents list
		POSITION pos = m_Contents.GetHeadPosition();
		while (pos != NULL)
		{
			FileRegHandle hndFileReg = (FileRegHandle) m_Contents.GetNext(pos);
			dc << "\n\t<" << i << "> ";
			hndFileReg->Dump(dc);
			i++;
		}
	}
	dc << "\nm_pFileRegistry@" << (void*)m_pFileRegistry << "}";
}
#endif

#ifdef REFCOUNT_WORK
void CFileRegSet::SetFileRegistry(CFileRegistry * pFileRegistry)
{
	// This should be a one time only operation.
//	ASSERT( IsEmpty() );

	if (NULL!=pFileRegistry)
	{
		POSITION pos = m_Contents.GetHeadPosition();
		while (NULL!=pos)
		{
			FileRegHandle frh = (FileRegHandle)m_Contents.GetNext(pos);
			pFileRegistry->AddRegRef(frh);
		}

		ASSERT(NULL==m_pFileRegistry);
		AddNotifyRx(pFileRegistry);
	}
	else if (NULL!=m_pFileRegistry)
	{
		RemoveNotifyRx(m_pFileRegistry);

		POSITION pos = m_Contents.GetHeadPosition();
		while (NULL!=pos)
		{
			FileRegHandle frh = (FileRegHandle)m_Contents.GetNext(pos);
			m_pFileRegistry->ReleaseRegRef(frh);
		}
	}
	else
	{
//		ASSERT(FALSE);
	}

	m_pFileRegistry = pFileRegistry;
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
//	CFileRegFilter

IMPLEMENT_DYNAMIC(CFileRegFilter, CFileRegSet)

CFileRegFilter::CFileRegFilter(CString strFilter)
{
	// Set our node type
	dwNodeType |= nodetypeRegFilter;

	m_strFilter = strFilter;
	m_strFilterLC = strFilter;
	m_strFilter.MakeUpper();
	m_strFilterLC.MakeLower();
}

CFileRegFilter::~CFileRegFilter()
{
	m_bUpdateAttribs = FALSE;	// don't attempt to update
 	m_fCalcAttrib = FALSE;		// don't re-calc attrib.

#ifndef REFCOUNT_WORK
	POSITION pos = m_Contents.GetHeadPosition();
	while (pos != NULL)
	{
		FileRegHandle hndFileReg = (FileRegHandle) m_Contents.GetNext(pos);
		
		// *don't* decr. the ref. count
		RemoveRegHandle(hndFileReg, FALSE);
	}

	// CFileRegSet::~CFileRegSet()
	// This does the same as above, but we do it first
	// so that it doesn't have any content to remove and *decr.* ref. count
	// which we don't want!
#endif
}

BOOL CFileRegFilter::Filter(LPCTSTR pszText)
{
	LPCTSTR pchLastText = NULL;
	LPCTSTR pchPat = m_strFilter;
	LPCTSTR pchPatLC = m_strFilterLC;
	int ichPat = 0, ichLastStar = -1;
	int c;

    if (theApp.GetCP() != 0)
	{
		// DBCS and German case
		LPCTSTR pchLastStar = NULL;
		while (*pchPat != _T('\0') && *pszText != _T('\0'))
		{
			if (*pchPat == _T('*'))
			{
				pchLastStar = pchPat;
				pchLastText = pszText;
			}
			else if (*pchPat == _T('?'))
			{
				pchPat = _tcsinc(pchPat);
			}
			else if (_tcsncicmp(pchPat,pszText,1)!=0) // handles DBCS correctly
			{
				if (pchLastStar != NULL)
				{
					pchPat = pchLastStar;
					pchLastText = _tcsinc(pchLastText);
					pszText = pchLastText;
				}
				else
					return FALSE;
			}
			else
				pszText = _tcsinc(pszText);

			pchPat = _tcsinc(pchPat);
		}
	}
	else
	{
		// optimized non-DBCS case (assumes no German ss/B in filters)
		ASSERT(m_strFilter.GetLength() == m_strFilterLC.GetLength());

		while ((*pszText != _T('\0')) && ((c = pchPat[ichPat]) != _T('\0')))
		{
			if (c == _T('*'))
			{
				ichLastStar = ichPat;
				pchLastText = pszText;
			}
			else if (c == _T('?'))
			{
				ichPat++;
			}
			else if ((c!=*pszText) && (pchPatLC[ichPat] != *pszText))
			{
				if (ichLastStar != -1)
				{
					ichPat = ichLastStar;
					pszText = ++pchLastText;
				}
				else
					return FALSE;
			}
			else
				pszText++;

			ichPat++;
		}
		pchPat += ichPat;
	}

	// at least one of these must be null to break out of loop
	ASSERT((*pchPat == _T('\0')) || (*pszText == _T('\0')));

	return (*pchPat == *pszText); // == _T('\0')
}

BOOL CFileRegFilter::AddRegHandle(FileRegHandle hndFileReg, BOOL bAddRef /* = TRUE */)
{
#ifndef REFCOUNT_WORK
	// Filters can only contain files
	ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegFile)));
	ASSERT(hndFileReg->IsNodeType(nodetypeRegFile));

	// Only add files that match our filter

	if (Filter(*((CFileRegFile*)hndFileReg)->GetFilePath()))
		// Filters do not addref their contents
		return CFileRegSet::AddRegHandle(hndFileReg, FALSE);
  	else
		return FALSE;
#else
	// This should never be called since the CFileRegistry should be 
	// managing the filter contents.
	ASSERT( FALSE );
	return FALSE;
#endif
}

BOOL CFileRegFilter::RemoveRegHandle(FileRegHandle hndFileReg, BOOL bReleaseRef /* = TRUE */)
{
#ifndef REFCOUNT_WORK
	// Filters do not addref their contents
	return CFileRegSet::RemoveRegHandle(hndFileReg, FALSE);
#else
	// This should never be called since the CFileRegistry should be 
	// managing the filter contents.
	ASSERT( FALSE );
	return FALSE;
#endif
}

#ifdef REFCOUNT_WORK
BOOL CFileRegFilter::AddFilterHandle(FileRegHandle hndFileReg)
{
	// Filters can only contain files
	ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegFile)));
	ASSERT(hndFileReg->IsNodeType(nodetypeRegFile));

	// Only add files that match our filter

	if (Filter(*((CFileRegFile*)hndFileReg)->GetFilePath()))
	{
#if 0
		ASSERT(NULL==m_Contents.Find(hndFileReg));
		VERIFY( m_Contents.AddTail(hndFileReg) );
		InformNotifyRxs(FRI_ADD, (DWORD)hndFileReg);
		return TRUE;
#else
		// Call base method.
		return CFileRegSet::AddRegHandle(hndFileReg);
#endif
	}
  	else
		return FALSE;
}

BOOL CFileRegFilter::RemoveFilterHandle(FileRegHandle hndFileReg)
{
	if (Filter(*((CFileRegFile*)hndFileReg)->GetFilePath()))
	{
		POSITION pos = m_Contents.Find(hndFileReg);
		ASSERT(NULL!=pos);
		if (NULL!=pos)
		{
#if 0
			m_Contents.RemoveAt(pos);
			InformNotifyRxs(FRI_DESTROY, (DWORD)hndFileReg);
			return TRUE;
#else
		// Call base method.
		return CFileRegSet::RemoveRegHandle(hndFileReg);
#endif
		}
	}
	return FALSE;
}
#endif

#ifdef _DEBUG
void CFileRegFilter::Dump(CDumpContext& dc) const
{
	// Call our base class function first
	CFileRegSet::Dump(dc);

	dc << "{CFileRegFilter:\"" << m_strFilter << "\"}";
}
#endif

#ifdef REFCOUNT_WORK

///////////////////////////////////////////////////////////////////////////////
//
//	CFileRegFilterSet

IMPLEMENT_DYNAMIC(CFileRegFilterSet, CFileRegSet)

CFileRegFilterSet::CFileRegFilterSet()
{
	dwNodeType |= nodetypeRegFilterSet;
}

CFileRegFilterSet::~CFileRegFilterSet()
{
#if 0
	//
	// Release references to CFileRegFilter's.
	//
	POSITION pos = m_FilterList.GetHeadPosition();

	while (NULL!=pos)
	{
		CFileRegFilter *pFilter = (CFileRegFilter*)m_FilterList.GetNext(pos);
		ASSERT(pFilter->IsNodeType(nodetypeRegFilter));
		pFilter->ReleaseFRHRef();
	}
#endif
}

void CFileRegFilterSet::OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint)
{
	FileRegHandle frh = (FileRegHandle)dwHint;
	switch (idChange)
	{
	case FRI_ADD:
		ASSERT( NULL!=m_FilterList.Find((void*)hndFileReg) );
		ASSERT(frh->IsNodeType(nodetypeRegFile));
		CFileRegSet::AddRegHandle(frh);
		break;

	case FRI_DESTROY:
		ASSERT( NULL!=m_FilterList.Find((void*)hndFileReg) );
		ASSERT(frh->IsNodeType(nodetypeRegFile));
		CFileRegSet::RemoveRegHandle(frh);
		break;

	default:
		CFileRegSet::OnNotify(hndFileReg, idChange, dwHint);
		break;
	}
}

BOOL CFileRegFilterSet::AddFilter( CFileRegFilter* pFilter )
{
	ASSERT(pFilter->IsNodeType(nodetypeRegFilter));
	ASSERT( NULL==m_FilterList.Find((void*)pFilter) );

	m_FilterList.AddTail(pFilter);
//	pFilter->AddFRHRef();

	pFilter->InitFrhEnum();

	// Add pFilter contents to CFileRegFilterSet contents.
	FileRegHandle frh = NULL;
	while (NULL!=(frh=pFilter->NextFrh()))
	{
		CFileRegSet::AddRegHandle(frh);
		frh->ReleaseFRHRef();
	}

	// Interested in FRI_ADD and FRI_DESTROY notifications from pFilter.
	pFilter->AddNotifyRx(this);

	return TRUE;
}

#endif //#ifdef REFCOUNT_WORK

///////////////////////////////////////////////////////////////////////////////
//
//	CFileRegFile

IMPLEMENT_DYNAMIC(CFileRegFile, CFileRegEntry)

ULONG	CFileRegFile::s_tickCurrent = 1;
#ifdef _DEBUG
ULONG	CFileRegFile::s_cFailedWatches = 0;
#endif

#ifdef REFCOUNT_WORK
#if 0
FileNameMap s_RegFileMap(911);
FileNameMap::FileNameMap(int nHashSize) : m_FileNameMap(16)
{
	m_FileNameMap.InitHashTable(nHashSize);
}

FileNameMap::~FileNameMap()
{
}
#endif

CGrowingMapStringToPtr*	CFileRegFile::s_pFileNameMap = NULL;
CFileRegFile::CInitMap s_InitRegFileMap;
CFileRegFile::CInitMap::CInitMap(int nHashSize)
{
	CFileRegFile::s_pFileNameMap = new CGrowingMapStringToPtr(16);
	CFileRegFile::s_pFileNameMap->InitHashTable(nHashSize);	// init our map too!
}

CFileRegFile::CInitMap::~CInitMap()
{
	// Prevent access to file map by other threads.
	CritSectionT cs(g_sectionFileMap);

#ifdef _DEBUG
	// delete file handles so we won't have memory leaks.
	POSITION pos = CFileRegFile::s_pFileNameMap->GetStartPosition();

	if (NULL!=pos)
		TRACE( "\nNote: Left over files may actually be held in global objects that haven't been deleted yet\n" );


	while(NULL!=pos)
	{
		CString strKey;
		FileRegHandle hndFileReg;
		CFileRegFile::s_pFileNameMap->GetNextAssoc(pos, strKey, (void*&) hndFileReg);
		ASSERT(NULL!=hndFileReg);
		TRACE( "\nLeft over file: " );
		AfxDump((CObject*)hndFileReg);

#ifdef PRESERVE_REGFILE
		if ( 0 == hndFileReg->GetRefCount() )
			delete hndFileReg;
#endif
	}
#endif
	delete CFileRegFile::s_pFileNameMap;
	CFileRegFile::s_pFileNameMap = NULL;
}


FileRegHandle CFileRegFile::GetFileHandle(LPCTSTR szFileName, LPTSTR szKeyName)
{
    TCHAR szKeyBuffer[MaxKeyLen];
	LPTSTR szKey = NULL;

	//
	// Allow user to specify storage for key so that it can be reused.
	//
	if (NULL==szKeyName)
		szKey = szKeyBuffer;
	else
		szKey = szKeyName;

	// Prevent access to file map by other threads.
	CritSectionT cs(g_sectionFileMap);

	FileRegHandle hndFileReg = LookupFileHandleByName(szFileName, szKey);

	if (NULL==hndFileReg)
	{
		CPath path;
		if (path.Create(szFileName))
		{
			CFileRegFile * pregfile = new CFileRegFile(&path);
			if (NULL!=pregfile)
			{
				hndFileReg = (FileRegHandle)pregfile;

				ASSERT(NULL!=s_pFileNameMap);
				if (NULL!=s_pFileNameMap)
					s_pFileNameMap->SetAt(szKey, hndFileReg);

				hndFileReg->AddFRHRef();
			}
		}
	}

	return hndFileReg;
}


FileRegHandle CFileRegFile::LookupFileHandleByName(LPCTSTR szFileName, LPTSTR szKeyName)
{
	FileRegHandle hndFileReg = NULL;
    TCHAR szKeyBuffer[MaxKeyLen];
	LPTSTR szKey = NULL;

	// No map no handle.
	if (NULL==s_pFileNameMap)
		return NULL;

	//
	// Allow user to specify storage for key so that it can be reused.
	//
	if (NULL==szKeyName)
		szKey = szKeyBuffer;
	else
		szKey = szKeyName;

	ASSERT(MaxKeyLen>_tcslen(szFileName));

	//
	// Key is uppercase full path name.
	// 
    _tcscpy(szKey, szFileName);
    _tcsupr(szKey);

	// Prevent access to file map by other threads.
	CritSectionT cs(g_sectionFileMap);

	s_pFileNameMap->Lookup(szKey,(void*&) hndFileReg);

	if (NULL!=hndFileReg)
		hndFileReg->AddFRHRef();

	return hndFileReg;
}


FileRegHandle CFileRegFile::LookupFileHandleByKey(LPCTSTR szKeyName)
{
	FileRegHandle hndFileReg = NULL;

	// No map no handle.
	if (NULL==s_pFileNameMap)
		return NULL;

	ASSERT(MaxKeyLen>_tcslen(szKeyName));

	// Prevent access to file map by other threads.
	CritSectionT cs(g_sectionFileMap);

	s_pFileNameMap->Lookup(szKeyName,(void*&) hndFileReg);

	if (NULL!=hndFileReg)
		hndFileReg->AddFRHRef();

	return hndFileReg;
}

void CFileRegFile::SafeDelete()
{
	// Prevent access to file map by other threads.
	CritSectionT cs(g_sectionFileMap);

	if (0==m_nRefCount)
		delete this;
}

#endif

CFileRegFile::CFileRegFile
(
	const CPath * pPath,
	BOOL bMatchCase /* = FALSE */,
	BOOL bFiltered /* = FALSE */
)
	: CFileRegEntry()
{
	// Set our node type
	dwNodeType |= nodetypeRegFile;
	m_nExistsOnDisk = TRUE;

	ASSERT(pPath->IsInit());
	m_Path = *pPath;
	ASSERT(0<_tcslen(m_Path.GetFullPath()));

#ifndef REFCOUNT_WORK
	m_bFiltered = bFiltered;
#endif
	
	m_bWantActualCase = (bMatchCase!=0);

	// Review: avoid setting case here if possible
	if (m_bMatchCase = (bMatchCase==TRUE)) // use bMatchCase = -1 to defer this
	{
		m_Path.GetActualCase();
	}
	m_bDirty = TRUE;
	m_bFileWatch = m_bFileAddedToFC = FALSE;
	m_tickFailedWatch = 0;	// haven't failed yet
}

CFileRegFile::~CFileRegFile()
{
#ifndef REFCOUNT_WORK
	{
		// Check if this frh is in the file change Q
		CritSectionT cs(g_sectionFileChangeQ);

		POSITION pos = g_FileChangeQ.GetHeadPosition();
		if (pos != (POSITION)NULL)
		{
			// refresh attributes for q'd files
			while (pos != (POSITION)NULL)
			{
				POSITION posCurr = pos;
				S_ATTRIB * pattrib = (S_ATTRIB *)g_FileChangeQ.GetNext(pos);

				// set from cache and then deallocate
				if (pattrib->_frh == (FileRegHandle)this)
				{
					// Remove this entry in the Q
					g_FileChangeQ.RemoveAt(posCurr);

					// FUTURE: release ref.?

					// de-allocate
					delete pattrib;
				}
			}
		}
	}
#endif

	// assynchronous file deletion?
	if (m_bFileAddedToFC)
#ifdef _BLD_SRC_FC_ASYNC
//#pragma message ("INFO : pfilereg.cpp : Using ASYNC file chng. add ....")
	{
		// asynchronous
		GetFileChange()->FDelFileAsync(m_Path, BldSrcFileChangeCallBack, NULL);
	}
#else // _BLD_SRC_FC_ASYNC
//#pragma message ("INFO : pfilereg.cpp : Using SYNC file chng. add ....")
	{
		ASSERT(0<_tcslen(m_Path.GetFullPath()));
		GetFileChange()->FDelFileAsync(m_Path, BldSrcFileChangeCallBack, NULL);
	}
#endif // !_BLD_SRC_FC_ASYNC

#ifdef REFCOUNT_WORK
	//
	// Remove from map (if map hasn't been destroyed yet during shutdown).
	//
	// No map no handle.
	if (NULL==s_pFileNameMap)
		return;

    TCHAR szKey[MAX_PATH];
    _tcscpy(szKey, *GetFilePath());
    _tcsupr(szKey);

	VERIFY(s_pFileNameMap->RemoveKey(szKey));
#endif
}

void
CFileRegFile::AllowRetryFailedWatches(BOOL fForceAll)
{
#ifdef _DEBUG
	// Failed watch calls are expensive because they cause us to try to stat()
	// files in nonexistent directories ... so monitor them.
	static ULONG cMaxFailedWatches = 10;			// arbitrary reporting limit
	if (s_cFailedWatches > cMaxFailedWatches + 10)	// arbitrary threshold
	{
		cMaxFailedWatches = s_cFailedWatches;
		TRACE("pfilereg.cpp: %lu failed AddWatch calls (this tick).\n", cMaxFailedWatches);
	}
	s_cFailedWatches = 0;
#endif
	// Bump the tick count so that attempts at watching files will be re-tried.
	s_tickCurrent += (fForceAll ? ctickRetryInterval : 1);
	if (s_tickCurrent == 0)
	{
		s_tickCurrent++;	// 0 is special, not a valid tick time
	}
}

BOOL CFileRegFile::WatchFile(BOOL & fRefreshed)
{
	BOOL fAddtoFC = !g_FileRegDisableFC && !m_bFileWatch && !m_bFileAddedToFC;
	fRefreshed = FALSE;

	// assynchronous file addition?
	if (fAddtoFC)
	{
#ifdef _BLD_SRC_FC_ASYNC
#ifndef _BLD_NO_FILE_CHNG
		// Make sure the file reg object hangs around
		AddFRHRef();

		if (FCanWatch() && GetFileChange()->
			FAddFileAsync(m_Path, BldSrcFileChangeCallBack, BldSrcFileAddedCallBack, (FileRegHandle)this, NULL, TRUE))
		{
			// asynchronous
			// do nothing, wait for async. notification
			m_bFileAddedToFC = TRUE;
			fRefreshed = TRUE;	// we will be in the async callback
		}
        else
#endif // _BLD_NO_FILE_CHNG
		{
			// Record that we failed, and when (will try again later).
			DEBUG_ONLY(s_cFailedWatches++);
			m_tickFailedWatch = s_tickCurrent;
            m_bDirty = TRUE;    // File change watch failed, so we'd
                                // better dirty ourselves so we get
                                // uptodate details from disk
		}

#else // _BLD_SRC_FC_ASYNC
#ifndef _BLD_NO_FILE_CHNG
		// we must not be locking the dep update list, since the file change thread
		// may need to add items to it.
		ASSERT(!g_sectionDepUpdateQ.FOwned());

#ifdef REFCOUNT_WORK
		ASSERT(0<_tcslen(m_Path.GetFullPath()));
#endif

		if (FCanWatch() && GetFileChange()->
			FAddFile(m_Path, BldSrcFileChangeCallBack, TRUE))
		{
			// synchronous
#ifdef REFCOUNT_WORK
			// file change thread reference.
//			AddFRHRef();
#endif
			m_bFileWatch = m_bFileAddedToFC = TRUE;
			fRefreshed = RefreshAttributes();
		}
        else
#endif // _BLD_NO_FILE_CHNG
		{
			// Record that we failed, and when (will try again later).
			DEBUG_ONLY(s_cFailedWatches++);
			m_tickFailedWatch = s_tickCurrent;
            m_bDirty = TRUE;    // File change watch failed, so we'd
                                // better dirty ourselves so we get
                                // uptodate details from disk
		}
#endif // !_BLD_SRC_FC_ASYNC	
	}

	return m_bFileWatch;	// now watched?
}

BOOL CFileRegFile::Touch()
{
	// This will cause the file change to be ignored. So things like the 
	// source editor will not get notified of the change.
	CIgnoreFile ignoreFile(GetFileChange(), m_Path);

	int fh = _utime ((LPCSTR)m_Path, NULL);
	if (fh == -1)
		return FALSE;
	return TRUE;
}

void CFileRegFile::DeleteFromDisk()
{
	// This will cause the file change to be ignored. So things like the 
	// source editor will not get notified of the change.
	m_Path.DeleteFromDisk();
	return;
}




BOOL CFileRegFile::GetFileTime(FILETIME& ft)
{
	(void)UpdateAttributes();
	return m_nExistsOnDisk && GetTimeProp(P_NewTStamp, ft);
}

BOOL CFileRegFile::GetFileTime(CString & str)
{
	FILETIME ft;
	if (GetFileTime(ft))
	{		 
		CTime time(ft);

		CString strTime = theApp.m_CPLReg.Format(time, TIME_ALL);
		CString strDate = theApp.m_CPLReg.Format(time, DATE_ALL);
		str = strTime + _TEXT(" ") + strDate;

		return TRUE;
	}

	return FALSE;
}

BOOL CFileRegFile::GetTimeProp(UINT idProp, FILETIME& ftime)
{
	// Get a time property value
	(void)UpdateAttributes();
 
	ASSERT(idProp == P_NewTStamp);
	ftime = m_FileTime;
 	return TRUE;
}

BOOL CFileRegFile::SetTimeProp(UINT idProp, FILETIME ftime)
{
 	if (idProp != P_NewTStamp )
	{
		TRACE1("Unhandled SetTimeProp(%d)!\n", idProp); 
 		return FALSE;
	}

 	FILETIME oldtime = m_FileTime;
 
	// any change?
	if (oldtime.dwLowDateTime != ftime.dwLowDateTime ||
		oldtime.dwHighDateTime != ftime.dwHighDateTime
	   )
	{
		m_FileTime = ftime;

		if (!g_bInProjLoad) // skip this during project load
		{
			// notify our dependants that a time property value has changed
			InformNotifyRxs(P_NewTStamp, (DWORD)&oldtime);
		}
	}

	return TRUE;
}

BOOL CFileRegFile::RefreshAttributes()
{
	// No longer dirty
	m_bDirty = FALSE;

	// Get the current file attributes
	S_ATTRIB attrib;
	GetAttributes(&attrib);

	// anything to do?
	if (m_FileTime.dwLowDateTime == attrib._filetime.dwLowDateTime &&
		m_FileTime.dwHighDateTime == attrib._filetime.dwHighDateTime &&
		m_nExistsOnDisk == attrib._fExists
	   )
		return FALSE;	// nothing to do

	// Set the new file attributes
 	SetAttributes(&attrib);

	// Ensure sequential access to file change Q
	CritSectionT cs(g_sectionFileChangeQ);

#ifndef REFCOUNT_WORK
	// Ensure sequential access to file map
	CritSectionT cs2(CFileRegistry::g_sectionFileMap);
#endif

	// Remove this file from our Q 'cos we have already sync'd!
	POSITION pos = g_FileChangeQ.GetHeadPosition();
	if (pos != (POSITION)NULL)
	{
		// refresh attributes for q'd files
		while (pos != (POSITION)NULL)
		{
			POSITION posCurr = pos;
			S_ATTRIB * pattrib = (S_ATTRIB *)g_FileChangeQ.GetNext(pos);

			// find the registry entry?
			if (pattrib->_frh == (FileRegHandle)this)
			{
				// remove
				g_FileChangeQ.RemoveAt(posCurr);

#ifdef _DEBUG
				const CPath * pPath = GetFilePath();
				TRACE("\nRemove in refresh '%s'", pPath->GetFileName());
#endif

				// FUTURE release ref.?
#ifdef REFCOUNT_WORK
				pattrib->_frh->ReleaseFRHRef();
#endif

				// de-allocate
				delete pattrib;
			}
		}
	}

	return TRUE;	// performed a refresh!
}

void CFileRegFile::SetAttributes(S_ATTRIB * pattrib)
{
 	// Are we being notified of changes on this
	// file?
 	ASSERT(pattrib->_fOk);
	{
	 	SetIntProp(P_ExistsOnDisk, pattrib->_fExists);
		SetTimeProp(P_NewTStamp, pattrib->_filetime);
	}
}

extern BOOL (WINAPI *g_pGetFileAttributesEx_DevBld)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx_DevBld( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx_DevBld)( lpFileName, fInfoLevelId, lpFileInformation);
}

void CFileRegFile::GetAttributes(S_ATTRIB * pattrib)
{
	if ((!m_bMatchCase) && (m_bWantActualCase))
	{
		WIN32_FIND_DATA find;
		HANDLE hfind = ::FindFirstFile((LPCTSTR)m_Path, &find);

		pattrib->_fOk = TRUE;
		if (hfind != INVALID_HANDLE_VALUE)
		{
			VERIFY(::FindClose(hfind));

			pattrib->_filetime = find.ftLastWriteTime;
			pattrib->_fExists = TRUE;

			m_Path.SetActualCase(find.cFileName);
		}
		else
		{
			pattrib->_filetime.dwLowDateTime = pattrib->_filetime.dwHighDateTime = 0;	// none
			pattrib->_fExists = FALSE;
		}
	}
	else
	{
		WIN32_FILE_ATTRIBUTE_DATA find;

		pattrib->_fOk = TRUE;
		if (Compatible_GetFileAttributesEx_DevBld( (LPCTSTR)m_Path, GetFileExInfoStandard, &find))
		{
			pattrib->_filetime = find.ftLastWriteTime;
			pattrib->_fExists = TRUE;
		}
		else
		{
			pattrib->_filetime.dwLowDateTime = pattrib->_filetime.dwHighDateTime = 0;	// none
			pattrib->_fExists = FALSE;
		}
	}
}

void CFileRegFile::SetMatchCase(BOOL bMatchCase, BOOL bCaseApproved /*=FALSE*/)
{
	if (!bCaseApproved && (!m_bMatchCase && bMatchCase))
 		m_Path.GetActualCase();

	m_bWantActualCase = bMatchCase;
	m_bMatchCase = bMatchCase;
}

BOOL CFileRegFile::UpdateAttributes()
{
	// if not dirty and not updating dep, can we rely on file watching?
	BOOL fRefreshed = FALSE;
	if (!m_bDirty && !g_bUpdateDep && FCanWatch() && WatchFile(fRefreshed))
		return fRefreshed;	// update performed if refreshed during watch

	// no, so do we'll have to maybe do it
 	return CFileRegEntry::UpdateAttributes();
}

#ifdef _DEBUG
void CFileRegFile::Dump(CDumpContext& dc) const
{
	// Call our base class function first
	CFileRegEntry::Dump(dc);

	dc << "{CFileRegFile:" << m_Path.GetFullPath();
 	dc << ";ExistsOnDisk: " << m_nExistsOnDisk;
#ifndef REFCOUNT_WORK
 	dc << ";Relative: " << m_bRelative;
#endif
	dc << ";MatchCase: " << m_bMatchCase;
	dc << ";WantActualCase: " << m_bWantActualCase;
	dc << "}";
}
#endif

/////////////////////////////////////////////////////////////////////////////
//
//	CFileRegistry

IMPLEMENT_DYNAMIC(CFileRegistry, CFileRegSet)

CFileRegistry::CFileRegistry(int nHashSize)
#ifdef REGISTRY_FILEMAP
	: CFileRegSet(nHashSize), m_FileMap(16)
#else
	: CFileRegSet(nHashSize)
#endif
{
	// Set our node type
	dwNodeType |= nodetypeRegRegistry;

	// Set up the file registry pointer
	m_pFileRegistry = this;

	// We must have a contents map because we use it for reference counting.
	m_pmapContents = new CMapPtrToWord;
	m_pmapContents->InitHashTable(nHashSize, FALSE);	// set hash size as requested
#ifdef REGISTRY_FILEMAP
	// FUTURE: tune size (may be too big)
	m_FileMap.InitHashTable(nHashSize);	// init our map too!
#endif

	// jimsc 10-21-96 If this is a java or static lib project, then we don't care about
	// how many of these things get entered. 

	m_fCareAboutRCFiles = TRUE;
	m_fCareAboutDefFiles = TRUE;
	CProject *pProj = (CProject *) g_BldSysIFace.GetActiveBuilder ();
	if (pProj)
	{
		CProjType * pProjType = pProj->GetProjType();

		if (pProjType && pProjType->GetUniqueTypeId() == CProjType::javaapplet )
		{
			m_fCareAboutRCFiles = FALSE;
			m_fCareAboutDefFiles = FALSE;
		}
		else
		{
			m_fCareAboutRCFiles = pProj->m_bCareAboutRCFiles;
			m_fCareAboutDefFiles = pProj->m_bCareAboutDefFiles;
		}
	}


#ifdef _DEBUG
	// Used by CFileRegistry::AssertValid
	m_bAssertValidCalled = FALSE;
#endif
}

CFileRegistry::~CFileRegistry()
{
#ifndef REFCOUNT_WORK
	// Only clean up the global file registry
	if (this != &g_FileRegistry)
		return;

	// Delete any remaining file reg entries, although there really
	// shouldn't be any at this point.
	DeleteAll();

#ifdef _BLD_REG_HISTORY
	// Remove all ref counting histories
	FileRegHandle frh;
	CFRHHistory * pHistory;
	pos = m_mapFRHHistory.GetStartPosition();
	while (pos != NULL)
	{
		m_mapFRHHistory.GetNextAssoc(pos, (void *&)frh, (void *&)pHistory);
		delete pHistory;
	}
	m_mapFRHHistory.RemoveAll();
#endif

#else //ifndef REFCOUNT_WORK

#ifdef _DEBUG
	if (!IsEmpty() )
		AfxDump(this);
#endif
	ASSERT( IsEmpty() );

	// Remove filters.
	POSITION pos0 = m_FilterMap.GetStartPosition();
	while(NULL!=pos0)
	{
		FileRegHandle frh0;
		CString strKey;
		m_FilterMap.GetNextAssoc(pos0, strKey, (void*&)frh0);
		if (frh0->IsNodeType(nodetypeRegFilter))
		{
			delete frh0;
		}
		else if (frh0->IsNodeType(nodetypeRegFilterSet))
		{
			delete frh0;
		}
		else
		{
			// Must be a CFileRegFilter or CFileRegSet containing filters.
			ASSERT(FALSE);
		}
	}

#endif //ifndef REFCOUNT_WORK
}

// olympus 16 (briancr)
// Provide mechanism for clearing file registry. Theoretically, this
// shouldn't be needed, since each FRH is deleted when its ref count
// gets to zero.
// Warning: Calling this function other than when a CFileRegistry object
// is being deleted may have ill side-effects. Specifically, if there is an
// FRH cached somewhere and it's later used to look up something in
// the CFileRegistry, the lookup will fail, or worse, return bogus info.
#ifndef REFCOUNT_WORK
void CFileRegistry::DeleteAll(void)
{
#ifdef _DEBUG
	const char* const THIS_FUNCTION = "CFileRegistry::DeleteAll";
#endif

	// Clear the scanner cache
	// The scanner cache must be cleared before the FRHs are deleted from m_Contents
	g_ScannerCache.Clear();

	// Delete all entries from m_Contents
#ifdef _DEBUG
	int nCount = m_Contents.GetCount();
	if (nCount > 0) {
		TRACE("%s: deleting %d still referenced file reg entries from m_Contents.\n", THIS_FUNCTION, nCount);
	}
#endif

	// Remove any file reg entries that still exist, by destroying them
	// completely. NOTE: Removing them from our containment list is not
	// enough, as they may have ref counts that are higher than 1 and
	// will cause them to stay around, causing memory leaks.
	POSITION pos;
	for ( pos = m_Contents.GetHeadPosition(); pos != (POSITION)NULL; ) {
		FileRegHandle hndFileReg = (FileRegHandle)m_Contents.GetNext(pos);
		delete hndFileReg;
	}
	m_Contents.RemoveAll();

	// Delete all entries from m_pmapContents
#ifdef _DEBUG
	nCount = m_pmapContents->GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from m_pmapContents.\n", THIS_FUNCTION, nCount);
	}
#endif
	m_pmapContents->RemoveAll();

	// Delete all entries from m_filelistDEF
#ifdef _DEBUG
	nCount = m_filelistDEF.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from m_filelistDEF.\n", THIS_FUNCTION, nCount);
	}
#endif
	m_filelistDEF.RemoveAll();

	// Delete all entries from m_filelistODL
#ifdef _DEBUG
	nCount = m_filelistODL.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from m_filelistODL.\n", THIS_FUNCTION, nCount);
	}
#endif
	m_filelistODL.RemoveAll();

	// Delete all entries from m_filelistRC
#ifdef _DEBUG
	nCount = m_filelistRC.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from m_filelistRC.\n", THIS_FUNCTION, nCount);
	}
#endif
	m_filelistRC.RemoveAll();

	// Delete all entries from m_LocalFileRegs
#ifdef _DEBUG
	nCount = m_LocalFileRegs.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from m_LocalFileRegs.\n", THIS_FUNCTION, nCount);
	}
#endif
	m_LocalFileRegs.RemoveAll();

	// Delete all entries from m_FileMap
#ifdef _DEBUG
	nCount = m_FileMap.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from m_FileMap.\n", THIS_FUNCTION, nCount);
	}
#endif
	m_FileMap.RemoveAll();

	// Delete all entries from m_FilterMap
#ifdef _DEBUG
	nCount = m_FilterMap.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from m_FilterMap.\n", THIS_FUNCTION, nCount);
	}
#endif
	m_FilterMap.RemoveAll();

	// Delete all entries from g_FileChangeQ
#ifdef _DEBUG
	nCount = g_FileChangeQ.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from g_FileChangeQ.\n", THIS_FUNCTION, nCount);
	}
#endif
	// "new'd" structs on this list must be freed!
	while ( !g_FileChangeQ.IsEmpty() ) {
		S_ATTRIB * ptr = (S_ATTRIB *) g_FileChangeQ.GetHead();
		delete ptr;
		g_FileChangeQ.RemoveHead();
	}
	g_FileChangeQ.RemoveAll();

	// Delete all entries from g_FileDepUpdateListQ
#ifdef _DEBUG
	nCount = g_FileDepUpdateListQ.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from g_FileDepUpdateListQ.\n", THIS_FUNCTION, nCount);
	}
#endif
	g_FileDepUpdateListQ.RemoveAll();

	// Delete all entries from g_FileForceUpdateListQ
#ifdef _DEBUG
	nCount = g_FileForceUpdateListQ.GetCount();
	if (nCount > 0) {
		TRACE("%s: removing %d entries from g_FileForceUpdateListQ.\n", THIS_FUNCTION, nCount);
	}
#endif
	g_FileForceUpdateListQ.RemoveAll();
}
#endif //ifndef REFCOUNT_WORK
// end olympus 16 fix

FileRegHandle CFileRegistry::RegisterFile
(
	const CPath* pPath,
	BOOL bMatchCase /* = FALSE */,
	BOOL bNoFilter /* = TRUE */
)
{
	if (!pPath->IsInit())
	{
		ASSERT(FALSE);				// caller shouldn't allow this
		return (FileRegHandle)NULL;	// can't do
	}

	// Lookup file in the global file registry thing
	// If its's there then get its FileRegHandle
	// otherwise create a new CFileRegFile item
	// and get its FileRegHandle
	FileRegHandle hndFileReg = NULL;
    TCHAR szKey[MAX_PATH];

#ifndef REFCOUNT_WORK
    _tcscpy(szKey, *pPath);
    _tcsupr(szKey);

	// Ensure sequential access to file map
	{
		CritSectionT cs(g_sectionFileMap);
		g_FileRegistry.m_FileMap.Lookup(szKey,(void*&) hndFileReg);
	}

	if( this != &g_FileRegistry ){
#ifdef _DEBUG
		// Save for comparison with handle returned by g_FileRegistry.RegisterFile.
		FileRegHandle tmpFRH = hndFileReg;
#endif
		hndFileReg = g_FileRegistry.RegisterFile( pPath, bMatchCase, bNoFilter );

#ifdef _DEBUG
		// g_FileRegistry.RegisterFile should return existing handle.
        if( tmpFRH != NULL )
			ASSERT( tmpFRH==hndFileReg );
#endif
	}

	if (hndFileReg == NULL)
	{
		ASSERT( this == &g_FileRegistry );

		// Should not already be in this registry.
		ASSERT( NULL == LookupFile((LPCTSTR)*pPath) );

#ifdef _DEBUG
		if ( !m_bAssertValidCalled )
		{
			ASSERT_VALID( this );
			m_bAssertValidCalled = TRUE; // Can't be done in AssertValid
		}
#endif

		// Require filtered?
		CFileRegFile * pregfile = new CFileRegFile(pPath, bMatchCase, !bNoFilter);

		{
			CritSectionT cs(g_sectionFileMap);
			m_FileMap.SetAt(szKey, hndFileReg = (FileRegHandle)pregfile);
		}
		AddRegHandle(hndFileReg);
	}
	else
	{
		// Check to see if we are trying to register
		// a file that is already registered with this
		// file registry. If so then we fail the
		// registration
		// UNDONE (colint): Irrelevant
        // VERIFY(m_FileMap.Lookup(szKey, (void*&)hndFileReg));
 		FileRegHandle hndTemp;
		// Don't do a 2nd LookupFile if this is g_FileRegistry.
		if (this == &g_FileRegistry)
			hndTemp = hndFileReg;
		else
 			hndTemp = LookupFile((LPCTSTR)*pPath);

		if (hndTemp == NULL)
		{
#ifdef _DEBUG
			if ( !m_bAssertValidCalled )
			{
				ASSERT_VALID( this );
				m_bAssertValidCalled = TRUE; // Can't be done in AssertValid
			}
#endif

			ASSERT( &g_FileRegistry != this );

 			// Require filtered?
			{
 				CritSectionT cs(g_sectionFileMap);
	 			m_FileMap.SetAt(szKey, hndFileReg);
			}

			((CFileRegFile *)hndFileReg)->m_bFiltered = !bNoFilter;
 			AddRegHandle(hndFileReg);
		}
		else
			AddRegRef(hndFileReg);

		hndFileReg->SetMatchCase(bMatchCase);
   	}
#else
	hndFileReg = CFileRegFile::GetFileHandle(*pPath, szKey);
	if (NULL!=hndFileReg)
	{
		AddRegRef(hndFileReg);
		hndFileReg->SetMatchCase(bMatchCase);
		hndFileReg->ReleaseFRHRef();
	}
#endif //#ifndef REFCOUNT_WORK

	return hndFileReg;
}

#ifndef REFCOUNT_WORK
void CFileRegistry::AllowAccess(CFileRegistry* pfreg)
{
	POSITION pos = m_LocalFileRegs.Find(pfreg);
	if (pos == (POSITION)NULL)
		m_LocalFileRegs.AddTail(pfreg);
}

BOOL CFileRegistry::DisallowAccess(CFileRegistry* pfreg)
{
	POSITION pos = m_LocalFileRegs.Find(pfreg);
	if (pos != (POSITION)NULL)
	{
		m_LocalFileRegs.RemoveAt(pos);
		return TRUE;
	}
	return FALSE;
}
#endif //ifndef REFCOUNT_WORK

#ifndef REFCOUNT_WORK
BOOL CFileRegistry::RemoveFile(const CPath* pPath)
{
	// Ensure sequential access to file map
	CritSectionT cs(g_sectionFileMap);

	// Lookup the file in this file registry
	// If it exists then we can remove it	
	FileRegHandle hndFileReg;

	ASSERT(pPath->IsInit());

    TCHAR szKey[MAX_PATH];
    _tcscpy(szKey, *pPath);
    _tcsupr(szKey);

	BOOL fRet = FALSE;
 
 	if (m_FileMap.Lookup(szKey, (void*&)hndFileReg))
	{
		// remove from map and from our set
 		m_FileMap.RemoveKey(szKey);

		(void)RemoveRegHandle(hndFileReg);

		// Release extra reference in global registry.
		if (this!=&g_FileRegistry)
			g_FileRegistry.ReleaseRegRef(hndFileReg);

		fRet = TRUE;
	}

	return fRet;
}
#endif //ifndef REFCOUNT_WORK

#ifdef _BLD_REG_HISTORY
void CFileRegistry::AddRegRefI(FileRegHandle hndFileReg, TCHAR * szFile, int nLine)
#else
void CFileRegistry::AddRegRef(FileRegHandle hndFileReg)
#endif
{
#ifdef _BLD_REG_HISTORY
	CFRHHistory * pOldHistory = NULL;
	m_mapFRHHistory.Lookup(hndFileReg, (void *&)pOldHistory);
	CFRHHistory * pHistory = new CFRHHistory(szFile, nLine, TRUE, pOldHistory);
	m_mapFRHHistory.SetAt(hndFileReg, pHistory);
#endif

#ifndef REFCOUNT_WORK

#if 0	// defined(_DEBUG)
	// A CFileRegFile must already be ref counted somewhere if not in this->m_Contents.
	if ( NULL == m_Contents.Find(hndFileReg) )
	{
		// Note: GetFilePath returns NULL if hndFileReg is not a CFileRegFile.
		CPath const * pPath = hndFileReg->GetFilePath();
		CString strPath;
		if ( pPath )
		{
			strPath = pPath->GetFullPath();

			// Must have been added somewhere else already.
			ASSERT( hndFileReg->GetRefCount() > 0 );
		}
	}
#endif

	ASSERT(hndFileReg);
 	hndFileReg->AddFRHRef();

	CFileRegEntry * pFileRegEntry = GetRegEntry(hndFileReg);

	// increment our set reference count
	{
		WORD wRefCount = 0;
		
		ASSERT(m_pmapContents != NULL);
		BOOL bFound = m_pmapContents->Lookup(hndFileReg, wRefCount);

        // FUTURE (colint): I would really like to enable this assert
        // but we need to fix addition of things to sets so that we
        // don't end up with an entry in a registry's m_pmapContents
        // but not in it's m_Contents.
		//if (hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegFile)))
		//	ASSERT(bFound);

		m_pmapContents->SetAt(hndFileReg, wRefCount+1);
	}
#else //ifndef REFCOUNT_WORK

	ASSERT(m_pmapContents != NULL);

	WORD wRefCount = 0;
	BOOL bFound = m_pmapContents->Lookup(hndFileReg, wRefCount);

	if (!bFound)
	{
		// Add to registry.
		// AddRegHandle takes care of actual ref counts on hndFileReg.
		VERIFY( AddRegistryHandle(hndFileReg) );
		wRefCount = 0;
	}

	wRefCount++;
	m_pmapContents->SetAt(hndFileReg, wRefCount);

#endif //#ifndef REFCOUNT_WORK
}

#ifdef _BLD_REG_HISTORY
void CFileRegistry::ReleaseRegRefI(FileRegHandle hndFileReg, TCHAR * szFile, int nLine)
#else
void CFileRegistry::ReleaseRegRef(FileRegHandle hndFileReg)
#endif
{
#ifdef _BLD_REG_HISTORY
	CFRHHistory * pOldHistory = NULL;
	m_mapFRHHistory.Lookup(hndFileReg, (void *&)pOldHistory);
	CFRHHistory * pHistory = new CFRHHistory(szFile, nLine, FALSE, pOldHistory);
	m_mapFRHHistory.SetAt(hndFileReg, pHistory);
#endif

	ASSERT(hndFileReg);
	if (!hndFileReg)
		return; // just bail

#ifndef REFCOUNT_WORK
	CFileRegEntry * pFileRegEntry = GetRegEntry(hndFileReg);

	// decrement the set reference count
	{
		WORD wRefCount;
		ASSERT(m_pmapContents != NULL);
		if (!m_pmapContents->Lookup(hndFileReg, wRefCount))
			wRefCount = 0;

		if (wRefCount != 0)
		{
 			wRefCount--;
			m_pmapContents->SetAt(hndFileReg, wRefCount);

			// Check to see if the registry reference count went to 0
			if (wRefCount == 0)
			{
				// A CFileRegEntry has been removed from this registry
				// so we may need to unfilter it, only do this if we are not going to
				// do a global destroy
				if (hndFileReg->GetRefCount() > 1)
					pFileRegEntry->InformNotifyRxs(FRN_LCL_DESTROY, (DWORD)(void *)m_pFileRegistry);

                // Make sure that any m_pmapContents (i.e. local ref count),
                // is removed completely
				ASSERT(m_pmapContents != NULL);
                m_pmapContents->RemoveKey(hndFileReg);
			}
		}
	}

	// Must release the actual ref after we have checked for whether
	// this CFileRegEntry has been removed from this registry, as
	// otherwise the object may delete itself.
	hndFileReg->ReleaseFRHRef();

#else //ifndef REFCOUNT_WORK

	WORD wRefCount;
	ASSERT(m_pmapContents != NULL);
	ASSERT (m_pmapContents->Lookup(hndFileReg, wRefCount));

	if (!m_pmapContents->Lookup(hndFileReg, wRefCount))
		wRefCount = 0;

	ASSERT(0!=wRefCount);

	if (wRefCount != 0)
 		wRefCount--;

	if (wRefCount != 0)
	{
		m_pmapContents->SetAt(hndFileReg, wRefCount);
	}
	else
	{
		m_pmapContents->RemoveKey(hndFileReg);

		// RemoveRegHandle takes care of actual ref counts on hndFileReg.
		VERIFY(RemoveRegistryHandle(hndFileReg));
	}

#endif //ifndef REFCOUNT_WORK

}

FileRegHandle CFileRegistry::FindBasicFilter(const CString* pstrBasicFilter)
{
	// Find a basic file filter
	FileRegHandle hndFileFilter;

	if (m_FilterMap.Lookup(*pstrBasicFilter, (void*&)hndFileFilter))
		return hndFileFilter;

#ifndef REFCOUNT_WORK
	// Ok, so now we have to check any sets we have as file filters
	POSITION pos = m_FilterMap.GetStartPosition();
	while (pos != NULL)
	{
		FileRegHandle hndFileReg;
		CString strFile;
		m_FilterMap.GetNextAssoc(pos, strFile, (void*&)hndFileReg);
		if (!hndFileReg->IsNodeType(nodetypeRegFilter))
		{
 			// This set will only contain file filters, so check these!
			const CPtrList* pFilterList = ((CFileRegSet*)hndFileReg)->GetContent();

			POSITION FilterPos = pFilterList->GetHeadPosition();
			while (FilterPos != NULL)
			{
				hndFileReg = (FileRegHandle) pFilterList->GetNext(FilterPos);
				ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegFilter)));
				ASSERT(hndFileReg->IsNodeType(nodetypeRegFilter));
				if (*((CFileRegFilter*)hndFileReg)->GetFilter() == *pstrBasicFilter)
					return hndFileReg;
			}
		}
	}
#endif

	return NULL;
}

FileRegHandle CFileRegistry::RegisterFileFilter(const CString* pstrFilter)
{
	FileRegHandle hndFileReg;

	hndFileReg = LookupFileFilter(pstrFilter);

	// Are we trying to register a file filter that has already been
	// registered?
#ifndef REFCOUNT_WORK
	if (hndFileReg)
		return NULL;
#else
	if (hndFileReg)
	{
		hndFileReg->AddFRHRef();
		return hndFileReg;
	}
#endif

	CStringList BasicFilters;
	GetBasicFilters(pstrFilter, BasicFilters);

	if (BasicFilters.GetCount() > 1)
	{
#ifndef REFCOUNT_WORK
		// Create the set
		hndFileReg = (FileRegHandle) new CFileRegSet;

		AddRegHandle(hndFileReg);
#else
		// Create the set
		hndFileReg = (FileRegHandle) new CFileRegFilterSet;

		hndFileReg->AddFRHRef();
#endif
 
		// Multiple file filter
		CPtrList NewFilters;

		FileRegHandle hndFileFilter;
		POSITION pos = BasicFilters.GetHeadPosition();
		while (pos != NULL)
		{
			CString strBasicFilter = BasicFilters.GetNext(pos);
			hndFileFilter = FindBasicFilter(&strBasicFilter);
			if (hndFileFilter == NULL)
			{
#ifndef REFCOUNT_WORK
	 			// Nope we don't have one so now we create it and 
				// set an entry in our map.
				hndFileFilter = (FileRegHandle)new CFileRegFilter(strBasicFilter);
				 		
				// Ensure sequential access to file map
				CritSectionT cs(g_sectionFileMap);

				// Filter all files through this file filter
				CString strFileKey;
				FileRegHandle hndFile;
				POSITION pos = m_FileMap.GetStartPosition();
				while (pos != NULL)
				{
					m_FileMap.GetNextAssoc(pos, strFileKey, (void*&)hndFile);
					ASSERT(hndFile->IsNodeType(nodetypeRegFile);
					((CFileRegFilter*)hndFileFilter)->AddRegHandle(hndFile);
				}
#else
				hndFileFilter = RegisterFileFilter(&strBasicFilter);
				hndFileFilter->ReleaseFRHRef();
#endif
 			}

#ifndef REFCOUNT_WORK
			((CFileRegSet*)hndFileReg)->AddRegHandle(hndFileFilter);
#else
			((CFileRegFilterSet*)hndFileReg)->AddFilter((CFileRegFilter*)hndFileFilter);
#endif
 		}
 	}
	else
	{
		// Single basic file filter
		// First we had better check to see if we actually have created a
		// file filter like this, but it is not registered.
		CString strKey = BasicFilters.GetHead();
		hndFileReg = FindBasicFilter(&strKey);
		if (hndFileReg == NULL)
		{
 			// Nope we don't have one so now we create it and 
			// set an entry in our map.
			hndFileReg = (FileRegHandle)new CFileRegFilter(strKey);
#ifndef REFCOUNT_WORK
 			AddRegHandle(hndFileReg);
#else
			hndFileReg->AddFRHRef();
#endif
 
#ifndef REFCOUNT_WORK
			// Ensure sequential access to file map
			CritSectionT cs(g_sectionFileMap);
#endif

			// Filter all files through this file filter
			CString strFileKey;
			FileRegHandle hndFile;
#ifdef REGISTRY_FILEMAP
			POSITION pos = m_FileMap.GetStartPosition();
#else
			POSITION pos = m_Contents.GetHeadPosition();
#endif
			while (pos != NULL)
			{
#ifdef REGISTRY_FILEMAP
				m_FileMap.GetNextAssoc(pos, strFileKey, (void*&)hndFile);
#ifndef REFCOUNT_WORK
				((CFileRegFilter*)hndFileReg)->AddRegHandle(hndFile);
#else
				((CFileRegFilter*)hndFileReg)->AddFilterHandle(hndFile);
#endif
#else	//	REGISTRY_FILEMAP
				hndFile = (FileRegHandle)m_Contents.GetNext(pos);
				ASSERT(NULL!=hndFile);
				if (hndFile->IsNodeType(nodetypeRegFile))
					((CFileRegFilter*)hndFileReg)->AddFilterHandle(hndFile);
#endif
			}
		}
		else
		{
#ifndef REFCOUNT_WORK
			// We already have the file filter so just use it!
			if (!AddRegHandle(hndFileReg))
				return NULL;
#else
			// FindBasicFilter() should not succeed after LookupFileFilter() failed.
			ASSERT(FALSE);
#endif
		}
	}

	// Put an entry in our registered file filter map
    TCHAR szKey[MAX_PATH];
    _tcscpy(szKey, *pstrFilter);
    _tcsupr(szKey);
 	m_FilterMap.SetAt(szKey, hndFileReg);

	return hndFileReg;
}

BOOL CFileRegistry::RemoveFileFilter(const CString* pstrFilter)
{
	// We can only remove file filters that have been registered
	FileRegHandle hndFileReg;

    TCHAR szKey[MAX_PATH];
    _tcscpy(szKey, *pstrFilter);
    _tcsupr(szKey);

 	if (!m_FilterMap.Lookup(szKey, (void*&)hndFileReg))
 		return FALSE;

 	if (!hndFileReg->IsNodeType(nodetypeRegFilter))
	{
		ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegSet)));
		ASSERT(hndFileReg->IsNodeType(nodetypeRegSet));
 		CFileRegSet* hndFileSet = (CFileRegSet*)hndFileReg;

#ifndef REFCOUNT_WORK
		const CPtrList* pFilterList = hndFileSet->GetContent();
#else
		const CPtrList* pFilterList = &hndFileSet->m_Contents;
#endif

		POSITION pos = pFilterList->GetHeadPosition();
		while (pos != NULL)
		{
			FileRegHandle hndFileRegFilter = (FileRegHandle) pFilterList->GetNext(pos);
#ifndef REFCOUNT_WORK
			hndFileSet->RemoveRegHandle(hndFileRegFilter);
#else
			POSITION posFilter = m_Contents.Find(hndFileRegFilter);
			if (NULL!=posFilter)
			{
				hndFileSet->m_Contents.RemoveAt(posFilter);
				hndFileRegFilter->ReleaseFRHRef();
			}
#endif
		}
 	}

	m_FilterMap.RemoveKey(szKey);

#ifndef REFCOUNT_WORK
	return RemoveRegHandle(hndFileReg);
#else
	hndFileReg->ReleaseFRHRef();
	return TRUE;
#endif
}

FileRegHandle CFileRegistry::LookupFile(LPCTSTR lpszFile)
{
#ifdef REGISTRY_FILEMAP

#ifndef REFCOUNT_WORK
	// Ensure sequential access to file map
	CritSectionT cs(g_sectionFileMap);
#endif

	FileRegHandle hndFileReg = (FileRegHandle)NULL;

    TCHAR szKey[MAX_PATH];
    _tcscpy(szKey, lpszFile);
    _tcsupr(szKey);

	// In our map?
	// ASSERT((UINT)m_FileMap.GetCount() < ((UINT)m_FileMap.GetHashTableSize() << 1)); // UNDONE
	if (!m_FileMap.Lookup(szKey, (void*&) hndFileReg))
	{
		POSITION pos = m_LocalFileRegs.GetHeadPosition();
#ifdef REFCOUNT_WORK
		// Local registries not used.
		ASSERT(pos==NULL);
#endif
		while (pos != NULL)
		{
			// In any of our local maps?
			CFileRegistry* pfreg = (CFileRegistry*) m_LocalFileRegs.GetNext(pos);
			hndFileReg = pfreg->LookupFile(lpszFile);
			if (hndFileReg != (FileRegHandle)NULL)
				break;
		}
	}
#ifdef REFCOUNT_WORK
	else
	{
		ASSERT(NULL!=hndFileReg);
		hndFileReg->AddFRHRef();
	}
#endif

#else
	FileRegHandle hndFileReg = CFileRegFile::GetFileHandle(lpszFile);
	if (NULL!=hndFileReg)
	{
		if (!RegHandleExists(hndFileReg))
		{
			hndFileReg->ReleaseFRHRef();
			hndFileReg = NULL;
		}
	}
#endif

	return hndFileReg;
}

FileRegHandle CFileRegistry::LookupFile(const CPath* pPath)
{
	// REVIEW: this override should be eliminated!!!

	ASSERT(pPath->IsInit());
	return CFileRegistry::LookupFile(LPCTSTR(*pPath));
}

FileRegHandle CFileRegistry::LookupFileFilter(const CString* pstrFilter)
{
	// Create a list of the basic file filters
 	CStringList BasicFilters;

	GetBasicFilters(pstrFilter, BasicFilters);

	// FUTURE (colint): NYI
 	// Generate permutations of the basic file filters
	CStringList Permutations;

	// FUTURE (colint): For now we just add one of the permutations
    TCHAR szTempPerm[MAX_PATH];
    _tcscpy(szTempPerm, *pstrFilter);
    _tcsupr(szTempPerm);
	Permutations.AddTail(szTempPerm);

	// Lookup each of the permutations
	FileRegHandle hndFileReg;

	
	POSITION pos = Permutations.GetHeadPosition();
	while (pos != NULL)
	{
		CString strKey = Permutations.GetNext(pos);
		if (m_FilterMap.Lookup(strKey, (void*&)hndFileReg))
			return hndFileReg;
	}

#ifndef REFCOUNT_WORK
	// We haven't found the filter in this registry, so look in 
	// associated ones too!
	pos = m_LocalFileRegs.GetHeadPosition();
	while (pos != NULL)
	{
		CFileRegistry* pfreg = (CFileRegistry*) m_LocalFileRegs.GetNext(pos);
		hndFileReg = pfreg->LookupFileFilter(pstrFilter);
		if (hndFileReg != NULL)
			return hndFileReg;
	}
#endif
 
 	return NULL;
}

void CFileRegistry::GetBasicFilters(const CString* pstrFilter, CStringList& strList)
{  		 
	CString strKey = *pstrFilter;
	strKey.MakeUpper();
	strKey += _T(";");

	int nBreak = -1;
	do
	{
		nBreak = strKey.Find(_T(';'));
		if (nBreak != -1)
		{
			CString strBasicFilter = strKey.Left(nBreak);
			strList.AddTail(strBasicFilter);
			strKey = strKey.Right(strKey.GetLength() - nBreak - 1);
		}
	} while (nBreak != -1);
}

void CFileRegistry::FilterFile(FileRegHandle hndFile)
{
	ASSERT(hndFile->IsKindOf(RUNTIME_CLASS(CFileRegFile)));
	ASSERT(hndFile->IsNodeType(nodetypeRegFile));

	// Notify all file filters that we have in the registry at
	// the moment.
	POSITION pos = m_FilterMap.GetStartPosition();
	while (pos != NULL)
	{
		FileRegHandle hndFileReg;
		CString strFile;
		m_FilterMap.GetNextAssoc(pos, strFile, (void*&)hndFileReg);
		if (hndFileReg->IsNodeType(nodetypeRegFilter))
		{
#ifndef REFCOUNT_WORK
			((CFileRegFilter*)hndFileReg)->AddRegHandle(hndFile);
#else
			((CFileRegFilter*)hndFileReg)->AddFilterHandle(hndFile);
#endif
		}
#ifndef REFCOUNT_WORK
		else
		{
			ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegSet)));
			ASSERT(hndFileReg->IsNodeType(nodetypeRegSet));

 			// This set will only contain file filters, so check these!
			const CPtrList* pFilterList = ((CFileRegSet*)hndFileReg)->GetContent();

			POSITION FilterPos = pFilterList->GetHeadPosition();
			while (FilterPos != NULL)
			{
				hndFileReg = (FileRegHandle) pFilterList->GetNext(FilterPos);
				ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegFilter)));
				ASSERT(hndFileReg->IsNodeType(nodetypeRegFilter));
				((CFileRegFilter*)hndFileReg)->AddRegHandle(hndFile);
 			}
		}
#endif //#ifndef REFCOUNT_WORK
	}
}

#ifdef REFCOUNT_WORK
void CFileRegistry::UnFilterFile(FileRegHandle hndFile)
{
	ASSERT(hndFile->IsKindOf(RUNTIME_CLASS(CFileRegFile)));
	ASSERT(hndFile->IsNodeType(nodetypeRegFile));

	// Notify all file filters that we have in the registry at
	// the moment.
	POSITION pos = m_FilterMap.GetStartPosition();
	while (pos != NULL)
	{
		FileRegHandle hndFileReg;
		CString strFile;
		m_FilterMap.GetNextAssoc(pos, strFile, (void*&)hndFileReg);
		if (hndFileReg->IsNodeType(nodetypeRegFilter))
		{
			((CFileRegFilter*)hndFileReg)->RemoveFilterHandle(hndFile);
		}
	}
}
#endif //#ifdef REFCOUNT_WORK

void CFileRegistry::OnNotify(FileRegHandle hndFileReg, UINT idChange, DWORD dwHint)
{
	ASSERT(hndFileReg);
	
	switch (idChange)
	{
#ifndef REFCOUNT_WORK
		case FRN_ADD:
		{
 			// If we are being told that a file has been added
			// then notify our filters
			if (hndFileReg->IsNodeType(nodetypeRegFile))
			{
				if (((CFileRegFile *)hndFileReg)->m_bFiltered)
					FilterFile(hndFileReg);
 			}
			break;
	  	}

		case FRN_LCL_DESTROY:
		{
			// Only do a FRN_DESTROY if it a local destroy in us
			if ((CFileRegistry *)dwHint != m_pFileRegistry)
				return;	// ignore completely

			// Remove us as a dependant of the item just removed
			hndFileReg->RemoveNotifyRx(this);

			// Fall thru'
		}

		case FRN_DESTROY:
		{
			// Something is being destroyed that we contain
			// Better remove any trace of it from us
			POSITION pos = m_Contents.Find(hndFileReg);
			if (pos != NULL)
				m_Contents.RemoveAt(pos);

			ASSERT(m_pmapContents != NULL);
			m_pmapContents->RemoveKey(hndFileReg);

			// Ensure sequential access to file map
			CritSectionT cs(g_sectionFileMap);

			CString strKey;
			if (hndFileReg->IsNodeType(nodetypeRegFile))
			{
#ifdef REGISTRY_FILEMAP
				// A file is going away that we still contain,
				// so remove it from our FileMap
				TCHAR szKey[MAX_PATH];
			    _tcscpy(szKey, *hndFileReg->GetFilePath());
				_tcsupr(szKey);
 
				m_FileMap.RemoveKey(szKey);
#endif
			}
			else if (hndFileReg->IsNodeType(nodetypeRegFilter))
			{
				// A basic filter is going away that we still contain
				// so we remove it from our FilterMap
				TCHAR szKey[MAX_PATH];
				_tcscpy(szKey, *((CFileRegFilter*)hndFileReg)->GetFilter());
				_tcsupr(szKey);
 
				m_FilterMap.RemoveKey(szKey);
			}
			else
			{
				// A compound filter is going away that we still contain
				// so we remove it from out FilterMap
				ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegSet)));
				ASSERT(hndFileReg->IsNodeType(nodetypeRegSet));

				const CPtrList* pFilterList = ((CFileRegSet*)hndFileReg)->GetContent();

				// Figure out the name of this compound filter based on the
				// basic filters that compose it.
				POSITION FilterPos = pFilterList->GetHeadPosition();
				while (FilterPos != NULL)
				{
					hndFileReg = (FileRegHandle) pFilterList->GetNext(FilterPos);
					ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegFilter)));
					ASSERT(hndFileReg->IsNodeType(nodetypeRegFilter));
					strKey += *((CFileRegFilter*)hndFileReg)->GetFilter();
					if (FilterPos != NULL)
						strKey += _T(';');
 				}

				m_FilterMap.RemoveKey(strKey);
			}

			break;
		}
#else //#ifndef REFCOUNT_WORK

		//
		// Take care of references counts.
		// (Add/Release)RegRef() will do the work.
		//
		case FRI_ADD:
		{
			CFileRegSet* pregset = (CFileRegSet*)hndFileReg;

			ASSERT(pregset->IsNodeType(nodetypeRegSet));
			ASSERT(!pregset->IsNodeType(nodetypeRegRegistry));
			ASSERT(this==pregset->m_pFileRegistry);

			CFileRegEntry* regent = (CFileRegEntry*)dwHint;
			AddRegRef(regent);
			break;
		}
		case FRI_DESTROY:
		{
			CFileRegSet* pregset = (CFileRegSet*)hndFileReg;

			ASSERT(pregset->IsNodeType(nodetypeRegSet));
			ASSERT(!pregset->IsNodeType(nodetypeRegRegistry));
			ASSERT(this==pregset->m_pFileRegistry);

			CFileRegEntry* regent = (CFileRegEntry*)dwHint;
			ReleaseRegRef(regent);
			break;
		}
#endif //#ifndef REFCOUNT_WORK

	}
}

BOOL CFileRegistry::DeleteFile(FileRegHandle hndFileReg)
{
	ASSERT(hndFileReg);
	ASSERT(hndFileReg->IsKindOf(RUNTIME_CLASS(CFileRegFile)));
	ASSERT(hndFileReg->IsNodeType(nodetypeRegFile));

	const CPath * pPath = ((CFileRegFile*)hndFileReg)->GetFilePath();
 	ASSERT(pPath != (const CPath *)NULL);

	BOOL fRet = ::DeleteFile((const TCHAR*)*pPath);

	if (fRet)
	{
		// it's gone, let's assume this and set the attributes
		S_ATTRIB attrib;
		attrib._fOk = TRUE;
		attrib._filetime.dwLowDateTime = attrib._filetime.dwHighDateTime = 0;	// none
		attrib._fExists = FALSE;

		((CFileRegFile*)hndFileReg)->SetAttributes(&attrib);
	}

	return fRet;
}

BOOL CFileRegistry::GetFileItemList(const CTargetItem * pTargetFilter,
									const CPtrList * pFileList,
									CObList & FileItemList,
									BOOL fOnlyBuildable /*= TRUE*/, const ConfigurationRecord * pcr /*= NULL*/)
{
	FileItemList.RemoveAll();

	POSITION pos = pFileList->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CObList * oblist = ((CFileRegEntry *)pFileList->GetNext(pos))->plstFileItems;
		if (oblist==NULL)
		{
			ASSERT(0);
			continue;
		}
		POSITION pos2 = oblist->GetHeadPosition();
		while (pos2 != (POSITION)NULL)
		{
			CFileItem * pFile = (CFileItem *)oblist->GetNext(pos2);
			CTargetItem * pTarget = pFile->GetTarget();
			CProject * pProject = pTarget->GetProject();

			// If the caller doesn't want FileItem's for this target, 
			// continue on.
			// pInputTarget == NULL implies caller wants FileItem's for all
			// targets.

			if (pTargetFilter != NULL && pTargetFilter != pTarget )
				continue;

			// do this with the all project items
			// in the specified config.
			CProjTempConfigChange projTempConfigChange(pProject);

			if (pcr != NULL)
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);

			// add to our list if this is buildable, or we don't care
			int fExcluded;
			ConfigurationRecord* pcrTarget = (ConfigurationRecord*) pTarget->GetActiveConfig();
			ASSERT(pTarget != NULL);

			if ((!fOnlyBuildable || (pFile->GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid && !fExcluded)) &&
				pcrTarget->IsValid())
				FileItemList.AddTail(pFile);

		}
	}

	return TRUE;
}

BOOL CFileRegistry::GetFileList(const CPath * pPath, const CPtrList * & pFileList)
{
	ASSERT(pPath->IsInit());
	pFileList = (const CPtrList *)NULL;
	const TCHAR * pchExt = pPath->GetExtension();

	// resource file?
	if (m_fCareAboutRCFiles && _tcsicmp(pchExt, _TEXT(".rc")) == 0)
		pFileList = GetRCFileList();

	// definition file?
	else if (m_fCareAboutDefFiles && _tcsicmp(pchExt, _TEXT(".def")) == 0)
		pFileList = GetDEFFileList();
		
	// odl file?
	else if (_tcsicmp(pchExt, _TEXT(".odl")) == 0)
		pFileList = GetODLFileList();
		
	return pFileList != (const CPtrList *)NULL;
}
	
UINT CFileRegistry::GetFileCount(const CTargetItem * pTargetFilter, const CPtrList * pFileList,
									 BOOL fOnlyBuildable /*= TRUE*/, const ConfigurationRecord * pcr /*= NULL*/)
{
	CObList FileItemList;
	if (GetFileItemList(pTargetFilter, pFileList, FileItemList, fOnlyBuildable, pcr))
		return FileItemList.GetCount();
	else
		return 0;	// couldn't get the list, return none
}

void CFileRegistry::RemoveFromProject(CProjItem * pItem, BOOL fRemoveContained)
{
	// do we have a file reghandle to remove?
	FileRegHandle hndFileReg = pItem->GetFileRegHandle();
	if (hndFileReg != (FileRegHandle)NULL)
	{

	CFileRegEntry * pRegEntry = GetRegEntry(hndFileReg); ASSERT (pRegEntry);

	ASSERT(NULL!=pItem);
	CTargetItem* pTarget = pItem->GetTarget();

	if (!pTarget->IsFileInTarget(pRegEntry))
	{
		ASSERT(0); // bogus!
		return;	// not in the project!
	}

	// interested in this item?
	if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
//#ifndef REFCOUNT_WORK
		pRegEntry->DisassociateFileItem((CFileItem *)pItem);
//#endif

		// remove from a list of files we are interested in?
		CPtrList * pFileList;
		if (GetFileList(pRegEntry->GetFilePath(), (const CPtrList * &)pFileList))
		{
			POSITION pos = pFileList->Find(pRegEntry);
			if (pos != (POSITION)NULL)
			{
				pFileList->RemoveAt(pos);

				// If we deleted an RC file then we may need to send out a notification
				if (pFileList == GetRCFileList())
				{
					// Only send notifications when we are not initialising or destroying the project
					CProject * pProject = pItem->GetProject(); ASSERT(pProject != (CProject *)NULL);
 					if (pProject->m_bProjectComplete)
					{
						// Construct the NOTIFYINFO packet of data regarding the deletion of
						// this rc file
						NOTIFYINFO Notify;
						const CPath * pPath = ((CFileRegFile *)pRegEntry)->GetFilePath();
						COleRef<IPkgProject> pPkgProj = NULL;
						VERIFY(SUCCEEDED(g_BldSysIFace.GetPkgProject((HBUILDER)pItem->GetProject(), &pPkgProj)));
						Notify.pPkgProject = pPkgProj;

						CTargetItem * pTarget = pItem->GetTarget();
						ASSERT(pTarget->IsKindOf(RUNTIME_CLASS(CTargetItem)));
						Notify.hFileSet = (HFILESET)pTarget;

						Notify.lstFiles.AddTail((CPath *)pPath);

						// Send the notification
						theApp.NotifyPackages(PN_DEL_RCFILE, (void *)&Notify);

						// Clean up the data
						Notify.lstFiles.RemoveAll();
					}
				}
			}
		}
 	}

//	pRegEntry->ReleaseProjRef();

	if (this != &g_FileRegistry)
	{
		// We are a target registry so we'd better remove our reference
		// to this file. NOTE: when we have v2 mak conversion to proper
		// v3 maks  i.e. containing target item nodes then we will always
		// do this.
#ifndef REFCOUNT_WORK
		RemoveFile(pRegEntry->GetFilePath());
#else
		ReleaseRegRef(pRegEntry);
#endif
	}
	}

	// remove all our children?
	if (fRemoveContained && pItem->GetContentList())
	{
		POSITION pos = pItem->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CProjItem * pContainedItem = (CProjItem *)pItem->GetNext(pos);
			pContainedItem->GetRegistry()->RemoveFromProject(pContainedItem, fRemoveContained);
		}
	}
}
	
void CFileRegistry::RestoreToProject(CProjItem * pItem, BOOL fRestoreContained)
{
	// do we have a file reghandle to restore?
	FileRegHandle hndFileReg = pItem->GetFileRegHandle();
	if (hndFileReg != (FileRegHandle)NULL)
	{

	CFileRegEntry *pRegEntry = GetRegEntry(hndFileReg); ASSERT(pRegEntry);

	ASSERT(NULL!=pItem);
	CProject* pProject = pItem->GetProject();
	ASSERT(NULL!=pProject);

	if (this != &g_FileRegistry)
	{
		// For target registries we must effectively register the file too
		// NOTE : When we have conversion support for v2 maks to v3 maks.
		// i.e. containing proper v3 target items then we will always do
		// this
#ifndef REFCOUNT_WORK
 		RegisterFile(pRegEntry->GetFilePath());
#else
		AddRegRef(hndFileReg);
#endif
	}

	// interested in this item?
	if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
//#ifndef REFCOUNT_WORK
		pRegEntry->AssociateFileItem((CFileItem *)pItem);
//#endif
		CProject * pProject = pItem->GetProject(); ASSERT(pProject != (CProject *)NULL);

		// add to a list of files we are interested in?
		CPtrList * pFileList;
		if ((GetFileList(pRegEntry->GetFilePath(), (const CPtrList * &)pFileList)) && (g_BldSysIFace.IsScanableFile((HBLDFILE)pItem)))
		{
			// don't allow multiple .RC or .DEF files, exclude this file if
			// there are already these files in the project
			if (pFileList == GetRCFileList() || pFileList == GetDEFFileList())
			{
				// is the associated project initializing from a project file?
				if (pProject->m_bPrivateDataInitialized)
				{
					// no
					BOOL fShowWarning = FALSE;
					
					// check this addition for all project configurations
					// (examine item included in build property)
					int iSize = pProject->GetPropBagCount();
					const CPtrArray * pArrayCfg = pProject->GetConfigArray();
					for (int i = 0; i < iSize; i++)
					{
						ConfigurationRecord * pcr = (ConfigurationRecord *)(*pArrayCfg)[i]; 
						CProjTempConfigChange projTempConfigChange(pProject);
						projTempConfigChange.ChangeConfig(pcr);

						CProjType * pProjType = pProject->GetProjType();
						BOOL bIsExternalTarget = pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget));

						if (!bIsExternalTarget)
						{
							int nBuildable = GetFileCount(pItem->GetTarget(), pFileList, TRUE, pcr);
							if (nBuildable >= 1) // buildable one already exists for this config.
							{
								// don't do warning if they are *all* excluded
								int fExcluded;
								pItem->GetIntProp(P_ItemExcludedFromBuild, fExcluded);
								if (!fExcluded)
								{
#if 1	// Begin hack
									//
									// HACK alert!
									// Since setting P_ItemExcludedFromBuild to TRUE will cause
									// a ReleaseRegRef() to occur, do an AddRegRef on
									// the build registry if P_ItemExcludedFromBuild doesn't
									// exist yet.
									// 
									// This is needed because CProjItem::GetIntProp has a hack to return
									// P_ItemExcludedFromBuild as TRUE when the proprety doesn't exist.  This
									// causes AssignActions to do an AddRefRef that needs to be undone.
									//
									CPropBag* pBag = pItem->GetPropBag();
									if (NULL!=pBag && NULL==pBag->FindProp(P_ItemExcludedFromBuild))
									{
										ConfigurationRecord* pcr = pItem->GetActiveConfig();
										ASSERT( NULL!=pcr);
										CFileRegistry *preg = g_buildengine.GetRegistry(pcr);
										ASSERT(NULL!=preg);
										FileRegHandle frh = pItem->GetFileRegHandle();
										ASSERT(NULL!=frh);

										preg->AddRegRef(frh);
									}
#endif
									pItem->SetIntProp(P_ItemExcludedFromBuild, TRUE);
									
									// Show warning only for the 2nd addition after
									// the buildable one
									if (GetFileCount(pItem->GetTarget(), pFileList, FALSE, pcr) == 1)
										fShowWarning = TRUE;
								}
							}
						}

  					}

					// Show the warning message if necessary
					if ((fShowWarning) && (!g_bExcludedNoWarning))
						InformationBox(IDS_FILE_TYPE_EXISTS, pFileList == GetRCFileList() ? _TEXT(".rc") : _TEXT(".def"));
				}
			}

			pFileList->AddTail(pRegEntry);

			// If we added an rc file then we may need to send out a notification
			if (pFileList == GetRCFileList() && !g_fCreatingProject && pProject->m_bProjectComplete)
			{
				// Get the state of the workspace
				LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();
				BOOL bWorkspaceInitialised = pProjSysIFace->IsWorkspaceInitialised() == S_OK;

				// Only send notifications after PN_WORKSPACE_INIT happened
 				if (bWorkspaceInitialised)
				{
					// Construct the NOTIFYINFO packet of data regarding the addition of
					// this rc file
					NOTIFYINFO Notify;
					const CPath * pPath = ((CFileRegFile *)pRegEntry)->GetFilePath();
					
					CTargetItem * pTarget = pItem->GetTarget();
					ASSERT(pTarget->IsKindOf(RUNTIME_CLASS(CTargetItem)));

					COleRef<IPkgProject> pPkgProj = NULL;
					VERIFY(SUCCEEDED(g_BldSysIFace.GetPkgProject((HBUILDER)pItem->GetProject(), &pPkgProj)));
					Notify.pPkgProject = pPkgProj;
					Notify.hFileSet = (HFILESET)pTarget;
					Notify.lstFiles.AddTail((CPath *)pPath);

					// Send the notification
					theApp.NotifyPackages(PN_ADD_RCFILE, (void *)&Notify);
					
					// Clean up the data
					Notify.lstFiles.RemoveAll();
				}
			}
		}
	}

//	pRegEntry->AddProjRef();

	}

	// restore all our children?
	if (fRestoreContained && pItem->GetContentList())
	{
		POSITION pos = pItem->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CProjItem * pContainedItem = (CProjItem *)pItem->GetNext(pos);
			pContainedItem->GetRegistry()->RestoreToProject(pContainedItem, fRestoreContained);
		}
	}
}

#ifdef _DEBUG
void CFileRegistry::Dump(CDumpContext& dc) const
{
	CFileRegSet::Dump(dc);
#ifdef REGISTRY_FILEMAP

	dc << "{CFileRegistry: m_FileMap";
	CString str;

	POSITION pos;
	FileRegHandle hndFileReg;
	for (pos = m_FileMap.GetStartPosition(); pos != NULL; )
	{
		m_FileMap.GetNextAssoc(pos, str, (void*&)hndFileReg);
		dc << "\n@" << (void*)hndFileReg << " " << str;
	}
#endif
	dc << "\nend of CFileRegistry}";
}

void CFileRegistry::AssertValid() const
{
	if ( m_bAssertValidCalled )
		return;


	CObject::AssertValid();
	// Expect that this registry is g_FileRegistry or a local registry of g_FileRegistry
#ifndef REFCOUNT_WORK
	ASSERT( this == &g_FileRegistry || IsLocalRegistryOf( &g_FileRegistry ) );
#endif
}

#ifndef REFCOUNT_WORK
BOOL CFileRegistry::IsLocalRegistryOf( CFileRegistry* pParent) const
{
	// Included directly in parent?
	if ( NULL != pParent->m_LocalFileRegs.Find( (void*)this ) )
		return TRUE;
	else
	{
		// Included indirectly?

		POSITION pos = pParent->m_LocalFileRegs.GetHeadPosition();
		while (pos != NULL)
		{
			CFileRegistry* pfreg = (CFileRegistry*) pParent->m_LocalFileRegs.GetNext(pos);
			if ( IsLocalRegistryOf( pfreg ) )
				return TRUE;
		}
		return FALSE;
	}
}
#endif //ifndef REFCOUNT_WORK

#endif

#ifdef REFCOUNT_WORK
//
// New CFileRegistry functions.
//

BOOL CFileRegistry::AddRegistryHandle(FileRegHandle hndFileReg)
{
	ASSERT(hndFileReg);

	// Shouldn't be adding again.
	ASSERT( !RegHandleExists(hndFileReg) );
	ASSERT( !hndFileReg->IsNodeType(nodetypeRegRegistry) );
	ASSERT( !hndFileReg->IsNodeType(nodetypeRegFilter) );

	// Already exists in set....return
	if (RegHandleExists(hndFileReg))
		return TRUE;

	// Reference held by this file set.
	hndFileReg->AddFRHRef();

	// This may result in new dependency update requests, so we must not be locking
	// the lists at this time.
	ASSERT(!g_sectionDepUpdateQ.FOwned());

	// Is the CFileRegEntry a CFileRegSet if so then we must
	// set up the associated file registry...
	CFileRegSet * pFileRegSet = (CFileRegSet *)hndFileReg;

	if (pFileRegSet->IsNodeType(nodetypeRegSet))
	{
		pFileRegSet->SetFileRegistry(this);

		// We need to receive notifications from this fileset.
		// (Already added to nofify list in SetFileRegistry).
		// pFileRegSet->AddNotifyRx(this);
	}

	// Add the CFileRegEntry to the registry.
	m_Contents.AddTail(hndFileReg);

	//
	// Add files to file map.
	//
	if (pFileRegSet->IsNodeType(nodetypeRegFile))
	{
#ifdef REGISTRY_FILEMAP
		TCHAR szKey[MAX_PATH];
		_tcscpy(szKey, *hndFileReg->GetFilePath());
		_tcsupr(szKey);

		m_FileMap.SetAt(szKey, hndFileReg);
#endif

		// Filter file.
		FilterFile(hndFileReg);
	}

	InformNotifyRxs(FRI_ADD, (DWORD)hndFileReg);
 	
	return TRUE;
}

BOOL CFileRegistry::RemoveRegistryHandle(FileRegHandle hndFileReg)
{
	// If the item being destroyed is still in us then remove it.
	POSITION pos = m_Contents.Find(hndFileReg);
	ASSERT(NULL!=pos);
	if (NULL==pos)
		return FALSE;


	//
	// Notify dependents this handle is being destroyed.
	//
	InformNotifyRxs(FRI_DESTROY, (DWORD)hndFileReg);

	// Is the CFileRegEntry a CFileRegSet if so then we must
	// set up the associated file registry...
	CFileRegSet * pFileRegSet = (CFileRegSet *)hndFileReg;

	if (pFileRegSet->IsNodeType(nodetypeRegSet))
	{
		// Remove from notification list.
//		pFileRegSet->RemoveNotifyRx(this);

		pFileRegSet->SetFileRegistry(NULL);
	}

	m_Contents.RemoveAt(pos);

	if (pFileRegSet->IsNodeType(nodetypeRegFile))
	{
#ifdef REGISTRY_FILEMAP
		TCHAR szKey[MAX_PATH];
		_tcscpy(szKey, *hndFileReg->GetFilePath());
		_tcsupr(szKey);
		VERIFY(m_FileMap.RemoveKey(szKey));
#endif

		// Remove from filters.
		UnFilterFile(hndFileReg);
	}

	// Release reference held by this file set.
	hndFileReg->ReleaseFRHRef();

	return TRUE;
}


#endif //#ifdef REFCOUNT_WORK


#ifdef _DEBUG

// DumpHeap() function, for use from the debugger.

// TrackFreeblocks: call this to have the CRT start saving freed blocks instead of actually
//		releasing them.  This is for measurement of heap churn.
extern void __cdecl TrackFreeblocks()
{
	_CrtSetDbgFlag(_CrtSetDbgFlag(_CRTDBG_REPORT_FLAG) |
				   _CRTDBG_DELAY_FREE_MEM_DF);
}
extern BOOL __cdecl DumpHeap()	// for use from debugger
{
	CWaitCursor wc;
	CMemStat stat;
	stat.ReportInExcel();
	return TRUE;
}

#endif

///////////////////////////////////////////////////////////////////////////////
//
//	Instantiate the file registry

CFileRegistry AFX_DATA_EXPORT g_FileRegistry;

// Helper function: Takes a list of FileRegHandles and make a CString out
// of them:

static CString strCachedOutDirValue;

void ClearMQSCache()
{
	strCachedOutDirValue = _T("<empty>");
}

void MakeQuotedString
( 
	CFileRegSet * pregset,
	CString & strOut,
	const CDir * pBaseDir /* = NULL*/, 
	BOOL bQuote /*= TRUE*/,
	BOOL (*pfn) (DWORD, FileRegHandle) /*= NULL*/,
	DWORD dwFuncCookie /*= NULL*/,
	const TCHAR *pSeparator /*= NULL*/,
	BOOL bOneOnly /* = FALSE */,
	const CObList *plItems, /* = NULL */
	BOOL bSort /* = FALSE */
)
{
	CFRFPtrArray * pregarray = new CFRFPtrArray;
#ifndef REFCOUNT_WORK
	pregarray->SetSize( pregset->GetContent()->GetCount() );
#else
	pregarray->SetSize( pregset->GetCount() );
#endif

	// init. the fileset enumeration
	pregset->InitFrhEnum();

	FileRegHandle frh;
	int index = 0;
	while ((frh = pregset->NextFrh()) != (FileRegHandle)NULL)
	{
		pregarray->SetAt( index, frh );
		index++;
	}

#ifndef REFCOUNT_WORK
	ASSERT( pregarray->GetSize() == pregset->GetContent()->GetCount() );
#else
	ASSERT( pregarray->GetSize() == pregset->GetCount() );
#endif

	MakeQuotedString( pregarray, strOut, pBaseDir, bQuote, pfn, dwFuncCookie, 
		pSeparator, bOneOnly, plItems, bSort );

#ifdef REFCOUNT_WORK
	for (index=0; index < pregarray->GetSize(); index++)
		(*pregarray)[index]->ReleaseFRHRef();
#endif

	delete pregarray;
}

int __cdecl CmpCStrings(const void * pstr1, const void * pstr2)
{
	return ((CString *)pstr1)->CompareNoCase((LPCSTR)*(CString *)pstr2);
}

void MakeQuotedString
( 
	CFRFPtrArray * pregarray,
	CString & strOutput,
	const CDir * pBaseDir /* = NULL*/, 
	BOOL bQuote /*= TRUE*/,
	BOOL (*pfn) (DWORD, FileRegHandle) /*= NULL*/,
	DWORD dwFuncCookie /*= NULL*/,
	const TCHAR *pSeparator /*= NULL*/,
	BOOL bOneOnly /* = FALSE */,
	const CObList *plItems, /* = NULL */
	BOOL bSort /* = FALSE */
)
{
	// increase size of output buffer
	// (note, it is not necessarily empty to begin with)
	int len = strOutput.GetLength();
	strOutput.GetBuffer(2048);
	strOutput.ReleaseBuffer(len);

	// default seperator?
	if (pSeparator == (TCHAR *)NULL)
		pSeparator = _TEXT(" ");

	CString str;
	CString strOutDirMacro, strOutDirValue;
	static CDir CachedOutDir;
	static CDir CachedBaseDir;
	CDir * pOutDir = (CDir *)NULL;
	CProjItem * pItem;
	CProjItem * pItemOld;
	CProjItem * pHeadItem = NULL;
	ConfigurationRecord * pcrToMatch = (ConfigurationRecord *)NULL;

	POSITION pos2 = plItems != (const CObList *)NULL ? plItems->GetHeadPosition() : (POSITION)NULL;

	// we must match the config. of the item at the head for the rest of the items
	if (pos2 != (POSITION)NULL)
	{
		if (plItems->GetCount() > 1)
			pHeadItem = ((CProjItem *)plItems->GetNext(pos2));
		else
			pHeadItem = ((CProjItem *)plItems->GetHead());

		pcrToMatch = (ConfigurationRecord *)pHeadItem->GetActiveConfig();
	}

	// copy of formatted strings to be sorted
	CStringArray strOutArray;
	int nOutSize = pregarray->GetSize();
	strOutArray.SetSize(nOutSize);
	CString strOut;
	int index = 0;
	int nOutDirType;
	UINT nID;
	BOOL bOutDir;
	
	for ( int ifrh = 0; ifrh < pregarray->GetSize(); ifrh++ )
	{
		FileRegHandle frh = (*pregarray)[ifrh];
		if (pfn != NULL && !(*pfn)(dwFuncCookie, frh))
		{
			nOutSize--;
			continue; 
		}

		CFileRegFile * preg = (CFileRegFile *)g_FileRegistry.GetRegEntry(frh);
		CPath * pPath = (CPath *)preg->GetFilePath();
		ASSERT_VALID(pPath);

		// when at the end of the item list, keep using the last known
		if (pos2 != (POSITION)NULL)
		{
			ASSERT(pcrToMatch);
			pOutDir = (CDir *)NULL;
			bOutDir = FALSE;
			pItem = (CProjItem *)plItems->GetNext(pos2);

			if (pItem != NULL) // no outdir if pItem is NULL
			{
				pItem->SetManualBagSearchConfig(pcrToMatch);
				
		 		bOutDir = (pItem->GetOutDirString(strOutDirMacro, &strOutDirValue));
				pItem->ResetManualBagSearchConfig();
			}
			else if ((nOutDirType = preg->GetOutDirType()) > 0)
			{
				ASSERT(pHeadItem != NULL);
				ASSERT(nOutDirType <= 2);
				nID = (nOutDirType==1) ? P_OutDirs_Target : P_OutDirs_Intermediate;

				pItem = pHeadItem;
				while ((pItem!=NULL) && (!pItem->IsKindOf(RUNTIME_CLASS(CProject))))
				{
					pItemOld = pItem;
					pItem = (CProjItem *)pItem->GetContainerInSameConfig();
					if (pItemOld != pHeadItem)
						pItemOld->ResetContainerConfig();
				}

				if (pItem != NULL)
				{
					bOutDir = pItem->GetOutDirString(strOutDirMacro, nID, &strOutDirValue, TRUE, FALSE);
				}
			}

			if (bOutDir && (pBaseDir!=NULL))
			{
				// FUTURE (karlsi): slightly broken on LHS when (pItem && !bOneOnly)
				// olympus 1797 [patbr]: don't create OutDir from relative path because
				// the current working directory may be used, which means that the GetRelativeName()
				// call below will return a non-relative path (i.e., without ".\" at start) which
				// means that all the $(OUTDIR) and $(INTDIR) macros disappear from the MAK file.
				if ((strOutDirValue == strCachedOutDirValue) && (*pBaseDir==CachedBaseDir))
				{
					pOutDir = &CachedOutDir;
				}
				else // must base $(OUTDIR) on project dir
				{
					ASSERT(pBaseDir!=NULL);
					CPath tempPath;
					CString strTemp = strOutDirValue + _T("\\a");
					if ((tempPath.CreateFromDirAndRelative(*pBaseDir, strTemp)) && (CachedOutDir.CreateFromPath(tempPath)))
					{
						strCachedOutDirValue = strOutDirValue;
						CachedBaseDir = *pBaseDir;
						pOutDir = &CachedOutDir;
					}
				}
			}
		}

		strOut.GetBuffer(63);
		strOut.ReleaseBuffer(0);

		int nPathStart = 0;
		if (pOutDir &&
			(pPath->GetRelativeName(*pOutDir, str, FALSE, TRUE)) &&
			(str[nPathStart++] == _T('.') && (str[nPathStart] == _T('\\'))))
		{
#if 0	// REVIEW: should no longer be necessary for .objs/.sbrs or anything
			// replace '.\' at head of relative path with './' to fix NMAKE bug
			str.SetAt(1, _T('/')); // REVIEW: is this fixed yet in NMAKE???
#endif

			// quote?
			if (bQuote) strOut += _T('"');

			strOut += strOutDirMacro;
			strOut += ((const TCHAR *)str + 1);	// skip '.'

			// quote?
			if (bQuote) strOut += _T('"');
		}
		else if (pBaseDir)
		{
			// always get a relative path
			BOOL fOldAlwaysRelative = pPath->GetAlwaysRelative();
			pPath->SetAlwaysRelative();
			pPath->GetRelativeName(*pBaseDir, str);
			pPath->SetAlwaysRelative(fOldAlwaysRelative);
			CDir dir;
			dir.CreateFromPath(*pPath);

			// only the include files will go through the ifs, because none of the other cases
			// will set the condition we test for.
			if ( dir == *pBaseDir )
			{
				// quote?
				if (bQuote) strOut += _T('"');

				strOut += str;

				// quote?
				if (bQuote)	strOut += _T('"');
			}	
			else if (preg->IsFileFoundInIncPath() && (g_nSharability != SHARE_LOW) )
			{
				strOut += _T("{$(INCLUDE)}");

				// quote?
				if (bQuote)	strOut += _T('"');

				// strOut += _T('\\');

				// need to exclude the path from the name
				int ich = preg->GetIndexNameRelative();
				if (ich)
					strOut += str.Right(ich);
				else
					// need original name 
					strOut += preg->GetOrgName(); 

				// quote?
				if (bQuote)	strOut += _T('"');
			}
			else if ( g_nSharability == SHARE_HIGH )
			{
				strOut += _T("{$(INCLUDE2)}");

				// quote?
				if (bQuote)	strOut += _T('"');

				strOut += _T('\\');

				int ich = preg->GetIndexNameRelative();
				if (ich)
					strOut += str.Right(ich);
				else
					strOut += pPath->GetFileName();

				// quote?
				if (bQuote)	strOut += _T('"');
			}
			else
			{
				// quote?
				if (bQuote)	strOut += _T('"');

				strOut += str;

				// quote?
				if (bQuote)	strOut += _T('"');
			}
		}
		else
		{
			// Quote really means quote if there are special charactes
			// involved:
			if (bQuote && pPath->ContainsSpecialCharacters())
			{ 
				strOut += _T('"');
				strOut += (const TCHAR *) *pPath;
				strOut += _T('"');
			}
			else
			{
				strOut += (const TCHAR *) *pPath;
			}
		}

		strOutArray.SetAt(index++, strOut);

		if (bOneOnly)	// stop if we only want the first valid item
			break;
	}

	nOutSize = index; // update size

	// sort if required
	if ((bSort) && (nOutSize > 1))
	{
		qsort(strOutArray.GetData(), nOutSize, sizeof(CString *), CmpCStrings);
	}

	// do final formatting here into strOutput
	for ( index = 0; index < nOutSize; index++)
	{
		if (index!=0)
			strOutput += pSeparator;

		strOutput += strOutArray[index];
	}
	strOutArray.RemoveAll();
}

///////////////////////////////////////////////////////////////////////////////
//
//	Special collection class for dependency lists.

void CSmallPtrSet::RemoveItem(void *pItem)
{
	for (int i = 0; i < m_nSize; i++)
	{
		if (m_pData[i] == pItem)
		{
			RemoveAt(i);
			break;		// only once
		}
	}
}

void* CSmallPtrSet::GetNext(POSITION& rPosition) const
{
	ASSERT(rPosition != NULL && int(rPosition) <= m_nSize);

	void *pItem = m_pData[int(rPosition) - 1];

	rPosition = POSITION(int(rPosition) + 1);
	if (int(rPosition) > m_nSize)
		rPosition = NULL;

	return pItem;
}

POSITION CSmallPtrSet::Find(void const * const pItem)
{
	for (int i = 0; i < m_nSize; i++)
	{
		if (m_pData[i] == pItem)
		{
			return POSITION(i + 1);
		}
	}
	return NULL;
}

//
// Slow GetFileAttributesEx for operating systems that do not support it.
//

extern BOOL (WINAPI *g_pGetFileAttributesEx_DevBld)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
static BOOL WINAPI Choose_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
static BOOL WINAPI Slow_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);


BOOL (WINAPI *g_pGetFileAttributesEx_DevBld)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation) = Choose_GetFileAttributesEx;

static BOOL WINAPI Choose_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	//
	// Block any other threads using mutex.  This is normally a one shot deal.
	//
	TCHAR szMutexName[50];

	//
	// Create a mutex name that is unique each process.
	//
	_stprintf( szMutexName, _T("Choose_GetFileAttributesEx:devbld:%lX"), GetCurrentProcessId() );

	HANDLE hMutex = CreateMutex( NULL, FALSE, szMutexName );
	if (NULL==hMutex)
	{
		ASSERT(0);
		if (&Choose_GetFileAttributesEx==g_pGetFileAttributesEx_DevBld)
		{
			g_pGetFileAttributesEx_DevBld = &Slow_GetFileAttributesEx;
			TRACE("Slow_GetFileAttributesEx was selected by Choose_GetFileAttributesEx because of failure\n");
		}
	}
	else
	{
		// Time out after 10 seconds. 
		DWORD dwWait = WaitForSingleObject(hMutex, 10000L);

		switch(dwWait)
		{
		case WAIT_OBJECT_0:
			if (&Choose_GetFileAttributesEx==g_pGetFileAttributesEx_DevBld)
			{
				HINSTANCE hLib = GetModuleHandle( _T("kernel32.dll") );
				if (NULL!=hLib)
				{
#ifdef _UNICODE
					FARPROC lpProc = GetProcAddress(hLib, "GetFileAttributesExW" );
#else
					FARPROC lpProc = GetProcAddress(hLib, "GetFileAttributesExA" );
#endif
					if (NULL!=lpProc)
					{
						g_pGetFileAttributesEx_DevBld = 
							(BOOL (WINAPI *)( LPCTSTR, GET_FILEEX_INFO_LEVELS,LPVOID))lpProc;
						TRACE("GetFileAttributesEx was selected by Choose_GetFileAttributesEx\n");
					}
					else
					{
						g_pGetFileAttributesEx_DevBld = &Slow_GetFileAttributesEx;
						TRACE("Slow_GetFileAttributesEx was selected by Choose_GetFileAttributesEx\n");
					}
				}

			}
			VERIFY(ReleaseMutex(hMutex));
			break;

		case WAIT_TIMEOUT:
		case WAIT_ABANDONED:
		default:
			//
			// Use Slow_GetFileAttributesEx when checking for GetFileAttributesEx fails.
			//
			ASSERT(0);
			if (&Choose_GetFileAttributesEx==g_pGetFileAttributesEx_DevBld)
			{
				g_pGetFileAttributesEx_DevBld = &Slow_GetFileAttributesEx;
			}
			TRACE("Slow_GetFileAttributesEx was selected by Choose_GetFileAttributesEx because of failure\n");
			break;
		}
		CloseHandle(hMutex);
	}
	return (*g_pGetFileAttributesEx_DevBld)( lpFileName, fInfoLevelId, lpFileInformation);
}

//
// Slow_GetFileAttributesEx is used when GetFileAttributesEx is unsupported.
//
static BOOL WINAPI Slow_GetFileAttributesEx( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	WIN32_FILE_ATTRIBUTE_DATA*  pFileData = (WIN32_FILE_ATTRIBUTE_DATA*)lpFileInformation;

	ASSERT(GetFileExInfoStandard==fInfoLevelId);

	WIN32_FIND_DATA find;
	HANDLE hfind = ::FindFirstFile(lpFileName, &find);

	if (hfind != INVALID_HANDLE_VALUE)
	{
		::FindClose(hfind);

		pFileData->dwFileAttributes = find.dwFileAttributes;
		pFileData->ftCreationTime = find.ftCreationTime; 
		pFileData->ftLastAccessTime = find.ftLastAccessTime; 
		pFileData->ftLastWriteTime = find.ftLastWriteTime; 
		pFileData->nFileSizeHigh = find.nFileSizeHigh; 
		pFileData->nFileSizeLow = find.nFileSizeLow; 

		return TRUE;
	}
	else
	{
		return FALSE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\prjdlg.cpp ===
// prjdlg.cpp : implementation file
//

#include "stdafx.h"
#include "bldiface.h"
#include "awiface.h"
#include <dlgbase.h>
#include "prjdlg.h"
#include "prjconfg.h"
#include "resource.h"
#include "exttarg.h"
#include "prjguid.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static int 	g_nLastPT = -1;

// Defined in bldiface.cpp
CAppWizIFace* GetAppWizIFace();

extern CString g_strTarg;

#define MAX_DISP  62


// This is the registry key under which we remember which platforms were last checked
//  by the user.  By using the registry, we always remember the user's "favorite"
//  platforms from session to session.
// COLINT: Since this is no longer in AppWizard, you may want to change the key's name.
static const char szDefPltSection[] = "AppWizard\\Default Platforms";


/////////////////////////////////////////////////////////////////////////////
// Japanese-specific functions

// This tests whether we're on a Japanese system
inline BOOL IsJapaneseSystem(void)
{
	return (PRIMARYLANGID(GetSystemDefaultLangID()) == LANG_JAPANESE);
}

// This function assumes we're on a Japanese system
BOOL IsSBKatakana(unsigned char c)
{
	return c >= 0xa1 && c <= 0xdf;
}


/////////////////////////////////////////////////////////////////////////////
// Configuration name validation
//
// A valid config name is at most <filename> characters according to the 
// file system, and contains only alphanumeric, underscore, single-byte
// katakana, or double-byte characters.

BOOL IsValidConfigName(LPCTSTR psz)
{
	if (*psz == _T('\0') || *psz == _T('.'))
		return FALSE;
	
	int cchLeft = 8;                // 8 for file name
	DWORD dwMaxLen = 8;
	DWORD  dwDummy1;
	if (::GetVolumeInformation(NULL, NULL, 0, NULL, &dwMaxLen,
		&dwDummy1, NULL, 0))
	{
		// succesfully got info from file system -- use it.
		cchLeft = (int)dwMaxLen;
	}
	
	TCHAR ch;
	while ((ch = *psz) != _T('\0'))
	{
		if (_istalnum(ch) || ch == _T('_') || ch == _T(' ') || IsDBCSLeadByte(ch)
			|| (IsJapaneseSystem() && IsSBKatakana(ch)) || ch < 0)
		{
			// count the character
			cchLeft -= _tclen(psz);
			// leave 8 for file name (Win95J is one character too short for MAX_LENGTH, so adjust it to 9)
			if (cchLeft < 9)
				return FALSE;		// too long
		}
		else
		{
			// illegal
			return FALSE;
		}
		psz = _tcsinc(psz);
	}
	return TRUE;
}

void DDV_ProjectName(CDataExchange* pDX, const CString & strProjName)
{
	if (!pDX->m_bSaveAndValidate)
		return;
	if (!IsValidConfigName(strProjName))
	{
		AfxMessageBox( IDS_INVALID_CONFIGNAME, MB_OK, 0);
		pDX->Fail();
	}
}

/////////////////////////////////////////////////////////////////////////////
// CNewProjectCopyDlg dialog

CNewProjectCopyDlg::CNewProjectCopyDlg(LPCTSTR pszProject, CWnd* pParent /*=NULL*/)
	: C3dDialog(CNewProjectCopyDlg::IDD, pParent)
{
	m_strProject = pszProject;
	m_bTrackBasedOn = TRUE;
}

CNewProjectCopyDlg::~CNewProjectCopyDlg()
{
	// Free the target list
	POSITION pos = m_ProjectTargets.GetHeadPosition();
	CProjectTargetRec *pTarget;
	while (pos)
	{
		pTarget = (CProjectTargetRec *)m_ProjectTargets.GetNext( pos );
		ASSERT_VALID( pTarget );

		delete pTarget;
	}
	m_ProjectTargets.RemoveAll();
}

void CNewProjectCopyDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewProjectCopyDlg)
		DDX_Control(pDX, IDC_TARGET_LISTCOMBO, m_TargetList);
		DDX_Control(pDX, IDC_TARGET_PLATFORM, m_Platforms);
		DDX_Text(pDX, IDC_PROJ_NAME, m_strProjName);
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
	DDV_ProjectName(pDX, m_strProjName);
}

BEGIN_MESSAGE_MAP(CNewProjectCopyDlg, C3dDialog)
	//{{AFX_MSG_MAP(CNewProjectCopyDlg)
		ON_LBN_SELCHANGE(IDC_TARGET_LISTCOMBO, OnSelchangeCopyFrom)
		ON_LBN_SELCHANGE(IDC_TARGET_PLATFORM, OnSelchangePlatform)
		ON_EN_CHANGE(IDC_PROJ_NAME, OnChangeProjName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewProjectCopyDlg message handlers

BOOL CNewProjectCopyDlg::OnInitDialog()
{
	m_pTarget = NULL;

	C3dDialog::OnInitDialog();

	m_pProject = g_pActiveProject;
	ASSERT (m_pProject != NULL);

	m_TargetList.ResetContent();

	CString	strCurrentConfigName;
	HFILESET hFileset = NULL;
	if (m_strProject.IsEmpty())
	{
		m_pProject->GetStrProp(P_ProjActiveConfiguration, strCurrentConfigName);
	}
	else
	{
		hFileset = g_BldSysIFace.GetFileSetFromTargetName(m_strProject, ACTIVE_BUILDER);
		// make sure we have the right project for this fileset!
		m_pProject = (CProject *)g_BldSysIFace.GetBuilderFromFileSet(hFileset);
		g_BldSysIFace.GetTargetNameFromFileSet(hFileset, strCurrentConfigName, (HBUILDER)m_pProject);
	}

	// Make sure we are in the required config
	CProjTempConfigChange projTempConfigChange(m_pProject);
	projTempConfigChange.ChangeConfig(strCurrentConfigName);
	CProjectTargetRec *pTarget;
	CProjType * pprojtype;

	// UNDONE: allow configs from other projects!
	const CPtrArray * pCfgArray;
	if (hFileset != NULL)
		pCfgArray = g_BldSysIFace.CnvHFileSet(NO_BUILDER, hFileset)->GetConfigArray();
	else
		pCfgArray = m_pProject->GetConfigArray();
	int cCfgs = pCfgArray->GetSize();
	for (int i = 0; i < cCfgs; i++)
	{
		ConfigurationRecord *pConfiguration = (ConfigurationRecord *)pCfgArray->GetAt(i);
		ASSERT_VALID(pConfiguration);

		// Is it valid?
		if (hFileset != NULL && !pConfiguration->IsValid())
			continue;

		// This target name.
		CString strConfigName = pConfiguration->GetConfigurationName();

		// Create a new CProjectTargetRec
		pTarget = new CProjectTargetRec;
		pTarget->m_strName = strConfigName;

		VERIFY(g_prjcompmgr.LookupProjTypeByName(LPCTSTR(pConfiguration->GetOriginalTypeName()), pprojtype));
		pTarget->m_strType = *pprojtype->GetTypeUIDescription();
		pTarget->m_strUIType = *pprojtype->GetUIDescription();
		pTarget->m_strPlatform = *pprojtype->GetPlatformUIDescription();
		pTarget->m_bDebug = IsDebug(pConfiguration);
		pTarget->m_bSupported = pprojtype->IsSupported();

		// Add it to the target list
		m_ProjectTargets.AddTail(pTarget);

		// Add it to the list box
		int iEntry = m_TargetList.AddString(pTarget->m_strName);
		ASSERT(iEntry != LB_ERR);
		m_TargetList.SetItemDataPtr(iEntry, (void *) pTarget);
	}

	int iCurSel = m_TargetList.FindStringExact(-1, strCurrentConfigName);
	if (iCurSel == LB_ERR && m_TargetList.GetCount() > 0)
		iCurSel = 0;	// select first if current not found

	if (iCurSel != LB_ERR)
	{
		// set the project type name 
		m_TargetList.SetCurSel(iCurSel);

		m_bTrackBasedOn = TRUE;
		OnSelchangeCopyFrom();
		((CEdit *)GetDlgItem(IDC_PROJ_NAME))->SetSel(0, -1);

		m_pTarget = (CProjectTargetRec *)m_TargetList.GetItemDataPtr(iCurSel);
	}

	UpdateTargetNameText();

	return FALSE;
}

void CNewProjectCopyDlg::OnOK()
{
	if (!UpdateData(TRUE))
		return;
	if (!AddSelectedTarget())
	{
		CProjType * pProjType;
		VERIFY(g_prjcompmgr.LookupProjTypeByUIDescription(m_pTarget->m_strUIType, pProjType));
		ASSERT_VALID(pProjType);
		if (pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
		{
			AfxMessageBox(IDS_CANNOT_ADD_EXTCONFIG, MB_OK | MB_ICONEXCLAMATION);
		}
		return;
	}

	C3dDialog::OnOK();
}

BOOL CNewProjectCopyDlg::AddSelectedTarget()
{
	TrgCreateOp trgop = TrgMirror; SettingOp setop = SettingsDefault;
	HBLDTARGET hTarg = NO_TARGET, hSettingsTarg = NO_TARGET;
	HBUILDER hBld = g_BldSysIFace.GetActiveBuilder(); // default

	ASSERT_VALID (m_pTarget);

	// target to copy
	hTarg = g_BldSysIFace.GetTarget(m_pTarget->m_strName, hBld);
	hBld = g_BldSysIFace.GetBuilder(hTarg); // don't assume it's the active project

	int iUseMFC;
	g_BldSysIFace.GetTargetProp(hTarg, Prop_UseOfMFC, iUseMFC);

	// copy settings?
	hSettingsTarg = hTarg;
	setop = SettingsClone;

	// get our platform and target type name
	CProjType * pProjType;
	VERIFY(g_prjcompmgr.LookupProjTypeByUIDescription(m_pTarget->m_strUIType, pProjType));
	ASSERT_VALID(pProjType);

	CString strUIPlatformName = GetPlatformName();
	CString strTargetName = ConstructTargetName(strUIPlatformName);

	g_strTarg = (g_BldSysIFace.CnvHTarget(hBld, hTarg))->GetTargDir();

	// Make sure this name doen't already exist
	HBUILDER hTBld;
	CString strProject, strTarget;
	g_BldSysIFace.InitBuilderEnum();
	while ((hTBld = g_BldSysIFace.GetNextBuilder(strProject)) != NO_BUILDER)
	{
		// Prepare to enumerate the targets
		g_BldSysIFace.InitTargetEnum(hTBld);

		// Enumerate all the targets
		HBLDTARGET hTarget = g_BldSysIFace.GetNextTarget(strTarget, hTBld);
		while (hTarget != NO_TARGET)
		{
			if (strTarget.CompareNoCase(strTargetName) == 0)
			{
				// target already exist
				AfxMessageBox(IDS_PROJNAME_EXISTS, MB_OK | MB_ICONEXCLAMATION);
				return FALSE;
			}
			hTarget = g_BldSysIFace.GetNextTarget(strTarget, hTBld);
		}
	}

	// perform this operation using the build interface
	return g_BldSysIFace.AddTarget
	(
		// name of this target
		(LPCTSTR)strTargetName,

		(LPCTSTR)strUIPlatformName,						// UI name of this target's platform
		(const TCHAR *)*pProjType->GetTypeUIDescription(),	// UI name of this target type
		TRUE,										// we're using 'UI' names.

		m_pTarget->m_bDebug,						// debug or release settings? default=debug

		trgop,										// clone or mirror another target? default=no
		hTarg,										// target to clone or mirror

		setop,										// copy or default settings?
		hSettingsTarg,								// target to copy settings from
		 
		FALSE,										// show any warnings/errors during creation? default=yes
		TRUE,										// create a new set of output directories
		(iUseMFC != NoUseMFC),						// using MFC?
		hBld										// add to current builder
	) != NO_TARGET;

}

void CNewProjectCopyDlg::OnSelchangeCopyFrom()
{
	// change the project's active configuration 
	int	iCurSel = m_TargetList.GetCurSel();

	if (iCurSel == LB_ERR)
		return;

	// setting the window text
	m_pTarget = (CProjectTargetRec *)m_TargetList.GetItemDataPtr(iCurSel);
	ASSERT_VALID (m_pTarget);

	const CStringList* pPlatformList = g_prjcompmgr.GetListOfPlatforms(m_pTarget->m_strType, TRUE);
	CString strUI;

	// Clear the platforms listbox and add in the supported platform
	// names.
	m_Platforms.SetRedraw(FALSE);
	m_Platforms.ResetContent();
	POSITION pos = pPlatformList->GetHeadPosition();
	while (pos != NULL)
	{
		strUI = pPlatformList->GetNext(pos);
		int iEntry = m_Platforms.AddString(strUI);
		ASSERT(iEntry != LB_ERR);
		CPlatform * pPlatform;
		g_prjcompmgr.LookupPlatformByUIDescription(strUI, pPlatform);
		m_Platforms.SetItemDataPtr(iEntry, (void *)pPlatform );
	}

	m_Platforms.SetRedraw(TRUE);

	// Try to select the platform that was originally selected if it is
	// still available. Otherwise we select the first platform.
	if (m_Platforms.SelectString(-1, m_pTarget->m_strPlatform) == LB_ERR)
		m_Platforms.SetCurSel(0);	

	if (m_bTrackBasedOn)
	{
		VERIFY(g_BldSysIFace.GetFlavourFromConfigName(m_pTarget->m_strName, m_strProjName));
 		SetDlgItemText(IDC_PROJ_NAME, m_strProjName);
		m_bTrackBasedOn = TRUE;
	}

	UpdateTargetNameText();
}

void CNewProjectCopyDlg::OnChangeProjName()
{
	m_bTrackBasedOn = FALSE;

	GetDlgItemText(IDC_PROJ_NAME, m_strProjName);
	UpdateTargetNameText();
}

void CNewProjectCopyDlg::OnSelchangePlatform()
{
	UpdateTargetNameText();
}

void CNewProjectCopyDlg::UpdateTargetNameText()
{
	if (m_pTarget == NULL)
		return;

	SetDlgItemText(IDC_STATIC_CONFIG_NAME, 
		ConstructTargetName(GetPlatformName()));
}

CString CNewProjectCopyDlg::GetPlatformName ()
{
	ASSERT_VALID (m_pTarget);

	CString strPlatform;
	int iCurSel = m_Platforms.GetCurSel();	
	if (iCurSel != LB_ERR)
	{
		m_Platforms.GetWindowText(strPlatform);
		CPlatform * pPlatform = (CPlatform *)m_Platforms.GetItemDataPtr(iCurSel);
		strPlatform = *pPlatform->GetUIName();
	}
	else
		strPlatform = m_pTarget->m_strPlatform;

	return strPlatform;
}

CString CNewProjectCopyDlg::ConstructTargetName(const CString &strPlatform)
{
	ASSERT_VALID(m_pTarget);

	CString strName;
	if (!IsValidConfigName(m_strProjName))
	{
		strName.LoadString(IDS_INVALID);
		return strName;
	}
	int ich = m_pTarget->m_strName.Find('-');
	if (ich != -1)
		strName = m_pTarget->m_strName.Left(ich);
	else
		strName = m_pTarget->m_strName;

	return (strName + _TEXT("- ") + strPlatform + _TEXT(" ") + m_strProjName);
}

BOOL CNewProjectCopyDlg::IsDebug(ConfigurationRecord *pConfig)
{
	int bDebug;

	m_pProject->SetManualBagSearchConfig(pConfig);
	m_pProject->GetIntProp(P_UseDebugLibs, bDebug);
	m_pProject->ResetManualBagSearchConfig();

	return bDebug != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\prjdlg.h ===
// prjdlg.h : header file
//

#ifndef _INCLUDE_PRJDLG_H
#define _INCLUDE_PRJDLG_H

#ifndef __UTILBLD__H__
#include <utilbld_.h>
#endif

// Values to switch() on after CPromptDlg's DoModal.  Stored in CPromptDlg::m_nCreator
enum
{
		CREATOR_APPWIZ,		// We should start up AppWizard steps
		CREATOR_IDE,		// The user is creating an empty IDE project (no appwiz)
		CREATOR_CANCEL		// The user hit cancel	
};

#define MAX_PLATFORMS	8

/////////////////////////////////////////////////////////////////////////////
// CNewProjectCopyDlg dialog

class CProjectTargetRec : public CObject
{
// Attributes:
public:
	CString m_strName;
	CString m_strType;
	CString m_strUIType;
	CString m_strPlatform;
	BOOL m_bDebug;
	BOOL m_bSupported;
};

/////////////////////////////////////////////////////////////////////////////

class CNewProjectCopyDlg : public C3dDialog
{
// Construction
public:
	CNewProjectCopyDlg(LPCTSTR pszProject, CWnd* pParent = NULL);   // standard constructor
	~CNewProjectCopyDlg();

// Dialog Data
	//{{AFX_DATA(CNewProjectCopyDlg)
	enum { IDD = IDD_INSERTPROJ_COPY };
	CComboBox m_TargetList;
	CComboBox m_Platforms;
	//}}AFX_DATA

// Implementation
protected:
	CString m_strProjName;
	CProject *m_pProject;
	CProjectTargetRec *m_pTarget;
 	CObList m_ProjectTargets;
	CString m_strProject;

	BOOL m_bTrackBasedOn;		// Track based on field for config name

	BOOL OnInitDialog();
	void OnSelchangeCopyFrom();
	void OnSelchangePlatform();
	void OnOK();
	void OnChangeProjName();
	BOOL IsDebug(ConfigurationRecord *pConfig);
	BOOL AddSelectedTarget();
	void DoDataExchange(CDataExchange* pDX);

	void UpdateTargetNameText ();
	CString GetPlatformName ();
	CString ConstructTargetName (const CString &strPlatform);

	DECLARE_MESSAGE_MAP()
};


#endif   // _INCLUDE_PRJDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\profdlg.h ===
//
// profdlg.h
//
// Defines CProfileDlg class, these are
// dialogs to obtain information that we don't have but need to complete
// a requested operation.
//
// Implementation is in : profdlg.cpp
//
// History:
// Date				Who			What
// 09/03/96			Winslowf	created
//
///////////////////////////////////////////////////////////////////////////////

#ifndef _PROGDLG_H_
#define _PROGDLG_H_

#include "resource.h"
//#include "prjconfg.h"
#include <dlgbase.h>		// C3dDialog
#include <srcapi.h>



///////////////////////////////////////////////////////////////////////////////
// CProfileDlg class
// definition for profiler dialog
///////////////////////////////////////////////////////////////////////////////

class CProfileDlg: public C3dDialog
{
	// Construction
public:
	CProfileDlg(BOOL bExecute = FALSE, CWnd * pParent = NULL);

	// Dialog Data
	//{{AFX_DATA(CProfileDlg)
	enum { IDD = IDD_PROFILE };
	static int m_btnIndex;
	static CString m_strComboCustom;
	static CString m_strEditAdvanced;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CJavaDebugInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
	enum PROFOPTIONS{FNTIMING, FNCOVERAGE, LNCOVERAGE, MERGE, CUSTOM, FNSAMPLING};
	
	void SetupPathFileName();
	void GetDebuggeeCommandLine(PSTR CommandLine, UINT size);

	CString strArgPrep1();
	CString strArgPrep2();
	CString strArgProfile();
	CString strArgPlist();
	CString strArgCustom();

	UINT Spawn(CStringList *slSpawnCmds);
	void RunProfiler();

protected:
	//{{AFX_MSG(CAboutDlg)
	afx_msg void OnPROFnTiming();
	afx_msg void OnPROFMerge();
	afx_msg void OnPROFnCover();
	afx_msg void OnPROFLnCover();
	afx_msg void OnPROFCustom();
	afx_msg void OnPROFBrowse();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

public:
	//{{AFX_MSG(CJavaDebugInfoDlg)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	// profiler dialog state retrieval/store from an archive
	static BOOL LoadProfOptStore(CArchive & archive);
	static BOOL SaveProfOptStore(CArchive & archive);

// private data
private:
	BOOL m_bExecute;
	CString m_strExe;
	CString m_strDir;
	CString m_strCmdLine;

	CString m_strPrep;
	CString m_strPlist;
	CString m_strProfile;
	CString m_strExtPbi;
	CString m_strExtMap;
};


class CBrowseDlg: public C3dFileDialog
{
// Construction
public:
	CBrowseDlg();
	~CBrowseDlg();

// Implementation
	int DoModal();
	CString GetFileName();

	// private data
private:
	TCHAR m_szFileBuff[_MAX_PATH];
};

extern BOOL g_fProfiling;
extern CConsoleSpawner *g_pSpawner;
BOOL FProfiling();

#endif // _PROGDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\progdlg.cpp ===
//
//	PROGDLG.CPP
//
//
// History
// =======
// Date			Who			What
// ----			---			----
// 22-May-93	danw		Created
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "progdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern HWND PASCAL _SushiGetSafeOwner(CWnd* pParent);

///////////////////////////////////////////////////////////////////////////////
//
// ----------------------------- CProgressDialog ------------------------------
//
///////////////////////////////////////////////////////////////////////////////
BOOL CProgressDialog::CreateProgressDialog	(
							LPCSTR lpszTemplateName, 
							CWnd *pParent /*= NULL*/)
{
//
//	Create the dialog and disable the main window:
//
	PreModalWindow();
	// allow OLE servers to disable themselves, usually called in CDialog::PreModal
	AfxGetApp()->EnableModeless(FALSE);

	ProgressDialogContinue = TRUE;
	if (!CDialog::Create (lpszTemplateName,
		FromHandle(_SushiGetSafeOwner(pParent))))
	{
		return FALSE;
	}
	AfxGetApp()->m_pMainWnd->EnableWindow(FALSE);
	EnableWindow (TRUE);
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
void CProgressDialog::DestroyProgressDialog  ()
{
	AfxGetApp()->m_pMainWnd->EnableWindow (TRUE);
	EnableWindow (FALSE);
	DestroyWindow();
	AfxGetApp()->EnableModeless(TRUE);
	PostModalWindow();
}
///////////////////////////////////////////////////////////////////////////////
void CProgressDialog::OnCancel()
{
//
//	Set the flag to false.  User still has to call DestroyProgressDialog.
//
	ProgressDialogContinue = FALSE;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProgressDialog::DoYield () 
{
//
//	Yield function calls PumpMessage, which will can IsDialog message.  This
//	needs to be changed if we have our own message pump:
//
	MSG msg;
	//
	//	FUTURE: Special yielding magic goes here:
	//
	while ( PeekMessage ( &msg, NULL, 0, 0, PM_NOREMOVE ) )
	{
		if (!AfxGetApp()->PumpMessage ()) return FALSE;

	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\profdlg.cpp ===
//
// Implementation for CProfDlg classes
//
// History:
// Date				Who			What
// 09/03/94			WinslowF	created
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"		// standard AFX include
#pragma hdrstop
#include "profdlg.h"
#include "resource.h"
#include "msgboxes.h"
// #include "utils.h"  // neither needed nor found bobz
#include "oleref.h"
#include "bldapi.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


UINT g_nidOWin = 0;
CConsoleSpawner *g_pSpawner = NULL;
LPOUTPUTWINDOW gpOutputWindow = NULL;
BOOL g_fProfiling = FALSE;
const char szProfFilter[] =	"Batch (*.bat;*.cmd)\0*.bat;*.cmd\0All Files (*.*)\0*.*\0\0";
int CProfileDlg::m_btnIndex = -1;
CString CProfileDlg::m_strComboCustom = _T("");
CString CProfileDlg::m_strEditAdvanced = _T("");


///////////////////////////////////////////////////////////////////////////////
// CProfileDlg implementation
///////////////////////////////////////////////////////////////////////////////
CProfileDlg::CProfileDlg(BOOL bExecute /*= FALSE*/, CWnd * pParent /*= NULL*/)
: C3dDialog(CProfileDlg::IDD, pParent),
  m_bExecute(bExecute)
{
	//{{AFX_DATA_INIT(CProfileDlg)
	m_strPrep    = "prep";
	m_strPlist   = "plist";
	m_strProfile = "profile";
	m_strExtPbi  = "pbi";
	m_strExtMap  = "map";
	//}}AFX_DATA_INIT
}

BEGIN_MESSAGE_MAP(CProfileDlg, C3dDialog)
	//{{AFX_MSG_MAP(CProfileDlg)
	ON_BN_CLICKED(IDC_PROF_FnTiming, OnPROFnTiming)
	ON_BN_CLICKED(IDC_PROF_Merge, OnPROFMerge)
	ON_BN_CLICKED(IDC_PROF_FnCover, OnPROFnCover)
	ON_BN_CLICKED(IDC_PROF_LnCover, OnPROFLnCover)
	ON_BN_CLICKED(IDC_PROF_Custom, OnPROFCustom)
	ON_BN_CLICKED(IDC_PROF_Browse, OnPROFBrowse)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////////
// CProfileDlg::DoDataExchange
void CProfileDlg::DoDataExchange(CDataExchange* pDX)
{
	C3dDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProfileDlg)
	DDX_Radio(pDX, IDC_PROF_FnTiming, m_btnIndex);
	DDX_Text(pDX, IDS_PROF_Custom, m_strComboCustom);
	DDX_Text(pDX, IDC_PROF_Advanced, m_strEditAdvanced);
	//}}AFX_DATA_MAP
}

///////////////////////////////////////////////////////////////////////////////
// CProfileDlg::OnInitDialog
BOOL CProfileDlg::OnInitDialog()
{

	// call the base class
	C3dDialog::OnInitDialog();
	if (m_btnIndex == -1)
	{
		CButton* cb = (CButton *) GetDlgItem(IDC_PROF_FnTiming);
		cb->SetCheck(1);
	}
	switch (m_btnIndex)
	{
	case MERGE:
		OnPROFMerge();
		break;
	case CUSTOM:
		OnPROFCustom();
		break;
	default:
		break;
	}
	return TRUE;
}


///////////////////////////////////////////////////////////////////////////////
// CProfileDlg::OnOK
void CProfileDlg::OnOK()
{
	UpdateData(TRUE);

	CDialog::OnOK();

	SetupPathFileName();
	RunProfiler();
}

/////////////////////////////////////////////////////////////////////////////
// CProfileDlg commands

void CProfileDlg::OnPROFnTiming() 
{
	// TODO: Add your control notification handler code here
	CButton* cbAdvanced = (CButton *) GetDlgItem(IDC_PROF_Advanced);
	CButton* cbBrowse = (CButton *) GetDlgItem(IDC_PROF_Browse);
	CButton* cbCustom = (CButton *) GetDlgItem(IDS_PROF_Custom);
	if(!cbAdvanced->IsWindowEnabled())
		cbAdvanced->EnableWindow(TRUE);
	if(cbBrowse->IsWindowEnabled())
		cbBrowse->EnableWindow(FALSE);
	if(cbCustom->IsWindowEnabled())
		cbCustom->EnableWindow(FALSE);
}

void CProfileDlg::OnPROFnCover() 
{
	// TODO: Add your control notification handler code here
	CButton* cbAdvanced = (CButton *) GetDlgItem(IDC_PROF_Advanced);
	CButton* cbBrowse = (CButton *) GetDlgItem(IDC_PROF_Browse);
	CButton* cbCustom = (CButton *) GetDlgItem(IDS_PROF_Custom);
	if(!cbAdvanced->IsWindowEnabled())
		cbAdvanced->EnableWindow(TRUE);
	if(cbBrowse->IsWindowEnabled())
		cbBrowse->EnableWindow(FALSE);
	if(cbCustom->IsWindowEnabled())
		cbCustom->EnableWindow(FALSE);
}

void CProfileDlg::OnPROFLnCover() 
{
	// TODO: Add your control notification handler code here
	CButton* cbAdvanced = (CButton *) GetDlgItem(IDC_PROF_Advanced);
	CButton* cbBrowse = (CButton *) GetDlgItem(IDC_PROF_Browse);
	CButton* cbCustom = (CButton *) GetDlgItem(IDS_PROF_Custom);
	if(!cbAdvanced->IsWindowEnabled())
		cbAdvanced->EnableWindow(TRUE);
	if(cbBrowse->IsWindowEnabled())
		cbBrowse->EnableWindow(FALSE);
	if(cbCustom->IsWindowEnabled())
		cbCustom->EnableWindow(FALSE);
}

void CProfileDlg::OnPROFMerge() 
{
	// TODO: Add your control notification handler code here
	CButton* cbAdvanced = (CButton *) GetDlgItem(IDC_PROF_Advanced);
	CButton* cbBrowse = (CButton *) GetDlgItem(IDC_PROF_Browse);
	CButton* cbCustom = (CButton *) GetDlgItem(IDS_PROF_Custom);
	if(cbAdvanced->IsWindowEnabled())
		cbAdvanced->EnableWindow(FALSE);
	if(cbBrowse->IsWindowEnabled())
		cbBrowse->EnableWindow(FALSE);
	if(cbCustom->IsWindowEnabled())
		cbCustom->EnableWindow(FALSE);
}

void CProfileDlg::OnPROFCustom() 
{
	// TODO: Add your control notification handler code here
	CButton* cbAdvanced = (CButton *) GetDlgItem(IDC_PROF_Advanced);
	CButton* cbBrowse = (CButton *) GetDlgItem(IDC_PROF_Browse);
	CButton* cbCustom = (CButton *) GetDlgItem(IDS_PROF_Custom);
	if(cbAdvanced->IsWindowEnabled())
		cbAdvanced->EnableWindow(FALSE);
	if(!cbBrowse->IsWindowEnabled())
		cbBrowse->EnableWindow(TRUE);
	if(!cbCustom->IsWindowEnabled())
		cbCustom->EnableWindow(TRUE);

}

void CProfileDlg::OnPROFBrowse() 
{
	// TODO: Add your control notification handler code here
	CBrowseDlg fDlg;

	if(fDlg.DoModal() == IDOK)
	{
		CComboBox* cbBrowse = (CComboBox *) GetDlgItem(IDS_PROF_Custom);
		cbBrowse->SetCurSel(cbBrowse->AddString(fDlg.GetFileName()));
	}
}

////////////////////////////////////////////////////////////////////////////
//
//	CProfileDlg::GetDebuggeeCommandLine
//
//	PURPOSE:	Gets the command line
//
////////////////////////////////////////////////////////////////////////////
void CProfileDlg::GetDebuggeeCommandLine(PSTR CommandLine, UINT size)
{
	PSTR pszCommandLine;
	UINT NumToCopy;
	TCHAR szGetBuf[_MAX_PATH];
	CString str;
	COleRef<IBuildSystem> pBldSysIFace;
	theApp.FindInterface(IID_IBuildSystem, (void**) pBldSysIFace.InOut());
// crappy to use FindInterface on ourselves, but I'm least fixing the leak

	// get the command-line from the project
	if (pBldSysIFace != NULL && (pBldSysIFace->IsActiveBuilderValid() == S_OK))
	{
		pBldSysIFace->GetProgramRunArguments(ACTIVE_BUILDER, str);
		_tcscpy(szGetBuf, (LPCTSTR)str);
	}
	else
	{
		ASSERT(theApp.m_jit.GetActive());
		szGetBuf[0] = _T('\0');
	}

	pszCommandLine	= szGetBuf;

	// OK, copy the command line across
	*CommandLine = '\0';
	NumToCopy = min(_ftcslen(pszCommandLine)+1, size-1);
	_ftcsncpy(CommandLine, pszCommandLine, NumToCopy-1);
	CommandLine[NumToCopy-1] = '\0';
}


void CProfileDlg::SetupPathFileName()
{
	CHAR	szExe[_MAX_PATH], _szExe[_MAX_PATH + 2], _szDir[_MAX_DIR], szFName[_MAX_FNAME], szDrive[_MAX_DRIVE], szDir[_MAX_DIR], _szCmdLine[256];

	if (!g_VPROJIdeInterface.Initialize())
	{
		ASSERT(FALSE);
		return;
	}

	EXEFROM exefrom;
	VERIFY(SUCCEEDED(g_VPROJIdeInterface.GetEditDebugStatus()->GetExecutableFilename(szExe, sizeof(szExe), &exefrom)));

	
	//GetExecutableFilename(szExe, sizeof(szExe));

	_splitpath(szExe, szDrive, szDir, szFName, NULL);

	// surround _szExe with quotes, since that is how it is always used
	_szExe[0] = _T('\"');
	_makepath(&(_szExe[1]), szDrive, szDir, szFName, NULL);
	int cb = strlen(_szExe);
	_szExe[cb] = _T('\"');
	_szExe[cb + 1] = '\0';

	_makepath(_szDir, szDrive, szDir, NULL, NULL);

	GetDebuggeeCommandLine(_szCmdLine, sizeof(_szCmdLine));
	
	m_strExe = _szExe;
	m_strDir = _szDir;
	m_strCmdLine = _szCmdLine;
}

CString CProfileDlg::strArgPrep1()
{
	CString strArg = "/nologo ";
	switch (m_btnIndex)
	{
	case FNTIMING:
		strArg += "/om /ft";
		break;
	case FNSAMPLING:
		strArg += "/fs";
		break;
	case FNCOVERAGE:
		strArg += "/om /fv";
		break;
	case LNCOVERAGE:
		strArg += "/lv";
		break;
	default:
		ASSERT(FALSE);
	}

	return strArg + " " + m_strEditAdvanced + " " +  m_strExe;
}

CString CProfileDlg::strArgPrep2()
{
	CString strArg = "/nologo /m ";

	return strArg + m_strExe;
}

CString CProfileDlg::strArgProfile()
{
	CString strArg = "/nologo";

	switch (m_btnIndex)
	{
	case FNSAMPLING:
		strArg += " /s 10000 /nc ";
		break;
	default:
		strArg += " /nc ";
	}

	return	strArg + m_strExe + " " + m_strCmdLine;
}

CString CProfileDlg::strArgPlist()
{
	CString strArg = "/nologo ";

	return strArg + m_strExe;
}

CString CProfileDlg::strArgCustom()
{
	CString strArg = m_strExe;

    return strArg + " " + m_strCmdLine;
}


void CProfileDlg::RunProfiler()
{
	//	must init only once
	if ( (gpOutputWindow == NULL) && SUCCEEDED(theApp.FindInterface(IID_IOutputWindow, (LPVOID *)&gpOutputWindow)))
	{
		// we have access to an output window
		CString strName;
		strName.LoadString(OWIN_PROFILE);
		TCHAR* szName = (TCHAR*)(const TCHAR*)strName;
		gpOutputWindow->OutputWindowAddVwin(szName, FALSE, &g_nidOWin);
	}
	
	CString strCmd = "";
	CStringList slSpawnCmds;

	switch (m_btnIndex)
	{
	case FNTIMING: 
	case FNSAMPLING:
	case FNCOVERAGE:
	case LNCOVERAGE:
		strCmd =	m_strPrep + " " + strArgPrep1();
		slSpawnCmds.AddTail(strCmd);
		strCmd = m_strProfile + " " + strArgProfile();
		slSpawnCmds.AddTail(strCmd);
		strCmd = m_strPrep + " " + strArgPrep2();
		slSpawnCmds.AddTail(strCmd);
		strCmd	= m_strPlist + " " + strArgPlist();
		slSpawnCmds.AddTail(strCmd);

		break;
	case MERGE:
		strCmd =	m_strProfile + " " + strArgProfile();
		slSpawnCmds.AddTail(strCmd);
		strCmd =	m_strPrep + " " + strArgPrep2();
		slSpawnCmds.AddTail(strCmd);
		strCmd =	m_strPlist + " " + strArgPlist();
		slSpawnCmds.AddTail(strCmd);
		break;
	case CUSTOM:
		strCmd =	m_strComboCustom + " " + strArgCustom();
		slSpawnCmds.AddTail(strCmd);
		break;
	default:
		ASSERT(FALSE);
	}
	
	Spawn(&slSpawnCmds);

}

UINT CProfileDlg::Spawn(CStringList *slSpawnCmds)
{
	UINT nRet;
	
	// get the environment from the directories manager
	CEnvironmentVariableList bldenviron;
	CDirMgr * pDirMgr = GetDirMgr();
	CString str;
	pDirMgr->GetDirListString(str, DIRLIST_PATH);
	bldenviron.AddVariable ("path", str);
	bldenviron.SetVariables();				// set it

	g_fProfiling = TRUE;
	g_pSpawner = new CConsoleSpawner(&g_pSpawner);
	g_pSpawner->m_fCloseWindow = TRUE;
	g_pSpawner->m_fGUITool = FALSE;
	g_pSpawner->m_fReloadNoPrompt = TRUE;
	g_pSpawner->InitializeSpawn((LPTSTR)LPCTSTR(m_strDir), g_nidOWin, TRUE);
	g_pSpawner->m_hNotifyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	// m_pSpawner is self-deleting! no need to delete it!

	if(nRet = g_pSpawner->PerformSpawnMultiple(slSpawnCmds))
	{
		theApp.IdleAndPump(g_pSpawner->m_hNotifyEvent);
		if (WaitForSingleObject(g_pSpawner->m_hCancelEvent, 0) == WAIT_OBJECT_0)
		{
			CString strError;
			strError.LoadString(IDS_TERMINATE_USER_REQ);
			gpOutputWindow->WriteStringToOutputWindow(strError, FALSE, TRUE);
		}

	}
	bldenviron.ResetVariables();
	g_fProfiling = FALSE;

	if(g_pSpawner != NULL)
	{
		delete g_pSpawner;
		g_pSpawner = NULL;
	}
	return(nRet);
}


BOOL CProfileDlg::LoadProfOptStore(CArchive & archive)
{

	TRY
	{

		archive >> ((WORD &)m_btnIndex);
		archive >> m_strComboCustom;
		archive >> m_strEditAdvanced;

	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
 	END_CATCH_ALL

	return TRUE;	// succeed
}

BOOL CProfileDlg::SaveProfOptStore(CArchive & archive)
{
	TRY
	{
		
		archive << ((WORD)m_btnIndex);
		archive << (m_strComboCustom);
		archive << (m_strEditAdvanced);

	}
	CATCH_ALL (e)
	{
		// failed
		return FALSE;
	}
	END_CATCH_ALL

	return TRUE;	// succeed
}


BOOL FProfiling()
{
	return g_fProfiling;
}


////////////////////////////////////////////////////////////////////
// Browse dialog class
// CBrowseDlg
////////////////////////////////////////////////////////////////////


CBrowseDlg::CBrowseDlg() 
	: C3dFileDialog(TRUE, NULL, NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_SHOWHELP, NULL, 
		NULL, 0, 0)
{
	 m_szFileBuff[0] = _T('\0');
}

CBrowseDlg::~CBrowseDlg()
{
}

CString CBrowseDlg::GetFileName()
{
	CString strFileName = m_szFileBuff;
	return strFileName;
}

int CBrowseDlg::DoModal()
{
	CString	strTitle;

	strTitle.LoadString(IDS_PROF_BROWSETITLE);

	m_ofn.lpstrFilter = szProfFilter;
	m_ofn.nMaxCustFilter = sizeof(szProfFilter);
	m_ofn.lpstrTitle = strTitle;

	m_ofn.lpstrFile = m_szFileBuff;
	m_ofn.nMaxFile = MAX_PATH-1;
	m_ofn.lpstrFileTitle = NULL;
	m_ofn.nMaxFileTitle = 0;	 
	m_ofn.nFileOffset = 0;
	m_ofn.nFileExtension = 0;
	m_ofn.lpstrDefExt = NULL;

	return C3dFileDialog::DoModal(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\prjoptn.cpp ===
//
// COptionTable
//

#include "stdafx.h"		// our standard AFX include
#pragma hdrstop
#include "mbctype.h"

IMPLEMENT_DYNAMIC(OptTreeNodeList, CPtrList);
IMPLEMENT_DYNAMIC(CProxySlob, CProjItem);
IMPLEMENT_DYNAMIC(COptionHandler, CBldSysCmp);
IMPLEMENT_DYNAMIC(COptHdlrUnknown, COptionHandler);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern CProjComponentMgr g_prjcompmgr;

CMapPtrToPtr OptTreeNode::m_ValidPcrMap;

//////////////////////////////////////////////////////////////////////////////
OptTreeNodeList::~OptTreeNodeList()
{
	while (!m_lstDeps.IsEmpty())
	{
		delete (OptTreeNodeList *) m_lstDeps.RemoveHead();
	}
}

void OptTreeNodeList::RemoveContent()
{
	while (!IsEmpty())
	{
		delete (OptTreeNode *) RemoveHead();
	}

	while (!m_lstDeps.IsEmpty())
	{
		delete (OptTreeNodeList *) m_lstDeps.RemoveHead();
	}
}

OptTreeNodeList * OptTreeNodeList::AddDependentList() 
{ 
	OptTreeNodeList * pDepList = new OptTreeNodeList; 
	m_lstDeps.AddTail((void *)pDepList); 
	return pDepList; 
}

OptTreeNodeList * OptTreeNodeList::GetDependentList(const CProjItem * pItem)
{
	OptTreeNodeList * pList;
	POSITION pos = m_lstDeps.GetHeadPosition();
	while (pos != NULL)
	{
		pList = (OptTreeNodeList *)m_lstDeps.GetNext(pos);
		if (pList->GetItem() == pItem)
			return pList;
	}
	return NULL;
}

OptTreeNode * OptTreeNodeList::GetFirstValidNode()
{
	OptTreeNode * pNode;
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		pNode = GetNext(pos);
		if (pNode->IsValid())
			return pNode;
	} 
	ASSERT(0);
	return NULL;
}

CProjType * OptTreeNodeList::GetProjType()
{
	CProjType * pProjType = NULL;
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		OptTreeNode * pNode = GetNext(pos);
		if (pNode->IsValid())
		{
			if (pProjType == NULL)
				pProjType = pNode->GetProjType();
			else if (pProjType != pNode->GetProjType())
				return NULL;
		}
	}
	return pProjType;
}

BOOL OptTreeNodeList::SetIntProp(UINT idProp, int val, OptBehaviour optbeh)
{
	BOOL retval = TRUE;
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		OptTreeNode * pNode = GetNext(pos);
		if (pNode->IsValid())
		{
			retval = pNode->SetIntProp(idProp, val, optbeh) && retval;
		}
	}
	return retval;
}

BOOL OptTreeNodeList::SetStrProp(UINT idProp, const CString & val, OptBehaviour optbeh)
{
	BOOL retval = TRUE;
	POSITION pos = GetHeadPosition();
	while (pos != NULL)
	{
		OptTreeNode * pNode = GetNext(pos);
		if (pNode->IsValid())
		{
			retval = pNode->SetStrProp(idProp, val, optbeh) && retval;
		}
	}
	return retval;
}

//////////////////////////////////////////////////////////////////////////////
OptTreeNode::OptTreeNode()
{
	// we don't have a container yet
	pContainerNode = (OptTreeNode *)NULL;
	m_fValidContent = FALSE;
	pcr = NULL;
	pItem = NULL;
}

OptTreeNode::~OptTreeNode()
{
	// disconnect from our children (if we have any)
	POSITION pos = m_Content.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = (OptTreeNode *)m_Content.GetNext(pos);
		pNode->pContainerNode = (OptTreeNode *)NULL;
		delete pNode;	// delete the child
	}
		
	// inform dependants of this node deletion
	pItem->InformDependants(SN_DESTROY_OPTNODE, (DWORD)this);
}

OptTreeNode::OptTreeNode(OptTreeNode * pParentNode, CProjItem * pNodeItem)
{
	// we don't have a container yet
	pContainerNode = (OptTreeNode *)NULL;
	m_fValidContent = FALSE;

	// our container item
	pItem = pNodeItem;

	// our container of this Node
	pContainerNode = pParentNode;

	// chain our config. by matching with parent
	pcr = pItem->ConfigRecordFromBaseConfig((ConfigurationRecord *)pParentNode->pcr->m_pBaseRecord,TRUE);
	ASSERT(pcr != NULL);

	// make sure the container has a reference to this node
	pParentNode->m_Content.AddTail((void *)this);
}

CProjType * OptTreeNode::GetProjType()
{
	CProjType * pProjType;
	pItem->SetManualBagSearchConfig(pcr);
	if (!g_prjcompmgr.GetProjTypefromProjItem(pItem, pProjType))
		pProjType = (CProjType *)NULL;	// may be external project
	pItem->ResetManualBagSearchConfig();
	return pProjType;
}

// get the tools applicable to this node
void OptTreeNode::GetViableBuildTools(CPtrList & listTools)
{
	// empty our list
	listTools.RemoveAll();

	//
	// is this a CProject?
	if (pItem->IsKindOf(RUNTIME_CLASS(CProject)))
	{
		// get our list of tools from the project type
		CProjType * pProjType = GetProjType();

		// append this project's list of tools
		listTools.AddTail((CPtrList *)pProjType->GetToolsList());
	}
	//
	// is this a CProjGroup?
	else if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
	{
		// no pages what so ever!
	}
	//
	// is this a CFileItem?
	else if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		// append our source tool for this item in this config.
		// (don't refresh the cache when getting the source tool)
		CBuildTool * pBuildTool = pcr->GetBuildTool();
		if (pBuildTool != (CBuildTool *)NULL)
			listTools.AddTail(pBuildTool);
	}
}

BOOL OptTreeNode::SetIntProp(UINT idProp, int val, OptBehaviour optbeh)
{
	pItem->SetManualBagSearchConfig(pcr);
	OptBehaviour optbehOld = pItem->SetOptBehaviour(optbeh);

	BOOL fRet = pItem->SetIntProp(idProp, val);

	(void )pItem->SetOptBehaviour(optbehOld);
	pItem->ResetManualBagSearchConfig();
	return fRet;
}

BOOL OptTreeNode::SetStrProp(UINT idProp, const CString& val, OptBehaviour optbeh)
{
	pItem->SetManualBagSearchConfig(pcr);

	//
	// Fix for SPEED:52.
	// GetProject()->ActiveConfig must match pcr->m_pBaseRecord so that functions called
	// as a result of pItem->SetStrProp (.e.g. CActionSlob::AssignActions ) will use the
	// correct project configuration.
	//
	pItem->GetProject()->SetManualBagSearchConfig((ConfigurationRecord*)pcr->m_pBaseRecord);

	OptBehaviour optbehOld = pItem->SetOptBehaviour(optbeh);

	BOOL fRet = pItem->SetStrProp(idProp, val);

	(void )pItem->SetOptBehaviour(optbehOld);

	pItem->GetProject()->ResetManualBagSearchConfig();

	pItem->ResetManualBagSearchConfig();
	return fRet;
}

GPT OptTreeNode::GetIntProp(UINT idProp, int &val, OptBehaviour optbeh)
{
	pItem->SetManualBagSearchConfig(pcr);
	OptBehaviour optbehOld = pItem->SetOptBehaviour(optbeh);

	GPT gpt = pItem->GetIntProp(idProp, val);

	(void )pItem->SetOptBehaviour(optbehOld);
	pItem->ResetManualBagSearchConfig();
	return gpt;
}

GPT OptTreeNode::GetStrProp(UINT idProp, CString &val, OptBehaviour optbeh)
{
	pItem->SetManualBagSearchConfig(pcr);
	OptBehaviour optbehOld = pItem->SetOptBehaviour(optbeh);

	GPT gpt = pItem->GetStrProp(idProp, val);

	(void )pItem->SetOptBehaviour(optbehOld);
	pItem->ResetManualBagSearchConfig();
	return gpt;
}

CPropBag * OptTreeNode::GetPropBag(int nBag)
{
	pItem->SetManualBagSearchConfig(pcr);
	CPropBag * pBag = pItem->GetPropBag(nBag);
	pItem->ResetManualBagSearchConfig();
	return pBag;
}

CProxySlob::CProxySlob()
{
 	m_pParentProxySlob = m_pChildProxySlob = (CProxySlob *)NULL;
	m_popthdlr = (COptionHandler *)NULL;

	// our owner project?
	// FUTURE: figure this using selection given multiple projects
	m_pOwnerProject = g_pActiveProject;
}

CProxySlob::~CProxySlob()
{
	if (m_pParentProxySlob)
		delete m_pParentProxySlob;
}

BOOL CProxySlob::IsSortOf(const CRuntimeClass* pClass)
{
	POSITION pos = m_ptrList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);
		if (!pNode->pItem->IsKindOf(pClass))
			return FALSE;
	}

	return TRUE;
}

CProjType * CProxySlob::GetProjType()
{
	CProjType * pProjType = (CProjType *)NULL;
	POSITION pos = m_ptrList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CProjType * pProjTypeT = ((OptTreeNode *)m_ptrList.GetNext(pos))->GetProjType();
		if (pProjType != (CProjType *)NULL && pProjType != pProjTypeT)
			return (CProjType *)NULL;
		else
			pProjType = pProjTypeT;
	}
 	return pProjType;
}

const CPlatform * CProxySlob::NextPlatform()
{
	const CPlatform * pPlatform = (const CPlatform *)NULL;

	// have we anymore?
	if (m_posList != (POSITION)NULL)
	{
		// get a node out of the selection
		OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(m_posList);

		// Otherwise if the project is an external makefile then
		// we have to rely on the P_ExtOpts_Platform property
		// to obtain the appropriate platform.
		CProject * pProject = pNode->pItem->GetProject();

		if (pProject->m_bProjIsExe)
		{
			CString strUIDescription;

			// make sure the project is in the same config. as the selected node	
			// n.b. item's base config. record *is* project's config. record.
			pProject->SetManualBagSearchConfig((ConfigurationRecord *)pNode->pcr->m_pBaseRecord);
			pProject->GetStrProp(P_ExtOpts_Platform, strUIDescription);
			pProject->ResetManualBagSearchConfig();

			g_prjcompmgr.LookupPlatformByUIDescription(strUIDescription, (CPlatform *&)pPlatform);
		}
		// If the project is an internal makefile then we can get the
		// platform by going through the project directly.
		else
		{
			// return the platform for this node's project type
			pPlatform = pNode->GetProjType()->GetPlatform();
		}
	}

	return pPlatform;
}


const ConfigurationRecord * CProxySlob::GetBaseConfig()
{	
	ConfigurationRecord * pcr = (ConfigurationRecord *)NULL;
	POSITION pos = m_ptrList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);
		if (pcr != (ConfigurationRecord *)NULL)
		{
			if (pNode->pcr->m_pBaseRecord != pcr)
				return (const ConfigurationRecord *)NULL;
		}
		else
			pcr = (ConfigurationRecord *)pNode->pcr->m_pBaseRecord;
	}

	return (const ConfigurationRecord *)pcr;
}

//////////////////////////////////////////////////////////////////////////////
void CProxySlob::Clear(BOOL fInform)
{
	POSITION pos = m_ptrList.GetHeadPosition();
	while (pos != (POSITION)NULL)
		Remove((OptTreeNode *)m_ptrList.GetNext(pos), fInform);
}

void CProxySlob::Add(OptTreeNode * pNode, BOOL fInform)
{
	// don't add of already exists
	if (m_ptrList.Find((void *)pNode) != (POSITION)NULL)
		return;
		
	m_ptrList.AddTail((void *)pNode);
	if (m_pChildProxySlob)	m_pChildProxySlob->FixContainment();	

	// add this node's container to our container CProxySlob
	if (pNode->pContainerNode)
	{
		if (!m_pParentProxySlob)
		{
			m_pParentProxySlob = new CProxySlob;
			m_pParentProxySlob->m_pChildProxySlob = this;
		}

		m_pParentProxySlob->Add(pNode->pContainerNode, FALSE);
		FixContainment();
	}

	// our active configuration
	m_pActiveConfig = IsSingle() ? GetSingle()->pcr : (ConfigurationRecord *)NULL;

	if (fInform)	InformDependants(SN_ALL);
}

void CProxySlob::Remove(OptTreeNode * pNode, BOOL fInform)
{
	// remove this node from our list
	POSITION pos = m_ptrList.Find((void *)pNode);
	if (pos == NULL)	return; // not in our selection, do nothing!
	
	m_ptrList.RemoveAt(pos);
	if (m_pChildProxySlob)	m_pChildProxySlob->FixContainment();	

	// remove this node's container from our container CProxySlob
	if (pNode->pContainerNode)
	{
		m_pParentProxySlob->Remove(pNode->pContainerNode, FALSE);
		FixContainment();	
	}

	// set our active configuration
	m_pActiveConfig = IsSingle() ? GetSingle()->pcr : (ConfigurationRecord *)NULL;

	if (fInform)	InformDependants(SN_ALL);
}

// property management across multiple OptTreeNodes
BOOL CProxySlob::SetIntProp(UINT idProp, int val)
{
	if (m_ptrList.GetCount() == 0)
		return TRUE;
	
	BOOL fOk = TRUE;
	POSITION pos = m_ptrList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);
		if (!pNode->SetIntProp(idProp, val, m_optbeh))
		{
			fOk = FALSE;
			break;	// we'll fail to set the others as well, don't bother
		}
	}

	if ( fOk )
		InformDependants( idProp );

	return fOk;
}

BOOL CProxySlob::SetStrProp(UINT idProp, const CString& val)
{
	if (m_ptrList.GetCount() == 0)
		return TRUE;

	BOOL fOk = TRUE;
	POSITION pos = m_ptrList.GetHeadPosition();

	// is this an option list?
	BOOL fDoMultiOptList = FALSE;
	TCHAR chJoin;		// join char
	BOOL fUseDefJoins;	// use default join string?

	// only need this for multiple-select option lists
	if (!IsSingle())
	{
		UINT idUnknownOption, idUnknownString;
		COptionHandler * popthdlr = m_popthdlr;
		while (popthdlr != (COptionHandler *)NULL)
		{
			popthdlr->GetSpecialOptProps(idUnknownOption, idUnknownString, m_optbeh);
			if (idProp == idUnknownString || idProp == idUnknownOption)
			{
				// final option list will *always* be space-sep,
				// we will *not* use the default seps to distinguish indi. elements
				chJoin = _T(' ');
				fDoMultiOptList = TRUE;
				fUseDefJoins = FALSE;
				break;
			}
			else if (popthdlr->IsListStrProp(idProp))
			{
				// final option list will *always* be comma-sep,
				// we will use the default seps to distinguish indi. elements
				chJoin = _T(',');
				fDoMultiOptList = fUseDefJoins =TRUE;
				break;
			}
			popthdlr = popthdlr->GetBaseOptionHandler();
		}
	}

	if (fDoMultiOptList)
	{
		// yes, append this elements to what we already have

		// create an array of option lists to hold our 'rememebered' node values
		COptionList * rgoptlstNode = new COptionList[m_ptrList.GetCount()];
		if (rgoptlstNode == (COptionList *)NULL)
			return FALSE;

		COptionList optlstCommon(chJoin, fUseDefJoins);
		CString valNode, valResult;
		BOOL fFirst = TRUE;
		int iNode;

		// get the common component, and the 'old' option list values

		iNode = 0;
		while (pos != (POSITION)NULL)
		{
			OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);

			GPT gpt;
			if ((gpt = pNode->GetStrProp(idProp, valNode, m_optbeh)) == valid)
			{
				rgoptlstNode[iNode].SetJoinUsage(chJoin, fUseDefJoins);
				rgoptlstNode[iNode].SetString(valNode);
				if (fFirst)
				{
					optlstCommon = rgoptlstNode[iNode];
					fFirst = FALSE;
				}
				else
					optlstCommon.Common(rgoptlstNode[iNode]);
			}

			iNode++;
		}

		// set the 'new' option list values

		COptionList optlstVal(val, chJoin, fUseDefJoins);
		iNode = 0;
		pos = m_ptrList.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);

			rgoptlstNode[iNode].Subtract(optlstCommon);	// subtract our 'old' common
			rgoptlstNode[iNode].Append(optlstVal);		// append our 'new' common
			rgoptlstNode[iNode].GetString(valResult);	// get the resultant string

			if (!pNode->SetStrProp(idProp, valResult, m_optbeh))
			{
				fOk = FALSE;
				break;	// we'll fail to set the others as well, don't bother
			} 

			iNode++;
		}

		// destroy our 'remembered' node values
		delete [] rgoptlstNode;
	}
	else
	{
		// no, set this value in all

		while (pos != (POSITION)NULL)
		{
			OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);
			if (!pNode->SetStrProp(idProp, val, m_optbeh))
			{
				fOk = FALSE;
				break;	// we'll fail to set the others as well, don't bother
			}
		}
	}

	if ( fOk )
		InformDependants( idProp );

	return fOk;
} 

GPT CProxySlob::GetStrProp(UINT idProp, CString& val)
{
	if (m_ptrList.GetCount() == 0)
		return invalid;

	CString valNode;
	BOOL fFirst = TRUE;
	POSITION pos = m_ptrList.GetHeadPosition();

	// is this an option list?
	BOOL fDoMultiOptList = FALSE;
	TCHAR chJoin;		// join char
	BOOL fUseDefJoins;	// use default join string?

	// only need this for multiple-select option lists
	if (!IsSingle())
	{
		UINT idUnknownOption, idUnknownString;
		COptionHandler * popthdlr = m_popthdlr;
		while (popthdlr != (COptionHandler *)NULL)
		{
			popthdlr->GetSpecialOptProps(idUnknownOption, idUnknownString, m_optbeh);
			if (idProp == idUnknownString || idProp == idUnknownOption)
			{
				// final option list will *always* be space-sep,
				// we will *not* use the default seps to distinguish indi. elements
				chJoin = _T(' ');
				fDoMultiOptList = TRUE;
				fUseDefJoins = FALSE;
				break;
			}
			else if (popthdlr->IsListStrProp(idProp))
			{
				// final option list will *always* be comma-sep,
				// we will use the default seps to distinguish indi. elements
				chJoin = _T(',');
				fDoMultiOptList = fUseDefJoins =TRUE;
				break;
			}
			popthdlr = popthdlr->GetBaseOptionHandler();
		}
	}

	if (fDoMultiOptList)
	{
		// yes, find the common option elements in the lists

		COptionList optlstCommon(chJoin, fUseDefJoins);
		while (pos != (POSITION)NULL)
		{
			OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);

			GPT gpt;
			if ((gpt = pNode->GetStrProp(idProp, valNode, m_optbeh)) != valid)
				return gpt;

			if (fFirst)
			{
				optlstCommon.SetString(valNode);
				fFirst = FALSE;
			}
			else
			{							
				COptionList optlstNode(valNode, chJoin, fUseDefJoins);
				optlstCommon.Common(optlstNode);
			}
		}
		optlstCommon.GetString(val);
	}
	else
	{
		// no, find the common value

		while (pos != (POSITION)NULL)
		{
			OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);

			GPT gpt;
			if ((gpt = pNode->GetStrProp(idProp, valNode, m_optbeh)) != valid)
				return gpt;

			if (fFirst)
			{
				val = valNode;
				fFirst = FALSE;
			}
			else if (val != valNode)
				return ambiguous;
		}
	}

	return valid;
}

GPT CProxySlob::GetIntProp(UINT idProp, int& val)
{
	if (m_ptrList.GetCount() == 0)
		return invalid;

	BOOL fFirst = TRUE;
	int valNode;
	POSITION pos = m_ptrList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);

		GPT gpt;
		if ((gpt = pNode->GetIntProp(idProp, valNode, m_optbeh)) != valid)
			return gpt;

		if (fFirst)
		{
			val = valNode;
			fFirst = FALSE;
		}
		else if (val != valNode)
			return ambiguous;
	}

	return valid;
}

void CProxySlob::OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint)
{
	if (idChange == SN_DESTROY_OPTNODE)
	{
		// remove from our selection
		Remove((OptTreeNode *)dwHint, TRUE);
		return;	// don't pass this on
	}
	
	InformDependants(idChange, dwHint);
}

CPropBag * CProxySlob::GetPropBag(int nBag)
{
	if (m_ptrList.GetCount() == 0)
		return (CPropBag *)NULL;

	OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetHead();
	return pNode->GetPropBag(nBag);
}

BOOL CProxySlob::Selected(OptTreeNode * pNode)
{
	return m_ptrList.Find(pNode) != (POSITION)NULL;
}

BOOL CProxySlob::Selected(CSlob * pSlob, ConfigurationRecord * pcr)
{
	POSITION pos = m_ptrList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptTreeNode * pNode = (OptTreeNode *)m_ptrList.GetNext(pos);
		if (pNode->pItem == pSlob && pNode->pcr == pcr)
			return TRUE;
	}

	return FALSE;	// no
}


//////////////////////////////////////////////////////////////////////////////
// implementation of the COptionList class
#pragma intrinsic(memcpy)

void COptionList::SetString(const TCHAR * pch)
{
	ASSERT(pch != (const TCHAR *)NULL);

	// empty the old one
	Empty();

	const TCHAR * rgchJoin = (const TCHAR *)m_strJoin;

	//
	// Use rgchJoinAndSpace to eliminate spaces surrounding separators.  This is a quick
	// fix to prevent the usability problem of leading and trailing spaces in tokens. (Speed:49).
	//
	// NOTE: This fix will prevent the obscure but legal use of path names with leading spaces.
	//

	// allocate enough to copy grchJoin and append space.
	TCHAR * rgchJoinAndSpace = new TCHAR[_tcslen(rgchJoin)+2];
	_tcscpy(rgchJoinAndSpace,rgchJoin);
	_tcscat(rgchJoinAndSpace,_T(" "));

	// skip leading join chars and spaces.
	while (*pch != _T('\0') && _tcschr(rgchJoinAndSpace, (unsigned int)(int)*pch) != (TCHAR *)NULL)	
		pch++;	// join chars assumed to be SBC

	// anything to do?
	if (*pch == _T('\0'))
	{
		delete [] rgchJoinAndSpace;
		return; // do nothing
	}

	TCHAR chVal, chJoin = m_strJoin[0];
	ASSERT(chJoin != _T('\0'));

	BOOL fQuoted = FALSE;
	const TCHAR * pchWord = pch;
	UINT cch, cchWord = 0;
	do
	{
		chVal = *pch;

		// are we quoted?
		if (chVal == _T('"'))
			fQuoted = !fQuoted;

		// look for a non-quoted join char, or terminator
		if (chVal == _T('\0') || (_tcschr(rgchJoin, chVal) != NULL && (chVal == _T('\t') || !fQuoted)))
		{
			// skip any extra join chars (and spaces) with this one, ie. ' , '
			if (chVal != _T('\0'))
			{
				chVal = *(++pch);	// join chars assumed to be SBC
				while (chVal != _T('\0') && _tcschr(rgchJoinAndSpace, chVal) != NULL)
				{												
					pch++; chVal = *pch;	// join chars assumed to be SBC
				}
			}

			// Remove trailing blanks from pchWord.
			while (0 != cchWord && 0 == _tccmp( _tcsdec(pchWord,pchWord+cchWord),_T(" ")) )
				--cchWord;

			// do we have any word characters?
			if (cchWord != 0)	Append(pchWord, cchWord);

			cchWord = 0;	// ready for start of next word
			pchWord = pch;
		}
		else
		{
			// skip non-join char
			cch = _tclen(pch);
			cchWord += cch; pch += cch;
		}
	}
	while (chVal != _T('\0'));

	delete [] rgchJoinAndSpace;
	return;
}

void COptionList::GetString(CString & str)
{
	TCHAR chJoin = m_strJoin[0];
	ASSERT(chJoin != _T('\0'));

	// allocate our buffer
	TCHAR * pch;
	if (!m_cchStr ||	// empty string?
		(pch = new TCHAR[m_cchStr]) == (TCHAR *)NULL
	   )
	{
		str = _TEXT(""); // in case of error
		return;
	}

	TCHAR * pchWord = pch;
	POSITION pos = m_lstStr.GetHeadPosition();
	ASSERT(pos != (POSITION)NULL);
	for (;;)	// we'll break (more efficient!)
	{
		OptEl * poptel = (OptEl *)m_lstStr.GetNext(pos);

		register int cch = poptel->cch;
		memcpy(pchWord, poptel->pch, cch);

		if (pos != (POSITION)NULL)
			pchWord[cch-1] = chJoin;	// join *not* terminate
		else
			break;	// terminate!

		pchWord += cch;
	}

	// return string and then delete our local buffer
	str = pch;
	delete [] pch;
}

void COptionList::Empty()
{
	// free-up our string memory
	POSITION pos = m_lstStr.GetHeadPosition(), posCurrent;
	while (pos != (POSITION)NULL)
	{
	 	posCurrent = pos;
		OptEl * poptel = (OptEl *)m_lstStr.GetNext(pos);
		VERIFY(Delete(poptel, posCurrent));
	}
}																			 

void COptionList::Add(OptEl * poptel)
{
	// put this into our list
	poptel->cref++;	// bump. ref. count.
	POSITION posOurWord = m_lstStr.AddTail((void *)poptel);
	m_cchStr += poptel->cch;

	// remember this for quick 'does string exist in list?' query
	// (in the case of dupes, we might nuke the old duplicate but that
	//  doesn't matter, it'll still solve its purpose)
	m_mapStrToPtr.SetAt(poptel->pch, (void *)posOurWord);
}

void COptionList::Append(const TCHAR * pch, int cch)
{
	OptEl * poptel = (OptEl *)new BYTE[sizeof(OptEl) + cch];
	if (poptel == (OptEl *)NULL)	return;

	// initialise with a ref. count of 1
	memcpy(poptel->pch, pch, cch);
	poptel->pch[cch] = _T('\0');
	poptel->cch = cch + 1;
	poptel->cref = 0;

	// can we add, ie. 
	// do we want to check for duplicates?
	if (!Exists(poptel->pch))
		Add(poptel);	// put this into our list
	else
		delete [] (BYTE *)poptel;	// duplicate
}

void COptionList::Append(COptionList & optlst)
{
	POSITION pos = optlst.m_lstStr.GetHeadPosition();
	while (pos != NULL)
	{
		OptEl * poptel = (OptEl *)optlst.m_lstStr.GetNext(pos);
		if (!Exists(poptel->pch))
			Add(poptel);
	}
}

void COptionList::Common(COptionList & optlst)
{
	POSITION pos = m_lstStr.GetHeadPosition(), posCurrent;
	while (pos != (POSITION)NULL)
	{
	 	posCurrent = pos;
		OptEl * poptel = (OptEl *)m_lstStr.GetNext(pos);
		if (!optlst.Exists(poptel->pch))
			VERIFY(Delete(poptel, posCurrent));
	}
}

BOOL COptionList::Delete(OptEl * poptel, POSITION posOurWord)
{
	// pre-loaded position to delete, or found this OptEl?
	if (!posOurWord && !m_mapStrToPtr.Lookup(poptel->pch, (void *&)posOurWord))
		return FALSE;	// no

	// retrieve our optel for this (might be the same)
	poptel = (OptEl *)m_lstStr.GetAt(posOurWord);

	m_lstStr.RemoveAt(posOurWord);
	(void) m_mapStrToPtr.RemoveKey(poptel->pch);

	m_cchStr -= poptel->cch;
	poptel->cref--;	// decr. the ref. count
	if (poptel->cref == 0)	// if zero, then free-up the element
		delete [] (BYTE *)poptel;

	return TRUE;
}

BOOL COptionList::Subtract(const TCHAR * pch)
{
	// does this exist?
	POSITION posOurWord;
	if (!m_mapStrToPtr.Lookup(pch, (void *&)posOurWord))	return FALSE;	// no

	// remove this from our list
	VERIFY(Delete((OptEl *)m_lstStr.GetAt(posOurWord), posOurWord));

	return TRUE; // ok
}

BOOL COptionList::Subtract(COptionList & optlst)
{
	BOOL fFound = FALSE;

	POSITION pos = optlst.m_lstStr.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptEl * poptel = (OptEl *)optlst.m_lstStr.GetNext(pos);
		// removed this from our list?
		if (Delete(poptel))
			fFound = TRUE;
	}

	return fFound;
}

void COptionList::Components(const TCHAR * pch, COptionList & optlstAdd, COptionList & optlstSub)
{
	COptionList optlst(_T(' '), FALSE);

	// set the option string to find components for
	optlst.m_strJoin = m_strJoin;
	optlst.SetString(pch);

	POSITION pos = m_lstStr.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		OptEl * poptel = (OptEl *)m_lstStr.GetNext(pos);
		// exist in us?
		if (!optlst.Delete(poptel))		// can do an addition comp.?
			optlstSub.Add(poptel);		// must be a subtract comp.
	}

	// return
	optlstAdd = optlst;
}

#pragma function(memcpy)

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptionHandler class
COptionHandler::COptionHandler(CBuildTool * pBuildTool, COptionHandler * popthdlrBase)
{
	m_pAssociatedBuildTool = pBuildTool;
	m_popthdlrBase = (COptionHandler *)popthdlrBase;	// no base option handler

	// make sure we got a valid build tool
	ASSERT_VALID(m_pAssociatedBuildTool);

	// Initialize our hierachy depth
	m_cDepth = 0;

	// Init. our slob stack
	m_sStk = 0;

	// assoc. ourselves with the build tool
	m_pAssociatedBuildTool->SetOptionHandler(this);

	// our associated CSlobs
	m_pSlob = (CSlob *)NULL;
}

COptionHandler::COptionHandler
(
	const TCHAR * szPkg, WORD id,
	const TCHAR * szPkgTool, WORD idTool,
	const TCHAR * szPkgBase, WORD idBase
)
{
	// set our id.
	SetId(GenerateComponentId(g_prjcompmgr.GenerateBldSysCompPackageId(szPkg), id));

	// Initialize our hierachy depth
	m_cDepth = 0;

	// Init. our slob stack
	m_sStk = 0;

	// our associated build tool (if we have one)
	m_pAssociatedBuildTool = (CBuildTool *)NULL;
	if (idTool != 0)
	{
		if (!g_prjcompmgr.LookupBldSysComp(GenerateComponentId(g_prjcompmgr.GenerateBldSysCompPackageId(szPkgTool), idTool),
										   (CBldSysCmp *&)m_pAssociatedBuildTool))
			ASSERT(FALSE);	// failed

		// make sure we got a valid build tool
		ASSERT_VALID(m_pAssociatedBuildTool);
		ASSERT(m_pAssociatedBuildTool->IsKindOf(RUNTIME_CLASS(CBuildTool)));

		// assoc. ourselves with the build tool
		m_pAssociatedBuildTool->SetOptionHandler(this);
	}

	// our base option handler (if we have one)
	m_popthdlrBase = (COptionHandler *)NULL;
	if (idBase != 0)
	{
		if (!g_prjcompmgr.LookupBldSysComp(GenerateComponentId(g_prjcompmgr.GenerateBldSysCompPackageId(szPkgBase), idBase),
										   (CBldSysCmp *&)m_popthdlrBase))
			ASSERT(FALSE);	// failed

		// make sure we got a valid base option handler
		ASSERT_VALID(m_popthdlrBase);
		ASSERT(m_popthdlrBase->IsKindOf(RUNTIME_CLASS(COptionHandler)));

		// calc. our depth
		COptionHandler * popthdlr = m_popthdlrBase;
		do
		{
			m_cDepth++;	// inc. depth (we have at least 1)
		}
		while (popthdlr = popthdlr->GetBaseOptionHandler());

		// If we have a tool then reset the option handler
		// as our depth has now changed. The depth must be
		// in ssync with the option handler in the tool.
		if (idTool != 0)
			m_pAssociatedBuildTool->SetOptionHandler(this);
	}


	// our associated CSlobs
	m_pSlob = (CSlob *)NULL;
}

COptionHandler::~COptionHandler()
{
	WORD key;
	CDefOptionProp * pdefopt;

	// destroy all of our default props for the map
	for (POSITION pos = m_mapDefOptions.GetStartPosition() ; pos != NULL;)
	{
		m_mapDefOptions.GetNextAssoc(pos, key, (void *&)pdefopt);
		delete pdefopt;
	}

	m_mapDefOptions.RemoveAll();

	ASSERT(m_pdirtyProps);
	delete m_pdirtyProps;
	delete [] m_pStrListPropIds;
}

BOOL COptionHandler::Initialise()
{
	// convert all table logical props to actual props
	COptStr	* poptstr = GetOptionStringTable();
	while (poptstr->idOption != (UINT)-1)
	{
		for (WORD cArgs = 0; cArgs < MAX_OPT_ARGS; cArgs++)
		{
			UINT * pidArg = poptstr->rgidArg + cArgs;
			if (*pidArg != (UINT)-1)
				*pidArg = MapLogical(*pidArg);
		}

		poptstr++;	// next
	}

	// create our default option map
	UINT nRange = GetOptPropRange();

	COptionLookup * poptlookup = GetOptionLookup();
	if ((poptlookup == (COptionLookup *)NULL) || GetOptionLookup()->FInit(GetOptionStringTable()))
	{
		// make the map hash size close to a prime no. matching the # of props.
		UINT nHash = (UINT)-1;
		if (nHash > 90)
			nHash = 89;
		else if (nHash > 60)
			nHash = 59;
		else if (nHash > 30)
			nHash = 29;
		if (nHash != (UINT)-1)
			m_mapDefOptions.InitHashTable(nHash);

		// fill the default option map
		CreateOptDefMap();
	}
	
	// create our dirty prop array
	m_pdirtyProps = new CByteArray; m_pdirtyProps->SetSize(nRange);
	m_pStrListPropIds = new UINT[nRange];	// max. required

	// create our cache of string list props
	m_cStrListPropIds = 0;
	UINT idPropMin, idPropMax; GetMinMaxOptProps(idPropMin, idPropMax);
	for (UINT idProp = idPropMin; idProp <= idPropMax; idProp++)
		if (IsListStrProp(idProp))
			m_pStrListPropIds[m_cStrListPropIds++] = idProp;

	return TRUE;	// ok
}

void COptionHandler::GetSpecialOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh)
{
	UINT nIDUnkOptB, nIDUnkStrB;
	GetSpecialLogicalOptProps(nIDUnkOpt, nIDUnkStr, optbeh);

	COptionHandler * popthdlr = GetBaseOptionHandler();

	if (nIDUnkOpt != (UINT)-1)
	{
		if (nIDUnkOpt == (UINT)NULL && popthdlr != (COptionHandler *)NULL)
			popthdlr->GetSpecialOptProps(nIDUnkOpt, nIDUnkStrB);
		else
			nIDUnkOpt = MapLogical(nIDUnkOpt);
	}
		
	if (nIDUnkStr != (UINT)-1)
	{
		if (nIDUnkStr == (UINT)NULL && popthdlr != (COptionHandler *)NULL)
			popthdlr->GetSpecialOptProps(nIDUnkOptB, nIDUnkStr);
		else
			nIDUnkStr = MapLogical(nIDUnkStr);
	}
}

int COptionHandler::GetTabDlgOrder()
{
	COptionHandler * popthdlr = GetBaseOptionHandler();
	if (popthdlr != (COptionHandler *)NULL)
		return popthdlr->GetTabDlgOrder();

	return 1000;	// default is at end of tabs
}

UINT COptionHandler::GetNameID()
{
	COptionHandler * popthdlr = GetBaseOptionHandler();
	if (popthdlr != (COptionHandler *)NULL)
		return popthdlr->GetNameID();

	return IDS_GENERAL;	// 'General' default
}

void COptionHandler::ResetPropsForConfig(ConfigurationRecord * pcr)
{
	// reset our base-handler props first
	COptionHandler * popthdlr = GetBaseOptionHandler();
	if (popthdlr != (COptionHandler *)NULL)
		popthdlr->ResetPropsForConfig(pcr);

	// reset our own props.
	UINT nPropMin, nPropMax;
	GetMinMaxOptProps(nPropMin, nPropMax);
	pcr->BagCopy(BaseBag, CloneBag, nPropMin, nPropMax, TRUE);
}

BOOL COptionHandler::CanResetPropsForConfig(ConfigurationRecord * pcr)
{
	// check our base-handler props first
	COptionHandler * popthdlr = GetBaseOptionHandler();
	if (popthdlr != (COptionHandler *)NULL)
		if (popthdlr->CanResetPropsForConfig(pcr))
			return TRUE;	// no need to check other handlers

	UINT nPropMin, nPropMax;
	GetMinMaxOptProps(nPropMin, nPropMax);
	return !pcr->BagSame(BaseBag, CloneBag, nPropMin, nPropMax, TRUE);
}
 
GPT COptionHandler::GetDefIntProp(UINT idProp, int & val)
{
	CDefOptionProp * pdefopt;
	if (!m_mapDefOptions.Lookup(idProp, (void *&)pdefopt)) return invalid;

	if (pdefopt->m_pprop->m_nType == string)
	{
		if (!ConvertFromStr(idProp, ((CStringProp *)pdefopt->m_pprop)->m_strVal, val))
			return invalid;
	}
	else
	{
		ASSERT(pdefopt->m_pprop->m_nType == booln || pdefopt->m_pprop->m_nType == integer);
		val = (pdefopt->m_pprop->m_nType == booln) ?
			   ((CBoolProp *)pdefopt->m_pprop)->m_bVal : ((CIntProp *)pdefopt->m_pprop)->m_nVal;
	}

	return valid;
}

GPT COptionHandler::GetDefStrProp(UINT idProp, CString & val)
{
	CDefOptionProp * pdefopt;
	if (!m_mapDefOptions.Lookup(idProp, (void *&)pdefopt)) return invalid;

	if (pdefopt->m_pprop->m_nType == integer)
	{
		if (!ConvertToStr(idProp, ((CIntProp *)pdefopt->m_pprop)->m_nVal, val))
			return invalid;
	}
	else
	{
		ASSERT(pdefopt->m_pprop->m_nType == string);
		val = ((CStringProp *)pdefopt->m_pprop)->m_strVal;
	}

	return valid;
}

BOOL COptionHandler::IsDefaultIntProp(UINT idProp, int & nVal)
{
	int nOurVal;
	return (GetDefIntProp(idProp, nOurVal) == valid) &&
		   (nOurVal == nVal);
}

BOOL COptionHandler::IsDefaultStringProp(UINT idProp, CString & strVal)
{
	CString strOurVal;
	if (GetDefStrProp(idProp, strOurVal) != valid)
		return FALSE;

   TCHAR * pch1 = (TCHAR *)(const TCHAR *)strOurVal;
   TCHAR * pch2 = (TCHAR *)(const TCHAR *)strVal;
   BOOL fEscaped = FALSE;
   TCHAR ch1, ch2;
   while ((ch1 = *pch1) != _T('\0') && (ch2 = *pch2) != _T('\0'))
   {
		// case insensitive compare (most likely for tool options)
   		if (_totupper(ch1) != _totupper(ch2))
   		{
			// treat a '\' and an '/' as equivalent if not escaped '\'
			// this is the case for common option args which are filenames
			if (fEscaped ||
				(ch1 != _T('\\') && ch1 != _T('/')) ||
				(ch2 != _T('\\') && ch2 != _T('/'))
			   )
	   			return FALSE;	// failed
   		}

		int cch = _tclen(pch1);
		pch1 += cch; pch2 += cch;

   		fEscaped = !fEscaped && (ch1 == _T('\\'));
   }

   return *pch1 == _T('\0') && *pch2 == _T('\0');
}

// conversion of int, oct,hex values into a text form
// FUTURE: I'd like to put this elsewhere, but where?
BOOL COptionHandler::ConvertToStr(UINT idProp, int nVal, CString & strVal)
{
	CDefOptionProp * pdefopt;
	if (!m_mapDefOptions.Lookup(idProp, (void *&)pdefopt)) return FALSE;

	SUBTYPE subtype = pdefopt->subtypeprop;
	int nBase;
	if (subtype == hexST)
	{
		nBase = 16; strVal = "0x";
	}
	else if (subtype == octST)
	{
		nBase = 8; strVal = "0";
	}
	else
	{
		ASSERT(subtype == intST);
		nBase = 10; strVal = "";
	}

	char	szVal[34];	// max. of 33 chars

	// we use unsigned longs, no negative ints allowed
	strVal += _ultoa((unsigned long)(unsigned int)nVal, szVal, nBase);

	return TRUE;
}

// what terminators do we have?
// o zero terminator ('\0') for regular number strings
// o '>' terminator for option table number strings
#define IsStrTerminator(ch) (ch == _T('\0') || ch == _T('>'))

BOOL COptionHandler::ConvertFromStr(UINT idProp, const TCHAR * pchVal, int & nVal)
{
	CDefOptionProp * pdefopt;
	if (!m_mapDefOptions.Lookup(idProp, (void *&)pdefopt)) return FALSE;

	SUBTYPE subtype = pdefopt->subtypeprop;
	TCHAR * pch = (TCHAR *)pchVal;

	// strip the prefix
	if (subtype == hexST)
	{
		// we'll allow a leading 'x' (a hack BTW)
		if (*pchVal == _T('x') || *pchVal == _T('X'))
			pch++;
		else if (*pchVal == _T('0') && (*(pchVal+1) == _T('x') || *(pchVal+1) == _T('X')))
			pch += 2;
		else
			subtype = intST;	// no leading hex prefix, we'll assume decimal
	}
	else if (subtype == octST)
	{
		// we'll allow a leading '0' (a hack BTW)
		if (*pchVal == _T('0'))
			pch++;
	}
	else
	{
		ASSERT(subtype == intST);
		if (*pchVal == _T('+'))
			pch++;	// '+' is a single byte DBC
	}

	UINT iOut = 0;

	// init. the value
	nVal = 0;

	if (subtype == hexST)
	{
		for (; !IsStrTerminator(pch[iOut]); iOut++)
		{
			// check for well-formed hex number
			if (iOut > 7 || !isxdigit((unsigned char)pch[iOut]) || nVal & 0xf0000000)
			{
				// not a hex-digit or 
				// too many hex-digits (only 32-bit, ie. 8 digit hex-numbers supported) or
				// next shift would cause overflow!
				InformationBox(IDS_BAD_HEX_NUMBER, pchVal);
				return FALSE;
			}

			nVal <<= 4;
			nVal += (toupper((unsigned char)pch[iOut]) -
					 (isdigit(toupper((unsigned char)pch[iOut])) ? '0' : 'A' - 10));
		}
	}
	else if (subtype == octST)
	{
		for (; !IsStrTerminator(pch[iOut]); iOut++)
		{
			// check for well-formed hex number
			if (iOut > 10 || !isdigit((unsigned char)pch[iOut]) ||
				pch[iOut] == _T('8') || pch[iOut] == _T('9') || nVal & 0xe0000000)
			{
				// we found '8' or '9'
				// too may oct-digits (only 32-bit, ie. 11 digit oct-numbers supported)
				// next shift would cause overflow!
				InformationBox(IDS_BAD_OCT_NUMBER, pchVal);
				return FALSE;
			}

			nVal <<= 3;
			nVal += (toupper((unsigned char)pch[iOut]) - '0');
		}
	}
	else
	{
		ASSERT(subtype == intST);

		for (; !IsStrTerminator(pch[iOut]); iOut++)
		{
			// check for well-formed dec. number
			if (iOut > 9 || !isdigit((unsigned char)pch[iOut]))
			{
				// only want positive numbers
				// too may decimal digits (only 32-bit, ie. 10 digit dec-numbers supported)
				InformationBox(IDS_BAD_DEC_NUMBER, pchVal);
				return FALSE;
			}

  			int nDigit = (toupper((unsigned char)pch[iOut]) - '0');
			
			// possible overflow?
			if ((nVal >= 429496729 && nDigit > 5) || (nVal > 429496730))
			{
				// number too big (only 32-bit, max. is 4,294,967,295)
				InformationBox(IDS_BAD_DEC_NUMBER, pchVal);
				return FALSE;
			}

			nVal *= 10;
			nVal += nDigit;
		}
	}

	return TRUE;
}

void COptionHandler::MungeListStrProp
(
	UINT nIDProp,
	const CString & strVal,
	BOOL fAppend,
	char chJoin
)
{
	// get our comma-sep list
	CString str;
	m_pSlob->GetStrProp(nIDProp, str);
	COptionList optlst(str, chJoin);

	// perform munge
	optlst.Subtract((const TCHAR *)strVal);
	if (fAppend)
		optlst.Append((const TCHAR *)strVal, strVal.GetLength());

	// set our 'munged' list
	optlst.GetString(str);
	m_pSlob->SetStrProp(nIDProp, str);
}

void COptionHandler::SetListStrProp
(
	CSlob * pSlob,
	UINT nIDExtraProp,
	CString & strVal,
	BOOL fInherit,
	BOOL fAnti,
	TCHAR chJoin
)
{
	// do nothing
	if (pSlob == (CSlob *)NULL)	return;

	CPropBag * pBag = pSlob->GetPropBag();

	// it is easy to set an anti prop
	if (fAnti)
	{
		pBag->SetStrProp(pSlob, ListStr_SubPart(nIDExtraProp), strVal);
	}
	else
	{
		// get the currently existing option list for our parent
		CString strParent; strParent = "";
		CSlob * pSlobParent = ((CProjItem *)pSlob)->GetContainerInSameConfig();
		if (pSlobParent != (CSlob *)NULL)
		{
			(void) GetListStrProp(pSlobParent, nIDExtraProp, strParent, fInherit, fAnti, chJoin);
			((CProjItem *)pSlobParent)->ResetContainerConfig();
		}

		// now figure out what we have subtracted or added
		COptionList optlstParent(strParent, chJoin);
		COptionList optlstAdd(chJoin), optlstSub(chJoin);

		// break into the component parts
		optlstParent.Components(strVal, optlstAdd, optlstSub);

		// we now have our add and subtract, convert back into strings
		CString strAddPart, strSubPart;
		optlstAdd.GetString(strAddPart);
		optlstSub.GetString(strSubPart);

		// set the properties
		pBag->SetStrProp(pSlob, ListStr_AddPart(nIDExtraProp), strAddPart);
		pBag->SetStrProp(pSlob, ListStr_SubPart(nIDExtraProp), strSubPart);
	}

	// inform people of a change to pseudo prop. nIDExtraProp
	pSlob->InformDependants(nIDExtraProp);
}

GPT COptionHandler::GetListStrProp
(
	CSlob * pOrigSlob,
	UINT nIDExtraProp,
	CString & strVal,
	BOOL fInherit,
	BOOL fAnti,
	char chJoin
)
{
	// do nothing?
	if (pOrigSlob == (CSlob *)NULL)	return invalid;

	// clear the buffer ready for concatenation
	strVal = "";
	
	// won't allow inheritance plus anti for string lists
	if (fAnti)	fInherit = FALSE;

	CSlob * pSlob = pOrigSlob;
	CObList obList;
	if (fInherit)
	{
		// we are a CProjItem and we are inheriting!
		// get the prop for each of our ancestor's in elder first order
		while (pSlob != (CSlob *)NULL)
		{
			obList.AddHead(pSlob);
			pSlob = ((CProjItem *)pSlob)->GetContainerInSameConfig();	// get our container
		}
	}
	else
	{
		// we can do a no-inheritance thing!
		obList.AddHead(pSlob);
	}

	// if we are a CProjItem and we are inheriting then do our own thing
	// ie. go through each CSlob in the container hierarchy and append each part to 
	// our options

	COptionList optlstVal(chJoin);
	POSITION pos = obList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		pSlob = (CSlob *)obList.GetNext(pos);

		// CProjGroups don't support tool options!
		if (!pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			CPropBag * pBag = pSlob->GetPropBag();
			CStringProp * pStrProp;

			// disable inheriting so we can do it!
			BOOL fPropInheritOld = ((CProjItem *)pSlob)->EnablePropInherit(FALSE);

			// using string lists
			COptionList optlstSub(chJoin);
			if ((pStrProp = (CStringProp *)pBag->FindProp(ListStr_SubPart(nIDExtraProp))) != (CStringProp *)NULL)
				optlstSub.SetString(pStrProp->m_strVal);

			// if *not* anti,
			// - append our 'add part'
			// - subtract our 'subtract part'
			// else
			// - add our 'subtract part'
			if (fAnti) /* anti-option */
			{
				CString strParent;
				CSlob * pSlobParent = ((CProjItem *)pSlob)->GetContainerInSameConfig();
				if (pSlobParent != (CSlob *)NULL)
				{
					(void) GetListStrProp(pSlobParent, nIDExtraProp, strParent, TRUE, FALSE);
					((CProjItem *)pSlobParent)->ResetContainerConfig();
				}

				// remove from the subtract option anything that
				// doesn't exist in our parent's list
				COptionList optlstParent(strParent, chJoin);
				optlstSub.Common(optlstParent);
				optlstVal.Append(optlstSub);
			}
			else /* not anti-option */
			{
				COptionList optlstAdd(chJoin);
				if ((pStrProp = (CStringProp *)pBag->FindProp(ListStr_AddPart(nIDExtraProp))) != (CStringProp *)NULL)
					optlstAdd.SetString(pStrProp->m_strVal);

				if (fInherit)	optlstVal.Subtract(optlstSub);	// no subtract, if no inherit
				optlstVal.Append(optlstAdd);
			}

			// re-set inheriting to old value
			((CProjItem *)pSlob)->EnablePropInherit(fPropInheritOld);
		}

		// only need to do this if we we'rere a got container
		// (ie. we're not the first node in this list)
		if (pSlob != pOrigSlob)
			((CProjItem *)pSlob)->ResetContainerConfig();
	}
	
	if (!fAnti && IsFakeProp(nIDExtraProp))
	{
		CString strAdd;

		SetSlob (pOrigSlob);
		GetDefStrProp (nIDExtraProp, strAdd);
		COptionList optlstAdd (strAdd);
		ResetSlob();

		optlstVal.Append (optlstAdd);
	} 
	// we need to convert our string list into a usable string
	// this will ensure all our join chars are chJoin
	optlstVal.GetString(strVal);
	
	return valid;
}

void COptionHandler::ClearStringLists(CPropBag * ppropbag)
{
	if (ppropbag == (CPropBag *)NULL)
		ppropbag = m_pSlob->GetPropBag();

	for (UINT i = 0; i < m_cStrListPropIds; i++)
	{
		// delete string list prop from the current property bag
		UINT idProp = m_pStrListPropIds[i];

		// always have both add/subtract if any at all - just check for add part
		if (ppropbag->FindProp(ListStr_AddPart(idProp)) != (CProp *)NULL)
		{
			// remove and inform of this prop change (update option view?)
			ppropbag->RemoveProp(ListStr_AddPart(idProp));
			ppropbag->RemoveProp(ListStr_SubPart(idProp));

			m_pSlob->InformDependants(idProp);
			OnOptionStrPropChange(idProp, _TEXT(""));
		}
	}
}

void COptionHandler::ClearCleanArgs(CPropBag * ppropbag, OptBehaviour optbeh)
{
	UINT nPropMin, nPropMax;
	GetMinMaxOptProps(nPropMin, nPropMax);

	if (ppropbag == (CPropBag *)NULL)
		ppropbag = m_pSlob->GetPropBag();

	UINT nIDUnknownOption, nIDUnknownString;
	GetSpecialOptProps(nIDUnknownOption, nIDUnknownString, optbeh);

	CProp * pprop;
	for (UINT nProp = nPropMin; nProp <= nPropMax; nProp++)
	{
		// don't do this for the unknown, or string options, or not dirtied args
		if (nProp == nIDUnknownOption || nProp == nIDUnknownString ||
			m_pdirtyProps->GetAt(nProp - nPropMin)
		   )
			continue;

		// was this a dirtied arg, if not then remove it
		if ((pprop = ppropbag->FindProp(nProp)) != (CProp *)NULL)
		{
			PROP_TYPE type = pprop->m_nType; 	// remember before delete

			// remove and inform of this prop deletion (it exists!)
			ppropbag->RemovePropAndInform(nProp, m_pSlob);

			if (type == integer || type == booln)
				OnOptionIntPropChange(nProp, 0);
			else
				OnOptionStrPropChange(nProp, _TEXT(""));
		}
	}
}

void COptionHandler::ClearSpecialOptProps(CPropBag * ppropbag, OptBehaviour optbeh)
{
	if (ppropbag == (CPropBag *)NULL)
		ppropbag = m_pSlob->GetPropBag();

	UINT nIDUnknownOption, nIDUnknownString;
	GetSpecialOptProps(nIDUnknownOption, nIDUnknownString, optbeh);

	// remove and inform deps. if the unknown props. exist in our bag
	ppropbag->RemovePropAndInform(nIDUnknownOption, m_pSlob);
	ppropbag->RemovePropAndInform(nIDUnknownString, m_pSlob);
}

BOOL COptionHandler::HasAnyOfOurProperties (CProjItem *pProjItem, BOOL bCheckFakeProps /* = FALSE */)
{
	ASSERT (!pProjItem->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	ASSERT (pProjItem->IsKindOf(RUNTIME_CLASS(CProjItem)));

	// if this is a CTargetItem then convert into a CProject...
	if (pProjItem->IsKindOf(RUNTIME_CLASS(CTargetItem)))
		pProjItem = pProjItem->GetProject();

	CPropBag * pPropBag = pProjItem->GetPropBag();

	UINT nPropMin, nPropMax;
	GetMinMaxOptProps(nPropMin, nPropMax);

	int idOldBag = pProjItem->UsePropertyBag(BaseBag);
	CPropBag * pBasePropBag = pProjItem->GetPropBag();
	(void) pProjItem->UsePropertyBag(idOldBag);

	BOOL retVal = FALSE;

	// additional data only used if bCheckFakeProps is TRUE (init below)
	CProject * pProject;
	OptBehaviour optbehOld, optbehProjOld;
	CPropBag  * pProjBag;
	CString strProp, strProjProp;

	// only implemented for projects
	bCheckFakeProps = bCheckFakeProps && !pProjItem->IsKindOf(RUNTIME_CLASS(CProject));

	if (bCheckFakeProps)
	{	
		// additional optional initialization needed only for bCheckFakeProps
		pProject = pProjItem->GetProject();
		ASSERT(pProject);

		// is this project item in a forced config.? if so then force the project in the same...
		if (pProjItem->m_pForcedConfig)
			pProject->ForceConfigActive((ConfigurationRecord *)pProjItem->m_pForcedConfig->m_pBaseRecord);

		pProjBag = ((ConfigurationRecord *)pProject->GetActiveConfig())->GetPropBag(CurrBag);
		ASSERT(pProjBag == ((ConfigurationRecord *)pProjItem->GetActiveConfig()->m_pBaseRecord)->GetPropBag(CurrBag));

		// set our own option behaviour, and our project's
		optbehOld = pProjItem->SetOptBehaviour(OBShowMacro | OBInherit | OBShowDefault);
		optbehProjOld = pProject->SetOptBehaviour(OBShowMacro | OBInherit | OBShowDefault);
	}

	// for all of our properties that this table uses, check to
	// see if we have any of them in our bag
	for (UINT nProp = nPropMin; nProp <= nPropMax; nProp++)
	{
		// is this in the current prop bag, or in the base prop bag?
		if ((pPropBag->FindProp(nProp) != (CProp *)NULL) ||
			(pBasePropBag->FindProp(nProp) != (CProp *)NULL))
		{
			retVal = TRUE;
			break;
		}

		// optionally also check fake props (not for ADD/SUB lines)
		if (bCheckFakeProps && IsFakeProp(nProp) &&
			((pProjBag->FindProp(nProp)==NULL) || IsListStrProp(nProp))
		   )
		{
			if (!SetsFakePropValue(nProp))
			{
				// the slob is hinting to us that its value for this property is
				// the same as the container's.
				ASSERT(!retVal);
				continue;
			}
			switch (GetDefOptionType(nProp)) {
				case string :
					if ((GetDefStrProp(nProp, strProp)==valid) && (!strProp.IsEmpty()))
					{
						ASSERT(m_pSlob==pProjItem);
						if (pProjItem->m_pForcedConfig)	// may have been reset by GetDefStrProp call above!
							pProject->ForceConfigActive((ConfigurationRecord *)pProjItem->m_pForcedConfig->m_pBaseRecord);

						m_pSlob = (CSlob *) pProject;
						if ((GetDefStrProp(nProp, strProjProp)!=valid) || (strProjProp.IsEmpty()) || (strProjProp!=strProp))
							retVal = TRUE;
						m_pSlob = (CSlob *) pProjItem;
					}
					break;
				case integer :
				case booln :
					// ignore default int props for now
					break;
				default :
					ASSERT(0);	// only types implemented
			};
			if (retVal)
				break;
		}
	}
	if (bCheckFakeProps)
	{
		pProjItem->SetOptBehaviour(optbehOld);
		pProject->SetOptBehaviour(optbehProjOld);
		pProject->ForceConfigActive();
	}

	if (retVal)
		return TRUE;

	// FUTURE: only need to check OutDirs once, not in each recursion!

	// Also look for the output directories props.  These are really
	// props that can affect all tools.  No need to check Base props here.
	if (pPropBag->FindProp(P_OutDirs_Intermediate) && !m_pAssociatedBuildTool->m_fTargetTool)
		return TRUE;

	if (pPropBag->FindProp(P_OutDirs_Target) && m_pAssociatedBuildTool->m_fTargetTool)
		return TRUE;

	// if we can't find anything, check if it has a BaseOptionHandler and 
	// it does, check if the base has the properties
	COptionHandler * popthdlrBase = GetBaseOptionHandler();
	if (popthdlrBase)
		return popthdlrBase->HasAnyOfOurProperties(pProjItem, bCheckFakeProps);

	return FALSE;
}

BOOL CompareProps(const CProp *, const CProp *); // Rvw: defined in projitem.cpp

BOOL COptionHandler::HasPerConfigProperties(CProjItem *pProjItem, BOOL bCheckBase /* = TRUE */ )
{
	ASSERT (!pProjItem->IsKindOf(RUNTIME_CLASS(CProxySlob)));
	ASSERT (pProjItem->IsKindOf(RUNTIME_CLASS(CProjItem)));
	int numBags = pProjItem->GetPropBagCount();
	if (numBags < 2)
		return 0;	// nothing to compare

	int retFromBase = 0, retVal = 0; // defaults
	UINT nPropMin, nPropMax;
	GetMinMaxOptProps(nPropMin, nPropMax);

	if (nPropMin != (UINT)-1 && nPropMax != (UINT)-1)
	{
		const CPtrArray & ppcr = *pProjItem->GetConfigArray();
		ConfigurationRecord * pcr;
		CProp * pProp, * pCmpProp, * pCmpBaseProp;
		int i;

		// for all of our properties that this table uses, check to
		// see if we have any of them in our bag
		for (UINT nProp = nPropMin; nProp <= nPropMax; nProp++)
		{
			for (i = 0; i < numBags; i++)
			{
				pcr = (ConfigurationRecord *)ppcr[i];

				pProp = pcr->GetPropBag(CurrBag)->FindProp(nProp);

				if (i==0)
					pCmpProp = pProp;
				else if (pProp)
				{
					if ((!pCmpProp) || !CompareProps(pProp, pCmpProp))
						return 1;
				}
				else if (pCmpProp)
					return 1;

				if (bCheckBase && (!retVal))
				{
					// note: we can ignore fake props for base props
					pProp = pcr->GetPropBag(BaseBag)->FindProp(nProp);
					if (i==0)
						pCmpBaseProp = pProp;
					else if ((pProp==NULL) || (pCmpBaseProp==NULL))
					{
						if (pProp!=pCmpBaseProp)
							retVal = 2;
					}
					else if (!CompareProps(pProp, pCmpBaseProp))
						retVal = 2;
				}
			}
		}
	}

	// if we can't find anything, check if it has a BaseOptionHandler and 
	// it does, check if the base has the properties
	COptionHandler * popthdlrBase = GetBaseOptionHandler();
	if (popthdlrBase)
		retFromBase = popthdlrBase->HasPerConfigProperties(pProjItem, bCheckBase);

	return (retFromBase) ? retFromBase : retVal;
}

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptHdlrUnknown class
// mechanism to allow for unknown option handlers

// we use this to retrieve a unique option property value each
// time an 'Uknown' option handler is CTORed
UINT g_nIDOptHdlrUnknown = 0;

// small option string table used to parse and generate uknown option lists
static COptStr g_poptstrOptHdlrUknown[] = {
	IDOPT_UNKNOWN_STRING,	"",		NO_OPTARGS, single,
	(UINT)-1,				NULL,	NO_OPTARGS, single
};

#define P_UnkHdkr_UnkStr_AddL	0
#define P_UnkHdlr_UnkStr_SubL	1

COptHdlrUnknown::COptHdlrUnknown(CBuildTool * pBuildTool) : COptionHandler(pBuildTool)
{
	// our base
	SetOptPropBase(PROJ_OPT_UNKNOWN + g_nIDOptHdlrUnknown);

	// we'll be using 2 off from this base
	// logical prop 0 is unknown string (add component)	== P_UnkHdkr_UnkStr_AddL
	// logical prop 1 is unknown string (subtract component) == P_UnkHdlr_UnkStr_SubL
	g_nIDOptHdlrUnknown += 2;

	ASSERT(g_nIDOptHdlrUnknown <= 100); // 100 should be plenty (allow for 50 unknown tools)

	Initialise();
}	

void COptHdlrUnknown::GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh)
{
	ASSERT_VALID(m_pSlob);

	nIDUnkOpt = (UINT) -1;
	nIDUnkStr = (optbeh & OBAnti) ? P_UnkHdlr_UnkStr_SubL : P_UnkHdkr_UnkStr_AddL;
}

// retrieive our min. and max. option prop IDs
void COptHdlrUnknown::GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp)
{
	nIDMinProp = P_UnkHdkr_UnkStr_AddL; nIDMaxProp = P_UnkHdlr_UnkStr_SubL;
}

COptStr * COptHdlrUnknown::GetOptionStringTable()
{
	return (COptStr *)g_poptstrOptHdlrUknown;
}

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptHdlrMapper class
COptHdlrMapper::COptHdlrMapper()
{
}

COptHdlrMapper::~COptHdlrMapper()
{
}

// get the right mapper option handler (used by COptHdlrMapper::MapLogical())
void COptHdlrMapper::SetMapperOptionHandler(UINT cDepth)
{
	UINT cStep = m_popthdlr->GetDepth() - cDepth;  
	m_popthdlrMapper = m_popthdlr;
	while (cStep--)
		m_popthdlrMapper = m_popthdlrMapper->GetBaseOptionHandler();

	m_cDepth = cDepth;
}

//////////////////////////////////////////////////////////////////////////////
// implementation of the COptionLookup class
// optimized lookup for the options
COptionLookup::~COptionLookup()
{
	WORD		keyDummy;
	CLookupEntry *	pentry;
	POSITION pos = m_mapChToPtr.GetStartPosition();

	while (pos != (POSITION)NULL)
	{
		 m_mapChToPtr.GetNextAssoc(pos, keyDummy, (void *&)pentry);
		 delete pentry;
	}
}

BOOL COptionLookup::FInit(COptStr * poptstr)
{
	COptStr	* poptstrOur = poptstr;

	//
	// create our lookup struct. for 'based on ID'
	//

	// what is the lowest ID we have in this table?
	m_idLowest = UINT_MAX;	// this is the highest
	while (poptstrOur->idOption != (UINT)-1)
	{
		// no need to do these!
		if (poptstrOur->idOption != IDOPT_UNKNOWN_OPTION &&
	    	poptstrOur->idOption != IDOPT_UNKNOWN_STRING)				
		{
			if (poptstrOur->idOption < m_idLowest)	m_idLowest = poptstrOur->idOption;
		}
		poptstrOur++;
	}

	// now using this lowest ID as the base create our
	// pointer array
	poptstrOur = poptstr;
	while (poptstrOur->idOption != (UINT)-1)
	{
		// no need to do these
		if (poptstrOur->idOption != IDOPT_UNKNOWN_OPTION &&
	    	poptstrOur->idOption != IDOPT_UNKNOWN_STRING)				
		{
			m_ptrIDArray.SetAtGrow(poptstrOur->idOption - m_idLowest, (void *)poptstrOur);
		}
		poptstrOur++;
	}

	// free up any extra
	m_ptrIDArray.FreeExtra();

	//
	// create our lookup struct. for 'based on char'
	//

	// init. our lookup char.
	m_chLookup = _T('\0');

	// now use an insertion sort to alphabetically sort our options (on first letter only)

	int iChArray = 0;
	unsigned char ch;

	poptstrOur = poptstr;

	while (poptstrOur->idOption != (UINT)-1)
	{
		// don't do this for our special ones!
		if (poptstrOur->idOption == IDOPT_UNKNOWN_OPTION ||
		    poptstrOur->idOption == IDOPT_UNKNOWN_STRING)
		{
			poptstrOur++;
			continue;
		}

		COptStr * poptstr;

		ch = (unsigned char)*(poptstrOur->szOption);

		iChArray = 0;
		while (iChArray <= m_ptrChArray.GetUpperBound())
		{
			poptstr = (COptStr *)m_ptrChArray[iChArray];

			// UNICODE ALERT:             
 			if ((unsigned char)*(poptstr->szOption) > ch)
				break; // break-out here

			iChArray++;
		}

		// insert at this position
		m_ptrChArray.InsertAt(iChArray, (void *)poptstrOur);
		poptstrOur++;
	}

	// free up any extra
	m_ptrChArray.FreeExtra();

	// now go through our list once more and for each first char.
	// put it's index into our map

	CLookupEntry * pentry = (CLookupEntry *)NULL;
	iChArray = 0; ch = _T('\0');	// last char.

	m_mapChToPtr.InitHashTable(53);	// prime no. >= 26 * 2 (alpha letters upper+lower)
	while (iChArray <= m_ptrChArray.GetUpperBound())
	{
		// don't do this for our special ones!
		if (poptstrOur->idOption == IDOPT_UNKNOWN_OPTION ||
		    poptstrOur->idOption == IDOPT_UNKNOWN_STRING)
		{
			iChArray++;
			continue;
		}

		COptStr * poptstr;

		poptstr = (COptStr *)m_ptrChArray[iChArray];

		// UNICODE ALERT:             
		// N.B. guaranteed to hit on first iteration
		if ((unsigned char)*(poptstr->szOption) != ch)
		{
			// fill in 'first char'
			pentry = new CLookupEntry;
			pentry->poptstr = poptstr;
			pentry->ioptstr = (UINT)-1;	// by default next is not available

			ch = (unsigned char)*(poptstr->szOption);
			m_mapChToPtr.SetAt((WORD)ch, (void *)pentry);
		}
		else if (pentry != (CLookupEntry *)NULL)
		{
			// fill in 'next char'
			pentry->ioptstr = iChArray;
			pentry = (CLookupEntry *)NULL;
		}

 		iChArray++;
	}

	return TRUE;
}

inline COptStr * COptionLookup::Lookup(UINT nID)
{
	// no need to do these!
	if (nID == IDOPT_UNKNOWN_OPTION ||
    	nID == IDOPT_UNKNOWN_STRING)
	{
		ASSERT(FALSE);
		return (COptStr *)NULL;
	}
	
	// must be within our bounds
	if ((nID >= m_idLowest) && (m_ptrIDArray.GetUpperBound() >= (int)(nID - m_idLowest)))
		return (COptStr *)m_ptrIDArray[nID - m_idLowest];

	return (COptStr *)NULL;	 // not found
}

inline COptStr * COptionLookup::LookupFirst(unsigned char ch, BOOL fCaseSensitive)
{
	CLookupEntry * pentry;

	if (m_mapChToPtr.Lookup((WORD)ch, (void *&)pentry) ||
		(!fCaseSensitive &&
		 m_mapChToPtr.Lookup((WORD)(isupper(ch) ? tolower(ch) : toupper(ch)), (void *&)pentry)))
	{
		// remember our char. plus first position
		m_chLookup = ch; m_ioptstr = pentry->ioptstr;
		return pentry->poptstr;
	}

	return (COptStr *)NULL;
}

inline COptStr * COptionLookup::LookupNext(int cchLead)
{
	// no lookup entry, or no next one to lookup
	if (m_ioptstr == (UINT)-1)	return (COptStr *)NULL;

	COptStr * poptstr = (COptStr *)m_ptrChArray[m_ioptstr];

	// is this next one valid?
	TCHAR * pch = (TCHAR *)poptstr->szOption;
	TCHAR ch = *pch;
	if (ch == m_chLookup ||
		((isupper(ch) ? tolower(ch) : toupper(ch)) == m_chLookup))
	{
		if ((int)++m_ioptstr > m_ptrChArray.GetUpperBound())
			m_ioptstr = (UINT)-1;
	}
	else
		m_ioptstr = (UINT)-1;	// no longer available

	// check the lead char. minimum
	if (poptstr)
	{
		int cchThisLead = 0;
		while (*pch != _T('\0') && *pch != _T('%'))
		{
			cchThisLead++;
			pch++;	// N.B. no Kanjii in tool option specifications
		}

		if (cchLead > cchThisLead)
			poptstr = (COptStr *)NULL;
	}
                          
	return poptstr;
}

// implementation of the COptionTable class

COptionTable::COptionTable()
{
	// init. our arg property list index
	for (UINT i = 0 ; i < MAX_OPT_ARGS ; i++)
		m_rgProps[i].idArg = (UINT)-1;

	// our list string cache
	m_pBagCache = (CPropBag *)NULL;

	// our default option prefixes
	strPrefixes = "/-";

	// our arg. value allocated to be 64
	pchArgValue = new char [cchArgValue = 64];

	// set up our default option behaviour
	m_optbeh = OBNone;
}

COptionTable::~COptionTable()
{
	// delete our arg property list
	ClearPropValList();

	// delete our arg. value if we had one
	if (pchArgValue != (TCHAR *)NULL)
		delete [] pchArgValue;
}


// set the option handler given a package name and component pair
COptionHandler * COptionTable::SetOptionHandler(const TCHAR * szPkg, WORD idOptHdlr)
{
	// generate this option handler's component id
	DWORD bsc_idOptHdlr = GenerateComponentId(g_prjcompmgr.GenerateBldSysCompPackageId(szPkg), idOptHdlr);
	
	// look it up
	COptionHandler * popthdlr;
	if (!g_prjcompmgr.LookupBldSysComp(bsc_idOptHdlr, (CBldSysCmp * &)popthdlr))
		popthdlr = (COptionHandler *)NULL;

	ASSERT(popthdlr->IsKindOf(RUNTIME_CLASS(COptionHandler)));

	// set this option handler?
	if (popthdlr != (COptionHandler *)NULL)
		SetOptionHandler(popthdlr);

	// return it
	return popthdlr;
}

void COptionTable::ClearPropertyBag()
{
	COptStr *	poptstr;

	poptstr = m_popthdlr->GetOptionStringTable();
	ASSERT(poptstr != (COptStr *)NULL);
	while (poptstr->idOption != (UINT)-1)
	{
		ClearPropVal(poptstr->rgidArg);
		poptstr++;	// next option args. to clear from prop.bag
	}
}


BOOL COptionTable::ParseString(CString & strOption, OptBehaviour optbeh)
{
	ASSERT(m_popthdlr);

	// set our option flags
	m_optbeh = optbeh;

	// can't have set defaults for root CSlob's
	if (m_pSlob->GetContainer() == (CSlob *)NULL)
		m_optbeh &= ~OBSetDefault;

	// don't clear props for anti-options!
	if (m_optbeh & OBAnti)
		m_optbeh &= ~OBClear;

 	// set the prop. bag usage
	int idOldBag = ((CProjItem *)m_pSlob)->UsePropertyBag((m_optbeh & OBBasePropBag) ? BaseBag : CurrBag);

	CPropBag * 	ppropbag = m_pSlob->GetPropBag();
	COptionHandler * popthdlr;

	popthdlr = m_popthdlr;
	while (popthdlr != (COptionHandler *)NULL)
	{
		// reset
		popthdlr->ResetDirtyArgs();

		// FUTURE: optimize this?
	 	// clear our string list arg. components for each option handler
		if (m_optbeh & OBClear)
			popthdlr->ClearStringLists(ppropbag);

		popthdlr = popthdlr->GetBaseOptionHandler(); // get our base-handler
	}		

	// create our unknown option/string buffers
	CString	strUnknownOption, strUnknownString, strPart;
	UINT nIDUnknownOption, nIDUnknownString;
	m_popthdlr->GetSpecialOptProps(nIDUnknownOption, nIDUnknownString, m_optbeh);

	// We want to append to any previously-read options/strings for this projitem
	// N.B. AppWizard depends on this behavior!

	// append any previous unknown strings/options if we are not clearing
	// ie. this might be multiple Add/Subtract lines in the makefile
	// (AppWizard generates .MAKs like this)
	if (!(m_optbeh & OBClear))
	{
		// don't want inheritance enabled for this
		OptBehaviour optbehOld = ((CProjItem *)m_pSlob)->GetOptBehaviour();
		((CProjItem *)m_pSlob)->SetOptBehaviour(optbehOld & ~OBInherit);

		if (nIDUnknownOption != (UINT)-1 &&
			m_pSlob->GetStrProp(nIDUnknownOption, strUnknownOption) == valid && !strUnknownOption.IsEmpty()
		   )
			strUnknownOption += _T(' ');

		if (nIDUnknownString != (UINT)-1 &&
			m_pSlob->GetStrProp(nIDUnknownString, strUnknownString) == valid && !strUnknownString.IsEmpty()
		   )
			strUnknownString += _T(' ');

		((CProjItem *)m_pSlob)->SetOptBehaviour(optbehOld);
	}

	TCHAR chSrc, chPrefix;
	BOOL fReturn = TRUE;	// default is to pass

	// reset for this new option string
	strSrc = strOption; ichSrc = 0;

	// break out on parse completion, ie. found terminator (chSrc == _T('\0'))
	for (;;)
	{
		// skip any leading whitespace
		cchAdvSrc = 0; SkipWhiteSpace(); ichSrc += cchAdvSrc;

		// reset our advancement pointers
		cchAdvSrc = cchAdvSrcToArg = 0;

		chSrc = NewGetAt(strSrc, ichSrc);

		// parsed all of the source?
		if (chSrc == _T('\0'))	break;

		BOOL fStringTrash = TRUE;	// default is 'it is trash!'

		// are we on a option prefix?
		BOOL fHasPrefix = strPrefixes.Find(chSrc) != -1;
		if (fHasPrefix)
		{
			// remember this prefix
			chPrefix = chSrc;

			// yes, this is an option
			BOOL		fFoundMatch = FALSE;

			ichSrc++;	// move over prefix

			// our option to try and parse with
			COptStr * poptstr;

			// our current fast-lookup object (one for each option handler)
			COptionLookup * poptlookup;

			// for each of our option handler lookup objects do this
			COptionHandler * popthdlrOld = m_popthdlr;	// start off at ourselves

			while (!fFoundMatch && m_popthdlr != (COptionHandler *)NULL)
			{
				// cache some values from this option handler
				m_popthdlr->GetMinMaxOptProps(m_nPropMin, m_nPropMax);
				m_fCaseSensitive = m_popthdlr->IsCaseSensitive();

				// get our fast-lookup object
				poptlookup = m_popthdlr->GetOptionLookup();

				// yes, so try to match each of our options
				poptstr = poptlookup ?
						  poptlookup->LookupFirst(NewGetAt(strSrc, ichSrc), m_fCaseSensitive) : (COptStr *)NULL;

				// we share the lookup list with our base + derived option tables
				// is this a valid option string?
				int cchMinLead = 0;
				while (!fFoundMatch && poptstr != (COptStr *)NULL)
				{
					fFoundMatch = MatchOption(poptstr);

					// did we find a match?
					if (fFoundMatch)
					{
						// yes, advance our source pointer
						ichSrc += cchAdvSrc;
					}
					else
					{
						if (cchAdvSrcToArg > cchMinLead)	cchMinLead = cchAdvSrcToArg;

						// no, get next option to try to match
						// (only get those options with *more* leading chars
						// we could match, ie. not /F% if we match /FI%)
						poptstr = poptlookup->LookupNext(cchMinLead);
					}

					cchAdvSrc = cchAdvSrcToArg = 0;	// reset our advancement pointers
				}

				m_popthdlr = m_popthdlr->GetBaseOptionHandler(); // get our base-handler
			}

			m_popthdlr = popthdlrOld;

			// did we find a match? ie. is this option trash?
			fStringTrash = !fFoundMatch;

			if (fStringTrash && nIDUnknownOption != (UINT)-1)
			{
				// collect together the unknown option
				strPart = ""; CollectOptionPart(strPart, FALSE, TRUE, FALSE, TRUE);

				// append part, terminate with a space
				AdjustBuffer(strUnknownOption);
				strUnknownOption += chPrefix;
				strUnknownOption += strPart;
				strUnknownOption += _T(' ');

				ichSrc += cchAdvSrc;	// advance our source pointer
				fStringTrash = FALSE;	// processed as 'option' string trash
			}
		}
		
		// is this just string trash?
		if (fStringTrash)
		{
			// collect together the trash (note: any collection of characters)
			strPart = ""; CollectOptionPart(strPart, FALSE, TRUE, TRUE, TRUE);
			ichSrc += cchAdvSrc;	// advance our source pointer

			// must have at least an unknown string unless we're Anti
			ASSERT((nIDUnknownString != (UINT)- 1) || (m_optbeh & OBAnti));
			if (nIDUnknownString != (UINT)-1)
			{
				// append part, terminate with a space
				AdjustBuffer(strUnknownString);
				if (fHasPrefix)	strUnknownString += chPrefix;
			  	strUnknownString += strPart;
				strUnknownString += _T(' ');
			}
		}
	}

	// set the unknown option property, and
	// set the unknown string property
	if (nIDUnknownOption != (UINT)-1)
		m_pSlob->SetStrProp(nIDUnknownOption, strUnknownOption);

	if (nIDUnknownString != (UINT)-1)
		m_pSlob->SetStrProp(nIDUnknownString, strUnknownString);

	// do we want to clear out non-dirty items?
	// clear any properties we didn't set
	if (m_optbeh & OBClear)
	{
		popthdlr = m_popthdlr;
		while (popthdlr != (COptionHandler *)NULL)
		{
			// FUTURE: optimize this?
			popthdlr->ClearCleanArgs(ppropbag);
			popthdlr = popthdlr->GetBaseOptionHandler(); // get our base-handler
		}		
	}

   	// reset the prop. bag usage
 	(void) ((CProjItem *)m_pSlob)->UsePropertyBag(idOldBag);

	return fReturn;	// success or failure?
}

void COptionTable::GenerateAppendUnknown(CString & strOption, UINT idOpt)
{
	CString strVal;

	// we need to inheriting!
	// get the prop for each of our ancestor's in elder first order
	CSlob * pSlob = m_pSlob;
	CObList obList;
	if (m_optbeh & OBInherit)
	{
		while (pSlob != (CSlob *)NULL)
		{
			obList.AddHead(pSlob);
			pSlob = ((CProjItem *)pSlob)->GetContainerInSameConfig();	// get our container
		}
	}
	else
	{
		// we can do a no-inheritance thing!
		obList.AddHead(pSlob);
	}

	// if we are a CProjItem and we are inheriting then do our own thing
	// ie. go through each CSlob in the container hierarchy and append each part to 
	// our options
	CString strExtraPart;

	POSITION pos = obList.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		pSlob = (CSlob *)obList.GetNext(pos);

		// CProjGroups don't support tool options!
		if (!pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			// disable inheriting so we can do it!
			BOOL fPropInheritOld = ((CProjItem *)pSlob)->EnablePropInherit(FALSE);

			// use strings
			if (pSlob->GetStrProp(idOpt, strExtraPart) != valid)
				strExtraPart = "";
			else
			if (!strExtraPart.IsEmpty())
			{
				if (!strVal.IsEmpty())
					strVal += _T(' ');
	
				strVal += strExtraPart;	// append
			}

			// re-set inheriting to old value
			((CProjItem *)pSlob)->EnablePropInherit(fPropInheritOld);
		}

		if (pSlob != m_pSlob)
			((CProjItem *)pSlob)->ResetContainerConfig();
	}

	// anything to append?
	if (!strVal.IsEmpty())
	{
		// yes

		UINT cch = strOption.GetLength();
		const TCHAR * pc = (const TCHAR *)NULL;
		if (cch != 0)
		{
			pc = (const TCHAR *) strOption + cch;
			pc = _tcsdec((const TCHAR *) strOption, (TCHAR *)pc);
		}

		// do we need to prepend a space?
		AdjustBuffer(strOption);
		if ((pc != NULL) && (*pc != _T(' '))) strOption += _T(' ');

		strOption += strVal;

		// we know strVal is non-empty so don't check cch != 0
		cch = strVal.GetLength();
		pc = (const TCHAR *) strVal + cch;
		pc = _tcsdec((const TCHAR *) strVal, (TCHAR *)pc);
		// do we need to append a space?
		if ((pc != NULL) && (*pc != _T(' '))) strOption += _T(' ');
	}
}

BOOL COptionTable::GenerateString(CString & strOption, OptBehaviour optbeh)
{
	ASSERT(m_popthdlr);

	// original 'option handler'
	COptionHandler * popthdlrOld = m_popthdlr;

	// set our option flags
	m_optbeh = optbeh;

	// being a root node implies inheritance by default
	if (m_pSlob->GetContainer() == (CSlob *)NULL)
		m_optbeh |= OBInherit;

	// no inheritance for anti-options
	if (m_optbeh & OBAnti)
		m_optbeh &= ~OBInherit;

	// don't use defaults to gen. with
	m_fUseDefault = FALSE;

	// set up our option behaviour
	// (selectively mask the current behaviour)
	OptBehaviour optbehOld = ((CProjItem *)m_pSlob)->GetOptBehaviour();

	optbeh = optbehOld;

	if (m_optbeh & OBInherit)
		optbeh |= OBInherit;
	else
		optbeh &= ~OBInherit;

 	(void)((CProjItem *)m_pSlob)->SetOptBehaviour(optbeh);

	// set the prop. bag usage
	int idOldBag = ((CProjItem *)m_pSlob)->UsePropertyBag((m_optbeh & OBBasePropBag) ? BaseBag : CurrBag);

	// iterate through our option table trying to generate
	// each option into a string and append it to our options

	// prefix to use
	CString strPrefix(strPrefixes[0]);

	UINT nIDUnknownOption, nIDUnknownString;
	m_popthdlr->GetSpecialOptProps(nIDUnknownOption, nIDUnknownString, m_optbeh);

	// create our list of pointers to option handlers
	CPtrList lstopthdlrs; UINT iopthdlr = 0;
	COptionHandler * popthdlr = m_popthdlr;
	while (popthdlr != (COptionHandler *)NULL)
	{
		lstopthdlrs.AddHead(popthdlr);
		popthdlr = popthdlr->GetBaseOptionHandler();
	}

	// our stack of remembered positions in option handler string
	// tables, this is initially empty
	CPtrList stkpoptstr;

	// ptr. into the string table for this handler
	COptStr * poptstr = (COptStr *)NULL;

	for (;;)
	{
	OptHdlr_Recurse:

		// get the next current option handler
		POSITION pos = lstopthdlrs.FindIndex(iopthdlr);
		ASSERT(pos != (POSITION)NULL);	// must exist

		m_popthdlr = (COptionHandler *)lstopthdlrs.GetAt(pos);

		// begin a new table?
		if (poptstr == (COptStr *)NULL)
			poptstr = m_popthdlr->GetOptionStringTable();	// begin a new table

		while (poptstr->idOption != (UINT)-1)
		{									
			// is this a request to start processing the derived option handler string table?
			if (poptstr->idOption == IDOPT_DERIVED_OPTHDLR)
			{
				poptstr++;
				
				// can we get a derived option handler?
				if (iopthdlr == (UINT)(lstopthdlrs.GetCount() - 1))
 					continue;	// can't do, continue
					
				// remember our next position in this table, and our current option handler
				stkpoptstr.AddTail(poptstr); ++iopthdlr; poptstr = (COptStr *)NULL;
				goto OptHdlr_Recurse;
			}
			// is this option the an collection of unknown strings or options?
			else if (poptstr->idOption == IDOPT_UNKNOWN_OPTION)
			{
				// yes, append our unknown options
				if (nIDUnknownOption != (UINT)-1 && !(m_optbeh & OBAnti))
					GenerateAppendUnknown(strOption, nIDUnknownOption);
			}
			else if (poptstr->idOption == IDOPT_UNKNOWN_STRING)
			{
				// yes, append out unknown strings (only for unk. opt. hdlr anti options)
				if (nIDUnknownString != (UINT)-1 &&
					(!(m_optbeh & OBAnti) || m_popthdlr->IsKindOf(RUNTIME_CLASS(COptHdlrUnknown)))
				   )
					GenerateAppendUnknown(strOption, nIDUnknownString);
			}
			else
			{
				(void) GenerateOption(strOption, poptstr, strPrefix, TRUE);
			}

			// next option to try to generate
			poptstr++;
		}

		// is this the last option string table?
		if (stkpoptstr.IsEmpty())
			break;

		// finished with this option handler and string table, restore last one
		poptstr = (COptStr *)stkpoptstr.RemoveTail();
		iopthdlr--;
	}

   	// reset the prop. bag usage							 
 	(void) ((CProjItem *)m_pSlob)->UsePropertyBag(idOldBag);

	// reset our option behaviour
	((CProjItem *)m_pSlob)->SetOptBehaviour(optbehOld);

	// reset our current option handler
	m_popthdlr = popthdlrOld;

	return TRUE;	// *always* success
}

BOOL COptionTable::GenerateSingleOption(UINT id, CString & strOption, OptBehaviour optbeh)
{
	ASSERT(m_popthdlr);

	COptStr * poptstr = m_popthdlr->GetOptionStringTable();
	ASSERT(poptstr != (COptStr *)NULL);

	// set our option flags
	m_optbeh = optbeh;
	// being a root node implies inheritance by default
	if (m_pSlob->GetContainer() == (CSlob *)NULL)
		m_optbeh |= OBInherit;

	// don't use defaults
	m_fUseDefault = FALSE;

 	// set the prop. bag usage
	int idOldBag = ((CProjItem *)m_pSlob)->UsePropertyBag((m_optbeh & OBBasePropBag) ? BaseBag : CurrBag);

	// prefix to use
	CString strPrefix(strPrefixes[0]);

	// set up the inheritance (if we can!)
	BOOL fPropInheritOld = ((CProjItem *)m_pSlob)->EnablePropInherit(m_optbeh & OBInherit);

	// remember the old option handler
	COptionHandler * popthdlrOld = m_popthdlr;

	// find the option we want then try to generate
	BOOL		fReturn = FALSE;	// default is to fail
	COptionHandler * popthdlr = m_popthdlr;
	while (!fReturn && popthdlr != (COptionHandler *)NULL)
	{
		COptionLookup * poptlookup = popthdlr->GetOptionLookup();
		poptstr = poptlookup ? poptlookup->Lookup(id) : (COptStr *)NULL;
		if (poptstr != (COptStr *)NULL)
		{
			// use this option handler to generate the single option string
			m_popthdlr = popthdlr;
	
			// generate the option
			fReturn = GenerateOption(strOption, poptstr, strPrefix, FALSE);
		}

		popthdlr = popthdlr->GetBaseOptionHandler();
	}

	// reset to the old option handler
	m_popthdlr = popthdlrOld;

	// reset the inheritance (if we can!)
	(void) ((CProjItem *)m_pSlob)->EnablePropInherit(fPropInheritOld);

   	// reset the prop. bag usage
 	(void) ((CProjItem *)m_pSlob)->UsePropertyBag(idOldBag);

	return fReturn;	// success or failure?
}

BOOL COptionTable::GenerateDescription
(
	CString &	strOut,
	BOOL &		fBlank
)
{
	// original 'option handler'
	COptionHandler * popthdlrOld = m_popthdlr;

	// we want to show the defaults if we are a child CSlob, otherwise don't
	CSlob * pSlobParent = m_pSlob->GetContainer();
	BOOL fSlobIsChild = pSlobParent != (CSlob *)NULL;
	m_optbeh = fSlobIsChild ? OBShowFake | OBShowDefault : OBNone;

	// set up the inheritance (if we can!)
	BOOL fPropInheritOldChild = ((CProjItem *)m_pSlob)->EnablePropInherit(TRUE);
 	BOOL fPropInheritOldParent = ((CProjItem *)pSlobParent)->EnablePropInherit(TRUE);

	// our prefix to use
	CString strPrefix(strPrefixes[0]), strEnglish;
	CString strOptionParent, strOptionChild;

	CString strLangAnd;	VERIFY(strLangAnd.LoadString(IDS_PROJECT_AND));
	CString strLangReplace;	VERIFY(strLangReplace.LoadString(IDS_PROJECT_REPLACES));
	CString strLangAndNot; VERIFY(strLangAndNot.LoadString(IDS_PROJECT_ANDNOT));

	// the options we inherit from. if any!
	if (!fSlobIsChild)
	{
		strOut.LoadString(IDS_TXT_DEF_OPT);
	}
	else if ((pSlobParent->IsKindOf(RUNTIME_CLASS(CProxySlob)) &&
			  ((CProxySlob *)pSlobParent)->IsSortOf(RUNTIME_CLASS(CProject)))
			 ||
			  pSlobParent->IsKindOf(RUNTIME_CLASS(CProject))
			 ||
			 (pSlobParent->IsKindOf(RUNTIME_CLASS(CProxySlob)) &&
			  ((CProxySlob *)pSlobParent)->IsSortOf(RUNTIME_CLASS(CProjGroup)))
			 ||
			 pSlobParent->IsKindOf(RUNTIME_CLASS(CProjGroup))
			 ||
			 (pSlobParent->IsKindOf(RUNTIME_CLASS(CProxySlob)) &&
			  ((CProxySlob *)pSlobParent)->IsSortOf(RUNTIME_CLASS(CTargetItem)))
			 ||
			 pSlobParent->IsKindOf(RUNTIME_CLASS(CTargetItem))
			)
	{
		strOut.LoadString(IDS_TXT_PRJ_OPT);
	}
	else
	{
		// This must be a multiple-selection CProxySlob with different container types.
		// Currently we don't generate a description for a multiple-selection and this
		// function is not called in this situation.
		ASSERT(FALSE);
	}

	// default is blank
	fBlank = TRUE;

	// create our list of pointers to option handlers
	CPtrList lstopthdlrs; UINT iopthdlr = 0;
	COptionHandler * popthdlr = m_popthdlr;
	while (popthdlr != (COptionHandler *)NULL)
	{
		lstopthdlrs.AddHead(popthdlr);
		popthdlr = popthdlr->GetBaseOptionHandler();
	}

	// our stack of remembered positions in option handler string
	// tables, this is initially empty
	CPtrList stkpoptstr;

	// ptr. into the string table for this handler
	COptStr * poptstr = (COptStr *)NULL;

	for (;;)
	{
	OptHdlr_Recurse:

		// get the next current option handler
		m_popthdlr = (COptionHandler *)lstopthdlrs.GetAt(lstopthdlrs.FindIndex(iopthdlr));

		// begin a new table?
		if (poptstr == (COptStr *)NULL)
			poptstr = m_popthdlr->GetOptionStringTable();	// begin a new table

		while (poptstr->idOption != (UINT)-1)
		{									
			// don't do this for the 'special' options!
			if (poptstr->idOption == IDOPT_UNKNOWN_OPTION ||
				poptstr->idOption == IDOPT_UNKNOWN_STRING)
			{
				poptstr++;

				continue;
			}
			// is this a request to start processing the derived option handler string table?
			else if (poptstr->idOption == IDOPT_DERIVED_OPTHDLR)
			{
				poptstr++;
				// can we get a derived option handler?
				if (iopthdlr == (UINT)(lstopthdlrs.GetCount() - 1))
 					continue;	// can't do, continue

				// remember our next position in this table, and our current option handler
				stkpoptstr.AddTail(poptstr); ++iopthdlr; poptstr = (COptStr *)NULL;
				goto OptHdlr_Recurse;
			}
		
			strOptionChild = "";	// clear

			// disable inheriting if we were a multiple option
			BOOL fMultipleOption;
			if (fMultipleOption = (poptstr->type == multiple))
				((CProjItem *)m_pSlob)->EnablePropInherit(FALSE);

			// generate the child option (don't use defaults!)
			m_fUseDefault = FALSE;

			(void) GenerateOption(strOptionChild, poptstr, strPrefix, FALSE);

			// can't do this if we are not a child CSlob
			if (fSlobIsChild)
			{ 
				// we had this option in the child CSlob
				CSlob * pSlob = m_pSlob;
				SetPropertyBag(pSlobParent);	// use our parent CSlob

				strOptionParent = "";

				// did we add an option?
				// if we did, try to generate the equivalent in the parent CSlob
				if (!strOptionChild.IsEmpty())
				{
					// don't do the replace for string lists, ie. multiple options
					if (poptstr->type != multiple) /* single option */
					{
						// generate the parent option (use defaults!)
						m_fUseDefault = TRUE;
				  		(void) GenerateOption(strOptionParent, poptstr, strPrefix, FALSE);
					}

					// shall we do the and text?
					if (strOptionParent.IsEmpty() || 
						strOptionChild != strOptionParent)	/* do and */
					{
						// let's use the ', and ' prefix first off
						strOut += strLangAnd;
						strOut += strOptionChild;
						if (poptstr->type != multiple &&
							!strOptionParent.IsEmpty())	 /* do replace */
						{
							// let's use the ' replaces ' prefix
							strOut += strLangReplace;
							strOut += strOptionParent;
						}
						fBlank = FALSE;
					}
				}
				else
				{
					// we didn't have this option in the child CSlob
					// did we have properties though?	
					if (m_fGenUsedProps)
					{						
						// generate the parent option (use defaults!)
						m_fUseDefault = TRUE;
				  		(void) GenerateOption(strOptionParent, poptstr, strPrefix, FALSE);

						// now construct our English text
						if (!strOptionParent.IsEmpty())
						{
							// let's use the ', and not ' prefix
							strOut += strLangAndNot;
							strOut += strOptionParent;
							fBlank = FALSE;
						}
					}
				}

	 			SetPropertyBag(pSlob);			// reset to our child CSlob

				// do we have a string list 'subtract' part? ie. is this a multiple option
				// (the above comment is strange .. some might say hacky .. but who gives a s**t!)
				if (fMultipleOption)
				{
					strOptionChild = "";

					// we get the subtract part using anti-options
					m_optbeh |= OBAnti; // set
			  		(void) GenerateOption(strOptionChild, poptstr, strPrefix, FALSE);

					// now construct our English text
					if (!strOptionChild.IsEmpty())
					{
						// let's use the ', and not ' prefix
						strOut += strLangAndNot;
						strOut += strOptionChild;
						fBlank = FALSE;
					}

					m_optbeh &= ~OBAnti; // clear
				}
			}
			else
			{
				// for non-child CSlob's do this
				// let's use the ', and ' prefix first off
				strOut += strLangAnd;
				strOut += strOptionChild;
				fBlank = FALSE;
			}
 
			// re-enable inheriting if we were a multiple option
			if (fMultipleOption)
				((CProjItem *)m_pSlob)->EnablePropInherit(TRUE);

			poptstr++;
		}

		// is this the last option string table?
		if (stkpoptstr.IsEmpty())
			break;

		// finished with this option handler and string table, restore last one
		poptstr = (COptStr *)stkpoptstr.RemoveTail();
		iopthdlr--;
	}

	// reset the inheritance (if we can!)
	(void) ((CProjItem *)m_pSlob)->EnablePropInherit(fPropInheritOldChild);
	(void) ((CProjItem *)pSlobParent)->EnablePropInherit(fPropInheritOldParent);

	// reset our current option handler
	m_popthdlr = popthdlrOld;

	return TRUE;
}

BOOL COptionTable::CollectOptionPart
(
	CString &	strOut,			// the collected option part
	BOOL		fAlphaNumOnly,	// allow only alpha-numeric
	BOOL		fAllowPunct,	// allow punctuation
	BOOL		fAllowKanji,	// allow Kanji characters
	BOOL		fKeepQuotes,	// keep the quotes?
	CString		strDelim		// any delimiters (could be empty)
)
{
	BOOL			fQuoted, fEscaped;
	UINT			ichFirst, cchAdvSrcOrig;
	TCHAR			* pchSrc, ch;

	// figure first char.
	ichFirst = ichSrc + cchAdvSrc; cchAdvSrcOrig = cchAdvSrc;

CollectOptionPart:

	fEscaped = FALSE;
	pchSrc = (TCHAR *)(const TCHAR *)strSrc + ichSrc + cchAdvSrc; 

	// move over the first quote if we have one
	if (fQuoted = (*pchSrc == _T('"')))
	{	
		// we're a quoted string
		pchSrc++; cchAdvSrc++;
		if (!fKeepQuotes)
		{
			ichFirst++; cchAdvSrcOrig++;
		}
	}

	// check for '/OPTION" /' where we are parsing
	// a partial typed string, we'll assume that whitespace
	// followed by an option delimiter is not a valid arg.
	int ichLeadWhiteSpace = cchAdvSrc;	// assume whitespace for quoted

	// the end of the option part is
	// o whitespace (if not quoted) or null terminator
	// o a double-quote (if not escaped)
	// o a non alpha-numeric if fAlphaNumOnly = TRUE
	// o a punctuation character ~= '=' and ~= ',' not a flag prefix
	// o we hit a delimiter
	while ((ch = *pchSrc) != _T('\0'))
	{
		int cch = _tclen(pchSrc); pchSrc += cch;

		// allow only alpha-numeric
		if (fAlphaNumOnly)
		{
			if (!isalnum(ch) && ch != _T('-') && ch != _T('+'))
				break;
		}
		// allow all alpha
		else if (isalpha(ch))
		{
			ichLeadWhiteSpace = 0;
		}
		else
		{
	#ifdef _MBCS
			if (!fAllowKanji && (_ismbbkana(ch) || _ismbblead(ch)))
				break;
	#endif

			// currently parsing a quoted string?
			if (fQuoted)
			{
				// yes
				// FUTURE: do we allow escaped 'quotes' in tool options?
				if (/*!fEscaped &&*/ ch == _T('"'))
					break;

				if (ichLeadWhiteSpace)
				{
					if (!_istspace(ch))
					{
						if (strPrefixes.Find(ch) != -1)
						{
							// back-up to the quote before the whitespace
							cchAdvSrc = ichLeadWhiteSpace;
							break;	// break here, we found '/OPTION"   /'
						}

				 		ichLeadWhiteSpace = 0;
					}
				}
			}
			else
			{
				//no
				// allow punctuation inside a quoted string!
				if (!fAllowPunct && ispunct(ch))
				{
					// FUTURE (matthewt): when we process '=' for defines correctly
					// then maybe we want to split the args, for now treat
					// as one arg.
					if (ch == _T('=') || ch == _T(','))
						break;

					if (strPrefixes.Find(ch) != -1)
						break;
				}

				if (_istspace(ch) || strDelim.Find(ch) != -1)
					break;	// break here, we found option delimiter (incls. whitespace)
			}
		}

		cchAdvSrc += cch;

		// do we have '\\' at the end of our string?
		if (fEscaped && fQuoted && ch == _T('\\') && *pchSrc == _T('"'))
			// skip back over the last one (ie. ignore it)
			cchAdvSrcOrig++;

		fEscaped = !fEscaped && ch == _T('\\');
	}

	UINT cchOut = cchAdvSrc - cchAdvSrcOrig;

 	// eat the final quote if we have one
	if (fQuoted && ch == _T('"'))
	{
		// we're a quoted string
		cchAdvSrc++;
		if (fKeepQuotes)	cchOut++;
	}

	// do it for the 2nd half of an arg., eg. /D foo="bar"
	if (!fQuoted && ch == _T('='))
	{
		// we're an equals sign
		cchAdvSrc++;

		// keep the quotes (if they exist) for second half of assignment
		// (ignore return of FALSE - we don't care if empty)
		fKeepQuotes = TRUE;
		goto CollectOptionPart;	// next half
	}

	// have we actually found any characters?
	if (!cchOut)
	{
		// do we need to have a quoted empty string
		// in order to succeed?
		if ((m_optbeh & OBNeedEmptyString) && !fQuoted)
			return FALSE;

		strOut = "";
	}
	else
	{
		ASSERT(ichFirst >= 0 && cchOut > 0);
		strOut += strSrc.Mid(ichFirst, cchOut);
	}

	return TRUE;	// got a match
}

void COptionTable::ExtractOptionArg(char * & pchExpr, UINT & cchExpr)
{
	char	chExpr = *pchExpr;
	TCHAR *	pch;
	UINT	cchArg = 0;

	// argument value pattern?
	//
	patArgValue = none;

	if (chExpr == _T('T') || chExpr == _T('F') ||
		chExpr == _T('t') || chExpr == _T('f'))
	{
		// booln arg
		pch = pchExpr++; cchArg++; // move over booln arg.
		patArgValue = booln;
	}
	else
	if (chExpr == _T('{') ||
		chExpr == _T('<'))
	{
		// what is our terminator char?
		TCHAR chTerm = chExpr == _T('{') ? _T('}') : _T('>');

		// choice or absolute arg
		pch = ++pchExpr; cchExpr--; // skip over '{' or '<'
		patArgValue = chExpr == _T('{') ? choice : absolute;

		char	chExpr, * pch;
									  
		// extract our '<...>' or '{...}' chunk
		chExpr = *pchExpr; pch = pchExpr;
		while (chExpr != chTerm)
		{
			chExpr = *pchExpr;	// we want' to stop just after the '}' or '>'!
			pchExpr = _tcsinc(pchExpr);
		}
		cchArg = pchExpr - pch;
	}

	cchExpr -= cchArg;

	// ensure that the arg buffer is big enough
	// for debug purposes only, the option table arg
	// 'chunks' are static
	ASSERT(cchArg < cchArgValue);
	_tcsncpy(pchArgValue, pch, cchArg); 
	pchArgValue[cchArg] = _T('\0');	// terminate
}

void COptionTable::ExtractPart(char * & pchExpr, UINT & cchExpr, char * & pchPart, UINT & cchPart)
{
	UINT	cBrackets = 1;		// used to count brackets
	char	chExpr;

	cchPart = 0;	// init. the count of chars in the part
	pchPart = ++pchExpr; cchExpr--;	// skip the '[', and remember the position

	// search for the corresponding close bracket
	while (TRUE)
	{
		chExpr = *pchExpr;
		ASSERT(chExpr != _T('\0'));	// must be able to find one!

		if (chExpr == _T('['))	cBrackets++;	// bump up bracket count
		else
		if (chExpr == _T(']'))	cBrackets--;	// bump down bracket count

		// have we found the match?
		if (cBrackets == 0)
			break;	// yes, so break-out of here

		UINT	cch = _tclen(pchExpr);
		cchPart += cch; pchExpr += cch; cchExpr -= cch;
	}

	pchExpr++; cchExpr--;	// terminate on the ']'
}

BOOL COptionTable::MatchChoice(UINT &nChoiceMatch, char * pchChoice, UINT * pidArg)
{
	UINT cchChoice;
	int cchAdvSrcKeep;
	char * pchStart;

	// signal any kind of match
	nChoiceMatch = 0;	// no match

	for (UINT nChoice = 1 ; /* we'll break out! */ ; nChoice++ /* next choice */)
	{
		pchStart = pchChoice;

		// find our choice expression
		while (*pchChoice != _T('|') && *pchChoice != _T('}'))
			pchChoice = _tcsinc(pchChoice);

		// do we have a choice to match?
		if (cchChoice = (pchChoice - pchStart))
		{
			cchAdvSrcKeep = cchAdvSrc;
			if (MatchExpression(pchStart, cchChoice, pidArg))
			{
				nChoiceMatch = nChoice;		// matched, or last resort match (cchAdvSrc == cchAdvSrcKeep)

				if (cchAdvSrc != cchAdvSrcKeep)	return TRUE;	// matched option

				// this choice matched no chars, ie. was purely arg matching
				// we will use this nChoice if no other option matches
			}
			cchAdvSrc = cchAdvSrcKeep; 	// no match
		}
		// this is an empty option
		// we will use this nChoice if no other option matches
		else
			nChoiceMatch = nChoice;	// last resort match	

		// skip over the '|'
		if (*pchChoice++ == _T('}'))
			return (nChoiceMatch != 0);	// no match possible?
										// ran out of choices, maybe last resort choice?
	}

	return TRUE;
}

BOOL COptionTable::GenerateChoice(CString & strOptionBit, UINT nChoice, char * pchChoice, UINT * pidArg)
{
	if (!nChoice)	return FALSE;	// no generation possible, no choice

	// look through the options for our one
	while (--nChoice != 0)
	{
		while (*pchChoice != _T('|') && *pchChoice != _T('}'))
			pchChoice = _tcsinc(pchChoice);

		// skip over the '|'
		if (*pchChoice++ == _T('}'))	return FALSE;	// no generation possible, ran out of choices
	}

	// now try to generate this option
	char *	pchStart = pchChoice;
	UINT	cchChoice = 0, cch;

	while (*pchChoice != _T('|') && *pchChoice != _T('}'))
	{
		cch = _tclen(pchChoice);
		pchChoice += cch; cchChoice += cch;
	}

	// FUTURE: do we want to generate 'empty' option bits (eg. empty string "")
	if (cchChoice == 0) return TRUE;

	// try option generation
	return GenerateExpression(strOptionBit, pchStart, cchChoice, pidArg);
}

																	   
BOOL COptionTable::MatchExpression(const char * pchExprConst, UINT cchExpr, UINT * pidArg)
{
	UINT cch, cArgs = 0;
	char * pchExpr = (char *)pchExprConst;
	unsigned char chExpr; // expression character

	CString	strOut; // output string
    
    char * pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our source                                        
                               
	// have we finished this pattern? we will break out on failure (return)
	while (cchExpr != 0)
	{
  		chExpr = *pchExpr;

 		// do we have an argument specified?
		if (chExpr == _T('%'))
		{
			// increment the number of args. found
			// first?
			if (++cArgs == 1)
				cchAdvSrcToArg = cchAdvSrc;	// remember the adv. src. to arg.

			cch = _tclen(pchExpr);
			pchExpr += cch; cchExpr -= cch; // move over arg. spec.
			chExpr = *pchExpr;

			// argument value?
			ExtractOptionArg(pchExpr, cchExpr);

			// argument index
			//
			UINT	iArg;		// our arg. index
			UINT	idArgProp;	// our arg. property
								  
			chExpr = *pchExpr;
			ASSERT(isdigit(chExpr));	// must be an arg. index!
			iArg = chExpr - '1';
			idArgProp = pidArg[iArg];	// retrieve this arg's property #
			cch = _tclen(pchExpr);
 			pchExpr += cch; cchExpr -= cch;	// move over arg. index

			BOOL fFake = m_popthdlr->IsFakeProp(idArgProp);
			BOOL fAlwaysShowDefault = m_popthdlr->AlwaysShowDefault(idArgProp);

			// what type of property is this?
			// we want to match in the source the property value
			switch (m_popthdlr->GetDefOptionType(idArgProp) /* property type */)
			{
				case ::integer:
				{
					int nVal;

					// do we want to match an choice?
					if (patArgValue == choice)
					{
						UINT uVal;

						// match a choice in the string
						if (!MatchChoice(uVal, pchArgValue, pidArg))
						{
							// for 0th choices we might have used subtract
							if (!(m_optbeh & OBAnti) || _tcsncmp(pchSrc, _TEXT("<none>"), 6))
								return FALSE;	// no match, failed to find choice

							cchAdvSrc += 6;	// skip over

							// consume this source
							pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source                                        

							uVal = 0;	// 0th
						}

						nVal = (int)uVal;
					}
					// do we want to set an absolute?
					else if (patArgValue == absolute)
					{
						// convert this absolute into a numeric to suit
						// the subtype of this integer 
					   	VERIFY(m_popthdlr->ConvertFromStr(idArgProp, pchArgValue, nVal));
					}
					else
					{
						// just match an integer in the string
						if (!CollectOptionPart(strOut, TRUE) || strOut.IsEmpty())
							return FALSE;	// no match, failed to collect

						// got a match, consume this source
						pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source                                        

						// do the conversion from a string into an integer
						// based on the sub-type
					   	if (!m_popthdlr->ConvertFromStr(idArgProp, strOut, nVal))
						{
							// couldn't convert due to bad numeric format
							// use existing value if one exists!
							CProp * pProp = m_pSlob->GetPropBag()->FindProp(idArgProp);
							if (pProp == (CProp *)NULL)
							{
								AddToPropList(iArg, idArgProp, NULL);
								break;	// doesn't exist, ignore ie. no pass, no fail
							}
							nVal = ((CIntProp *)pProp)->m_nVal;
						}
					}

					// don't set defaults, or fake props
					BOOL fSet;
					if (fFake)
						fSet = fAlwaysShowDefault;
					else
						fSet = fAlwaysShowDefault || (m_optbeh & OBSetDefault);

					if (!fSet && m_popthdlr->IsDefaultIntProp(idArgProp, nVal))
						break;

					CIntProp *	ppropInt = new CIntProp(nVal);
					AddToPropList(iArg, idArgProp, ppropInt);
					break;
				}
				
				case ::booln:
				{
					BOOL	bVal;
					BOOL	fSoftBool = FALSE;

					// do we want to match an choice?
					if (patArgValue == choice)
					{	
						UINT	nVal;

						// match a choice in the string
						if (!MatchChoice(nVal, pchArgValue, pidArg))
							return FALSE;	// no match, failed to find choice

						// got a match, consume this source
						pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source 
						                                       
						// match an choice in the string
						bVal = (nVal == 1) ? FALSE : TRUE;	// convert to a booln
					}
					else
					{
						ASSERT(patArgValue == booln);
						// just set the property based in the booln arg value
						bVal = (*pchArgValue == _T('T') || (fSoftBool = (*pchArgValue == _T('t'))));
					}

					// don't set defaults, or fake props
					BOOL fSet;
					if (fFake)
						fSet = fAlwaysShowDefault;
					else
						fSet = fAlwaysShowDefault || (m_optbeh & OBSetDefault);

					if (!fSet && m_popthdlr->IsDefaultBoolProp(idArgProp, bVal))
						break;

					// do we need to invert the integer value?
					// FUTURE: don't do this for softbool values (remove when per-prop remove in .PRJ)
					if ((m_optbeh & OBAnti) && !fSoftBool) 
						bVal = !bVal;	// invert

					CBoolProp *	ppropBool = new CBoolProp(bVal);
					AddToPropList(iArg, idArgProp, ppropBool);
					break;
				}

				case ::string:
				{
					if (!CollectOptionPart(strOut))
						return FALSE;	// no match, failed to collect

					// got a match, consume this source
					pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source                                        

					// don't set defaults, or fake props
					BOOL fSet;
					if (fFake)
						fSet = fAlwaysShowDefault;
					else
						fSet = fAlwaysShowDefault || (m_optbeh & OBSetDefault);

					if (!fSet && m_popthdlr->IsDefaultStringProp(idArgProp, strOut))
						break;

					CStringProp * ppropString = new CStringProp(strOut);
					AddToPropList(iArg, idArgProp, ppropString);
					break;
				}
					 
				case ::longint:	// not yet needed!
				case ::number:
					break;

				default:
					ASSERT(FALSE);
					break;
			}
		}
		// do we have an open bracket (optional part)?
		else if (chExpr == _T('['))
		{
			char * pchPart;
			UINT cchPart;

			// extract the optional part
			ExtractPart(pchExpr, cchExpr, pchPart, cchPart);

			// don't bother matching empty optional parts
			if (cchPart != 0)
			{
				NoChangedPropValList();	// reset, so we recognise args to back-out
				if (MatchExpression(pchPart, cchPart, pidArg))
					// got a match, consume this source
				    pchSrc = (char *)(const char *)strSrc + ichSrc + cchAdvSrc;	// our 'new' source                                        
				else
					// back-out args set in no match optional part
					ClearPropValList(TRUE);
			}

			// continue, this is matching an optional part
		}
		// is this a 'just' whitespace candidate?
		// only do this for 'single whitespace expressions'
		else if (cchExpr == 1 && chExpr == _T(' '))
		{
			UINT cchAdvSrcOrig = cchAdvSrc;

			SkipWhiteSpace();	// skip any  whitespace
			pchExpr++; cchExpr--;	// skip over this space in the expression
			pchSrc += (cchAdvSrc - cchAdvSrcOrig);	// advance our source
		}
		// else should just try to match this
		else
		{
			if (_tccmp(pchExpr, pchSrc) != 0)	// not a char. match
			{
				unsigned char chSrc = *pchSrc;

				// did this not match 'cos of only case insensitivity
				if (m_fCaseSensitive || (toupper(chExpr) != toupper(chSrc)))
					return FALSE;
			}

			cch = _tclen(pchExpr);
			pchExpr += cch; cchExpr -= cch;

			cch = _tclen(pchSrc);
			pchSrc += cch; cchAdvSrc += cch;
		}

		// continue trying to match source and expression
	}
	return TRUE;	// successful match
}

BOOL COptionTable::GenerateExpression(CString & strOptionBit, const char * pchExprConst, UINT cchExpr, UINT * pidArg)
{
	UINT	cch;
	char * 	pchExpr = (char *)pchExprConst;
	unsigned char chExpr;	// expression character

	if (cchExpr == 0)
		return FALSE;

	// have we finished this pattern? we will break out on failure (return)
	while (cchExpr != 0)
	{
		chExpr = *pchExpr;

		// do we have an argument specified?
		if (chExpr == _T('%'))
		{
			cch = _tclen(pchExpr);
			pchExpr += cch; cchExpr -= cch; // move over arg. spec.
			chExpr = *pchExpr;

			// argument value?
			ExtractOptionArg(pchExpr, cchExpr);

			// argument index
			//
			UINT	idArgProp;	// our arg. property
								  
			chExpr = *pchExpr;
			ASSERT(isdigit(chExpr));	// must be an arg. index!
			idArgProp = pidArg[chExpr - '1'];	// retrieve this arg's property #
			cch = _tclen(pchExpr);
 			pchExpr += cch; cchExpr -= cch;	// move over arg. index

			BOOL fFake = m_popthdlr->IsFakeProp(idArgProp);
			BOOL fAlwaysShowDefault = m_popthdlr->AlwaysShowDefault(idArgProp);

			// what type of property is this?
			// we want to generate in the output the property value
			switch (m_popthdlr->GetDefOptionType(idArgProp) /* property type */)
			{
				case ::integer:
				{
					int		nVal;
					BOOL	fAbort;

					ASSERT(!m_fMultipleGen);	// only for single

					// want to show the option defaults when generating an option string?
					BOOL fPropDefaultOld = ((CProjItem *)m_pSlob)->UseOptionDefaults
 										   	(!(m_optbeh & OBAnti) && (m_fUseDefault || fAlwaysShowDefault));

					// get the property value
					// can't generate invalid props!
					BOOL fValid = m_pSlob->GetIntProp(idArgProp, nVal) == valid;

 					// we don't want to show the option defaults when generating an option string!
					(void) ((CProjItem *)m_pSlob)->UseOptionDefaults(fPropDefaultOld);

  					// can't generate invalid props!
					if (!fValid)	return FALSE;

					// used a prop!
					m_fGenUsedProps = TRUE;

					BOOL fIgnore;

					if (fFake)
						fIgnore = fAlwaysShowDefault || (m_optbeh & OBShowFake);
					else
						fIgnore = fAlwaysShowDefault || (m_optbeh & OBShowDefault);

					// is this a default?
					// don't bother checking for always showing defaults
					// don't bother for fake props.
					BOOL fGenerate = fIgnore || !m_popthdlr->IsDefaultIntProp(idArgProp, nVal);
					if (!fGenerate)
						return FALSE;

					// do we want to generate a choice?
					if (patArgValue == choice)
					{
						if (fAbort = !GenerateChoice(strOptionBit, nVal, pchArgValue, pidArg))
						{
							// for 0th choices  we'll need to use subtract
							if (!nVal && (m_optbeh & OBAnti))
							{
								strOptionBit += _TEXT("<none>");	// none
								fAbort = FALSE;
							}
						}
					}
					// do we have a match in the absolute value?
					else if (patArgValue == absolute)
					{
						// convert this absolute into a numeric to suit
						// the subtype of this integer 
						int nAbsoluteVal;
					   	VERIFY(m_popthdlr->ConvertFromStr(idArgProp, pchArgValue, nAbsoluteVal));
						fAbort = (nVal != nAbsoluteVal);
					}
					// do we want to generate an integer?
					else
					{
						ASSERT(patArgValue == none);
						CString strVal;

						// do the conversion from an integer into a string
						// based on the sub-type
					   	VERIFY(m_popthdlr->ConvertToStr(idArgProp, nVal, strVal));
						strOptionBit += strVal;
						fAbort = FALSE;
					}

					if (fAbort)	return FALSE;	// no generate, failed to generate integer value
					break;
				}

				case ::booln:
				{
					ASSERT(!m_fMultipleGen);	// only for single

					BOOL bVal, fAbort;
					BOOL fSoftBool = patArgValue == booln &&
									(*pchArgValue == _T('t') ||
									 *pchArgValue == _T('f'));

					// want to show the option defaults when generating an option string?
					BOOL fPropDefaultOld = ((CProjItem *)m_pSlob)->UseOptionDefaults
										   	(!(m_optbeh & OBAnti) && (fSoftBool || m_fUseDefault || fAlwaysShowDefault));

					// get the property
					BOOL fValid = m_pSlob->GetIntProp(idArgProp, bVal) == valid;

					(void) ((CProjItem *)m_pSlob)->UseOptionDefaults(fPropDefaultOld);

					// can't generate invalid props!
					// FUTURE: don't do this for invalid anti-softbool (fix when per-prop sub. in .PRJ)
					if (!fValid && !(fSoftBool && (m_optbeh & OBAnti)))
						return FALSE;

					// used a prop.
					m_fGenUsedProps = TRUE;

 					BOOL fIgnore;

					if (fFake)
						fIgnore = fAlwaysShowDefault || (m_optbeh & OBShowFake);
					else
						fIgnore = fAlwaysShowDefault || (m_optbeh & OBShowDefault) || fSoftBool;

	  				// do we need to invert the returned value?
					// FUTURE: don't do this for softbool values (fix when per-prop sub. in .PRJ)
					if ((m_optbeh & OBAnti) && !fSoftBool)
						bVal = !bVal;	// invert

					// is this a default?
					// don't bother checking for booln 't' and 'f'
					// don't bother checking for always showing defaults
					// don't bother for fake props.
					BOOL fGenerate = fIgnore || !m_popthdlr->IsDefaultBoolProp(idArgProp, bVal);
					if (!fGenerate)
						return FALSE;

					// do we want to generate a choice?
					if (patArgValue == choice)
					{
						fAbort = !GenerateChoice(strOptionBit, bVal ? 2 : 1, pchArgValue, pidArg);
					}
					// do we have a match in the booln value?
					else
					{
						ASSERT(patArgValue == booln);
						fAbort = (bVal != (*pchArgValue == _T('T') || *pchArgValue == _T('t')));
					}

					if (fAbort)	return FALSE;	// no generate, failed to generate booln value
					break;
				}

				case ::string:
				{
					// anti-options can only be used for string lists
					if (!m_fMultipleGen && (m_optbeh & OBAnti))
						return FALSE;

					CString	strVal;

					// generate this string value (quoted)
					// if we are a multiple option attempt to pluck out the arg. in the
					// comma sep. list we want
					if (m_fMultipleGen)
					{
						CPropBag * pBag = m_pSlob->GetPropBag();
						BOOL fUseCache =
							(
							 // same property bag?
							 pBag == m_pBagCache &&

							 // same multiple prop. for this property bag?
							 idArgProp == m_idArgPropCache &&

							 // subsequent iteration?
							 m_iGenIteration >= m_iGenIterationCache &&

							 // same option behaviour?
							 m_optbeh == m_optbehCache
						    );

						if (!fUseCache)
						{
							CString str;

							// get the property
							// can't generate invalid props!

							// set to retrieve subtract if anti-option
							BOOL fPropAntiOld = ((CProjItem *)m_pSlob)->EnableAntiProps(m_optbeh & OBAnti);

							// get the property
							BOOL fValid = m_pSlob->GetStrProp(idArgProp, str) == valid;
							
							(void) ((CProjItem *)m_pSlob)->EnableAntiProps(fPropAntiOld);

							if (!fValid) return FALSE;

							m_optlstCache.SetString(str);
							m_pBagCache = pBag;
							m_posCache = m_optlstCache.GetHeadPosition();
							m_iGenIterationCache = 0;
							m_idArgPropCache = idArgProp;
							m_optbehCache = m_optbeh;
						}

						if (m_posCache == (POSITION)NULL)
						{
							m_fStopMultipleGen = TRUE;
							return (m_iGenIteration != 0);	// can't generate this iteration
						}

						do					
						{
							strVal = m_optlstCache.GetNext(m_posCache);
						}
						while (m_posCache != (POSITION)NULL && m_iGenIteration != m_iGenIterationCache++);

  						if (m_posCache == (POSITION)NULL && m_iGenIteration != m_iGenIterationCache)
						{
							m_fStopMultipleGen = TRUE;
							return TRUE;	// can't generate this iteration
						}
																											
 						m_fGenUsedProps = TRUE;	// used a property!
						fAlwaysShowDefault = FALSE;	// no defaults for option lists
					}
					else
					{
						// want to show the option defaults when generating an option string?
						BOOL fPropDefaultOld = ((CProjItem *)m_pSlob)->UseOptionDefaults(m_fUseDefault || fAlwaysShowDefault);

						// get the property
						// can't generate invalid props!
						BOOL fValid = m_pSlob->GetStrProp(idArgProp, strVal) == valid;

						(void) ((CProjItem *)m_pSlob)->UseOptionDefaults(fPropDefaultOld);

						if (!fValid) return FALSE;
					}

					// gen. used a prop.!
					m_fGenUsedProps = TRUE;

					// is this a default or, in the case of strings, empty?
					if (strVal.IsEmpty() && !(m_optbeh & OBNeedEmptyString))
						return FALSE;	// don't generate empty strings

					AdjustBuffer(strOptionBit);

					// don't bother doing this for multiple string lists!
					if (!m_fMultipleGen)
					{
						BOOL fIgnore;

						if (fFake)
							fIgnore = fAlwaysShowDefault || (m_optbeh & OBShowFake);
						else
							fIgnore = fAlwaysShowDefault || (m_optbeh & OBShowDefault);

						if (!fIgnore && m_popthdlr->IsDefaultStringProp(idArgProp, strVal))
							return FALSE;	// don't generate the default

#if 0
						// we want to make sure that we don't get 
						// 'foobar\"', this needs to be 'foobar\\"'
						int cch = strVal.GetLength();
						if (cch != 0)	// don't bother with empty ""
						{
							// check for a single '\' at the end of the string
							const TCHAR * pc = (const TCHAR *)strVal + cch;
							pc = _tcsdec((const TCHAR *)strVal, (TCHAR *)pc);
							if (pc && *pc == _T('\\'))
							{
								pc = _tcsdec((const TCHAR *)strVal, (TCHAR *)pc);
								if (!pc || *pc != _T('\\'))
									strVal += _T('\\');	// need an extra
							}
						}
#endif
					}
 
					// only do the check for $(INTDIR) and $(OUTDIR) on 
					// string props with subtype 'pathST' or 'dirST'
					SUBTYPE st = m_popthdlr->GetDefOptionSubType(idArgProp);

					BOOL fQuote = TRUE;

					// path or dir subtype ('pathST')
					if (st == pathST || st == dirST)
					{
						// possibility of a macro of form '$(MACRO)' in this?
						if ((m_optbeh & OBShowMacro) != 0)
						{
							// got the '$(MACRO)'?
							if (strVal[0] == _T('$') && strVal[1] == _T('('))
							{
								// we have a macro
								// it doesn't matter if we quote this, 
								// nmake will expand the macro
							}	
							else
							// check for a path that we can place a macro in..
							{
								// property of output directory we may want to convert to a macro
								UINT idProp;

								// uses output directory?
								if ((idProp = m_popthdlr->GetFakePathDirProp(idArgProp)) != (UINT)-1)
								{
									CString strMacro, strValue;
									if (((CProjItem *)m_pSlob)->GetOutDirString(strMacro, idProp, &strValue, TRUE, TRUE))
									{
										// get the output and project's directories
										CPath pathOutput;
										CDir dirOutput, dirProj = ((CProjItem *)m_pSlob)->GetProject()->GetWorkspaceDir();

										// convert our targ value into a file
										strValue += _TEXT("\\x");

										if (pathOutput.CreateFromDirAndFilename((const CDir &)dirProj, strValue) &&
											dirOutput.CreateFromPath(pathOutput))
										{
											CPath path;
											CString strPath = strVal;	// temp. path (used as path storage initially)

											TCHAR * pch = (TCHAR *)(const TCHAR *)strPath;
											pch = _tcsdec(pch, pch + _tcslen(pch));

											BOOL fDir;
											if (fDir = (*pch == _T('\\') || *pch == _T('/')))
												strPath += _TEXT("x");	// strip 'bogus' filename later

											// need to append a '/x'?
											if (!fDir && st == dirST)
												strPath += _TEXT("/x");	// strip 'bogus filename later

												// use the target's working directory
											if (path.CreateFromDirAndFilename((const CDir &)dirProj, strPath) &&
												// try to relativize it
												path.GetRelativeName(dirOutput, strPath, FALSE, TRUE) &&
												// == _T('.') if was made *subdir* relative to output directory
												strPath[0] == _T('.'))
											{
												// skip '.'s and replace '\' with '/'
												int nDots = 1;	// at least one
												if (strPath[1] == _T('.'))
													nDots++;

												// strip out the 'bogus' filename?
												if (fDir)
												{
													int iNewLen = strPath.GetLength() - 1;
													TCHAR * pch = strPath.GetBufferSetLength(iNewLen);
													strPath.ReleaseBuffer(iNewLen);
												}

												// construct our new value
												strVal = strMacro;
												strVal += _T('\\');

												// automatically quoted (see below, fQuote == TRUE)
												// (skip over the '.'s and '\'
												strVal += ((const TCHAR *)strPath + nDots + 1);
											}
										}
									}
								}
							}
						}
					}
					else
					{
						// not a directory or a filename
						// don't quote an assignment, ie. we want to keep
						// a option of the form /D WIN32=1 or /D SZTITLE="Foo Bar"
						fQuote = strVal.Find(_T('=')) == -1;
					}

					// don't bother doing this for multiple string lists!
					if (!m_fMultipleGen)
					{
						// we want to make sure that we don't get 
						// 'foobar\"', this needs to be 'foobar\\"'
						int cch = strVal.GetLength();
						if (cch != 0)	// don't bother with empty ""
						{
							// check for a single '\' at the end of the string
							const TCHAR * pc = (const TCHAR *)strVal + cch;
							pc = _tcsdec((const TCHAR *)strVal, (TCHAR *)pc);
							if (pc && *pc == _T('\\'))
							{
								pc = _tcsdec((const TCHAR *)strVal, (TCHAR *)pc);
								if (!pc || *pc != _T('\\'))
									strVal += _T('\\');	// need an extra
							}
						}
					}
 
					// prepend the '"' (if needed) before the string
					// ie. "foo"
					if (fQuote)	strOptionBit += _T('"'); 
					strOptionBit += strVal;
					if (fQuote)
					{
						BOOL bAddBackSlash = FALSE;
						LPCTSTR pchStart = strOptionBit;
						int length = _tcslen(pchStart);

						//
						// Already added quote.
						//
						ASSERT(0!=length);

						//
						// If last char is backslash and 2nd to last is not backslash,
						// append an extra backslash before quote.
						//
						// review(tomse): We are in trouble if user 
						// adds more multiple trailing backslashes.
						TCHAR* pchLast = _tcsdec(pchStart,pchStart+length);
						if (_T('\\')==*pchLast)
						{
							ASSERT(1<length);
							bAddBackSlash = _T('\\')!=*_tcsdec(pchStart,pchLast);
						}

						if (bAddBackSlash)
							strOptionBit += _T('\\');
						strOptionBit += _T('"');
					}
					break;
				}

				case ::longint:	// not yet needed!
				case ::number:
					break;

				default:
					ASSERT(FALSE);
					break;
			}
		}
		// do we have an open bracket (optional part?)
		else if (chExpr == _T('['))
		{
			char * pchPart;
			UINT cchPart;

			// extract the optional part
			ExtractPart(pchExpr, cchExpr, pchPart, cchPart);

			UINT	cch = strOptionBit.GetLength();

			// ignore if any option part used props
			// and it failed
			BOOL fOldGenUsedProps = m_fGenUsedProps;
			if (!GenerateExpression(strOptionBit, pchPart, cchPart, pidArg))
			{
				// back-out our we had props flag
				m_fGenUsedProps = fOldGenUsedProps;
				// back-out the optional part strOptionBit changes
				strOptionBit.ReleaseBuffer(cch);
				// continue, this was optional!
			}
		}
		// else just put this into the option bit
		else
		{		
			AdjustBuffer(strOptionBit);
			strOptionBit += chExpr;

			cch = _tclen(pchExpr);
			pchExpr += cch; cchExpr -= cch;
		}

		// continue trying to generate this option
	}

	return TRUE;	// successful generation
}

BOOL COptionTable::MatchOption(COptStr * poptstr)
{
	BOOL	fMatched;

	// what type of option it this? single or multiple?
 	m_fMultipleGen = (poptstr->type == multiple);

	// can we match this expression?
	fMatched = MatchExpression(poptstr->szOption, _tcslen(poptstr->szOption), poptstr->rgidArg);

	// must terminate in a whitespace or EOS
	unsigned char	chTerm = NewGetAt(strSrc, ichSrc + cchAdvSrc);

	fMatched = fMatched && (chTerm == _T('\0') || _istspace(chTerm));
	
	if (fMatched)	
		// yes, so set up these properties in our bag
		SetPropValListInPropBag(poptstr->rgidArg);

	// clear our property-value list (may be empty)
	ClearPropValList();

	return fMatched;
}

BOOL COptionTable::GenerateOption
(
	CString & strOption,
	COptStr * poptstr,
	CString & strPrefix,
	BOOL fAddTrailSpace
)
{
	CString	strOptionBit;
	BOOL	fGenerated, fContinue;

	// this will be our first generation iteraton
	m_iGenIteration = 0;

	// what type of option it this? single or multiple?
	m_fMultipleGen = (poptstr->type == multiple);
	m_fStopMultipleGen = FALSE;	// not stop multiple (for singles never changed)

	// do the generation until we need to stop
	do
	{
		// make sure we clear our option bit before generating into it!
		strOptionBit = "";

		// init. whether this gen had props used in the generation
		m_fGenUsedProps = FALSE;
		fGenerated = GenerateExpression(strOptionBit,
										poptstr->szOption,
										_tcslen(poptstr->szOption),
										poptstr->rgidArg);

		// are we in anti-options and have we generated one?
		// if so try to generate the 'regular' equivalent
		// don't do this for multiple options
		if ((m_optbeh & OBAnti) && !m_fMultipleGen && 
			fGenerated && !strOptionBit.IsEmpty())
		{
			CString strRegOptionBit;
			BOOL fAntiHasRegularRep = FALSE;

			// temp. turn off (ie. regular options)
			m_optbeh &= ~OBAnti;

			// generate the 'regular' equivalent
			fAntiHasRegularRep = GenerateExpression(strRegOptionBit,
												    poptstr->szOption,
								   				    _tcslen(poptstr->szOption),
								   				    poptstr->rgidArg) &&
								 !strRegOptionBit.IsEmpty();

			// turn back on again (ie. anti options)
			m_optbeh |= OBAnti;

			// if the regular representation exists ignore this
			if (fAntiHasRegularRep)	return TRUE;	// no error, just no generate
		}


		// did we generate this?
		if (fContinue = fGenerated && !m_fStopMultipleGen && !strOptionBit.IsEmpty())
		{
			AdjustBuffer(strOption);

			// append the requested prefix, eg. '/' or ', and /'
			strOption += strPrefix;

			// append this option bit to our current option
			strOption += strOptionBit;

			// place a trailing space if requested
			if (fAddTrailSpace)
				strOption += _T(' ');

			// next invocation
			m_iGenIteration++;
 		}
	}
	while (m_fMultipleGen && fContinue);

	return fGenerated;	// success or failure?
}

void COptionTable::ClearPropVal(UINT *poptarg)
{
	CPropBag * 	ppropbag = m_pSlob->GetPropBag();

	for (WORD cArgs = 0; cArgs < MAX_OPT_ARGS; cArgs++, poptarg++)
	{
		// do we need to remove this prop?
		if (*poptarg != (UINT)-1)
		{
			if (m_popthdlr->IsListStrProp(*poptarg))
			{
				BOOL fExists = FALSE;

				// delete add/subtract prop from the current property bag (if they exist)
			 	if (ppropbag->FindProp(ListStr_AddPart(*poptarg)) != (CProp *)NULL)
				{
					ppropbag->RemoveProp(ListStr_AddPart(*poptarg));
					ppropbag->RemoveProp(ListStr_SubPart(*poptarg));
					// inform of this prop change (update option view?)
					m_pSlob->InformDependants(*poptarg);
				}
			}
		 	else
		 	{
				// delete this from the current property bag (if it exists)
				ppropbag->RemovePropAndInform(*poptarg, m_pSlob);
		 	}
		}
	}
}

void COptionTable::ClearPropValList(BOOL fOnlyThoseChanged)
{
	for (WORD cArgs = 0 ; cArgs < MAX_OPT_ARGS ; cArgs++)
		if (m_rgProps[cArgs].idArg != (UINT)-1 && 
		    (!fOnlyThoseChanged || m_rgProps[cArgs].fChanged)
		   )
		{
			if (m_rgProps[cArgs].pProp)
				CProp::DeleteCProp(m_rgProps[cArgs].pProp);
			m_rgProps[cArgs].idArg = (UINT)-1;
		}
}

void COptionTable::SetPropValListInPropBag(UINT * poptarg)
{
	CPropBag * 	ppropbag = m_pSlob->GetPropBag();
	CProp * ppropExisting; 

	for (WORD cArgs = 0; cArgs < MAX_OPT_ARGS ; cArgs++, poptarg++)
	{
		UINT	idArg = m_rgProps[cArgs].idArg;
		BOOL	fExists = (ppropExisting = ppropbag->FindProp(*poptarg)) != (CProp *)NULL;

		// has this arg. been set?
		if (idArg == (UINT)-1)
		{
			UINT	idOptArg = *poptarg;

			// should we clear the arg? we need to do this for args that exist for the option
			// but which have not been set
			if (idOptArg != (UINT)-1)
			{
				// yes, clear it, but for multiple options just append an empty prop. value
				if (m_fMultipleGen)
				{
					// get the prop value
					CString	strVal;

					// set to retrieve subtract if anti-option
					BOOL fPropAntiOld = ((CProjItem *)m_pSlob)->EnableAntiProps(m_optbeh & OBAnti);

					// get the existing comma sep. list of args if *we* have one
					// ie. we only want to do this for *our* propbag (not the parents)
					if (ppropbag->FindProp(ListStr_AddPart(idOptArg)) ||
						ppropbag->FindProp(ListStr_SubPart(idOptArg)))
					{
						(void) m_pSlob->GetStrProp(idOptArg, strVal);

						// append a sep
						strVal += _T(',');
					}

					// append a comma sep
					m_pSlob->SetStrProp(idOptArg, strVal); 

					(void) ((CProjItem *)m_pSlob)->EnableAntiProps(fPropAntiOld);
				}
				// remove this prop if we have one
				else if (fExists)
				{
					// delete this from the current property bag (it exists!)
					ppropbag->RemovePropAndInform(idOptArg, m_pSlob);
				}
			}

			continue;
		}

		CProp *	pprop = m_rgProps[cArgs].pProp;

		// if we have NULL here then ignore
		// we want to use the previous existing value (if one exists)
		if (pprop == (CProp *)NULL)
			continue;

		// dirty this prop we are about to set

		// for string list props we need to delete the components
		// *not* the pseudo prop
		if (m_fMultipleGen && m_popthdlr->IsListStrProp(idArg))
		{
			m_popthdlr->DirtyArg(ListStr_AddPart(idArg) - m_nPropMin);
			m_popthdlr->DirtyArg(ListStr_SubPart(idArg) - m_nPropMin);
		}
		else
		{
			m_popthdlr->DirtyArg(idArg - m_nPropMin);
		}

		// what is the property type?
		// don't set property values if current property has this value!
		switch (pprop->m_nType /* property type */)
		{	
			case ::integer:
				ASSERT(!m_fMultipleGen);	// only for single options
				if (!fExists ||
					(((CIntProp *)pprop)->m_nVal != ((CIntProp *)ppropExisting)->m_nVal)
				   )
				{
					m_pSlob->SetIntProp(idArg, ((CIntProp *)pprop)->m_nVal); 
				}
				break;

			case ::booln:
				ASSERT(!m_fMultipleGen);	// only for single options
				if (!fExists ||
					(((CBoolProp *)pprop)->m_bVal != ((CBoolProp *)ppropExisting)->m_bVal)
				   )
				{
					m_pSlob->SetIntProp(idArg, ((CBoolProp *)pprop)->m_bVal); 
				}
				break;

			case ::string:
			{
				// if we are a multiple option, append using comma seps.
				if (m_fMultipleGen)
				{	
					// the option sep. list
					CString	strVal;

					// set to retrieve subtract if anti-option
					BOOL fPropAntiOld = ((CProjItem *)m_pSlob)->EnableAntiProps(m_optbeh & OBAnti);

					// get the existing comma sep. list of args if *we* have one
					// and append to that
					if (m_pSlob->GetStrProp(idArg, strVal) == valid)
					{
						if (!strVal.IsEmpty())
							strVal += _T(',');
						strVal += ((CStringProp *)pprop)->m_strVal;

						m_pSlob->SetStrProp(idArg, strVal); 
					}

					(void) ((CProjItem *)m_pSlob)->EnableAntiProps(fPropAntiOld);
				}
				else
				{
					// anti-option only for multiple string lists
					if (m_optbeh & OBAnti)
						break;

					if (!fExists ||
						(((CStringProp *)pprop)->m_strVal != ((CStringProp *)ppropExisting)->m_strVal)
					   )
					{
						m_pSlob->SetStrProp(idArg, ((CStringProp *)pprop)->m_strVal); 
					}
				}

				break;
			}

			case ::longint:	// not yet needed!
			case ::number:
				break;

			default:
				ASSERT(FALSE);
				break;
		} 
	}
}

int COptionTable::GenerateHashValue (CString & str)
{
	UINT uHashValue = 0;

	for (int i = 0; i < str.GetLength(); i++)
		uHashValue += (UINT) i ^ (UINT)str[i];
	return (int) uHashValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\prjoptn.h ===
//
// COptionTable
//
// Option parsing and re-generation using property bag values.
//
// [matthewt]
//				   

#ifndef _INCLUDE_OPTIONTBL_H										
#define _INCLUDE_OPTIONTBL_H   

#ifndef _SUSHI_PROJECT
// If you are including this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

#include "slob.h"		// CSlob and CPropBag def'n
#include "projprop.h"	// tool option prop. range #defs
#include "projitem.h"	// our CProjItem ::GetStrProp, ::GetIntProp stuff

// Each node in the option dialog tree
// is a pair of project item and configuration that item is in.
// Using the information in this node we'll be able to 
// retrieve prop values from the project item for the particular
// configuration 'tree' that node belongs to.
class OptTreeNode
{
public:
	OptTreeNode();
	OptTreeNode(OptTreeNode * pParentNode, CProjItem * pItem);
	~OptTreeNode();

	// construct an option tree node

	// get the project type of this node
	CProjType * GetProjType();

	// get the tools applicable to this node
	void GetViableBuildTools(CPtrList & listTools);

	// property management across multiple OptTreeNodes
	// make sure the property get/set follows the correct behaviour
	BOOL SetIntProp(UINT idProp, int val, OptBehaviour optbeh);
	BOOL SetStrProp(UINT idProp, const CString& val, OptBehaviour optbeh);
	GPT GetStrProp(UINT idProp, CString& val, OptBehaviour optbeh);
	GPT GetIntProp(UINT idProp, int& val, OptBehaviour optbeh);

	// get our property bag
	CPropBag *GetPropBag(int nBag = -1);

	inline BOOL IsValid() { void * pVoid; return m_ValidPcrMap.Lookup((void *)pcr->m_pBaseRecord, pVoid ); }
	inline void SetValid() { m_ValidPcrMap.SetAt((void *)pcr->m_pBaseRecord, NULL); }
	static void SetValidConfig(ConfigurationRecord * pconfig) { m_ValidPcrMap.SetAt((void *)pconfig->m_pBaseRecord, NULL); }

	static BOOL IsValidConfig(ConfigurationRecord * pconfig) { void * pVoid; return m_ValidPcrMap.Lookup((void *)pconfig->m_pBaseRecord, pVoid); }
	static void ResetValidConfigMap() { m_ValidPcrMap.RemoveAll(); }

	// our public data
	CProjItem * pItem;			// our project item
	ConfigurationRecord * pcr;	// our configuration for this item

	// our parent
	OptTreeNode * pContainerNode;

	// our content
	CPtrList m_Content;
	BOOL m_fValidContent;
private:
	static CMapPtrToPtr m_ValidPcrMap;
};

class OptTreeNodeList : public CPtrList
{
	DECLARE_DYNAMIC(OptTreeNodeList);
	OptTreeNodeList() { }
	~OptTreeNodeList();
	CProjType * GetProjType();
	OptTreeNode * GetHead() { return (OptTreeNode *) CPtrList::GetHead(); }
	OptTreeNode * GetNext(POSITION & pos) { return (OptTreeNode *) CPtrList::GetNext(pos); }
	OptTreeNode * GetFirstValidNode();

	// property management across multiple OptTreeNodes
	BOOL SetIntProp(UINT idProp, int val, OptBehaviour optbeh);
	BOOL SetStrProp(UINT idProp, const CString& val, OptBehaviour optbeh);

	// our public data
	CProjItem * GetItem() { return IsEmpty() ? NULL : GetHead()->pItem; }
	BOOL IsValidContent() { return IsEmpty() ? NULL : GetHead()->m_fValidContent; }
	CPtrList * GetContent() { return IsEmpty() ? NULL : &(GetHead()->m_Content); }
	void RemoveContent();

	OptTreeNodeList * AddDependentList();
	OptTreeNodeList * GetDependentList(const CProjItem * pItem);
private:
	CPtrList m_lstDeps;
};

class COptionHandler;
class BLD_IFACE CProxySlob : public CProjItem
{
	DECLARE_DYNAMIC(CProxySlob);

public:
	CProxySlob();
	virtual ~CProxySlob();

	// IsSortOf support for multiple selection
	// Returns FALSE if not all items in the selection match
	// the class.
	BOOL IsSortOf(const CRuntimeClass* pClass);

	// Enumeration of the platforms for the current selection (can return duplicates)
	__inline void InitPlatformEnum() {m_posList = m_ptrList.GetHeadPosition();}
	const CPlatform * NextPlatform();

	// Get the 'common' project type for the current selection (if one exists)
	CProjType * GetProjType();

	// General enumeration of nodes
	__inline POSITION GetHeadPosition() {return m_ptrList.GetHeadPosition();}
	__inline OptTreeNode * GetNext(POSITION & pos) {return (OptTreeNode *)m_ptrList.GetNext(pos);}

	// Returns configuration of the selection, or NULL
	// if there are nodes for multiple configurations.
	const ConfigurationRecord * GetBaseConfig();

	// OptTreeNode list management
	// selection of OptTreeNodes we are in communicado with
	// (fInform == FALSE will not generate an ::OnInform for the item
	//  , this can be used to reduce the # of informs sent out)
	void Clear(BOOL fInform = TRUE);
	void Add(OptTreeNode * pNode, BOOL fInform = TRUE);
	void Remove(OptTreeNode * pNode, BOOL fInform = TRUE);									   
	__inline void Single(OptTreeNode * pNode, BOOL fInform = TRUE) {Clear(FALSE); Add(pNode, fInform);}
	__inline BOOL IsSingle() {return m_ptrList.GetCount() == 1;}
	__inline OptTreeNode * GetSingle() {ASSERT(IsSingle()); return (OptTreeNode *)m_ptrList.GetHead();}
	__inline int GetCount() {return m_ptrList.GetCount();}
	
	// selected in this proxy slob?
	BOOL Selected(OptTreeNode * pNode);
	BOOL Selected(CSlob * pSlob, ConfigurationRecord * pcr);
 
	// make sure our containment is correct
	__inline void FixContainment()
		{m_pContainer = (m_pParentProxySlob && m_pParentProxySlob->m_ptrList.IsEmpty())
																? (CSlob *)NULL : m_pParentProxySlob;}

	// set the *primary* option handler, ie. the one the multiple selection is 
	// using right now to modify tool options
	__inline void SetOptionHandler(COptionHandler * popthdlr)
		{m_popthdlr = popthdlr; if (m_pParentProxySlob) m_pParentProxySlob->SetOptionHandler(popthdlr);}

	// property management across multiple OptTreeNodes
	BOOL SetIntProp(UINT idProp, int val);
	BOOL SetStrProp(UINT idProp, const CString& val);
	GPT GetStrProp(UINT idProp, CString& val);
	GPT GetIntProp(UINT idProp, int& val);

	// FUTURE: not yet implemented
	BOOL SetDoubleProp(UINT idProp, double val)			{ASSERT(FALSE);return FALSE;}
	BOOL SetLongProp(UINT idProp, long val)				{ASSERT(FALSE);return FALSE;}
	BOOL SetSlobProp(UINT idProp, CSlob* val)			{ASSERT(FALSE);return FALSE;}
	BOOL SetRectProp(UINT idProp, const CRect& val)		{ASSERT(FALSE);return FALSE;}
	BOOL SetPointProp(UINT idProp, const CPoint& val)	{ASSERT(FALSE);return FALSE;}
	GPT GetDoubleProp(UINT idProp, double& val)			{ASSERT(FALSE);return invalid;}
	GPT GetLongProp(UINT idProp, long& val)				{ASSERT(FALSE);return invalid;}
	GPT GetSlobProp(UINT idProp, CSlob*& val)			{ASSERT(FALSE);return invalid;}
	GPT GetRectProp(UINT idProp, CRect& val)			{ASSERT(FALSE);return invalid;}
	GPT GetPointProp(UINT idProp, CPoint& val)			{ASSERT(FALSE);return invalid;}
	
	// this is just our container!
	__inline CSlob * GetContainerInSameConfig() {return GetContainer();}

	// propagate informs
	virtual void OnInform(CSlob* pChangedSlob, UINT idChange, DWORD dwHint);

	// FUTURE: how to deal with the project option engine
	// requesting a CPropBag* when the CProxySlob has multiple selection?
	// Enumerate?
	CPropBag *GetPropBag(int nBag = -1);

	// our list of OptTreeNodes
	CPtrList m_ptrList;

private:
	CProxySlob * m_pParentProxySlob;
	CProxySlob * m_pChildProxySlob;
	POSITION m_posList;
	COptionHandler * m_popthdlr;
};

// highly efficient manipulation of option string lists
// o uses map for quick check to see if exists
// o uses low-level mem. copy and compare.
// o CProjItem string list prop. aware

// are we the add or subtract component of a pseudo string list prop?
#define ListStr_AddPart(prop) (prop + 1)
#define ListStr_SubPart(prop) (prop + 2)

// NOTE: no duplicates are allowed in the option list

typedef struct tagOptEl {
	BYTE cref;		// ref. count
	int cch;		// # of chars. in pch (incl. '\0')
	TCHAR pch[1];	// space for single terminator
} OptEl;

class BLD_IFACE COptionList : public CObject
{
public:
	// ConstrucTORs
	COptionList(TCHAR chJoin = _T(','), BOOL fUseDefJoins = TRUE, BOOL fAllowDupes = FALSE)
		{m_cchStr = 0;m_bAllowDuplicates = fAllowDupes; SetJoinUsage(chJoin, fUseDefJoins);}

	COptionList(const TCHAR * pch, TCHAR chJoin = _T(','), BOOL fUseDefJoins = TRUE, BOOL fAllowDupes = FALSE)
		{m_cchStr = 0;m_bAllowDuplicates = fAllowDupes; SetJoinUsage(chJoin, fUseDefJoins); SetString(pch);}

	__inline void SetJoinUsage(TCHAR chJoin = _T(','), BOOL fUseDefJoins = TRUE)
		{m_strJoin = (CString)chJoin + (fUseDefJoins ? _TEXT(",;\t") : _TEXT(""));}

	// DestrucTOR
	virtual ~COptionList()
		{Empty();}

	void Empty();										// empty
	void GetString(CString & str);						// conversion
	void SetString(const TCHAR * pch);					// conversion
	__inline const COptionList & operator=(COptionList & optlst)
		{Empty(); Append(optlst); return *this;}		// assignment
	void Append(const TCHAR * pch, int cch);			// element append
	void Append(COptionList & optlst);					// list append
	BOOL Subtract(const TCHAR * pch);					// element subtraction (returns FALSE if it didn't exist)
	BOOL Subtract(COptionList & optlst);				// list subtraction (returns FALSE if none existed)
	void Common(COptionList & optlst);					// retrieve common part
	__inline BOOL Exists(const TCHAR * pch)				// existance?
		{POSITION posOurWord; return m_bAllowDuplicates? FALSE : m_mapStrToPtr.Lookup(pch, (void *&)posOurWord);}

	// enumeration
	__inline POSITION GetHeadPosition()
		{return m_lstStr.GetHeadPosition();}
	__inline TCHAR * GetNext(POSITION & pos)
		{return ((OptEl *)m_lstStr.GetNext(pos))->pch;}
	__inline int GetCount()
		{return m_lstStr.GetCount();}

	// form the component parts from 'pch' based on 'this'.
	void Components(const TCHAR * pch, COptionList & optlstAdd, COptionList &optlstSub);

protected:
	// addition/deletion of elements using ref. counting
	void Add(OptEl * poptel);
	BOOL Delete(OptEl * poptel, POSITION posToDelete = (POSITION)NULL);	// if POSITION known pls. use

	CString m_strJoin;				// our join chars
	CMapStringToPtr	m_mapStrToPtr;	// our hash lookup
	CPtrList m_lstStr;				// our actual list
	int m_cchStr;					// total length of string (bytes, incl. join char. seps.)
	BOOL m_bAllowDuplicates;
};

// some static buffer sizes
#define MAX_OPT_ARGS	3		// max. of two args. per option

// special IDOPTs that refer to the collection of unknown options
// and unknown strings repsectively, these may be placed in the
// option table 
// these are reserved, start your own IDOPTs from IDOPT_BASE
#define IDOPT_UNKNOWN_OPTION		(UINT)0
#define IDOPT_UNKNOWN_STRING		(UINT)1
#define IDOPT_DERIVED_OPTHDLR		(UINT)2
#define IDOPT_BASE					(UINT)3

// our tool option tables
#define OPTION_HANDLER(tool) COptHdlr##tool

// I'd like to allocate chunks of memory to CString's internal buffer so that
// a character append will be inexpensive (the generation of an option string does
// this a lot!).
#define OPTSTR_ALLOC_CHUNK	64	// 64 bytes at a time (N.B. must be a power of 2)
#define OPTSTR_ALLOC_EXPON	6	// 64 == 2 ^ 6

__inline void AdjustBuffer(CString & str)
{
	register unsigned int cch = (unsigned int)str.GetLength(); // # chars (will be zero, for initial alloc.)
	
	// are we at a length boundary?
	if ((cch & (OPTSTR_ALLOC_CHUNK-1)) == 0)	// check for no remainder .. can do logical AND if power of 2
	{
		// allocate a new chunk
		(void) str.GetBuffer((int)OPTSTR_ALLOC_CHUNK * ((cch >> OPTSTR_ALLOC_EXPON) + 1));	// set buffer length
		(void) str.ReleaseBuffer(cch);				// set data length, and terminate
	}
}
 
// what type is the option?
typedef enum {single, multiple} OptType;

// what sub-type is the option prop?
typedef enum {boolST, intST, hexST, octST, strST, pathST, dirST} SUBTYPE;

class CDefOptionProp : public CObject
{
public:
	CDefOptionProp() { m_pprop = NULL; }
	~CDefOptionProp() { if (m_pprop != NULL) CProp::DeleteCProp(m_pprop); }

	CDefOptionProp(WORD idProp, int n, SUBTYPE st = intST, OptType ot = single)
	{
		m_pprop = (st == boolST) ? (CProp *) new CBoolProp(n) : (CProp *) new CIntProp(n);
		subtypeprop = st;
		m_opttype = ot;
	}

	CDefOptionProp(WORD idProp, const char * sz, SUBTYPE st = strST, OptType ot = single)
	{
		m_pprop = (CProp *) new CStringProp(sz);
		subtypeprop = st;
		m_opttype = ot;
	} 

	CProp *	m_pprop;
	OptType m_opttype;
	SUBTYPE subtypeprop;
};

// our def'n of an option
struct COptStr
{
	UINT			idOption;
	const char *	szOption;
	UINT			rgidArg[MAX_OPT_ARGS];
	OptType			type;
};

// definition of the COptionLookup class
class BLD_IFACE COptionLookup : public CObject
{
public:
	~COptionLookup();

	// perform init. now
	BOOL FInit(COptStr *);

	// lookup the option based on ID
	__inline COptStr * Lookup(UINT nID);

	// lookup the option based on first char.
	__inline COptStr * LookupFirst(unsigned char ch, BOOL fCaseSensitive = TRUE);
	__inline COptStr * LookupNext(int cchLead);

private:
	// used for lookup 'based on ID'
	UINT		m_idLowest;
	CPtrArray	m_ptrIDArray;

	// used for lookup 'based on first char.
	unsigned char	m_chLookup;
	UINT			m_ioptstr;
	CPtrArray		m_ptrChArray;
	CMapWordToPtr	m_mapChToPtr;

};

// used to optimize lookups for parsing and generation

typedef struct {
	COptStr *	poptstr;
	UINT		ioptstr;
} CLookupEntry;

// I'd like GetAt to return the zero terminator if the index
// is >= GetLength()!
#define NewGetAt(str, ich) ((ich) >= str.GetLength() ? '\0' : str.GetAt((ich)))

// convertion of depth based ids
#define OHStripDepth(x) ((x) & 0x0fff)
#define OHAddDepth(x, d) ((x) | (0x1000 * (d)))
#define OHGetDepth(x) (((x) & 0xf000) / 0x1000)

#define _MAX_SLOB_STACK	5

class COptionPage;
class COptionPageTab;
class BLD_IFACE COptionHandler : public CBldSysCmp
{
	DECLARE_DYNAMIC(COptionHandler);

public:
	COptionHandler(CBuildTool * pBuildTool, COptionHandler * popthdlrBase = (COptionHandler *)NULL);
	COptionHandler(const TCHAR * szPkg, WORD id,
				   const TCHAR * szPkgTool, WORD idTool,
				   const TCHAR * szPkgBase, WORD idBase);
	~COptionHandler();

	// called by ctor, dtors of derived classes
	virtual BOOL Initialise();

	// create our default option map
	virtual void CreateOptDefMap() {}

	// retrieve our 'special' option props, ie. the unknown strins and options prop IDs (logical)
	virtual void GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh = OBNone) {ASSERT(FALSE);}

	// retrieive our min. and max. option prop IDs (logical)
	virtual void GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp) {ASSERT(FALSE);}

	// retrieve our 'special' option props, ie. the unknown strins and options prop IDs (actual)
	void GetSpecialOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour optbeh = OBNone);

	// case sensitive option string table?
	virtual const BOOL IsCaseSensitive() {ASSERT(FALSE); return TRUE;}

	// what CSlob do we (and all of our base option handlers) refer to ?
 	__inline void SetSlob(CSlob * pSlob, BOOL fRemember = TRUE)
	{
		COptionHandler * popthdlr = GetBaseOptionHandler();
		if (popthdlr != NULL)
			popthdlr->SetSlob(pSlob, fRemember);

		// fRemember if TRUE pushes old onto stack
		if (fRemember)
			m_stkOldSlobs[m_sStk++] = m_pSlob;

		ASSERT(m_sStk <= 5);
		m_pSlob = pSlob;
	}

	__inline void ResetSlob()
	{
		COptionHandler * popthdlr = GetBaseOptionHandler();
		if (popthdlr != NULL)
			popthdlr->ResetSlob();

		// make sure the SetSlob & ResetSlob calls are matched
		ASSERT(m_sStk > 0);
		m_pSlob = m_stkOldSlobs[--m_sStk];
	}
	
	// retrieve our base option handler (if we have one, by default we don't)
	__inline COptionHandler * GetBaseOptionHandler()	{return m_popthdlrBase;}

	// retrieve our root option handler
	__inline COptionHandler * GetRootOptionHandler()
	{
		COptionHandler * popthdlr = GetBaseOptionHandler();
		if (popthdlr == (COptionHandler *)NULL)
			return this;	// we are the root!
		return popthdlr->GetRootOptionHandler();
	}

	// retrieve our option string table
	virtual COptStr * GetOptionStringTable()	{ASSERT(FALSE);return (COptStr *)NULL;}

	// get our option lookup
	virtual COptionLookup * GetOptionLookup()	{ASSERT(FALSE);return (COptionLookup *)NULL;}

	// Do we have any properties in the slob:
	BOOL HasAnyOfOurProperties(CProjItem *pProjItem, BOOL bCheckFakeProps = FALSE);

	// Are all our properties the same between configs?
	BOOL HasPerConfigProperties(CProjItem *pProjItem, BOOL bCheckBase = TRUE);

	// get our string resource id (name)
	virtual UINT GetNameID();

	// our option pages, first one should be a general page
	// set 'fUseBasePages' to FALSE if you don't want any pages for 'base'
	// option handlers to be shown
	virtual CRuntimeClass * * GetOptionPages(BOOL & fUseBasePages) {return (CRuntimeClass * *)NULL;}

	// reset our current props from the base props
	virtual void ResetPropsForConfig(ConfigurationRecord * pcr);
	// is there a need to do this reset? (TRUE -> yes)
 	virtual BOOL CanResetPropsForConfig(ConfigurationRecord * pcr);

	// set out 'base' prop value
	__inline void SetOptPropBase(UINT nPropBase) {m_nPropBase = nPropBase;}

	// get out 'actual' minimum and maximum props
	__inline void GetMinMaxOptProps(UINT & nIDMinProp, UINT & nIDMaxProp)
	{
		nIDMinProp = m_nPropBase; nIDMaxProp = m_nPropBase + GetOptPropRange() - 1;
	}


	// get our 'range' of props required
	__inline const UINT GetOptPropRange()
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return nPropMax - nPropMin + 1;
	}

	// get our 'actual' prop from logical prop
	__inline UINT MapLogical(UINT nOptProp)
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return m_nPropBase + OHStripDepth(nOptProp - nPropMin);
	}

	// get our 'logical' prop from actual prop
 	__inline UINT MapActual(UINT nOptProp)
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return OHAddDepth(nOptProp + nPropMin - m_nPropBase, m_cDepth);
	}

	__inline UINT GetDepth() {return m_cDepth;}

	__inline UINT FirstOptProp()
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return m_nPropBase + OHStripDepth(nPropMin);
	}

	__inline UINT LastOptProp()
	{
		UINT nPropMin, nPropMax; GetMinMaxLogicalOptProps(nPropMin, nPropMax);
		return m_nPropBase + OHStripDepth(nPropMax);
	}

	//
	// add default tool option properties to our map
	//
	__inline void AddDefStrProp(UINT idProp, const char * sz, OptType ot = single)
		{m_mapDefOptions.SetAt(idProp, new CDefOptionProp(idProp, sz, strST, ot));}

	__inline void AddDefPathProp(UINT idProp, const char * sz, OptType ot = single)
		{m_mapDefOptions.SetAt(idProp, new CDefOptionProp(idProp, sz, pathST, ot));}

	__inline void AddDefDirProp(UINT idProp, const char * sz, OptType ot = single)
		{m_mapDefOptions.SetAt(idProp, new CDefOptionProp(idProp, sz, dirST, ot));}

	__inline void AddDefIntProp(UINT idProp, int n, OptType ot = single)
		{m_mapDefOptions.SetAt(idProp, new CDefOptionProp(idProp, n, intST, ot));}

	__inline void AddDefBoolProp(UINT idProp, BOOL b, OptType ot = single)
		{m_mapDefOptions.SetAt(idProp, new CDefOptionProp(idProp, b, boolST, ot));}
																			
	__inline void AddDefHexProp(UINT idProp, BOOL b, OptType ot = single)
		{m_mapDefOptions.SetAt(idProp, new CDefOptionProp(idProp, b, hexST, ot));}

	//
	// is this tool option property a default?
	//
	virtual BOOL IsDefaultIntProp(UINT idProp, int & nVal);
	virtual BOOL IsDefaultStringProp(UINT idProp, CString & strVal);
#define IsDefaultBoolProp(idProp, bVal)	IsDefaultIntProp((idProp), (int &)(bVal))
	 
	__inline virtual BOOL AlwaysShowDefault(UINT idProp)	{return FALSE;	/* never always show defaults*/}
	__inline virtual BOOL IsFakeProp(UINT idProp)			{return FALSE;	/* default is no */}

	// retrieve the main-type of this property
	__inline PROP_TYPE GetDefOptionType(UINT idProp)
	{
		CDefOptionProp * pdefopt;
		VERIFY(m_mapDefOptions.Lookup(idProp, (void *&)pdefopt));
		return pdefopt->m_pprop->m_nType;
	}

	// retrieve the sub-type of this property
	// eg. subtypes for ints are bool, hex, int, oct
	__inline SUBTYPE GetDefOptionSubType(UINT idProp)
	{
		CDefOptionProp * pdefopt;
		VERIFY(m_mapDefOptions.Lookup(idProp, (void *&)pdefopt));
		return pdefopt->subtypeprop;
	}

	// retrieve our default tool options from the map
	virtual GPT GetDefIntProp(UINT idProp, int & nVal);
	virtual GPT GetDefStrProp(UINT idProp, CString & strVal);

	// get the output directory string id, == -1 if none, that is used to fake (prepend to)
	// this property 'idProp'
	virtual UINT GetFakePathDirProp(UINT idProp) {return (UINT)-1;}

	// an option property in the table has changed
	virtual void OnOptionStrPropChange(UINT idProp, const CString & strVal) { /* do nothing */ }
	virtual void OnOptionIntPropChange(UINT idProp, int nVal) { /* do nothing */ }

	// conversion of int, oct,hex values into a text form
	// FUTURE (matthewt): I'd like to put this elsewhere, but where?
	BOOL ConvertToStr(UINT idProp, int nVal, CString & strVal);
	BOOL ConvertFromStr(UINT idProp, const TCHAR * pchVal, int & nVal);

	__inline BOOL NeedsSubtypeConversion(UINT idProp)
	{
		CDefOptionProp * pdefopt;
		if (!m_mapDefOptions.Lookup(idProp, (void *&)pdefopt))	return FALSE;
		return (pdefopt->m_pprop->m_nType == integer);
	}

	__inline BOOL IsListStrProp(UINT idProp)
	{
		CDefOptionProp * pdefopt;
		if (!m_mapDefOptions.Lookup(idProp, (void *&)pdefopt))	return FALSE;
		return (pdefopt->m_opttype == multiple);
	}

	// joins prop strings together using the chJoin char
	// (only the current property bag will be searched and not the any of the container's (parent's))
	GPT GetListStrProp
	(
		CSlob * pSlob,
		UINT nIDProp,
		CString & strVal,
		BOOL fInherit = TRUE, BOOL fAnti = FALSE,
		char chJoin = ','
	);

 	// add or remove the string from the list
	void MungeListStrProp(UINT nIDProp, const CString & strVal, BOOL fAppend, char chJoin = ' ');

	void SetListStrProp
	(
		CSlob * pSlob,
		UINT nIDExtraProp,
		CString & strVal,
		BOOL fInherit = TRUE, BOOL fAnti = FALSE,
		char chJoin = ','
	);

	// clear string lists, not-dirtied args
	// PERFORMANCE: improve performance
	__inline void ResetDirtyArgs()
	{
		UINT nPropMin, nPropMax; GetMinMaxOptProps(nPropMin, nPropMax);
		for (UINT nProp = 0; nProp < nPropMax - nPropMin + 1; nProp++)
			m_pdirtyProps->SetAt(nProp, (BYTE)FALSE);
	}

	__inline void DirtyArg(UINT nAdjProp)
		{m_pdirtyProps->SetAt(nAdjProp, (BYTE)TRUE);}

	void ClearStringLists(CPropBag * ppropbag = (CPropBag *)NULL);
	void ClearCleanArgs(CPropBag * ppropbag = (CPropBag *)NULL, OptBehaviour = OBNone);
	void ClearSpecialOptProps(CPropBag * ppropbag = (CPropBag *)NULL, OptBehaviour = OBNone);

	// is this property id valid with respect to its deps?
	__inline virtual BOOL CheckDepOK(UINT idProp) {return TRUE; /* always valid */}
	
	// Override this to control ordering of tabs in the Settings dialog.
	virtual int GetTabDlgOrder();
 
	// Query whether this slob's faked property value may be different from what the
	// "default" would be for a random slob in the same container.
	// Option handlers can safely return TRUE for all fake properties.  Returning FALSE
	// is an optimization hint to the build engine, which may save time by avoiding
	// queries of the fake property value.
	__inline virtual BOOL SetsFakePropValue(UINT idProp)	{return TRUE;}
		
	// our associated CBuildTool
	CBuildTool * m_pAssociatedBuildTool;

	// our 'current' and 'old' CSlobs stack
	CSlob *	m_pSlob;
	CSlob * m_stkOldSlobs[_MAX_SLOB_STACK];
	unsigned short m_sStk;

protected:
	CMapWordToPtr	m_mapDefOptions;	// our default option value map							  
	UINT			m_nPropBase;		// base of our option prop range, determined at run-time
	UINT			m_cDepth;			// our option handler 'depth' == number of 'base' handlers 

private:
	COptionHandler *	m_popthdlrBase;		// our base option handler (if we have one)
	CByteArray *		m_pdirtyProps;		// dirty properties
	UINT *				m_pStrListPropIds;	// cache of string list props IDs 
	UINT				m_cStrListPropIds;	// # of entries in this cache
};

// our 'Unknown' option handler
// this will substitute for any other option handler and still
// parse and generate option strings
class COptHdlrUnknown : public COptionHandler
{
	DECLARE_DYNAMIC(COptHdlrUnknown);

public:
	COptHdlrUnknown(CBuildTool * pBuildTool);

	// create our default option map
	void CreateOptDefMap() {/* do nothing*/}

	// retrieve our 'special' option props, ie. the unknown strins and options prop IDs
	void GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour = OBNone);

	// retrieive our min. and max. option prop IDs
	void GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp);

	// case sensitive (though this is ignored as we have ignored options'n' strings)
	__inline const BOOL IsCaseSensitive() {return TRUE;}

	// retrieve our option string table
	// (just has two entries, unknown option and unknown string)
	COptStr * GetOptionStringTable();

	// we don't have an option lookup
	__inline COptionLookup * GetOptionLookup()	{return (COptionLookup *)NULL;}

	// we don't have any option UI!
	__inline CRuntimeClass * GetGeneralOptionPage() {return (CRuntimeClass *)NULL;}
};

// definition of the COptHdlrMapper class
class BLD_IFACE COptHdlrMapper
{
public:
	COptHdlrMapper();
	virtual ~COptHdlrMapper();

	//	Return the COptionHandler for this tool
	__inline COptionHandler * GetOptionHandler() {return m_popthdlr;}

	//  Set the COptionHandler for this tool
	__inline void SetOptionHandler(COptionHandler * popthdlr)
		{m_popthdlr = m_popthdlrMapper = popthdlr; m_cDepth = popthdlr->GetDepth();}

	void SetMapperOptionHandler(UINT cDepth);

	// mapping of logical->actual option handler props
	__inline UINT MapLogical(UINT idProp)
	{
		if (OHGetDepth(idProp) != m_cDepth)	SetMapperOptionHandler(OHGetDepth(idProp));
		return m_popthdlrMapper->MapLogical(idProp);
	}

protected:
	COptionHandler * m_popthdlr;		// the tool's option handler

private:
	COptionHandler * m_popthdlrMapper;	// our option handler used to map the props
	UINT m_cDepth;						// our current depth handler
};

// definition of the COptionTable class
class BLD_IFACE COptionTable: public CObject
{
public:
	// initialise our option table with
	COptionTable();
	~COptionTable();

	// get/set the COptionHandler that we'll use
	__inline COptionHandler * GetOptionHandler() {return m_popthdlr;}
	__inline void SetOptionHandler(COptionHandler * popthdlr)
	{
 		m_popthdlr = popthdlr; if (m_pSlob && m_popthdlr) m_popthdlr->SetSlob(m_pSlob, FALSE);
	}

	// set the option handler given a package name and component pair
	COptionHandler * SetOptionHandler(const TCHAR * szPkg, WORD id);

	// get/set the CSlob that contains the property bag that contains the tool option values
	// the CSlob must be a CProjItem to support inheritance
	// (but this is not required if inheritance is not wanted)
	__inline CSlob * GetPropertyBag() {return m_pSlob;} 
	__inline void SetPropertyBag(CSlob * pSlob)
	{
 		ASSERT(pSlob); m_pSlob = pSlob; if (m_popthdlr) m_popthdlr->SetSlob(m_pSlob, FALSE);
	}

	// 'nukes' any tool option values for the current property bag
	void ClearPropertyBag();

	// parse a string using the option string table and set the approp.
	// properties in the current CSlob's property bag, returns FALSE if unable
	BOOL ParseString(CString &, OptBehaviour optbeh = OBClear);

	// generate a string using the option string table based on the approp.
	// property values in the current CSlob's property bag, returns FALSE if unable
	BOOL GenerateString(CString &, OptBehaviour optbeh = OBShowDefault | OBShowFake | OBInherit);

	// generate a hash value given a string 
	int GenerateHashValue (CString &);

	// generate a single option using the option string table based on the approp.
	// property values in the current CSlob's property bag, returns FALSE if unable
	BOOL GenerateSingleOption(UINT idOption, CString &,	OptBehaviour optbeh = OBShowDefault | OBShowFake | OBInherit);

	// generate a descriptive text instead of raw-text using the option table based on
	// the approp. property values in the current CSlob's property bag, returns FALSE
	// if it was enable to do this
	// eg. /W1 replaces /W3, and /Tp, and not /nologo
	BOOL GenerateDescription(CString &, BOOL & fBlank);

	// Note : for GenerateString() and GenerateSingleOption()
	// if the current CSlob is a CProjItem then 
	// the inheritance can be turned off by setting fInherit = FALSE, in this state

private:
	// option 'arg expression' helper & option 'optional part' extraction
	void ExtractOptionArg(char * & pchExpr, UINT & cchExpr);
	void ExtractPart(char * & pchExpr, UINT & cchExpr, char * & pchPart, UINT & cchPart);

	// parsing option string helper functions
	BOOL MatchChoice(UINT &, char *, UINT *);
	BOOL MatchExpression(const char * pchExpr, UINT cchExpr, UINT * pidArg);	// match an expression
	BOOL MatchOption(COptStr * poptstr);	// match an option with the source

	// choice matching/generating helpers
	BOOL GenerateChoice(CString & strOptionBit, UINT, char *, UINT *);
	BOOL GenerateExpression(CString & strOptionBit, const char * pchExpr, UINT cchExpr, UINT * pidArg);
	void GenerateAppendUnknown(CString & strOption, UINT idOpt);
	BOOL GenerateOption(CString & strOption, COptStr * poptstr, CString & strPrefix, BOOL fAddTrailSpace = TRUE);

	// skip whitespace in the source
	__inline void SkipWhiteSpace()
	{
		while (isspace((unsigned char)NewGetAt(strSrc, ichSrc + cchAdvSrc)))
			cchAdvSrc++;
	}

	// collect characters from the source into the output buffer according to a set of char. filters
	BOOL CollectOptionPart
	(
		CString & strOut,				// the collected option part
		BOOL	  fAlphaNumOnly = FALSE,// allow only alpha-numeric
		BOOL	  fAllowPunct = FALSE,	// don't allow punct.
		BOOL	  fAllowKanji = TRUE,	// allow Kanji characters (required)
		BOOL      fKeepQuotes = FALSE,	// keep the quotes?
		CString   strDelim = ""			// any delimiters (could be empty)
	);

private:
	// our option handler and current CSlob (property bag) 
	COptionHandler * m_popthdlr;
	CSlob * m_pSlob;

	// how should the parsing, generation behave?
	// ie. are we using defaults, showing defaults, setting defaults etc. etc.?
	OptBehaviour m_optbeh;

	//
	// property arg list
	//
	struct {
		UINT	idArg;
		BOOL	fChanged;
		CProp *	pProp;
		OptType type;
	} m_rgProps[MAX_OPT_ARGS];	// our properties to set for each option

	// clear our property arg list
	void ClearPropValList(BOOL fOnlyThoseChanged = FALSE);
	void ClearPropVal(UINT *poptarg);

	// add a property to our list,
	// set the properties in the list in the current property bag (also for multiple options)
	__inline void AddToPropList(UINT iArg, UINT idArg, CProp * pprop)
	{
		// first delete any existing arg (likely due to matching an optional part)
		if (m_rgProps[iArg].idArg != (UINT)-1 && m_rgProps[iArg].pProp)
			CProp::DeleteCProp(m_rgProps[iArg].pProp);

		m_rgProps[iArg].idArg = idArg;	// our arg id to set
		m_rgProps[iArg].pProp = pprop;	// our property
		m_rgProps[iArg].fChanged = TRUE;	// we changed this arg. recently
	}

	void SetPropValListInPropBag(UINT * poptarg);

	// reset our property list changed flags so we can spot which ones
	// we recently set when we go to back-out
	__inline void NoChangedPropValList()
	{
		for (WORD cArgs = 0; cArgs < MAX_OPT_ARGS ; cArgs++)
			m_rgProps[cArgs].fChanged = FALSE;
	}

	// allowable flag prefixes
	CString			strPrefixes;

	// option string table 'cached' props, and 'cached' case sensitive bool
	UINT	m_nPropMin, m_nPropMax;
	BOOL	m_fCaseSensitive;

	// source to parse/generate 
	CString strSrc;			// our source string
	int	ichSrc;				// our current position
	int	cchAdvSrc;			// count chars advanced
	int cchAdvSrcToArg;		// count chars advanced to first arg.

	// multiple option data
	BOOL m_fMultipleGen;		// single or multiple?
	BOOL m_fStopMultipleGen;	// stop the gen. of multiple options?
	UINT m_iGenIteration;		// # of the generation iteration
	BOOL m_fGenUsedProps;	// how did the last generate string fail, did it use props?

	// cached data for our multiple option generation
	CPropBag * m_pBagCache;
	UINT m_idArgPropCache;
	UINT m_iGenIterationCache;
	OptBehaviour m_optbehCache;

	COptionList m_optlstCache;
	POSITION m_posCache;

	// are we using defaults to parse and generate with?
	BOOL m_fUseDefault;

	// FUTURE: move this to the stack as locals
	TCHAR * pchArgValue;		// option arg expr. value
	UINT cchArgValue; 			// size of this dynamic buffer
	enum {none, booln, choice, absolute} patArgValue;	// option arg type
};

extern BLD_IFACE COptionTable g_prjoptengine;

extern UINT g_nIDOptHdlrUnknown;

#define NO_OPTARGS		{UINT(-1),UINT(-1),UINT(-1)}
#define OPTARGS1(a) 	{a,UINT(-1),UINT(-1)}
#define OPTARGS2(a,b)	{a, b,UINT(-1)}
#define OPTARGS3(a,b,c)	{a, b, c}

// declare the option string table
#define DECL_OPTSTR_TABLE() \
public: \
	void GetSpecialLogicalOptProps(UINT & nIDUnkOpt, UINT & nIDUnkStr, OptBehaviour = OBNone); \
	void GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp); \
	const BOOL IsCaseSensitive(); \
	COptStr * GetOptionStringTable(); \
	COptionLookup * GetOptionLookup(); \
protected: \
	COptionLookup m_optlookup; \
	static COptStr m_poptstr[]; \

// declare the option default map
#define DECL_OPTDEF_MAP() \
private: \
	virtual void CreateOptDefMap();

// define the option string table
// need to provide:-
// o props used for the unknown option/string props (-1 if one doesn't exist)
// o min. and max. props that exist in the option string table
// o whether the parsing of the option string should be case sensitive
#define BEGIN_OPTSTR_TABLE(tool, nIDArg1, nIDArg2, nIDArg3, nIDArg4, fCaseSensitive) \
	void OPTION_HANDLER(tool)::GetSpecialLogicalOptProps(UINT & nIDUnknownOption, UINT & nIDUnknownString, OptBehaviour optbeh) \
		{ \
			ASSERT_VALID(m_pSlob); \
			nIDUnknownOption = (optbeh & OBAnti) ? (UINT)-1 : (nIDArg1); \
			nIDUnknownString = (optbeh & OBAnti) ? (UINT)-1 : (nIDArg2); \
		} \
	void OPTION_HANDLER(tool)::GetMinMaxLogicalOptProps(UINT & nIDMinProp, UINT & nIDMaxProp) \
		{nIDMinProp = (nIDArg3); nIDMaxProp = (nIDArg4); ASSERT(nIDMinProp != (UINT)-1 && nIDMaxProp != (UINT)-1);} \
	const BOOL OPTION_HANDLER(tool)::IsCaseSensitive() \
		{return fCaseSensitive;} \
	COptStr * OPTION_HANDLER(tool)::GetOptionStringTable() \
		{return (COptStr *)m_poptstr;} \
	COptionLookup * OPTION_HANDLER(tool)::GetOptionLookup() \
		{return &m_optlookup;} \
	COptStr OPTION_HANDLER(tool)::m_poptstr[] = {

#define END_OPTSTRTBL() \
	{(UINT)-1, NULL, NO_OPTARGS, single}};

// declare the option handler
#define DEFN_OPTHDLR_HEADER(tool, szPkg, id, szPkgTool, idTool, szPkgBase, idBase)\
class OPTION_HANDLER(tool) : public COptionHandler { \
public: \
	OPTION_HANDLER(tool)() : COptionHandler(szPkg, id, szPkgTool, idTool, szPkgBase, idBase) {} \

#define DEFN_OPTHDLR_COMMON(tool, szPkg, id, szPkgTool, idTool) \
	DEFN_OPTHDLR_HEADER(tool, szPkg, id, szPkgTool, idTool, (const TCHAR *)NULL, 0)
#define DEFN_OPTHDLR_PLATFORM(tool, szPkg, id, szPkgTool, idTool, szPkgBase, idBase) \
	DEFN_OPTHDLR_HEADER(tool, szPkg, id, szPkgTool, idTool, szPkgBase, idBase)

#define END_OPTHDLR() };

// this defines the ctor that will create our default option map for the handler
#define BEGIN_OPTDEF_MAP(tool) void OPTION_HANDLER(tool)::CreateOptDefMap() {

#define OPTDEF_LIST(name, sz) AddDefStrProp(MapLogical(P_##name), sz, multiple);
#define OPTDEF_DIR_LIST(name, sz) AddDefDirProp(MapLogical(P_##name), sz, multiple);

#define OPTDEF_BOOL(name, b) AddDefBoolProp(MapLogical(P_##name), b);
#define OPTDEF_STRING(name, sz) AddDefStrProp(MapLogical(P_##name), sz);
#define OPTDEF_PATH(name, sz) AddDefPathProp(MapLogical(P_##name), sz);
#define OPTDEF_INT(name, n) AddDefIntProp(MapLogical(P_##name), n);
#define OPTDEF_HEX(name, h) AddDefHexProp(MapLogical(P_##name), h);

#define END_OPTDEF_MAP() }

#include "optnui.h"		// the tool option UI

#endif // _INCLUDE_OPTIONTBL_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\progdlg.h ===
//
//	PROGDLG.H
//
//
//	Defines dialog class for giving feedback during a long operation
//	with a "Cancel" button.  Main purpose is to get all yielding code
//	in one place.
//
//
//	Call DoYield function to allow the main window to run.
//
//	Expects the dialog template to have a button with IDCANCEL.
//	Anything else is up to you.  You can give feedback by calling
//	SetDlgItemText or whatever.
//
//
//
// History
// =======
// Date			Who			What
// ----			---			----
// 22-May-93	danw		Created
//
///////////////////////////////////////////////////////////////////////////////
#ifndef __PROGDLG_H__
#define	__PROGDLG_H__

#undef AFX_DATA
#define AFX_DATA AFX_EXT_DATA

class CProgressDialog: public CDialog 
{
public:
	//
	//	Create creates the dialog _and_ disables the main window:
	//
	BOOL CreateProgressDialog	(LPCSTR lpszTemplateName, 
								 CWnd *pParent = NULL);
	BOOL CreateProgressDialog	(UINT id, CWnd *pParent = NULL) 
	{
		return CreateProgressDialog( MAKEINTRESOURCE (id), pParent);
	}
	//
	//	Must call this even if user aborted.  Reenables main window:
	//
	void DestroyProgressDialog  ();
	//
	//	Get the state of the user abort flag.  FALSE if user hit
	//	cancel:
	//
	BOOL GetState () { return ProgressDialogContinue; };
	//
	//	Call DoYield to allow other parts of the app to run.  Returns
	//	FALSE if a WM_QUIT message has been seen by PumpMessage.
	//
	BOOL DoYield ();
private:
	void OnCancel();
	//
	//	The dialog will set this flag to FALSE if the user presses Cancel:
	//
	BOOL ProgressDialogContinue;
};

/////////////////////////////////////////////////////////////////////////////

#undef AFX_DATA
#define AFX_DATA NEAR

#endif // __PROGDLG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projcntr.cpp ===
//
//	PROJCNTR.CPP
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#pragma hdrstop

#include "newgrp.h"		// For New Group dialog.
#include "projcomp.h"	// For g_Spawner
#include "resource.h"
#include "bldslob.h"
#include "bldnode.h"

#include <prjapi.h>
#include <prjguid.h>

IMPLEMENT_SERIAL (CProjContainer, CProjItem, SLOB_SCHEMA_VERSION)
IMPLEMENT_SERIAL (CProjGroup, CProjContainer, SLOB_SCHEMA_VERSION)
IMPLEMENT_SERIAL (CDependencyContainer, CProjContainer, SLOB_SCHEMA_VERSION)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ CProjContainer ------------------------------
//                                 
///////////////////////////////////////////////////////////////////////////////
//
//
#define theClass CProjContainer
BEGIN_SLOBPROP_MAP(CProjContainer, CProjItem)
END_SLOBPROP_MAP()
#undef theClass

CProjContainer::CProjContainer ()
{
	m_pFindItemCache = NULL;
}

CProjContainer::~CProjContainer ()
{
	if (m_pFindItemCache != NULL)
	{
		delete m_pFindItemCache;
		m_pFindItemCache = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands

void CProjContainer::CmdAddGroup()
{
	// Build must not be in progress
	ASSERT(!g_Spawner.SpawnActive());

	CNewGroupDlg dlg;
	
	if (dlg.DoModal() == IDOK)
	{
		// Add a new group now
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
		pProjSysIFace->BeginUndo(IDS_UNDO_ADD_GROUP);

		CProjGroup *pGroup = AddNewGroup(dlg.m_strGroup, dlg.m_strGroupFilter);
	
		// The recently added group should be at the end of our contents list:
		pProjSysIFace->EndUndo();
	}
}


CDependencyContainer * CProjContainer::GetDependencyContainer (BOOL bMake)
{
//
//	Return dependency container. Make one if there isn't one:
//

	POSITION pos, posSave;
	CSlob *pSlob;
	CDependencyContainer *pDepCntr;
	CProject * pProject = GetProject();
	BOOL bLast = TRUE;
	CObList * pContentList = GetContentList();
	for (pos = pContentList->GetTailPosition(); pos != NULL; )
	{
		posSave = pos;
		pSlob = (CSlob *)pContentList->GetPrev (pos);
		if (pSlob->IsKindOf ( RUNTIME_CLASS ( CDependencyContainer )))
        {
            pDepCntr = (CDependencyContainer*) pSlob;
			ConfigurationRecord * pcrBase = pProject->GetActiveConfig();
            if (pDepCntr->IsValid(pcrBase))
			{
				if (!bLast)
				{
					// make sure it is at the end of list
					pContentList->RemoveAt(posSave);
					pContentList->AddTail(pSlob);
				}		
				return (CDependencyContainer *) pSlob;
			}
		}
		bLast = FALSE;
	}

//
//	Have to make it:
//
	if ( bMake == TRUE)
	{
		// don't want to record this action
		theUndoSlob.Pause();

		pDepCntr = new CDependencyContainer();

        // Set up the config for which this container is active
        ConfigurationRecord * pcr = GetActiveConfig();
        pDepCntr->SetValid((ConfigurationRecord *)pcr->m_pBaseRecord);
        
		pDepCntr->MoveInto (this);

		theUndoSlob.Resume();
		return pDepCntr;
	}
	return NULL;
}			

BOOL CProjContainer::CanRemove ( CSlob *pRemoveSlob )
{
	return TRUE;
}

void CProjContainer::Add ( CSlob * pAddSlob )
{
	CProjItem::Add ( pAddSlob );
}

void CProjContainer::Remove ( CSlob * pRemoveSlob )
{
	CProjItem::Remove (pRemoveSlob);
};

// not terribly efficient;  Avoid except when necessary
// optimized for an already sorted list
void CProjContainer::SortContentList()
{
	int nCount = m_objects.GetCount();
	if (nCount < 2)
		return;  // nop

	CObList OldList; OldList.AddTail(&m_objects);
	m_objects.RemoveAll();

	m_objects.AddHead(OldList.RemoveHead());  // just insert the first element
	BOOL bAdded;
	CProjItem * pItem;
	CProjItem * pCompItem;
	POSITION pos, curPos;
	while (!OldList.IsEmpty())
	{
		bAdded = FALSE;
		pItem = (CProjItem *)OldList.RemoveHead();
		pos = m_objects.GetTailPosition();
		while (pos != NULL)
		{
			curPos = pos;
			pCompItem = (CProjItem *)m_objects.GetPrev(pos);
			if (pItem->CompareSlob(pCompItem) >= 0)
			{
				m_objects.InsertAfter(curPos, pItem);
				bAdded = TRUE;
				break;
			}
		}
		if (!bAdded)
		{
			m_objects.AddHead(pItem);
		}
	}
	ASSERT(m_objects.GetCount() == nCount);
	OldList.RemoveAll();
};

void CProjContainer::RefreshAllMirroredDepCntrs()
{
    CProject * pProject = GetProject();
	if (pProject->IsExeProject())
		return;	// we should not have gotten here

	if (!IsKindOf(RUNTIME_CLASS(CTargetItem)))
	{
		ASSERT(GetTarget() != NULL);
		GetTarget()->RefreshAllMirroredDepCntrs();
		return;
	}
	// REVIEW: move to CTargetItem

	// For this item we want to go through all configs
	// and for any configs that are valid, we put the
	// project into this config and call RefreshDependencyContainer
	// finally resetting the config back.
	// This will refresh all dep containers for a given
	// container
	ConfigurationRecord * pcr, * pcrBase;
	CProjTempConfigChange projTempConfigChange(pProject);

	int nSize = m_ConfigArray.GetSize();
	for (int nConfig = 0; nConfig < nSize; nConfig++)
	{
		pcr = (ConfigurationRecord *)m_ConfigArray[nConfig];
		if (pcr->IsValid())
		{
            pcrBase = (ConfigurationRecord *)pcr->m_pBaseRecord;
			projTempConfigChange.ChangeConfig(pcrBase);
			RefreshDependencyContainer();
		}
	}
}

void CProjContainer::RefreshDependencyContainer() 
{
	if (!IsKindOf(RUNTIME_CLASS(CTargetItem)))
	{
		ASSERT(GetTarget() != NULL);
		GetTarget()->RefreshDependencyContainer();
		return;
	}
	// REVIEW: move to CTargetItem

	CFileRegistry * pRegistry = ((CTargetItem *)this)->GetRegistry();

	// our list of source + scanned dependencies across all actions
	FileRegHandle frh, frh2;
	CPtrList lstDeps;
    CProject * pProject = GetProject();
	ASSERT(NULL!=pProject);
	CObList ol;
	FlattenSubtree( ol, flt_Normal | flt_ExcludeProjects | flt_ExcludeGroups | flt_RespectItemExclude | flt_ExcludeDependencies | flt_RespectTargetExclude | flt_ExcludeProjDeps);

	POSITION pos = ol.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CFileRegSet * psetDep;

		// the contained project item
		CProjItem * pItem = (CProjItem *)ol.GetNext(pos);

		// get the actions for the item in this config.
		CActionSlobList * pActions = pItem->GetActiveConfig()->GetActionList();
		if (pActions->IsEmpty())
			continue;	// do nothing

		{
			POSITION pos1 = pActions->GetHeadPosition();
			while (pos1 != (POSITION)NULL)
			{
				CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos1);

				// get our scanned deps
				psetDep = pAction->GetScannedDep();
				psetDep->InitFrhEnum();
				while ((frh = psetDep->NextFrh()) != (FileRegHandle)NULL)
				{
					// don't add deps that are already in the project
					// UNDONE: handle multiple projects properly!
					frh2 = pRegistry->LookupFile(frh->GetFilePath());
					if (frh2 != NULL)
					{
						ASSERT(frh2==frh);
						if (GetTarget()->IsFileInTarget(frh2,TRUE))
						{
#ifdef REFCOUNT_WORK
							frh->ReleaseFRHRef();
							frh2->ReleaseFRHRef();
#endif
							continue;
						}
#ifdef REFCOUNT_WORK
						frh2->ReleaseFRHRef();
#endif
					}
					lstDeps.AddTail(frh);
				}

				// get our source deps
				psetDep = pAction->GetSourceDep();
				psetDep->InitFrhEnum();
				while ((frh = psetDep->NextFrh()) != (FileRegHandle)NULL)
				{
					// don't add deps that are already in the project
					// UNDONE: handle multiple projects properly!
					frh2 = pRegistry->LookupFile(frh->GetFilePath());
					if (frh2 != NULL)
					{
						ASSERT(frh2==frh);
						if (GetTarget()->IsFileInTarget(frh2,TRUE))
						{
#ifdef REFCOUNT_WORK
							frh2->ReleaseFRHRef();
							frh->ReleaseFRHRef();
#endif
							continue;
						}
#ifdef REFCOUNT_WORK
						frh2->ReleaseFRHRef();
#endif
					}
					lstDeps.AddTail(frh);
				}
			}
		}
	}

	// a map to allow us to remove duplicates and deps. no longer required
	CMapPtrToPtr ptrMap(31 /* increase map size */);
																				
	// try to get a dependency container (*don't* create it)
	CDependencyContainer * pDepCntr = GetDependencyContainer(FALSE);
	ASSERT(IsKindOf(RUNTIME_CLASS(CTargetItem)));

	CTargetItem* pTarget = (CTargetItem*)this;

	BOOL bHasExternalDepFolder = FALSE;
	if (valid!=pTarget->GetIntProp(P_TargNeedsDepUpdate,bHasExternalDepFolder))
		bHasExternalDepFolder = FALSE;

	if (pDepCntr == (CDependencyContainer *)NULL)
	{
		// don't need any deps?
		if (!bHasExternalDepFolder && lstDeps.IsEmpty())
			return;

		// create the container
		pDepCntr = GetDependencyContainer(TRUE);
		ASSERT(pDepCntr != (CDependencyContainer *)NULL);
	}
	else
	{
		// enter all the existing dependencies as unsused
		POSITION pos1 = pDepCntr->GetHeadPosition();
		while (pos1 != (POSITION)NULL)
			ptrMap.SetAt(((CDependencyFile *)pDepCntr->GetNext(pos1))->GetFileRegHandle(), FALSE);
	}

	// don't want to record these dependency container changes
	theUndoSlob.Pause();

	pos = lstDeps.GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		frh = (FileRegHandle)lstDeps.GetNext(pos);

		// Filter out files that should not be in dep folder(e.g., .pch files).
		if (FileNameMatchesExtension(frh->GetFilePath(), "pch"))
		{
			frh->ReleaseFRHRef();
			continue;
		}
		BOOL fDepUsed;
		if (!ptrMap.Lookup((void *)frh, (void *&)fDepUsed))
		{
			// create the dependency file and move it into the 
			// dependency container
			CDependencyFile * pDepFile = new CDependencyFile;
			pDepFile->SetFileRegHandle(frh);
			pDepFile->MoveInto(pDepCntr);

			// mark dep. file as used
			ptrMap.SetAt((void *)frh, (void *)TRUE);
		}
		// mark dep. file as used
		else if (!fDepUsed)
		{
			ptrMap.SetAt((void *)frh, (void *)TRUE);
		}
#ifdef REFCOUNT_WORK
		frh->ReleaseFRHRef();
#endif
	}

	// go through the list of dependancy files and remove any
	// that were never referenced
	pos = pDepCntr->GetHeadPosition();
	while (pos != (POSITION)NULL)
	{
		CDependencyFile * pDepFile = (CDependencyFile *)pDepCntr->GetNext(pos);
		
		BOOL fDepUsed;
		VERIFY(ptrMap.Lookup((void *)pDepFile->GetFileRegHandle(), (void *&)fDepUsed));
		
		// delete the dependency file?
		if (!fDepUsed)
			pDepFile->MoveInto(NULL);
	}


	//
	// Update 
	if (!bHasExternalDepFolder && pProject->m_bPrivateDataInitialized)
	{
		//
		// Saving P_HasExternalDeps
		//
		pProject->SetIntProp(P_HasExternalDeps,NULL!=pDepCntr->GetHeadPosition());
	}
	bHasExternalDepFolder = bHasExternalDepFolder || NULL!=pDepCntr->GetHeadPosition();

	// if there are no dependencies, then delete the dependency container
	if (!bHasExternalDepFolder && NULL==pDepCntr->GetHeadPosition())
		pDepCntr->MoveInto(NULL);

	// allow recording again
	theUndoSlob.Resume();
}

void CProjContainer::DoAddFiles(BOOL bSubgroups)
{
	// this function should no longer be called since adding files to a
	// project is now controlled and performed from within the shell.
	ASSERT(FALSE);
}

CProjGroup *CProjContainer::AddNewGroup (const TCHAR * pszName /* = NULL */, const TCHAR * pszFilter /* = NULL */)
{
	CProjGroup *pGroup;

	if (pszName)
		pGroup = new CProjGroup(pszName);
	else
		pGroup = new CProjGroup;

	CProjContainer * pContainer = this;
	if (pContainer->IsKindOf(RUNTIME_CLASS(CProject)))
	{
		CTargetItem *pTarget;
#if 1
		ASSERT(0);  // should never get here
		pTarget = GetTarget();
#else
		CString strTargetName;
		((CProject *)pContainer)->InitTargetEnum();
		VERIFY(((CProject *)pContainer)->NextTargetEnum(strTargetName, pTarget));
#endif;
		pContainer = (CProjContainer *)pTarget;
	}
	pGroup->MoveInto(pContainer);

	if ((pszFilter) && (*pszFilter))
	{
		CString strFilter = pszFilter;
		VERIFY(pGroup->SetStrProp(P_GroupDefaultFilter, strFilter));
	}

	return pGroup;

	// FUTURE (rkern): fix
 	/*
 	// select this group in our view
   	((CProjectView *)GetSlobWnd())->m_TreeWnd.SetSelectedContainer(pGroup);

	// if the property sheet is not visible 
	// then show it for this newly added group
	if (!IsPropertyBrowserVisible())
		ShowPropertyBrowser(TRUE);
	*/
}

BOOL CProjContainer::ScanDependencies (BOOL bUseAnyMethod /* FALSE */, 
	BOOL bWriteOutput /* = TRUE */ )
{
//	Simply go through and scan every memeber.
	BOOL rc;

	g_ScannerCache.BeginCache();
	ConfigCacheEnabler EnableCaching;

	rc = g_ScannerCache.UpdateDependencies( this, bUseAnyMethod, bWriteOutput );

	g_ScannerCache.EndCache();

	return rc;
}


CProjGroup *CProjContainer::FindGroup (const TCHAR * pszName /* = NULL */)
{
	CProject *pProject;
	CObList ol;
	POSITION pos;
	CProjGroup *pGroup;
	BOOL	bFound = FALSE;
	CString strGroupName;
	CString str(pszName);

	pProject = GetProject ();
	if (!pProject) return NULL;
	pProject->FlattenSubtree ( ol, flt_Normal | flt_ExcludeDependencies );
	
	do
	{
		for (pos = ol.GetHeadPosition (); 
			 pos != NULL && !bFound; )
		{
			pGroup = (CProjGroup *) ol.GetNext (pos);
			if (!pGroup->IsKindOf ( RUNTIME_CLASS ( CProjGroup )))
				continue;
			pGroup->GetStrProp(P_GroupName, strGroupName);
			if (pGroup != this 	&&	CompareMonikers (strGroupName, str)==0)
				bFound = TRUE;
		}		
	} while (!bFound);

	if (bFound)
		return (CProjGroup *) pGroup;
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjContainer::ReadInChildren(CMakFileReader& mr, const CDir &BaseDir)
{
//	Helper function to read in children from make file.  
	CObject *pObject = NULL;
	CProjItem *pItem = NULL, *pTemp;
	CRuntimeClass *pRTC;
	CMakComment *pMC;

	CProject * pProject = GetProject();

	TRY
    {
		do
		{
			VERIFY (pObject = mr.GetNextElement ());

			if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
			{
				if ((pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) &&
					(((CMakDirective *)pObject)->m_dtyp == CMakDirective::DTYP_ENDIF))
						continue;	// orphan ENDIF might be okay

				AfxThrowFileException (CFileException::generic);
			}
			pMC = (CMakComment *) pObject;

			// Done if this is the end marker:
			if (IsEndToken (pObject)) break;

			// Figure out what kind of item this is supposed to be
			// and create it:
			pRTC = GetRTCFromNamePrefix(((CMakComment *) pObject)->m_strText);

			if (pRTC == NULL)
			{  
				delete (pObject);
				pObject = NULL;
				continue;
			}

			pItem = (CProjItem *) pRTC->CreateObject();

			CSlob * pContainer = this;

			// for v2 projects, put group into the target
			if ((pProject->m_bConvertedVC20) && (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup))))
			{
				ASSERT(pProject==this);
				pContainer = pProject->GetActiveTarget();
				ASSERT(pContainer);
				CString strFilter = "cpp;c;cxx;rc;def;r;odl;hpj;bat;for;f90";
				VERIFY(pItem->SetStrProp(P_GroupDefaultFilter, strFilter));
			}

			// make sure this is something that belongs in us
			if (!CanContain(pItem))
				AfxThrowFileException (CFileException::generic);

			pTemp = pItem; pItem = NULL;

			// do a part of the move, ie. just fix up the containment structure
			(void)pTemp->PreMoveItem(pContainer, FALSE, TRUE, FALSE);
			(void)pTemp->MoveItem(pContainer, (CSlob *)NULL, FALSE, TRUE, FALSE);

			mr.UngetElement (pObject);
			pObject = NULL;

			// preserve the current config. while we read in each child
			// to ensure that the child doesn't have the side-effect of 
			// changing this
			ConfigurationRecord * pcrProject = pProject->GetActiveConfig();

			// read in the item data
			// (item will do the post-move)
			if (!pTemp->ReadFromMakeFile (mr, BaseDir))
				AfxThrowFileException (CFileException::generic);

			// preserve the current config.

			(void) pProject->SetActiveConfig(pcrProject);

		} while (TRUE);

		ConfigurationRecord * pcr;
		CProjTempConfigChange projTempConfigChange(pProject);

		int nSize = m_ConfigArray.GetSize();
		for (int nConfig = 0; nConfig < nSize; nConfig++)
		{
			// Put project into right config
			pcr = (ConfigurationRecord *)m_ConfigArray[nConfig];
			projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);

 			// Update the dependency container
//			if (IsKindOf(RUNTIME_CLASS(CTargetItem)))
//				RefreshDependencyContainer();	// Show kids dependencies.

		}
		if ((pProject==this)  && (pProject->m_bConvertedVC20))
		{
			ConvertDeps();
 		}
 	}
	CATCH (CException, e)
	{
		if (pObject) delete (pObject);
		if (pItem) 	 delete (pItem);
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
//  Stuff for serialization:  A projitem needs to write out its "private"
//	binary properties to the OPT file (done through an CArchive) and
//	label its data so that it can be later retrieved.  Remember that the
//  actual project tree is stored in the "global" makefile, so there
//	may be items in the OPT file that don't exist in the make file and visa
//	versa.  
//
//	A simple CProjItem (ie no contents) record consists of:
//				Item's relative moniker ( a CString) 
//				Items's runtime class (as string)
//				Items's props

// A container's record looks like:
//				Item's relative moniker ( a CString) 
//				Items's runtime class (as string)
//				Items's props
//
//					0 or more contained items.
//				EndOfSerializeRecord
//
///////////////////////////////////////////////////////////////////////////////
const CString CProjContainer::EndOfSerializeRecord = "\x08\x14\x44\x4A\x57"; // :-)

BOOL CProjContainer::SerializeProps(CArchive& ar)
{
	POSITION pos;
	CProjItem *pProjItem, *pTempItem = NULL;
	CString str;
	CRuntimeClass *pRTC;
	UINT wSchemaNum = 0l;

	// write our base-class properties first
	CProjItem::SerializeProps (ar);

	TRY
	{
		if (ar.IsStoring())
		{
			//	When were storing, write out our contents followed by and end 
			//	of record mark. 
			for (pos=GetHeadPosition(); pos != NULL;)
			{
				pProjItem = (CProjItem *) GetNext (pos);
				ASSERT (pProjItem->IsKindOf (RUNTIME_CLASS (CProjItem)));
			
				//	Do not save subprojects--the're save seperately to their own
				//	OPT file:
				if (pProjItem->IsKindOf (RUNTIME_CLASS (CProject))) continue;

				if( pProjItem->IsKindOf (RUNTIME_CLASS (CFileItem)) ) continue;

				pProjItem->GetMoniker ( str );
				ar << str;
				(pProjItem->GetRuntimeClass())->Store (ar);

				if (!pProjItem->SerializeProps(ar))
					AfxThrowArchiveException (CArchiveException::generic);
			}

			ar << EndOfSerializeRecord;
		}
		else
		{
			while ( ar >> str, str != EndOfSerializeRecord)
			{
				pRTC = CRuntimeClass::Load ( ar, &wSchemaNum );

				if (pRTC == NULL || wSchemaNum != pRTC->m_wSchema )
					AfxThrowArchiveException (CArchiveException::badSchema);

				pProjItem = FindItem (str, pRTC);

				// If pProjItem = NULL, then the associacted item has been reomved 
				// from the make file.  However, we still need to read the object's
				// data to keep the archive working, so we create a temporray 
				// object of the appropriate class, let it read its stuff, and then
				// delete it:

				if (pProjItem == NULL )
				{
					PFILE_TRACE ("A %s at %p  in CProjContainer::SerializeProps "
						"could not find child with moniker %s and class %s.\n",
						GetRuntimeClass()->m_lpszClassName, this, 
						(const char *) str, pRTC->m_lpszClassName );

					pTempItem = (CProjItem *) pRTC->CreateObject ();
					if (!pTempItem->SerializeProps(ar))	   	// Recursion!
						AfxThrowArchiveException (CArchiveException::generic);
					delete (pTempItem);
					pTempItem = NULL;
				}
				else if (!pProjItem->SerializeProps(ar))	// Recursion!
					AfxThrowArchiveException (CArchiveException::generic);
		 	}
		}
	}
	CATCH(CException, e)
	{
		if (pTempItem) delete (pTempItem);
		return FALSE;	// failure
	}
	END_CATCH

	// Delete the map that FindItem created to cache info about projitems.
	delete m_pFindItemCache;
	m_pFindItemCache = NULL;

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
CProjItem *CProjContainer::FindItem (CString strMoniker, CRuntimeClass *pRTC )
{
//	This is slow, essentially O[n].  Note that monikers are compared 
//	_wihhout_ regard to case:

	CProjItem *pProjItem;

	if (m_pFindItemCache == NULL)
	{
		// Initialise our cached info map.

		POSITION pos;
		CString str;

		m_pFindItemCache = new CMapStringToPtr;
		for (pos=GetHeadPosition(); pos != NULL;)
		{
			pProjItem = (CProjItem *) GetNext (pos);
			ASSERT (pProjItem->IsKindOf (RUNTIME_CLASS (CProjItem)));
			pProjItem->GetMoniker(str);
			str.MakeUpper();
			m_pFindItemCache->SetAt(str, pProjItem);
		}
			
	}

	strMoniker.MakeUpper();		// make sure monikers are unique (case-insensitive)
	
	// Lookup may fail.
	if (m_pFindItemCache->Lookup(strMoniker, (void *&) pProjItem))
	{
		ASSERT(pProjItem->IsKindOf (RUNTIME_CLASS (CProjItem)));
		if (pProjItem->GetRuntimeClass() == pRTC)
			return pProjItem;
	}

	return NULL;
}

extern BOOL g_bExcludedNoWarning; // defined in pfilereg.cpp

void CProjContainer::ConvertDeps()
{
	CProject * pProject = GetProject();
	ASSERT(pProject);
	ASSERT(pProject->m_bProjConverted || pProject->m_bConvertedVC20 || pProject->m_bConvertedDS4x);
	{
		FileRegHandle frh;
		CTargetItem * pTarget = GetTarget();
		ASSERT(pTarget);
		CFileRegistry * pRegistry = pTarget->GetRegistry();

		BOOL bJava = FALSE;
		CProject *pProj = (CProject *) g_BldSysIFace.GetActiveBuilder ();
		CProjType * pProjType = pProj->GetProjType();

		if (pProjType && pProjType->GetUniqueTypeId() == CProjType::javaapplet)
			bJava = TRUE;

		CString strName, strHeaderFilter, strResFilter;
		strName.LoadString(IDS_HEADER_FILES);
		strHeaderFilter.LoadString(IDS_HEADER_FILES_FILTER);

		CProjGroup * pHeaders = NULL;
		if (!bJava)
			pHeaders = pTarget->AddNewGroup(strName, strHeaderFilter);

		strName.LoadString(IDS_RESOURCE_FILES);
		strResFilter.LoadString(IDS_RESOURCE_FILES_FILTER);

		CProjGroup *pResources = pTarget->AddNewGroup(strName, strResFilter);

		// ones we might use...
		CProjGroup *pHelpFiles = NULL;
		CProjGroup *pTemplates = NULL;

		pTarget->RefreshAllMirroredDepCntrs();
			
		// REVIEW: do this for all configs

		CDependencyContainer * pDepCntr = pTarget->GetDependencyContainer(FALSE);
		if (pDepCntr != NULL)
		{
			POSITION pos = pDepCntr->GetHeadPosition();
			while (pos != NULL)
			{
				CDependencyFile * pDepFile = (CDependencyFile *)pDepCntr->GetNext(pos);
				frh = pRegistry->LookupFile(*pDepFile->GetFilePath());
				if (frh != NULL)
				{
					if (pTarget->IsFileInTarget(frh,TRUE))
					{
						// already in project
						frh->ReleaseFRHRef();
						frh = NULL;
						continue;
					}
					else
					{
						//
						// Ignore files that are generated during the build.
						// Assume that any file with a dep graph node is a generated file.
						//
						CFileDepGraph* pDepGraph = g_buildengine.GetDepGraph(GetActiveConfig());
						if (NULL!=pDepGraph)
						{
							CDepGrNode* pgrn;
							if (pDepGraph->FindDep(frh,pgrn))
							{
								// found in depgraph for this configuration, ignore.
								frh->ReleaseFRHRef();
								frh = NULL;
								continue;
							}
						}
					}
					CProjContainer * pNewContainer = NULL;

					// See if this belongs in the project
					// and if so, in what folder
					CPath path = *pDepFile->GetFilePath();
					CDir dir;
					dir.CreateFromPath(path);
					CString strDir = dir;
					// 1. if in project dir
					if (GetProject()->GetWorkspaceDir() == dir)
					{
						pNewContainer = pTarget; // default
					}
					else
					{
						// 2. Check subdirs: res, inc, include, hlp, template
						CString strPrj = pProject->GetWorkspaceDir();
						CString strTmp;
						if (strDir.Right(3).CompareNoCase("res")==0)
							pNewContainer = pResources;
						else
						{
							strTmp = strPrj + _T("\\inc"); //inc
							if (strTmp.CompareNoCase(strDir)==0)
								pNewContainer = pHeaders;
							else
							{
								strTmp = strPrj + _T("\\include"); //include
								if (strTmp.CompareNoCase(strDir)==0)
									pNewContainer = pHeaders;
								else
								{
									strTmp = strPrj + _T("\\hlp"); //hlp
									if (strTmp.CompareNoCase(strDir)==0)
									{
										if (pHelpFiles == NULL)
										{
											CString strHelpName; strHelpName.LoadString(IDS_HELP_FILES);
											pHelpFiles = pTarget->AddNewGroup(strHelpName);
											ASSERT(pHelpFiles);
										}
										pNewContainer = pHelpFiles;
									}
									else
									{
										strTmp = strPrj + _T("\\template"); //template
										if (strTmp.CompareNoCase(strDir)==0)
										{
											if (pTemplates == NULL)
											{
												CString strTemplateName; strTemplateName.LoadString(IDS_TEMPLATE_FILES);
												CString strTemplateFilter; strTemplateFilter.LoadString(IDS_TEMPLATE_FILES_FILTER);
												pTemplates = pTarget->AddNewGroup(strTemplateName,strTemplateFilter);
												ASSERT(pTemplates);
											}
											pNewContainer = pTemplates;
										}
										// 3. if ChangeExtension to .cpp is in project
										else if ((_tcsnicmp((LPCTSTR)path.GetExtension(), _T(".h"),2)==0) && ((path.ChangeExtension(".cpp"), (pTarget->IsProjectFile(path))) ||
												 (path.ChangeExtension(".c"), (pTarget->IsProjectFile(path))) ||
												 (path.ChangeExtension(".cxx"), (pTarget->IsProjectFile(path)))
												))
										{
											pNewContainer = pTarget; // default
										}
										else
										{
											// FUTURE: add other tests here
										}
									}
								}
							}
							
						}
					}

					if (pNewContainer != NULL)
					{
						if (pNewContainer == pTarget) // try to improve on default
						{
							if (FileNameMatchesExtension(pDepFile->GetFilePath(), strHeaderFilter))
								pNewContainer = pHeaders;
							else if (FileNameMatchesExtension(pDepFile->GetFilePath(), strResFilter))
								pNewContainer = pResources;


							ASSERT(pNewContainer);
						}

						BOOL bNoScan = (strDir.Right(9).CompareNoCase("\\template")==0);	
						BOOL bExclude = (bNoScan || FileNameMatchesExtension(pDepFile->GetFilePath(), "odl;idl;c;cxx;cpp;rc;for;f90"));
						CFileItem * pFile = new CFileItem;
						pFile->SetFile(pDepFile->GetFilePath(), TRUE);
						if (bExclude)
							g_bExcludedNoWarning = TRUE;
						pFile->MoveInto(pNewContainer);

						if (bNoScan)
							pFile->SetIntProp(P_ItemExcludedFromScan, TRUE);
						if (bExclude)
						{
							g_bExcludedNoWarning = FALSE;
							int iSize = pTarget->GetPropBagCount();
							ASSERT(iSize);
							const CPtrArray * pArrayCfg = pTarget->GetConfigArray();
							for (int j = 0; j < iSize; j++)
							{
								ConfigurationRecord * pcr = (ConfigurationRecord *)(*pArrayCfg)[j]; 
								if (pcr->IsValid())
								{
									CProjTempConfigChange projTempConfigChange(pProject);
									projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
									pFile->SetIntProp(P_ItemExcludedFromBuild, TRUE);
									int idOldBag = pFile->UsePropertyBag(BaseBag);
									pFile->SetIntProp(P_ItemExcludedFromBuild, TRUE);
									(void) pFile->UsePropertyBag(idOldBag);

									// HACK: avoid adding to dep graph
									BOOL bSavedComp = pProject->m_bProjectComplete;
									pProject->m_bProjectComplete = TRUE;
									pFile->InformDependants(P_ItemExcludedFromBuild);
									pProject->m_bProjectComplete = bSavedComp;
								}
							}
						}
					}
					frh->ReleaseFRHRef();
					frh = NULL;
				}
			}
		}

		// VS98 #878: Make sure resource.h is put in project also
		CPath path; path.CreateFromDirAndFilename(GetProject()->GetWorkspaceDir(), _T("resource.h"));
		if ((pHeaders!=NULL) && (path.ExistsOnDisk()))
		{
			frh = pRegistry->LookupFile(path);
			if ((frh == NULL) || (!pTarget->IsFileInTarget(frh,TRUE)))
			{
				// not already in project
				CFileItem * pFile = new CFileItem;
				pFile->SetFile(&path, FALSE);
				pFile->MoveInto(pHeaders);
			}
			if (frh!= NULL)
			{
				frh->ReleaseFRHRef();
				frh = NULL;
			}
		}

		pTarget->RefreshAllMirroredDepCntrs();

#if 0	/* DISABLED: Empty groups left in project so user knows where to put these types of files. */
		//
		// Delete unused groups
		//
		if (NULL!=pHeaders && pHeaders->GetContentList()->IsEmpty())
			pHeaders->MoveInto(NULL);

		if (NULL!=pResources && pResources->GetContentList()->IsEmpty())
			pResources->MoveInto(NULL);
#endif
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------------- CProjGroup --------------------------------
//                                 
///////////////////////////////////////////////////////////////////////////////
//
//
#define theClass CProjGroup
BEGIN_SLOBPROP_MAP(CProjGroup, CProjContainer)
	STR_PROP(GroupName)
END_SLOBPROP_MAP()
#undef theClass

CProjGroup::CProjGroup ()
{
	VERIFY (m_strGroupName.LoadString (IDS_BASE_GROUP_NAME));

	// the Project Window icon inset
	m_nIconIdx = 1;
}

CProjGroup::CProjGroup (const TCHAR * pszName)
{
	m_strGroupName = pszName;

	// the Project Window icon inset
	m_nIconIdx = 1;
}

void CProjGroup::GetMoniker (CString& cs)
{
	ASSERT (!m_strGroupName.IsEmpty());
	cs = m_strGroupName;
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands
void CProjGroup::CmdAddFiles()
{
	DoAddFiles ( FALSE );
}

BOOL CProjGroup::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	AddPropertyPage(&g_GrpGeneralPage, this);

	if( bSetCaption )
		SetPropertyCaption(CString(MAKEINTRESOURCE(IDS_GROUP)));

	return TRUE;
}

BOOL CProjGroup::MakeGroupNameUnique(CString & strGroupName)
{
	CProject *pProject;
	CObList ol;
	POSITION pos;
	CProjGroup *pGroup;
	BOOL	bCollision;
	int i = 1;
	CString str;

	pProject = GetProject ();
	if (!pProject) return FALSE;
	pProject->FlattenSubtree ( ol, flt_Normal | flt_ExcludeDependencies );
	str = strGroupName;
	CString fmt, key;
	fmt.LoadString (IDS_GROUP_CUSTOMIZER);
	key.LoadString (IDS_GROUP_CUSTOMIZER_KEY);
	
	do
	{
		bCollision = FALSE;

		for (pos = ol.GetHeadPosition (); 
			 pos != NULL && !bCollision; )
		{
			pGroup = (CProjGroup *) ol.GetNext (pos);
			if (!pGroup->IsKindOf ( RUNTIME_CLASS ( CProjGroup )))
								continue;

			if (pGroup != this 
					&&
				CompareMonikers (pGroup->m_strGroupName, str)==0
				)
							bCollision = TRUE;
		}		

		if ( bCollision )
		{
			int n;

			// If it already ends in "No. #", strip it before adding it again
			if (((n = strGroupName.Find(LPCTSTR(key))) > 0)
				&& (n > (strGroupName.GetLength() - (key.GetLength() + 2))))
				strGroupName = strGroupName.Left(n);

			TCHAR * pc = str.GetBuffer (256);

			// Make sure there is enough space for the customizer:
			if (strGroupName.GetLength () > 255 - fmt.GetLength() -1 ) 
						strGroupName.ReleaseBuffer (255 - fmt.GetLength() -1 );
			_snprintf ( pc, 
						255, 
						(const TCHAR *) fmt, 
						(const TCHAR *) strGroupName,
						i );
			pc[255] = 0;							 
			str.ReleaseBuffer ();
 			i++; 
		}

	} while (bCollision);

	// Look at i to see if there ever was a collision:
	if (i > 1) 
		strGroupName = str;

	return (i > 1);
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjGroup::ReadInChildren(CMakFileReader& mr, const CDir &BaseDir)
{
//	Helper function to read in children from make file.  
	CObject *pObject = NULL;
	CProjItem *pItem = NULL, *pTemp;
	CRuntimeClass *pRTC;
	CMakComment *pMC;

	// Get the target to which this belongs, which is the first
	// target
	CProject * pProject = GetProject();
	CProjItem * pContainer = (CProjItem *)GetContainer();
	CTargetItem* pTarget = (CTargetItem *)GetTarget();
	CSlob * pSlob = (CSlob *)this;
;			
#if 1	// UNDONE: remove once we keep V2 groups
	if (pContainer->IsKindOf(RUNTIME_CLASS(CProject)))	// VC 2.0 makefile
	{
		CString strTargetName;
		((CProject *)pContainer)->InitTargetEnum();
		VERIFY(((CProject *)pContainer)->NextTargetEnum(strTargetName, pTarget));
		pSlob = (CSlob *)pTarget;
	}
#endif

	CSlob * pSavedSlob = pSlob;
	TRY
    {
		do
		{
			pSlob = pSavedSlob;

			VERIFY (pObject = mr.GetNextElement ());

			if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
					AfxThrowFileException (CFileException::generic);
			pMC = (CMakComment *) pObject;

			// done if this is the end marker
			if (IsEndToken (pObject)) break;

			// figure out what kind of item this is supposed to be and create it
			pRTC = GetRTCFromNamePrefix(((CMakComment *) pObject)->m_strText);

			if (pRTC == NULL)
			{  
				delete (pObject);
				pObject = NULL;
				continue;
			}

			pItem = (CProjItem *) pRTC->CreateObject();

			// make sure this is something that belongs in us
			if (!CanContain(pItem))
			{
				// REVIEW: possible for VC20 projects also?
				if ((pProject->m_bConvertedDS4x) && (pTarget->CanContain(pItem)))
				{
					pSlob = pTarget; // meant to add this to the target instead!
				}
				else
				{
						AfxThrowFileException (CFileException::generic);
				}
			}
			pTemp = pItem; pItem = NULL;


			// do a part of the move, ie. just fix up the containment structure
			// move into the target rather than the group, we'll delete this group
			// after we've finished reading the VC++ 2.0 makefile
			(void)pTemp->PreMoveItem(pSlob, FALSE, TRUE, FALSE);
			(void)pTemp->MoveItem(pSlob, (CSlob *)NULL, FALSE, TRUE, FALSE);

			mr.UngetElement (pObject);
			pObject = NULL;

			// preserve the current config. while we read in each child
			// to ensure that the child doesn't have the side-effect of 
			// changing this
			ConfigurationRecord * pcrProject = GetProject()->GetActiveConfig();

			// read in the item data
			if (!pTemp->ReadFromMakeFile (mr, BaseDir))
				AfxThrowFileException (CFileException::generic);

			// preserve the current config.
			(void) GetProject()->SetActiveConfig(pcrProject);

		} while (TRUE);

		if (pProject->m_bConvertedDS4x || (pProject->m_bProjConverted && (!pProject->m_bConvertedVC20) && (!pProject->m_bConvertedDS5x)))
		{
			ConvertDeps();
#if 0
			ConfigurationRecord* pcr;
			int nSize = m_ConfigArray.GetSize();
			for (int nConfig = 0; nConfig < nSize; nConfig++)
			{
				pcr = (ConfigurationRecord *)m_ConfigArray[nConfig];
				ForceConfigActive(pcr);
				RefreshDependencyContainer ();	// Show kids dependencies.
				ForceConfigActive();
			}
#endif
		}
	}
	CATCH (CException, e)
	{
		if (pObject) delete (pObject);
		if (pItem) 	 delete (pItem);
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}

BOOL CProjGroup::CanAdd ( CSlob* pSlob )
{
	if (g_Spawner.SpawnActive())
		return FALSE;

	if (pSlob->IsKindOf(RUNTIME_CLASS(CFileItem)))
		return TRUE;

	if (!pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		return CProjContainer::CanAdd(pSlob);

	CProjItem * pContainer = this;
	while ((pContainer != NULL) && (pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup))))
	{
		if (pContainer == (CProjItem *)pSlob)
			return FALSE; // can't add this group!!
		pContainer = (CProjItem *)pContainer->GetContainer();
	}
	return TRUE;
}

GPT CProjGroup::GetStrProp ( UINT idProp, CString &str )
{
	// special per-item props
	if (idProp == P_GroupDefaultFilter || idProp == P_FakeGroupFilter)
	{
		str = m_strDefaultExtensions;
		return valid;
	}
	// P_ProjItemName is a fake prop that just maps to P_GroupName.
	return CProjContainer::GetStrProp ((idProp == P_ProjItemName || idProp == P_FakeProjItemName) ? P_GroupName : idProp, str);
}

BOOL CProjGroup::SetStrProp ( UINT idProp,  const CString &str )
{
	BOOL bRetval;
	BOOL bNameChanged = FALSE;
	CString strChanged;
	if (idProp == P_ProjItemName || idProp == P_GroupName) 
	{
		if (str.IsEmpty())
		{
			MsgBox (Error, IDS_NO_EMPTY_GROUP) ;
			InformDependants(P_ProjItemName);
			return FALSE;
		}
	}

	// special per-item props
	if (idProp == P_GroupDefaultFilter)
	{
		m_strDefaultExtensions = str;
		return TRUE;
	}

	// If we're changing the group's name, make sure it's still unique:
	if (((idProp == P_ProjItemName) || (idProp == P_GroupName)) && (m_strGroupName.Compare(str)))
	{
		strChanged = str;
		bNameChanged = MakeGroupNameUnique(strChanged);
	}

	// P_ProjItemName is a fake prop that just maps to P_GroupName.
	bRetval = CProjContainer::SetStrProp ((idProp == P_ProjItemName) ? P_GroupName : idProp, (bNameChanged) ? strChanged : str);

	return bRetval;
}

BOOL CProjGroup::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// do the base-class thing
	if (!CProjContainer::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	if (pContainer == NULL) // just bail if deleted
		return TRUE;

#if 0
	// if that worked and not deleted, process content as well
	CProjItem * pItem;
	CObList * pGrpContents = GetContentList();
 	POSITION pos = pGrpContents->GetHeadPosition();
	if (pos != NULL)
	{
		theUndoSlob.Pause();
		while (pos != NULL)
		{
			pItem = (CProjItem *)pGrpContents->GetNext(pos);
			ASSERT(pItem);
			if (!pItem->PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged))
			{
				ASSERT(0);
				continue;
			}
		}
		theUndoSlob.Resume();
	}
#endif
	return TRUE;
}

BOOL CProjGroup::MoveItem(CSlob * pContainer, CSlob *pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// do the base-class thing
	if (!CProjContainer::MoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	if (pContainer == NULL) // just bail if deleted
		return TRUE;

#if 0
	// if that worked and not deleting, move the content as well
	CProjItem * pItem;
	CObList * pGrpContents = GetContentList();
 	POSITION pos = pGrpContents->GetHeadPosition();
	if (pos != NULL)
	{
		theUndoSlob.Pause();
		while (pos != NULL)
		{
			pItem = (CProjItem *)pGrpContents->GetNext(pos);
			ASSERT(pItem);
			if (!pItem->MoveItem(this, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
			{
				ASSERT(0);
				continue;
			}
		}
		theUndoSlob.Resume();
	}
#endif
	return TRUE;
}

BOOL CProjGroup::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// let the base-class do it's thing
	if (!CProjContainer::PostMoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	if (pContainer == NULL) // just bail if deleted
		return TRUE;

#if 0
	// if that worked, process content as well
	if ((GetProject()) && (GetProject()->m_bProjectComplete))
	{
		CProjItem * pItem;
		CObList * pGrpContents = GetContentList();
 		POSITION pos = pGrpContents->GetHeadPosition();
		if (pos != NULL)
		{
			theUndoSlob.Pause();
			while (pos != NULL)
			{
				pItem = (CProjItem *)pGrpContents->GetNext(pos);
				ASSERT(pItem);
				if (!pItem->PostMoveItem(this, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
				{
					ASSERT(0);
					continue;
				}
			}
			theUndoSlob.Resume();
		}
	}
#endif
	// if we are being moved into a new container, make sure there isn't a group
	// with our name already
	if (fToPrj)
	{
		CString strGroupName = m_strGroupName;
		if (MakeGroupNameUnique(strGroupName))
		{
			// this allows the undo slob to record name change
			SetStrProp(P_GroupName, strGroupName);
			InformDependants(P_GroupName);
		}

		// don't do this during project load
		if (GetProject()->m_bProjectComplete)
			RefreshAllMirroredDepCntrs();
	}

	return TRUE;	// success
}

BOOL CProjGroup::WriteToMakeFile
( 
	CMakFileWriter& pw, 
	CMakFileWriter& mw, 
	const CDir &BaseDir,
	CNameMunger& nm
)
{
	BOOL retval = TRUE;
	POSITION pos;
	const TCHAR *pc = GetNamePrefix (this);
	PFILE_TRACE ("CProjGroup at %p writing to CMakFileWriter at %p\n",
														this, &mw);
	if (g_bWriteProject)
	{
		// write group open comment
		// pw.WriteSeperatorString();
		pw.WriteCommentEx("Begin %s \"%s\"", pc, (const TCHAR *) m_strGroupName);
		pw.EndLine();
	}

	if (g_bWriteProject)
	{
#if 0
		if (!g_buildfile.WriteToolForNMake(this, &nm))
		{
			// failed to write tools section for this group
			ASSERT(0);
			retval = FALSE;
		}
#else
		// only allow common Group props for now
		WritePerItemProperties(pw);
#endif
	}

	// this will cause our content to get written in a predictable order
	SortContentList();

	pos = GetHeadPosition ();
	while (pos != NULL)
	{
		if (!((CProjItem *) GetNext (pos))->WriteToMakeFile(pw, mw, BaseDir, nm))
		{
			ASSERT(0);
			retval = FALSE;	// failed to write out group content
		}
	}

	if (g_bWriteProject)
	{
		// write group closing comment
		pw.WriteCommentEx ( "%s %s", EndToken, pc );
	}

	return retval;	// success
}

BOOL CProjGroup::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
//	Read in this item and any childred from a makfile reader.  The make
//  comment is the first line of our stuff:
//
	TCHAR *pBase;
	CObject *pObject = NULL;
	CString str;

	PFILE_TRACE ("CProjGroup at %p reading from CMakFileWriter at %p\n",
														this, &mr);

	TRY
    {
		pObject = mr.GetNextElement ();
		if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
				AfxThrowFileException (CFileException::generic);

		// Get our name from the comment:
		pBase =	((CMakComment*) pObject)->m_strText.GetBuffer (1);	

		// Skip over the "Begin":
		SkipWhite    (pBase);
		SkipNonWhite (pBase);
		SkipWhite    (pBase);
		// Skip over the Group declaration
		SkipNonWhite (pBase);
		SkipWhite    (pBase);
		

		// Make sure its quoted, and then shave the quotes off:
		if (*pBase++ != _T('"') ||
			((CMakComment*) pObject)->
				m_strText[((CMakComment*) pObject)->m_strText.GetLength()-1] != _T('"'))
		    AfxThrowFileException (CFileException::generic);

		m_cp = EndOfConfigs;
		str = pBase;
		str.ReleaseBuffer ( str.GetLength () - 1 );
		SetStrProp(P_ProjItemName, str);
		delete (pObject); pObject = NULL; 

		for (; pObject = mr.GetNextElement ();)
	   	{
			if (IsPropComment(pObject))
				continue;
			else if (IsAddSubtractComment(pObject))
				continue;
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) 
			{
				ReadConfigurationIfDef((CMakDirective *)pObject);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				SuckMacro((CMakMacro *)pObject, BaseDir);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				if (!SuckDescBlk((CMakDescBlk *)pObject))
					AfxThrowFileException (CFileException::generic);
			}
			// Comment marks start of children:
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment))) 
			{
				ASSERT(m_cp==EndOfConfigs);
				mr.UngetElement ( pObject );
				pObject = NULL;
				break;
			}
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakEndOfFile))) 
			{
				AfxThrowFileException (CFileException::generic);
			}

	   		delete (pObject); pObject = NULL;
		}				 

		// preserve the current config. while we read in each child
		// to ensure that the child doesn't have the side-effect of 
		// changing this
		ConfigurationRecord * pcrProject = GetProject()->GetActiveConfig();

		// Read in children:
		if (!ReadInChildren(mr, BaseDir))
 			AfxThrowFileException (CFileException::generic);

		// preserve the current config.
		(void) GetProject()->GetActiveConfig();
	}
	CATCH ( CException, e)
	{
		if (pObject) delete (pObject);
		return FALSE;	// failure
	}
	END_CATCH

	// do the rest of the move
	(void)PostMoveItem(GetContainer(), (CSlob *)NULL, FALSE, TRUE, FALSE);

	return TRUE;	// success
}

void CProjGroup::PrepareAddList(CMultiSlob* pAddList, BOOL bPasting)
{
	CMapPtrToPtr mapFileRegs;
	CProjItem * pItem, *pDupItem;
	CObList * pAddListContents = pAddList->GetContentList();
	CTargetItem * pTarget = GetTarget();
	ASSERT(pTarget);
 
 	FileRegHandle hndFileReg;
	CObList * pGrpContents = GetContentList();
	
 	POSITION pos = pGrpContents->GetHeadPosition();
	while (pos != NULL)
	{
		pItem = (CFileItem *) pGrpContents->GetNext(pos);
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			VERIFY(hndFileReg = pItem->GetFileRegHandle());
			mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
		}
	}
	// Now cycle through items to be added (backwards!) and eliminate any dupes
	pos = pAddListContents->GetTailPosition();
	while (pos != NULL)
	{
		pItem = (CProjItem *)pAddListContents->GetPrev(pos);
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			FileRegHandle hndFileReg = pItem->GetFileRegHandle();
			ASSERT(hndFileReg); // if in file reg, check if in this group
			if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pDupItem))
			{
				// new behaviour: duplicate: remove original, replace in map
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
				if (pDupItem->GetContainer()==this)
					{	// if removing an existing item, move into UndoSlob
						pDupItem->MoveInto(NULL);
					}
				else	// if dup is also from AddList, just delete it
					{
						theUndoSlob.Pause();
						pAddList->Remove(pDupItem);	// removes dependency
						delete pDupItem;			// prevent memory leaks
						theUndoSlob.Resume();
					}
			}
			else if (pTarget->IsFileInTarget(hndFileReg, TRUE))
			{
				// keep the original in this case
				theUndoSlob.Pause();
				pAddList->Remove(pItem);	// removes dependency
				delete pDupItem;			// prevent memory leaks
				theUndoSlob.Resume();
			}
			else
			{
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
			}
		}
		else if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			BOOL bReject = FALSE;
			CProjItem * pContainer = this;
			while ((pContainer != NULL) && (pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup))))
			{
				if (pContainer == pItem)
				{
					// can't add group to itself or its children
					theUndoSlob.Pause();
					pAddList->Remove(pItem);
					delete pItem;				// prevent memory leaks
					bReject = TRUE;
					theUndoSlob.Resume();
					break;
				}
				pContainer = (CProjItem *)pContainer->GetContainer();
			}
			// reject duplicates
			if (!bReject)
			{
				// reject duplicates in group content
				CObList ol;
				pItem->FlattenSubtree( ol, flt_Normal | flt_ExcludeProjects | flt_ExcludeGroups | flt_ExcludeDependencies | flt_RespectTargetExclude | flt_ExcludeProjDeps);
				POSITION pos = ol.GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					CFileRegSet * psetDep;

					// the contained project item
					CProjItem * pContainedItem = (CProjItem *)ol.GetNext(pos);
					ASSERT(pContainedItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
					if (!pContainedItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
						continue;

					FileRegHandle hndFileReg = pContainedItem->GetFileRegHandle();
					ASSERT(hndFileReg); // if in file reg, check if in this group
					if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pContainedItem))
					{
						theUndoSlob.Pause();
						pAddList->Remove(pContainedItem);	// removes dependency
						delete pItem;			// prevent memory leaks
						theUndoSlob.Resume();
					}
					else if (pTarget->IsFileInTarget(hndFileReg, TRUE))
					{
						theUndoSlob.Pause();
						pAddList->Remove(pContainedItem);	// removes dependency
						delete pItem;			// prevent memory leaks
						theUndoSlob.Resume();
					}
					else
					{
						mapFileRegs.SetAt((void *)hndFileReg, (void *)pContainedItem);
					}
				}
				ol.RemoveAll();
			}
		}
		else
		{
			// ignore all non-fileitems
			theUndoSlob.Pause();
			pAddList->Remove(pItem); 	// removes dependency
			delete pItem;				// prevent memory leaks
			theUndoSlob.Resume();
		}	
	}
}

BOOL CProjGroup::CanContain(CSlob* pSlob)
{
	if (pSlob->IsKindOf(RUNTIME_CLASS(CFileItem)) ||
	    pSlob->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		return TRUE;

	// FUTURE: allow CDependencyFiles (with conversion)

	if (pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)))
	{
		// need to ensure we're not dropping into a descendent
		const CSlob * pContainer;
		for (pContainer = GetContainer(); pContainer != NULL; pContainer = pContainer->GetContainer())
		{
			if (pContainer==pSlob)
				return FALSE;	// can't contain our parent
			else if (!pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup)))
				return TRUE;	// done if we've checked all groups
		}
		return TRUE; // okay if no container
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Drag and Drop support

void CProjGroup::PrepareDrop(CDragNDrop* pInfo)
{
	CSlob* pDragSlob;
 	
	pDragSlob = pInfo->m_dragSlob;

	CMapPtrToPtr mapFileRegs;
	CProjItem * pItem, * pDupItem;
	CObList * pAddListContents = pDragSlob->GetContentList();
	CTargetItem * pTarget = GetTarget();
	ASSERT(pTarget);

 	FileRegHandle hndFileReg;
	CObList * pGrpContents = GetContentList();
	
	ASSERT(!theUndoSlob.IsRecording());	// no need for pause/resume for Remove()

	CProject * pProject = (CProject *)GetContainer();	
	if (!pProject->AreFilesUnique(pDragSlob))
	{
		InformationBox(IDS_DUPES_IN_SELECTION);
	}

 	POSITION pos = pGrpContents->GetHeadPosition();
	while (pos != NULL)
	{
		pItem = (CFileItem *) pGrpContents->GetNext(pos);
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			VERIFY(hndFileReg = pItem->GetFileRegHandle());
			mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
		}
	}

	// Can't delete slobs just yet, so just keep track of which ones to
	// delete later in DoDrop()
	ASSERT(m_DeathRow.IsEmpty());

	// Now cycle through items to be added (backwards!) and reject any we can't drop
	pos = pAddListContents->GetTailPosition();
	while (pos != NULL)
	{
		pItem = (CProjItem *)pAddListContents->GetPrev(pos);
		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			FileRegHandle hndFileReg = pItem->GetFileRegHandle();
			ASSERT(hndFileReg); // if in file reg, check if in this group
			if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pDupItem))
			{
				// duplicate: remove from group
				if (pItem == pDupItem)
				{
					// Dropping into the same container
					// so we just remove from add list
					pDragSlob->Remove(pItem);
				}
				else
				{
					// replace duplicate with pItem
					if (pDupItem->GetContainer()==this)
					{
						// remove duplicate from group
						m_DeathRow.AddHead((void *)pDupItem);
					}
					else
					{
						// the dupe is something we were adding,
						// so we must remove it from the list
						pDragSlob->Remove(pDupItem);

						// only delete it if we're doing a move
						// or copying a clone
						if (pDupItem->GetContainer()==NULL)
						{
							delete pDupItem;	// delete clone	
						}
						else if (!pInfo->IsCopy())
						{
							m_DeathRow.AddHead((void *)pDupItem);
						}
					}
					mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
				}			
			}
			else if (pTarget->IsFileInTarget(hndFileReg, TRUE))
			{
				// keep the original in this case
				pDragSlob->Remove(pItem);
			}
			else
			{
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
			}
		}
		else if (pItem->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		{
			BOOL bReject = FALSE;
			CProjItem * pContainer = this;
			while ((pContainer != NULL) && (pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup))))
			{
				if (pContainer == pItem)
				{
					// can't add group to itself or its children
					pDragSlob->Remove(pItem);
					bReject = TRUE;
					break;
				}
				pContainer = (CProjItem *)pContainer->GetContainer();
			}
			if (!bReject)
			{
				// reject duplicates in group content
				CObList ol;
				pItem->FlattenSubtree( ol, flt_Normal | flt_ExcludeProjects | flt_ExcludeGroups | flt_ExcludeDependencies | flt_RespectTargetExclude | flt_ExcludeProjDeps);
				POSITION pos = ol.GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					CFileRegSet * psetDep;

					// the contained project item
					CProjItem * pContainedItem = (CProjItem *)ol.GetNext(pos);
					ASSERT(pContainedItem->IsKindOf(RUNTIME_CLASS(CFileItem)));
					if (!pContainedItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
						continue;

					FileRegHandle hndFileReg = pContainedItem->GetFileRegHandle();
					ASSERT(hndFileReg); // if in file reg, check if in this group
					if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pContainedItem))
					{
						m_DeathRow.AddHead((void *)pContainedItem);
					}
					else if (pTarget->IsFileInTarget(hndFileReg, TRUE))
					{
						m_DeathRow.AddHead((void *)pContainedItem);
					}
					else
					{
						mapFileRegs.SetAt((void *)hndFileReg, (void *)pContainedItem);
					}
				}
				ol.RemoveAll();
			}
		}
		else
		{
			// ignore all non-fileitems
			pDragSlob->Remove(pItem); 	// removes dependency
		}	
	}
}

CSlobDragger* CProjGroup::CreateDragger(CSlob* pDragObject, CPoint screenPoint)
{
	return new CProjDragger;
}

void CProjGroup::DoDrop(CSlob *pSlob, CSlobDragger *pDragger)
{
	// We are actually dropping some files onto a group

	CMultiSlob* pSelection;
	POSITION pos;
	pSelection = new CMultiSlob;

	// Remove any unneeded slobs identified in PrepareDrop()
	while (!m_DeathRow.IsEmpty())
	{
		((CSlob*)m_DeathRow.RemoveHead())->MoveInto(NULL);
	}

    GetBuildNode()->HoldUpdates();
	
	pos = pSlob->GetHeadPosition();
	while (pos != NULL)
	{
		CSlob* pItemSlob = pSlob->GetNext(pos);
		
		if (CanAdd(pItemSlob))
		{
			pItemSlob->MoveInto(this);
			pSelection->Add(pItemSlob);
		}
		else
		{
			pItemSlob->MoveInto(NULL);
		}
	}
		
	// Clear the current selection and then select the items that
	// have been dropped.
    // FUTURE (colint): Fix to work with new build view (but only if
    // we ever reincarnate this group code!!)
	// m_pPSWnd->UpdateSelection(pSelection);

	delete pSelection;

    GetBuildNode()->EnableUpdates();
}

void CProjGroup::DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint)
{
	pDragger->Show(TRUE);
}

BOOL CProjGroup::CanAct(ACTION_TYPE action)
{
	// no manipulating of groups while building
	if (g_Spawner.SpawnActive())
		return FALSE;

	return CProjContainer::CanAct(action);
}


#if 0 // defined inline
void CProjGroup::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	if (!(fo & flt_ExcludeGroups))
	{
		fAddItem = TRUE;
	}

	// Always consider contents regardless of whether we consider the
	// group node itself
	fAddContent = TRUE;
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
// -------------------------- CDependencyContainer ----------------------------
//
///////////////////////////////////////////////////////////////////////////////
#define theClass CDependencyContainer
BEGIN_SLOBPROP_MAP(CDependencyContainer, CProjContainer)
END_SLOBPROP_MAP()
#undef theClass

CDependencyContainer::CDependencyContainer()
{
	// the Project Window icon inset
	m_nIconIdx = 4;
}

void CDependencyContainer::GetMoniker( CString& cs) 
{
	cs = "dep";		// Only ever one of these in a group.
}

GPT CDependencyContainer::GetStrProp(UINT idProp, CString& val)
{
	// is this a fake prop?
	switch (idProp)
	{
		case P_ProjItemName:	// yes
			VERIFY(val.LoadString(IDS_EXT_DEPENDENCIES));
			return valid;
	}

	// no, pass on to base class
	return CProjContainer::GetStrProp(idProp, val);
}

BOOL CDependencyContainer::CanAdd ( CSlob *pAddSlob )
{
	// The user cannot add directly to the dependency container

	return FALSE;
}

BOOL CDependencyContainer::CanAct(ACTION_TYPE action)
{
	switch (action)
	{
	// refuse to be inserted into the undo slob since
	// we can disappear spontaneously.
	case act_insert_into_undo_slob:
		return FALSE;

	case act_drag:
	case act_drop:
	case act_delete:
	case act_cut:
	case act_copy:
	case act_paste:
		return FALSE;
	}

	return CProjContainer::CanAct(action);
}

BOOL CDependencyContainer::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	// no pages

	CProjContainer::SetupPropertyPages(pNewSel, FALSE);
	
	if( bSetCaption )
		SetPropertyCaption(CString(MAKEINTRESOURCE(IDS_DEPENDENCIES)));

	return TRUE;
}

BOOL CDependencyContainer::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// go down the project from pContainer to find where we should go.
	if (fToPrj)
	{
		CDependencyContainer * pOldDepCntr;

		if (pContainer->IsKindOf(RUNTIME_CLASS(CProjContainer)))
		{
			pOldDepCntr = ((CProjContainer *)pContainer)->GetDependencyContainer(FALSE);

			// an existing container?
			if (pOldDepCntr == (CSlob *)NULL)
				// no, do the base-class thing
				return CProjContainer::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged);

			// move into the old container
			pContainer = pOldDepCntr;
		}

		if (pContainer->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		{
			// move each member into the existing group
			POSITION pos = GetHeadPosition();

			while (pos != (POSITION)NULL)
				GetNext(pos)->MoveInto(pContainer);

			// we're no londer needed...
			pContainer = (CSlob *)NULL;
		}

	}

	// do the base-class thing
	return CProjContainer::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged);
}

BOOL CDependencyContainer::CanContain(CSlob * pSlob)
{
	if (pSlob->IsKindOf(RUNTIME_CLASS(CDependencyFile)))
		return TRUE;

	return FALSE;
}

void CDependencyContainer::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	if (!(fo & flt_ExcludeDependencies))
	{
		fAddItem = TRUE;
		fAddContent = TRUE;
	}
}

BOOL CDependencyContainer::IsValid(ConfigurationRecord * pcrBase /* = NULL */)
{
	// Get the base config of the active project and compare it to our pcrBase

	// Get the currently active project
	if (pcrBase == NULL)
	{
		CProject * pProject = g_pActiveProject;
		ASSERT(pProject);
		pcrBase = pProject->GetActiveConfig();
	}

 	return (pcrBase == m_pcrBase);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projcomp.cpp ===
//
//	PROJCOMP.CPP
//
//		Definition of interfaces defined in PROJCOMP.H
//
#include "stdafx.h"

#pragma hdrstop

#include "projcomp.h"

#include <prjapi.h>
#include <prjguid.h>

IMPLEMENT_DYNAMIC (COutputWinEC, CErrorContext)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

static BOOL g_fUserStoppedBuild = FALSE;
HANDLE g_hStdIn = NULL;
extern BOOL g_bHTMLLog;

///////////////////////////////////////////////////////////////////////////////

CVPROJIdeInterface::CVPROJIdeInterface()
{
	m_pEditDebugStatus = NULL;
	m_pOutputWindow = NULL;
	m_pDLLInfo = NULL;
}

CVPROJIdeInterface::~CVPROJIdeInterface()
{
}

BOOL CVPROJIdeInterface::Initialize()
{
	if (theApp.m_bInvokedCommandLine)
		return FALSE;

	VERIFY(GetEditDebugStatus());
	VERIFY(GetOutputWindow());
	GetDLLInfo();
	return((m_pEditDebugStatus != NULL) && (m_pOutputWindow != NULL) /* && (m_pDLLInfo != NULL) */);
}

void CVPROJIdeInterface::Terminate()
{
	ReleaseEditDebugStatus();
	ReleaseOutputWindow();
	ReleaseDLLInfo();
}

CVPROJIdeInterface g_VPROJIdeInterface;
CSpawner g_Spawner;

//	Yield callback function passed to the IDE:
BOOL YieldFunction ()
{
	return theApp.IdleAndPump ();
}
///////////////////////////////////////////////////////////////////////////////
CSpawner::CSpawner()
{
	m_pSpawner = NULL;
	m_InitCount = 0;
	m_bBuildTerminated = FALSE;
}

BOOL CSpawner::CanSpawn()
{
	return(m_pSpawner == NULL);
}

COutputWinEC *CSpawner::InitSpawn(BOOL bClear /* = TRUE */)
{
	m_bBuildTerminated = FALSE;
	m_fClear = FALSE; // bClear;
	m_dwProjError = m_dwProjWarning = 0;
	m_dwFileErrors = m_dwFileWarnings = 0;
	if (!theApp.m_bInvokedCommandLine)
	{
		VERIFY(SUCCEEDED(g_VPROJIdeInterface.GetOutputWindow()->OwinGetBuildCommandID(&m_nOutputWindowID)));
		ASSERT(m_nOutputWindowID != -1);
	}
	else
	{
		m_nOutputWindowID = 0;
	}


	if ((theApp.m_bInvokedCommandLine) && (!g_hStdIn))
	{
		g_hStdIn = ::GetStdHandle(STD_INPUT_HANDLE);
	}

	if (!m_InitCount)
	{
		LPSOURCECONTROLSTATUS pInterface;
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)));
		BOOL bIsSccInstalled = (pInterface->IsSccInstalled() == S_OK);
		pInterface->Release();
		LPSOURCECONTROL pSccManager;
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
		if (bIsSccInstalled) pSccManager->Enable(FALSE);
		pSccManager->Release();

		// our COMSPEC environment variable
		_tcscpy(m_szComspec, NotOnNT() ? "command.com" : "cmd.exe");
		TCHAR * szEnvStr;
		if (szEnvStr = getenv("COMSPEC"))
		{
			// use this and normalise
			(void) _tcscpy(m_szComspec, szEnvStr);
			(void) _tcslwr(m_szComspec);
		}
		  
		if (!theApp.m_bInvokedCommandLine)
		{
			if (bClear)
			{
				g_VPROJIdeInterface.GetOutputWindow()->OutputWindowVwinClear(m_nOutputWindowID);
				// note: window not actually cleared until subsequent SelectVwin call
			}
			// selected output window is brought to the top (and optionally cleared)
			g_VPROJIdeInterface.GetOutputWindow()->OutputWindowSelectVwin(m_nOutputWindowID, TRUE);
		}

		m_InitCount++;
	}

	return (COutputWinEC *)g_buildengine.OutputWinEC();
}

// implemented in project.cpp
extern void GetFirstFile(CString &, CString &, CString &);

#define szVCSpawnEchoCmd	TEXT("~vcecho!")
#define szVCSpawnTimeCmd	TEXT("~vctime!")
#define szVCSpawnSleepCmd	TEXT("~vcsleep!")

// Note the the integer error codes returned by this function are
// actually  exit codes of NTSPAWN.  Look there is you want to know
// what they mean.
int CSpawner::DoSpawn(CPtrList &plCmds, CDir &dir, BOOL fCheckForComspec, BOOL fIgnoreErrors, CErrorContext &EC, BOOL fAsyncSpawn)
{
	// create the spawner object here--InitSpawn() not called for every DoSpawn()
	ASSERT(m_pSpawner == NULL);
	m_pSpawner = new CConsoleSpawner(&m_pSpawner);

	VERIFY(m_pSpawner->InitializeSpawn((LPTSTR)(LPCTSTR)dir, m_nOutputWindowID, m_fClear, FALSE, &EC));
	m_fClear = FALSE;

    // Just join all the lists together for now.
	// NOTE this must be changed to support parrallel stuff.
	int nCount=0;
	POSITION pos1 = plCmds.GetHeadPosition();
    while(pos1){
		CCmdLine *pCmdLine =(CCmdLine *)plCmds.GetNext(pos1);
		nCount += pCmdLine->slCommandLines.GetCount();
	}	

	// anything to do?
	if (nCount == 0)
		return 0;	// ol

	// ASSERT(slCmds.GetCount() == slDesc.GetCount());
	ASSERT(!fIgnoreErrors);	// not supported

	// two words
	// - loword == return value
	// - hiword == command that returned the value
	int nRetval = 0;
	int iCmd = 1;

	CStringList slSpawnCmds;
	CString strDescLine;

	POSITION pos2 = plCmds.GetHeadPosition();
    while(pos2){
		CCmdLine *pCmdLine =(CCmdLine *)plCmds.GetNext(pos2);
		CStringList &slCmds = pCmdLine->slCommandLines;
		CStringList &slDesc = pCmdLine->slDescriptions;
		POSITION posCmd = slCmds.GetHeadPosition();
		POSITION posDesc = slDesc.GetHeadPosition();
		while (posCmd != (POSITION)NULL)
		{
			CString & strCmdLine = slCmds.GetNext(posCmd);
	
			// check to see if we need to prefix with a comspec?
			if (fCheckForComspec)
			{
				// found this command?
				BOOL fGotPath;
	
				// split into command and arguments
				CString strCaller, strArgs;
				GetFirstFile(strCmdLine, strCaller, strArgs);
	
				TCHAR * psz, szCmdPath[_MAX_PATH + 1];
				if (!(fGotPath = SearchPath(NULL, (const TCHAR *)strCaller, _TEXT(".exe"), _MAX_PATH, szCmdPath, &psz)))
						// we failed, so just use the name
						_tcscpy(szCmdPath, (const TCHAR *)strCaller);
	
				// normalize
				// (void) _tcslwr(szCmdPath);
	
				// is this a GUI command? (assume no if not found)
				BOOL fIsGUI = FALSE;
				BOOL fUseComSpec = TRUE;
				if (fGotPath)
				{
					WORD wSubSystem;
					WORD wExeType = GetExeType(szCmdPath, &wSubSystem);
	
					fIsGUI = wExeType == EXE_WIN || ((wExeType == EXE_NT) && (wSubSystem == IMAGE_SUBSYSTEM_WINDOWS_GUI));
					fUseComSpec = wExeType == EXE_NONE || wExeType == EXE_FAIL;
				}
	
				// make sure not executing command shell
				BOOL fIsShell = FALSE;
				if (!fIsGUI)
				{
					CPath pathComspec;
					if (pathComspec.Create(m_szComspec))
					{
						TCHAR szCmdPathTmp[_MAX_PATH + 1];
	
						_tcscpy(szCmdPathTmp, szCmdPath);
						_tcslwr(szCmdPathTmp);
						fIsShell = _tcsstr(szCmdPathTmp, (const TCHAR *)pathComspec) != (const TCHAR *)NULL;
						fUseComSpec = fUseComSpec && !fIsShell;
					}
				}
	
				// use the command-spec if we have re-direction chars.
				fUseComSpec = fUseComSpec || (strCmdLine.FindOneOf(_TEXT("<>|&^")) != -1);
	
				// don't allow spawning just the shell!
				if (fIsShell && strArgs.IsEmpty())
				{
					// fail the execute
					// make a note + index of command for multi-commands
					nRetval = 1 | (iCmd << 16);
				}
	
				// need to prefix with comspec?
				else if (fUseComSpec)
				{
					// re-construct our command-line
					strCmdLine = m_szComspec;
					strCmdLine += _TEXT(" /c ");
					strCmdLine += szCmdPath;
					strCmdLine += _TEXT(" ");
					strCmdLine += strArgs;
				}
			}
	
			// index of the next command
			iCmd += 2;

			// hack for Win95 FAT16 timing problems
			if (pCmdLine->bDelay)
				slSpawnCmds.AddTail(szVCSpawnSleepCmd);
	
			// add the description
			// as '~vcecho<desc>'
			strDescLine = szVCSpawnEchoCmd;
			strDescLine += slDesc.GetNext(posDesc);
			slSpawnCmds.AddTail(strDescLine);
	
			// add the command
			slSpawnCmds.AddTail(strCmdLine);
	
			// make sure we show spawn-time if /Y3
			if (g_bSpawnTime)
				slSpawnCmds.AddTail(szVCSpawnTimeCmd);
		}
		delete pCmdLine;
	}	

	BOOL bUserCancel = FALSE;
	BOOL bSpawnFailed = FALSE;
	g_fUserStoppedBuild = FALSE;
	// already failed the execute in pre-check above?
	if (!nRetval)
	{
#if defined(_DEBUG)
		// message so we de-lineate our vcspawns
		if (g_bSpawnTime)
			EC.AddString(_TEXT("Spawning 'vcspawn'...\n"));
#endif
		m_pSpawner->m_hNotifyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!m_pSpawner->PerformSpawnMultiple(&slSpawnCmds))
		{
			ASSERT(FALSE);  // Spawner failed!
			m_dwFileErrors += 1;
			bSpawnFailed = TRUE;
		}
		else
		{
			if (fAsyncSpawn)
				theApp.IdleAndPump (m_pSpawner->m_hNotifyEvent);
			else  {
				while (WaitForSingleObject (m_pSpawner->m_hNotifyEvent, 0) == WAIT_TIMEOUT ) 
				{
					MSG msg;
					AfxGetApp ()->DoWaitCursor (1);
					Sleep (1000 / 10);		// 1/10th second
					// If a whole ton of output is coming back from
					// the spawned process, then our Output window code is going to
					// set a timer in order to have the main thread dequeue some
					// of the strings, and then it's going to block.  This
					// produces a deadlock situation.  To hack around this, while
					// we're waiting we dequeue all WM_TIMER messages.
					while (PeekMessage (&msg, 0, WM_TIMER, WM_TIMER, PM_REMOVE))
					{
						if (!theApp.PreTranslateMessage (&msg))
							DispatchMessage (&msg);
					}
				}
			}
			nRetval = m_pSpawner->m_dwTermStatus;
			// check to see if user cancelled the build
			if (WaitForSingleObject(m_pSpawner->m_hCancelEvent, 0) == WAIT_OBJECT_0)
				bUserCancel = TRUE;
			
			ULONG errors = 0;
			ULONG warnings = 0;
			m_pSpawner->GetErrorWarningCount(&errors, &warnings);
			m_dwFileErrors += errors;
			m_dwFileWarnings +=warnings;

			HANDLE hProcess = GetCurrentProcess();
			HANDLE hThread;
			VERIFY(DuplicateHandle(hProcess, m_pSpawner->m_hWaitThread, hProcess,
				&hThread, DUPLICATE_SAME_ACCESS, TRUE, DUPLICATE_SAME_ACCESS));
			SetEvent(m_pSpawner->m_hCleanEvent);
			WaitForSingleObject(hThread, INFINITE);
			VERIFY(CloseHandle(hThread));
			if( g_fUserStoppedBuild ){
				m_InitCount=0;
			}
		}
	}

	// unpack return value and index of command that failed
	// for multiple commands
	iCmd = (int)((nRetval >> 16) & 0xffff);
	nRetval = (int)(short)(nRetval & 0xffff);

	// why did we fail the execute?
	POSITION pos = slSpawnCmds.FindIndex(iCmd);
	if (nRetval && pos != (POSITION)NULL)
	{
		CString & strCmdLine = slSpawnCmds.GetAt(pos);

		// Get end of exe name:
		const TCHAR * pchCmdLine = (const TCHAR *)strCmdLine;
		unsigned short nExeNameLen = 0;
		const TCHAR * pchEndQuote = 0;
		if (pchCmdLine[0] == '"' && GetQuotedString(pchCmdLine, pchEndQuote)) {
			// ENC: handle quoted commands that may contain spaces
			// 12/22/97 georgiop [vs98 23180]
			nExeNameLen = pchEndQuote - pchCmdLine;
		}
		else while (pchCmdLine[nExeNameLen] != _T('\0') &&
			   !_istspace(pchCmdLine[nExeNameLen])
			  )
		{
			nExeNameLen++;
		}

		// load the error string
		UINT nIDError;
		if (nRetval == -1)
			nIDError = IDS_FAIL_SPAWN;
		else if (bUserCancel)
			nIDError = IDS_TERMINATE_USER_REQ;
		else
			nIDError = IDS_FAIL_EXECUTE;

		CString strErr;
		VERIFY(strErr.LoadString(nIDError));
			
		// format the error message
		TCHAR buf[512];
		_snprintf(buf, 512, strErr, nExeNameLen, nExeNameLen, pchCmdLine);

		g_fUserStoppedBuild = FALSE;
		EC.AddString(buf);
	}
	else if (bSpawnFailed)
	{
		CString strErr;
		VERIFY(strErr.LoadString(IDS_FAIL_VCSPAWN));
		EC.AddString(strErr);
	}

	if (bUserCancel)
		nRetval = -2;

	g_fUserStoppedBuild = FALSE;
	return nRetval;
}

void CSpawner::TermSpawn()
{
//	Called at end of spawning session.
	if (--m_InitCount > 0) return;

	m_InitCount = 0;

	LPSOURCECONTROLSTATUS pInterface;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)));
	BOOL bIsSccInstalled = (pInterface->IsSccInstalled() == S_OK);
	pInterface->Release();
	LPSOURCECONTROL pSccManager;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
	if (bIsSccInstalled) pSccManager->Enable(TRUE);
	pSccManager->Release();
}

void CSpawner::DoSpawnCancel()
{
	m_bBuildTerminated = TRUE;

	ASSERT(m_pSpawner != NULL);
	g_fUserStoppedBuild = TRUE;
	m_pSpawner->CancelSpawn();

	LPSOURCECONTROLSTATUS pInterface;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)));
	BOOL bIsSccInstalled = (pInterface->IsSccInstalled() == S_OK);
	pInterface->Release();
	LPSOURCECONTROL pSccManager;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
	if (bIsSccInstalled) pSccManager->Enable(TRUE);
	pSccManager->Release();
}

void CSpawner::ReInitSpawn ()
{
//	Called after DoSpawnCancel to reinitialise the
//	cancelled spawner
	m_bBuildTerminated = FALSE;

	m_InitCount = 1;

	LPSOURCECONTROLSTATUS pInterface;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)));
	BOOL bIsSccInstalled = (pInterface->IsSccInstalled() == S_OK);
	pInterface->Release();
	LPSOURCECONTROL pSccManager;
	VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
	if (bIsSccInstalled) pSccManager->Enable(FALSE);
	pSccManager->Release();
}

void CSpawner::GetErrorCount(DWORD &dwErrCnt, DWORD &dwWarnCnt)
{
	dwErrCnt = m_dwProjError + m_dwFileErrors;
	dwWarnCnt = m_dwProjWarning + m_dwFileWarnings;
}

EXEFROM CSpawner::GetExecutableFilename(PSTR strName, UINT size)
{
	if (!g_VPROJIdeInterface.Initialize())
		return exefromNone;

	EXEFROM exefrom;
	VERIFY(SUCCEEDED(g_VPROJIdeInterface.GetEditDebugStatus()->GetExecutableFilename(strName, size, &exefrom)));
	return(exefrom);
}

BOOL CSpawner::IsSaveBeforeRunningTools(BOOL *pbQuery)
{
	if (!g_VPROJIdeInterface.Initialize())
		return FALSE;

	return(g_VPROJIdeInterface.GetEditDebugStatus()->IsSaveBeforeRunningTools(pbQuery) == S_OK);
}

CDocument * CSpawner::GetLastDocWin()
{
	if (!g_VPROJIdeInterface.Initialize())
		return NULL;

	CDocument *pDoc;
	VERIFY(SUCCEEDED(g_VPROJIdeInterface.GetEditDebugStatus()->GetLastDocWin(&pDoc)));
	return(pDoc);
}

void CSpawner::WriteStringToOutputWindow(const char *pchar, BOOL bToolError /*= FALSE*/, BOOL bAddCtlLF /*= TRUE*/)
{
	if (theApp.m_bInvokedCommandLine)
	{
		theApp.WriteLog(pchar, bAddCtlLF);
	}
	else
	{
		VERIFY(SUCCEEDED(g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(pchar, bToolError, bAddCtlLF)));
	}
}

void CSpawner::WriteStringToOutputWindow(UINT id)
{
	CString str;
	VERIFY(str.LoadString(id));
	if (theApp.m_bInvokedCommandLine)
	{
		theApp.WriteLog(str, TRUE);
	}
	else
	{
		VERIFY(SUCCEEDED(g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(str, FALSE, TRUE)));
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------ COutputWinEC --------------------------------
//
///////////////////////////////////////////////////////////////////////////////
// An error context for writing to the output window through the CVPROJIdeInterface:
#define MAX_OUTPUT  249		// Max chars debugger can show in output window

void COutputWinEC::AddString ( const TCHAR *pstr )
{
	// write to the output log if there is one.
	LogTrace( "%s\n", pstr );
	
	if (g_fUserStoppedBuild)
		return;

	if (theApp.m_bInvokedCommandLine)
	{
        if (*pstr)
        {
            if (*pstr != '\n')
            {
                theApp.WriteLog(pstr, TRUE);
            }
			else
			{
				theApp.WriteLog("", TRUE);
			}
        }

		// poll stdin for a ctrl-C; stop build if found
		char buffer[80];
		DWORD i, nBytesRead, nBytesAvail, nBytesLeft;
		if ((g_hStdIn != NULL) && (::PeekNamedPipe(g_hStdIn, buffer, 1, &nBytesRead, &nBytesAvail, &nBytesLeft)) && (nBytesRead > 0))

		{
			if (nBytesAvail > 80)
				nBytesAvail = 80;

			if (::ReadFile(g_hStdIn, buffer, nBytesAvail, &nBytesRead, NULL))
			{
				for (i = 0; i < nBytesRead; i++)
				{
					if (buffer[i] == '')
					{
						AfxGetMainWnd()->PostMessage(WM_COMMAND, IDM_PROJECT_STOP_BUILD);
						break;
					}
				}
			}
		}
		return;

	}

	TCHAR buf [MAX_OUTPUT+1];
	int i;
	// The Outout window doesn't handle returns very well, so eat
	// return/linefeed pairs and genrate multiple lines:
	while (*pstr)
	{
		i =0;
		while (*pstr && *pstr != 0x0A && *pstr != 0x0D && i < MAX_OUTPUT)
		{
		#ifdef _MBCS
			if (IsDBCSLeadByte((BYTE)*pstr))
							buf[i++] = *pstr++;
			ASSERT (*pstr);	// Second byte shouldn't be null;
		#endif
			buf[i++] = *pstr++;
		}
		buf[i]	= 0;
		VERIFY(SUCCEEDED(g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(buf, TRUE, TRUE)));
		while (*pstr && (*pstr == 0x0A || *pstr == 0x0D) ) 	pstr++;
	}
}

void COutputWinEC::AddString ( UINT ResID )
{
	if (g_fUserStoppedBuild)
		return;

	CString str;
	if (str.LoadString (ResID))
	{
		if (theApp.m_bInvokedCommandLine)
		{
			theApp.WriteLog(str, TRUE);
		}
		else
		{
			VERIFY(SUCCEEDED(g_VPROJIdeInterface.GetOutputWindow()->WriteStringToOutputWindow(str, TRUE, TRUE)));
		}
	}
	else TRACE ("CStorageEC::AddString failed to load string %i\n", ResID );
};

///////////////////////////////////////////////////////////////////////////////
// Log helpers:
#ifdef PROJ_LOG
FILE *g_pLogFile = NULL;
void OpenProjLog(CProject *pProject)
{
	if (g_pLogFile != NULL) return;	// Alread open
	if( g_bWriteBuildLog == FALSE )
		return;

	const CPath *pPath = pProject->GetFilePath();
	CPath FilePath;
	ASSERT (pPath);
	FilePath = *pPath;
	FilePath.ChangeExtension ("plg");
	if ((g_pLogFile = fopen( (const TCHAR *) FilePath, _TEXT("w+t"))) == NULL )
	{
		TRACE ("Opening project log file %s failed\n", (const TCHAR *) FilePath);
		return;
	}
	else
	{
		CString strHeader;
		if( g_bHTMLLog )
			strHeader.LoadString(IDS_HTML_HEADER);
		else
			strHeader.LoadString(IDS_NORMAL_HEADER);
		
		// LogTrace("<html>\n<body>\n<pre>\n<h1>BuildLog</h1>\n");
		LogTrace(strHeader);
	}
}
void CloseProjLog	()
{
	if (!g_pLogFile) return;

	if( g_bHTMLLog ){
		CString strFooter;
		strFooter.LoadString(IDS_HTML_FOOTER);
		LogTrace(strFooter);
	}

	fclose (g_pLogFile);
	g_pLogFile = NULL;
}

#define DBG_BUFSIZE 2048
#define MAX_DBG_BUFSIZE (512*DBG_BUFSIZE)	// 1 meg worth.

void CDECL LogTrace(LPCSTR pszFormat, ...)
{
	int nWritten = -1;
	int nBuf = DBG_BUFSIZE;
	LPTSTR szBuffer = NULL;
	if( g_bWriteBuildLog == FALSE )
		return;

	const TCHAR* pszLocalFormat;

	if (!g_pLogFile) return;   	

	pszLocalFormat = pszFormat;

	va_list args;
	va_start(args, pszFormat);

	//
	// reallocate buffer, write into buffer, loop while buffer too small.
	//
	for (nBuf=DBG_BUFSIZE; -1==nWritten && MAX_DBG_BUFSIZE >= nBuf; nBuf *= 2)
	{
		// reallocate
		delete szBuffer;
		szBuffer = new TCHAR[nBuf];
		if (NULL==szBuffer)
			break;

		//
		// Returns -1 if buffer is too small.
		//
		nWritten = _vsnprintf(szBuffer, nBuf, pszLocalFormat, args);
		szBuffer[nBuf-1] = 0;
		ASSERT(nWritten <= nBuf);
	}

	if (szBuffer==NULL)
	{
		if (fputs ("\nError writing log file\n", g_pLogFile) == EOF)
			CloseProjLog();
	}
	else
	{
		if (fputs (szBuffer, g_pLogFile) == EOF)
			CloseProjLog();

		if (-1==nWritten && fputs ("\nSome information just truncated in log file\n", g_pLogFile) == EOF)
			CloseProjLog();

		delete szBuffer;
	}

	va_end(args);
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
// ------------------------------- CTempMaker ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////

CTempMaker::~CTempMaker ()
{
	ASSERT (m_Files.IsEmpty ());
}

BOOL CTempMaker::CreateTempFile (
					CStdioFile *&pFile,
					CPath &rPath,
					CErrorContext& EC, /*=g_DummyEC*/
					BOOL fBatFile /* =FALSE */
					)
{
	TCHAR buf[MAX_PATH *  sizeof (TCHAR)];
	CFileException e;

	// Get the temp path if we don't alread have it:
	if (m_Files.IsEmpty())
	{
		if (!m_DirTempPath.CreateTemporaryName () )
		{
			EC.AddString ( IDS_COULD_NOT_GET_TEMP_PATH );
			// OS call failed, use CWD:
			if (!m_DirTempPath.CreateFromCurrent ())
			{
				EC.AddString ( IDS_COULD_NOT_GET_CWD );
				return FALSE;
			}
		}
	}

	if ( (::GetTempFileName ( (const TCHAR *) m_DirTempPath,_TEXT ("RSP"), 0, buf ) == 0)  || 
		 !rPath.Create ( buf )
	   )
	{
		
		EC.AddString ( IDS_COULD_NOT_GET_TEMP_NAME );
		return FALSE;
	}

	DWORD fOpen = CFile::modeWrite | CFile::typeText;
	if( fBatFile ){
		CStdioFile *pTFile = new CStdioFile;
		pTFile->Open ((const TCHAR *) rPath, fOpen , &e);
		pTFile->Close();
		m_Files.SetAt ( rPath, pTFile );

		rPath.ChangeExtension( ".bat" );
		fOpen |= CFile::modeCreate;
	}

	pFile = new CStdioFile;	

	if ( !pFile->Open ((const TCHAR *) rPath, fOpen , &e) )
	{
		CString str;
		EC.AddString (MsgText ( str, rPath, IDS_COULD_NOT_OPEN_TEMP_FILE, &e));
		delete (pFile);
		return FALSE;
	}

	m_Files.SetAt ( rPath, pFile );
	return TRUE;
}	

// Remove all the files from disk:
void CTempMaker::NukeFiles (CErrorContext& EC/*=g_DummyEC*/)
{
	CPath cp;
	POSITION pos;
	CStdioFile *pFile;

	for (pos = m_Files.GetStartPosition (); pos != NULL; )
	{
		m_Files.GetNextAssoc ( pos, cp, (CObject *&) pFile );

		// Check that the file has alread been closed:
	   	ASSERT (pFile->m_hFile == (UINT) CFile::hFileNull);
	   	delete (pFile);

		if (!::DeleteFile ( (const TCHAR *) cp ))
		{
			CString str;
			DWORD lOsError = ::GetLastError ();
			CFileException e(CFileException::OsErrorToException(lOsError),
				lOsError);
			EC.AddString (
				::MsgText ( str, cp, IDS_COULD_NOT_DELETE_TEMP_FILE, &e)
				);
		}
	}
	m_Files.RemoveAll ();
}

BOOL CTempMaker::CreateTempFileFromString (	
					CString& str,
					CPath &rPath,
					CErrorContext& EC,/*=g_DummyEC*/
					BOOL fBatFile
					)
{
	CStdioFile *pFile;
	if (!CreateTempFile ( pFile, rPath, EC, fBatFile )) return FALSE;
	BOOL bRetval;
	#ifdef PROJ_LOG
	CString strCreate;
	strCreate.LoadString(IDS_CREATING_TEMPFILE);

	PBUILD_TRACE ((const TCHAR *)strCreate,
			(const TCHAR *)	rPath,
			(const TCHAR *) str
			);
	#endif
	TRY
	{
		pFile->WriteString ( str );
		pFile->Close ();
		bRetval = TRUE;
	}
	CATCH_ALL (e)
	{
		#ifdef PROJ_LOG
		PBUILD_TRACE ("Creating temp file failed!!\n");
		#endif

		bRetval = FALSE;
		pFile->Abort ();
	}
	END_CATCH_ALL
   	return bRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projdep.h ===
///////////////////////////////////////////////////////////////////////////////
//
//	CProjectDependency
//
///////////////////////////////////////////////////////////////////////////////

#ifndef __PROJECTDEP__
#define __PROJECTDEP__

class BLD_IFACE CProjectDependency : public CProjItem
{
	DECLARE_SERIAL (CProjectDependency)

protected:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

	//	File item commands
	//{{AFX_MSG(CFileItem)
	afx_msg void OnOpen();
	//}}AFX_MSG(CFileItem)

public:
	CProjectDependency();
	virtual ~CProjectDependency(); 

	virtual BOOL SetStrProp (UINT idProp, const CString &str);
	virtual GPT GetStrProp(UINT nIDProp, CString & val);

	// hooks to add as a dependent on the target we reference so we track changes in target name
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	 	
	virtual BOOL UsesSourceTool () {return TRUE;}

	virtual void FlattenQuery(int fo, BOOL& bAddContent, BOOL& fAddItem);
 
	// .MAK reading and writing
	virtual BOOL WriteToMakeFile(CMakFileWriter& pw, CMakFileWriter& mw, const CDir &BaseDir, CNameMunger& nm);
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);
	void CProjectDependency::WriteRule( BOOL bClean, CMakFileWriter& mw, const CDir &BaseDir );


 	virtual BOOL CanAct(ACTION_TYPE action);
	virtual BOOL PreAct(ACTION_TYPE action);

	__inline void SetProjectDep(CTargetItem * pTarget, LPCTSTR pszTarget = NULL) { m_pTarget = pTarget; if (pszTarget) m_strName = pszTarget; }
	__inline CTargetItem * GetProjectDep() { return m_pTarget; }
	ConfigurationRecord* GetTargetConfig();
	ConfigurationRecord* GetCompatibleTargetConfig(ConfigurationRecord *);

//protected:
	
	// Return a container-less, symbol-less, clone of 'this'
	virtual CSlob* Clone();

private:
	// Makefile reading/writing support
	static const TCHAR *pcDepPrefix;

	BOOL IsDepComment(CObject*& pObject);

	CTargetItem	*	m_pTarget;	// Target we depend upon
	CString m_strName;			// Name of target
	DECLARE_SLOBPROP_MAP()
};

class CProjDepInfo {
public:
	CProjectDependency *	pProjDep;
	CString					strProject;
	CString					strTarget;
};

extern CPtrList g_lstprojdeps;

CProjDepInfo * AddDep( CString strTop, CString strSub, CProjectDependency *pProjectDep );
CProjDepInfo * AddDep( CProjectDependency *pProjectDep );
BOOL RemoveDep( CString strTop, CString strSub );
BOOL RemoveDep(  CProjectDependency *pProjDep  );
void GetSubProjects( CString &strTop, CStringList &listSub );
BOOL IsReachable(CString &strTop, CString &strSeek);
void InitWorkspaceDeps( void );
BOOL RemoveAllReferences( CString strProj );


#endif	// __PROJECTDEP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projcomp.h ===
//
//	PROJCOMP.H
//
//			Intefaces for starting build tools and accessing the IDE.
//
#ifndef _PROJCOMP_H_
#define _PROJCOMP_H_

#ifndef _SUSHI_PROJECT
// If you are encluding this in a file that is being compiled under
// WIN16, either make sure everything compiles under WIN16 and remove
// this error, or include conditional on _SUSHI_PROJECT.
//
#error This code may not be Win 3.1 compatible.
#endif

#include "dllgrid.h"

#include <utilbld_.h>

#include <srcapi.h>
#include <srcguid.h>
#include <dbgpkapi.h>
#include <dbgpguid.h>

class COutputWinEC;

///////////////////////////////////////////////////////////////////////////////
//
//	Class for spawning a process and invoking a tool.  Also, this is the global
//	reposititory about building/spawning state information:  
//
class CSpawner 
{
public:
	CSpawner();

	BOOL CanSpawn ();

	//	Calls InitSpawn down in the IDE
	COutputWinEC * InitSpawn(BOOL bClear = TRUE);
	int DoSpawn
	(
		CPtrList & plCmds,
		CDir & dir,
		BOOL fCheckForComspec = FALSE,
		BOOL fIgnoreErrors = FALSE,
		CErrorContext & EC = g_DummyEC,
		BOOL fAsyncSpawn = TRUE
	);

	void TermSpawn();
	void DoSpawnCancel();
	void ReInitSpawn();
	void GetErrorCount(DWORD & ErrCnt, DWORD & WarnCnt);

	void WriteStringToOutputWindow
	(
		const char *pchar, 
		BOOL bToolError = FALSE,
		BOOL bAddCtlLF  = TRUE
	);
	void WriteStringToOutputWindow(UINT id);

	EXEFROM GetExecutableFilename(PSTR strName, UINT size);
	CDocument * GetLastDocWin();
	BOOL IsSaveBeforeRunningTools(BOOL * pbQuery);

	__inline BOOL SpawnActive() {return m_InitCount > 0;}

	// Our project facility errors/warnings we'd like logged
	// ie. errors/warnings that get added to the tool
	// totals we get back from the spawns that occur in VCPP32
	DWORD m_dwProjError;
	DWORD m_dwProjWarning;

private:
	// OS command shell specification
	TCHAR m_szComspec[_MAX_PATH];

	BOOL m_bBuildTerminated;

	// Count of requests for InitSpawn
	int	m_InitCount;

	// output window ID (for 'Build' pane)
	UINT m_nOutputWindowID;
	// spawner object (defined in shell) used to actually run the build
	CConsoleSpawner *m_pSpawner;
	DWORD m_dwFileWarnings;
	DWORD m_dwFileErrors;
	BOOL  m_fClear;
};

extern CSpawner g_Spawner;

///////////////////////////////////////////////////////////////////////////////
//	Error context that writes to the output window in the IDE.  Note the 
//	the IDE must be in output window "mode" so that the output window is
//	visible, etc:
class COutputWinEC : public CErrorContext 
{
	DECLARE_DYNCREATE (COutputWinEC);
protected:
	CStringList m_StringList;
public:

	virtual void AddString ( const TCHAR *pstr ); 
	virtual void AddString ( UINT ResID ); 

};

///////////////////////////////////////////////////////////////////////////
//	Class to interface to the IDE.

class CVPROJIdeInterface 
{
	friend class CSpawner;

public:
	CVPROJIdeInterface();
	~CVPROJIdeInterface();

	BOOL Initialize();
	void Terminate();

	// cache the spawner interface
	LPEDITDEBUGSTATUS GetEditDebugStatus()
	{
		if (m_pEditDebugStatus == NULL)
			theApp.FindInterface(IID_IEditDebugStatus, (LPVOID FAR *)&m_pEditDebugStatus);
		return(m_pEditDebugStatus);
	}

	void ReleaseEditDebugStatus()
	{
		if (m_pEditDebugStatus != NULL)
			m_pEditDebugStatus->Release();
	}

	// cache the output window interface
	LPOUTPUTWINDOW GetOutputWindow()
	{
		ASSERT(!theApp.m_bInvokedCommandLine);

		if (m_pOutputWindow == NULL)
			theApp.FindInterface(IID_IOutputWindow, (LPVOID FAR *)&m_pOutputWindow);
		return(m_pOutputWindow);
	}

	void ReleaseOutputWindow()
	{
		if (m_pOutputWindow != NULL)
			m_pOutputWindow->Release();
	}

	// cache the DLL grid interface
	LPDLLINFO GetDLLInfo()
	{
		if (m_pDLLInfo == NULL)
			theApp.FindInterface(IID_IDLLInfo, (LPVOID FAR *)&m_pDLLInfo);
		return(m_pDLLInfo);
	}

	void ReleaseDLLInfo()
	{
		if (m_pDLLInfo != NULL)
			m_pDLLInfo->Release();
	}

private:
	LPEDITDEBUGSTATUS	m_pEditDebugStatus;
	LPOUTPUTWINDOW		m_pOutputWindow;
	LPDLLINFO			m_pDLLInfo;
};

extern CVPROJIdeInterface g_VPROJIdeInterface; 

#endif	 // _PROJCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projdep.cpp ===
///////////////////////////////////////////////////////////////////////////////
//
//	CProjectDependency
//
///////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "bldrfile.h"	// our CBuildFile
#include "projdep.h"

IMPLEMENT_SERIAL (CProjectDependency, CProjItem, SLOB_SCHEMA_VERSION)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define theClass CProjectDependency
BEGIN_SLOBPROP_MAP(CProjectDependency, CProjItem)
END_SLOBPROP_MAP()
#undef theClass

CPtrList g_lstprojdeps;


void InitWorkspaceDeps( void ){
	POSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	
	{
		POSITION posSave = pos;
		CTargetItem * pTargDep = NULL;
		
		CProjDepInfo * pProjDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		HFILESET hFileSet = g_BldSysIFace.GetFileSetFromTargetName(pProjDepInfo->strTarget, ACTIVE_BUILDER /* check them all */);
		if (hFileSet) // UNDONE: could be missing
		{
			HBUILDER hBld = g_BldSysIFace.GetBuilderFromFileSet(hFileSet);
			pTargDep = g_BldSysIFace.CnvHFileSet(hBld, hFileSet);
		}
		
		if( pProjDepInfo->pProjDep == NULL ){
			CProject *pProj = (CProject *) g_BldSysIFace.GetBuilderFromName(pProjDepInfo->strProject);
			if( pProj ) {
				CTargetItem * pTarget = pProj->GetActiveTarget();
				pProjDepInfo->pProjDep = new CProjectDependency();
				// remove from the list if found

				pProj->SetOkToDirtyProject(FALSE);
				pProjDepInfo->pProjDep->SetProjectDep(pTargDep, pProjDepInfo->strTarget);
				pProjDepInfo->pProjDep->MoveInto(pTarget);
				pProj->SetOkToDirtyProject(TRUE);
			}
		} else {
			// if found this one should already exisit in the project
			// REVIEW(KiP:9/96): is this needed ?
			pProjDepInfo->pProjDep->SetProjectDep(pTargDep, pProjDepInfo->strTarget);
		}
	}
}

CProjDepInfo * AddDep( CString strTop, CString strSub, CProjectDependency *pProjectDep ){
	POSITION pos = g_lstprojdeps.GetHeadPosition();
	BOOL bFound = FALSE;
	while (pos != NULL)
	{
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->strProject == strTop && pDepInfo->strTarget == strSub ){
			pDepInfo->pProjDep = pProjectDep;
			bFound = TRUE;
			break;
		}
	}
	if( bFound == FALSE ){
		CProjDepInfo *pNewDep = new CProjDepInfo;
		pNewDep->pProjDep = pProjectDep;
		pNewDep->strTarget = strSub;
		pNewDep->strProject = strTop;
		g_lstprojdeps.AddTail(pNewDep);
		return pNewDep;
	}
	return NULL;
}

CProjDepInfo * AddDep( CProjectDependency *pProjectDep ){
	// Could be coming from the Undo slob. If so, it wont be in the list.
	CProjDepInfo *pDepInfo;
	CString strProject;
	CString strSub;
	pProjectDep->GetProject()->GetName(strProject);
	pProjectDep->GetStrProp(P_ProjItemName, strSub);

	POSITION pos = g_lstprojdeps.GetHeadPosition();
	BOOL bFound = FALSE;
	while (pos != NULL)
	{
		pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->pProjDep == pProjectDep ){
			bFound = TRUE;
			break;
		}
	}
	if( bFound == FALSE ){
		pDepInfo = new CProjDepInfo;
		pDepInfo->pProjDep = pProjectDep;
		pDepInfo->strTarget = strSub;
		pDepInfo->strProject = strProject;
		g_lstprojdeps.AddTail( pDepInfo );
		return pDepInfo;
	}
	return NULL;
}

BOOL RemoveDep( CString strTop, CString strSub ){
	POSITION oldPos;
	POSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	{
		oldPos = pos;
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->strProject == strTop && pDepInfo->strTarget == strSub ){
			g_lstprojdeps.RemoveAt( oldPos );
			delete pDepInfo;
			return TRUE;
		}
	}
	return FALSE;
}

BOOL RemoveAllReferences( CString strProj ) {
	POSITION oldPos;
	POSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	{
		oldPos = pos;
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->strProject == strProj || pDepInfo->strTarget == strProj ){
			g_lstprojdeps.RemoveAt( oldPos );
			delete pDepInfo;
		}
	}
	return FALSE;
}

BOOL RemoveDep(  CProjectDependency *pProjDep  ){
	POSITION oldPos;
	POSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	{
		oldPos = pos;
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->pProjDep == pProjDep ){
			g_lstprojdeps.RemoveAt( oldPos );
			delete pDepInfo;
			return TRUE;
		}
	}
	return FALSE;
}

void GetSubProjects( CString &strTop, CStringList &listSub ){
	POSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	{
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->strProject == strTop  ){
			listSub.AddTail(pDepInfo->strTarget);
		}
	}
}

	 
BOOL IsReachable(CString &strTop, CString &strSeek) {
	BOOL bReachable = FALSE;

	CStringList subProjects;
	
	GetSubProjects(strTop, subProjects);

	// REVIEW(KiP:9/96) brute force approach. Significantly WORSE than N^2. fix if too slow.
	while ( !subProjects.IsEmpty() ) {
		CString strSub = subProjects.RemoveHead();
		if( strSub == strSeek ){
			bReachable = TRUE;
			return bReachable;	
		}
		GetSubProjects(strSub, subProjects);
	};
	return bReachable;	
}

BOOL CProjectDependency::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// WARNING! This does not fall through to a message map.  You must
	// handle both CN_COMMAND and CN_UPDATE_COMMAND_UI if you want your
	// commands to be enabled.

	if (nCode == CN_COMMAND && pExtra == NULL)
	{
		if (nID == IDM_PROJITEM_OPEN)
		{
			OnOpen();
			return TRUE;
		}
	}
	else if (nCode == CN_UPDATE_COMMAND_UI)
	{
		ASSERT(pExtra != NULL);
		CCmdUI* pCmdUI = (CCmdUI*)pExtra;
		ASSERT(pCmdUI->m_nID == nID);           // sanity assert

		if (nID == IDM_PROJITEM_OPEN)
		{
			pCmdUI->Enable(TRUE);
			return TRUE;
		}
	}

	// pass on to the default handler
	return CProjItem::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

CProjectDependency::CProjectDependency() 
{
	// the Project Window item inset
	m_nIconIdx = 5;
	m_pTarget = NULL;
}

CProjectDependency::~CProjectDependency()
{
	DeleteContents();

	// Make sure that if we are really going away
	// that if there is an active project (we could
	// be on the clipboard) does not have us on its
	// dependancy list
	CProject* pProject = GetProject();
	if (pProject)
		pProject->RemoveDependant(this);

	// now remove the pointer from the global collection
	POSITION oldPos;
	POSITION pos = g_lstprojdeps.GetHeadPosition();
	while (pos != NULL)
	{
		oldPos = pos;
		CProjDepInfo *pDepInfo = (CProjDepInfo *)g_lstprojdeps.GetNext(pos);
		if( pDepInfo->pProjDep == this ){
			pDepInfo->pProjDep = NULL;
			break;
		}
	}
}

BOOL CProjectDependency::SetStrProp(UINT idProp, const CString &str)
{
	// pass on to base-class
	/*
	switch (idProp)
	{
		case P_ProjItemName:	// yes
			str = m_strName;
			return TRUE;
 		default:
			break;
	}
	*/

	return CProjItem::SetStrProp(idProp, str);
}
  
GPT CProjectDependency::GetStrProp(UINT idProp, CString& val)
{
	// is this a fake prop?
	
	switch (idProp)
	{
		case P_ProjItemName:	// yes
				if (m_pTarget != NULL)
				{
#if 0
					g_BldSysIFace.GetFileSetName((HFILESET)m_pTarget, val, (HBUILDER)m_pTarget->GetProject());
 					m_strName = val;
#else
					m_strName = val = m_pTarget->GetTargetName();
#endif
				}
				else
				{
					val = m_strName;  // as read from project file
				}
				return valid;
		default:
			break;
	}
	
 	// no, pass on to base class
	return CProjItem::GetStrProp(idProp, val);
}

// Target name prefix written to the makefile
const TCHAR *CProjectDependency::pcDepPrefix = _TEXT("Project_Dep_Name ");
 
BOOL CProjectDependency::WriteToMakeFile
( 
	CMakFileWriter& pw, 
	CMakFileWriter& mw, 
	const CDir &BaseDir,
	CNameMunger& nm
)
{
	CProject * pProject = GetProject();

	// FUTURE (karlsi): remove BaseDir and just use CProject::GetProjDir()
	ASSERT(BaseDir==pProject->GetWorkspaceDir());
	
	CString strSrc, str, strOut;
	BOOL bNamedTool= FALSE;
	CBuildTool * pBuildTool = NULL;
	const TCHAR *pc = GetNamePrefix (this);

	PFILE_TRACE ("CProjectDependency \"%s\" at %p writing to CMakFileWriter at %p\n",
				(const TCHAR *)	*GetFilePath(),this, &pw);
	
	TRY			  
	{
		if (g_bExportMakefile)
		{
#ifdef _DEBUG
			const ConfigurationRecord * pcrSave = GetActiveConfig();
			const ConfigurationRecord * pcrSaveBase = pcrSave->m_pBaseRecord;
#endif

			int cCFGs = 0;
			ConfigurationRecord * pcr;

			const CPtrArray & ppcr = *GetConfigArray();
			CProjTempConfigChange projTempConfigChange(pProject);

			for (int k = 0; k < ppcr.GetSize(); k++)
			{
				pcr = (ConfigurationRecord *)ppcr[k];

				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);
 
				// Only write out sections for the valid configs
				if (GetTarget()->GetActiveConfig()->IsValid())
				{	
					// write IF/ELSEIF if writing multiple configs
					m_cp = (cCFGs == 0) ? FirstConfig : MiddleConfig;
					if (g_bExportMakefile)
						WriteConfigurationIfDef(mw, GetActiveConfig());

					// increment the # configs we write out
					cCFGs++;
					WriteRule(FALSE,mw,BaseDir);
					WriteRule(TRUE,mw,BaseDir);
				}
				
 			}

			projTempConfigChange.Release();
			
			// Write final ENDIF if writing multiple configs (if we need to)
			if (cCFGs != 0)
			{
				m_cp = EndOfConfigs;
				if (g_bExportMakefile)
					WriteConfigurationIfDef(mw, NULL);
			}
			
#ifdef _DEBUG
			ASSERT(pcrSave == GetActiveConfig());
			ASSERT(pcrSaveBase == pcrSave->m_pBaseRecord);
#endif
		}

	}
	CATCH(CException, e)
	{
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}



void CProjectDependency::WriteRule(
	BOOL bClean,
	CMakFileWriter& mw, 
	const CDir &BaseDir
	)
{
	CProject * pProject = GetProject();
  	ConfigurationRecord * pcrProjDep = GetTargetConfig();
	if (pcrProjDep != NULL)
	{
		CString strTargetRefName = pcrProjDep->GetConfigurationName();
		// Write out pseudo target dependancy

		CString strPseudoTarg;
		if( bClean )
			strPseudoTarg = _T('\"') + strTargetRefName + _T("CLEAN") + _T('\"');
		else
			strPseudoTarg = _T('\"') + strTargetRefName + _T('\"');
		
		if (g_bExportMakefile)
			mw.WriteDesc(strPseudoTarg, _T(""));

		CPath Path = *(m_pTarget->GetProject()->GetFilePath());
		CDir Dir = m_pTarget->GetProject()->GetWorkspaceDir();
		TCHAR DriveW = ((LPCTSTR)pProject->GetWorkspaceDir())[0];
		TCHAR DriveP = ((LPCTSTR)Dir)[0];
		BOOL bWriteDrive = ((DriveP != DriveW) && (DriveP != _T('\\')));
		if (g_bExportMakefile)
		{
			CString strMakefileName;
			Path.ChangeExtension(_T(".mak"));
			if (bWriteDrive)
			{

				CString strPushD = DriveP;
				strPushD += _T(":");
				mw.Indent ();
				mw.WriteString(strPushD);
				mw.EndLine ();
			}
			CString strBuildLine0 = _T("cd ");


			// relativise sub project dir
			CPath dummyPath;
			dummyPath.CreateFromDirAndRelative(Dir,".\\dummy$$$" );
			CString strRel;
			dummyPath.SetAlwaysRelative();
			dummyPath.GetRelativeName(BaseDir, strRel, FALSE,TRUE);
			strRel = strRel.Left( strRel.GetLength() - 9 );
			strBuildLine0 += "\"" + strRel + "\"";

			mw.Indent ();
			mw.WriteString(strBuildLine0);
			mw.EndLine ();

			CString strBuildLine;
			CProjType * pProjType = m_pTarget->GetProject()->GetProjType();
			if( pProjType->GetUniqueTypeId() != exttarget ){
				Path.GetRelativeName(Dir, strMakefileName, TRUE /* quotes */);
				if( bClean )
					strBuildLine = _T("$(MAKE) /$(MAKEFLAGS) /F ") + strMakefileName + _T(" CFG=\"") + strTargetRefName + _T("\" RECURSE=1 CLEAN ");
				else
					strBuildLine = _T("$(MAKE) /$(MAKEFLAGS) /F ") + strMakefileName + _T(" CFG=\"") + strTargetRefName + _T("\" ");
				// mw.EndLine ();
			} else {
				// get the command line
				if( bClean )
					strBuildLine = _T("");
				else {
					CProjTempConfigChange projTempConfigChange(m_pTarget->GetProject());
					projTempConfigChange.ChangeConfig(pcrProjDep);
					m_pTarget->GetProject()->GetStrProp (P_Proj_CmdLine, strBuildLine);
				}
			}
			if( !strBuildLine.IsEmpty() ) {
				mw.Indent ();
				mw.WriteString(strBuildLine);
				mw.EndLine ();
			}

			if ((bWriteDrive) && (DriveW != _T('\\')))
			{

				CString strPopD = DriveW;
				strPopD += _T(":");
				mw.Indent ();
				mw.WriteString(strPopD);
				mw.EndLine ();
			}

			CString strBuildLine1 = _T("cd ");

			// relativise calling project dir
			strRel = "";
			dummyPath.SetAlwaysRelative();
			dummyPath.CreateFromDirAndRelative(pProject->GetWorkspaceDir(),".\\dummy$$$" );
			dummyPath.GetRelativeName(Dir, strRel, FALSE);
			strRel = strRel.Left( strRel.GetLength() - 9 );
			strBuildLine1 += "\"" + strRel + "\"";

			mw.Indent ();
			mw.WriteString(strBuildLine1);
			mw.EndLine ();

		}
	}
}



// Reads target name comments and sets up the config recs accordingly. Also
// registers the target with the target manager.
BOOL CProjectDependency::IsDepComment(CObject *&pObject)
{
	// If this is not a makefile comment then give up now!
	if (!pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
		return FALSE;

	CMakComment *pMc = (CMakComment*) pObject;

	// Skip over any initial white space
	TCHAR *pc, *pcEnd;
	pc = pMc->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// We should have the target name prefix at the front of
	// the comment
	if (_tcsnicmp(pcDepPrefix, pc, _tcslen(pcDepPrefix)) != 0)
		return FALSE;

	// Ok, we found the prefix so skip over it.
	pc += _tcslen(pcDepPrefix);
	SkipWhite(pc);

	// Get the quoted fileset name
	if (!GetQuotedString(pc, pcEnd))
		return FALSE;

	*pcEnd = _T('\0');


	CProjDepInfo * pProjDepInfo = new CProjDepInfo;
	pProjDepInfo->pProjDep = this;

	CString strProject = GetTargetName();
	int iDash = strProject.Find(_T(" - "));
	if (iDash > 0)
		strProject = strProject.Left(iDash);
	pProjDepInfo->strProject = strProject;

	CString strName = pc;
	pProjDepInfo->strTarget = strName;
	m_strName = strName;

	g_lstprojdeps.AddTail(pProjDepInfo);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjectDependency::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
//	Read in this item and  a makfile reader. 
//
	CObject *pObject = NULL;
	PFILE_TRACE ("CTargetReference at %p reading from CMakFileReader at %p\n",
														this, &mr);
	CPath cpFile;
	
	TRY
	{
		// The next element better be a comment marking our start:
		pObject = mr.GetNextElement ();
		ASSERT (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)));

		delete pObject;

		m_cp = EndOfConfigs;
	   	for (pObject = mr.GetNextElement(); !IsEndToken(pObject); pObject = mr.GetNextElement())
	   	{
			// set the target we reference (m_pcr) by reading in P_TargetRefName
			if (IsDepComment(pObject)){
				delete (pObject); pObject = NULL;
				continue;
			}
 
			// make sure we set which target this target reference is contained in
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) 
			{
				// read in the configuration information
				ReadConfigurationIfDef((CMakDirective *)pObject);
			}

	   		delete (pObject); pObject = NULL;
		}				 
	}
	CATCH ( CException, e)
	{
		if (pObject) delete (pObject);
		return FALSE;	// failure
	}
	END_CATCH

	// do the rest of the move
	(void)PostMoveItem(GetContainer(), (CSlob *)NULL, FALSE, TRUE, FALSE);
	::SetWorkspaceDocDirty();

	return TRUE;	// success
}

// Opening up a target reference opens up the actual target
// for v3 this means switching active config. to that of the target
void CProjectDependency::OnOpen()
{
    // FUTURE (colint): do we need to do something more appropriate here
    MessageBeep(0);
}

// Return a container-less, symbol-less, clone of 'this'
CSlob* CProjectDependency::Clone()
{
	CSlob * pClone = CProjItem::Clone(); // call base class to create clone
	ASSERT(pClone->IsKindOf (RUNTIME_CLASS (CProjItem)));
	ASSERT(((CProjItem *)pClone)->GetFileRegHandle()==GetFileRegHandle());
	
	// Set up the clones target reference
	CString strTarget;
	VERIFY(GetStrProp(P_TargetRefName, strTarget));
	VERIFY(pClone->SetStrProp(P_TargetRefName, strTarget));

 	return pClone;
}

BOOL CProjectDependency::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	BOOL bRefreshName = FALSE;

	// removing from a project?
	if (fFromPrj)
	{
		// the item is being removed from the project
		// (most likely to be moved onto the undo slob)
		// so we need to remove us as a dependant of the project
		GetProject()->RemoveDependant(this);
	}

	// do the base-class thing
	return CProjItem::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged);
}

BOOL CProjectDependency::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// moving into a project?
	if (fToPrj)
	{
		// we are being added to the project
		// so we need to add ourselves as a dependant of the project
		GetProject()->AddDependant(this);
		
		if( ::AddDep( this ) != NULL ){
			::SetWorkspaceDocDirty();
		}
	}
	if( pContainer == NULL ){
		// it is being moved into the Undo slob at this point
		::SetWorkspaceDocDirty();

		// find it on the list and remove it.
		::RemoveDep( this );
	}

	// do the base-class thing
	return CProjItem::PostMoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged);
}

ConfigurationRecord * CProjectDependency::GetTargetConfig()
{
	if (m_pTarget==NULL)
		return NULL;

	CString str;
	CProject* pProject = m_pTarget->GetProject();
	g_BldSysIFace.GetTargetNameFromFileSet((HFILESET)m_pTarget, str, (HBUILDER)GetProject(), TRUE);

	ConfigurationRecord * pcr = pProject->ConfigRecordFromConfigName(str);

	return pcr;
}

ConfigurationRecord * CProjectDependency::GetCompatibleTargetConfig(ConfigurationRecord * pcr)
{
	if (m_pTarget==NULL)
		return NULL;

	CString strName;
	CProject* pProject = m_pTarget->GetProject();
	ConfigurationRecord *pcrPrj = pProject->GetActiveConfig();
	pcrPrj->GetProjectName(strName);

	CString str;

	HBLDTARGET hTarget = g_BldSysIFace.GetActiveTarget ((HBUILDER) pProject);
	HFILESET hFileSet = g_BldSysIFace.GetFileSet ((HBUILDER) pProject, hTarget);
	if (hFileSet == NO_FILESET)
		return NULL;

	g_BldSysIFace.GetTargetNameFromFileSet (hFileSet, str, ACTIVE_BUILDER);

	pcr = pProject->ConfigRecordFromConfigName(str);

	return pcr;
}

///////////////////////////////////////////////////////////////////////////////
void CProjectDependency::FlattenQuery(int fo, BOOL& bAddContent, BOOL& fAddItem)
{
	if (fo & flt_ExcludeProjDeps)
		fAddItem = FALSE;
	else
		fAddItem = TRUE;
}

BOOL CProjectDependency::CanAct(ACTION_TYPE action)
{
	switch (action)
	{
	// refuse to be inserted into the undo slob since
	// we can disappear spontaneously.
	case act_insert_into_undo_slob:
		return TRUE;

	case act_delete:
		return (!g_Spawner.SpawnActive());

	case act_drag:
	case act_cut:
	case act_copy:
	case act_paste:
		return FALSE;
	}

	return CProjItem::CanAct(action);
}

BOOL CProjectDependency::PreAct(ACTION_TYPE action)
{
	if (action == act_delete)
	{
		return (!g_Spawner.SpawnActive());
	}

	return CProjItem::PreAct(action);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\projitem.cpp ===
//	PROJITEM.CPP
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#pragma hdrstop

#include "projcomp.h"
#include "resource.h"
#include "cursor.h"
#include "mmsystem.h"
#include "exttarg.h"
#include "bldrfile.h"	// our CBuildFile
#include "bldslob.h"
#include "bldnode.h"
#include "optndlg.h"    // for build.settings tree ctl
#include "toolcplr.h"
#include "toolrc.h"
#include "util.h"
#include "oleref.h"

#include "image.h"

#include <prjapi.h>
#include <prjguid.h>
#include <srcguid.h>
#include <utilauto.h>	// For Automation CAutoApp

IMPLEMENT_SERIAL (CProjItem, CProjSlob, SLOB_SCHEMA_VERSION)
IMPLEMENT_SERIAL (CFileItem, CProjItem, SLOB_SCHEMA_VERSION)
IMPLEMENT_SERIAL (CDependencyFile, CProjItem, SLOB_SCHEMA_VERSION)
IMPLEMENT_DYNAMIC (ConfigurationRecord, CObject)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


#include "icapexp.h"

bool
IsCrashDumpEnabled(
	);

// Cache used to speed up reading of dependency files from the makefile.
// See code in CProjItem::SuckMacro().
// FUTURE (karlsi): this should be allocated dynamically just for makefile reading
CMapStringToPtr	*g_pMakReadDepCache;

// Since INCLUDE dep paths are per platform, we need to maintain a seperate
// cache per platform here.
CMapStringToPtr *g_pMakReadIncludeDepCache;

// this variable is part of a MAJOR HACK involving the BuildCmds Macro and
// unsupported platforms in makefiles. find a betterr work around for this problem ASAP
// olympus bug #1103 for details.
CBuildTool *g_pBuildTool=NULL;

// 04-10-96 jimsc This is used by SuckMacro, but ReadMakeFile has to set it in project.cpp
CBuildTool *g_pLastTool = NULL;

// HACK: used to preserve formated name of current source file during writing
static CString strSrc;
extern BOOL g_bHTMLLog;

#ifdef _DEBUG

// These variables keep track of the value of the P_D_ properties used
// to implement the "projinfo" property page.
int			g_D_nPropIdCur = -1;
int			g_D_nPropBag = 0;
CString		g_D_strTargetCur;

BOOL AFX_DATA_EXPORT bDoFileTrace   	= FALSE;
BOOL AFX_DATA_EXPORT bDoConfigTrace 	= FALSE;
BOOL AFX_DATA_EXPORT bDoInformTrace 	= FALSE;
BOOL AFX_DATA_EXPORT bDoScanTrace   	= FALSE;

// Our own debug output 'cause MFC sucks (crashes when line is too long)

#define DBG_BUFSIZE	1024
#define MAX_OUTPUT  249		// Max chars debugger can show in output window
void CDECL PrjTrace(LPCSTR pszFormat, ...)
{
	int nBuf;
	TCHAR szBuffer[DBG_BUFSIZE];
	const TCHAR* pszLocalFormat;

	pszLocalFormat = pszFormat;

	va_list args;
	va_start(args, pszFormat);

	nBuf = _vsnprintf(szBuffer, DBG_BUFSIZE, pszLocalFormat, args);
	szBuffer[DBG_BUFSIZE-1] = 0;
	ASSERT(nBuf < DBG_BUFSIZE);

    // The following code is not DBC aware.  Don't TRACE
    // with mbcs strings!

    char szLine[MAX_OUTPUT];
    char *pszTo, *pszFrom;

    pszFrom = szBuffer;
    pszTo = szLine;
    while( *pszFrom )
    {
        if( (szLine + sizeof(szLine) - pszTo) < 3 )
        {
            *pszTo = '0';
            OutputDebugString(szLine);
            OutputDebugString("\r\n");
            pszTo = szLine;
        }
        *pszTo++ = *pszFrom++;
        if( *(pszFrom-1) == '\n' )
            *pszTo++ = '\r'; 
    }
    if( pszTo != szLine )
    {
        *pszTo = '\0';
        OutputDebugString(szLine);
    }

	va_end(args);
}

#endif

// Remember to free() the return value!
TCHAR *StripQuotes(LPCTSTR szFilePath)
{
	const TCHAR * pchLookup = szFilePath;
	TCHAR *pchSet = new TCHAR[lstrlen(szFilePath) + 1];
	TCHAR *pchRet = pchSet;

	ASSERT(pchSet != NULL);

	while (*pchLookup != _T('\0'))
	{
		if (*pchLookup != _T('"'))
 		{
			_tccpy(pchSet, pchLookup);
			pchSet = _tcsinc(pchSet);
 		}
		pchLookup = _tcsinc(pchLookup);
	}

    *pchSet = _T('\0');
	return pchRet;
}

///////////////////////////////////////////////////////////////////////////////
// Dependency cache management.

// These caches are used so we don't go around asking for fullpaths for filenames
// every time we read new dependency information.

VOID InitDependencyCaches( )
{
	ASSERT(g_pMakReadDepCache == NULL);
	ASSERT(g_pMakReadIncludeDepCache == NULL);

	g_pMakReadDepCache = new CMapStringToPtr;
	g_pMakReadDepCache->InitHashTable(199);

	CDirMgr *pDirMgr = GetDirMgr();
	int cToolset = pDirMgr->GetNumberOfToolsets();
	ASSERT(cToolset > 0);
	
	g_pMakReadIncludeDepCache = new CMapStringToPtr[cToolset];

	for ( int i = 0; i < cToolset ; i++ )
		g_pMakReadIncludeDepCache[i].InitHashTable(97);
}


VOID FreeDependencyCaches( )
{
#ifdef REFCOUNT_WORK
	POSITION pos = NULL;
	CString strKey;
	CDirMgr *pDirMgr = GetDirMgr();
	int cToolset = pDirMgr->GetNumberOfToolsets();
	ASSERT(cToolset > 0);

	if (NULL!=g_pMakReadIncludeDepCache)
	{
		for ( int i = 0; i < cToolset ; i++ )
		{
			pos = g_pMakReadIncludeDepCache[i].GetStartPosition();
			while (NULL!=pos)
			{
				FileRegHandle frh = NULL;
				g_pMakReadIncludeDepCache[i].GetNextAssoc( pos, strKey, (void*&)frh );
				ASSERT(NULL!=frh);
				frh->ReleaseFRHRef();
			}
		}
	}

	pos = (NULL==g_pMakReadDepCache)?NULL:g_pMakReadDepCache->GetStartPosition();
	while (NULL!=pos)
	{
		FileRegHandle frh = NULL;
		g_pMakReadDepCache->GetNextAssoc( pos, strKey, (void*&)frh );
		ASSERT(NULL!=frh);
		frh->ReleaseFRHRef();
	}
#endif
	delete g_pMakReadDepCache;
	delete [] g_pMakReadIncludeDepCache;

	g_pMakReadDepCache = NULL;
	g_pMakReadIncludeDepCache = NULL;
}

//
// Helper function that test for a container being non-NULL or that the
// undo slob is recording(which mean that the undo slob could be the container)
//
static __inline BOOL CouldBeContainer(CSlob* pContainer)
{
	return (NULL!=pContainer || theUndoSlob.IsRecording());
}

// CStack Tiny Stack 
void CStack::Push( void * data ) { 
	SNode *tmp = new SNode; 
	tmp->next = head; 
	tmp->data = data;
	head = tmp;
}



///////////////////////////////////////////////////////////////////////////////
//
// ------------------------- ConfigurationRecord ------------------------------
//
///////////////////////////////////////////////////////////////////////////////
DWORD ConfigurationRecord::nSignature = 0;
int ConfigurationRecord::nCongfigCacheCount = 0;

ConfigurationRecord::ConfigurationRecord
(
	const ConfigurationRecord * pBaseRecord, 
	CProjItem * pOwner
) :
  m_parryTargetFiles (NULL), m_pTargetFiles (NULL),m_pPathExtTrg(NULL),
// increase the size of the hash table for project-level,
// these bags have the most props, to a more efficient value
// than the default of 17 and reduce for CfileItems and CDepItems
#if 1
  m_BasePropBag(pOwner->GetBagHashSize()),
  m_CurrPropBag(pOwner->GetBagHashSize()),
  m_ClonePropBag(pOwner->GetBagHashSize())
#else
  m_BasePropBag(53),
  m_CurrPropBag(53),
  m_ClonePropBag(53)
#endif
{
	// Owner project item
	m_pOwner = pOwner;

	// Record linkage
	m_pBaseRecord = pBaseRecord;
	#ifdef _DEBUG
	if (pBaseRecord) ASSERT_VALID (pBaseRecord);
	#endif
	// default is *NO* attributes which are dirty
	m_iAttrib = 0;
	m_fAttribDirty = TRUE;

	// Config rec is not valid for the owning item by default
	m_fValid = FALSE;

	// Actions list is allocated on demand..
	m_pActions = (CActionSlobList *)NULL;
	m_LastUpdate = 0;
}

ConfigurationRecord::~ConfigurationRecord()
{
	// empty our target file set
#if 0	// m_setTargetFiles removed from ConfigurationRecord
	m_setTargetFiles.EmptyContent();
#endif
	delete m_pPathExtTrg;

	// delete our actions and actions list
	if (m_pActions)
	{
		POSITION pos = m_pActions->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CActionSlob * pAction = (CActionSlob *)m_pActions->GetNext(pos);

			// must not be bound, unless it's an unknown tool
			// we *just* directly added these, so we can *just* directly
			// delete them, no CActionSlob::UnAssign or CActionSlob::Assign used!
			ASSERT(pAction->m_pTool == (CBuildTool *)NULL ||
				   pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)));
			delete pAction;
		}
		delete m_pActions;
	}

	// FUTURE: remove this
	FreeOutputFiles();

	// This is already done by FreeOutputFiles().
	delete m_parryTargetFiles;
	delete m_pTargetFiles;
}

CActionSlobList * ConfigurationRecord::GetActionList()
{
	if (m_pActions == (CActionSlobList *)NULL)
		m_pActions = new CActionSlobList;
	return m_pActions;
}

#if 0
CPropBag * ConfigurationRecord::GetPropBag(UINT idBag)
 {
	switch( idBag ){
		case BaseBag:
			return &m_BasePropBag;
		case CloneBag:
			return &m_ClonePropBag;
		default:
			return &m_CurrPropBag;
	}
}

void ConfigurationRecord::EmptyPropBag(UINT idBag)
 {
	switch( idBag ){
		case BaseBag:
			m_BasePropBag.Empty();
		case CloneBag:
			m_ClonePropBag.Empty();
		default:
			m_CurrPropBag.Empty();
	}
}
#endif

BOOL ConfigurationRecord::IsSupported()
{
	CProjType * pprojtype;
	
	if (!g_prjcompmgr.LookupProjTypeByName(GetOriginalTypeName(), pprojtype))
		return FALSE;

	return pprojtype->IsSupported();
}

BOOL ConfigurationRecord::IsBuildable()
{
	CProjType * pprojtype;
	
	if (!g_prjcompmgr.LookupProjTypeByName(GetOriginalTypeName(), pprojtype))
		return FALSE;

	return pprojtype->GetPlatform()->GetBuildable();
}

void ConfigurationRecord::FreeOutputFiles ()
{
	if (m_parryTargetFiles)
	{
		// Maybe only a CProject???
		ASSERT( m_pOwner->IsKindOf(RUNTIME_CLASS(CProject)) );

		delete m_parryTargetFiles;
		m_parryTargetFiles = NULL;
	}

	if (m_pTargetFiles)
	{
		// Must be project.
		ASSERT( m_pOwner->IsKindOf(RUNTIME_CLASS(CProject)) );

		m_pTargetFiles->EmptyContent();
		delete m_pTargetFiles;
		m_pTargetFiles = NULL;
	}

#ifdef REFCOUNT_WORK
	for (int i=0; i < m_arryOutputFiles.GetSize(); i++)
	{
		m_arryOutputFiles[i]->ReleaseFRHRef();
	}
#endif

	// Size = 0, GrowBy = 2. Assume that there are usually 2 pointers added.
	m_arryOutputFiles.SetSize( 0, 2 );
}

CString &ConfigurationRecord::GetConfigurationName () const
{
	ASSERT (m_pBaseRecord);
	const CPropBag * pBag = ((ConfigurationRecord *)m_pBaseRecord)->GetPropBag(CurrBag);

	CStringProp *pProp = (CStringProp *)pBag->FindProp (P_ProjConfiguration);
	ASSERT (pProp);
	ASSERT (pProp->m_nType == string);
	return pProp->m_strVal;
}

void ConfigurationRecord::GetProjectName (CString &strProject) const
{
	ASSERT (m_pBaseRecord);
	CProject * pProject = (CProject *)m_pBaseRecord->m_pOwner;
	ASSERT(pProject);
	if (pProject->m_bProjIsExe)
	{
		strProject = pProject->GetFilePath()->GetFileName();
	}
	else
	{
		const CPropBag * pBag = ((ConfigurationRecord *)m_pBaseRecord)->GetPropBag(CurrBag);

		CStringProp *pProp = (CStringProp *)pBag->FindProp (P_ProjConfiguration);
		ASSERT (pProp);
		ASSERT (pProp->m_nType == string);

	    strProject = (const char *)((CStringProp *)pProp)->m_strVal;
  	  int iDash = strProject.Find(_T(" - "));
  	  if (iDash > 0)
  	      strProject = strProject.Left(iDash);
	}

	return ;
}

void ConfigurationRecord::GetConfigurationDescription ( CString &strDescription ) const
{
	ASSERT (m_pBaseRecord);
	const CPropBag * pBag = ((ConfigurationRecord *)m_pBaseRecord)->GetPropBag(CurrBag);

	CStringProp *pProp = (CStringProp *)pBag->FindProp (P_ProjConfiguration);
	ASSERT (pProp);
	ASSERT (pProp->m_nType == string);
	strDescription = pProp->m_strVal;

    strDescription = (const char *)((CStringProp *)pProp)->m_strVal;
	int nSep = strDescription.Find(_T(" - "));
	strDescription = strDescription.Right(strDescription.GetLength() - nSep - 3 );

	return;
}



CString &ConfigurationRecord::GetOriginalTypeName() const
{
	ASSERT (m_pBaseRecord);
	const CPropBag * pBag = ((ConfigurationRecord *)m_pBaseRecord)->GetPropBag(CurrBag);

	// format is '<Platform> <ProjType>'
	CStringProp *pProp = (CStringProp *)pBag->FindProp (P_ProjOriginalType);
	ASSERT (pProp);
 	ASSERT (pProp->m_nType == string);

	return pProp->m_strVal;
}

void ConfigurationRecord::BeginConfigCache()
{
	if (nCongfigCacheCount == 0) nSignature++;
	nCongfigCacheCount++;

}
void ConfigurationRecord::EndConfigCache()
{
	nCongfigCacheCount--;
}
	  
CBuildTool * ConfigurationRecord::GetBuildTool()
{
	// don't return a build tool for non-source tools
	if (!m_pOwner->UsesSourceTool())
		return (CBuildTool *)NULL;

	// FUTURE: fix the use of this function
	// given customizable build tools we may have
	// multiple sources tools per item
	// for now we know we have one, return that
	CActionSlobList * plstActions = GetActionList();
	int c = plstActions->GetCount();
	ASSERT(c <= 1);	// must re-write this function!

	if (c == 0)
		return (CBuildTool *)NULL;	// no tools

	// return the first
	return ((CActionSlob *)plstActions->GetHead())->m_pTool;
}

int ConfigurationRecord::GetTargetAttributes()
{
	BOOL			fForce = FALSE;

	// do we need to force ourselves into the same config.?
	if (m_pOwner->GetActiveConfig() != this)
	{
		m_pOwner->ForceConfigActive(this);
 		fForce = TRUE;
	}

	BOOL fIsExternal =
		m_pOwner->IsKindOf(RUNTIME_CLASS(CProject))	&& 
		((CProject *)m_pOwner)->m_bProjIsExe;

	BOOL fIsExternalTarget = m_pOwner->IsKindOf(RUNTIME_CLASS(CProject)) &&
		((CProject *)m_pOwner)->IsExternalTarget();

	// if we're an exe project create the current target
	// and check it against the one we last got attributes for
	// if they are different then get the new set of attributes
	if (fIsExternal || fIsExternalTarget)
	{
		CPath path;
		CString strTarget;

		VERIFY(m_pOwner->GetStrProp(fIsExternalTarget ? P_Proj_Targ : P_ExtOpts_Targ, strTarget) == valid);

		path.CreateFromDirAndFilename(((CProject*)m_pOwner)->GetWorkspaceDir(), strTarget);

		// if this target is different to our current we are dirty
		if( m_pPathExtTrg == NULL )
		{
			m_pPathExtTrg = new CPath( path );
			m_fAttribDirty = TRUE;
		} 
		else if (path != *m_pPathExtTrg)
		{
			*m_pPathExtTrg = path;
			m_fAttribDirty = TRUE;
		}
	}

	// are our target attributes dirty?
	if (m_fAttribDirty)
	{
		m_iAttrib = 0;

		// for an external makefile (.EXE 'pseudo' makefile)
		// refresh the target attributes only if the target has changed
		if (fIsExternal || fIsExternalTarget)
		{
			// we need to figure out as much of the attributes as
			// we can from the PE header and if that doesn't exist
			// use the extension 

			//
			// is this a executable (eg. .exe, .dll or other executable code)?
			//
			
			BOOL		fOpened = FALSE;
			IMAGE_INFO	ImageInfo = {0};

			ImageInfo.Size = sizeof (ImageInfo);

			fOpened = GetImageInfo (*m_pPathExtTrg, &ImageInfo);

			if (fOpened) {

				if (ImageInfo.ImageType == IMAGE_TYPE_WIN32) {
				
					//
					// Ok. This is a valid Win32 subsystem image, check if
					// it's  DLL or EXE.
					//
					
					if (ImageInfo.u.Win32.Characteristics & IMAGE_FILE_DLL) {
						m_iAttrib |= ImageDLL | TargetIsDebugable;
					} else {
						m_iAttrib |= ImageExe | TargetIsDebugable;
					}

				} else if (ImageInfo.ImageType == IMAGE_TYPE_CRASHDUMP &&
						   IsCrashDumpEnabled ()) {

					//
					// Win32 Crashdump is treated like a EXE.
					//

					m_iAttrib |= ImageExe | TargetIsDebugable;
				} else if(!fIsExternalTarget) {
					CString strPlat;
					CPlatform *pPlat;
					/* Could be an XBE */
					if(m_pOwner->GetStrProp(P_ExtOpts_Platform, strPlat) &&
						g_prjcompmgr.LookupPlatformByUIDescription(strPlat,
						pPlat) && pPlat->GetUniqueId() == xbox)
					{
						/* We're Xbox, so look at the filename */
						if (FileNameMatchesExtension (m_pPathExtTrg,
								_TEXT ("xbe")))
							m_iAttrib |= (ImageExe | TargetIsDebugable);
					}
				}

				//
				// NOTENOTE: Java support has been removed.
				//
			}
				

	
			// let's cheat and use
			// the extension to at least provide *some*
			// information back as to the image type if we
			// don't already have it AND we couldn't find the image
			
			if (!fOpened && !(m_iAttrib & (ImageExe | ImageDLL | ImageStaticLib)))
			{
				if (FileNameMatchesExtension (m_pPathExtTrg, _TEXT ("exe")))
					m_iAttrib |= (ImageExe | TargetIsDebugable);
				else if (FileNameMatchesExtension (m_pPathExtTrg, _TEXT ("dll")))
					m_iAttrib |= (ImageDLL | TargetIsDebugable);
				else if (FileNameMatchesExtension (m_pPathExtTrg, _TEXT ("lib")))
					m_iAttrib |= ImageStaticLib;
				else if (FileNameMatchesExtension (m_pPathExtTrg, _TEXT ("xbe")))
					m_iAttrib |= (ImageExe | TargetIsDebugable);
			}

			if (((CProject *)m_pOwner)->m_bProjIsExe)
			{
				CString strUIDescription;

				CPlatform * pPlatform;
				if (m_pOwner->GetStrProp(P_ExtOpts_Platform, strUIDescription) == valid)
					g_prjcompmgr.LookupPlatformByUIDescription(strUIDescription, pPlatform);

				if (!pPlatform->IsSupported() || !pPlatform->GetBuildable())
					m_iAttrib &= ~TargetIsDebugable;			// only supported platforms are debuggable
			}
		}
		// for an internal project
		else if (m_fAttribDirty)
		{
			// cache our target attributes
			CProjType * pProjType = m_pOwner->GetProjType(); ASSERT(pProjType != (CProjType *)NULL);
			m_iAttrib = pProjType->GetAttributes();
			CPlatform *pPlatform = pProjType->GetPlatform();
			if (!pPlatform->IsSupported() || !pPlatform->GetBuildable())
				m_iAttrib &= ~TargetIsDebugable;        
		}

		m_fAttribDirty = FALSE;
	}


	if (fForce)
		m_pOwner->ForceConfigActive();

	return m_iAttrib;	// return the attributes
}

//
// GetTargetFiles has been changed to dynamicly create a CFileRegSet instead of returning a pointer
// to m_setTargetFiles.  Caller must delete pointer returned by this function.
//
const CFileRegSet * ConfigurationRecord::GetTargetFiles(BOOL fPrimary /* TRUE */, BOOL fAll /* FALSE */)
{
	// FUTURE: remove this hack
	// It's v.slow, for now disable file-change notification while we do
	// this, we don't need them anyway
	BOOL g_oldFileRegDisableFC = g_FileRegDisableFC;
	g_FileRegDisableFC = TRUE;

	// Ensure that we support the combination
	// FUTURE: replace these two BOOLs with one!
	ASSERT(fPrimary || fAll && !(fPrimary && fAll));

	CFileRegSet * psetTargetFiles = new CFileRegSet(11);

	// Empty our target file set
#if 0	// m_setTargetFiles removed from ConfigurationRecord
	m_setTargetFiles.EmptyContent();
#endif

	// Ensure we are in the right config.
	m_pOwner->SetManualBagSearchConfig(this);

	// Obtain the primary target file name
	// In the case of an external makefile this is simply
	// stored in the property P_ExtsOpt_Targ.
	// For an internal makefile we must loop through the
	// schmooze tools asking each one for a primary target
	// name, only one should return such a file name.

	// Our parents projtype
	CProjType * pProjType = m_pOwner->GetProjType();

	// External target, from either an internal or exe project?
	if (m_pOwner->IsKindOf(RUNTIME_CLASS(CProject)) &&
		((CProject *)m_pOwner)->m_bProjIsExe)
	{
		CString strTargetFile;
		if (m_pOwner->GetStrProp(P_ExtOpts_Targ, strTargetFile) == valid)
		{
			CPath path;
			if (path.CreateFromDirAndFilename(((CProject *)m_pOwner)->GetWorkspaceDir(), strTargetFile))
			{
#ifndef REFCOUNT_WORK
				FileRegHandle frh = g_FileRegistry.RegisterFile((const CPath *)&path);
				psetTargetFiles->AddRegHandle(frh);
#else
				FileRegHandle frh = CFileRegFile::GetFileHandle(path);
				psetTargetFiles->AddRegHandle(frh);
				frh->ReleaseFRHRef();
#endif
			}
		}
	}
	else if (m_pOwner->IsKindOf(RUNTIME_CLASS(CProject)) &&
			 pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
    {
        CString strTargetFile;
        if (m_pOwner->GetStrProp(P_Proj_Targ, strTargetFile) == valid)
        {
            CPath path;
            if (path.CreateFromDirAndFilename(((CProject *)m_pOwner)->GetWorkspaceDir(), strTargetFile))
            {
#ifndef REFCOUNT_WORK
                FileRegHandle frh = g_FileRegistry.RegisterFile((const CPath *)&path);
                psetTargetFiles->AddRegHandle(frh);
#else
                FileRegHandle frh = CFileRegFile::GetFileHandle(path);
                psetTargetFiles->AddRegHandle(frh);
				frh->ReleaseFRHRef();
#endif
            }
        }
    }
    else
 	{
		CProjType * pProjType;
 		VERIFY(g_prjcompmgr.LookupProjTypeByName(GetOriginalTypeName(), pProjType));

		// ignore 'Unknown' ProjTypes
		if (!pProjType->IsSupported())
			goto Exit;

		// Only if the tools want this item!
		// FUTURE: for now 'know' that SchmoozeTool's only
		// work on CProject items
		if (!this->m_pOwner->IsKindOf(RUNTIME_CLASS(CProject)))
			goto Exit;

		GraphOpFn pfn = fPrimary ? CFileDepGraph::GetPrimaryTarget : CFileDepGraph::GetAllTarget;
		DWORD dw = (DWORD)psetTargetFiles;
		g_buildengine.GetDepGraph(this)->PerformOperation(pfn, dw);
 	}

Exit:
	// Re-enable file-change notification?
	g_FileRegDisableFC = g_oldFileRegDisableFC;

	// Reset the config.
	m_pOwner->ResetManualBagSearchConfig();

	// Check that we didn't punt due to an 'unknown' target type (CProjType)
#ifndef REFCOUNT_WORK
	if ( psetTargetFiles->GetContent()->IsEmpty() )
#else
	if ( psetTargetFiles->IsEmpty() )
#endif
	{
		delete psetTargetFiles;
		psetTargetFiles = NULL;
	}
	return psetTargetFiles;
}

CFileRegSet * ConfigurationRecord::GetTargetFilesList()
{
	CHECK_CACHE
	// N.B. uses IsEmpty so that TargetFiles default to output files
	// for tools that don't currently maintain a separate targets
	// list (Source tools, etc.)
	// GetTargetFilesList should only be called ConfigurationRecord's
	// owned by a CProject.  m_pTargetFiles will be NULL for anything else.
	ASSERT( m_pOwner->IsKindOf(RUNTIME_CLASS(CProject) ) );

	// REVIEW(tomse): m_pTargetFiles can be NULL if m_pOwner->m_pOwnerTarget==NULL.
	// Should check ConfigurationRecord::Refresh() logic to make sure that
	// m_pTargetFiles is correctly not created.
//	ASSERT( NULL != m_pTargetFiles );

	// speed:3883 - GPF's because m_pTargetFiles is NULL.
	if ( NULL == m_pTargetFiles )
	{
		m_pTargetFiles = new CFileRegSet(1);
	}
	return m_pTargetFiles;
}

void ConfigurationRecord::Refresh () 
{
	// FUTURE: remove this hack
	// It's v.slow, for now disable file-change notification while we do
	// this, we don't need them anyway
	BOOL g_oldFileRegDisableFC = g_FileRegDisableFC;
	g_FileRegDisableFC = TRUE;

	BOOL fForce = FALSE;

	// Here we setup the output and target file lists
	// The property pages rely on these lists having the
	// dominant output/target at the head of the list.
	// This means that the GetOutputPaths method of
	// source tools MUST return a list with the dominant
	// output/target at the head of the list

	m_LastUpdate = nSignature;

	// do we need to force ourselves into the same config.?
	if (m_pOwner->GetActiveConfig() != this)
	{
		m_pOwner->ForceConfigActive (this);
		fForce = TRUE;
	}

 	BOOL bExternal = FALSE;
	CProjType * pProjType = NULL;

	BOOL bOwnerIsProject = m_pOwner->IsKindOf(RUNTIME_CLASS(CProject));
	
	// Are we a regular v2 external makefile
	if (bOwnerIsProject && ((CProject *)m_pOwner)->m_bProjIsExe)
		bExternal = TRUE;
 	else
		// We have to get the projtype of the internal makefile, as we may
		// be dealing with an external target
		VERIFY(g_prjcompmgr.LookupProjTypeByName(GetOriginalTypeName(), pProjType ));

    BOOL bIsExtTarget = (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)));
	// Are we external(i.e. a v2 external makefile, or a v3 external target
	if (bExternal || (bIsExtTarget && bOwnerIsProject))
	{
		CString strTrg, strBsc, strDir;
		CPath pathTrg, pathBsc, pathTemp;
		CDir Dir, *pProjDir;

		pProjDir = &(g_pActiveProject->GetWorkspaceDir());

		FreeOutputFiles();

		// Add the exe and browser as a target:
		// NOTE, these GetStrProp's may fail when we are in the
		// process of loading a project, and so we have to be able
		// to handle failure here.
		if (m_pOwner->GetStrProp(bIsExtTarget ? P_Proj_Targ : P_ExtOpts_Targ, strTrg) != valid)
			goto Exit_Refresh;
		if (m_pOwner->GetStrProp(bIsExtTarget ? P_Proj_BscName : P_ExtOpts_BscName, strBsc) != valid)
			goto Exit_Refresh;

		// always use the workspace dir, since P_Proj_Targ has the targ dir appended alreay
 		Dir = g_pActiveProject->GetWorkspaceDir();
 
		if (pathTrg.CreateFromDirAndFilename ( Dir, strTrg ))
		{
#ifndef REFCOUNT_WORK
			m_arryOutputFiles.Add(g_FileRegistry.RegisterFile ( &pathTrg ));
#else
			m_arryOutputFiles.Add(CFileRegFile::GetFileHandle(pathTrg ));
#endif

			// m_pTargetFiles is only allocated for CProject's.
			if ( bOwnerIsProject )
			{
				if (NULL==m_pTargetFiles)
					m_pTargetFiles = new CFileRegSet(1);

#ifndef REFCOUNT_WORK
				m_pTargetFiles->AddRegHandle(g_FileRegistry.RegisterFile ( &pathTrg ));
#else
				FileRegHandle frhTmp = CFileRegFile::GetFileHandle(pathTrg );
				m_pTargetFiles->AddRegHandle(frhTmp);
				frhTmp->ReleaseFRHRef();
#endif
			}
		}
		if (pathBsc.CreateFromDirAndFilename ( Dir, strBsc ))
		{
#ifndef REFCOUNT_WORK
			m_arryOutputFiles.Add(g_FileRegistry.RegisterFile ( &pathBsc ));
#else
			m_arryOutputFiles.Add(CFileRegFile::GetFileHandle(pathBsc ));
#endif

			// m_pTargetFiles is only allocated for CProject's.
			if ( bOwnerIsProject )
			{
				if (NULL==m_pTargetFiles)
					m_pTargetFiles = new CFileRegSet(1);

#ifndef REFCOUNT_WORK
				m_pTargetFiles->AddRegHandle(g_FileRegistry.RegisterFile ( &pathBsc ));
#else
				FileRegHandle frhTmp = CFileRegFile::GetFileHandle(pathBsc );
				m_pTargetFiles->AddRegHandle(frhTmp);
				frhTmp->ReleaseFRHRef();
#endif
			}
		}
	}
	// Figure out which build tool to use with this file.  Get a pointer to 
	// our project type from the name stored in the base record, and ask for
	// our tool.  Loop through all the configurations if bDoAllConfigs is 
	// true:
	else
	{
		// ignore 'Unknown' ProjTypes
		if (!pProjType->IsSupported())
			goto Exit_Refresh;

		FreeOutputFiles();
		
		CActionSlobList * plstActions = GetActionList();
		POSITION pos = plstActions->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CActionSlob * pAction = (CActionSlob *)plstActions->GetNext(pos);

			CFileRegSet * pSet = pAction->GetOutput(); 
#ifndef REFCOUNT_WORK
			POSITION posFile = ((CPtrList *)pSet->GetContent())->GetHeadPosition();
			while (posFile != (POSITION)NULL)
			{
				FileRegHandle frh =	(FileRegHandle)((CPtrList *)pSet->GetContent())->GetNext(posFile);
#else
			pSet->InitFrhEnum();
			FileRegHandle frh = pSet->NextFrh();
			while (frh != NULL)
			{
#endif
				int count = m_arryOutputFiles.GetSize();
				int index;
				BOOL bGotOne = FALSE;
				for ( index=0; index < count; index++ )
				{
					if ( frh == m_arryOutputFiles[index] )
					{
						bGotOne = TRUE;
						break;
					}
				}

#ifndef REFCOUNT_WORK
				if ( bGotOne )
					continue;	// got already!

#else
				if ( bGotOne )
				{
					// Not added to m_arryOutputFiles.
					frh->ReleaseFRHRef();
					frh = pSet->NextFrh();
					continue;
				}

#endif
				m_arryOutputFiles.Add(frh);
				
				// is this a target tool?
				if (pAction->m_pTool->m_fTargetTool)
				{
					CSchmoozeTool * pTrgTool = (CSchmoozeTool *)pAction->m_pTool;

					if (pTrgTool->IsProductFile(g_FileRegistry.GetRegEntry(frh)->GetFilePath()))
					{
						if (NULL == m_parryTargetFiles)
						{
							m_parryTargetFiles = new CFRFPtrArray;
							ASSERT(NULL==m_pTargetFiles);

							if ( bOwnerIsProject )
								m_pTargetFiles = new CFileRegSet(1);
						}

						if (pTrgTool->m_fDeferredTool)
						{
							// add to back
							m_parryTargetFiles->Add(frh);
							if ( bOwnerIsProject )
							{
								ASSERT(NULL!=m_pTargetFiles);
								m_pTargetFiles->AddRegHandle(frh);
							}
						}
						else
						{
							// add to front
							m_parryTargetFiles->InsertAt(0,frh);
							if ( bOwnerIsProject )
							{
								ASSERT(NULL!=m_pTargetFiles);
								m_pTargetFiles->AddRegHandle(frh, TRUE, TRUE);
							}
						}
					}
				}
				// custom build tool on target?
				else if (bOwnerIsProject &&
						 pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
				{
					// add to back
					if (NULL == m_parryTargetFiles)
					{
						m_parryTargetFiles = new CFRFPtrArray;

						ASSERT(NULL==m_pTargetFiles);
						m_pTargetFiles = new CFileRegSet(1);
					}

					m_parryTargetFiles->Add(frh);
					m_pTargetFiles->AddRegHandle(frh);
				}
#ifdef REFCOUNT_WORK
				frh = pSet->NextFrh();
#endif
			}
		}
	}

// used to expediate exit from Refresh()
Exit_Refresh:

	// Re-enable file-change notification?
	g_FileRegDisableFC = g_oldFileRegDisableFC;

	if (fForce)
		m_pOwner->ForceConfigActive();
}

BOOL ConfigurationRecord::BagSame(UINT idBag1, UINT idBag2, UINT nPropMin, UINT nPropMax, BOOL fUseDefaults, BOOL fCheckPrivate /* = TRUE */)
{
	CPropBag * pBag1 = GetPropBag(idBag1), * pBag2 = GetPropBag(idBag2);
	CProp * pprop1, * pprop2;
	ASSERT(pBag1 != NULL);
	ASSERT(pBag2 != NULL);

	int retval = 1; // default

	BOOL fFullRange = (nPropMin == -1 && nPropMax == -1);

	// check all available props for full compare
	// o first quick-check to see if # of props is same
	const int cBag1 = pBag1->GetPropCount();
	const int cBag2 = pBag2->GetPropCount();

	//
	// Bags are same if both are empty
	//
	if (0==cBag1 && 0==cBag2)
		return TRUE;

	if (fFullRange && cBag1 != cBag2 && (fCheckPrivate))
		return FALSE;	// different # of props, can't be same!

	// FUTURE (matthewt): partial ranges not supported yet!
	if (nPropMin == -1 && nPropMax != -1)
	{
		ASSERT(FALSE);
		return FALSE;
	}
	else if (nPropMin != -1 && nPropMax == -1)
	{
		ASSERT(FALSE);
		return FALSE;
	}

	// full-range compare?
 	ASSERT(nPropMin <= nPropMax);

	BOOL fEndOfRange = FALSE;

	UINT nProp;		// for !fFullRange
	POSITION pos;	// for fFullRange

	//
	// Must also loop over Bag2 when !fCheckPrivate.
	//
	BOOL bLoopingOverBag2 = FALSE;
	int nFoundInBag1 = 0;
	int nFoundInBag2 = 0;

	if (fFullRange)
	{
		if (0==cBag1)
		{
			//
			// Switch over to bag 2 if !fCheckPrivate.
			//
			ASSERT(!fCheckPrivate);
			pos = pBag2->GetStartPosition();
			bLoopingOverBag2 = TRUE;
		}
		else
		{
			pos = pBag1->GetStartPosition();
		}

		ASSERT(NULL!=pos);
	}
	else
		nProp = nPropMin;

	fEndOfRange = fFullRange ? (pos == (POSITION)NULL) : (nProp > nPropMax);
	for ( ;!fEndOfRange; nProp++)
	{
		// get source prop.to compare (method depends on range type)
		if (!bLoopingOverBag2)
		{
			if (fFullRange)
			{
				pBag1->GetNextAssoc(pos, nProp, pprop1);

				// get corresponding destination prop. to compare
				if (cBag2 > nFoundInBag2)
				{
 					pprop2 = pBag2->FindProp(nProp);
					if (NULL!=pprop2)
						nFoundInBag2++;
				}
				else
				{
					pprop2 = NULL;
				}

				//
				// Setup looping through bag 2 if needed.
				//
				if (NULL==pos && !fCheckPrivate  && cBag2 > nFoundInBag2 )
				{
					//
					// Switch over to bag 2 if !fCheckPrivate.
					//
					pos = pBag2->GetStartPosition();
					bLoopingOverBag2 = TRUE;
				}
			}
			else
			{
				//
				// Looping from nPropMin to nPropMax
				//
				if (cBag1 == nFoundInBag1 && cBag2 == nFoundInBag2)
					break;

				if (cBag1 > nFoundInBag1)
				{
 					pprop1 = pBag1->FindProp(nProp);
					if (NULL!=pprop1)
						nFoundInBag1++;
				}
				else
					pprop1 = NULL;

				if (cBag2 > nFoundInBag2)
				{
 					pprop2 = pBag2->FindProp(nProp);
					if (NULL!=pprop2)
						nFoundInBag2++;
				}
				else
					pprop2 = NULL;
			}
		}
		else
		{
			if (cBag2 == nFoundInBag2)
			{
				// We are done!
				break;
			}

			ASSERT(cBag2 > nFoundInBag2);
			ASSERT(fFullRange);
			ASSERT(!fCheckPrivate);
			pBag2->GetNextAssoc(pos, nProp, pprop2);

			//
			// See if we have already processed everything in Bag1 while
			// looping through Bag2.
			//
			if (cBag1 > nFoundInBag1)
			{
 				pprop1 = pBag1->FindProp(nProp);

				//
				// If found in Bag1, proprety was already processed in Bag1 loop.
				// else this is a new proprety found in Bag2.
				//
				if (NULL!=pprop1)
				{
					nFoundInBag1++;
					continue;
				}
			}
			else
				pprop1 = NULL;

			ASSERT(NULL==pprop1);
			nFoundInBag2++;
		}

		// check for end_of_while condition (depends on range type)
		fEndOfRange = fFullRange ? (pos == (POSITION)NULL) : (nProp == nPropMax);

  		// in neither? (logical XOR)
		if (pprop1 == (CProp *)NULL || pprop2 == (CProp *)NULL)
		{
			if (pprop1 != (CProp *)NULL || pprop2 != (CProp *)NULL)
			{
				// normalize (pprop2 to be NULL)
				if (pprop2 != (CProp *)NULL)
				{
					pprop1 = pprop2; pprop2 = (CProp *)NULL;
				}

				// one of the property bags doesn't have a prop. use
				// the defaults for that bag in the comparision?
				// (*only* if we are the base-prop. bag, ie. the owner is *not* a child)
				if (!fUseDefaults || m_pOwner->GetContainer() != (CSlob *)NULL)
				{
					if (fCheckPrivate || IsPropPublic(nProp))
						return FALSE;	// different!
					retval = -1;
					continue;
				}

				// do we have an option handler?
				COptionHandler * popthdlr = g_prjcompmgr.FindOptionHandler(nProp);
				if (popthdlr == (COptionHandler *)NULL)
				{
					// no handler == no default, so different!
					if (fCheckPrivate || IsPropPublic(nProp))
						return FALSE;	// different!
					retval = -1;
					continue;
				}

				// make sure the option handling refers to our owner!
		 		m_pOwner->ForceConfigActive(this);
				popthdlr->SetSlob(m_pOwner);

				// is this a value in our default property map?
				BOOL fIsDefault = FALSE;

				// always show default props
				BOOL fOldUseDefault = m_pOwner->UseOptionDefaults();
		  		switch (pprop1->m_nType)
				{
					case integer:
					{
						int nVal;
						fIsDefault = popthdlr->GetDefIntProp(nProp, nVal) == valid &&
									 ((CIntProp*)pprop1)->m_nVal == nVal;
						break;
					}
   
					case string:
					{
						CString strVal;
						fIsDefault = popthdlr->GetDefStrProp(nProp, strVal) == valid &&
									 ((CStringProp*)pprop1)->m_strVal == strVal;
						break;
					}
		
					default:
						ASSERT(FALSE);
						break;
				}
	
				// reset the option handler CSlob
				(void) m_pOwner->UseOptionDefaults(fOldUseDefault);
		 		m_pOwner->ForceConfigActive();
				popthdlr->ResetSlob();

				if (!fIsDefault)
				{
					// not a default, so different!
					if (fCheckPrivate || IsPropPublic(nProp))
						return FALSE;	// different!
					retval = -1;
					continue;
				}
			}

			continue;	// the same...
			// next one
		}

		// same type?
		if (pprop1->m_nType != pprop2->m_nType)
		{
			if (fCheckPrivate || IsPropPublic(nProp))
				return FALSE;	// different!
			retval = -1;
			continue;
		}

  		switch (pprop1->m_nType)
		{
			case integer:
				if (((CIntProp*)pprop1)->m_nVal != ((CIntProp*)pprop2)->m_nVal)
				{
					if (fCheckPrivate || IsPropPublic(nProp))
						return FALSE;	// different!
					retval = -1;
					continue;
				}
				break;

			case string:
				if (((CStringProp*)pprop1)->m_strVal != ((CStringProp*)pprop2)->m_strVal)
				{
					if (fCheckPrivate || IsPropPublic(nProp))
						return FALSE;	// different!
					retval = -1;
					continue;
				}
				break;
		
			default:
				ASSERT(FALSE);
				return FALSE;
		}

		// next one
	}

	return retval;	// the same
}

void ConfigurationRecord::BagCopy(UINT idBagSrc, UINT idBagDest, UINT nPropMin, UINT nPropMax, BOOL fInform)
{
	CPropBag * pBagSrc = GetPropBag(idBagSrc), * pBagDest = GetPropBag(idBagDest);
	ASSERT(pBagSrc != NULL);
	ASSERT(pBagDest != NULL);

	CProp * ppropSrc, * ppropDest;

	// need to make sure we are in the right config in case of inform
	if (fInform)
		m_pOwner->SetManualBagSearchConfig(this);

	// copy from our source to the destination the props in
	// our range by either adding or replacing prop. values
	POSITION pos = pBagSrc->GetStartPosition();
	while (pos != NULL)
	{
		BOOL fDifferent = TRUE;

		UINT id;
		// get the next prop from our source
		pBagSrc->GetNextAssoc(pos, id, ppropSrc);

		// make range checkes against minimum and maximum props
		if ((nPropMin != -1 && id < nPropMin) ||
			(nPropMax != -1 && id > nPropMax))
			continue;

		// get the equiv. in our destination
		ppropDest = pBagDest->FindProp(id);

		// make sure the types are the same if found in both bags
		ASSERT(ppropDest == (CProp *)NULL || ppropSrc->m_nType == ppropDest->m_nType);

		// do the copy (FUTURE: no Undo)
		switch (ppropSrc->m_nType)
		{
			case integer:
				if (ppropDest != (CProp *)NULL)
				{
					// exists in destination, just do in-place set and check for equivalence
					fDifferent = ((CIntProp*)ppropDest)->m_nVal != ((CIntProp*)ppropSrc)->m_nVal;
					((CIntProp*)ppropDest)->m_nVal = ((CIntProp*)ppropSrc)->m_nVal;
				}
				else
				{
					// doesn't exist, add the prop.
					pBagDest->AddProp(id, new CIntProp(((CIntProp*)ppropSrc)->m_nVal));
				}
				break;

			case string:
				if (ppropDest != (CProp *)NULL)
				{
					// exists in destination, just do in-place set and check for equivalence
					fDifferent = ((CStringProp*)ppropDest)->m_strVal != ((CStringProp*)ppropSrc)->m_strVal;
					((CStringProp*)ppropDest)->m_strVal = ((CStringProp*)ppropSrc)->m_strVal;
				}
				else
				{
					// doesn't exist, add the prop.
					pBagDest->AddProp(id, new CStringProp(((CStringProp*)ppropSrc)->m_strVal));
				}
				break;
		
			default:
				ASSERT(FALSE);
				break;
		}

		if (fInform && fDifferent)
		{
			m_pOwner->InformDependants(id);

			// got an option handle for this?
			COptionHandler * popthdlr = g_prjcompmgr.FindOptionHandler(id);
			if (popthdlr != (COptionHandler *)NULL)
			{
				popthdlr->SetSlob(m_pOwner);

				// integer changes
				if (ppropSrc->m_nType == integer)
					popthdlr->OnOptionIntPropChange(id, ((CIntProp*)ppropSrc)->m_nVal);

				// string changes
				else if (ppropSrc->m_nType == string)
					popthdlr->OnOptionStrPropChange(id, ((CStringProp*)ppropSrc)->m_strVal);

				// reset the option handler CSlob
				popthdlr->ResetSlob();
			}
		}
	}

	// remove from our destination all those props. not copied
	pos = pBagDest->GetStartPosition();
	while (pos != NULL)
	{
		UINT id;
		// get the next prop in our destination
		pBagDest->GetNextAssoc(pos, id, ppropSrc);

		// make range checkes against minimum and maximum props
		if ((nPropMin != -1 && id < nPropMin) ||
			(nPropMax != -1 && id > nPropMax))
			continue;

		// not in our source bag, so delete (it exists!)
		if (!pBagSrc->FindProp(id) && pBagDest->FindProp(id))
		{
			if (fInform)
			{
				// m_pOwner->InformDependants(id);

				// review: should this also be deferred until after prop is changed

				// got an option handle for this?
				COptionHandler * popthdlr = g_prjcompmgr.FindOptionHandler(id);
				if (popthdlr != (COptionHandler *)NULL)
				{
					popthdlr->SetSlob(m_pOwner);

					// integer changes
					if (ppropSrc->m_nType == integer)
						popthdlr->OnOptionIntPropChange(id, 0);

					// string changes
					else if (ppropSrc->m_nType == string)
						popthdlr->OnOptionStrPropChange(id, "");

					// reset the option handler CSlob
					popthdlr->ResetSlob();
				}
			}

			pBagDest->RemoveProp(id);

			// defer inform until after prop is actually changed
			if (fInform)
			{
				m_pOwner->InformDependants(id);
			}
		}
	}

	// restore to previous state
	if (fInform)
		m_pOwner->ResetManualBagSearchConfig();
}

#ifdef _DEBUG
void ConfigurationRecord::AssertValid() const
{
	// should point to top level record
	ASSERT(m_pBaseRecord == m_pBaseRecord->m_pBaseRecord);
}

void ConfigurationRecord::Dump (CDumpContext &DC) const
{
}
#endif

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------	CProjItem ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////
#define theClass CProjItem
BEGIN_SLOBPROP_MAP(CProjItem, CProjSlob)
END_SLOBPROP_MAP()
#undef theClass

const CString & CProjItem::GetTargetName() { return GetTarget()->GetTargetName(); }

void CProjItem::DeleteContents()
{

	// free-up our output files references
	int nIndex, nSize = GetPropBagCount();
	for (nIndex = 0; nIndex < nSize; nIndex++)
		((ConfigurationRecord *)m_ConfigArray[nIndex])->FreeOutputFiles();

	// delete all its children
	// NOTE: We cannot use a normal GetHeadPosition, GetNext loop here,
	// as removing one item may result in removing another item in the list
	// This situation occurs when we remove a file item and this results in
	// the removal of the corresponding dependency container
	CObList * pContentList = GetContentList();
	if (pContentList)
	{
		while (!pContentList->IsEmpty())
		{
 	    	// any contained slobs should also be items..
			CProjItem * pItem = (CProjItem *) pContentList->GetHead();
			ASSERT(pItem != NULL);
			ASSERT_VALID(pItem);
			RemoveDependant(pItem);

			// delete
			pItem->MoveInto(NULL);
		}
	}

	// remove our reference?
#ifndef REFCOUNT_WORK
	FileRegHandle frh;
	if ((frh = GetFileRegHandle()) != (FileRegHandle)NULL)
		g_FileRegistry.ReleaseRegRef(frh);
#endif

	// delete our configuration records
	for (nIndex = 0; nIndex < nSize; nIndex++)
		delete (ConfigurationRecord *)m_ConfigArray[nIndex];

	m_ConfigArray.RemoveAll();
	m_ConfigMap.RemoveAll();

	m_pActiveConfig = NULL;
}
///////////////////////////////////////////////////////////////////////////////
CProjItem::CProjItem ()	: m_ConfigMap (3)
{
	m_ConfigMap.InitHashTable(3);

	// our current 'owner' project is undefined currently!
	m_pOwnerProject = (CProject *)NULL;

	// our current 'owner' target is undefined currently!
	m_pOwnerTarget = (CTargetItem *)NULL;

	// by default prop search uses inheritance
	// by default prop search uses default
	// by default we are not anti-options
	// no manual bag find
	m_optbeh = OBInherit | OBShowDefault;

	// by default we are not figuring a dep!
	m_fPropsDepFigure = FALSE;

	// default is outside config switches
	m_cp = EndOfConfigs;

	// no active or forced configuration
	m_pActiveConfig = m_pForcedConfig = NULL;

	// no manual config rec. by deault
	m_pManualConfigRec = NULL;

	// not getting a list string using ::GetStrProp
 	m_fGettingListStr = FALSE;

	// Default is to use the current property bag for each config. rec.
	m_idBagInUse = CurrBag;
}
///////////////////////////////////////////////////////////////////////////////
CProjItem::~CProjItem()
{
}
///////////////////////////////////////////////////////////////////////////////
CTargetItem * CProjItem::GetTarget()
{
	// do we have one cached?
	if (m_pOwnerTarget != (CTargetItem *)NULL)
		return m_pOwnerTarget;

	// no, so try to find it given the active target
	ConfigurationRecord * pcr = GetActiveConfig();
	CProject * pProject = GetProject();
	if (pcr == (ConfigurationRecord *)NULL || pProject == (CProject *)NULL)
		return (CTargetItem *)NULL;

	// the active one
	return pProject->GetTarget(pcr->GetConfigurationName());
}
///////////////////////////////////////////////////////////////////////////////
// Removes project item from view 
BOOL CProjItem::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// removing item altogether from project?
	if (fFromPrj || fPrjChanged)
	{
		// remove ourselves, and remove children..
		CFileRegistry * preg = GetRegistry();
		ASSERT(preg != (CFileRegistry *)NULL);
		preg->RemoveFromProject(this, CouldBeContainer(pContainer));

		// free-up our output files references
		int nIndex, nSize = GetPropBagCount();
		for (nIndex = 0; nIndex < nSize; nIndex++)
			((ConfigurationRecord *)m_ConfigArray[nIndex])->FreeOutputFiles();
	}

	return TRUE;	// success
}

// Alters the containment and fixes configs. of item,
// but not 'officially' in or out-of project
BOOL CProjItem::MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	BOOL fRefreshDeps = FALSE;

	CTargetItem * pTarget = GetTarget();
	CProject * pProject = GetProject();

	// moving from a project?
	if ((fFromPrj) && (pProject != NULL))
	{
 
		ASSERT(pTarget != NULL);

		// set the project to into each valid config. for this target
		const CPtrArray * pCfgArray = pTarget->GetConfigArray();
		int iSize = pCfgArray->GetSize();
		for (int i = 0; i < iSize; i++)
		{
			ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(i);

			if ( pcr->IsValid())
			{
				// refresh our container's dependencies?
				// project not being created/destroyed?
				if (!fRefreshDeps && pProject->m_bProjectComplete)
				{
					CProjTempConfigChange projTempConfigChange(pProject);
					projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);

					ASSERT(GetActiveConfig());
					CActionSlobList * pActions = GetActiveConfig()->GetActionList();

					projTempConfigChange.Release();
					
					// only check the first action for a file (we only have one currently)
					if (!pActions->IsEmpty() && pActions->GetCount() == 1)
					{
						CActionSlob * pAction = (CActionSlob *)pActions->GetHead();
#ifndef REFCOUNT_WORK
						fRefreshDeps = !pAction->GetScannedDep()->GetContent()->IsEmpty() ||
									   !pAction->GetSourceDep()->GetContent()->IsEmpty();
#else
						fRefreshDeps = !pAction->GetScannedDep()->IsEmpty() ||
									   !pAction->GetSourceDep()->IsEmpty();
#endif
					}
				}

				// FUTURE: optimize by only doing this if its moving to a new target...
				
				// un-assign actions to each of this items configurations
				// *OR* if we going into an undo then un-bind actions from the build instance
				ASSERT(fFromPrj);
				if (fPrjChanged || (!CouldBeContainer(pContainer) && !fToPrj))
					CActionSlob::UnAssignActions(this, (CPtrList *)NULL, pcr, CouldBeContainer(pContainer));
				else if (!fToPrj)
					CActionSlob::UnBindActions(this, (CPtrList *)NULL, pcr, TRUE /* CouldBeContainer(pContainer) */ );

			}
		}

		// removing item altogether from project?
		// and project not being created/destroyed?
		if ((!fToPrj || fPrjChanged) && GetProject()->m_bProjectComplete)
		{
			// if we're removing a project item from the project we need to 
			// isolate it from the container
			IsolateFromProject(); // Rvw: overkill for drag & drop
		}
	}	

	// fix our 'cached' containment
	// so that any notifies from below work
	// moved to a project?
	if (fToPrj)
	{
		// Search for our new 'owner' project correctly
		CSlob * pSlob = pContainer;
		CTargetItem * pNewTarg = NULL;
		while (!pSlob->IsKindOf(RUNTIME_CLASS(CProject)))
		{
			// can we find the target 'owner'?
			if (pSlob->IsKindOf(RUNTIME_CLASS(CTargetItem)))
				pNewTarg = (CTargetItem *)pSlob;

			// must be able to find a project 'owner'
			pSlob = pSlob->GetContainer();
			ASSERT(pSlob != (CSlob *)NULL);
		}

#if 0	// should already be done above!
		if (fFromPrj && ((GetProject() != (CProject *)pSlob) || fPrjChanged))
		{
			// if we're moving from one project to another we also need to 
			// isolate it from the old container
			IsolateFromProject(); // Rvw: overkill for drag & drop
		}
#endif

		if ((pNewTarg==NULL) && (IsKindOf(RUNTIME_CLASS(CTargetItem))))
			pNewTarg = (CTargetItem *)this; // hey, we are the target

		// Cache our notion of the 'owner' project
		SetOwnerProject((CProject *)pSlob, pNewTarg);
	}
	// else from a project

	// alter our containment
	// if pContainer == NULL then this will *delete*
	// ourselves, do *not* access object data from here
	// on out in this situation
	if (!CSlob::SetSlobProp(P_Container, pContainer))
		return FALSE;

	// fix our 'cached' containment
	// so that any notifies from below work
	// moved to a project?
	if (fToPrj)
	{
		// moving to a project by removing from a project or undo'ing?
		// yes, then match the new container's configurations.
		// (This may require the deletion of some)
		if (fFromPrj || fPrjChanged || (pOldContainer == NULL) || pOldContainer == &theUndoSlob)
			CloneConfigs((const CProjItem *)pContainer);
	}
	// else from a project into something else
	else if (theUndoSlob.IsRecording())
	{
		// *Not* a project item -> *No* owner project -> *No* owner target,
		// most likely contained in the undo CSlob, or some such thing
		ASSERT((pContainer == (CSlob *)NULL) || pContainer == &theUndoSlob || pContainer->IsKindOf(RUNTIME_CLASS(CClipboardSlob)));
		SetOwnerProject(NULL, NULL);
	}

	return TRUE;	// success
}

// Make item item 'officially' in or out-of project    
BOOL CProjItem::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// moving into the project?
	if (fToPrj)
	{
 		// restore ourselves, include children only if not being created?
		CFileRegistry * preg = GetRegistry();
		ASSERT(preg != (CFileRegistry *)NULL);
		BOOL bContents = ((GetProject()== NULL) || (GetProject()->m_bProjectComplete)); // true except when reading project file
		preg->RestoreToProject(this, bContents); // REVIEW

		CTargetItem * pTarget = GetTarget();
		CProject * pProject = GetProject();

		ASSERT(pTarget!=NULL);
		ASSERT(pProject!=NULL);
		if ((pTarget==NULL) || (pProject==NULL))
			return FALSE; // can happen with bogus makefile

		// Set the project to into each valid config. for this target
		const CPtrArray * pCfgArray = pTarget->GetConfigArray();
		int iSize = pCfgArray->GetSize();
		for (int i = 0; i < iSize; i++)
		{
			ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(i);

			if ( pcr->IsValid())
			{
				// assign actions to each of the items configurations or
				// *OR* if we coming in from an undo then re-bind to the build instance
				ASSERT(fToPrj);
				if (((!CouldBeContainer(pOldContainer)) && (!fFromPrj)) || fPrjChanged)
				{
					// ASSERT(pOldContainer);
					CActionSlob::AssignActions(this, (CPtrList *)NULL, pcr, CouldBeContainer(pOldContainer));
				}
				else if (!fFromPrj)
					CActionSlob::BindActions(this, (CPtrList *)NULL, pcr, CouldBeContainer(pOldContainer));

			}
		}

        // Dirty the project since we will have to save this change
		if (!IsKindOf(RUNTIME_CLASS(CDependencyFile)) && 
			!IsKindOf(RUNTIME_CLASS(CProjectDependency)) && 
			!IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		{
			pProject->DirtyProject();
		}
	}
	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
void CProjItem::GetMoniker(CString& cs) 
{
	GetStrProp (P_ProjItemName, cs);
}
///////////////////////////////////////////////////////////////////////////////
int CProjItem::CompareMonikers (CString& str1, CString& str2)
{
	return _tcsicmp ((const char *)str1, (const char *)str2);
}	
///////////////////////////////////////////////////////////////////////////////
const CPath *CProjItem::GetFilePath () const
{
	FileRegHandle frh = GetFileRegHandle();
	if (frh) return g_FileRegistry.GetRegEntry(frh)->GetFilePath();
	else 	 return NULL;
} 
///////////////////////////////////////////////////////////////////////////////
FileRegHandle CProjItem::GetFileRegHandle () const 
{
	return NULL; 
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SetFile (const CPath *pPath, BOOL bCaseApproved /* = FALSE */)
{
	TRACE ( "CProjItem::SetFile() called for non-File class %s\n", 
												GetRuntimeClass()->m_lpszClassName );
 	// ASSERT (FALSE);
	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////
// Verb Commands
BOOL CProjItem::CanDoScan()
{
	BOOL fOkToScan = !g_Spawner.SpawnActive();

	return fOkToScan;
}



void CProjItem::CmdCompile(BOOL bMenu)
{
	// StartCAP();
	UINT nPos = 0;
	if( !bMenu ){
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
		VERIFY(SUCCEEDED(pProjSysIFace->GetVerbPosition(&nPos)));
	}

 	BOOL bClearOutputWindow = (nPos == 0);

	CBuildIt wholeBuild;
	(VOID) DoTopLevelBuild(TOB_Build, NULL, fcaNeverQueried, TRUE, bClearOutputWindow, TRUE);

	// StopCAP();
}

void CProjItem::CmdClean()
{
	// StartCAP();
	CBuildIt wholeBuild(FALSE);
	(VOID) DoTopLevelBuild(TOB_Clean);
	// StopCAP();
}

void CProjItem::CmdReBuild()
{
	// StartCAP();
	CBuildIt wholeBuild;

	(VOID) DoTopLevelBuild(TOB_Clean);
	CBuildIt::m_mapConfigurationsBuilt.RemoveAll();
	(VOID) DoTopLevelBuild(TOB_ReBuild,NULL,fcaNeverQueried,TRUE,FALSE); // don't clear output window for second build
	// StopCAP();
}

void CProjItem::CmdBuild()
{
	// StartCAP();
	CBuildIt wholeBuild;
	(VOID) DoTopLevelBuild(TOB_Build);
	// StopCAP();
}

BOOL g_bBatchBuildInProgress = FALSE;
void CProjItem::CmdBatchBuild(BOOL bBuildAll, CStringList * pConfigs, BOOL bRecurse /* = TRUE */, BOOL bClean /* = FALSE */)
{
	// StartCAP();
	CBuildIt wholeBuild(bBuildAll || !bClean);

	g_bBatchBuildInProgress = TRUE;
	if (pConfigs->GetCount() > 0) {
		// save the original config
		CString strActiveConfig;
		// CProject * pProject = GetProject();
		// pProject->GetStrProp(P_ProjActiveConfiguration, strActiveConfig);

		// Do the build
		if( bBuildAll ) {
			ASSERT(!bClean);
			CStringList dupConfigs;
			for (POSITION pos = pConfigs->GetHeadPosition (); pos != NULL; )
			{
				dupConfigs.AddTail( pConfigs->GetNext (pos) );
			}

			(VOID) DoTopLevelBuild( TOB_Clean,pConfigs,fcaNeverQueried,TRUE,TRUE,bRecurse);
			CBuildIt::m_mapConfigurationsBuilt.RemoveAll();
			(VOID) DoTopLevelBuild( TOB_ReBuild, &dupConfigs,fcaNeverQueried,TRUE,FALSE,bRecurse); // don't clear output window for second build
		} else {
			(VOID) DoTopLevelBuild( bClean ? TOB_Clean : TOB_Build, pConfigs,fcaNeverQueried,TRUE,TRUE,bRecurse);
		}

		// Restore the original config.
		// pProject->SetStrProp(P_ProjActiveConfiguration, strActiveConfig);
	}
	g_bBatchBuildInProgress = FALSE;
	// StopCAP();
}

// FUTURE: move these into bldrfile.cpp
const TCHAR *CProjItem::EndToken = _TEXT ("End");
const TCHAR *CProjItem::pcFileMacroName = _TEXT ("SOURCE");
const TCHAR *CProjItem::pcFileMacroNameEx = _TEXT ("$(SOURCE)"); 	

BOOL CProjItem::WriteToMakeFile
(
	CMakFileWriter& pw,
	CMakFileWriter& mw,
	const CDir &BaseDir,
	CNameMunger& nm
)
{
	PFILE_TRACE ("%s at %p called CProjItem::WriteToMakeFile (do nothing)\n",
				 GetRuntimeClass()->m_lpszClassName, this);
	return TRUE;	// success by default
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
/** If you change this table, you MUST change HasMakefileProperties to match */
const CProjItem::PropWritingRecord CProjItem::nMakeFileProps[] = {
	{P_ProjUseMFC,	 			_TEXT("Use_MFC"),				integer, PropRead | PropWrite | All},
	{P_UseDebugLibs,	 		_TEXT("Use_Debug_Libraries"),	integer, PropRead | PropWrite | All},
	{P_OutDirs_Target, 			_TEXT("Output_Dir"),			string, PropRead | PropWrite | All},
	{P_OutDirs_Intermediate,	_TEXT("Intermediate_Dir"),		string, PropRead | PropWrite | All},
	{P_Proj_TargDefExt,	 		_TEXT("Target_Ext"),			string, PropRead | PropWrite | Project},
	{P_Proj_CmdLine,			_TEXT("Cmd_Line"),				string, PropRead | PropWrite | Project},
	{P_Proj_RebuildOpt,			_TEXT("Rebuild_Opt"),			string, PropRead | PropWrite | Project},
	{P_Proj_Targ,				_TEXT("Target_File"),			string, PropRead | PropWrite | Project},
	{P_Proj_BscName,			_TEXT("Bsc_Name"),				string, PropRead | PropWrite | Project},
//    {P_Proj_WorkingDir,         _TEXT("Bld_Working_Dir"),       string, PropRead | PropWrite | Project},
	{P_ItemExcludedFromBuild,	_TEXT("Exclude_From_Build"),	integer, PropRead | PropWrite | File | TargetRef},
	{P_ItemExcludedFromScan,	_TEXT("Exclude_From_Scan"),	integer, PropRead | PropWrite | File | Group | NotPerConfig},
	{P_ProjClsWzdName,			_TEXT("Classwizard_Name"),		string, PropRead | PropWrite | Project},
	{P_GroupDefaultFilter,		_TEXT("Default_Filter"),	string, PropRead | PropWrite | Group | NotPerConfig },
	{P_Proj_PerConfigDeps,		_TEXT("AllowPerConfigDependencies"),	integer, PropRead | PropWrite | Project | NotPerConfig },
#ifdef VB_MAKEFILES
	{P_Proj_IsVB,				_TEXT("VB_Project"),		integer, PropRead | PropWrite | Project | NotPerConfig },
	{P_VBProjName,				_TEXT("VB_ProjectName"),		string, PropRead | PropWrite | Project | NotPerConfig },
#endif
	{P_Proj_IgnoreExportLib,	_TEXT("Ignore_Export_Lib"),		integer, PropRead | PropWrite | Project },
	{P_ItemIgnoreDefaultTool,	_TEXT("Ignore_Default_Tool"),		integer, PropRead | PropWrite | File },

// Scc
	{P_ProjSccProjName,			_TEXT("Scc_ProjName"),	string, PropRead | PropWrite | NotPerConfig | Project},
	{P_ProjSccRelLocalPath,		_TEXT("Scc_LocalPath"),	string, PropRead | PropWrite | NotPerConfig | Project},

// NB: if you add or remove any Writeable props here, you MUST also
// update the constant nWriteableProps constant below:
#ifdef VB_MAKEFILES
#define nWriteableProps (20)
#else
#define nWriteableProps (18)
#endif
// we should eliminate this redundancy, put in a marker item or put the two types of props in seperate arrays

	// Really, these are project only.  Also, they are not per conifg, so 
	// they would not be written out properly.  However, they are only read in:
	{P_ProjMarkedForScan,		_TEXT("Marked_For_Scan"),		integer, PropRead | Project | NotPerConfig },
	{P_ProjMarkedForSave,		_TEXT("Marked_For_Save"),		integer, PropRead | Project | NotPerConfig },
	{P_ProjHasNoOPTFile,		_TEXT("Has_No_OPT_File"),		integer, PropRead | Project | NotPerConfig },
	{P_TargetRefName,		_TEXT("Target_Ref_Name"),		string, PropRead | TargetRef },
	{P_Proj_TargDir,	 		_TEXT("Target_Dir"),			string, PropRead | Project},	// only needed for conversions (ignored)
// NB: if you add or remove any Read-only props here, you MUST also
// update the constant nReadOnlyProps constant below:
#define nReadOnlyProps (5) // should be eliminated, as above
	{P_END_MAP, NULL, null},
};

// FUTURE: move these into bldfile.cpp
const TCHAR *CProjItem::pcPropertyPrefix 	= _TEXT("PROP ");
const TCHAR *CProjItem::pcADD 				= _TEXT("ADD ");
const TCHAR *CProjItem::pcSUBTRACT			= _TEXT("SUBTRACT ");
const TCHAR *CProjItem::pcBASE				= _TEXT("BASE ");

// Consider: use this elsewhere
static CString & StripTrailingSlash(CString & str)
{
	int len = str.GetLength();
	_TCHAR * pchStart = str.GetBuffer(len);
	_TCHAR * pchEnd = pchStart + len;
	if (len > 1)
	{
		pchEnd = _tcsdec(pchStart, pchEnd);
		if ((pchEnd > pchStart) && ((*pchEnd =='/') || (*pchEnd == '\\')))
		{
			*pchEnd = 0;
			len = pchEnd - pchStart;
		}
	}

	str.ReleaseBuffer(len);
	return str;
}

BOOL CProjItem::GetOutDirString
(
	CString & str,
	CString * pstrValue, /* = NULL */
	BOOL bAllowItemMacro, /* = FALSE */
	BOOL fRecurse /* = FALSE */
)
{
	ASSERT(!bAllowItemMacro); // no longer supported

	// default is target prop for project
	UINT PropId = P_OutDirs_Target;

	CProjItem * pItem = GetProject();
	ASSERT(pItem != (CProjItem *)NULL);

	BOOL fForced = FALSE;

	// are we not a project or target item?
	if (this != pItem && this != GetTarget())
	{
		// no
		PropId = P_OutDirs_Intermediate;

		// can we get the property?
		if (GetPropBag()->FindProp(PropId))
		{
			// if (!bAllowItemMacro)
			return FALSE;

			// yes so use us!
			// pItem = (CProjItem *)this;
		}
		else
		{
			// try to get it from our parent project instead
			// (base-record *is* project config. record)
			ASSERT(GetActiveConfig());
			if (pItem->GetActiveConfig() != GetActiveConfig()->m_pBaseRecord)
			{
				pItem->ForceConfigActive((ConfigurationRecord *)GetActiveConfig()->m_pBaseRecord);
				fForced = TRUE;
			}
		}
	}

	BOOL fRet = pItem->GetOutDirString(str, PropId, pstrValue, TRUE, fRecurse);

	if (fForced) // restore original config.?
		pItem->ForceConfigActive();

	return fRet;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::GetOutDirString
(
	CString & str,
	UINT PropId,
	CString * pstrValue, /* = NULL */
	BOOL bMacro, /* = TRUE */
	BOOL fRecurse /* = FALSE */
)
{	
	// the rest are output directory related
	// find one somewhere in the hierarchy
	CProjItem * pItem = this;

	CProp * pprop = pItem->GetPropBag()->FindProp(PropId);
	while (fRecurse && pprop == (CProp *)NULL)
	{
		// *chain* the proper. config.
		CProjItem * pItemOld = pItem;
		pItem = (CProjItem *)pItem->GetContainerInSameConfig();
		if (pItemOld != (CProjItem *)this)
			pItemOld->ResetContainerConfig();

		if (pItem == (CProjItem *)NULL)
			break;	// not found in hierarchy

		pprop = pItem->GetPropBag()->FindProp(PropId);
	}

	// reset the last container we found
	if (pItem != (CProjItem *)NULL && pItem != (CProjItem *)this)
		pItem->ResetContainerConfig();

	// did we get one? fail if this isn't the target level
	if (pprop == (CProp *)NULL && !IsKindOf(RUNTIME_CLASS(CProject)))
		return FALSE;	// failure

	if (pstrValue)
	{
		// get the value
		CString strOutDir = pprop == (CProp *)NULL ? _TEXT("") : ((CStringProp *)pprop)->m_strVal;

		if (strOutDir.IsEmpty())
		{
			*pstrValue = _T('.');
		}
		else
		{
			strOutDir.TrimLeft();
			pstrValue->GetBuffer(strOutDir.GetLength() + 3);
			pstrValue->ReleaseBuffer(0);

			const TCHAR * pch = (const TCHAR *)strOutDir;

			// prepend ".\\" if not absolute or UNC path or already relative
			if ((pch[0] != _T('\\')) && 
				(pch[0] != _T('/')) &&
				(!(pch[0] == _T('.') && pch[1] == _T('\\'))) &&
				(!IsDBCSLeadByte (pch[0]) && (pch[1] != _T(':'))) || (IsDBCSLeadByte (pch[0])) 
				)
			{
				*pstrValue += _T(".\\");
			}

			*pstrValue += strOutDir;
			StripTrailingSlash(*pstrValue);
		}
	}

	str.GetBuffer(13); str.ReleaseBuffer(0);

	if (bMacro) str += _T("$(");

	// get the output directory macro name
	str += PropId == P_OutDirs_Intermediate ? _T("INTDIR") : _T("OUTDIR");

	// was this found in a file?
	if (IsKindOf(RUNTIME_CLASS(CFileItem)) && GetPropBag()->FindProp(PropId))
	{
		str += _T("_SRC");	// decorate the file-level output directory macro name
		return FALSE; // no longer supported
	}

	if (bMacro) str += _T(')');

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SubstOutDirMacro(CString & str, const ConfigurationRecord * pcr)
{
	// substitute for $(OUTDIR) macro if nessessary

	if (pcr==NULL)	// this is not optional
		return FALSE;

	int nFndLoc;
	CString strOutDirMacro, strOutDirValue;
	BOOL retval = FALSE;
	if (pcr != GetActiveConfig())
		SetManualBagSearchConfig((ConfigurationRecord *)pcr);

	if (GetOutDirString(strOutDirMacro, &strOutDirValue))
	{
		nFndLoc = str.Find(strOutDirMacro);
		if (nFndLoc != -1)
		{
			// ASSERT(nFndLoc==0);
			str = str.Left(nFndLoc) + strOutDirValue + str.Mid(nFndLoc + strOutDirMacro.GetLength());
			retval = TRUE;
		}
	}

	if (pcr != GetActiveConfig())
		ResetManualBagSearchConfig();

	return retval;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::WriteOutDirMacro(CMakFileWriter & mw)
{
	ASSERT(g_bExportMakefile);
	ASSERT(mw.IsMakefile());

	// don't do this for CTargetItems
	if (IsKindOf(RUNTIME_CLASS(CTargetItem)))
		return TRUE;

	BOOL retVal = TRUE;

	TRY
	{
		CString strMacro, strValue;

		// write macros, if necessary
		if (GetOutDirString(strMacro, P_OutDirs_Target, &strValue, FALSE))
		{
			ASSERT(this == GetProject());
			mw.WriteMacro(strMacro, strValue);
		}

		if (GetOutDirString(strMacro, P_OutDirs_Intermediate, &strValue, FALSE))
			mw.WriteMacro(strMacro, strValue);
	}
	CATCH (CException, e)
	{
		retVal = FALSE;	// failure
	}
	END_CATCH

	return retVal;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::WriteOutDirDescBlk(CMakFileWriter & mw)
{
	ASSERT(mw.IsMakefile());

	BOOL retVal = TRUE;
	CProject * pProject = GetProject();
	ASSERT(pProject != (CProject *)NULL);

	TRY
	{
		CPropBag * pBag;

		ASSERT(GetActiveConfig());
		pBag = ((ConfigurationRecord *)GetActiveConfig())->GetPropBag(CurrBag);
		CStringProp * pOutProp = (CStringProp *)pBag->FindProp(P_OutDirs_Target);
		CStringProp * pIntProp = (CStringProp *)pBag->FindProp(P_OutDirs_Intermediate);

		pBag = ((ConfigurationRecord *)GetActiveConfig()->m_pBaseRecord)->GetPropBag(CurrBag);
		CStringProp * pProjOutProp = (CStringProp *)pBag->FindProp(P_OutDirs_Target);
		CStringProp * pProjIntProp = (CStringProp *)pBag->FindProp(P_OutDirs_Intermediate);

		CString strMacro;

		// next write dep line and 'build rule', if necessary
		if (pOutProp && !pOutProp->m_strVal.IsEmpty())
		{
			// Currently, only the project can have an OutDir defined
			ASSERT(this == pProject);

			// write '"$(OUTDIR)" :'
			VERIFY(GetOutDirString(strMacro, P_OutDirs_Target));
		}
		
		// write OUTDIR inference rule
		if (!strMacro.IsEmpty())
		{
			// write dependency line for '"$(...)" :'
			CString strValue;

			strValue = _T('\"');
			strValue += strMacro;
			strValue += _TEXT("\" :");
			mw.WriteString(strValue);
			mw.EndLine();

			// finally, write mkdir line
			strValue = _TEXT("    if not exist \"");
			strValue += strMacro;

			CString strNull;
			strNull.LoadString(IDS_NULL);
			strValue += _TEXT("/$(");
			strValue += strNull;
			strValue += _TEXT(")\" mkdir \"");
			strValue += strMacro;
			strValue += _TEXT("\"");

			mw.WriteString(strValue);

			mw.EndLine(); mw.InsureSpace();
		}

		if (pIntProp && !pIntProp->m_strVal.IsEmpty())
		{
			if (this == pProject ||
			    ((!pProjOutProp || pProjOutProp->m_strVal.CompareNoCase(pIntProp->m_strVal)) &&
				 (!pProjIntProp || pProjIntProp->m_strVal.CompareNoCase(pIntProp->m_strVal)))
			   )
			{
				if (!pOutProp || pOutProp->m_strVal.CompareNoCase(pIntProp->m_strVal))
				{
					// write '"$(INTDIR)" :'
					if ((GetOutDirString(strMacro, P_OutDirs_Intermediate)) && (!strMacro.IsEmpty()))
					{
						// write INTDIR inference rule
						// write dependency line for '"$(...)" :'
						CString strValue;

						strValue = _T('\"');
						strValue += strMacro;
						strValue += _TEXT("\" :");
						mw.WriteString(strValue);
						mw.EndLine();

						// finally, write mkdir line
						strValue = _TEXT("    if not exist \"");
						strValue += strMacro;

            			CString strNull;
			            strNull.LoadString(IDS_NULL);

            			strValue += _TEXT("/$(");
			            strValue += strNull;
            			strValue += _TEXT(")\" mkdir \"");

						strValue += strMacro;
						strValue += _TEXT("\"");

						mw.WriteString(strValue);

						mw.EndLine(); mw.InsureSpace();
					}
				}
			}
		}
	}
	CATCH (CException, e)
	{
		retVal = FALSE;	// failure
	}
	END_CATCH

	return retVal;
}
			
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::WriteMakeFileDependencies (CMakFileWriter& mw, CNameMunger& nm, BOOL /* bPerConfig */)
{
    // This is where you can write out per-config dep info, e.g.
    // take a look at CFileItem's override.
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::WritePerItemProperties (CMakFileWriter& mw)
{
	ASSERT(!mw.IsMakefile());

	CString strOutput, strBase;
	TCHAR buf [18];
	
	TRY
	{
		for (int i = 0; nMakeFileProps[i].idProp != P_END_MAP; i++)
		{
			// is this a valid prop. for the current item?
			if ((!(nMakeFileProps[i].nRdWrt & PropWrite)) // read-only?
			|| (!(nMakeFileProps[i].nRdWrt & Project) && IsKindOf(RUNTIME_CLASS(CProject))) ||
				(!(nMakeFileProps[i].nRdWrt & Group) && IsKindOf(RUNTIME_CLASS(CProjGroup))) ||
				(!(nMakeFileProps[i].nRdWrt & File) && IsKindOf(RUNTIME_CLASS(CFileItem)))   ||
				(!(nMakeFileProps[i].nRdWrt & TargetRef) && IsKindOf(RUNTIME_CLASS(CProjectDependency))) ||
				(!(nMakeFileProps[i].nRdWrt & Target) && IsKindOf(RUNTIME_CLASS(CTargetItem)))
			   )
				continue;
			
			// Only check props that are not per config
			if (!(nMakeFileProps[i].nRdWrt & NotPerConfig))
				continue;

			// construct our 'PROP <name> <value>' line
			strOutput = pcPropertyPrefix + (CString)nMakeFileProps[i].pPropName + _T(' ');

			UINT idProp = nMakeFileProps[i].idProp;

			switch (nMakeFileProps[i].type)
			{
				case string:
				{
					CString strVal;
					if (GetStrProp(idProp, strVal) != valid)
					{
						// ignore (empty string) if not valid
						continue;
					}
					strOutput += _T('\"') + strVal + _T('\"');
					break;
				}

				case integer:
				case booln:
				{
					int nVal = 0;
					if (GetIntProp(idProp, nVal) != valid)
					{
						// ignore (default 0) if not valid)
						continue;
					}
					// no need to write these if defaults
					if (nVal==0  && (idProp==P_ItemExcludedFromBuild || idProp==P_ItemExcludedFromScan || idProp==P_ItemIgnoreDefaultTool
#ifdef VB_MAKEFILES
							|| idProp==P_Proj_IsVB
#endif
					))
						continue;

					_itoa (nVal, &buf[0], 10);
					strOutput += buf;
					break;
				}

				default:
					ASSERT (FALSE); // Other types not supported.
					continue;
			}

			// write out this as a comment, throw exception if we can't
			mw.WriteComment(strOutput);
		}
	}
	CATCH (CException, e)
	{
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::WriteMakeFileProperties (CMakFileWriter& mw)
{
	ASSERT(!mw.IsMakefile());

	CString strOutput, strBase;
	TCHAR buf [18];
	
	TRY
	{
		// FUTURE (karlsi): really only need to write Int/Target dirs for base props
		BOOL fWriteBase = TRUE;	// first write out base props
		while (TRUE)
		{
			// our prefix
			strBase = (fWriteBase) ? pcBASE : _T("");
			
			ASSERT(GetActiveConfig());
			if (GetActiveConfig()->GetPropBag(fWriteBase ? BaseBag : CurrBag)->GetPropCount () != 0)
			{
				for (int i = 0; nMakeFileProps[i].idProp != P_END_MAP; i++)
				{
					// We don't write out non per config props here
					if (nMakeFileProps[i].nRdWrt & NotPerConfig)
						continue;
					
					UINT idProp = nMakeFileProps[i].idProp;
					// do we have a property in our bag?
					CProp * pProp = GetActiveConfig()->GetPropBag(fWriteBase ? BaseBag : CurrBag)
													 ->FindProp(idProp);
									   
					if (pProp == (CProp *)NULL)
						continue;	// no, try to get the next one

					// construct our 'PROP <name> <value>' line
					strOutput = pcPropertyPrefix + strBase + nMakeFileProps[i].pPropName + _T(' ');

					switch (pProp->m_nType)
					{
						case string:
						{
							strOutput += _T('\"') + ((CStringProp *)pProp)->m_strVal + _T('\"');
							break;
						}

						case integer:
						case booln:
						{
							int nVal = pProp->m_nType == integer ?
										((CIntProp *)pProp)->m_nVal : ((CBoolProp *)pProp)->m_bVal;

							// no need to write these if defaults
							if (nVal==0  && (idProp==P_ItemExcludedFromBuild || idProp==P_ItemExcludedFromScan || idProp==P_ItemIgnoreDefaultTool
#ifdef VB_MAKEFILES
							|| idProp==P_Proj_IsVB
#endif
							))
								continue;

							// adjust the value?
							if (idProp == P_ProjUseMFC)
							{
								// do we have a use of MFC by AppWiz (LSB3 set)?
								CProp * pProp = GetActiveConfig()->GetPropBag(fWriteBase ? BaseBag : CurrBag)
										->FindProp(P_ProjAppWizUseMFC);
								if( pProp == NULL )
									break;

								ASSERT(pProp->m_nType == integer);
								if (((CIntProp *)pProp)->m_nVal != 0)
									nVal = nVal | 0x4;	// AppWiz gen'ed use of MFC
							}

							_itoa (nVal, &buf[0], 10);
							strOutput += buf;
							break;
						}

						default:
							ASSERT (FALSE); // Other types not supported.
							continue;
					}

					// write out this as a comment, throw exception if we can't
					mw.WriteComment(strOutput);
				}
			}
 			
			// do we want to write out current?
			if (!fWriteBase)	break;	// write current props next
			fWriteBase = FALSE;
		}
	}
	CATCH (CException, e)
	{
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
// FUTURE (karlsi): move into class CProp::operator==
BOOL CompareProps(const CProp * pProp1, const CProp * pProp2)
{
	if ((pProp1==NULL) || (pProp2==NULL))
		return (pProp1==pProp2);

	ASSERT(pProp1->m_nType==pProp2->m_nType);

	switch (pProp1->m_nType)
	{
		case integer:
			return (((CIntProp *)pProp1)->m_nVal==((CIntProp *)pProp2)->m_nVal);
		case booln:
			return (((CBoolProp *)pProp1)->m_bVal==((CBoolProp *)pProp2)->m_bVal);
		case string:
			return (((CStringProp *)pProp1)->m_strVal==((CStringProp *)pProp2)->m_strVal);
		default:
			ASSERT(0);	// other types not implemented
	};

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::HasMakefileProperties () const
{
	int i, j;
	ConfigurationRecord *pcr;
	int size = GetPropBagCount();

	// only look at the meaningful (writable) props
#ifdef _DEBUG
	// Currently, there are 5 R/O props, plus add 1 for the terminating NULL
	int nProps = (sizeof(nMakeFileProps) / sizeof(nMakeFileProps[0])) - (nReadOnlyProps+1);

	// Currently, there are 18 Props that we actually need to write here
	ASSERT(nProps==nWriteableProps);
#endif
	CProp * CmpProps[nWriteableProps]; // bump this value if nProps changes
	CProp * pProp;

	BOOL fCompareBase = FALSE;	// first compare current props
	while (TRUE)
	{
		for (j=0; j < size; j++)
		{
			pcr = (ConfigurationRecord*)m_ConfigArray[j];
			// if (pcr->GetPropBag(fCompareBase ? BaseBag : CurrBag)->GetPropCount () != 0)
			{
				for (i=0; i < nWriteableProps; i++)
				{
					ASSERT(nMakeFileProps[i].idProp != P_END_MAP);

					// is this a valid prop. for the current item?
					if ((!(nMakeFileProps[i].nRdWrt & Project) && IsKindOf(RUNTIME_CLASS(CProject))) ||
						(!(nMakeFileProps[i].nRdWrt & Group) && IsKindOf(RUNTIME_CLASS(CProjGroup))) ||
						(!(nMakeFileProps[i].nRdWrt & File) && IsKindOf(RUNTIME_CLASS(CFileItem)))   ||
						(!(nMakeFileProps[i].nRdWrt & TargetRef) && IsKindOf(RUNTIME_CLASS(CProjectDependency))) ||
						(!(nMakeFileProps[i].nRdWrt & Target) && IsKindOf(RUNTIME_CLASS(CTargetItem)))
					   )
						continue;

					pProp = (pcr->GetPropBag(fCompareBase ? BaseBag : CurrBag)->FindProp(nMakeFileProps[i].idProp));
					if (j==0)
					{
						// save props from first config for later comparison
						CmpProps[i] = pProp;
					}
					else
					{
						// check for props that differ between configs
						if (!CompareProps(pProp, CmpProps[i]))
						{
							return TRUE;
						}
					}
				}
			}
			
		}
		// repeat test for base props?
		if (fCompareBase)	break;
		fCompareBase = TRUE;	// compare base props next
	}
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::IsPropComment (CObject *&pObject)
{
	// Pls. note that this will digest props regardless of whether or not they are
	// in the prop bag or not....
	if (!pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
		return FALSE; 

	BOOL retval = FALSE; // assume failure

	CMakComment * pMakComment = (CMakComment *)pObject;

	// get the comment and skip leading whitespace
	TCHAR * pc = pMakComment->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// look for the 'Begin Custom Build' prefix
	if (_tcsnicmp(g_pcBeginCustomBuild, pc, _tcslen(g_pcBeginCustomBuild)) == 0)
	{
		CProject * pProject = GetProject();
		if (pProject->m_bConvertedDS5x || pProject->m_bConvertedDS4x)
		{
			CString strExt = GetFilePath()->GetExtension();
			if (strExt.CompareNoCase(_T(".idl"))==0) // REVIEW
			{
				SetIntProp(P_ItemIgnoreDefaultTool, TRUE);
			}
		}

		// read in the custom build rule
		BOOL fRet = CCustomBuildTool::DoReadBuildRule(this, pc);

		delete pObject; pObject = (CObject *)NULL;
		return fRet;
	}

	// look for the 'Begin Special Build Tool' prefix
	if (_tcsnicmp(g_pcBeginSpecialBuildTool, pc, _tcslen(g_pcBeginSpecialBuildTool)) == 0)
	{
		// read in the custom build rule
		BOOL fRet = CSpecialBuildTool::DoReadBuildRule(this, pc,(m_cp == EndOfConfigs));

		delete pObject; pObject = (CObject *)NULL;
		return fRet;
	}

	// look for the 'PROP' prefix
	if (_tcsnicmp(pcPropertyPrefix, pc, 4) != 0)
		return FALSE;

	int i, j, k, nConfigs;
	CString str;
	TCHAR *pcEnd;

	// Get the property name and look for it in the nMakeFileProps array:
	pc += 4;
	SkipWhite (pc);

	// check if BASE property
	BOOL fUseBase = _tcsnicmp(pcBASE, pc, 5) == 0; 
	if (fUseBase)
	{
		// skip over the "BASE" keyword
		pc += 5; SkipWhite(pc);
	}

 	// set the prop. bag usage
	int idOldBag = UsePropertyBag(fUseBase ? BaseBag : CurrBag);

	BOOL bBlankProp = FALSE;
	GetMakToken(pc, pcEnd);
 	bBlankProp = (*pcEnd == _T('\0'));
	*pcEnd = _T('\0');

	for (i=0; nMakeFileProps[i].idProp != P_END_MAP; i++)
	{
		if (!(nMakeFileProps[i].nRdWrt & PropRead)) continue;
		if ( _tcsicmp (nMakeFileProps[i].pPropName, pc) ==0 ) break;
	}
	if (nMakeFileProps[i].idProp != P_END_MAP )
	{
 		if (bBlankProp)
			pc = pcEnd;
		else
			pc = ++pcEnd;
        
        // Get the end of the prop line
        while (*pcEnd)
            pcEnd = _tcsinc(pcEnd);        

		if (m_cp == EndOfConfigs)
		{
			// global across *all configs* so
			// make sure we have all of our configs matching the project
			CreateAllConfigRecords();

			nConfigs = GetPropBagCount();
		}

		switch (nMakeFileProps[i].type)
		{
			case string:
			{
                // We strip quotes around the property, this is only
                // for compatability with previous makefiles, and should
                // not really be needed here.
                // FUTURE (colint): Delete this when we have a v2 bld convtr
                // that does this, and when most internal v3 makefiles have
                // been saved out to not have surrounding quotes!
                if (*pc == _T('"'))
                {
                    pc++;
                    if (*_tcsdec(pc, pcEnd) == _T('"'))
                        *(--pcEnd) = _T('\0');
                    else
                        ASSERT(FALSE);  // unmatched quotes
                }

				// copy the string arg. between quotes into buffer
				str = pc;

				// may need to re-relativize paths if converted project
				if (GetProject()->m_bConvertedDS4x)
				{
					int id = nMakeFileProps[i].idProp;
					if ((id == P_OutDirs_Target) || (id == P_OutDirs_Intermediate) || (id == P_Proj_TargDir))
					{
						// Use special workspace dir (not actual wkspcdir)
						if ((!str.IsEmpty()) && (str[0] != _T('\\')) && (str[0] != _T('/')) && ((str.GetLength() < 2) || (str[1] != _T(':'))))
						{
							// REVIEW: should really add a temp filename here
							ASSERT(g_pConvertedProject);
							ASSERT(*(LPCTSTR)g_pConvertedProject->GetWorkspaceDir());
							CPath pathDir;
							pathDir.SetAlwaysRelative();
							if (pathDir.CreateFromDirAndFilename(g_pConvertedProject->GetWorkspaceDir(), str))
							{
								if (_tcsicmp((LPCTSTR)pathDir, (LPCTSTR)GetProject()->GetWorkspaceDir())==0)
									str = ".";
								else
									pathDir.GetRelativeName(GetProject()->GetWorkspaceDir(), str);
							}
						}
					}
				}
				if ((m_cp == EndOfConfigs) && !(nMakeFileProps[i].nRdWrt & NotPerConfig))
				{
					for (k=0; k < nConfigs; k++)
					{
						// Force config. active, set prop, and then restore.
						ForceConfigActive((ConfigurationRecord *)m_ConfigArray[k]);
						VERIFY (SetStrProp(nMakeFileProps[i].idProp, str));
						ForceConfigActive();
					}
				}
				else
				{
					ASSERT((m_cp == EndOfConfigs) || !(nMakeFileProps[i].nRdWrt & NotPerConfig));
					CProject * pProject = GetProject();
					SetStrProp ( nMakeFileProps[i].idProp, str );
				}
				str.Empty ();
				break;
			}

			case integer:
			case booln:
			{
				BOOL b;
				j = atoi (pc);

				// using MFC property?
   				if (nMakeFileProps[i].idProp == P_ProjUseMFC)
				{
					// adjust...
					// do we have a use of MFC by AppWiz (LSB3 set)
					b = j & 0x4; j &= 0x3;
				}
										    
				if ((m_cp == EndOfConfigs) && !(nMakeFileProps[i].nRdWrt & NotPerConfig))
				{
					for (k=0; k < nConfigs; k++)
					{
						// Force config. active, set prop, and then restore.
						ForceConfigActive((ConfigurationRecord *)m_ConfigArray[k]);

						SetIntProp(nMakeFileProps[i].idProp, j);

						if (nMakeFileProps[i].idProp == P_ProjUseMFC)
							SetIntProp(P_ProjAppWizUseMFC, b);

						ForceConfigActive();
					}
				}
				else
				{
					ASSERT((m_cp == EndOfConfigs) || !(nMakeFileProps[i].nRdWrt & NotPerConfig));
					SetIntProp(nMakeFileProps[i].idProp, j);

					if (nMakeFileProps[i].idProp == P_ProjUseMFC)
						SetIntProp(P_ProjAppWizUseMFC, b);
				}
			 	break;
			}

			default:
				ASSERT (FALSE); // Other types not supported.
				break;

		}
	}

	// we'll just ignore those props that we don't recognise
	// rather than flag the .MAK as unreadable	
	retval = TRUE; // indicate success

   	// reset the prop. bag usage
 	UsePropertyBag(idOldBag);

	delete pObject; pObject = (CObject *)NULL;

	return retval;
}
///////////////////////////////////////////////////////////////////////////////
void CountkidsRecursively (CProjItem *pItem, int &rCount)
{
	CProjItem *pSubItem;
	rCount++;

	if (pItem->GetContentList ()== NULL
		||
		pItem->IsKindOf (RUNTIME_CLASS (CProject))
		) return;

	for (POSITION pos = pItem->GetHeadPosition (); pos != NULL; )
	{
		pSubItem = (CProjItem *) pItem->GetNext (pos);
		if (pSubItem->IsKindOf (RUNTIME_CLASS (CFileItem ))
			||
			pSubItem->IsKindOf (RUNTIME_CLASS (CProjGroup ))
			||
			pSubItem->IsKindOf (RUNTIME_CLASS (CProject))
			||
			pSubItem->IsKindOf (RUNTIME_CLASS (CTargetItem ))
			) 
		{
			CountkidsRecursively (pSubItem, rCount );
		}
	}
}
int	CProjItem::CountInterestingChildren ()
{
	int nCount = 1;
	if (GetContentList ())
	{
		for (POSITION pos = GetHeadPosition (); pos != NULL; )
		{
			CountkidsRecursively ( (CProjItem *) GetNext(pos), nCount );
		}
	}
	return nCount;
}
///////////////////////////////////////////////////////////////////////////////
int CompareConfigRecs ( const void *pv1, const void *pv2 )
{

	return (
		(*((ConfigurationRecord **) pv1))->GetConfigurationName ().Collate 
			(
			(const TCHAR *) (*((ConfigurationRecord **) pv2))->
														GetConfigurationName ()
			)
		);
}

///////////////////////////////////////////////////////////////////////////////
const TCHAR *CProjItem::GetNamePrefix (CProjItem *pItem)
{
	// FUTURE: nuke this

	CRuntimeClass *pRTC = pItem->GetRuntimeClass ();

	if (pRTC == RUNTIME_CLASS ( CFileItem )) 
										return _TEXT ("Source File" );
	else if (pRTC == RUNTIME_CLASS ( CProjGroup )) 	
										return _TEXT ("Group" );
	else if (pRTC == RUNTIME_CLASS ( CProject )) 	
										return _TEXT ("Project" );
	else if (pRTC == RUNTIME_CLASS ( CProjectDependency ))
										return _TEXT ("Project Dependency" );
	else if (pRTC == RUNTIME_CLASS ( CTargetItem ))
										return _TEXT ("Target" );	// Use BTarget so that first letter is
																	// unique!.

	TRACE ( "CProjItem::GetNamePrefix called for unknown class %s\n", 
												pRTC->m_lpszClassName );
	ASSERT (FALSE);
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////
BOOL  CProjItem::IsEndToken (CObject *& pToken )
{
	if (pToken->IsKindOf ( RUNTIME_CLASS (CMakEndOfFile)))
	{
		delete (pToken); pToken = NULL;
		AfxThrowFileException (CFileException::generic);
	}
	
	if (!pToken->IsKindOf ( RUNTIME_CLASS (CMakComment))) return FALSE;

	const TCHAR *pc = ((CMakComment *) pToken)->m_strText;
	SkipWhite (pc);
	if ( _tcsnicmp ( pc, EndToken, (sizeof(EndToken) -1) / sizeof(TCHAR)) == 0) 
	{
		delete (pToken); pToken = NULL;
		return TRUE;
	}
	return FALSE; 
}
///////////////////////////////////////////////////////////////////////////////
CRuntimeClass *CProjItem::GetRTCFromNamePrefix (const TCHAR *pcPrefix)
{
	// Skip over the "Begin":
	SkipWhite    (pcPrefix);
	SkipNonWhite (pcPrefix);
	SkipWhite    (pcPrefix);

	if ( *pcPrefix == '\0')
		return NULL;

 	// Get the runtime class by looking at the name.
 	if (_tcsnicmp(pcPrefix, _TEXT ("Source File"), 11) == 0)
		return RUNTIME_CLASS ( CFileItem );
	else if (_tcsnicmp(pcPrefix, _TEXT ("Group"), 5) == 0)
		return RUNTIME_CLASS ( CProjGroup );
	else if (_tcsnicmp(pcPrefix, _TEXT ("Project Dependency"), 18) == 0)
		return RUNTIME_CLASS ( CProjectDependency );
	else if (_tcsnicmp(pcPrefix, _TEXT ("Project"), 7) == 0)
		return RUNTIME_CLASS ( CProject );
	else if (_tcsnicmp(pcPrefix, _TEXT ("Target"), 6) == 0)
		return RUNTIME_CLASS ( CTargetItem );
 
 	TRACE ( "CProjItem::GetRTCFromNamePrefix got unknown prefix %s\n",
						pcPrefix );
	return NULL;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SuckDescBlk(CMakDescBlk *pDescBlk)
{
	BOOL retVal = TRUE;
	BOOL bOldInherit;
	CString str = pDescBlk->m_strTool;

	// get a project type
	CProjType * pprojtype = GetProjType();
	int len = str.GetLength();

	// ignore blk if pseudo-rule for OUTDIR/INTDIR/INTDIR_SRC
	if ((len >= 6) && (!str.Mid(2,4).Compare(_T("TDIR"))))
		return TRUE;

	// FUTURE: <ignatius 4/21/94>
	// Condition comes from ReadMasterDepsLine() in project.cpp
	// We probably should combine both functions together, instead of doing
	// a check for _T("ALL") in both here and ReadMasterDepsLine().
	// 
	if ( ( (_tcsicmp(_T("ALL"), pDescBlk->m_strTargets) == 0) ||
		   (_tcsicmp(_T("CLEAN"), pDescBlk->m_strTargets) == 0) )  && 
		 pprojtype->IsSupported()
	   )
		return TRUE;

	if ((len == 0) && (len = pDescBlk->m_strTargets.Find(_T('_'))) > 0)
	{
		// FUTURE: consider handling this in ParseDescBlk instead
		// also look for a "Fake" target of the form TOOLPREFIX_xxx
		str = pDescBlk->m_strTargets.Left(len);
		ASSERT(len==str.GetLength());
	}

	int i = 0, nMax = m_cp == EndOfConfigs ? GetPropBagCount() : 1;

	// bounds for iteration
	// iterate through all configs if m_cp == EndOfConfigs
	if (m_cp == EndOfConfigs)
	{ 
		// global across *all configs* so
		// make sure we have all of our configs matching the project
		CreateAllConfigRecords();
	
	 	(void) ForceConfigActive((ConfigurationRecord *)m_ConfigArray[0]);
	}

	// nothing to do unless unsupported projtype-specific block
	TRY
	{
		for (;;) // iterate through configs if necessary based on m_cp
		{
			// get a tool for the prefix?
			CBuildTool * pTool = len > 0 ? pprojtype->GetToolFromCodePrefix(str, len) : (CBuildTool *)NULL;

 			// get the action list
			ASSERT(GetActiveConfig());
			CActionSlobList * pActions = GetActiveConfig()->GetActionList();

			// currently got a tool?
			// FUTURE: support multiple actions per-item
			CBuildTool * pCurrentTool = (CBuildTool *)NULL;
			if (!pActions->IsEmpty() && !IsKindOf(RUNTIME_CLASS(CProject)))
				pCurrentTool = ((CActionSlob *)pActions->GetHead())->BuildTool();

			// preserve this tool-specific block
			// o if not an external target, external targets have their own build rules that we can safely ignore.
			// and,
			// o we recognise the block as for an unknown tool, or
			// o we don't have a tool already for the block
			if (!pprojtype->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)) &&
				(!pTool || pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)))
			   )
			{
				// if don't already have a tool, then use the current one
				// else create it
				if (!pCurrentTool)
				{
					if (!pTool)
					{
						// try to get an unknown tool
						const TCHAR * pchPrefix = len > 0 ? (const TCHAR *)str : _TEXT("UNK");
						pTool = pprojtype->GetToolFromCodePrefix(pchPrefix, 3);
						
						if( (_tcsicmp(pchPrefix,"BuildCmds") == 0) && (pTool == NULL) ){
							pTool = g_pBuildTool;
						} 
						
						if (pTool == (CBuildTool *)NULL)
						{
							// no, unknown one, create new projtype-specific 'unknown' tool
							pTool = new CUnknownTool(*pprojtype->GetPlatformName(), pchPrefix);
							pprojtype->AddTool(pTool);
						}
					}

					// add an action if we don't already have one for this tool...
					if (!pActions->Find(pTool))
					{
						// explicitly add an action for this tool
						CActionSlob * pAction;
						pAction = new CActionSlob(this, pTool, FALSE, GetActiveConfig());
						pActions->AddTail(pAction);
					}
				}
				else
				{
					// use the current tool
					pTool = pCurrentTool;
				}

				// read in the raw-data for this descriptor block

				if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)) && ( _tcsicmp(_T("ALL"), pDescBlk->m_strTargets) != 0))
				{
					str.Empty();
					bOldInherit = EnablePropInherit(FALSE);
					if (GetStrProp(((CUnknownTool *)pTool)->GetUnknownPropId(), str)!=valid)
						str.Empty();

					// make sure a blank line precedes the build rule
					int len1 = str.GetLength();
					ASSERT(len1==0 || len1 >= 4);
					if ((len1==0) || ((len1 >= 4) && (_tcscmp((LPCTSTR(str) + len1 - 4), _T("\r\n\r\n"))!=0)))
						str += _T("\r\n");

					str += pDescBlk->m_strRawData;
					SetStrProp(((CUnknownTool *)pTool)->GetUnknownPropId(), str);
					EnablePropInherit(bOldInherit);
				}
			}

			// repeat for next config, if necessary
			if (++i >= nMax) break;

			ForceConfigActive();
			ForceConfigActive((ConfigurationRecord *)m_ConfigArray[i]);
		}
	}
	CATCH (CException, e)
	{
		retVal = FALSE;	// failure
	}
	END_CATCH

	ForceConfigActive();
	return retVal;
}

///////////////////////////////////////////////////////////////////////////////
// Helper for CProjItem::SuckDependency
FileRegHandle CProjItem::SuckDependency(TCHAR *pchDep, CBuildTool * pTool, const CDir &BaseDir, BOOL & fDepIsPerConfig, BOOL bCaseApproved /*=FALSE*/)
{	
	ASSERT(pTool);
	ASSERT(g_pMakReadDepCache != NULL);
	ASSERT(g_pMakReadIncludeDepCache != NULL);


	CString str;  
	FileRegHandle frh = (FileRegHandle)NULL;

	BOOL bForceRelativePath = ((pchDep[0] == _T('.')) && (pchDep[1] == _T('.')));
	fDepIsPerConfig = FALSE;

	BOOL fIncludeDep = FALSE;

	BOOL fUseIncludeDepCache = FALSE;

	CDirMgr *pDirMgr = GetDirMgr();
	int nToolSet = -1;
	int cToolSet = pDirMgr->GetNumberOfToolsets();

	// substitute for $(OUTDIR) macro if nessessary
	if (*pchDep == _T('$'))
	{
		str = pchDep;
		if (GetProject()->SubstOutDirMacro(str, (ConfigurationRecord *)GetProject()->GetActiveConfig()))
		{
			pchDep = (TCHAR *)(const TCHAR *)str;
			fDepIsPerConfig = TRUE;
		}
	}
	else if (_tcsnicmp(_T("{$(INCLUDE)}"), pchDep, 12)==0)
	{
		fIncludeDep = TRUE;

		// HACK: we only use the cache for the compiler tool at these points.
		// The other tools could have their own tool specific include paths   
		//  and we don't want to keep a cache for #Tools * #Toolsets since 
		// the other tools will typically have only a few deps in the makefile.
		fUseIncludeDepCache = pTool->IsKindOf(RUNTIME_CLASS(CCCompilerTool));

		// if we are from include path, we should start with the macro {$(INCLUDE)}
		// Figure out the name without the $(INCLUDE) part.
		
		// skip backslash and terminate at '"' if there is one
		int cchBase = _tcslen(pchDep);
		if (cchBase < 14)	// bad syntax
			return (FileRegHandle)NULL;

		pchDep += 14;
        cchBase -= 14;
		if (*_tcsdec(pchDep, pchDep + cchBase) == _T('"'))
			*(pchDep + cchBase) = _T('\0');	// terminate

		CProjType *	pprojtype = GetProjType();
		CString strPlatNameTmp = *pprojtype->GetPlatformName();
		nToolSet = strPlatNameTmp.IsEmpty() ? (int)-1 : pDirMgr->GetPlatformToolset(strPlatNameTmp);

		int nToolSetOld = pDirMgr->GetCurrentToolset();
		
		pDirMgr->SetCurrentToolset(nToolSet);
		
		// If nToolSet is -1, which means we are using the current default.
		// To use the cache however we need to determine exactly what the default is.
		// We get that information by calling GetCurrentToolset.
		nToolSet = pDirMgr->GetCurrentToolset();

		if ( nToolSet < 0 || nToolSet >= cToolSet)
			fUseIncludeDepCache = FALSE;

		pDirMgr->SetCurrentToolset(nToolSetOld);

	}

	// see if this string is already in our "dep cache" (which
	// was cleared when we started to read the makefile).  If
	// so, we don't need to create a CPath object and can instead
	// just increment the ref count on the FileRegHandle.
	// There are two cases here.
	// a) We have a workspace relative or an absolute path in which case we can directly 
	//    look in the global cache.
	// b) If the dep had a $(INCLUDE) this could change for every toolset, so we 
	//    look in the toolset specific cache for that.

	void * pv;
	if (!fIncludeDep && g_pMakReadDepCache->Lookup(pchDep, pv))
	{
		frh = (FileRegHandle)pv;
#ifndef REFCOUNT_WORK
		g_FileRegistry.AddRegRef(frh);
#else
		frh->AddFRHRef();
#endif
	}
	else if (fUseIncludeDepCache && g_pMakReadIncludeDepCache[nToolSet].Lookup(pchDep, pv))
	{
		frh = (FileRegHandle)pv;
#ifndef REFCOUNT_WORK
		g_FileRegistry.AddRegRef(frh);
#else
		frh->AddFRHRef();
#endif
	}
	else
	{
		// our dependency file
		CPath cpFile;

		if ( fIncludeDep )
		{
			CString strIncludePath;
			TCHAR buf [MAX_PATH];

			int nToolSetOld = pDirMgr->GetCurrentToolset();

			pDirMgr->SetCurrentToolset(nToolSet);
			// get our include paths for this tool.
			pTool->GetIncludePaths(this, strIncludePath);
			pDirMgr->SetCurrentToolset(nToolSetOld);


			CString strOptionPath;
			int iFound;
			// this is a helper function in scanner.c which replace SearchPath
			if ((iFound=GetFileFullPath((TCHAR *)(LPCTSTR)strIncludePath, pchDep, buf, strOptionPath))!=NOTFOUND)
			{
				if (cpFile.Create(buf))
				{
#ifndef REFCOUNT_WORK
					frh = g_FileRegistry.RegisterFile (&cpFile, TRUE);
#else
					frh = CFileRegFile::GetFileHandle(cpFile);
#endif
				
					if ((iFound == ONPATH) && (frh != NULL))
					{
						g_FileRegistry.GetRegEntry(frh)->SetFileFoundInIncPath();

						if (_tcsstr(pchDep, _TEXT("..\\")))
						{
							g_FileRegistry.GetRegEntry(frh)->SetOrgName(pchDep);
						}
						else
						{
							g_FileRegistry.GetRegEntry(frh)->SetIndexNameRelative(_tcslen(pchDep));
						}
					}
				}
			}
			else
			{
				// well, we can't find this file from the path
				// do we warn user? in any case just register the file with the raw name
				if (cpFile.CreateFromDirAndRelative(BaseDir, pchDep))
#ifndef REFCOUNT_WORK
					frh = g_FileRegistry.RegisterFile(&cpFile, TRUE);
#else
					frh = CFileRegFile::GetFileHandle(cpFile);
#endif
			}
			
			if ( fUseIncludeDepCache && (frh != NULL))
			{
				// Add the FileRegHandle to the per toolset include "dep cache".
#ifndef REFCOUNT_WORK
				g_pMakReadIncludeDepCache[nToolSet].SetAt(pchDep, (void *)frh);
#else
				if (!g_pMakReadIncludeDepCache[nToolSet].Lookup(pchDep, pv))
				{
					g_pMakReadIncludeDepCache[nToolSet].SetAt(pchDep, (void *)frh);
					frh->AddFRHRef();
				}
#endif
			}
		}
		else 
		{
			if (cpFile.CreateFromDirAndRelative(BaseDir, pchDep))
#ifndef REFCOUNT_WORK
				frh = g_FileRegistry.RegisterFile(&cpFile, !bCaseApproved);
#else
				frh = CFileRegFile::GetFileHandle(cpFile);
#endif

			if (frh != NULL)
			{
				// if bCaseApproved then we read this CFileItem in from makefile
				// and will therefore assume correct case is already set...
				if (bCaseApproved)
					frh->SetMatchCase(TRUE, TRUE);

				if (_tcsstr(pchDep, _TEXT("..\\")))
				{
					g_FileRegistry.GetRegEntry(frh)->SetOrgName(pchDep);
					g_FileRegistry.GetRegEntry(frh)->SetFileNameRelativeToProj();
				}

				// Add the FileRegHandle to the global "dep cache".
	#ifndef REFCOUNT_WORK
				g_pMakReadDepCache->SetAt(pchDep, (void *)frh);
	#else
				if (!g_pMakReadDepCache->Lookup(pchDep, pv))
				{
					g_pMakReadDepCache->SetAt(pchDep, (void *)frh);
					frh->AddFRHRef();
				}
	#endif
			}
		}
	}

	if (bForceRelativePath && frh)
		g_FileRegistry.GetRegEntry(frh)->SetRelative(TRUE);

	return frh;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SuckMacro(CMakMacro * pMacro, const CDir & BaseDir, BOOL bCaseApproved /*=FALSE*/)
{
//	Examine a macro and figure out what its for.  Either its the dependencies
//	macro (in which case it starts with DEP) or it belongs to some tool, in 
//  which case we can get the tool from the macro's prefix:
//  for a tool

	const TCHAR * pMacName = pMacro->m_strName;

	// ignore OUTDIR and INTDIR macros
	if ((_tcsnicmp(_TEXT("OUTDIR"), pMacName, 6) == 0) ||
	    (_tcsnicmp(_TEXT("INTDIR"), pMacName, 6) == 0)
	   )
	{
		return TRUE;	// ok
	}

	BOOL retVal = TRUE;
	FileRegHandle frh;

	BOOL fPerConfig = m_cp != EndOfConfigs;

	TRY
	{	
		// dependency macro?
		if (_tcsnicmp(_TEXT("DEP_"), pMacName, 4) == 0 || // scanned dependency
			_tcsnicmp(_TEXT("NODEP_"), pMacName, 6) == 0 || // missing dependency
			_tcsnicmp(_TEXT("USERDEP_"), pMacName, 8) == 0) // user-defined dependency
		{
			// scanned or missing dependency?
			UINT depType;
			if (*pMacName == _T('N'))
			{
				depType = DEP_Missing;
				pMacName += (6 * sizeof(TCHAR));
			}
			else if (*pMacName == _T('U'))
			{
				depType = DEP_UserDefined;
				pMacName += (8 * sizeof(TCHAR));
			}
			else
			{
				depType = DEP_Scanned;
				pMacName += (4 * sizeof(TCHAR));
			}

			// if we haven't got any actions then this must be for an unknown tool
			ASSERT(GetActiveConfig());
			CActionSlobList * pActions = GetActiveConfig()->GetActionList();
			if (pActions->IsEmpty())
			{
				CBuildTool * pTool;

				// search for tool prefix
				TCHAR * pUnderScore = _tcschr(pMacName, _T('_'));
				int index = pUnderScore != (TCHAR *)NULL ? pUnderScore - pMacName : -1;

				// found the tool prefix?
				CProjType *	pprojtype = GetProjType();

				TCHAR * pchPrefix;
				if (index == -1)
				{
					// we'll have to default to 'UNK' (unknown)
					pchPrefix = _TEXT("UNK");
					index = 3;
				}
				else
				{
					// we'll get the tool for the tool-prefix
					pchPrefix = (TCHAR *)pMacName;
				}

				// no tool?
				pTool = pprojtype->GetToolFromCodePrefix(pchPrefix, 3);
				/*
				if( (_tcsicmp(pchPrefix,"BuildCmds") == 0) && (pTool == NULL) ){
					pTool = g_pBuildTool;
				} 
				*/
				
				if (pTool == (CBuildTool *)NULL)
				{
					// create new projtype-specific 'unknown' tool
					pTool = new CUnknownTool(*pprojtype->GetPlatformName(), pchPrefix);
					pprojtype->AddTool(pTool);
					g_pLastTool = pTool;
				}

				// make sure we have this tool in our action-list if it's unknown
				if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)) &&
					!pActions->Find(pTool)
				   )
				{
					// explicitly add an action for this tool
					CActionSlob * pAction;
					ASSERT(GetActiveConfig());
					pAction = new CActionSlob(this, pTool, FALSE, GetActiveConfig());
					pActions->AddTail(pAction);
				}
			}

			ConfigurationRecord * pcrSrc = GetActiveConfig(), * pcrDest;

			// We're going to want this across all configs
			if (!fPerConfig)
				CreateAllConfigRecords();	// make sure we have all of the configs...

			// FUTURE: handle more than one tool on this source file
			ASSERT(pActions->GetCount() == 1);	  
			CActionSlob * pAction = (CActionSlob *)pActions->GetHead();

			// get the dependency list to create
			CFileRegSet * psetDep;
			if (depType == DEP_Scanned)
				psetDep = pAction->GetScannedDep();

			else if (depType == DEP_UserDefined)
			{
				// Do nothing.
			}

			else if (depType == DEP_Missing)
				psetDep = pAction->GetMissingDep();

			else
				ASSERT(FALSE);

			// Parse the dependants list to get our file name and dependents:

			// This is the accepted way to get a mungeable pointer a CString's
			// data.  Note we never call ReleaseBuffer:
			TCHAR * pBase = pMacro->m_strValue.GetBuffer (1);	

			// Squirrel away the length of the deps string, since we'll be 
			// writing all over it:
			const TCHAR * pDepEnd =  (const TCHAR *)pMacro->m_strValue + pMacro->m_strValue.GetLength();
	
			// possible token start and end
			TCHAR * pTokenEnd = max(pBase, (TCHAR *) pDepEnd-1);
			
			// generic buffer	
			CString str;

			for ( ; pTokenEnd < pDepEnd; pBase = _tcsinc (pTokenEnd) )
			{
				// skip whitespace
		  		SkipWhite (pBase);

				TCHAR * pTokenStart = pBase;

				// skip lead-quote?
				if (pBase[0] == _T('"'))
					pBase++;

				// get .mak token
				GetMakToken(pTokenStart, pTokenEnd);

				// back-up over end-quote?
				if (*(pTokenEnd - 1) == _T('"'))
					*(pTokenEnd - 1) = _T('\0');
				else
					*pTokenEnd = _T('\0'); 

				// get our dependency from this string
				BOOL fDepIsPerConfig = TRUE;	// we want the first one, so pretend per-config

				// per-configuration
				if (fPerConfig)
				{
					// Add user-defined dep to configuration record.
					if (DEP_UserDefined==depType)
					{
						CString strDeps;
						if (invalid == GetStrProp(P_UserDefinedDeps, strDeps) )
							strDeps.Empty();

						strDeps += _T("\"");
						strDeps += pBase;
						strDeps += _T("\"\t");
						VERIFY(SetStrProp(P_UserDefinedDeps, strDeps));
					}

					// add this per-config dep.
					if ((frh = SuckDependency(pBase, pAction->m_pTool, BaseDir, fDepIsPerConfig, FALSE)) == (FileRegHandle)NULL)
					{
						// just ignore bad deps
						continue;
					}

 					// olympus 778 (briancr)
					// a better fix to this bug is to still suck in the
					// dependencies, but then add them to the appropriate list
					if (depType == DEP_Scanned) {
						pAction->AddScannedDep(frh);
					}
					else if (depType == DEP_UserDefined) {
						pAction->AddSourceDep(frh);
					}
					else{
						pAction->AddMissingDep(frh);
					}
#ifdef REFCOUNT_WORK
					frh->ReleaseFRHRef();
#endif
				}
				else
				{
					int nSize = m_ConfigArray.GetSize();
					
#ifdef REFCOUNT_WORK
					frh = NULL;
#endif
					CProjTempConfigChange projTempConfigChange(GetProject());

					// add this dep. to all configs.
					for (int nConfig = 0; nConfig < nSize; nConfig++)
					{
						pcrDest = (ConfigurationRecord *)m_ConfigArray[nConfig];

						// Get dep list to copy to
						projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcrDest->m_pBaseRecord);

						// Should we do this?
						ASSERT(GetActiveConfig());
						if (!GetTarget()->GetActiveConfig()->IsValid())
							continue;

						CActionSlobList * pActions = GetActiveConfig()->GetActionList();
						if (!pActions->IsEmpty())
						{
							// FUTURE: handle more than one tool on this source file
							ASSERT(pActions->GetCount() == 1);	  
							CActionSlob * pAction = (CActionSlob *)pActions->GetHead();

 							// add this per-config dep.?
#ifdef REFCOUNT_WORK
							if (fDepIsPerConfig && NULL!=frh)
							{
								frh->ReleaseFRHRef();
								frh = NULL;
							}
#endif
							// Add user-defined dep to configuration record.
							if (DEP_UserDefined==depType)
							{
								CString strDeps;
								if (invalid == GetStrProp(P_UserDefinedDeps, strDeps) )
									strDeps.Empty();

								strDeps += _T("\"");
								strDeps += pBase;
								strDeps += _T("\"\t");
								VERIFY(SetStrProp(P_UserDefinedDeps, strDeps));
							}

							if (fDepIsPerConfig &&
								(frh = SuckDependency(pBase, pAction->m_pTool, BaseDir, fDepIsPerConfig, bCaseApproved && (DEP_UserDefined != depType))) == (FileRegHandle)NULL)
							{
								// just ignore bad deps
								continue;
							}

 							// olympus 778 (briancr)
							// a better fix to this bug is to still suck in the
							// dependencies, but then add them to the appropriate list
							
							if (frh != NULL)
							{
								if (depType == DEP_Scanned)
								{
									pAction->AddScannedDep(frh);
								}
								else if (depType == DEP_UserDefined)
								{
									pAction->AddSourceDep(frh);
								}
								else
								{
									pAction->AddMissingDep(frh);
								}
							}
						}
					}
#ifdef REFCOUNT_WORK
					if (NULL!=frh)
					{
						frh->ReleaseFRHRef();
						frh = NULL;
					}
#endif
				}
			}
		}
		// tool macro or some tool option macro?
		else
		{
			// probably a tool definition or tool macro, or some random macro
			CBuildTool * pTool = NULL;
			int index = pMacro->m_strName.Find(_T('_'));
			int i = 0, nMax = fPerConfig ? 1 : GetPropBagCount();

			// tool macro?
			if (index == -1 && IsKindOf(RUNTIME_CLASS(CProject)))
			{
				for (;;) // iterate through configs if necessary based on m_cp
				{
					if (!fPerConfig)
						ForceConfigActive((ConfigurationRecord *)m_ConfigArray[i]);

					// tool definition; extract tool name
					CProjType * pprojtype = GetProjType();
					/*
					if( _tcsicmp(pMacName,"BuildCmds") == 0 ){
						pTool = g_pBuildTool;
					} 
					else
					*/
					pTool = pprojtype->GetToolFromCodePrefix( pMacName, _tcslen(pMacName) );
					if ( pTool == NULL )
					{
						// create new projtype-specific 'unknown' tool
						pTool = new CUnknownTool(*pprojtype->GetPlatformName(),
										pMacro->m_strName, pMacro->m_strValue);

						pprojtype->AddTool(pTool);
						g_pLastTool = pTool;
					}

					// repeat for next config, if necessary
					if (++i >= nMax)
						break;
				}
			}
	 		else if (index != -1)
			{
				for (;;) // iterate through configs if necessary based on m_cp
				{
					if (!fPerConfig)
						ForceConfigActive((ConfigurationRecord *)m_ConfigArray[i]);

					if ((pTool = GetProjType()->GetToolFromCodePrefix(pMacName, index)) != NULL)
					{
						g_pLastTool = pTool;	// save most recently used tool
					}
					else
					{
						pTool = g_pLastTool;	// worst-case default
					}

					// found macro for some tool?
					if (pTool)
					{
						ASSERT(GetActiveConfig());
						CActionSlobList * pActions = GetActiveConfig()->GetActionList();

						// make sure we have this tool in our action-list if it's unknown
						if (pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)) &&
							!pActions->Find(pTool)
						   )
						{
							// explicitly add an action for this tool
							CActionSlob * pAction;
							pAction = new CActionSlob(this, pTool, FALSE, GetActiveConfig());
							pActions->AddTail(pAction);
						}

						if (!pTool->ReadToolMacro(pMacro, this))
							AfxThrowFileException(CFileException::generic);
					}

					// repeat for next config, if necessary
					if (++i >= nMax)
						break;
				}
			}
			else if( (_tcsicmp(pMacName,"BuildCmds") == 0) && (g_pBuildTool != NULL) 
					&& g_pBuildTool->IsKindOf(RUNTIME_CLASS(CUnknownTool)) ){
				// append the whole macro to the unknow prop in the last tool!
				g_pBuildTool->ReadToolMacro(pMacro,this);
			}
		}
	}
	CATCH (CException, e)
	{
		retVal = FALSE;	// failure
	}
	END_CATCH

	ForceConfigActive();

	return retVal;	// success?
}
///////////////////////////////////////////////////////////////////////////////

BOOL CProjItem::IsAddSubtractComment (CObject *&pObject)
{
	if ( !pObject->IsKindOf ( RUNTIME_CLASS (CMakComment))) return FALSE; 
	TCHAR *pc, *pcOld;
	CBuildTool *pbt;
	BOOL bRetval = FALSE, bSubtract;
	BOOL bBase = FALSE;
	int i, nRepCount = 1;

	pc = ((CMakComment *) pObject)->m_strText.GetBuffer (1);
	SkipWhite (pc);

	// Look for the ADD or SUBTRACT prefix:
	if (  _tcsnicmp(pcADD, pc, 4) == 0 ) 
	{
		bSubtract = FALSE;
		pc += 4;
	}
	else if	(  _tcsnicmp(pcSUBTRACT, pc, 9) == 0 ) 
	{
		bSubtract = TRUE;
		pc += 9;
	}
	else return FALSE;

	SkipWhite (pc);

	// Check for BASE flag
	if (!_tcsnicmp(pcBASE, pc, 5))
	{
		bBase = TRUE;
		pc += 5;	// skip past base flag
		SkipWhite (pc);
	}
	
	// global across *all configs* so
	// make sure we have all of our configs matching the project
	CreateAllConfigRecords();

	if (m_cp == EndOfConfigs)
	{
		// FUTURE (karlsi): this is not very efficient, since we have to
		// reparse the same line n times.  Ideally, we could
		// defer this to when we set the properties, except
		// different configs might have different tools, and it
		// might get tricky. Reevaluate for V5.

		nRepCount = GetPropBagCount();
		pcOld = pc;	// save char pointer for each iteration
	}

	for (i = 0; i < nRepCount; i++)
	{
		if (m_cp == EndOfConfigs)
		{
			pc = pcOld;	// restore pointer to tool code-prefix

			// force config active
			ForceConfigActive((ConfigurationRecord *)m_ConfigArray[i]);
		}

		// Ask the current project type which one of its tools
		// matches the tool code-prefix.
		CProjType * pprojtype = GetProjType(); 
		g_pBuildTool = pbt = pprojtype->GetToolFromCodePrefix(pc, _tcslen (pc));
		

		if (pbt != NULL)
		{
			// Skip to start of flags to end of string
			while (*pc != _T('\0') && !_istspace(*pc))
				pc = _tcsinc(pc);	// next MBC character
	
			bRetval = pbt->ProcessAddSubtractString(this, pc, bSubtract, bBase);

			// FUTURE (karlsi): Do we want to allow/ignore failures
			//         when m_cp == EndOfConfigs?
			if (!bRetval)
			{
				// reset config.?
				if (m_cp == EndOfConfigs)
					ForceConfigActive();

				break; // quit if fails for any Config
			}
		}

		// reset config.?
		if (m_cp == EndOfConfigs)
			ForceConfigActive();
	}

	delete pObject;	pObject = NULL;

	// Something went wrong, but this token was for us:
	if (!bRetval)
	{
		ASSERT(GetProject());
		if (GetProject() && (!GetProject()->m_bProjConverted))
			AfxThrowFileException (CFileException::generic);
	}
	return TRUE;	

}
///////////////////////////////////////////////////////////////////////////////
void CProjItem::WriteConfigurationIfDef ( 
						CMakFileWriter& mw,
						const ConfigurationRecord *pcr
						)	 // (throw CFileException)
{

	CString str;
	char *pc;
	
	mw.InsureSpace ();	
	if ( m_cp == EndOfConfigs )		// Write !ENDIF
	{
		mw.WriteDirective (CMakDirective::DTYP_ENDIF, NULL);
	}	
	else
	{
		const CString &strCfg = pcr->GetConfigurationName ();

		int len = 16 + strCfg.GetLength ();
		pc = str.GetBuffer (len);
		_tcscpy ( pc, _TEXT (" \"$(CFG)\" == \"") );
		_tcscpy ( pc +	14, (const char *) strCfg);
		_tcscpy ( pc + len -2, _TEXT ("\"")); 

		mw.WriteDirective (
				(( m_cp == FirstConfig) ? CMakDirective::DTYP_IF : 
									   CMakDirective::DTYP_ELSEIF)
				,pc
				);
	}
	mw.EndLine ();
}
///////////////////////////////////////////////////////////////////////////////
// (throw CFileException if unknown confiugration)
void CProjItem::ReadConfigurationIfDef(CMakDirective *pmd, BOOL bCheckProj /* = FALSE */)
{
	// N.B. FUTURE (karlsi): Currently we don't handle nested switches
	TCHAR *pstart, *pend;

	if (pmd->m_dtyp == CMakDirective::DTYP_ENDIF)
	{
		if (bCheckProj)
		{
			ASSERT(IsKindOf(RUNTIME_CLASS(CProject)));
			CString strProject;
			CProject * pProject;
			CProject::InitProjectEnum();
			while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
			{
				pProject->m_cp = EndOfConfigs;
			}
		}
		else
		{
			m_cp = EndOfConfigs;
		}
	}
	else if (pmd->m_dtyp == CMakDirective::DTYP_ELSEIF ||
			 pmd->m_dtyp == CMakDirective::DTYP_IF)
	{
		// Skip over "$(CFG)" part
		pstart	= pmd->m_strRemOfLine.GetBuffer(1);
		if (!GetQuotedString (pstart, pend) ||
			_tcsncmp ( _TEXT("$(CFG)"), pstart, 6) != 0)
			AfxThrowFileException (CFileException::generic);

		pstart =_tcsinc(pend);
		if (!GetQuotedString(pstart, pend))
			AfxThrowFileException (CFileException::generic);

		*pend = _T('\0');

		// put the whole project into this configuration
		if (bCheckProj)
		{
			ASSERT(IsKindOf(RUNTIME_CLASS(CProject)));
			CString strProject;
			BOOL bFoundProject = FALSE;
			CProject * pProject = (CProject *)this;
			CProject::InitProjectEnum();
			while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
			{
				if (!bFoundProject)
				{
					int i;
					ConfigurationRecord* pcr;
					int size = pProject->GetPropBagCount();
					for (i=0; i < size; i++)
					{
						pcr = (ConfigurationRecord*) pProject->GetConfigArray()->GetAt(i);
						ASSERT(pcr);
						if (pcr->GetConfigurationName().CompareNoCase(pstart) == 0)
						{
							bFoundProject = TRUE;
							g_pActiveProject = pProject;
							break;
						}
					}
				}
				pProject->m_cp = (pmd->m_dtyp == CMakDirective::DTYP_IF) ? 
						FirstConfig : MiddleConfig;									 
			}

			ASSERT(bFoundProject);
			if (!bFoundProject)
				AfxThrowFileException (CFileException::generic);

			g_pActiveProject->SetActiveConfig(pstart);
		}
		else	
		{
			GetProject()->SetActiveConfig(pstart);
			m_cp = (pmd->m_dtyp == CMakDirective::DTYP_IF) ? 
					FirstConfig : MiddleConfig;									 
		}

	}
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::GetDependenciesMacro(UINT depType, CString & strDeps, CNameMunger & nm)
{
    ConfigurationRecord * pcr = GetActiveConfig();
    if (pcr == (ConfigurationRecord *)NULL)
		return FALSE;

	CActionSlobList * pActions = pcr->GetActionList();
	if (pActions->IsEmpty())
		return FALSE;

	// FUTURE: handle more than one tool on this source file
	ASSERT(pActions->GetCount() == 1 || !IsKindOf(RUNTIME_CLASS(CFileItem)));
	CActionSlob * pAction = (CActionSlob *)pActions->GetHead();

	CFileRegSet * psetDep;

	// get approp. dep. set
	if (depType == DEP_Scanned)
		psetDep = pAction->GetScannedDep();

	else if (depType == DEP_Missing)
		psetDep =pAction->GetMissingDep();

	else if (depType == DEP_UserDefined)
		psetDep = NULL /*pAction->GetUserDefinedDep()*/;

	else
		ASSERT(FALSE);

	// any deps?
#ifndef REFCOUNT_WORK
	if (psetDep->GetContent()->IsEmpty())
		return FALSE;
#else
	if (depType == DEP_UserDefined )
	{
		BOOL fExcluded;
		CString strDeps;
		if (invalid == GetStrProp(P_UserDefinedDeps, strDeps) )
			return FALSE;
		else if (strDeps.IsEmpty())
			return FALSE;
		// REVIEW: we currently don't persist excluded custom build rules, so don't persist
		//			the user deps either
		else if ((GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid) && (fExcluded))
			return FALSE;
	}
	else
	{
		ASSERT(IsKindOf(RUNTIME_CLASS(CFileItem)));

		if (psetDep->IsEmpty() && !((CFileItem *)this)->m_bAlwaysWriteDepMacro)
		{
			return FALSE;
		}
	}
#endif

	CBuildTool * pTool = GetSourceTool();
	ASSERT(pTool != (CBuildTool *)NULL);

	// construct dependency macro of the form
	// 'DEP_<tool prefix>_<munged name>' eg. 'DEP_CPP_APPWIZ'
	CString strMungeName;
	nm.MungeName (GetFilePath()->GetFileName (), strMungeName);

	// get approp. dep. prefix
	if (depType == DEP_Scanned)
		strDeps = _TEXT("DEP_");

	else if (depType == DEP_Missing)
		strDeps = _TEXT("NODEP_");

	else if (depType == DEP_UserDefined)
	{
		// Only custom build rules can have user defined deps for 5.0.
		ASSERT((pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))) ||
			(pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool))));

		strDeps = _TEXT("USERDEP_");
	}

	else
		ASSERT(FALSE);

	// tool prefix?
	strDeps += pTool->m_strToolPrefix;

	// filename postfix?
	if ((depType != DEP_UserDefined) || (!pTool->IsKindOf(RUNTIME_CLASS(CUnknownTool))))
	{
		strDeps += _T("_");
		strDeps += strMungeName;
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
HCURSOR CProjItem::GetCursor(int ddcCursorStyle)
{
	int iCursors = 0;	// At the moment we only have 1 set of cursors!

	switch (ddcCursorStyle)
	{
		case DDC_SINGLE:
			return g_Cursors.GetDDCur(iCursors);

		case DDC_COPY_SINGLE:
			return g_Cursors.GetDDCopyCur(iCursors);

		case DDC_MULTI:
			return g_Cursors.GetDDMultiCur(iCursors);

		case DDC_COPY_MULTI:
			return g_Cursors.GetDDMultiCopyCur(iCursors);

		default:
			ASSERT(FALSE);
			return NULL;
	}
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	// no page
	
	return CProjSlob::SetupPropertyPages(pNewSel, bSetCaption);
}
///////////////////////////////////////////////////////////////////////////////
void CProjItem::InformDependants(UINT idChange, DWORD dwHint)
{
	CSlob::InformDependants(idChange, dwHint);

	BOOL fIsProxySlob = IsKindOf(RUNTIME_CLASS(CProxySlob));

	//
	// Inform other non-CSlob, dependents here ....
	//
	// only inform if not CProxySlob
	if (!fIsProxySlob)
	{
		CProject * pProject = GetProject();

		if (idChange == P_ProjUseMFC &&	pProject->m_bProjectComplete)
		{
			// we need to make sure we have the right setup
			// for an MFC project
			CProjType * pprojtype = pProject->GetProjType();
			int val;
			if (pprojtype != (CProjType *)NULL &&
				pProject->GetIntProp(P_ProjUseMFC, val)
			   )
			{
				pprojtype->PerformSettingsWizard(this, val);
			}
		}
	}

	// 
	// Inform other, non-CSlob, dependents here ....
	//
	// only inform if to current bag and not CProxySlob, ie. not the clone bag during Project.Settings
	if (m_idBagInUse == CurrBag && !fIsProxySlob)
	{
		// inform any associated actions so that they may add/remove inputs and outputs?
		// or that the file may become a part of the build
		if (idChange == P_ItemExcludedFromBuild)
		{
			CProject * pProject = GetProject();
			CTargetItem* pTarget = GetTarget();

			if (pProject != (CProject *)NULL && pProject->m_bProjectComplete &&	// project complete
						pTarget->IsFileInTarget(GetFileRegHandle()))	// part of project
			{
				if (!IsKindOf(RUNTIME_CLASS(CDependencyFile)) &&
					!IsKindOf(RUNTIME_CLASS(CDependencyContainer))
				   )
				{
#ifndef REFCOUNT_WORK
					// including or excluding in build?
					BOOL fExcluded;
					if (GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid)
					{
						if (fExcluded)
							CActionSlob::ReleaseRefFileItem(this);
						else	
							CActionSlob::AddRefFileItem(this);
					}
#else
					if (IsKindOf(RUNTIME_CLASS(CFileItem)))
					{
							// Add to dependency graph as possible input to schmooze tool.
						BOOL fExcluded;
						if (GetIntProp(P_ItemExcludedFromBuild, fExcluded) == valid)
						{
							ConfigurationRecord* pcr = GetActiveConfig();
							ASSERT( NULL!=pcr);
							CFileRegistry *preg = g_buildengine.GetRegistry(pcr);
							ASSERT(NULL!=preg);
							FileRegHandle frh = GetFileRegHandle();
							ASSERT(NULL!=frh);

							if (fExcluded)
								preg->ReleaseRegRef(frh);
							else
								preg->AddRegRef(frh);
						}
					}
#endif
				}

				// local, only affects outputs for those actions assoc. with this item
				CActionSlob::InformActions(this, P_ItemExcludedFromBuild, (ConfigurationRecord *)NULL, FALSE);
			}
		}
  		
		// inform our actions that their output state is likely to have changed?
 		// (many output files are derived from the output directories and/or remote target)
		else if (idChange == P_OutDirs_Target || idChange == P_OutDirs_Intermediate ||
				 idChange == P_TargetName || idChange == P_RemoteTarget ||
                 idChange == P_DeferredMecr)
		{
			CProject * pProject = GetProject();
			// only inform if the project is complete, ie. not constructing/destructing
			if (pProject != (CProject *)NULL && pProject->m_bProjectComplete)
			{
				// global, may affect childrens outputs
				CActionSlob::InformActions(GetTarget(), P_ToolOutput);

				// When the output directory changes make sure we rescan the rc files
				// This is a hack so that we fix up tlb dependencies correctly
//				if (!g_bNewUpdateDepModel&& idChange == P_OutDirs_Target)
				if (idChange == P_OutDirs_Target)
				{
					CObList ol;
					pProject->FlattenSubtree(ol, flt_Normal | flt_ExcludeDependencies);

					POSITION pos = ol.GetHeadPosition();
					while (pos)
					{
						CProjItem * pItem = (CProjItem *)ol.GetNext(pos);
						if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
						{
							CString strExt = pItem->GetFilePath()->GetExtension();
							if (strExt.CompareNoCase(_T(".RC")) == 0)
							{
								// Must rescan this item as it is a rc file.
//								FileItemDepUpdateQ((CFileItem *)pItem, NULL, NULL, g_FileForceUpdateListQ);
//								FileItemDepUpdateQ((CFileItem *)pItem, NULL, pItem->GetFileRegHandle(), g_FileDepUpdateListQ);
							}
						}
					}
				}

				// FUTURE:
				// this is a hack for project-level custom-build steps
				// informing that the inputs (.objs) to the .exe has changed
				// will remove the .exe and then re-create, we need
				// to re-affix the project-level custom-build step thus...
				CBuildTool * pTool;
				VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_CustomBuild), (CBldSysCmp *&)pTool));

				CPtrList lstSelectTools;
				lstSelectTools.AddTail(pTool);

				// Special build tool to handle pre-link/post-build.
				VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_SpecialBuild), (CBldSysCmp *&)pTool));
				lstSelectTools.AddTail(pTool);

#if 0
				CProjItem * pMyItem = pProject;
				CTargetItem * pMyTarget = pMyItem->GetTarget();
				ASSERT(pMyTarget->GetTarget());
#endif
				// un-assign any project-level custom build tool
				CActionSlob::UnAssignActions(pProject, &lstSelectTools, (ConfigurationRecord  *)NULL, FALSE);

				// try to re-assign any project-level custom build tool
				CActionSlob::AssignActions(pProject, &lstSelectTools, (ConfigurationRecord  *)NULL, FALSE);

			}
		}

		// setting the target output directory or ext. opts .bsc name? -> inform packages
		// (the user has potentially changed the .BSC name)
		if (idChange == P_OutDirs_Target || idChange == P_ExtOpts_BscName || idChange == P_Proj_BscName)
		{ 
			CProject * pProject = GetProject();
			// only inform if the project is complete, ie. not constructing/destructing
			if (pProject != (CProject *)NULL && pProject->m_bProjectComplete && pProject->m_bNotifyOnChangeConfig )
				theApp.NotifyPackages(PN_CHANGE_BSC);	
		}
		
		// configuration name changes may need to be forwarded to targets/target references displaying
		// the configuration name that has changed
		else if (idChange == P_ProjConfiguration && GetProject() && GetProject()->m_bProjectComplete)
		{
			CString strConfig;
			VERIFY(GetStrProp(P_ProjConfiguration, strConfig));

			CProject * pProject = GetProject();
			CBuildNode * pBldNode = GetBuildNode();
			pBldNode->InformBldSlobs(this, P_ProjConfiguration, dwHint);
		}

		// option handler action changes
		else if (idChange >= PROJ_BUILD_OPTION_FIRST && idChange <= PROJ_BUILD_OPTION_LAST)
		{
			// get the option handler for the prop?
			COptionHandler * pOptHdlr = g_prjcompmgr.FindOptionHandler(idChange);
			CBuildTool * pTool = pOptHdlr != (COptionHandler *)NULL ? pOptHdlr->m_pAssociatedBuildTool : (CBuildTool *)NULL;
			
			// affects the outputs?
			if (pTool != (CBuildTool *)NULL && pTool->AffectsOutput(pOptHdlr->MapActual(idChange)))
			{
				// local, only affects outputs of those actions interested in tool
				pTool->InformDependants(P_ToolOutput, (DWORD)this);
			}
		}

		// break else here... to test for SN_ALL

		// re-assign custom build actions changes
		if (idChange == P_CustomCommand || idChange == P_CustomOutputSpec ||	// semantic change
			idChange == P_UserDefinedDeps ||

			idChange == SN_ALL ||												// global change

			idChange == P_TargetName ||											// target name (binding)
			idChange == P_OutDirs_Target ||										// target output (binding)
			idChange == P_PreLink_Command ||
			idChange == P_PostBuild_Command ||
			idChange == P_RemoteTarget											// target output (binding)
		   )
		{
			CProject * pProject = GetProject();

			if (pProject != (CProject *)NULL && pProject->m_bProjectComplete)	// project complete
			{
				CBuildTool * pTool;
				VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_CustomBuild), (CBldSysCmp *&)pTool));

				CPtrList lstSelectTools;
				lstSelectTools.AddTail(pTool);

				// Special build tool to handle pre-link/post-build.
				VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_SpecialBuild), (CBldSysCmp *&)pTool));
				lstSelectTools.AddTail(pTool);

				// un-assign any custom build tool
#if 0
				if (pProject == this)
				{
					ASSERT(GetTarget());
					CActionSlob::UnAssignActions(GetTarget(), &lstSelectTools, (ConfigurationRecord  *)NULL, FALSE);

					// try to re-assign a custom build tool
					CActionSlob::AssignActions(GetTarget(), &lstSelectTools, (ConfigurationRecord  *)NULL, FALSE);
				}
				else
#endif
				{
					CActionSlob::UnAssignActions(this, &lstSelectTools, (ConfigurationRecord  *)NULL, FALSE);

					// try to re-assign a custom build tool
					CActionSlob::AssignActions(this, &lstSelectTools, (ConfigurationRecord  *)NULL, FALSE);
				}

#if 0
				// We are never actually changing this property when
				// idChange is any of the ones in the if stmt above.
				// calling this causes us to do gratuitous AddRef's or 
				// ReleaseRef's [sanjays]

				// possible buildable change
				InformDependants(P_ItemExcludedFromBuild);
#endif

				// possible target-name change
				if (idChange == P_TargetName)
				{
					CString strConfig;
					VERIFY(GetStrProp(P_ProjConfiguration, strConfig));

					CProject * pProject = GetProject();
					CBuildNode * pBldNode = GetBuildNode();
					pBldNode->InformBldSlobs(this, P_TargetName, dwHint);
				}
			}
		}

		// break else here... to test for SN_ALL

		// global action changes
 		// (SN_ALL or builder filename change)
		if (idChange == SN_ALL ||				// global change
			idChange == P_BldrFileName ||
			idChange == P_Proj_TargDefExt		// default target extension
		   )
		{
			COptionHandler * pOptHdlr;
			CPtrList lstTool;	 

			g_prjcompmgr.InitOptHdlrEnum();
			while (g_prjcompmgr.NextOptHdlr(pOptHdlr))
			{
				CBuildTool * pTool = pOptHdlr->m_pAssociatedBuildTool;

				// affects the outputs?
				if (pTool != (CBuildTool *)NULL &&
					(idChange == SN_ALL || pTool->AffectsOutput(idChange))
				   )
					lstTool.AddTail(pTool);
			}

			POSITION pos = lstTool.GetHeadPosition();
			while (pos != (POSITION)NULL)
				// local, only affects outputs of those actions interested in tool
				((CBuildTool *)lstTool.GetNext(pos))->InformDependants(P_ToolOutput, (DWORD)this);
		}
	}

	if (idChange == P_ItemIgnoreDefaultTool && (!fIsProxySlob))
	{
		ASSERT(IsKindOf(RUNTIME_CLASS(CFileItem)));
		if (GetProject() && GetProject()->m_bProjectComplete)
		{
			ConfigurationRecord * pcr = (ConfigurationRecord *)GetActiveConfig()->m_pBaseRecord;
			CActionSlob::UnAssignActions(this, NULL, pcr);
			CActionSlob::AssignActions(this, NULL, pcr);
		}
	}

	// Inform the Build.Settings tree of changes, so it can display changes to target names
	// and also display changes to item glyphs when exclude from build state changes.
	CProject * pProject;
	POSITION posProjects = CProject::GetProjectList()->GetHeadPosition();
	while (posProjects != NULL)
	{
		pProject = (CProject *)CProject::GetProjectList()->GetNext(posProjects);
		if ((pProject == NULL) || (!pProject->IsLoaded()))
			continue;

		COptionTreeCtl * pOptTreeCtl = pProject->GetOptionTreeCtl();
		if (pOptTreeCtl != (COptionTreeCtl *)NULL &&
			pOptTreeCtl->InterestedInPropChange(idChange, this))
			pOptTreeCtl->ProjItemChanged(this, idChange);
	}

	//
	// DO NOT dirty project for dependency file or container.
    // DO NOT dirty project for private build options
	//
    if ( idChange == P_Container || IsPropPublic(idChange) )
	{
		if (
			(!IsKindOf(RUNTIME_CLASS(CDependencyFile))) && 
			(!IsKindOf(RUNTIME_CLASS(CProjectDependency))) &&
			(!IsKindOf(RUNTIME_CLASS(CDependencyContainer)) &&
            idChange != P_DeferredMecr)
		   )
		{
			CProject *pProj = GetProject();
			if( pProj ){
				pProj->DirtyProject();
			}
		}
	}

	// FUTURE: inform the option handler?
	// FUTURE: get the option handler for this prop?
	// what about duplication with GetStrProp()
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::CanDoTopLevelBuild ()
{
	// we can't do a build if :-
	// o we are already doing one

	return g_Spawner.CanSpawn();
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::CheckForDuplicateTargets (CObList &ol, UINT idMess /* = -1 */)
{
	// is this list empty?
	if (ol.IsEmpty())
		return FALSE;	// no duplicates!
		
	CProjItem *pItem, * pItem1;
	POSITION pos;
	CMapPtrToPtr FileMap (ol.GetCount() * 2);
	FileRegHandle frh;
	CString str;
	CString strExtension;

	for (pos = ol.GetHeadPosition (); pos != NULL;)
	{
		pItem = (CProjItem *) ol.GetNext (pos);

		if (!pItem->UsesSourceTool ()) continue;

		// We don't have to check for exlude from build properites--we assume 
		// this was done when the subtree was created.
		ASSERT(pItem->GetActiveConfig());
		CFRFPtrArray * parray = pItem->GetActiveConfig()->GetTargetFilesArray();
		ASSERT(parray);
		int index;
		int count = parray->GetSize();

		for ( index=0; index < count; index++ )
		{
			frh = parray->GetAt(index);
			strExtension =  g_FileRegistry.GetRegEntry(frh)->GetFilePath()->GetExtension();

			// we should just skip .pdb/.icc files since quite a few files
			// will have the same .pdb/.icc files.
			if (strExtension.CompareNoCase(_T(".PDB")) == 0 ||
				strExtension.CompareNoCase(_T(".IDB")) == 0)
				continue;

			if (FileMap.Lookup ( (void *) frh, (void *&) pItem1))
			{
				if (idMess != -1)
				{
					::MsgBox ( 
							Error, 
						   	::MsgText ( 
						   			str, 
						   			idMess,
									(const TCHAR *) *pItem->GetFilePath(),
						   			(const TCHAR *) *pItem1->GetFilePath(),
									(const TCHAR *) *g_FileRegistry.GetRegEntry(frh)->GetFilePath()
 									),
						   	MB_OK
						   );
				}
				return TRUE;
			}
			else  FileMap.SetAt ( frh, pItem );
		}
	}
	return FALSE;		// No dupes.
}

///////////////////////////////////////////////////////////////////////////////
// Log build time information to a remote server.
//
#ifdef _BTLOG
//#pragma message ("ALERT! : projitem.cpp : Including build time logging for QA...")
static void TransportBTInfo(const CString& strElapsedTime, CProject::BuildType bt, 
							BOOL bRebuildAll, CProject* pProject, DWORD dwTargetSize, 
							CString strPlatform)
{
	// Send the Build Time information over the net to the database.
	// Just use a hard-coded file name as this is completely
	// internal.
 	static char szLogFileName[] = "\\\\dtqalogs\\db\\editgo\\editgo.dat";
 	const int maxRetries = 1;
	HANDLE hFile ;

	for (int i = 0; i < maxRetries ; i++ )
	{
		if ( (hFile = CreateFile(szLogFileName,GENERIC_READ|GENERIC_WRITE,
								FILE_SHARE_READ,NULL,OPEN_ALWAYS,
								FILE_ATTRIBUTE_NORMAL,NULL)
			  ) != INVALID_HANDLE_VALUE )
		{
			break;
		}
		Sleep(300); // wait 0.3 seconds if it failed.
	}
	if ( i == maxRetries )
		return ; // No luck couldn't open the file.

	// Start writing from the end of the file.
	SetFilePointer(hFile,0,NULL,FILE_END);

	// Write out the relevant information to the file in the
	// following format.
	// 10/6/93, COLINT3, Debug or Release IDE, Chicago or Daytona,
	// Elapsed build time
 	const DWORD MAX_SIZE = 512;
	char buffer[MAX_SIZE]; // Buffer to hold intermediate values.
	char logString[MAX_SIZE * 2]; // Complete string.
	DWORD  cBytesWritten ;

	logString[0] = '\n';
	_strdate(logString + 1); // get current date in mm/dd/yy form.
	lstrcat(logString,",");

	_strtime(logString + lstrlen(logString));
	lstrcat(logString,",");

	// Computer name.
	GetComputerName(buffer,(LPDWORD)&MAX_SIZE);
	lstrcat(logString,buffer);
	lstrcat(logString,",");

#ifdef _DEBUG
	lstrcat(logString, "Debug IDE,");
#else	
	lstrcat(logString, "Release IDE,");
#endif

	if (NotOnNT())
		lstrcat(logString, "Chicago,");
	else
		lstrcat(logString, "Daytona,");

	if (theApp.m_fOEM_MBCS)
		lstrcat(logString, "Multi-byte OS,");
	else
		lstrcat(logString, "Single-byte OS,");

	// Project name
	CString strProjectName;
	pProject->GetStrProp(P_ProjItemName, strProjectName);
	lstrcat(logString, strProjectName);
	lstrcat(logString, ",");

	// Platform name
	lstrcat(logString, strPlatform);
	lstrcat(logString, ",");

	// Target name
	ASSERT(pProject->GetActiveConfig());
	const ConfigurationRecord* pcr = pProject->GetActiveConfig();
	CString strTargetName = pcr->GetConfigurationName();
	lstrcat(logString, strTargetName);
	lstrcat(logString, ",");

	// Target size
	char szTargetSize[20];
	sprintf(szTargetSize, "%u,", dwTargetSize / 1000);
	lstrcat(logString, szTargetSize);

	// Build type
	switch (bt)
	{
		case CProject::Compile:
			// Should never log compiles, just builds, rebuilds, and
			// batch builds
			ASSERT(FALSE);
			break;

		case CProject::NormalBuild:
			lstrcat(logString, "Normal Build,");
 			break;

		case CProject::BatchBuild:
			lstrcat(logString, "Batch Build,");
			break;
		}

	if (bRebuildAll)
		lstrcat(logString, "Rebuild,");
	else
		lstrcat(logString, "Build,");

 	// elapsed build time
	lstrcat(logString, strElapsedTime);
 
	WriteFile(hFile,logString, lstrlen(logString),&cBytesWritten,NULL);

	// We are all done, close the file.
	CloseHandle(hFile);
}
#endif

///////////////////////////////////////////////////////////////////////////////
// Called for the highest level item to be built. This build only
// single items. Group have there own implementation.
//
BOOL CProjItem::DoTopLevelBuild (UINT buildType,
				CStringList * pConfigs /* = NULL */,
				FlagsChangedAction fca /* = fcaNeverQueried */,
				BOOL bVerbose /* = TRUE */,
				BOOL bClearOutputWindow /* = TRUE */,
				BOOL bRecurse /* = TRUE */
				) 
{ 
#ifdef PROF_BUILD_OVERHEAD
	StartCAPAll();
#endif

	CErrorContext *pEC;
	CProject::BuildResults br;
	CString str, strName;
	BOOL bCancelled = FALSE;
	BOOL bQuery;
	CProject::BuildType bt;
	CPlatform * pPlatform;
	BOOL bDeferMecr = FALSE;
	int iDeferredMecr = 0;

	CPath * pPath;

	DWORD dwStartTime = ::GetTickCount(); 

#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "devbldd.pkg", "DoTopLevelBuild()", letypeBegin, 0);
#endif

#ifdef _BTLOG
	CPtrList	ConfigPcrs;	// Used to figure out total target size
#endif

	DWORD errs = 0, warns = 0;
	DWORD TotalErrs = 0, TotalWarns = 0;

	if (!theApp.NotifyPackages(PN_QUERY_BEGIN_BUILD) || 
		!g_Spawner.CanSpawn())
	{
#ifdef PROF_BUILD_OVERHEAD
		StopCAPAll();
#endif
		return FALSE;
	}

	CProject * pProject = GetProject(); ASSERT_VALID (pProject);

	// Are we building a macintosh 68k target, if so then we
	// may be attempting to update the remote target.
	// If so do we have a remote executable file name, if not
	// then we should ask for one before we can do the build.
	CProjType *pProjType = GetProjType();
	if( pProjType == NULL ){
		return FALSE;
	}

	pPlatform = pProjType->GetPlatform();

	if ((pPlatform->GetUniqueId() == mac68k ||
         pPlatform->GetUniqueId() == macppc) && 
		 pConfigs == NULL)
	{
		VERIFY(pProject->GetIntProp(P_DeferredMecr, iDeferredMecr));
		if (iDeferredMecr == dabNotDeferred)
		{
			// Make sure we have a remote executable name...
			if (!pProject->GetInitialRemoteTarget())
			{
#ifdef PROF_BUILD_OVERHEAD
				StopCAPAll();
#endif
				return FALSE;
			}
		}
	}

	// No properties can change from here on out.  We can do this before a save 
	// because we know we won't be doing a save as, so the project filename and
	// and directory won't be changing
	ConfigCacheEnabler EnableCaching;				
	ASSERT (pProject->GetFilePath());

	// What type of build are we attempting to do, compile, build, or 
	// batch build?	
	if (IsKindOf(RUNTIME_CLASS(CFileItem)))
		bt = CProject::Compile;
	else if (pConfigs == NULL)
		bt = CProject::NormalBuild;
	else
		bt = CProject::BatchBuild;

	CWaitCursor wc;		// Display hourglass until this object destroyed

	// First flatten the subtree and check whether there is anything
	// to compile or not.
	CObList ol;
	FlattenSubtree (ol, bt == CProject::Compile ? (flt_Normal | flt_ExcludeDependencies | flt_ExcludeGroups) : (flt_Normal|flt_RespectItemExclude | flt_ExcludeDependencies | flt_RespectTargetExclude | flt_ExcludeGroups));

	BOOL bIsExternalTarget = (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)));
	if (buildType!=TOB_Clean && !bIsExternalTarget && CheckForDuplicateTargets(ol, IDS_SAME_TARGET) && bt!=CProject::BatchBuild)
	{
#ifdef PROF_BUILD_OVERHEAD
		StopCAPAll();
#endif
		return FALSE;
	}

	wc.Restore();

	// ASSERT (pProject == this );
#if 0
	BOOL bFilesToBuild = TRUE; // (bt==CProject::BatchBuild);
	if (!bFilesToBuild)
	{
		POSITION pos = ol.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CProjItem * pItem = (CProjItem *)ol.GetNext(pos);
			if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)) || pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			{
 				bFilesToBuild = TRUE;
				break;
			}
 		}
	}

	if (!bFilesToBuild  && (pProjType && !pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget))))
	{
		if( !g_bBatchBuildInProgress )
			MsgBox(Information, IDS_NO_SOURCE_FILE_BUILD);

#ifdef PROF_BUILD_OVERHEAD
		StopCAPAll();
#endif
		return TRUE;
	}
#endif
	
	// Do save before build (if appropriate):
	if (g_Spawner.IsSaveBeforeRunningTools(&bQuery))
	{
		if (bIsExternalTarget)
		{
			// save non-project files too for external target
			if (!theApp.SaveAll(bQuery, FILTER_DEBUG | FILTER_PROJECT))
			{
#ifdef PROF_BUILD_OVERHEAD
				StopCAPAll();
#endif
				return FALSE;
			}
		}
		else
		{
			if (!theApp.SaveAll(bQuery, FILTER_DEBUG | FILTER_PROJECT | FILTER_NON_PROJECT | FILTER_NEW_FILE))
			{
#ifdef PROF_BUILD_OVERHEAD
				StopCAPAll();
#endif
				return FALSE;
			}
		}
	}


	// Initialize the spawner and output window:
	ASSERT (!g_Spawner.SpawnActive ());

	if ((pEC = g_Spawner.InitSpawn (bClearOutputWindow)) == NULL )
	{
#ifdef PROF_BUILD_OVERHEAD
		StopCAPAll();
#endif
		return FALSE;
	}
	LogEnabler *pLog = NULL;
	if (buildType != TOB_Clean)
		pLog = new LogEnabler(GetProject());

	theApp.NotifyPackages (PN_BEGIN_BUILD, (void *)bIsExternalTarget);
	
	// Handle the default case - where we just build the active config

	BOOL bConfigAllocated = FALSE;
	if (pConfigs == NULL)
	{
		CString strActiveConfig;

// 		pProject->GetStrProp(P_ProjActiveConfiguration, strActiveConfig);
		ConfigurationRecord *pCfg = pProject->GetActiveConfig();
		ASSERT(pCfg != NULL);
		strActiveConfig = pCfg->GetConfigurationName();

		pConfigs = new CStringList;
		pConfigs->AddTail(strActiveConfig);
		bConfigAllocated = TRUE;
	} else {
		// Fixing a long standing bug in Batch build. This bit of code
		// goes through the configs list and attempts to remove
		// subprojects that are going to be built anyway.
		// Note this is a very slow procedure, but not nearly as slow
		// as actually compiling twice ! (KPerry)
		
/*
		CStringList HitList;
		POSITION pos = pConfigs->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CString strConfigName = pConfigs->GetNext(pos);
			HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strConfigName, NO_BUILDER);
			if (hTarget == NO_TARGET)
				continue;
			CTargetItem * pCurrentTarget = g_BldSysIFace.CnvHTarget(g_BldSysIFace.GetBuilder(hTarget), hTarget);
	
			POSITION pos2 = pConfigs->GetHeadPosition();
			while (pos2 != (POSITION)NULL)
			{
				CString strConfigName2 = pConfigs->GetNext(pos2);
				HBLDTARGET hTarget2 = g_BldSysIFace.GetTarget(strConfigName2, NO_BUILDER);
				if (hTarget2 == NO_TARGET)
					continue;
				CTargetItem * pTarget = g_BldSysIFace.CnvHTarget(g_BldSysIFace.GetBuilder(hTarget2), hTarget2);
		
				// get a str list of all sub project configurations.
				if ( pCurrentTarget->IsTargetReachable(pTarget) ){
					CString str1,str2;
					CString strTarg, strTarg2;
					// now if the 2 configurations match exactly then don't build this.
					str1 = strConfigName.Right(strConfigName.GetLength() - (strConfigName.Find(" - ")+3) );
					str2 = strConfigName2.Right(strConfigName2.GetLength() - (strConfigName2.Find(" - ")+3) );
					if ( str2 == str1 ){
						HitList.AddHead( strConfigName2 );
					}
				}
			}
		}

		// Now remove the elements. (Note this could be done in the previous
		// loop but it might have been tricky to get right).
		pos = HitList.GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			POSITION pos2;
			CString strConfigName = HitList.GetNext(pos);
			pos2 = pConfigs->Find(strConfigName);
			if( pos2 )
				pConfigs->RemoveAt(pos2);
		}
	*/
	}

	while (!pConfigs->IsEmpty() && !bCancelled)
	{
		CString strConfigName;

		strConfigName = pConfigs->GetHead();
		HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strConfigName, NO_BUILDER);
		ASSERT(hTarget);
		if (hTarget == NO_TARGET){
			pConfigs->RemoveHead();
			continue;
		}

		pProject = (CProject *)g_BldSysIFace.GetBuilder(hTarget);
		ASSERT(pProject);
		if (pProject==NULL){
			pConfigs->RemoveHead();
			continue;
		}

		// pProject->SetStrProp(P_ProjActiveConfiguration, strConfigName);
	
		CProjTempProjectChange projectChange(pProject);
		CProjTempConfigChange configChange(pProject);
		configChange.ChangeConfig(strConfigName);

		void *pDummy = NULL;
		if( CBuildIt::m_mapConfigurationsBuilt.Lookup(strConfigName, pDummy) ){
			pConfigs->RemoveHead();
			continue;
		}


		// If we are doing a batch build then we defer mecr by default
		// set on per config base
		if (bt == CProject::BatchBuild)
		{
			VERIFY(pProject->GetIntProp(P_DeferredMecr, iDeferredMecr));
			VERIFY(pProject->SetIntProp(P_DeferredMecr, dabDeferred));
			bDeferMecr = TRUE;
		}

#ifdef _BTLOG
		const ConfigurationRecord* pcr = GetActiveConfig();
		ASSERT(pcr);
		ConfigPcrs.AddTail((void*)pcr);
#endif
		// we basically need to get just the filename
		// of the main output generated by this projitem
		CPath pathTemp ;
		if (IsKindOf (RUNTIME_CLASS(CProject)) )
		{
			pPath = pProject->GetTargetFileName() ;
			if (pPath)
			{
				ASSERT(pPath); ASSERT(pPath->IsInit());
				strName = (TCHAR *) pPath->GetFileName() ;
				delete pPath;
			}
			else
			{	
				// If this is java, just set strName to the project name.  First make
				// sure this is a java target (if it's a batch build and a platform
				// doesn't exist, we can end up in this code for platforms other then
				// Java.

				CString strActiveConfig, strFlavor;

				// logic taken from CBldSysIFace::GetTargetNameFromFileSet
				ASSERT(pProject->GetActiveConfig());
				strActiveConfig = pProject->GetActiveConfig ()->GetConfigurationName ();
				g_BldSysIFace.GetFlavourFromConfigName(strActiveConfig, strFlavor);
				strActiveConfig = strActiveConfig.Left(strActiveConfig.GetLength() - 
					                                   strFlavor.GetLength());
				strName = strActiveConfig;
				int nSep = strActiveConfig.Find(_T(" - "));
				if (nSep > 1)
				{
					strName = strActiveConfig.Left(nSep);
					strActiveConfig = strActiveConfig.Mid(nSep + 3);
					// Review: Could also apply to generic projects
					// ASSERT(strActiveConfig == "Java Virtual Machine ");
				}
			}
		}
		else if (IsKindOf (RUNTIME_CLASS (CFileItem)) &&
			 (GetStrProp (P_ProjMainTarget, strName) == valid))
		{
			pathTemp.Create(strName) ;
			strName = pathTemp.GetFileName() ;
		}
		else 
		{
			GetStrProp (P_ProjItemName, strName) ;
			pathTemp.Create(strName) ;
			strName = pathTemp.GetFileName() ;
		}

		CTempMaker TM;
		if(bt == CProject::BatchBuild){
			br = pProject->DoBuild (pProject, buildType, buildType==TOB_Clean, fca, TM, *pEC, bt, bVerbose, bRecurse);
		} else {
			br = pProject->DoBuild (this, buildType, buildType==TOB_Clean, fca, TM, *pEC, bt, bVerbose, bRecurse);
		}

		
		TM.NukeFiles (*pEC);	// Clean up temporary files.

		g_Spawner.GetErrorCount ( errs, warns );

		errs = errs - TotalErrs;
		warns = warns - TotalWarns;
		// fixup case where an error occured but the spawner couldn't figure that out.
		// REVIEW: the whole counting of errors scheme should be reworked so we don't have to do this.
		int actualErrs = errs ? errs : ( br == CProject::BuildError);
		CBuildIt::m_actualErrs += actualErrs;
		CBuildIt::m_warns += warns;

		// BLOCK: Buzz the user...
		if (buildType != TOB_Clean)
		{
			UINT nBeepType = 0;
			UINT idsBeep;

			switch (br)
			{
			case CProject::BuildCanceled:
				break;

			case CProject::BuildError:
			case CProject::BuildComplete:
				if (actualErrs != 0)
				{
					idsBeep = IDS_SOUND_BUILD_ERROR;
					nBeepType = MB_ICONEXCLAMATION;
				}
				else if (warns != 0)
				{
					idsBeep = IDS_SOUND_BUILD_WARNING;
					nBeepType = MB_ICONQUESTION;
				}
				else
				{
					idsBeep = IDS_SOUND_BUILD_COMPLETE;
					nBeepType = MB_ICONASTERISK;
				}
				break;

			case CProject::NoBuild:
				idsBeep = IDS_SOUND_BUILD_UPTODATE;
				nBeepType = MB_ICONASTERISK;
				break;
			}

			if( buildType != TOB_Clean ) {
				if( PlayDevSound(idsBeep) )
					nBeepType = 0;
	
				if (nBeepType != 0)
					MessageBeep(nBeepType);
			}

			if (bDeferMecr)
			{
				if (pProject->GetCurrentPlatform()->GetUniqueId() == mac68k ||
					pProject->GetCurrentPlatform()->GetUniqueId() == macppc)
				{
					pEC->AddString("");
					pEC->AddString ( IDS_BATCH_BLD_NO_MECR );
				}
			}

			if (br == CProject::NoBuild) 
			{
				pEC->Reset() ;
				pEC->AddString (MsgText(str, IDS_BUILD_UPTODATE, (const char *) strName)) ;
			}
			else
			{
				TotalErrs = TotalErrs + errs;
				TotalWarns = TotalWarns + warns;
				
				pEC->AddString("");

				if (br == CProject::BuildCanceled)
				{
					pEC->AddString ( IDS_USERCANCELED );
					if (pConfigs->GetCount() > 1)
					{
						if ((!g_pAutomationState->DisplayUI()) || (MsgBox(Question, IDS_BUILD_BATCH_CONTINUE, MB_YESNO) == IDNO))
							bCancelled = TRUE;
						else
							g_Spawner.ReInitSpawn();
					}
				}
				else
				{
					pEC->AddString("\n");

					if( g_bHTMLLog ){
						CString strResults;
						strResults.LoadString(IDS_RESULTS);
						LogTrace(strResults);
					}
					pEC->AddString(MsgText(str, IDS_BUILD_COMPLETE, (const char *) strName, actualErrs, warns));
				}
			}
		}

			// If we are doing a batch build then reset the deferred state of mecr
		if (bt == CProject::BatchBuild)
		{
			VERIFY(pProject->SetIntProp(P_DeferredMecr, iDeferredMecr));
		}
		
		if (!bCancelled)
			pConfigs->RemoveHead();
	}

	// Delete the temporary CStringList created if we are just doing
	// a normal build
	if (bConfigAllocated)
	{
		pConfigs->RemoveAll();
		delete pConfigs;
	}


	DWORD dwEndTime = ::GetTickCount();
	DWORD dwElapsedTime = dwEndTime - dwStartTime;

	if ((g_bSpawnTime) && (buildType != TOB_Clean))
	{
		int nMinutes = dwElapsedTime / 60000;
		int nSeconds = (dwElapsedTime % 60000) / 1000;
		int nTenthsOfSecond = (dwElapsedTime % 1000) / 100;

 		CString strElapsedTime;
 		strElapsedTime.Format("Build Time %d:%2.2d.%d", nMinutes, nSeconds, nTenthsOfSecond);
		pEC->AddString(strElapsedTime);
	}

	theApp.NotifyPackages (PN_END_BUILD, (void *)bIsExternalTarget);


	g_Spawner.TermSpawn ();

#ifdef _BTLOG
	// Only log build info for successful builds and not source compiles
	if (bt != CProject::Compile && buildType != TOB_Clean && br == CProject::BuildComplete && g_bBuildLogging)
	{
		DWORD dwTargetSize = 0;
		CString strPlatform;
		
		// Get the total target file size
		POSITION pos = ConfigPcrs.GetHeadPosition();
 		while (pos != NULL && !bCancelled)
		{
 			ConfigurationRecord * pcr = (ConfigurationRecord*) ConfigPcrs.GetNext(pos);

			// Force the target level config. record, ie. the base
			pProject->ForceConfigActive((ConfigurationRecord *)pcr->m_pBaseRecord);

			CString strCurrentPlatform = *(pProject->GetProjType()->GetPlatformName());
			if (strCurrentPlatform.CompareNoCase(strPlatform) != 0)
			{
				if (strPlatform.IsEmpty())
					strPlatform = strCurrentPlatform;
				else
 					strPlatform = "Multi-platform";
			}

			CPath* pPath = pProject->GetTargetFileName();
			ASSERT(NULL!=pPath);

			pProject->ForceConfigActive();

			CString strPath = pPath->GetFullPath();
			HANDLE h = CreateFile(pPath->GetFullPath(), GENERIC_READ, 
								  FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 
								  FILE_ATTRIBUTE_NORMAL, NULL);
			if (h != INVALID_HANDLE_VALUE)
			{
				dwTargetSize += GetFileSize(h, NULL);
				CloseHandle(h);
			}
			delete pPath;
		}

		CString strBuildTime; 
	 	strBuildTime.Format("%d", dwElapsedTime);
		TransportBTInfo(strBuildTime, bt, buildType, pProject, dwTargetSize, strPlatform);
	}
#endif

#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "devbldd.dll", "DoTopLevelBuild()", letypeEnd, 0);
#endif

	delete pLog;

#ifdef PROF_BUILD_OVERHEAD
	StopCAPAll();
#endif

	return br == CProject::BuildComplete || br == CProject::NoBuild;
}

	
CSlob * CProjItem::GetContainerInSameConfig()
{
	CProjItem * pItem = (CProjItem *)GetContainer();
	if (pItem != (CSlob *)NULL)
	{
		// if we have a manual than our containe uses the same manual,
		// else it uses our current if it needs to

		ConfigurationRecord * pRec = (ConfigurationRecord *)NULL;

		// use the same manual config. if we have one
		if (m_pManualConfigRec != (ConfigurationRecord *)NULL)
			pRec = m_pManualConfigRec;

		// don't do anything if we don't need to
		else
		{
			ASSERT(GetActiveConfig());
			// ASSERT(pItem->GetActiveConfig());
			if (pItem->GetActiveConfig(TRUE)->m_pBaseRecord != GetActiveConfig()->m_pBaseRecord)
				pRec = m_pActiveConfig;
		}

		pItem->SetManualBagSearchConfig(pRec);
	}
	return pItem;
}

void CProjItem::SetCurrentConfigAsBase(COptionHandler * popthdlr)
{
	ConfigurationRecord * pRec = GetActiveConfig();
	ASSERT(pRec != (ConfigurationRecord *)NULL);

	while (popthdlr != (COptionHandler *)NULL)
	{
		UINT nMinProp, nMaxProp ;
		popthdlr->GetMinMaxOptProps (nMinProp, nMaxProp) ;
		pRec->BagCopy(CurrBag, BaseBag, nMinProp, nMaxProp);
		// get the base-handler
		popthdlr = popthdlr->GetBaseOptionHandler();
	}
}

void CProjItem::SetBaseConfigAsCurrent(COptionHandler * popthdlr)
{
	ConfigurationRecord * pRec = GetActiveConfig();
	ASSERT(pRec != (ConfigurationRecord *)NULL);

	while (popthdlr != (COptionHandler *)NULL)
	{
		UINT nMinProp, nMaxProp ;
		popthdlr->GetMinMaxOptProps (nMinProp, nMaxProp) ;
		pRec->BagCopy(BaseBag, CurrBag, nMinProp, nMaxProp);
		// get the base-handler
		popthdlr = popthdlr->GetBaseOptionHandler();
	}
}

///////////////////////////////////////////////////////////////////////////////
// GetPropBag
////////////////////////////////////////////////////////////////////////////////
int CProjItem::GetPropBagCount() const
{
	const CPtrArray * pCfgArray = GetConfigArray();
	return pCfgArray->GetSize();
}

CPropBag* CProjItem::GetPropBag(int nBag)
{
	// look for the *current* property bag?
	if (nBag == -1) /* get current */
	{
		// ASSERT(GetActiveConfig());
		return ((ConfigurationRecord *)GetActiveConfig(TRUE))->GetPropBag(m_idBagInUse);	// our prop bag for current active config
	}

	// get a particular property bag (using index)
	ConfigurationRecord *pcr;
	ASSERT(nBag >= 0);
	if (nBag > m_ConfigArray.GetUpperBound())
		return (CPropBag *)NULL ;

	pcr = (ConfigurationRecord *)m_ConfigArray[nBag];
	return pcr->GetPropBag(m_idBagInUse);
}

CPropBag * CProjItem::GetPropBag(const CString & strBagName)
{
	ConfigurationRecord * pcr = ConfigRecordFromConfigName(strBagName); 
	return pcr != (ConfigurationRecord *)NULL ? pcr->GetPropBag(m_idBagInUse) : (CPropBag *)NULL;
};
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::ConfigurationChanged(const ConfigurationRecord *pcr )
{
	POSITION pos;
#ifdef _DEBUG
	void * pv;
#endif
	BOOL retVal = FALSE; // return true if and only if "new" cr added
	CProjItem *	pProjItem;
	ConfigurationRecord * pcrNew;
	CString strType, strName;

	PCFG_TRACE ("%s at %p notfied of config change to base at %p (name: %s)\n",
	  GetRuntimeClass()->m_lpszClassName, this, pcr, ((CStringProp *) 
	  ((ConfigurationRecord *)pcr->m_pBaseRecord)->GetPropBag(CurrBag)->FindProp(P_ProjConfiguration))->m_strVal);

	ASSERT (pcr);
	ASSERT (pcr->m_pBaseRecord == pcr ); // pcr should be top level!

	// FUTURE (karlsi): Change subproject and warn if there's state if they don't
	// have a matching config.

	// This is where items other than projects find out that there's a new
	// config:  They're told to switch to a config they don't know about,
	// so they create it:
	if (!m_ConfigMap.Lookup((void *) pcr, (void *&) m_pActiveConfig))
	{
		strType = pcr->GetOriginalTypeName();
		strName = pcr->GetConfigurationName();
		pcrNew = ConfigRecordFromConfigName(strName, FALSE, FALSE);
		if ((pcrNew) && (pcrNew->GetOriginalTypeName()==strType))
		{
			// matched by name & projtype, so reuse this one
			m_pActiveConfig = pcrNew;
			VERIFY(m_ConfigMap.RemoveKey((void*)m_pActiveConfig->m_pBaseRecord)); // readded for new base below
			m_pActiveConfig->m_pBaseRecord = pcr->m_pBaseRecord;
		}
		else
		{
			m_pActiveConfig = new ConfigurationRecord (pcr, this);
			int x = m_ConfigArray.Add(m_pActiveConfig);
			ASSERT(((ConfigurationRecord *)m_ConfigArray[x])->GetConfigurationName()==pcr->GetConfigurationName());
			retVal = TRUE;
		}
		ASSERT(!m_ConfigMap.Lookup((void *)m_pActiveConfig->m_pBaseRecord, (void *&)pv));
		m_ConfigMap.SetAt((void *)m_pActiveConfig->m_pBaseRecord, m_pActiveConfig);
		ASSERT(m_ConfigMap.GetCount()==m_ConfigArray.GetSize());
	}
	ASSERT_VALID (m_pActiveConfig);

	// notify all of our children of this change
	// don't do this if we don't have a content list
	if (
		!GetContentList()
	   )
		return retVal;

	for (pos = GetHeadPosition(); pos != NULL; )
	{
		pProjItem = (CProjItem *)GetNext(pos);
		BOOL bChildAdded = pProjItem->ConfigurationChanged(pcr);
		if (retVal)	// FUTURE (karlsi): fix targdlgs so this ASSERT is always valid
		{	// if adding a new config record, should also be for children
			ASSERT(retVal==bChildAdded);
		}
	}
	return retVal;

}
///////////////////////////////////////////////////////////////////////////////
// make sure we have all of our configs matching the project
void CProjItem::CreateAllConfigRecords()
{
	CTargetItem *pTarget = GetTarget();
	CProject *pProject = GetProject();
	const CPtrArray * pCfgArray;
	BOOL fUseProjectConfig = FALSE;

	if (pTarget != NULL && pTarget != this && pProject != this)
	{
		pCfgArray = pTarget->GetConfigArray();
	}
	else if (pProject != NULL)
	{
		pCfgArray = pProject->GetConfigArray();
		fUseProjectConfig = TRUE;
	}

	if (pCfgArray != NULL)
	{
		int icfg, size = pCfgArray->GetSize();
		for (icfg = 0; icfg < size; icfg++)
		{
			ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(icfg);
			if (fUseProjectConfig || pcr->IsValid())
				(void)ConfigRecordFromBaseConfig((ConfigurationRecord *)pcr->m_pBaseRecord, TRUE);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
ConfigurationRecord * CProjItem::GetActiveConfig(BOOL bCreate /* = FALSE */)
{
	// return a forced configuration?
	if (m_pForcedConfig != (ConfigurationRecord *) NULL)
		return m_pForcedConfig;

	if (m_pManualConfigRec)
	{
		ConfigurationRecord * pRec;
		if (m_ConfigMap.Lookup( 
				(void  *) m_pManualConfigRec->m_pBaseRecord,
				(void *&) pRec
				))
			return pRec;
		
		// ASSERT(0); should never get here, but if so, ignore m_pManualConfigRec
	}

	// do we have a matching config. with our owner project?
	// (compare base records)
	CProjItem * pItem = GetProject();
	
	// Is this item in a project, if not then it doesn't have
	// an active config
	if (pItem == NULL)
		return NULL;

	if (pItem != this)
	{
		ConfigurationRecord * pcrItem = pItem->GetActiveConfig(bCreate);
		if (!m_pActiveConfig || pcrItem != m_pActiveConfig->m_pBaseRecord)
		{
			if (pcrItem != NULL)
			{
				// get a config. record, create if needs be
				m_pActiveConfig = ConfigRecordFromBaseConfig(pcrItem, bCreate);
				if (bCreate)
				{
					ASSERT(m_pActiveConfig);
					ASSERT_VALID(m_pActiveConfig);
				}
			} 
			else
			{
				m_pActiveConfig = NULL;
			}
		}
	}

	// return the active configuration...
	return m_pActiveConfig;
}
///////////////////////////////////////////////////////////////////////////////
ConfigurationRecord* CProjItem::ConfigRecordFromBaseConfig
(
	ConfigurationRecord *	pcrBase,
	BOOL					fCreate /* = FALSE */
)
{
	ConfigurationRecord * pcr;

	// not found matching?
	if (!m_ConfigMap.Lookup((void *)pcrBase, (void *&)pcr))
	{
		// create?
		if (fCreate)
		{
			CString strType = pcrBase->GetOriginalTypeName();
			CString strName = pcrBase->GetConfigurationName();

			pcr = ConfigRecordFromConfigName(strName);
			if (pcr && pcr->GetOriginalTypeName() == strType)
			{
				// matched by name & projtype, so reuse this one
				VERIFY(m_ConfigMap.RemoveKey((void*)pcr->m_pBaseRecord)); // readded for new base below
				pcr->m_pBaseRecord = pcrBase;
			}
			else
			{

				// Make sure we are not creating a ConfigurationRecord on 
				// these objects which does not belong in the target.
				// Currently there are still cases where we hit this assert,
				// so it is not turned on by default.
				// You can turn it on if you need to check for bogus configs. 
#if 0 
				if (IsKindOf(RUNTIME_CLASS(CFileItem)) ||
					IsKindOf(RUNTIME_CLASS(CDependencyFile)) ||
					IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
				{
					CTargetItem *pTarget = GetTarget();
					ASSERT(pTarget);
					const CPtrArray * pArrayCfg = pTarget->GetConfigArray();
					int j ;
					ConfigurationRecord * pcr ;

					for ( j = 0 ; j < pArrayCfg->GetSize() ; j++)
					{
						pcr = (ConfigurationRecord *)pArrayCfg->GetAt(j);
						if (pcrBase->m_pBaseRecord == pcr->m_pBaseRecord)
							break;
					}

					if ( j == pArrayCfg->GetSize() || !pcr->IsValid())
						ASSERT(FALSE);
				}
#endif // 0
					
				// not  matched, so create a new one
				pcr = new ConfigurationRecord(pcrBase, this);
				int ipcr = m_ConfigArray.Add(pcr);
				ASSERT(((ConfigurationRecord *)m_ConfigArray[ipcr])->GetConfigurationName() == pcrBase->GetConfigurationName());
			}

			// add this into our config. map (it's already in our array)
#ifdef _DEBUG
			void * pv;
#endif // _DEBUG
			ASSERT(!m_ConfigMap.Lookup((void *)pcr->m_pBaseRecord, (void *&)pv));
			m_ConfigMap.SetAt((void *)pcr->m_pBaseRecord, pcr);

			ASSERT(m_ConfigMap.GetCount() == m_ConfigArray.GetSize());
		}
		else
			pcr = (ConfigurationRecord *)NULL;
	}

	return pcr;
}
///////////////////////////////////////////////////////////////////////////////
ConfigurationRecord *CProjItem::ConfigRecordFromConfigName
(
	const TCHAR *	pszConfig,
	BOOL			fCreate /* = FALSE */,
	BOOL fMatchExact /* = TRUE */
)
{
	CString strConfigToMatch, strConfig;
	TCHAR * pszChar;
	ConfigurationRecord * pcrMatch = NULL;
	if (!fMatchExact)
	{
		TCHAR * pszChar = _tcsstr(pszConfig, _T(" - "));
		if (pszChar != NULL)
		{
			strConfigToMatch = pszChar + 3;
		}
		else
		{
			fMatchExact = TRUE;
		}
	}
	int size = GetPropBagCount();
	for (int i = 0; i < size; i++)
	{
		ConfigurationRecord * pcr = (ConfigurationRecord *)m_ConfigArray[i];
		strConfig = pcr->GetConfigurationName();
		if (strConfig.CompareNoCase(pszConfig) == 0)
			return pcr;

		if ((!fMatchExact) && (pcrMatch == NULL))
		{
			pszChar = _tcsstr(strConfig, _T(" - "));
			if ((pszChar != NULL) && (strConfigToMatch.CompareNoCase(pszChar + 3) == 0))
			{
				// found possible match
				pcrMatch = pcr;
			}
		}
	}

	if (pcrMatch != NULL)
		return pcrMatch;

	// not found, so create?
	if (fCreate)
	{
		// must have one in project, so create one based on this project's config.
		return ConfigRecordFromBaseConfig(GetProject()->ConfigRecordFromConfigName(pszConfig), TRUE);
	}

	return NULL;
}

CProjType * CProjItem::GetProjType ()
{
	CProject * pProject = GetProject();
	ASSERT(pProject != (CProject *)NULL);

	if (pProject->m_bProjIsExe)
		return (CProjType *)NULL;
	
	ConfigurationRecord * pcr = GetActiveConfig();
	if (pcr == (ConfigurationRecord *)NULL)
		return (CProjType *)NULL;	// no current configuration -> no project type!

	ASSERT(pcr->m_pBaseRecord);

	CStringProp * pProp = (CStringProp *) ((ConfigurationRecord *)pcr->m_pBaseRecord)
						 ->GetPropBag(CurrBag)->FindProp (P_ProjOriginalType);
	if (pProp==NULL)
	{
		return NULL;
		// ASSERT(0);
	}

	ASSERT(pProp->m_nType == string); 

	// ignore return
	CProjType * pprojtype;
	if (!g_prjcompmgr.LookupProjTypeByName(pProp->m_strVal, pprojtype))
		return (CProjType *)NULL;

	return pprojtype;
}
///////////////////////////////////////////////////////////////////////////////
void CProjItem::FlattenSubtree (CObList &rObList, int fo) 
{
 	BOOL fAddItem = FALSE, fAddContent = FALSE;

	FlattenQuery(fo, fAddContent, fAddItem);

	// If we have items contained then flatten each of these as well
	if (fAddContent && GetContentList())
	{
		POSITION pos;
 		for (pos = GetHeadPosition(); pos != (POSITION)NULL;)
		{
			CProjItem * pProjItem = (CProjItem *) GetNext (pos);
			if (!(fo & flt_ExpandSubprojects) && pProjItem->IsKindOf(RUNTIME_CLASS(CProject)))
				continue;

			pProjItem->FlattenSubtree(rObList, fo);
		}
	}

	if ((fo & flt_OnlyTargRefs) && !IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return;	// only include target references!
					
	// Add the item if we need to
	if (fAddItem)
		rObList.AddTail(this);
}

void CProjItem::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	fAddContent = FALSE;
	fAddItem = FALSE;
}

///////////////////////////////////////////////////////////////////////////////
CFileRegistry* CProjItem::GetRegistry()
{
	// we'll use our target's registry,
	// and if we don't have one (ie. external makefiles)
	// we'll use the global registry
	CTargetItem * pTarget = GetTarget();
	if (pTarget == NULL)
		return &g_FileRegistry;
	else
		return pTarget->GetRegistry();
}
///////////////////////////////////////////////////////////////////////////////
// CanContain - our internal (within VPROJ) CanAdd method
 
BOOL CProjItem::CanContain(CSlob* pSlob)
{
	// Must override
	ASSERT(FALSE);
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
GPT CProjItem::GetIntProp(UINT idProp, int& val)
{
//#pragma message ("ALERT! : projitem.cpp : Including P_QA_ProjItemType hook for QA...")
	// return to QA what the type of this project item is
	if (idProp == P_QA_ProjItemType)
	{
		if (IsKindOf(RUNTIME_CLASS(CProject)))
			val = QA_TypeIs_Target;
		else if (IsKindOf(RUNTIME_CLASS(CProjGroup)))
			val = QA_TypeIs_Group;
		else if (IsKindOf(RUNTIME_CLASS(CFileItem)))
			val = QA_TypeIs_File;
		else if (IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
			val = QA_TypeIs_DepGroup;
		else if (IsKindOf(RUNTIME_CLASS(CDependencyFile)))
			val = QA_TypeIs_DepFile;
		else ASSERT(FALSE);	// unrecognised type!

		return valid;	// success
	}

	GPT gpt;
	// want to handle special case here:
	if (idProp == P_ItemOptState || idProp == P_ItemOptChanged)
	{
		if (IsKindOf (RUNTIME_CLASS (CProject)) || IsKindOf (RUNTIME_CLASS (CFileItem)) || 
			IsKindOf (RUNTIME_CLASS (CProjGroup)) || IsKindOf (RUNTIME_CLASS (CTargetItem)))
		{
			gpt = CSlob::GetIntProp (P_ItemOptState, val);
			if (gpt == invalid)
				val = 1;
			else 
			{
				if (idProp == P_ItemOptState)
					val = val & 0x7fffffff; // masking off the highest bit
				else
					val = (val & 0x80000000) ? 1 : 0; // get the highest bit
			}
			return valid;
		}
		else
			return invalid;
	}

	if ((idProp == P_ItemExcludedFromScan) || (idProp == P_IPkgProject))
	{
		// not per config and not valid by default
		// override to do anything special
		val = FALSE;
		return invalid;
	}

	if ((idProp == P_Proj_PerConfigDeps) && (GetProject() != NULL))
	{
		val = GetProject()->m_bProj_PerConfigDeps;
		return valid;
	}

#if 0
	// fake prop that is actually maintained by the Scc Manager
	if (idProp == P_SccStatus)
	{
		const CPath * pPath = GetFilePath();
		ASSERT(pPath);
		LPSOURCECONTROL pSccManager;
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
		g_pSccManager->GetStatus(&val, (LPCTSTR)*pPath);	
		pSccManager->Release();
		return (val!=-1) ? valid : invalid;
	}
#endif

	// get the option handler
	COptionHandler * popthdlr = g_prjcompmgr.FindOptionHandler(idProp);

	if (popthdlr != (COptionHandler *)NULL)
	{
		// if we have an option handler for this prop we must be an option
		// check it's dependencies
		if (!(m_optbeh & OBNoDepCheck))
		{
			BOOL fCheckDepOK;

			// the DepCheck needs to view the whole 'context' ie.
			// the tool options with inheritance
			// prevent the DepCheck() recursing
			OptBehaviour optbehOld = m_optbeh;
			m_optbeh |= OBInherit | OBShowDefault | OBNoDepCheck;
		
			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);
			fCheckDepOK = popthdlr->CheckDepOK(idProp);
			popthdlr->ResetSlob();

			m_optbeh = optbehOld;

			// is this an invalid option?
			if (!fCheckDepOK)	return invalid;
		}
	}

	// usual CSlob property behaviour
	// ask the base-class to actual find the prop.
	gpt = CSlob::GetIntProp(idProp, val);

	// do we want to supply this ourselves?
	if (gpt == invalid && (idProp == P_ItemExcludedFromBuild))
	{
		val = FALSE; gpt = valid;	// valid and FALSE by default
	}

	// does this property exist for this CSlob?
	if (gpt == invalid)
	{
		// are we not at the root and inheriting?
		if (m_optbeh & OBInherit)
		{
			// automatically detect if we need to do a manual config?
			// we don't need to if we already have a manual config rec. to use
			CProjItem * pContainer = (CProjItem *) GetContainerInSameConfig();
			while (pContainer != (CSlob *)NULL)
			{
				// yes, so let's search in our container CSlob if we have one
				OptBehaviour optbehOld = pContainer->m_optbeh;
 				int idOldBag = pContainer->UsePropertyBag(UsePropertyBag());

				// make them use our option behaviour, but return any context sensitive
				// information such as defaults .. we'll do the inheritance chaining here!
				pContainer->m_optbeh = (m_optbeh | OBBadContext | OBNoDepCheck) & ~OBInherit;

				GPT gptContainer = pContainer->GetIntProp(idProp, val);

				pContainer->m_optbeh = optbehOld;
 	   			(void) pContainer->UsePropertyBag(idOldBag);

				if (gptContainer == valid)
				{
					pContainer->ResetContainerConfig();
					return valid;
				}

				// chain our config.
				// look in the next container
				CProjItem * pNextContainer = (CProjItem *) pContainer->GetContainerInSameConfig();
				pContainer->ResetContainerConfig();
				pContainer = pNextContainer;
			}
		}

		//
		// *** base-case ***
		//
		// right context?
		if (!(m_optbeh & OBBadContext))
		{
			if (popthdlr != (COptionHandler *)NULL)
			{
				// make sure the option handling refers to us!
				popthdlr->SetSlob(this);

				// we need to find this in our default property map
				// ask our helper which map it is in

				// always show fake props, if inheriting
				if (((m_optbeh & OBInherit) && popthdlr->IsFakeProp(idProp)) ||
					(m_optbeh & OBShowDefault))
				{
					OptBehaviour optbehOld = m_optbeh;

					m_optbeh |= OBShowDefault;
					gpt = popthdlr->GetDefIntProp(idProp, val);
					m_optbeh = optbehOld;
				}
				
				// reset the option handler CSlob
				popthdlr->ResetSlob();
			}
		}
	}

 	// mustn't be OBAnti, the option handler takes care of this
	ASSERT((m_optbeh & OBAnti) == 0);

	return gpt;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SetIntProp(UINT idProp, int val)
{
	BOOL fOk;

	if ((idProp == P_Proj_PerConfigDeps) && (GetProject() != NULL))
	{
		GetProject()->m_bProj_PerConfigDeps = val;
	}

#if 0
	// fake prop that is actually maintained by the Scc Manager
	if (idProp == P_SccStatus)
	{
		const CPath * pPath = GetFilePath();
		ASSERT(pPath);
		LPSOURCECONTROL pSccManager;
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
		VERIFY(SUCCEEDED(pSccManager->SetStatus((LPCTSTR)*pPath, val)));	
		pSccManager->Release();
		return valid;
	}
#endif

	// mustn't be OBAnti, the option handler takes care of this for integer props
	ASSERT((m_optbeh & OBAnti) == 0);

	// need to do special handling here
	int valTemp = 0;
	GPT gpt;
	if (idProp == P_ItemOptState)
	{
		gpt = GetIntProp (P_ItemOptChanged, valTemp);
		if (gpt == valid)
		{
			val = valTemp ? 0x80000000 | val : val; // set the high bit if valTemp is set
			fOk = CSlob::SetIntProp(P_ItemOptState, val);
		}
		else
		{
			ASSERT (FALSE);
			return FALSE;
		}
	}
	else if (idProp == P_ItemOptChanged)
	{
		gpt = GetIntProp (P_ItemOptState, valTemp);
		if (gpt == valid)
		{
			val = val ? 0x80000000 | valTemp : valTemp;
			fOk = CSlob::SetIntProp(P_ItemOptState, val);
		}
		else
		{
			ASSERT (FALSE);
			return FALSE;
		}
	}
	else
	{
		fOk = CSlob::SetIntProp(idProp, val);
	}

	if (fOk && idProp == P_ItemExcludedFromBuild)
	{
		// FUTURE: Do THIS?
		// Finally, we want to mark the item's project to suggest
		// a relink.  Do this by specifying the last build flags
		// string to be empty:
		CProject * pProject = GetProject();
		ASSERT(pProject != (CProject *)NULL);

		// broadcast to our option handlers
		COptionHandler * popthdlr;
		g_prjcompmgr.InitOptHdlrEnum();
		while (g_prjcompmgr.NextOptHdlr(popthdlr))
		{
			// inform of this option change
			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);
			popthdlr->OnOptionIntPropChange(P_ItemExcludedFromBuild, val);

			// reset the option handler CSlob
			popthdlr->ResetSlob();
		}
	}

	// get the option handler for the prop
	COptionHandler * popthdlr;
	if (fOk && ((popthdlr = g_prjcompmgr.FindOptionHandler(idProp)) != (COptionHandler *)NULL))
	{
		// inform of this option change
		// make sure the option handling refers to us!
		popthdlr->SetSlob(this);
		popthdlr->OnOptionIntPropChange(idProp, val);

		// reset the option handler CSlob
		popthdlr->ResetSlob();
	}

	return fOk;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProjItem::SetStrProp(UINT idProp, const CString & str)
{
	// get the option handler for this prop
	COptionHandler * popthdlr = g_prjcompmgr.FindOptionHandler(idProp);

	BOOL fIsListStrProp = (popthdlr != (COptionHandler *)NULL) && popthdlr->IsListStrProp(idProp);

	// only string lists and unk. opt. hdlr strings are available as anti-options
	ASSERT ((m_optbeh & OBAnti) == 0 || fIsListStrProp || popthdlr->IsKindOf(RUNTIME_CLASS(COptHdlrUnknown)));

	if (popthdlr != (COptionHandler *)NULL)
	{
		// do we to do a type conversion ourselves?
		// ie. does the CSlob *not* support this tool option type?
		if (popthdlr->NeedsSubtypeConversion(idProp))
		{	
			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);

			int nVal;

			BOOL fRet;

			// is this the empty string? if so we want
			// to nuke it from our property bag
			if (str.IsEmpty())
			{
				CPropBag * pPropBag = GetPropBag();
				ASSERT(pPropBag != (CPropBag *)NULL);

				pPropBag->RemoveProp(idProp);
				fRet = TRUE;
			}
			else if (!popthdlr->ConvertFromStr(idProp, str, nVal))
			{
				// no change, inform dependants of this
				InformDependants(idProp);
				fRet = FALSE;
			}
			else
				fRet = SetIntProp(idProp, nVal);

			// reset option handler CSlob
			popthdlr->ResetSlob();
			
			return fRet;
		}
 	}

	// setting the output directories?
	if (idProp == P_OutDirs_Target || idProp == P_OutDirs_Intermediate)
	{
		// if we're setting the output dirs props to an empty string, remove
		// the prop if it exists, only if we're a child that way the removal
		// will reset the prop to inherit from the parent
		if (m_pContainer != (CSlob *)NULL && str.IsEmpty())
		{
			GetPropBag()->RemovePropAndInform(idProp, this);
			return TRUE; 
		}
	}

	BOOL fOk = FALSE;

	// do we have a list of strings for this property?
	if (fIsListStrProp)
	{
		// figure add and subtract string props
		popthdlr->SetListStrProp(this, idProp, (CString &)str, m_optbeh & OBInherit, m_optbeh & OBAnti);
		fOk = TRUE;
	}
	else
	{
		fOk = CSlob::SetStrProp(idProp, str);
	}

	// inform of this option change
	if (fOk && popthdlr != (COptionHandler *)NULL)
	{
		// make sure the option handling refers to us!
		popthdlr->SetSlob(this);
		popthdlr->OnOptionStrPropChange(idProp, str);

		// reset option handler CSlob
		popthdlr->ResetSlob();
	}

	return fOk;
}
///////////////////////////////////////////////////////////////////////////////
GPT CProjItem::GetStrProp(UINT idProp, CString& val)
{
	// fake prop that is actually maintained by the Scc Manager
	if (idProp == P_SccStatus)
	{
		// translate to string
		LPSOURCECONTROLSTATUS pInterface;
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControlStatus, (LPVOID FAR*)&pInterface)));
		BOOL bIsSccInstalled = (pInterface->IsSccInstalled() == S_OK);
		pInterface->Release();
		LPSOURCECONTROL pSccManager;
		VERIFY(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (LPVOID FAR*)&pSccManager)));
		GPT gpt = (bIsSccInstalled && (GetFilePath()!=NULL) && (SUCCEEDED(pSccManager->GetStatusText(*GetFilePath(), val)))) ? valid : invalid;
		pSccManager->Release();
		return gpt;
	}

	if (idProp == P_Title) // alias
		return GetStrProp(P_ProjItemName, val);

	// get the option handler for this prop
	COptionHandler * popthdlr = g_prjcompmgr.FindOptionHandler(idProp);

	// are we a string list prop?
	BOOL fIsListStrProp = (popthdlr != (COptionHandler *)NULL) && popthdlr->IsListStrProp(idProp);

	// only string lists and unk. opt. hdlr strings are available as anti-options
	ASSERT ((m_optbeh & OBAnti) == 0 || fIsListStrProp || popthdlr->IsKindOf(RUNTIME_CLASS(COptHdlrUnknown)));
	
	if (popthdlr != (COptionHandler *)NULL)
	{
		// do we to do a type conversion ourselves?
		// ie. does the CSlob *not* support this tool option type?
		if (popthdlr->NeedsSubtypeConversion(idProp))
		{	
			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);
			GPT gptRet;

			// is this a valid prop?
			int nVal;
			if (GetIntProp(idProp, nVal) != valid)
			{
				gptRet = invalid;	
			}
			else
			{
				// is this a default, ie. not in any bag?
				OptBehaviour optbehOld = m_optbeh;
				m_optbeh &= ~OBShowDefault;
				GPT gpt = GetIntProp(idProp, nVal);
				m_optbeh = optbehOld;

				if (gpt != valid)
				{
					val = "";	// for defaults return the empty string
					gptRet = valid;
				}
				else
					gptRet = popthdlr->ConvertToStr(idProp, nVal, val) ? valid : invalid;		
			}

			// reset the option handler CSlob
			popthdlr->ResetSlob();

			return gptRet;
		}

	 	// if we have a default option map this must be an option
		// check it's dependencies
		if (!(m_optbeh & OBNoDepCheck))
		{
			BOOL fCheckDepOK;

			// the DepCheck needs to view the whole 'context' ie.
			// the tool options with inheritance
			// prevent the DepCheck() recursing
			OptBehaviour optbehOld = m_optbeh;
			m_optbeh |= OBInherit | OBShowDefault | OBNoDepCheck;

			// make sure the option handling refers to us!
			popthdlr->SetSlob(this);
			fCheckDepOK = popthdlr->CheckDepOK(idProp);
			popthdlr->ResetSlob();

			m_optbeh = optbehOld;

			// is this an invalid option?
			if (!fCheckDepOK)	return invalid;
		}
	}

  	GPT gpt = invalid;	// default is the prop. find is invalid

	// do we have a list of strings for this property?
	// if so then we'll want to show this list
	if (fIsListStrProp && !m_fGettingListStr)
	{
		SUBTYPE st = popthdlr->GetDefOptionSubType(idProp);

		// join our directory string lists with ';'
		TCHAR chJoin = st == dirST ? _T(';') : _T(',');

		// show add and/or subtract props combined for this
		m_fGettingListStr = TRUE;
		gpt = popthdlr->GetListStrProp(this, idProp, val, m_optbeh & OBInherit, m_optbeh & OBAnti, chJoin) ? valid : invalid;
		m_fGettingListStr = FALSE;
	}
	else
	{
		// usual CSlob property behaviour
		// ask the base-class to actual find the prop.
		gpt = CSlob::GetStrProp(idProp, val);
	}

	// does this property exist for this CSlob?
	if (gpt == invalid)
	{
		// fake prop for custom build description .. <- no inheritance!
		if ((m_optbeh & OBShowDefault) && idProp == P_CustomDescription)
		{
			VERIFY(val.LoadString(IDS_CUSTOMBUILD_DESC));
			return valid;
		}

		// are we not at the root and inheriting?
		if (m_optbeh & OBInherit)
		{
			// automatically detect if we need to do a manual config?
			// we don't need to if we already have a manual config rec. to use
			CProjItem * pContainer = (CProjItem *) GetContainerInSameConfig();
			while (pContainer != (CSlob *)NULL)
			{
				// yes, so let's search in our container CSlob if we have one
				OptBehaviour optbehOld = pContainer->m_optbeh;
				int idOldBag = pContainer->UsePropertyBag(UsePropertyBag());

				// make them use our option behaviour, but return any context sensitive
				// information such as defaults .. we'll do the inheritance chaining here!
				pContainer->m_optbeh = (m_optbeh | OBBadContext | OBNoDepCheck) & ~OBInherit;

				GPT gptContainer = pContainer->GetStrProp(idProp, val);

				pContainer->m_optbeh = optbehOld;
   				(void) pContainer->UsePropertyBag(idOldBag);

				if (gptContainer == valid)
				{
					pContainer->ResetContainerConfig();
					return valid;
				}

				// chain our config.
				// look in the next container
				CProjItem * pNextContainer = (CProjItem *) pContainer->GetContainerInSameConfig();
				pContainer->ResetContainerConfig();
				pContainer = pNextContainer;
			}
		}

		//
		// *** base-case ***
		//
		// right context?
		if (!(m_optbeh & OBBadContext))
		{
			if (popthdlr != (COptionHandler *)NULL)
			{
				// make sure the option handling refers to us!
				popthdlr->SetSlob(this);

				// we need to find this in our default property map
				// ask our helper which map it is in

				// always show fake props, if inheriting
				if (((m_optbeh & OBInherit) && popthdlr->IsFakeProp(idProp)) ||
					(m_optbeh & OBShowDefault))
				{
					OptBehaviour optbehOld = m_optbeh;

					m_optbeh |= OBShowDefault;
					gpt = popthdlr->GetDefStrProp(idProp, val);
					m_optbeh = optbehOld;
				}

				// reset the option handler CSlob
				popthdlr->ResetSlob();
			}
			// show the defaults for non-tool option props?
			else if (m_optbeh & OBShowDefault)
			{
				// only have target directory for project
				// don't have intermediate directories for groups
				if (idProp == P_OutDirs_Target || idProp == P_OutDirs_Intermediate)
				{
					val = ""; // default is nothing for the int/trg directories
					gpt = valid;
				}
			}
		}
	}

	return gpt;
}

void CProjItem::SetOwnerProject(CProject * pProject, CTargetItem * pTarget)
{
	m_pOwnerProject = pProject;
	m_pOwnerTarget = pTarget;
	
	// repeat for all children*
	if (GetContentList())
	{
		POSITION pos;
	 	for (pos=GetHeadPosition(); pos!=NULL;)
	  	{
			// Any contained slobs should also be items:
			((CProjItem *)GetNext(pos))->SetOwnerProject(pProject, pTarget);
		}
	}
}

void CProjItem::IsolateFromProject()
{
	// update each config record
	UINT nIndex, nSize = GetPropBagCount();

	// copying into a non-projitem, so remove any links to Project
	for (nIndex = 0; nIndex < nSize; nIndex++)
	{
		// copy important pieces from project base record
		ConfigurationRecord * pcr = (ConfigurationRecord *)m_ConfigArray[nIndex];
		ForceConfigActive(pcr);

		theUndoSlob.Pause();	// don't record SetStrProp within SetSlopProp
		SetStrProp(P_ProjConfiguration,	pcr->m_pBaseRecord->GetConfigurationName());
		SetStrProp(P_ProjOriginalType, pcr->m_pBaseRecord->GetOriginalTypeName());
		theUndoSlob.Resume();
		
		// now set ourselves as our own Base record
		VERIFY(m_ConfigMap.RemoveKey((void*)pcr->m_pBaseRecord));
		pcr->m_pBaseRecord = pcr;
		m_ConfigMap.SetAt((void *)pcr->m_pBaseRecord, (void *)pcr);

		// reset config.
		ForceConfigActive();
	}

	// repeat for all children*
	if (GetContentList())
	{
		POSITION pos;
	 	for (pos=GetHeadPosition(); pos!=NULL;)
	  	{
			// Any contained slobs should also be items:
			((CProjItem *)GetNext(pos))->IsolateFromProject();
		}
	}
}

BOOL CProjItem::SetSlobProp(UINT idProp, CSlob * val)
{
	// only interested in container property changes
	if (idProp != P_Container)
		// pass on to the base-class
		return CSlob::SetSlobProp(idProp, val);

	// old container?
	CSlob * pOldContainer = m_pContainer; 

	// REVIEW: this currently happens during UNDO.  Bogus Undo record
	// ASSERT(pOldContainer != val);
	if (pOldContainer == val)
		return TRUE; // nothing to do

	// from a project?
	BOOL fFromPrj = m_pContainer && m_pContainer->IsKindOf(RUNTIME_CLASS(CProjItem)) && (((CProjItem *)m_pContainer)->GetProject() != NULL);

	// into a project?
	BOOL fToPrj = val && val->IsKindOf(RUNTIME_CLASS(CProjItem));

	BOOL fPrjChanged = FALSE;
	if (fFromPrj && fToPrj)
	{
		fPrjChanged = (((CProjItem *)val)->GetProject() != ((CProjItem *)m_pContainer)->GetProject());
	}
	// pre-move item
	if (!PreMoveItem(val, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	// do the 'containment' part of the move
	if (!MoveItem(val, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	// pos-move item, only call if not deleted!
	// ie. not deleted if moving to another container or
	// we're recording if, and hence moving into the undo slob.
	if (CouldBeContainer(val) &&
		!PostMoveItem(val, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
const CString CProjItem::EndOfBagsRecord = "\x08\x14\x53\x53\x42\x52"; // :-)

BOOL CProjItem::SerializeProps ( CArchive &ar )
{
	PFILE_TRACE ("SerializeProps for a %s at %p\n", 
							GetRuntimeClass()->m_lpszClassName, this );
	SerializePropMap(ar);

	// Now write info in the property bags:
	if (ar.IsStoring())
	{
		ConfigurationRecord *pcr;
		int i;
		int size = GetPropBagCount();
		for (i=0; i < size; i++)
		{
			pcr = (ConfigurationRecord *) m_ConfigArray[i];
			if (pcr->GetPropBag(CurrBag)->GetPropCount () == 0 ) continue;
			ar << pcr->GetConfigurationName ();
			pcr->GetPropBag(CurrBag)->Serialize (ar, this);
		}
		ar << EndOfBagsRecord;
	}
	else
	{
		CString str;
		CPropBag *pBag, DummyBag;
		while (1)
		{
			ar >> str;
			if (str == EndOfBagsRecord)
				break;

			pBag = GetPropBag(str);
			if (NULL==pBag&&IsKindOf(RUNTIME_CLASS(CProject)))
			{
				//
				// PropBag for this item was not found for current project so enumerate
				// thouugh other projects to see if appropriate PropBag can be found.
				//
				CProject* pProject = NULL;
				POSITION pos = CProject::m_lstProjects.GetHeadPosition();  // use our own private pos pointer
				while (pos != NULL)
				{
					pProject = (CProject *)CProject::m_lstProjects.GetNext(pos);

					// Already checked g_pActiveProject
					if (pProject==g_pActiveProject)
						continue;

					pBag = pProject->GetPropBag(str);
					if (NULL!=pBag)
						break;
				}

			}
			if (pBag)
				pBag->Serialize ( ar, this );
			else
			{
				// No matching config, but we still have to 
				// move through the archive if we want to keep reading:
            	DummyBag.Serialize(ar, this);
				DummyBag.Empty();
			}
		}
	}

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
//
//	Override CSlob's serialize function to save only private properties:

BOOL CProjItem::SerializePropMapFilter(int nProp)
{
	return ::IsPropPrivate (nProp);
}

///////////////////////////////////////////////////////////////////////////////
// Return a container-less, symbol-less, clone of 'this'
CSlob* CProjItem::Clone()
{
	CSlob * pClone = CSlob::Clone(); // call base class to creat clone
	ASSERT(pClone->IsKindOf (RUNTIME_CLASS (CProjItem)));

	((CProjItem*)pClone)->SetFile(GetFilePath());

	if (GetProject() != NULL)
		((CProjItem *)pClone)->IsolateFromProject();

	return pClone;
}

///////////////////////////////////////////////////////////////////////////////
void CProjItem::CopyProps(CSlob * pClone)
{
	// set up the configs to match that of 'this'

	// do we need to bother?
	if (pClone->GetPropBagCount() == 0)
	{
		ASSERT(pClone->IsKindOf(RUNTIME_CLASS(CProjItem)));
		((CProjItem *)pClone)->CloneConfigs(this);
	}

	// now ask the base-class to actually copy the prop maps
	// and these newly created prop bags
	CSlob::CopyProps(pClone);

	// if it is a projitem, then we want to copy 
	// the default prop bags as well
	if (pClone->IsKindOf(RUNTIME_CLASS (CProjItem)))
	{
		CopyDefaultPropBags((CProjItem *)pClone);
	}
}

////////////////////////////////////////////////////////////////////////////////
void CProjItem::CopyDefaultPropBags(CProjItem * pItemClone)
{
	int nBags = GetPropBagCount();
	int idOldBag = UsePropertyBag(BaseBag);
	int idOldCloneBag = pItemClone->UsePropertyBag(BaseBag);

	for (int i = 0 ; i < nBags ; i++)
	{
		CPropBag * pBag = GetPropBag(i);
		ASSERT(pBag != (CPropBag *)NULL);

		CPropBag * pCloneBag = pItemClone->GetPropBag(i);
		ASSERT(pCloneBag != (CPropBag *)NULL);
		pCloneBag->Clone(pItemClone, pBag);
	}

	(void) pItemClone->UsePropertyBag(idOldCloneBag);
	(void) UsePropertyBag(idOldBag);
}

///////////////////////////////////////////////////////////////////////////////
void CProjItem::CloneConfigs(const CProjItem * pItem)
{
//	We have moved into a new project tree and need to adopt its configurations
//	We'll enumerate throught the new parents configurations and create new
//	configs for any we don't have, and delete any configurations that the 
//	parent doesn't support.
//
//	We say one our configurations matches a parent configuration if its based
//	on the same project type and has the same name.
//
//	In the special case that we have no configurations, just blindly copy the
//	parent's:

	if (GetPropBagCount() == 0)
	{
		UINT nSize = pItem->GetPropBagCount();

		// create the new configuration records
		for (UINT nIndex = 0; nIndex < nSize; nIndex++)
		{
			const ConfigurationRecord * pcr = (ConfigurationRecord *) pItem->m_ConfigArray[nIndex];
			ASSERT_VALID(pcr);
			ASSERT_VALID(pcr->m_pBaseRecord);

			VERIFY(ConfigurationChanged(pcr->m_pBaseRecord));

			// validate newly-created CR
			pcr = (ConfigurationRecord *)m_ConfigArray[nIndex]; 
			ASSERT_VALID(pcr);
			ASSERT_VALID(pcr->m_pBaseRecord);													
		}
		ASSERT(GetPropBagCount()==pItem->GetPropBagCount()); // make sure they all got created

		// Finally, make sure we have the same active config:
		if (pItem->m_pActiveConfig)	// May be null during desrialize
		{		
			VERIFY(!ConfigurationChanged (pItem->m_pActiveConfig->m_pBaseRecord));
			ASSERT_VALID (m_pActiveConfig);
		}
		else
		{
			m_pActiveConfig = NULL; // don't leave as bogus value
		}
	}
	else
	{
		// if we got here we must be undo/redo'ing, dragging/dropping or cloning
		// if (!theUndoSlob.InUndoRedo())
		{
			// Configuration Matching. This is only used by cut/paste & drag/drop
			
			// For drag and drop the configurations should be identical
			// so we check this here!
			// However, for clipboard cut/paste,
			// the configurations will not necessarily match identically
			// and we will have to be somewhat cleverer than we already are. 

			int nIndex, nSize = pItem->GetPropBagCount();
			const ConfigurationRecord *pcr;

			for (nIndex = 0; nIndex < nSize; nIndex++)
			{
				pcr = (const ConfigurationRecord*)pItem->m_ConfigArray[nIndex];
				ASSERT_VALID (pcr);
				ASSERT_VALID (pcr->m_pBaseRecord);

				// look for matching config
				if (ConfigurationChanged(pcr->m_pBaseRecord))
				{
					// FUTURE: try for partial match
					// Last cr in m_ConfigArray is new
					// try to initialize based on projtype
				}
			}

			// Delete any unreferenced configs and reorder, if necessary
			FixConfigs(pItem);
			
			// Finally, make sure we have the same active config:
			if (pItem->m_pActiveConfig)	// May be null during desrialize
			{
				VERIFY(!ConfigurationChanged (pItem->m_pActiveConfig->m_pBaseRecord));
				ASSERT_VALID (m_pActiveConfig);
			}
  		}
	}
	ASSERT(GetPropBagCount()==pItem->GetPropBagCount());
}

///////////////////////////////////////////////////////////////////////////////
void CProjItem::FixConfigs(const CProjItem * pItem)
{
// Garbage collection

	// delete any unneeded source configs
	CPtrList deathRow;
	ConfigurationRecord * pcr;
	const ConfigurationRecord * pcrBase;
	int nSize = GetPropBagCount();
	for (int nIndex = 0; nIndex < nSize; nIndex++)
	{
		// look up the base config for pItem that matches each entry
		// by name.  If the base configs do not match, then this is
		// an unneeded entry that should be deleted.

		pcr = (ConfigurationRecord *)m_ConfigArray[nIndex];
		ASSERT_VALID (pcr);
		ASSERT_VALID (pcr->m_pBaseRecord);

		pcrBase = ((CProjItem *)pItem)->ConfigRecordFromConfigName(pcr->GetConfigurationName());
		if (!pcrBase || pcr->m_pBaseRecord != pcrBase->m_pBaseRecord)
		{
			// this one needs to be deleted
			deathRow.AddTail((void *)pcr->m_pBaseRecord);
		}
	}

	while (!deathRow.IsEmpty())
		DeleteConfigFromRecord((ConfigurationRecord *)deathRow.RemoveHead(), FALSE);

	ASSERT(GetPropBagCount()==pItem->GetPropBagCount());

	// Now reorder remaining configs, if necessary, based on pItem
	nSize = pItem->GetPropBagCount();
	ASSERT(nSize==GetPropBagCount()); // consistency check
	for (nIndex = 0; nIndex < nSize; nIndex++)
	{	
		pcrBase = ((ConfigurationRecord *)pItem->m_ConfigArray[nIndex])->m_pBaseRecord;
		VERIFY(m_ConfigMap.Lookup((void*)pcrBase, (void *&)pcr));
		m_ConfigArray[nIndex] = pcr;
	}
	
	//	Repeat for all children:
	if (GetContentList ())
	{
		POSITION pos;
		for (pos=GetHeadPosition(); pos!=NULL;)
		{
			// Any contained slobs should also be cleaned up
			((CProjItem *)GetNext(pos))->FixConfigs(pItem);
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
void CProjItem::DeleteConfigFromRecord (ConfigurationRecord *prec, BOOL bChildren)
{
//	Delete the configuration and tell our kids to do the same.  Note that
//  subprojects that get called for a parents config will do nothing since
// 	they won't find prec.

	PCFG_TRACE ("%s at %p deleting config with base at %p (name: %s)\n",
	  GetRuntimeClass()->m_lpszClassName, this, prec, ( (CStringProp *) 
	  ((ConfigurationRecord *)prec->m_pBaseRecord)->GetPropBag(CurrBag)->FindProp(P_ProjConfiguration))->m_strVal);

	// Notify target items about config deletions
	if (this->IsKindOf(RUNTIME_CLASS(CTargetItem)) ||
		this->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
 		InformDependants(SN_DESTROY_CONFIG, (DWORD)prec);
	}
 
	if (bChildren && GetContentList())
	{
		for (POSITION pos = GetHeadPosition(); pos != (POSITION)NULL;)
			((CProjItem *) GetNext (pos))->DeleteConfigFromRecord (prec);
	}

	// We may not have the config rec that we want to delete, in which case we
	// don't do anything (however we do still recurse to our children just above,
	// in case they have the config rec).
	ConfigurationRecord *pMyRec;
	if (m_ConfigMap.Lookup(prec, (void *&) pMyRec))
	{
		ASSERT_VALID(pMyRec);
		ASSERT(pMyRec->m_pBaseRecord == prec);

		// remove from both Map and Array
		int i = 0;
		int size = GetPropBagCount();

		m_ConfigMap.RemoveKey(prec);
		while (i < size)
		{
			if (pMyRec == m_ConfigArray.GetAt(i))
			{
				m_ConfigArray.RemoveAt(i);
				break;	// stop if found
			}

			i++;
		}

		// if we're deleting our current active then 
		// set it to NULL which will cause ::GetActiveConfig()
		// to re-figure it out
		if (m_pActiveConfig == pMyRec)
			m_pActiveConfig = (ConfigurationRecord *)NULL;

		delete pMyRec;
	}
}

///////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void CProjItem::AssertValid () const
{
	CProjItem * ncthis = (CProjItem *)this; // Brute force since we're const.

	// validate base component
	CObject::AssertValid();

	// validate content list
	if (ncthis->GetContentList()) ASSERT_VALID (ncthis->GetContentList());

	// validate our path
	if (GetFilePath ()) ASSERT_VALID (GetFilePath());

#if 0
	// We can't really check the dependencies because the currently active config
	// could be something which is not applicable to this object. We end up creating
	// bogus config records if we do this.  [sanjays]

	// validate our list of dependencies
	if (GetDependenciesList ()) ASSERT_VALID (GetDependenciesList());
#endif
}
///////////////////////////////////////////////////////////////////////////////
void CProjItem::Dump (CDumpContext &DC) const
{
	//ASSERT_VALID(this);
	POSITION pos;
	CObject *pObject;
	ConfigurationRecord *pcr;
	void *pv;
	TCHAR buf[257]; buf[256]=0;
	CProjItem *ncthis = (CProjItem *) this; // Brute force since we're const.

	if (DC.GetDepth () > 1) DC << 
	"************************************************************************";

	_snprintf ( buf, 256, "Dump of %s at %p:"
		" File path = \"%s\"",
		(const char *) GetRuntimeClass()->m_lpszClassName, (void *) this,
		(GetFilePath ()) ? ((const char *) *GetFilePath ()) : " (no file) " );
	DC << buf;

#if 0	// Doesn't work with new dependency mechanism.
	if (m_dependants.IsEmpty ()) DC << 	"DependantsList list is emtpy\n";
	else
	{
		DC << "DependantsList list:\n";
		for (pos = m_dependants.GetHeadPosition(); pos != NULL;)
		{
			pObject = m_dependants.GetNext (pos);
			_snprintf (buf, 256, "     a %s at %p    ",
			 		(const char *) pObject->GetRuntimeClass()->m_lpszClassName, 
					(void *) pObject);
			DC << buf; 
		}
	}
#endif

	int i;
	int size = GetPropBagCount();
	if (!size)	DC << 	"ConfigArray is empty\n";
	else
	{
		_snprintf ( buf, 256, "Config array has %i entries. Active is %p",
				size, (void *)((CProjItem *)this)->GetActiveConfig());
		DC << buf;	
		for (i =0; i < size; i++)
		{
			DC << (ConfigurationRecord *)m_ConfigArray[i];
		}
	}
	if (m_ConfigMap.IsEmpty ())	 DC << 	"ConfigMap is empty\n";
	else
	{
		_snprintf ( buf, 256, "Config map has %i entries. Active is %p",
				m_ConfigMap.GetCount (), (void *) ((CProjItem *)this)->GetActiveConfig());
		DC << buf;	
		for (pos = m_ConfigMap.GetStartPosition (); pos != NULL;)
		{
			m_ConfigMap.GetNextAssoc ( pos, pv, (void *&) pcr );
			DC << pcr;
		}
	}

	if (ncthis->GetContentList()) 
	{
		if (ncthis->GetContentList()->IsEmpty()) 
									DC << "Contents list is empty.";
		else
		{
			DC << "Contents list:";
			for (pos = ncthis->GetContentList()->GetHeadPosition(); pos != NULL;)
			{
				pObject = ncthis->GetContentList()->GetNext (pos);
				if (DC.GetDepth () > 1)	pObject->Dump ( DC );
				else
				{
					_snprintf (buf, 256, "     a %s at %p",
				 		(const char *) pObject->GetRuntimeClass()->m_lpszClassName,
						(void *) pObject);
					DC << buf; 
				}
			}
		}
	}
}
#endif

BOOL CProjItem::CanAct(ACTION_TYPE action)
{
	if (action == act_rename)
		return FALSE;

	return CProjSlob::CanAct(action);
}

void CProjItem::CopyCommonProps(CProjItem * pSrcItem, const CString & strTarget)
{
    ConfigurationRecord * pcrSrc = pSrcItem->ConfigRecordFromConfigName(strTarget, FALSE, FALSE);
    ConfigurationRecord * pcrDest = GetActiveConfig();
	if( pcrSrc == NULL ){
		// this is a sanity check since ConfigR...gName() can return NULL
		// if it does return NULL then there is no configuration to copy.
		// this should be ok.
		return;
	}

    CPropBag * pBagSrc = pcrSrc->GetPropBag(m_idBagInUse);
    CPropBag * pBaseBagSrc = pcrSrc->GetPropBag(BaseBag);
    CPropBag * pBagDest = pcrDest->GetPropBag(m_idBagInUse);
    CPropBag * pBaseBagDest = pcrDest->GetPropBag(BaseBag);

    // Copy all of the properties here
    //pBagDest->Clone(this, pBagSrc, FALSE);

    // Now we have to check for string list properties and potentially munge
    // the copied versions so that we only copy common settings!
    CProp * ppropSrc, * ppropBaseSrc, * ppropDest, * ppropBaseDest;

    POSITION pos = pBagSrc->GetStartPosition();
    while (pos != NULL)
    {
        UINT id;
		BOOL bInform;
        pBagSrc->GetNextAssoc(pos, id, ppropSrc);

		switch (ppropSrc->m_nType)

		{
			case integer:
				//
				// Inform dependants if setting P_ItemExcludedFromBuild to TRUE and
				// proprety for P_ItemExcludedFromBuild wasn't previously in pBagDest.
				// This is needed because CProjItem::GetIntProp has a hack to return
				// P_ItemExcludedFromBuild as TRUE when the proprety doesn't exist.  This
				// causes AssignActions to do an AddRefRef that needs to be undone.
				//
				bInform = P_ItemExcludedFromBuild==id && 
					NULL==pBagDest->FindProp(P_ItemExcludedFromBuild) &&
					((CIntProp *)ppropSrc)->m_nVal;

				pBagDest->SetIntProp(this, id, ((CIntProp *)ppropSrc)->m_nVal);

				if (bInform)
					InformDependants(id);
				break;

			case string:
			{
				COptionHandler * popthdlr = g_prjcompmgr.FindOptionHandler(id);
				BOOL fIsListStrProp = (popthdlr != (COptionHandler *)NULL) && popthdlr->IsListStrProp(id-1);
				if (!fIsListStrProp)
 					pBagDest->SetStrProp(this, id, ((CStringProp *)ppropSrc)->m_strVal);
 				else
				{
					// Ok now we may need to start munging to get correct props

					// Get all of our properties from the various bags
					ppropBaseSrc = pBaseBagSrc->FindProp(id);
					ppropDest = pBagDest->FindProp(id);
					ppropBaseDest = pBaseBagDest->FindProp(id);

					CString strNewProp;
					if (ppropDest)
					{
						// Work out the differences we need to apply to the destination bag
						COptionList optlstAdd, optlstSub;
						COptionList optlist;
						optlist.SetString(((CStringProp *)ppropBaseSrc)->m_strVal);

						optlist.Components(((CStringProp *)ppropSrc)->m_strVal, optlstAdd, optlstSub);

						// Apply the differences to the base prop val in the destination bag
						COptionList optlstDest;
						optlstDest.SetString(((CStringProp *)ppropDest)->m_strVal);
						optlstDest.Subtract(optlstSub);
						optlstDest.Append(optlstAdd);

						// Get the new prop string
						optlstDest.GetString(strNewProp);
					}
					else
						strNewProp = ((CStringProp *)ppropSrc)->m_strVal;

					// set the prop value
					pBagDest->SetStrProp(this, id, strNewProp);
				}
                break;
			}

			default:
				ASSERT(FALSE);
				break;
		}
    }
}

int CProjItem::CompareSlob(CSlob * pCmpSlob)
{
	ASSERT(pCmpSlob->IsKindOf(RUNTIME_CLASS(CProjItem)));

	// Put dependency containers at the end of this container
	if (IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		return 1;

	if (((CProjItem *)pCmpSlob)->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		return -1;

	// Put Groups at the start of this container
	if (((CProjItem *)pCmpSlob)->IsKindOf(RUNTIME_CLASS(CProjGroup)))
		return 1;

	if (IsKindOf(RUNTIME_CLASS(CProjGroup)))
		return -1;

	// Put subprojects at the start of this container
	if (((CProjItem *)pCmpSlob)->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return 1;

	if (IsKindOf(RUNTIME_CLASS(CProjectDependency)))
		return -1;

	CString strExt, strCmpExt; 
	BOOL bCmpIsFileItem = (((CProjItem *)pCmpSlob)->IsKindOf(RUNTIME_CLASS(CFileItem)));
	BOOL bIsFileItem = (IsKindOf(RUNTIME_CLASS(CFileItem)));
	if (bCmpIsFileItem)
		strCmpExt = ((CFileItem *)pCmpSlob)->GetFilePath()->GetExtension();
	if (bIsFileItem)
		strExt = GetFilePath()->GetExtension();

	// Put .lib files last and don't sort them alphabetically
	if (bIsFileItem && (strExt.CompareNoCase(".lib")==0))
		return 1;

	if (bCmpIsFileItem && (strCmpExt.CompareNoCase(".lib")==0))
		return -1;

	// Put .obj files last and don't sort them alphabetically
	if (bIsFileItem && (strExt.CompareNoCase(".obj")==0))
		return 1;

	if (bCmpIsFileItem && (strCmpExt.CompareNoCase(".obj")==0))
		return -1;

	// Everything else is sorted based on their P_Title property, i.e alphabetically

	int retval = CProjSlob::CompareSlob(pCmpSlob);

	// as a tie breaker, use the absolute path to at least get consistency
	if (retval == 0)
	{
		ASSERT(GetFilePath() != NULL);
		ASSERT(((CProjItem *)pCmpSlob)->GetFilePath() != NULL);
		retval = _tcsicmp((LPCTSTR)*GetFilePath(), (LPCTSTR)*((CProjItem *)pCmpSlob)->GetFilePath());
	}
	ASSERT(retval != 0); // should never be equal
	return retval;
}

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------	CFileItem ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////
#define theClass CFileItem
BEGIN_SLOBPROP_MAP(CFileItem, CProjItem)
END_SLOBPROP_MAP()
#undef theClass

BOOL CFileItem::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// WARNING! This does not fall through to a message map.  You must
	// handle both CN_COMMAND and CN_UPDATE_COMMAND_UI if you want your
	// commands to be enabled.

	if (nCode == CN_COMMAND && pExtra == NULL)
	{
		if (nID == IDM_PROJITEM_OPEN)
		{
			OnOpen();
			return TRUE;
		}
	}
	else if (nCode == CN_UPDATE_COMMAND_UI)
	{
		ASSERT(pExtra != NULL);
		CCmdUI* pCmdUI = (CCmdUI*)pExtra;
		ASSERT(pCmdUI->m_nID == nID);           // sanity assert

		if (nID == IDM_PROJITEM_OPEN)
		{
			pCmdUI->Enable(TRUE);
			return TRUE;
		}
	}

	// pass on to the default handler
	return CProjItem::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

CFileItem::CFileItem () 
{
	// our file handle
	m_hndFileReg = NULL;

	// the Project Window item inset
	m_nIconIdx = 3; 

	// display name dirty to begin with
	m_fDisplayName_Dirty = TRUE;

	// by default, path is in the project dir
	m_bIsInProjDir = FALSE;

	// default is to scan a file for classes
	m_bExcludedFromScan = FALSE;

	m_bAlwaysWriteDepMacro = FALSE;
}

BOOL CFileItem::SetIntProp(UINT idProp, int val)
{
	// which prop are we setting?
	switch (idProp)
	{
		case P_ItemExcludedFromBuild:
		{
			// don't do anything if we are initializing from a project file
			CProject * pProject = GetProject(); ASSERT(pProject != (CProject *)NULL);
			if (pProject->m_bPrivateDataInitialized)
			{
				CPtrList * pFileList;
				CObList FileItemList;
				CFileItem * pItem;
				const ConfigurationRecord * pcr = GetActiveConfig();

				ASSERT(GetFilePath());
				// is this a file we can only have on of included in the build?
				if (!val &&	// wanting to include this in the build?
					GetRegistry()->GetFileList(GetFilePath(), (const CPtrList * &)pFileList) &&
					GetRegistry()->GetFileItemList(GetTarget(), pFileList, FileItemList, TRUE, pcr) &&
					FileItemList.GetCount() == 1 &&
					(pItem = (CFileItem * )FileItemList.GetHead()) != this)	// one already included in build?
				{
 					// ask the user if they want to do this?
					TCHAR * pExt = pFileList == GetRegistry()->GetRCFileList() ? _TEXT(".rc") : _TEXT(".def");
					CString strPath;
					GetFilePath()->GetRelativeName(pProject->GetWorkspaceDir(), strPath);
					if ( pcr != NULL && QuestionBox(IDS_FILE_INCL_TOGGLE, MB_YESNO, pExt, (TCHAR *)(const TCHAR *)strPath, pExt) == IDYES)
					{
						// toggle the other one to 'excluded from build'
						pItem->ForceBaseConfigActive((ConfigurationRecord *)pcr->m_pBaseRecord);
						pItem->SetIntProp(P_ItemExcludedFromBuild, TRUE);
						pItem->ForceConfigActive();
					}
					else
						return FALSE;	// don't do this
 				}

			}
			break;
		}
		case P_ItemIgnoreDefaultTool:
		{
			BOOL retval = CProjItem::SetIntProp(idProp, val);
			if (retval && GetProject() && GetProject()->m_bProjectComplete)
			{
				ConfigurationRecord * pcr = GetActiveConfig();
				CActionSlob::UnAssignActions(this, (CPtrList *)NULL, (ConfigurationRecord *)pcr->m_pBaseRecord);
				CActionSlob::AssignActions(this, (CPtrList *)NULL, (ConfigurationRecord *)pcr->m_pBaseRecord);
			}
			return retval;
		}
		break;
		case P_ItemExcludedFromScan:
		{
			// not per config props are stored locally
			m_bExcludedFromScan = val;
			return TRUE;
			break;
		}
		default:
			break;
	}

	// pass on to base-class
	return CProjItem::SetIntProp(idProp, val);
}

BOOL CFileItem::SetStrProp(UINT idProp, const CString & str)
{
	if (idProp == P_ProjItemOrgPath)
	{
		if (str.IsEmpty())
		{
			GetMoniker(m_strOrgPath);  // default
			return TRUE;
		}

		// UNDONE: much further validation needed here!!!

		m_strOrgPath = str;
		return TRUE;
	}
	return CProjItem::SetStrProp(idProp, str);
}

GPT CFileItem::GetStrProp(UINT idProp, CString& val)
{
	// is this a fake prop?
	switch (idProp)
	{
		case P_ProjItemName:	// yes
			if (m_fDisplayName_Dirty)
			{
				ASSERT(m_hndFileReg != NULL);
				m_strDisplayName = (g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFilePath())
					->GetFileName ();
				m_fDisplayName_Dirty = FALSE;
			}
			val = m_strDisplayName;
			return valid;

		case P_ProjItemOrgPath:
		case P_FakeProjItemOrgPath:
			ASSERT(m_hndFileReg != NULL);
			if (m_strOrgPath.IsEmpty())
			{
				const TCHAR * pszOrgName = g_FileRegistry.GetRegEntry(m_hndFileReg)->GetOrgName();
				if (pszOrgName != NULL)
					m_strOrgPath = pszOrgName;
			}
			if (m_strOrgPath.IsEmpty())
				GetMoniker(m_strOrgPath);

			val = m_strOrgPath;
			return valid;

		case P_FileName:
		case P_ProjItemFullPath:
			ASSERT(m_hndFileReg != NULL);
			val = (const TCHAR*) *g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFilePath();
			return valid;

		case P_ProjItemDate:
			ASSERT(m_hndFileReg != NULL);
			if (!g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFileTime(val))
				VERIFY(val.LoadString(IDS_FILE_ITEM_NONEXISTANT));
			return valid;

		case P_ProjMainTarget:
			{
				ASSERT(GetActiveConfig());
				CFRFPtrArray * parray = GetActiveConfig()->GetTargetFilesArray();

				if (parray != NULL && parray->GetSize() > 0)
				{
					FileRegHandle frh = parray->GetAt(0);
					if (frh != (FileRegHandle)NULL)
					{
						val = (const TCHAR *) *g_FileRegistry.GetRegEntry(frh)->GetFilePath();
						return valid;
					}
				}
				return invalid;
			}

		case P_ProjMainTargetDate:
			{
				ASSERT(GetActiveConfig());
				CFRFPtrArray * parray = GetActiveConfig()->GetTargetFilesArray();

				if (parray != NULL && parray->GetSize() > 0)
				{
					FileRegHandle frh = parray->GetAt(0);
					if (frh != (FileRegHandle)NULL)
					{
						if (!g_FileRegistry.GetRegEntry(frh)->GetFileTime(val))
							VERIFY(val.LoadString(IDS_NO_TOOL_OUTPUT));
						return valid;
					}
				}
				return invalid;
			}

		// not allowed for file items
		case P_OutDirs_Target:
			if ((m_optbeh & OBShowMacro) && (GetProject()->GetOutDirString(val)))
				return valid; // config doesn't matter since always "$(OUTDIR)"
			else
				return invalid;

		case P_OutDirs_Intermediate:
			{
				// must only use INTDIR Macro, never INTDIR_SRC if defined
				if ((m_optbeh & OBShowMacro) && (GetOutDirString(val)))
					return valid;
				break;
			}
		default:
			break;
	}

	// no, pass on to base class
	return CProjItem::GetStrProp(idProp, val);
}

GPT CFileItem::GetIntProp(UINT idProp, int& val)
{
	// is this a fake prop?
	switch (idProp)
	{
		case P_ItemExcludedFromBuild:
		{
			// If this is an external target then all files are excluded from the build
			CProject * pProject = GetProject();

			// FUTURE: the top half of this 'if' may be redundant
            CProjType * pProjType;
            if (m_pForcedConfig != (ConfigurationRecord *) NULL)
            {
                pProject->ForceConfigActive((ConfigurationRecord *)m_pForcedConfig->m_pBaseRecord);
				pProjType = pProject->GetProjType();
                pProject->ForceConfigActive();
			}
            else
                pProjType = /*pProject->*/GetProjType();

#if 0
			BOOL bIsExternalTarget = pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget));
			if (bIsExternalTarget)
			{
				val = TRUE;
				return valid;
			}
			break;
#endif
		}

		case P_ItemIgnoreDefaultTool:
		{
#if 0
			int bExcluded;
			if (GetIntProp(P_ItemExcludedFromBuild, bExcluded) == valid && bExcluded)
			{
				val = 0;
				return invalid;
			}
#endif

			GPT retval = CProjItem::GetIntProp(idProp, val);
			if (retval != valid)
			{
				val = 0;
				retval = valid;	// always valid if not excluded
			}
			return retval;
		}
		break;
		case P_ItemExcludedFromScan:
		{
			// not per config props are stored locally
			val = m_bExcludedFromScan;

			// ignore this prop if zero
			return (val) ? valid : invalid;
			break;
		}

		default:
			break;
	}

	// no, pass on to base class
	return CProjItem::GetIntProp(idProp, val);
}

BOOL CFileItem::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	// test for multi selection.
	if (pNewSel->IsKindOf(RUNTIME_CLASS(CMultiSlob)))
	{
		POSITION posProv = pNewSel->GetHeadPosition();
		int count = 0;
		while (posProv != NULL)
		{
			CSlob* pSlob = (CSlob*)pNewSel->GetNext(posProv);
			count++;
			if( count > 1 ){
				return TRUE;
			}
		}
	}

	// Are we dealing with an external target, since external targets do not
	// have input/output pages
	CProjType * pProjType = GetProjType();
	BOOL bIsExternalTarget = (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)));

#if 1	// REVIEW: bogus
	CString strConfig;
	CTargetItem * pTarget = GetTarget();
	BOOL bMatchingConfig = g_BldSysIFace.GetTargetNameFromFileSet((HFILESET)pTarget, strConfig, ACTIVE_BUILDER, TRUE);

	bIsExternalTarget = bIsExternalTarget || !bMatchingConfig;
#endif

	// items which have the PassThroughTool don't
	// have the output directories
	CBuildTool * pSrcTool = GetSourceTool();

	// if we have no source tool or if our source
	// tool is the pass-through tool, let the base
	// class deal with this
	// if( pSrcTool == (CBuildTool*)NULL )
	// 	AddPropertyPage(&g_DepGeneralPage, this);
	// else
		AddPropertyPage(&g_FileGeneralPage, this);	// is this the File 'General' page?

	// is this the File 'Inputs', 'Outputs', 'Dependencies' pages?
	if( !bIsExternalTarget )
	{
		AddPropertyPage(&g_InputsPage, this);
		AddPropertyPage(&g_OutputsPage, this);
		AddPropertyPage(&g_DepsPage, this);
	}

	CProjItem::SetupPropertyPages(pNewSel, bSetCaption);

	if( bSetCaption )
		SetPropertyCaption(CString(MAKEINTRESOURCE(IDS_FILEITEM)));

	return TRUE;
}

// Return a container-less, symbol-less, clone of 'this'
CSlob * CFileItem::Clone()
{
	// call base class to create clone
	CSlob * pClone = CProjItem::Clone();
	ASSERT(pClone->IsKindOf(RUNTIME_CLASS(CFileItem)));
	ASSERT(((CFileItem *)pClone)->GetFileRegHandle()==GetFileRegHandle());

	return pClone;
}

/////////////////////////////////////////////////////////////////////////
CFileRegSet * CFileItem::GetDependenciesList() const
{		    
    ConfigurationRecord * pcr = ((CFileItem *)this)->GetActiveConfig();
    if (pcr == (ConfigurationRecord *)NULL)
		return (CFileRegSet *)NULL;

	CActionSlobList * pActions = pcr->GetActionList();
	if (pActions->IsEmpty())
		return (CFileRegSet *)NULL;

	ASSERT(pActions->GetCount() == 1);

	return ((CActionSlob *)pActions->GetHead())->GetScannedDep();
}
//////////////////////////////////////////////////////////////////////////
BOOL CFileItem::SetFile(const CPath *pPath, BOOL bCaseApproved /*=FALSE*/) 
{
	// need to refresh this cache
	m_fDisplayName_Dirty = TRUE;

	// keep copy of old registry handle
	FileRegHandle hndFileRegOld = m_hndFileReg;

	// register this new file
#ifndef REFCOUNT_WORK
	m_hndFileReg = g_FileRegistry.RegisterFile(pPath, !bCaseApproved);
#else
	m_hndFileReg = CFileRegFile::GetFileHandle(*pPath);
#endif

	BOOL bChanged = (m_hndFileReg != hndFileRegOld);

	// release a ref. to the old file
	if (hndFileRegOld)
	{
#ifndef REFCOUNT_WORK
		g_FileRegistry.ReleaseRegRef(hndFileRegOld);
#else
	hndFileRegOld->ReleaseFRHRef();
#endif
	}

	if ((m_hndFileReg != (FileRegHandle)NULL) && bChanged)
	{
		// invalidate cached relative path
		m_strMoniker.Empty();
		if ((GetProject()!= NULL) && (GetProject()->m_bProjectComplete))
		{
			m_strOrgPath.Empty();
			GetProject()->DirtyProject();
		}

		// by default, path is in the project dir
		m_bIsInProjDir = FALSE;

		((CPath *)GetFilePath())->SetAlwaysRelative();
		// if bCaseApproved then we read this CFileItem in from makefile
		// and will therefore assume correct case is already set...
		if (bCaseApproved || !m_hndFileReg->IsMatchCase())
		{
			if (bCaseApproved && !m_hndFileReg->IsMatchCase())
			{
				// someone added this file without regard to case
				// but we DO care, so let's do the calculations
				((CFileRegFile *)m_hndFileReg)->SetFilePath(pPath);
			}
			m_hndFileReg->SetMatchCase(TRUE, bCaseApproved);
		}
 	}

	return m_hndFileReg != (FileRegHandle)NULL;	// success?
}
///////////////////////////////////////////////////////////////////////////////
BOOL CFileItem::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// do the base-class thing
	if (!CProjItem::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

#if 0
	if (g_bNewUpdateDepModel)
		return TRUE;

	// Are we deleting this file without undo switched on
	if (!CouldBeContainer(pContainer) && fFromPrj && !fToPrj)
	{
			// Then make sure that we remove the item from the dependency updating
			// queue. Note PostMoveItem will not be called if we get here.
			FileRegHandle frh = GetFileRegHandle();
			TCHAR * pch = _tcschr((LPCTSTR)(*frh->GetFilePath()), '.');

			// don't scan the deps for now, hopefully background parser will do this for us quick enough
			if (pch && (_tcsicmp(pch, ".cpp")==0 || _tcsicmp(pch, ".cxx")==0 || _tcsicmp(pch, ".c")==0 ))
			{
				// cache the file list, so we can make sure that all the deps are updated before we write out to makefile
				FileItemDepUpdateQ(this, NULL, NULL, g_FileDepUpdateListQ, fFromPrj);
				FileItemDepUpdateQ(this, NULL, NULL, g_FileForceUpdateListQ, fFromPrj);
			}
			else
			{
				// non-C files, queue it on for updating deps
				// also put it on the force update Q, so we don't miss it if idle update didn't catch it
				FileItemDepUpdateQ(this, NULL, NULL, g_FileForceUpdateListQ, fFromPrj);
				FileItemDepUpdateQ(this, NULL, frh, g_FileDepUpdateListQ, fFromPrj);
			}
	}
#endif

	return TRUE;	// success
}

BOOL CFileItem::MoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	CTargetItem * pTarget;
	
	// Get our file reg handle
	FileRegHandle frh = GetFileRegHandle();

	// moving into or out of the project?
	// project not being created/destroyed?
	CProjItem * pProjCntr = (CProjItem *)(fToPrj ? pContainer : pOldContainer);
	ASSERT(pProjCntr != (CProjItem *)NULL);

	// If no undo then we send out a delete notify now.
	// We MUST do this before the real MoveItem as we will be deleted
	if (!theUndoSlob.IsRecording() && fFromPrj && (!fToPrj) && frh != (FileRegHandle)NULL)
	{
		pTarget = pProjCntr->GetTarget();
		if (pTarget != NULL)
		{
			pTarget->AddToNotifyList(frh, fFromPrj);	
		}
	}

	if (!CProjItem::MoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	// Send out file addition notifications here
	if (!theUndoSlob.IsRecording() && fToPrj && (fPrjChanged || !fFromPrj) && frh != (FileRegHandle)NULL)
	{
		// If doing drag n drop then send out a delete
		if (fFromPrj)
		{
			pTarget = ((CProjItem *)pOldContainer)->GetTarget();
			if (pTarget != NULL)
			{
				pTarget->AddToNotifyList(frh, TRUE);	
			}
		}

		// send out the add
		pTarget = ((CProjItem *)pContainer)->GetTarget();
		if (pTarget != NULL)
		{
			pTarget->AddToNotifyList(frh, FALSE);	
		}

	}

 	return TRUE;	// sucess
}

BOOL CFileItem::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
 	if (!CProjItem::PostMoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;
 
	// moving into or out of the project?
	// project not being created/destroyed?
	CProjItem * pProjCntr = (CProjItem *)(fToPrj ? pContainer : pOldContainer);
	ASSERT(pProjCntr != (CProjItem *)NULL);

	if ((fFromPrj || fToPrj) && pProjCntr->GetProject()->m_bProjectComplete)
	{
		// Send out 'addition' of file notification
		FileRegHandle frh = GetFileRegHandle();
		if (frh != (FileRegHandle)NULL)
		{
			// Send out 'addition' or 'deletion' of file notification
			if (fFromPrj && fToPrj)
			{
				ASSERT(pOldContainer != pContainer);
				if (fPrjChanged)
				{
					ASSERT(((CProjContainer *)pOldContainer)->GetTarget()!=((CProjContainer *)pContainer)->GetTarget());
					// Send out a delete followed by an add, for drag/n/drop
					((CProjItem *)pOldContainer)->GetTarget()->AddToNotifyList(frh, TRUE);
					((CProjItem *)pContainer)->GetTarget()->AddToNotifyList(frh, FALSE);
					
					// invalidate the moniker beacuse it changed projects.
					if( fPrjChanged ){
						m_strOrgPath.Empty();
						m_strMoniker.Empty();
					}
				}
				else
				{
					ASSERT(((CProjContainer *)pOldContainer)->GetTarget()==((CProjContainer *)pContainer)->GetTarget());
					// REVIEW: do nothing in this case
				}
			}
			else
			{
				pProjCntr->GetTarget()->AddToNotifyList(frh, fFromPrj);
			}

#if 0 // dead code.
			if (!g_bNewUpdateDepModel)
			{
				// do dep updates for the files move into project
				// 1) C files, put on the waiting queue, this queue will be updated only before 
				//    makefile being written out most of the time, deps will be updated through 
				//    parser calls, items on the queue will be removed
				// 2) Non-C files, will be put on unpdate queue, scan deps will happen in the idle loop.

				// get extension
				TCHAR * pch = _tcschr((LPCTSTR)(*frh->GetFilePath()), '.');

				// don't scan the deps for now, hopefully background parser will do this for us quick enough
				if (pch && (_tcsicmp(pch, ".cpp")==0 || _tcsicmp(pch, ".cxx")==0 || _tcsicmp(pch, ".c")==0 ))
				{
					// cache the file list, so we can make sure that all the deps are updated before we write out to makefile
					FileItemDepUpdateQ(this, NULL, NULL, g_FileForceUpdateListQ, fFromPrj);
				}
				else
				{
					// non-C files, queue it on for updating deps
					// also put it on the force update Q, so we don't miss it if idle update didn't catch it
					FileItemDepUpdateQ(this, NULL, NULL, g_FileForceUpdateListQ, fFromPrj);
					FileItemDepUpdateQ(this, NULL, frh, g_FileDepUpdateListQ, fFromPrj);
				}
			}
#endif // dead code.
		}
	}

	return TRUE;	// sucess
}
///////////////////////////////////////////////////////////////////////////////
void CFileItem::FlattenQuery(int fo, BOOL& bAddContent, BOOL& fAddItem)
{
	if (fo & flt_RespectItemExclude)
	{
		// get excluded from and convert into fAddItem by negating
		VERIFY(GetIntProp(P_ItemExcludedFromBuild, fAddItem) == valid);
		fAddItem = !fAddItem;
	}
	else
		fAddItem = TRUE;
}
///////////////////////////////////////////////////////////////////////////////
void CFileItem::GetMoniker( CString& cs )
{
	if (m_strMoniker.IsEmpty())
	{
		// Get the file's name relative to its project directory:
		const CPath *pPath = GetFilePath ();	
		ASSERT (pPath);
		// ASSERT(pPath->GetAlwaysRelative());
		if (!pPath->GetAlwaysRelative()) // this could fail if shared from SCC, etc.
			((CPath *)pPath)->SetAlwaysRelative(); // needed for GetRelativeName() call

		if (!pPath->GetRelativeName(GetProject()->GetWorkspaceDir(), m_strMoniker))
			{
				m_bIsInProjDir = FALSE;
				m_strMoniker = *pPath;
			}
		else if ((m_strMoniker[0]==_T('.')) && (m_strMoniker[1]==_T('\\')) &&
				(_tcschr(LPCTSTR(m_strMoniker) + 2, _T('\\'))==NULL))
		{
			// can only use inference rules if in project directory
			// FUTURE: allow subdirs as well
			m_bIsInProjDir = TRUE;
		}
		else
			m_bIsInProjDir = FALSE;

		ASSERT(!m_strMoniker.IsEmpty());
	}

	cs = m_strMoniker;
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands
void CFileItem::OnOpen()
{
	const CPath * pPath = g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFilePath();
	ASSERT(pPath != (const CPath *)NULL);

	// cannot open a file that would be opened as
	// a project [DOLPHIN bug #13674]
	CDocument * pDocument = NULL;

	// We should open makefiles as text
	CString strFileName = *pPath;
	if (strFileName == *g_BldSysIFace.GetBuilderFile((HBUILDER)GetProject()))
	{
		CDocument* pOpenDoc;
		CDocTemplate * pTemplate =
			theApp.GetOpenTemplate(strFileName, pOpenDoc);

		// Check to see if its already open
		if (pTemplate != NULL)
		{
			ASSERT(pOpenDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));

			((CPartDoc*) pOpenDoc)->ActivateDoc();
			return;
		}

		// This makefile is not the same as the builder currently loaded, so we
		pTemplate = theApp.GetTemplate(CLSID_TextDoc /*CLSID_TextDocument*/);
		if (pTemplate != NULL)
		{
			// can safely open it as text!
			theApp.LockRecentFileList(TRUE);
			pTemplate->OpenDocumentFile(*pPath);
			theApp.LockRecentFileList(FALSE);
		}
		else
			TRACE("CProjItem::OnOpen() failed to open makefile as text\n");

 		return;
	}
	//else
	//{
		// Attempting to open the current project's makefile as text, but
		// we can only have a file open by one editor at a time
		//MsgBox(Information, IDS_ERR_OPENING_MAK_AS_TEXT);
		//return;
	//}

	// before OpenDocumentFileEx(), it checks if the file exists on disk
	// or not. If it doesn't exist, it should ask if an empty file should be
	// created or not. We create empty file if we answer yes.
	// Modify the above with "give source control a shot first"
	COleRef<ISourceControl> sourceControl;
	BOOL bScc = FALSE;
// REVIEW: this code should be after the check through loaded documents
// so that if a file is open but deleted, double clicking goes to
// the open document.
	if ((!pPath->ExistsOnDisk()) &&
		// give the user a chance to "get latest" if it doesn't exist.
			!(SUCCEEDED(theApp.FindInterface(IID_ISourceControl, (void**)&sourceControl))
			&& (sourceControl != NULL)
			&& (bScc = (sourceControl->IsValidOp(*pPath, SccSyncOp) == S_OK))
			&& (QuestionBox (IDS_SCCGET_NONEXISTANT_FILE, MB_YESNO, pPath->GetFullPath()) == IDYES)
			&& (sourceControl->Sync(*pPath, TRUE) == S_OK) // TRUE to sleep
			&& (pPath->ExistsOnDisk()))
		)
	{
		if (bScc) {
			return;
		}
	// REVIEW: not sure if we want the "look through opened docs" code to run in the
	// scc case or not.

		// doesn't exist on disk
		CPartTemplate * pTemplate, * pOpenTemplate = (CPartTemplate *)NULL;
		CDocTemplate::Confidence confidence;

		POSITION pos = theApp.GetFirstDocTemplatePosition();

		while (pos != NULL)
		{
			pTemplate = (CPartTemplate*)theApp.GetNextDocTemplate(pos);
			if (!pTemplate->IsKindOf(RUNTIME_CLASS(CPartTemplate)))
				continue;

			// use the basic MFC template matching, this file doesn't exist
			// and package template matchers return CDocTemplate::noAttempt
			// if they can't open the file so that they can check the format
			CDocument * pDoc;
			confidence = pTemplate->CDocTemplate::MatchDocType(*pPath, pDoc);

			// already open? if so don't create .. use the current opened one
			// use this template to create the document?
			if (confidence == CDocTemplate::yesAlreadyOpen ||
				confidence == CDocTemplate::yesAttemptNative)
			{
				pOpenTemplate = pTemplate;
				break;
			}
		}

		// can we just open the currently opened one?
		if (confidence != CDocTemplate::yesAlreadyOpen)
		{
			// file doesn't exist, so we should ask if one should be created
			if (QuestionBox (IDS_CREATE_FILE, MB_YESNO, pPath->GetFullPath()) == IDNO)
				return;

			// did we find a template to create this?
			if (pOpenTemplate != (CPartTemplate *)NULL)
			{
				CDocument * pDoc;
				if ((pDoc = pOpenTemplate->OpenDocumentFile(NULL)) != (CDocument *)NULL)
				{
					// save this
					ASSERT(pDoc->IsKindOf(RUNTIME_CLASS(CPartDoc)));
					((CPartDoc *)pDoc)->DoSave(*pPath, TRUE);
				}
			}
			else
			{
				// create a blank file (no template matched this)
				HANDLE h;
				h = CreateFile(pPath->GetFullPath(), 
							   GENERIC_READ | GENERIC_WRITE,
							   FILE_SHARE_READ,
							   NULL,
							   CREATE_NEW,
							   FILE_ATTRIBUTE_NORMAL,
							   NULL);
				if (h == INVALID_HANDLE_VALUE)
				{
					ErrorBox (IDS_CANNOT_CREATE_FILE, pPath->GetFullPath());
					return;
				}
				else
					CloseHandle (h);
			}
		}
	}

	// open up this file (which does now exist), or execute it if it is an executable
	const char * szFileName = (const TCHAR *)*pPath;
	ASSERT(szFileName != (const TCHAR *)NULL);

	if (IsExecutableFile(szFileName))
	{
		ShellExecute(AfxGetApp()->m_pMainWnd->m_hWnd, NULL, 
					 szFileName, NULL, NULL, SW_SHOWNORMAL);
	}
	else
	{
		// Call OpenDocumentFileEx instead of OpenDocumentFile.  The
		// extended function tries to open the file with ShellExecute 
		// if there's not a good template match.
		theApp.LockRecentFileList(TRUE);
		theApp.OpenDocumentFileEx(szFileName, TRUE);
		theApp.LockRecentFileList(FALSE);
	}
}

BOOL CFileItem::ScanDependencies (BOOL bUseAnyMethod /* = FALSE */, 
	BOOL bWriteOutput /* = TRUE */ )
{
	BOOL bRetval = TRUE;
	CBuildTool * pTool = (CBuildTool *)GetSourceTool();
	ConfigurationRecord* pcr = GetActiveConfig();


	if (g_bNewUpdateDepModel && NULL != pcr && NULL != pTool && pTool->HasDependencies(pcr))
	{
		ASSERT(pcr->m_pOwner==this);

		CStringArray strArray;
		if (pTool->GetDependencies(pcr,strArray))
		{
			// See if dependencies have changed and then update
			// update if necessary
			BOOL bDirty = FALSE;
			CActionSlob* pAction = NULL;
			CActionSlobList* pActions = pcr->GetActionList();
			if (NULL==pActions)
				return FALSE;

			POSITION pos = pActions->GetHeadPosition();
			if (NULL==pos)
				return FALSE;

			// Get CActionSlob* from pcr that matches this tool.  Assume that
			// the CActionSlobList can have multiple CActionSlob's since we
			// may be allowing more than one tool to be associated with a tool
			// eventually.
			while (NULL!=pos)
			{
				CActionSlob* pLastAction = (CActionSlob*)pActions->GetNext(pos);

				if (pTool==pLastAction->m_pTool)
				{
					pAction = pLastAction;
					break;
				}
			}

			if (NULL==pAction)
				return FALSE;

			//
			// Determine if dependencies have changed.
			//
			{
				// remember previously scanned deps.
				// and also any old ones (so we can compare diffs)
				CMapPtrToPtr depsPrevious;

				// construct the map of current deps
				FileRegHandle frh;
				CFileRegSet * pfrs;
				
				pfrs = pAction->GetScannedDep();
				pfrs->InitFrhEnum();
				while ((frh = pfrs->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
					depsPrevious.SetAt(frh, (void*)DEP_Scanned);
#else
				{
					depsPrevious.SetAt(frh, (void*)DEP_Scanned);
					frh->ReleaseFRHRef();
				}
#endif

				pfrs = pAction->GetMissingDep();
				pfrs->InitFrhEnum();
				while ((frh = pfrs->NextFrh()) != (FileRegHandle)NULL)
#ifndef REFCOUNT_WORK
					depsPrevious.SetAt(frh, (void*)DEP_Missing);
#else
				{
					depsPrevious.SetAt(frh, (void*)DEP_Missing);
					frh->ReleaseFRHRef();
				}
#endif

				for (int i=0; i < strArray.GetSize(); i++ )
				{
					CPath path;
					VERIFY(path.Create(strArray[i]));
#ifndef REFCOUNT_WORK
					FileRegHandle frh = g_FileRegistry.LookupFile(&path);
#else
					FileRegHandle frh = CFileRegFile::LookupFileHandleByName(path);
					if (NULL!=frh)
						frh->ReleaseFRHRef();
#endif
					if (NULL==frh)
					{
						bDirty = TRUE;
						break;
					}
					else if ( !depsPrevious.RemoveKey((void *)frh) )
					{
						bDirty = TRUE;
						break;
					}
				}
				bDirty = bDirty || !depsPrevious.IsEmpty();
			}

			if (bDirty)
			{
				// clear the action's dependencies list
				pAction->ClearScannedDep();
				pAction->ClearMissingDep();

#ifdef USE_LATEST_IDB
				//
				// Add to dep scanner if necessary
				//
				// review(tomse) : checked in disabled because of risk that special files
				// such as the .pch that are configuration specific could be erroneously added
				// as a dependency to another configuration.  This would be bad for files that
				// were dependent only one the source and the pch files.
				//
				BOOL bAddToScannerCache = FALSE;
				if (bUseAnyMethod)
				{
					if (!g_ScannerCache.LookupFile(GetFileRegHandle()))
					{
						pAction->SetDepState(DEP_Empty);
						bAddToScannerCache = TRUE;
					}
				}
#endif // #ifdef USE_LATEST_IDB

				// add new ones
				for (int i=0; i < strArray.GetSize(); i++ )
				{
					CPath path;
					VERIFY(path.Create(strArray[i]));
#ifndef REFCOUNT_WORK
					FileRegHandle frh = g_FileRegistry.RegisterFile(&path);
					if (NULL!=frh)
						pAction->AddScannedDep(frh);
#else
					FileRegHandle frh = CFileRegFile::GetFileHandle(path);
					if (NULL!=frh)
					{
						pAction->AddScannedDep(frh);

#ifdef USE_LATEST_IDB
						//
						// Store in scanner cache so file doesn't need to be scanned.
						//
						if (bAddToScannerCache)
						{
							// Add scanned deps here
							CString str = path;
							VERIFY(pAction->AddScannedDep(0xff, str, 0, FALSE));
						}
#endif // #ifdef USE_LATEST_IDB
						frh->ReleaseFRHRef();
					}
#endif
				}

#ifdef USE_LATEST_IDB
				if (bAddToScannerCache)
				{
					CIncludeEntryList* pEntryList = pAction->GetIncludeDep();

					// FUTURE: remove hack init.
					// do we need an 'dummy' list?
					if (pEntryList == DEP_Empty)
						pEntryList = new CIncludeEntryList(5);

  					g_ScannerCache.Add(GetFileRegHandle(), pEntryList);
				}
#endif // #ifdef USE_LATEST_IDB

				// No need to dirty project anymore
				// GetProject()->DirtyProject();
			}

			pAction->UpdateDepInfoTimeStamp();

			bRetval = TRUE;
		}
		else if (bUseAnyMethod)
		{
			//
			// Try to use the scanner.  
			// review(tomse): May try to use NCB information if available.
			//
			ConfigCacheEnabler EnableCaching;

			if (pTool != (CBuildTool *)NULL && pTool->IsScannable())
			{
				g_ScannerCache.BeginCache();
				bRetval = pTool->ScanDependencies(this,bWriteOutput);
				g_ScannerCache.EndCache();
			}
		}
		else
		{
			bRetval = FALSE;
		}
	}
	else
	{
		ConfigCacheEnabler EnableCaching;

		if (pTool != (CBuildTool *)NULL && pTool->IsScannable())
		{
			g_ScannerCache.BeginCache();
			bRetval = pTool->ScanDependencies(this,bWriteOutput);
			g_ScannerCache.EndCache();
		}
	}

	return bRetval;
}

//auto update dep, don't want check in this yet
BOOL CFileItem::UpdateDependencies (CPtrList *pdepList)
{
	// Should not reach this code when using new model.
	ASSERT(!g_bNewUpdateDepModel);

	BOOL bRetval = TRUE;
	CBuildTool * pTool = (CBuildTool *)GetSourceTool();

	if (pTool != (CBuildTool *)NULL && pTool->IsScannable())
	{
		bRetval = pTool->UpdateDependencies(this, pdepList);
	}

	return bRetval;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CFileItem::WriteMakeFileDependencies (CMakFileWriter& mw, CNameMunger& nm, BOOL bPerConfig)
{
    // This is where you can write out per-config dep info, e.g.
    // take a look at CFileItem's override.

    const CDir& BaseDir = GetProject()->GetWorkspaceDir();

    ConfigurationRecord * pcr = GetActiveConfig();
    ASSERT(pcr != (ConfigurationRecord *)NULL);

	CActionSlobList * pActions = pcr->GetActionList();
	if (pActions->IsEmpty())
		return TRUE;	// ignore

	ASSERT(pActions->GetCount() == 1);

	CActionSlob * pAction = (CActionSlob *)pActions->GetHead();
	CBuildTool * pTool = pAction->m_pTool;

	CString strDeps, strDepMacro;
	if (!mw.IsMakefile())
	{
	// no need to write deps for internal project if
	// MRE deps are supported
	if ((!mw.IsDepFile()) && (pTool->DontWriteDependencies(pcr)))
		return TRUE;

	CFileRegSet * pregsetScanned = pAction->GetScannedDep();
#if 0
	// Not used.
	CFileRegSet * pregsetSource = pAction->GetSourceDep();
#endif
	CFileRegSet * pregsetMissing = pAction->GetMissingDep();


	// write the dependencies macro which is used by all the tools?
#ifndef REFCOUNT_WORK
	if (!pregsetScanned->GetContent()->IsEmpty())
#else
	if ((!pregsetScanned->IsEmpty())
// FAST_EXPORT
		 || (bPerConfig && (!GetProject()->m_bProj_PerConfigDeps) && ScanDependencies(TRUE, FALSE) && (!(pregsetScanned = pAction->GetScannedDep())->IsEmpty()))
// FAST_EXPORT
		)
#endif
	{
		// start text
        strDeps = _TEXT("\\\r\n\t");

		// add scanned dependencies?
#ifndef REFCOUNT_WORK
		if (!pregsetScanned->GetContent()->IsEmpty())
#endif
		{
			MakeQuotedString(
						pregsetScanned,
						strDeps,
						&BaseDir,
						TRUE,
						NULL,
						NULL,
						_TEXT("\\\r\n\t"),
						FALSE, NULL,	// all, not outdir relative
						TRUE			// sort output
						);
			// need an extra separator if scanned dependencies is not null
			strDeps += _TEXT("\\\r\n\t"); 
		}
    }

// FAST_EXPORT
	m_bAlwaysWriteDepMacro = ((!bPerConfig) && (!GetProject()->m_bProj_PerConfigDeps) && (!strDeps.IsEmpty()));
// FAST_EXPORT

	// have any dependencies to write out?
	if (!strDeps.IsEmpty())
	{
		if (mw.IsDepFile())
		{
			// CObList lstItem;
			// pTool->GetTargets(pAction, lstItem, strTargets, FALSE);
			// REVIEW: copy from static
			mw.WriteDesc(strSrc, strDeps);
		}
		else if (GetDependenciesMacro(DEP_Scanned, strDepMacro, nm))
		{
		// write out on macro lines 'DEP_CPP_FOOBAR = '
			mw.WriteMacro(strDepMacro, strDeps);
		}
	}

	if (!mw.IsDepFile())
	{
#ifndef REFCOUNT_WORK
	if (!pregsetMissing->GetContent()->IsEmpty())
#else
	if (!pregsetMissing->IsEmpty())
#endif
	{
		// start text
        strDeps = _TEXT("\\\r\n\t");

		// add scanned dependencies?
#ifndef REFCOUNT_WORK
		if (!pregsetMissing->GetContent()->IsEmpty())
#endif
		{
			MakeQuotedString(
						pregsetMissing,
						strDeps,
						&BaseDir,
						TRUE,
						NULL,
						NULL,
						_TEXT("\\\r\n\t"),
						FALSE, NULL,	// all, not outdir relative
						TRUE			// sort output
						);
			// need an extra separator if missing dependencies is not null
			strDeps += _TEXT("\\\r\n\t"); 
		}

		// write out on macro lines 'NODEP_CPP_FOOBAR = '
		if (GetDependenciesMacro(DEP_Missing, strDepMacro, nm))
			mw.WriteMacro(strDepMacro, strDeps);
	}
	}	// !IsDepFile()

	}	// !IsMakefile()

	if (!mw.IsDepFile())
	{
		//
		// Code for handling User-defined dependencies
		//
		if (valid == GetStrProp(P_UserDefinedDeps, strDeps) )
		{
			if (!strDeps.IsEmpty())
			{
				// write out on macro lines 'NODEP_CPP_FOOBAR = '
				if (GetDependenciesMacro(DEP_UserDefined, strDepMacro, nm))
					mw.WriteMacro(strDepMacro, strDeps);
			}
		}
	}

    return TRUE;
}

BOOL CFileItem::WriteToMakeFile
( 
	CMakFileWriter& pw, 
	CMakFileWriter& mw, 
	const CDir &BaseDir,
	CNameMunger& nm
)
{
	// FUTURE (karlsi): remove BaseDir and just use CProject::GetProjDir()
	ASSERT(BaseDir==GetProject()->GetWorkspaceDir());

	int i, size;
	CString str, strOut;
	ConfigurationRecord *pcr;
	BOOL bNamedTool= FALSE;
	BOOL bHasTool= FALSE;
	CBuildTool * pBuildTool = NULL;
	const TCHAR *pc = GetNamePrefix (this);

	PFILE_TRACE ("CFileItem \"%s\" at %p writing to CMakFileWriter at %p\n",
				(const TCHAR *)	*GetFilePath(),this, &mw);
	
	TRY			  
	{
		if (g_bWriteProject)
		{
			// pw.WriteSeperatorString ();
			pw.WriteCommentEx ("Begin %s", pc);
			pw.EndLine ();
		}
		if (g_bExportMakefile)
		{
			// mw.WriteSeperatorString ();
			// pw.EndLine ();
		}
		
		strSrc = m_strOrgPath;
		if (strSrc.IsEmpty())	// REVIEW: additional validation required
			GetMoniker(strSrc);
		else {
			CString strDummy;
			GetMoniker(strDummy);
		}

		if (::ScanPathForSpecialCharacters(strSrc)){
			TCHAR *szSrcNoQuote = StripQuotes( strSrc );
			CString strSrcNoQuote = szSrcNoQuote;
			strSrc = _T('\"') + strSrcNoQuote + _T('\"');
			delete szSrcNoQuote;
		}
		
		// Examine all of our configs and see if in any of them we
		// have a tool with a name.  If there are any, then we'll need
		// a dpendencies macro:
		size = GetPropBagCount();
		for (i = 0; i < size; i++)
		{
			pcr = (ConfigurationRecord *) m_ConfigArray[i];
			ASSERT_VALID (pcr);
			pBuildTool = pcr->GetBuildTool();
			if (pBuildTool != NULL)
			{ 
				bHasTool = TRUE;
				if (!pBuildTool->GetName()->IsEmpty()) 
				{
					bNamedTool = TRUE; 
					break;
				}
			}
		}

		if (g_bWriteProject)
			pw.WriteMacro ( pcFileMacroName, strSrc );	

		if (g_bExportMakefile && bHasTool)
			mw.WriteMacro ( pcFileMacroName, strSrc );	

#if 0	// breaks things
//#ifdef _DEBUG
		ConfigurationRecord * pcr = GetActiveConfig();
		const ConfigurationRecord * pcrSaveBase = pcr->m_pBaseRecord;
#endif
		if (!g_buildfile.WriteToolForNMake(this, &nm))
			AfxThrowFileException(CFileException::generic);
#if 0
// #ifdef _DEBUG
		ASSERT(pcr == GetActiveConfig());
		ASSERT(pcrSaveBase == pcr->m_pBaseRecord);
#endif

		if (g_bWriteProject)
			pw.WriteCommentEx ( "%s %s", EndToken, pc);
	}
	CATCH(CException, e)
	{
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
//	Read in this file from the makefile reader
//

struct Pair {
	CObject *pObject;
	ConfigurationRecord *pcr;
	CBuildTool *pTool;
};


BOOL CFileItem::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
	CPtrList ListMacros;
	BOOL bPerConfigDeps = TRUE, bPerConfigDesc = TRUE;
	TCHAR *pBase, *pTokenEnd;
	CObject *pObject = NULL;
	Pair *pPair;

	PFILE_TRACE ("CFileItem at %p reading from CMakFileWriter at %p\n",
														this, &mr);
	TRY
	{
		// The next element better be a comment marking our start:
		pObject = mr.GetNextElement ();
		ASSERT (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)));

		delete pObject;

		// The next item should be a macro with our file name:
		pObject = mr.GetNextElement ();
		if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakMacro))
				||
			((CMakMacro*) pObject)->m_strName.CompareNoCase (pcFileMacroName)
			)  AfxThrowFileException (CFileException::generic);

		// This is the accpeted way to get a mungable pointer a CString's
		// data.  Note we never call ReleaseBuffer:

		pBase =	((CMakMacro*) pObject)->m_strValue.GetBuffer (1);	
		SkipWhite (pBase);
		GetMakToken (pBase, pTokenEnd);

		*pTokenEnd = _T('\0');

		CPath cpFile;
		m_strOrgPath = pBase;

		// translate $(MACRO_NAME) here.
		CString strBase = pBase;
		if( !ReplaceEnvVars(strBase) ){
			strBase = pBase;
		}
		
		if (pBase == pTokenEnd ||
			!cpFile.CreateFromDirAndRelative (BaseDir, strBase))
			AfxThrowFileException (CFileException::generic);

		// preserve relative path if it begins with "..\"
		// if ((pBase[0] == _T('.')) && (pBase[1] == _T('.')))
		cpFile.SetAlwaysRelative();

		if (!SetFile(&cpFile, TRUE))
			AfxThrowFileException (CFileException::generic);

		delete pObject;

		m_cp = EndOfConfigs;
	   	for (pObject = mr.GetNextElement(); !IsEndToken(pObject); pObject = mr.GetNextElement())
	   	{
			if (IsPropComment(pObject) || IsAddSubtractComment(pObject))
				continue;

			if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				const TCHAR * pMacName = (const TCHAR *)((CMakMacro *)pObject)->m_strName;
				
				// Per-config deps.?
				if (_tcsnicmp("DEP_", pMacName, 4) == 0 ||
					_tcsnicmp("NODEP_", pMacName, 6) == 0 ||
					_tcsnicmp(_TEXT("USERDEP_"), pMacName, 8) == 0) // user-defined dependency
				{
					if (m_cp == EndOfConfigs)
						bPerConfigDeps = FALSE;
				}

				// Got a tool macro, store it away for later processing, after
				// we have created all the actions
				pPair = new Pair;
				pPair->pObject = pObject;
				pPair->pcr = GetActiveConfig();
				pPair->pTool = g_pBuildTool;
				ListMacros.AddTail( pPair );

				pObject = (CObject *)NULL;
				continue;
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				// Got a tool desc. block macro, store it away for later processing, after
				// we have created all the actions
				if (m_cp == EndOfConfigs)
					bPerConfigDesc = FALSE;

				pPair = new Pair;
				pPair->pObject = pObject;
				pPair->pcr = GetActiveConfig();
				pPair->pTool = NULL;
				ListMacros.AddTail( pPair );

				pObject = (CObject *)NULL;
				continue;
			}

			if (pObject->IsKindOf(RUNTIME_CLASS(CMakDirective))) 
			{
				// Setup this configuration
				ReadConfigurationIfDef((CMakDirective *)pObject);
			}

	   		delete pObject; pObject = (CObject *)NULL;
		}				 

		// Make sure we got a file name:
		ASSERT (GetFilePath () != NULL);

		// Do rest of the move
		(void)PostMoveItem(GetContainer(), (CSlob *)NULL, FALSE, TRUE, FALSE);

		//
		// Process tool macros now
		//
 		ConfigurationRecord * pcr;
		CProject * pProject = GetProject();
		CProjTempConfigChange projTempConfigChange(pProject);

		while( !ListMacros.IsEmpty() )
		{
			pPair =(Pair *)ListMacros.RemoveHead();
			pObject = pPair->pObject;
			pcr = pPair->pcr;
			g_pBuildTool = pPair->pTool;
			delete pPair;

			// Make sure we're in the right configuration
			projTempConfigChange.ChangeConfig((ConfigurationRecord *)pcr->m_pBaseRecord);

			// Descriptor block or macro?
			if (pObject->IsKindOf(RUNTIME_CLASS(CMakMacro)))
			{
				if (!bPerConfigDeps)
					m_cp = EndOfConfigs;
				else
					m_cp = FirstConfig;

				if (!SuckMacro((CMakMacro *)pObject, BaseDir, TRUE))
					AfxThrowFileException(CFileException::generic);
			}
			else
			{
				if (!bPerConfigDesc)
					m_cp = EndOfConfigs;
				else
					m_cp = FirstConfig;

				if (!SuckDescBlk((CMakDescBlk *)pObject))
					AfxThrowFileException(CFileException::generic);				
			}
				
			delete pObject; pObject = (CObject *)NULL;
		}
	}
	CATCH ( CException, e)
	{
		// free the object that we were working on when the exception occured.
		if (pObject != (CObject *)NULL)
		{
	   		delete pObject; pObject = (CObject *)NULL;
		}

		// free all Tool macros that we hadn't processed yet.
		while( !ListMacros.IsEmpty() )
		{
			pPair = (Pair *)ListMacros.RemoveHead();
			delete pPair->pObject;
			delete pPair;
		}
		
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}

BOOL CFileItem::CanAct(ACTION_TYPE action)
{
	if (action == act_delete || action == act_cut
#define FILE_RENAME_SUPPORTED
#ifdef FILE_RENAME_SUPPORTED
	 	|| action == act_rename
#endif
		)
		return (!g_Spawner.SpawnActive());

    // File items can be dragged into CTargetItems and CProjGroups
    if (action == act_drag)
        return TRUE;

	return CProjItem::CanAct(action);
}

BOOL CFileItem::PreAct(ACTION_TYPE action)
{
	if (action == act_delete || action == act_cut)
	{
		COleRef<IPkgProject> pPkgProj = NULL;
		VERIFY(SUCCEEDED(g_BldSysIFace.GetPkgProject((HBUILDER)GetProject(), &pPkgProj)));
		NOTIFYINFO notify;
		notify.pPkgProject = pPkgProj;
		notify.hFileSet = (HFILESET)GetTarget();
		notify.lstFiles.AddTail((CPath*)GetFilePath());

		BOOL bRetVal = theApp.NotifyPackages(PN_QUERY_DEL_FILE, (void *)&notify);

		notify.lstFiles.RemoveAll();
	
		return bRetVal;
	}

    if (action == act_drag)
        return TRUE;

	return CProjItem::PreAct(action);
}

///////////////////////////////////////////////////////////////////////////////
//
// ---------------------------	CDependencyFile -------------------------------
//
///////////////////////////////////////////////////////////////////////////////
#define theClass CDependencyFile
BEGIN_SLOBPROP_MAP(CDependencyFile, CProjItem)
END_SLOBPROP_MAP()
#undef theClass

BOOL CDependencyFile::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// WARNING! This does not fall through to a message map.  You must
	// handle both CN_COMMAND and CN_UPDATE_COMMAND_UI if you want your
	// commands to be enabled.

	if (nCode == CN_COMMAND && pExtra == NULL)
	{
		if (nID == IDM_PROJITEM_OPEN)
		{
			OnOpen();
			return TRUE;
		}
	}
	else if (nCode == CN_UPDATE_COMMAND_UI)
	{
		ASSERT(pExtra != NULL);
		CCmdUI* pCmdUI = (CCmdUI*)pExtra;
		ASSERT(pCmdUI->m_nID == nID);           // sanity assert

		if (nID == IDM_PROJITEM_OPEN)
		{
			pCmdUI->Enable(TRUE);
			return TRUE;
		}
	}

	// pass on to the default handler
	return CProjItem::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

CDependencyFile::CDependencyFile()
{
	m_hndFileReg = NULL;
 
 	// the Project Window icon inset
	m_nIconIdx = 3;

	// display name dirty to begin with
	m_fDisplayName_Dirty = TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands
void CDependencyFile::OnOpen()
{
	const CPath * pPath = g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFilePath();
	ASSERT(pPath != (const CPath *)NULL);

	// cannot open a file that would be opened as
	// a project [DOLPHIN bug #13674]
	CDocument * pDocument = NULL;
	theApp.LockRecentFileList(TRUE);
	theApp.OpenDocumentFile(*g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFilePath());
	theApp.LockRecentFileList(FALSE);
}

BOOL CDependencyFile::SetFile(const CPath *pPath, BOOL bCaseApproved /*=FALSE*/) 
{
	FileRegHandle hndFileRegOld = m_hndFileReg;

	// add a reference to the new file
#ifndef REFCOUNT_WORK
	m_hndFileReg = g_FileRegistry.RegisterFile(pPath, !bCaseApproved);
#else
	m_hndFileReg = CFileRegFile::GetFileHandle(*pPath);
#endif

	// remove the reference to the old file
	if (hndFileRegOld)
#ifndef REFCOUNT_WORK
		g_FileRegistry.ReleaseRegRef(hndFileRegOld);
#else
	hndFileRegOld->ReleaseFRHRef();
#endif

	return m_hndFileReg != NULL;
}

GPT CDependencyFile::GetStrProp(UINT idProp, CString& val)
{
	// is this a fake prop?
	switch (idProp)
	{
		case P_ProjItemName:	// yes
			if (m_fDisplayName_Dirty)
			{
				ASSERT(m_hndFileReg != NULL);
				m_strDisplayName = (g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFilePath())->GetFileName ();
				m_fDisplayName_Dirty = FALSE;
			}
			val = m_strDisplayName;
			return valid;

		case P_ProjItemFullPath:
			ASSERT(m_hndFileReg != NULL);
			val = (const TCHAR*) *g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFilePath();
			return valid;

		case P_ProjItemDate:
			{
				FILETIME ft;
				CTime time;

				ASSERT(m_hndFileReg != NULL);
				if (g_FileRegistry.GetRegEntry(m_hndFileReg)->GetFileTime(ft))
				{		 
					time = ft;
					CString strDate = theApp.m_CPLReg.Format(time, DATE_ALL);
					CString strTime = theApp.m_CPLReg.Format(time, TIME_ALL);
					val = strTime + _TEXT(" ") + strDate;
				}
				else
					VERIFY(val.LoadString(IDS_FILE_ITEM_NONEXISTANT));
				return valid;
			}
	}

	// no, pass on to base class
	return CProjItem::GetStrProp(idProp, val);
}

BOOL CDependencyFile::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// go down the project from pContainer to find where we should go
	if (fToPrj)
	{
		if (pContainer->IsKindOf(RUNTIME_CLASS(CProjContainer)) &&
			!pContainer->IsKindOf(RUNTIME_CLASS(CDependencyContainer)))
		{
			pContainer = ((CProjContainer *)pContainer)->GetDependencyContainer(TRUE);

			// if no depedency container then we can't do this!
			if (pContainer == (CSlob *)NULL)
				return FALSE;
		}
	}

	// do the base-class thing
	return CProjItem::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged);
}

void CDependencyFile::SetFileRegHandle(FileRegHandle hndFileReg)
{
	m_fDisplayName_Dirty = TRUE;	// need to refresh this cache

#ifdef REFCOUNT_WORK
	FileRegHandle oldfrh = m_hndFileReg;
#endif

	m_hndFileReg = hndFileReg;
#ifndef REFCOUNT_WORK
	g_FileRegistry.AddRegRef(hndFileReg); 
#else
	hndFileReg->AddFRHRef();
	if (NULL!=oldfrh)
		oldfrh->ReleaseFRHRef();
#endif
}

BOOL CDependencyFile::CanAct(ACTION_TYPE action)
{
	switch (action)
	{
	case act_insert_into_undo_slob:
	case act_delete:
	case act_cut:
		return FALSE;

	case act_drag: // File items can be dragged into CTargetItems and CProjGroups
		return TRUE;

	case act_copy:	// UNDONE: make this work
	case act_paste:
        return FALSE;
	}

	return CProjItem::CanAct(action);
}

BOOL CDependencyFile::SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption)
{
	AddPropertyPage(&g_DepGeneralPage, this);

	if( bSetCaption )
		SetPropertyCaption(CString(MAKEINTRESOURCE(IDS_DEPFILE)));

	return TRUE;
}

void CDependencyFile::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	if (!(fo & flt_ExcludeDependencies))
	{
		fAddItem = TRUE;
		fAddContent = TRUE;
	}
}

BOOL CDependencyFile::SetSlobProp(UINT idProp, CSlob * val)
{
#if 1
	// only interested in container property changes
	if (idProp != P_Container)
		// pass on to the base-class
		return CProjItem::SetSlobProp(idProp, val);

	// old container?
	CSlob * pOldContainer = m_pContainer; 
	if ((val != NULL) && ((val->IsKindOf(RUNTIME_CLASS(CProjGroup))) || (val->IsKindOf(RUNTIME_CLASS(CTargetItem)))))
	{
		CFileItem * pItem = new CFileItem; // review
		pItem->SetFile(GetFilePath());
		if (pItem->SetSlobProp(idProp, val))
		{
			return CProjItem::SetSlobProp(idProp, NULL);
		}
		else
		{
			delete pItem;
			return FALSE;
		}
	}
#endif
	return CProjItem::SetSlobProp(idProp, val);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\project.h ===
///////////////////////////////////////////////////////////////////////////////
//
// PROJECT.H
//                                                                             
///////////////////////////////////////////////////////////////////////////////
#ifndef __PROJECT_H__
#define __PROJECT_H__


// make sure we define this before the CProject et al
#include "bldiface.h"
#include <afxmt.h>		// for CCriticalSection

#include <prjapi.h>
#include <bldguid.h>

#define IDD_PROPSTEST                   113

#ifndef __SHLDOCS_H__
#include "shldocs.h"
#endif

#ifndef __PROPPAGE_H___
#include "proppage.h"
#endif
 
#ifndef __PROJITEM__
#include "projitem.h"
#endif

#ifdef _INSTRAPI
#ifndef __INSTRAPI__H
#include "instrapi.h"
#endif
#endif

#ifndef _TARGETITEM_H
#include "targitem.h"
#endif

// Switch to turn on the External makefile files list:
#define EXT_FILES

// Debug-only flag to turn on "project info" prop pages:
#ifdef _DEBUG
extern	BOOL	g_bProjDebugInfo;
#endif

// Debug-only flag to turn on a debug "project view"
#ifdef _DEBUG
extern	BOOL	g_bProjDebugView;
#endif

// When build logging is enabled in the build it can be
// temporarily disabled by throwing /Y2 on the command line
#ifdef _BTLOG
extern	BOOL	g_bBuildLogging;
#endif

// Makefile sharability levels
#define SHARE_LOW 0
#define SHARE_NORM 1
#define SHARE_HIGH 2

// Make available in shipping builds also 
extern  BOOL	g_bSpawnTime;

extern  BOOL	g_bInProjClose;

extern BOOL g_bBadConversion;
extern BOOL g_bAlwaysExportMakefile;
extern BOOL g_bAlwaysExportDeps;
extern BOOL g_bExportMakefile;
extern BOOL g_bExportDeps;
extern BOOL g_bWriteProject;
extern BOOL g_bWriteBuildLog;

extern BOOL g_nSharability;
extern BOOL g_bMultiBuild;
extern BOOL g_bStopBuild;

#ifdef _INSTRAPI
extern	LOG	g_ProjectPerfLog;
#endif

HINSTANCE GetResourceHandle();

// All CProject 'exported' functions to other packages should be
// virtual so that cross-DLL function calling indirects through
// the object VTABLE ptr
#define EXPORTED virtual

class CBldPackage;
class CProjectDoc;
class CStateSaver;
class CTempMaker;
class CPlatform;

//  Helper class:
// a list of target includes for a project
class CTargIncl
{
protected:
	struct CItem
	{
		HBLDTARGET m_hTarget;
		CString m_strIncls;
		CItem * m_pNext;
	};
	CItem * m_pHead;
	CCriticalSection m_cs;
	HBUILDER m_hBld;
public:
	CTargIncl();
	~CTargIncl();
	BOOL Lookup (HBLDTARGET hTarget, CString & strIncls);
	void RemoveAll();
	BOOL Remove (HBLDTARGET hTarget);
	void SetAt (HBLDTARGET hTarget, CString & strIncls);
	void Init(HBUILDER hBld);
	void AddTarget (HBLDTARGET hTarget);
};

typedef struct tagPROJDEPREFINFO {
    CProjItem * pProjDep;
    ConfigurationRecord * pcr;
} PROJDEPREFINFO;

typedef PROJDEPREFINFO ConfigurationHandle;

//	Helper functions:

//	Converts the a project file name (.mak etc.) to the corresponding
//	workspace file name (.MDP ):
void ProjNameToWksName(CPath &rPath);

//	Converts the a project file name (.mak etc.) to the corresponding
//	pirvate binary file name (.OPT ):
inline void ProjNameToOptName (CPath &rPath)
{
	ProjNameToWksName(rPath);
	rPath.ChangeExtension(".opt");
}

inline void ProjNameToBinName (CPath &rPath)
{
	// old version for 4.x compatibility only
	rPath.ChangeExtension(WORKSPACE_EXT);
}

inline void BinNameToProjName (CPath &rPath)
{
	rPath.ChangeExtension (BUILDER_EXT);
}

class CProjectInterfaces : public CCmdTarget {
protected:
	BEGIN_INTERFACE_PART(Project, IBSProject)
		INIT_INTERFACE_PART(CProjectInterfaces, Project)
		STDMETHOD(SetDirtyState)(BOOL b);
		STDMETHOD(AddDependentProject)(IBSProject *);
		STDMETHOD(RemoveDependentProject)(IBSProject *);
		STDMETHOD(EnumDependentProjects)(IEnumBSProjects **);
		STDMETHOD(SetCurrentConfiguration)(HCONFIGURATION);
		STDMETHOD(AddConfiguration)(HCONFIGURATION);
		STDMETHOD(RemoveConfiguration)(HCONFIGURATION);
		STDMETHOD(EnumConfigurations)(IEnumConfigurations **);
		STDMETHOD(GetConfigurationName)(HCONFIGURATION,LPOLESTR *);
		STDMETHOD(GetConfigurationPlatform)(HCONFIGURATION,IPlatform **);
		STDMETHOD(Build)(HCONFIGURATION,UINT type);
		STDMETHOD(AssignCustomBuildStep)(HCONFIGURATION,LPBUILDFILE,LPCOLESTR);
		STDMETHOD(RemoveCustomBuildStep)(HCONFIGURATION,LPBUILDFILE);
		STDMETHOD(SetToolSettings)(HCONFIGURATION,LPBUILDFILE);
		STDMETHOD(GetCallingProgramName)(HCONFIGURATION,LPOLESTR *);
		STDMETHOD(GetRunArguments)(HCONFIGURATION,LPOLESTR *);
		STDMETHOD(SetRunArguments)(HCONFIGURATION,LPOLESTR);
		STDMETHOD(GetCProject)(void **pProj);
	END_INTERFACE_PART(Project)

	BEGIN_INTERFACE_PART(ProjectFileManager, IBSProjectFileManager)
		INIT_INTERFACE_PART(CProjectInterfaces, ProjectFileManager)
		STDMETHOD(AddFile)(LPCOLESTR,LPBUILDFILE*);
		STDMETHOD(GetFileSet)(LPBUILDFILESET *);
		STDMETHOD(IsInProject)(LPCOLESTR,LPBUILDFILE*);
		STDMETHOD(IsBuildableFile)(LPBUILDFILE);
		STDMETHOD(IsScanableFile)(LPBUILDFILE);
	END_INTERFACE_PART(ProjectFileManager)

	BEGIN_INTERFACE_PART(RemoteProject, IBSRemoteProject)
		INIT_INTERFACE_PART(CProjectInterfaces, RemoteProject)
		STDMETHOD(GetRemoteTargetName)(HCONFIGURATION, LPCOLESTR*);
		STDMETHOD(SetRemoteTargetName)(HCONFIGURATION, LPCOLESTR);
		STDMETHOD(GetInitialRemoteTarget)(HCONFIGURATION, LPCOLESTR*);
		STDMETHOD(UpdateRemoteTarget)(HCONFIGURATION);
	END_INTERFACE_PART(RemoteProject)
	
	BEGIN_INTERFACE_PART(OptionManager,IBSOptionManager)
		INIT_INTERFACE_PART(CProjectInterfaces, OptionManager)
		STDMETHOD(GetBoolProp)(UINT id,IBuildTool*,LPBUILDFILE,HCONFIGURATION, BOOL *rval);
		STDMETHOD(GetIntProp)(UINT id, IBuildTool*,LPBUILDFILE,HCONFIGURATION, int  *rval);
		STDMETHOD(GetStrProp)(UINT id, IBuildTool*,LPBUILDFILE,HCONFIGURATION, LPOLESTR *rval);
		STDMETHOD(SetBoolProp)(UINT id,IBuildTool*,LPBUILDFILE,HCONFIGURATION, BOOL val);
		STDMETHOD(SetIntProp)(UINT id, IBuildTool*,LPBUILDFILE,HCONFIGURATION, int  val);
		STDMETHOD(SetStrProp)(UINT id, IBuildTool*,LPBUILDFILE,HCONFIGURATION, LPOLESTR val);
	END_INTERFACE_PART(OptionManager)

	BEGIN_INTERFACE_PART(PkgProject,IPkgProject)
		INIT_INTERFACE_PART(CProjectInterfaces, PkgProject)
		STDMETHOD(AddFiles)(LPCOLESTR * pszFileNames, ULONG count, 
					LPCOLESTR szDestinationFolder);
		STDMETHOD(CanAddFile)(LPCOLESTR szFileName, LPCOLESTR szDestinationFolder, BOOL bShowUI);
		STDMETHOD(DeleteFile)(LPCOLESTR szFileName, LPCOLESTR szDestinationFolder);
		STDMETHOD(RenameFile)(LPCOLESTR szOldFileName, LPCOLESTR szSourceFolder,
					LPCOLESTR szNewFileName, LPCOLESTR szDestinationFolder);
		STDMETHOD(CreateFolder)(LPCOLESTR szFolder);
		STDMETHOD(OnActivate)(BOOL bActivate);
		STDMETHOD(GetAutomationObject)(LPDISPATCH *ppAutomationProject);
		STDMETHOD(Delete)(DeletionCause dcCause, BOOL * pbSuccess);
		STDMETHOD(SetDependentProject)(IPkgProject *pDependentProject);
		STDMETHOD(GetClassID)(CLSID * pClsID);
		STDMETHOD(GetProjectInfo)(LPCOLESTR *pszProjName, LPCOLESTR *pszProjFullPath,
					DWORD *pdwPackageID, DWORD *pdwFlags);
                STDMETHOD(GetProjectTypeName)(CString **ppszType);
		STDMETHOD(DrawProjectGlyph)(HDC hDC, LPCRECT pRect) ;
		STDMETHOD(Save)() ;
		STDMETHOD(IsDirty)() ;
		STDMETHOD(GetDefaultFolder)(LPCOLESTR *pszDefaultFolder);
		STDMETHOD(CanBrowseFolders)(BOOL *pbCanBrowse);
		STDMETHOD(BrowseFolders)(LPCOLESTR szStartingFolder,
							LPCOLESTR *pszFolderChosen);
		STDMETHOD(GetAllFolders)(CALPOLESTR *pAllFolders);
		STDMETHOD(GetAssociatedFiles)(CStringArray& outFiles, BOOL selected);
		STDMETHOD(SetDirty)(BOOL bDirty);
		STDMETHOD(GetProjectData)(DWORD dwProp, CString & strVal);
		STDMETHOD(SetProjectData)(DWORD dwProp, LPCSTR szVal);
	END_INTERFACE_PART(PkgProject)

	DECLARE_INTERFACE_MAP()

public:
	CProjectInterfaces();
	~CProjectInterfaces();

	void SetThis( CProject *pProj ){ m_pProject = pProj; };
	CProject *GetProject(){ return m_pProject; };

	LPBSPROJECT GetInterface(void){
		LPBSPROJECT pIProject;
		m_xProject.QueryInterface( IID_IBSProject, (void **)&pIProject );
		return pIProject;
 	};

private:
	CProject *m_pProject;
};


#ifdef VB_MAKEFILES
class VBInfo {
public:
	CString m_IconForm;
	CString m_Startup;
	CString m_HelpFile;
	CString m_Title;
	CString m_Command32;
	CString m_ExeName32;
	CString m_Path32;
	CString m_Name;
	CString m_Type;
	CString m_HelpContextID;
	CString m_CompatibleMode;
	BOOL m_MajorVer;
	BOOL m_MinorVer;
	BOOL m_RevisionVer;
	BOOL m_AutoIncrementVer;
	BOOL m_ServerSupportFiles;
	CString m_VersionCompanyName;
	BOOL m_CompilationType;
	BOOL m_OptimizationType;
	BOOL m_FavorPentiumPro;
	BOOL m_CodeViewDebugInfo;
	BOOL m_NoAliasing;
	BOOL m_BoundsCheck;
	BOOL m_OverflowCheck;
	BOOL m_FlPointCheck;
	BOOL m_FDIVCheck;
	BOOL m_UnroundedFP;
	BOOL m_StartMode;
	BOOL m_Unattended;
	BOOL m_ThreadPerObject;
	int m_MaxNumberOfThreads;
};
#endif

class CEnumConfigurations : public CCmdTarget {
public:
	CEnumConfigurations( CProjItem *pProjItem ){
		m_pos = NULL;
		const CPtrArray * pCfgArray = pProjItem->GetConfigArray();
		m_len = pCfgArray->GetSize();
		m_aConfigs = new ConfigurationHandle[];
		for( int i=0; i<m_len; i++ ) {
			m_aConfigs[i].pProjDep = pProjItem;
			m_aConfigs[i].pcr = (ConfigurationRecord *)(*pCfgArray)[i];
		}
	};

	LPENUMCONFIGURATIONS GetInterface(void){
		LPENUMCONFIGURATIONS pIEnum;
		m_xEnumConfigurations.QueryInterface(IID_IEnumConfigurations, (void **)&pIEnum);
		return pIEnum;
	}

protected:
	BEGIN_INTERFACE_PART(EnumConfigurations, IEnumConfigurations)
		INIT_INTERFACE_PART(CEnumConfigurations, EnumConfigurations)
		STDMETHOD(Next)(THIS_ ULONG celt, HCONFIGURATION *rgelt, ULONG *pceltFetched);
		STDMETHOD(Skip)(THIS_ ULONG celt);
		STDMETHOD(Reset)(THIS);
		STDMETHOD(Clone)(THIS_ IEnumConfigurations **ppenum);
	END_INTERFACE_PART(EnumConfigurations)

	DECLARE_INTERFACE_MAP()

public:
	ConfigurationHandle *m_aConfigs;
	int m_pos;
	int m_len;
};
	


class CEnumDependentProjects : public CCmdTarget {
public:
	CEnumDependentProjects(){
		m_pos = NULL;
		m_pList = NULL;
	};
	LPENUMBSPROJECTS GetInterface(void){
		LPENUMBSPROJECTS pIEnum;
		m_xEnumProjects.QueryInterface(IID_IEnumBSProjects, (void **)&pIEnum);
		return pIEnum;
	}

protected:
	BEGIN_INTERFACE_PART(EnumProjects, IEnumBSProjects)
		INIT_INTERFACE_PART(CEnumDependentProjects, EnumProjects)
		STDMETHOD(Next)(THIS_ ULONG celt, LPBSPROJECT *rgelt, ULONG *pceltFetched);
		STDMETHOD(Skip)(THIS_ ULONG celt);
		STDMETHOD(Reset)(THIS);
		STDMETHOD(Clone)(THIS_ IEnumBSProjects **ppenum);
	END_INTERFACE_PART(EnumProjects)

	DECLARE_INTERFACE_MAP()

private:
	const CPtrList *m_pList;
	POSITION m_pos;
};
	

///////////////////////////////////////////////////////////////////////////////
// What project property page do we want to show
enum ProjSettingsPage
{
	Project_General,				// config. mode etc. (always the first) 
	Project_DebugInfo_Settings		// brings up debug options
};									

///////////////////////////////////////////////////////////////////////////////
class CProjTreeCtl;
class CProjectInterfaces;
class BLD_IFACE CProject : public CProjContainer
{
	friend class CBldPackage;
	friend class CProjectView;
	friend class CBldSysIFace;
	friend class CProjTempConfigChange;
	friend class CProjDeferDirty;
	friend class CProjectInterfaces;
	friend class CProjOptionsDlg;
	friend class CProjItem;

//
//	Top level project class.  May be more than one if there are subprojects.
//
	DECLARE_SERIAL (CProject)

	FileRegHandle   m_hndFileReg;		// File registry for .mak file.
	BOOL m_bPrivateDataInitialized;
	BOOL m_bProjectComplete;
	BOOL m_bNotifyOnChangeConfig;
	BOOL m_bClassWizAddedFiles;			// set by ClassWizard VCPP32 callback
	BOOL m_bPostMakeFileRead;			// TRUE once we have read most of the
										// makefile in, i.e doing post makefile
										// reading stuff

protected:
	// Project commands
	// Shared with OnSettings() and OnPopupSettings()
	void OnSettingsCommon(CSlob * pSelection);

	//{{AFX_MSG(CProject)

	// custom tools top-level menuitem
	afx_msg void OnTools();
	afx_msg void OnUpdateTools(CCmdUI *);
	afx_msg void OnSettings();
	afx_msg void OnConfigurations();
	afx_msg void OnSubprojects();
	afx_msg void OnBuildGraph();
	afx_msg void OnNewGroup();
	afx_msg void OnPopupFilesIntoProject();
	afx_msg void OnCompile();
	afx_msg void OnBuild();
	afx_msg void OnClean();
	afx_msg void OnRebuildAll();
	afx_msg void OnBatchBuild();
	afx_msg void OnStopBuild();
	afx_msg void OnToggleBuild();
	afx_msg void OnScan();
	afx_msg void OnScanAll();
	afx_msg void OnSelectTarget();
	afx_msg void OnSelectConfig();
	afx_msg void OnToolMecr();
	afx_msg void OnCompilePostMsg();
	afx_msg void OnCleanPostMsg();
	afx_msg void OnBuildPostMsg();
	afx_msg void OnRebuildAllPostMsg();
	afx_msg void OnBatchBuildPostMsg();
	afx_msg void OnExport();
	afx_msg void OnProjectWrite();
	afx_msg void OnDumpHeap();
	afx_msg void OnProfile();
	afx_msg void OnUpdateNewGroup(CCmdUI *);
	afx_msg void OnUpdateSettings(CCmdUI *);
	afx_msg void OnUpdateConfigurations(CCmdUI *);
	afx_msg void OnUpdateSubprojects(CCmdUI *);
	afx_msg void OnUpdateSettingsPop(CCmdUI *);
	afx_msg void OnUpdateFilesIntoProject(CCmdUI *);
	afx_msg void OnUpdateBuildGraph(CCmdUI *);
	afx_msg void OnUpdateCompile(CCmdUI *);
	afx_msg void OnUpdateBuild(CCmdUI *);
	afx_msg void OnUpdateClean(CCmdUI *);
	afx_msg void OnUpdateRebuildAll(CCmdUI *);
	afx_msg void OnUpdateBatchBuild(CCmdUI *);
	afx_msg void OnUpdateStopBuild(CCmdUI *);
	afx_msg void OnUpdateToggleBuild(CCmdUI *);
	afx_msg void OnUpdateScan(CCmdUI *);
	afx_msg void OnUpdateScanAll(CCmdUI *);
	afx_msg void OnUpdateToolMecr(CCmdUI *);
	afx_msg void OnUpdateTargetCombo(CCmdUI *);
	afx_msg void OnUpdateConfigCombo(CCmdUI *);
	afx_msg void OnUpdateExport(CCmdUI *);
	afx_msg void OnUpdateProjectWrite(CCmdUI *);
	afx_msg void OnUpdateProfile(CCmdUI *);
	afx_msg void OnUpdateDumpHeap(CCmdUI *);
	afx_msg void OnUpdateUseWebBrowser(CCmdUI *pCmdUI);
	afx_msg void OnUpdateUseTestContainer(CCmdUI *pCmdUI);
	//}}AFX_MSG(CProject)

	virtual BOOL OnCmdMsg(UINT, int, void *, AFX_CMDHANDLERINFO *);

public:
	// constructor
	CProject ();

	// destroy contents
	void Destroy();

	// destructor
	virtual ~CProject();

	// we want to update the content of the 'Project' menu
	// with our deferred commands. these will always exist
	// if a tool has a deferred command, but it may be
	// grayed if that deferred command is not applicable
	// in the current project state
	// by setting fNuke == TRUE, this function will
	// Nuke them all
	void UpdateDeferredCmds(BOOL fNuke);

	virtual BOOL UsesSchmoozeTool () { return TRUE; }

// CSlob methods:
	// The CanAdd method tells us what makes sense for the user to
	// be able to add to this slob container
	// In this case we can add CProjGroup's but nothing else.
	virtual BOOL CanAdd ( CSlob * );

	// The CanAct method tells us what it makes sense for
	// a user to be able to perform a certain action.
	virtual BOOL CanAct(ACTION_TYPE action);

	virtual BOOL SetupPropertyPages(CSlob* pNewSel, BOOL bSetCaption = TRUE);

	// Special CloneConfigs method.  As a subproject, the project tries
	// to switch to a compatible configuartion:
	virtual void CloneConfigs ( const CProjItem *pItem );
	void MatchConfig (const ConfigurationRecord *pcr );

	// Hook GetIntProp & GetStrProp to provide some defaults.
	virtual GPT GetIntProp(UINT idProp, int& val);
	virtual GPT GetStrProp(UINT idProp, CString& val);

	// We want to hook into the SetStrProp so we can catch configuration changes.
	virtual BOOL SetStrProp(UINT idProp, const CString& val);
	virtual BOOL SetIntProp(UINT idProp, int val);

	// Ad/remove ourselves as a dependent of the project view.
	virtual BOOL PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);
	virtual BOOL PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged);

	// This is our internal CanAdd method, and tells us what we can
	// add to this slob container
	// In this case we can add CProjGroup's but nothing else.
	virtual BOOL CanContain(CSlob* pSlob);	

	// Drop and Drag support
	virtual CSlobDragger * CreateDragger(CSlob *pDragObject, CPoint screenPoint);
	virtual void DoDrop(CSlob *pSlob, CSlobDragger *pDragger);
	virtual void DoDrag(CSlob *pSlob, CSlobDragger *pDragger, CPoint screenPoint);

	// File I/O and creation:
	// Fills out a new project:
	BOOL InitNew (const CPtrList * pProjTypeList); // Uses a temporary file.
	BOOL InitFromFile (const char *pFileName, BOOL bLoadOPTFile = TRUE);

	void InitPrivateData();	// not needed for new projects
	void InitPrivateDataForExe ();

	BOOL DoSave (BOOL bSavePrivate = FALSE);
	BOOL DoSaveAs (BOOL bSavePrivate = FALSE);

	virtual BOOL SetFile (const CPath *pPath, BOOL bCaseApproved = FALSE);

	virtual BOOL DoTopLevelScan(BOOL bWriteOutput = TRUE);

	// Describes how we flatten a project node
	virtual void FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem);
private:	
	// Targets remaining to build when doing a batch build
	CStringList	m_BuildConfigs;
	CDir		m_ProjDir;

public:
	CDir & GetWorkspaceDir() { return m_ProjDir; }
	CDir & GetProjDir(ConfigurationRecord * pcr = NULL);

	virtual FileRegHandle GetFileRegHandle () const { return m_hndFileReg; };

// Other API:
	// Return the project's resources for the specified configuration,
	// (or the current active if pcr = NULL)
	EXPORTED BOOL GetResourceFileList(CObList & filelist, BOOL fOnlyBuildable = FALSE, const ConfigurationRecord *pcr = NULL);

	// Return the project's resource /I (includes) + Include Path for the specified
	// resource file. Returns TRUE if can do, or FALSE if resource file not valid
	EXPORTED BOOL GetResourceIncludePath(CFileItem * pResFile, CString & strIncludes); 

	// Get version info for App studio:
	EXPORTED void GetVersionInfo(PROJECT_VERSION_INFO* ppvi);

	// Show a particular project settings page
	EXPORTED BOOL ShowProjSettingsPage(ProjSettingsPage prjpage);
		
	// Setup the project's envirnoment variables:
	EXPORTED void GetEnvironmentVariables (CEnvironmentVariableList *pEnvList);
	// Get the project's toolset
	EXPORTED INT GetProjectToolset();

	//	Build the project, starting at the specified item (which
	//	may be the project itself):

	enum BuildResults
	{
		BuildComplete,
		BuildCanceled,
		BuildError,
		NoBuild,
	};

	enum BuildType
	{
		Compile,
		NormalBuild,
		BatchBuild,
	};

	virtual BuildResults DoBuild
	(
		CProjItem * pItemStart,
		UINT buildType,
		BOOL bContinueAfterErrors,
		FlagsChangedAction & fca,
		CTempMaker & rTM,
		CErrorContext& EC = g_DummyEC,
		BuildType bBuildType = NormalBuild,
		BOOL bVerbose = TRUE,
		BOOL bRecurse = TRUE
	);

	BuildStates GetBuildStateForTool
	(
		CSchmoozeTool * pSTool,
		CFileRegSet & regsetConsumables,
		CErrorContext & EC = g_DummyEC
	);

	virtual BOOL TopLevelRunDeferedBuildTool(CSchmoozeTool *pTool, BOOL fAlways = FALSE);

	// Special methods for the IDE to access project info.  Note that
	// these all need to be EXPORTED (ie. virtual) since the IDE doesn't link with 
	// us:

	// Check to see if the specified file is in the project.  If so,
	// return a pointer to the CProjItem.  If not, the behavior
	// depends on the value of bAddIfNecessary.  If bAddIfNecessary
	// is TRUE, the user is prompted to add the file.  If the user
	// answers Yes, the file is added and a pointer to its resulting
	// CProjItem is returned.  If the user answers No, this method
	// returns NULL.  If bAddIfNecessary is FALSE, this method will
	// immediately return NULL if the file isn't in the project.
	//
	// If the same file is present multiple times in the project
	// (e.g., in different groups -- we don't permit it to be present
	// multiple times in a single group), the returned CProjItem will
	// simply be the first one found.
	EXPORTED CProjItem * EnsureFileInProject(CPath * pPath, BOOL bAddIfNecessary);
	// Refigure project state before a debug step or whatever:
	EXPORTED void SetProjectState ();
	// Scan all deps:
	EXPORTED void ScanAllDependencies();
	// Scan deps for a particular item (must be a CFileItem).  Returns
	// FALSE if the scan failed for any reason (like the file isn't of
	// scannable type).  You can get a pointer to the CFileItem by using
	// EnsureFileInProject(pPathFileName, FALSE).
	EXPORTED BOOL ScanItemDependencies(CFileItem *);
	// Returns or'ed together ProjAttribtues (get this from the 
	// CProjType)
	EXPORTED int GetTargetAttributes ();
	// Returns exe to debug (if there is one):
	EXPORTED CPath *GetTargetFileName ();
	// Are we trying to build the calling program?:
	EXPORTED BOOL TargetIsCaller ();
	// Returns .BSC file (if there is one):
	EXPORTED const CPath *GetBrowserDatabaseName ();
	// Returns name of calling program (DLL project types only):
	EXPORTED void GetCallingProgramName (CString &str);
	// Returns the working directory for the calling program:
	EXPORTED void GetWorkingDirectory (CString &str);
	// Returns argument string for debuggee (EXE project types only):
	EXPORTED void GetProgramRunArguments (CString &str);
	EXPORTED void SetProgramRunArguments (CString &str);
	// Should we prompt user for local name of future remote DLL's that are loaded?
	EXPORTED BOOL FPromptForDlls (void);
	EXPORTED VOID SetPromptForDlls (BOOL);

	// Name of the class wizard .clw file
	EXPORTED BOOL ClassWizardName (CPath &path);

	// Attempts to update our remote target
	EXPORTED BOOL UpdateRemoteTarget();

	// Display a dialog to obtain the initial remote target
	// file name. This is used when the remote target file name is
	// blank and we really, really need it. E.G. when attempting
	// to debug, or run a remote copy utility (mfile)
	EXPORTED BOOL GetInitialRemoteTarget(BOOL bBuild = FALSE, BOOL fAlways = FALSE);

	// Display a dialog to obtain the executable file
	// name for debugging/executing.
	EXPORTED BOOL GetInitialExeForDebug(BOOL bExecute = FALSE);

	// Returns the name of the remote target
	EXPORTED void GetRemoteTargetFileName (CString &str);
	EXPORTED void SetRemoteTargetFileName (CString &str);

	// Add this file to the first group in the project (adding a
	// group if nessesary), but don't scan:
	EXPORTED void AddFile (const CPath *pPath );
	// Is this file used in this project:
	EXPORTED BOOL IsProjectFile (const CPath *pPath );
	// Is this an external project:
	EXPORTED BOOL IsExeProject () const;

	// Is the active target an external target
	EXPORTED BOOL IsExternalTarget();

	// exported version of OnNewGroup (accessed from CBuildSlob)
	EXPORTED void CreateNewGroup() { OnNewGroup(); }
	// exported version of OnPopupFilesIntoProject (accessed from CBuildSlob)
	EXPORTED void ActPopupFilesIntoProject() { OnPopupFilesIntoProject(); }
	// exported version of OnUpdateFilesIntoProject (accessed from CBuildSlob)
	EXPORTED void UpdPopupFilesIntoProject(CCmdUI *pCmdUI) { OnUpdateFilesIntoProject(pCmdUI); }

	BOOL AreFilesUnique(const CSlob * pSlob, BOOL bTopLevel = TRUE);
	
	// check if P_Profile is set or not
	// this method is created so that vcpp32\c\qcqp.c
	// can access this property w/o accessing the P_Profile
	// directly
	EXPORTED BOOL IsProfileEnabled();

private:
	// Build helpers:
	BuildResults BuildAsExternalMakefile(BOOL bBuildAll, CErrorContext & EC = g_DummyEC); 

	BuildResults RunSchmoozeTool
	(
		CSchmoozeTool * pTool, 
		BOOL bContinueAfterErrors,
		CDir & rMyDir,
		CTempMaker & rTM,
		CErrorContext& EC
	);

public:		
	// Get the OPT File name
	void GetOPTFileName(CPath & MSFPath);
	
	// Save the project's private data:
	BOOL LoadFromOPT(CStateSaver& stateSave);
	BOOL SaveToOPT(CStateSaver& stateSave);
	
	// Convert the external stream when converting an external makefile
	// to an internal makefile
	BOOL ConvertOPTFile(CArchive & ar);

protected:
	BOOL LoadExternalFromOPT(CStateSaver& stateSave, BOOL bIsExternal);
	BOOL LoadInternalFromOPT(CStateSaver& stateSave, BOOL bIsExternal,BOOL bWorkspace);
	BOOL SaveExternalToOPT(CStateSaver& stateSave, BOOL bIsExternal);
	BOOL SaveInternalToOPT(CStateSaver& stateSave, BOOL bIsExternal,BOOL bWorkspace);

	// Helper for setting props when converting OPT file.
	BOOL SetStrPropConfigs(CPtrList * plstpcr, UINT idProp, const CString& val);
	BOOL SetIntPropConfigs(CPtrList * plstpcr, UINT idProp, int val);

	HGLOBAL m_hOPTData;

public:
	// Read/write makefile.  Assume file name has already been set:
	enum ReadMakeResults
	{
		ReadExternal,
		ReadInternal,
		ReadError,
		ReadExportedMakefile,
	};

	// .MAK reading
	ReadMakeResults ReadMakeFile (BOOL& bProjectDirty);
	virtual BOOL ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir);
#ifdef VB_MAKEFILES
	void OpenVBProject(const TCHAR *szFileName);
#endif
	
	// Read and write comments listing what configurations there are and
	// what project types they reference.  Also write our the current active
	// configuration and read it back in:
	BOOL WriteConfigurationHeader(CMakFileWriter& mw);
	BOOL ReadConfigurationHeader(CMakFileReader& mr);

	// Process ALL : <targets> line
	BOOL ReadMasterDepsLine(CMakDescBlk * pObject, const CDir & BaseDir);

#ifdef EXT_FILES
	BOOL BuildFilesList ();
#endif

	// TRUE if the .MAK file was read-only last time we checked.  Of
	// course, its state may have changed; call RecheckReadOnly()
	// to update this variable with a check of the file on disk.
	BOOL		m_bProjWasReadOnly;

private:
	BOOL IsCustomBuildMacroComment(CObject* pObject);
	BOOL ReadCustomBuildMacros(CMakFileReader& mr);
	BOOL WriteCustomBuildMacros(CMakFileWriter& mw, CString &strFiles );

public:		
	// Set m_bProjWasReadOnly to FALSE.  Useful after warning the user about
	// a project being read-only.
	void		ResetReadOnly() { m_bProjWasReadOnly = FALSE; }

	// Set the value of m_bProjWasReadOnly by checking the .MAK file
	// on disk to see if it's read-only or not.
	void		RecheckReadOnly() { m_bProjWasReadOnly = GetFilePath()->IsReadOnlyOnDisk(); }

	// TRUE if the project was read-only last time we looked.  This
	// state can be 'refreshed' by calling RecheckReadOnly().
	BOOL		WasReadOnly() const { return m_bProjWasReadOnly; }

	// Write the all : <all targets> line.
	// Public because it gets called in CProjItem::WriteToolsSection()
	// If you don't want a particular target on the all line then
	// you can filter it out in FilterMasterDepsLine.
	friend BOOL FilterMasterDepsLine(DWORD dw, FileRegHandle frh);
	BOOL WriteMasterDepsLine(CMakFileWriter& mw, const CDir &BaseDir, BOOL bPostBuildDep = FALSE );

	// our configuration information
	CString		m_strProjActiveConfiguration;
	CString		m_strProjDefaultConfiguration; // CFG= line from makefile
	CString		m_strProjStartupConfiguration; // Primary/Supported cfg from makefile
	
	// Makefile has been freshly converted from an external makefile
	BOOL		m_bProjExtConverted;

	// This flag tells us whether this is a special "exe project" -- that is,
	// the user loaded an exe file in order to debug it and we created a temporary
	// external project for him.  This generally behaves like an external makefile
	// EXCEPT that we don't mess with any corresponding OPT file.
	BOOL		m_bProjIsExe;

	// Makefile has been freshly converted from an 'old' makefile version
	BOOL		m_bProjConverted;

	// Cached flag indicating whether project has at least one supported config
	// This needs to be adjusted anywhere a project configuration can be
	// created or deleted, such as in makefile reading and the targets dialog.
	BOOL		m_bProjIsSupported;

	void GetName(CString &strName ){ 
		ConfigurationRecord * pcr = GetActiveConfig();
		if(pcr)
			pcr->GetProjectName(strName);
	};

	CString		m_strProjItemName;
	CString		m_strProjSccProjName;
	CString		m_strProjSccRelLocalPath;

	// Special properties that are only set when read in from the makefile.
	BOOL		m_bProjMarkedForScan;
	BOOL		m_bProjMarkedForSave;	// can be set by AppWizard
	BOOL		m_bProjHasNoOPTFile;
	BOOL		m_bCareAboutRCFiles;	
	BOOL		m_bCareAboutDefFiles;
	BOOL		m_bProj_PerConfigDeps;

	// delete configuration named strName, and changed the active configuration
	// to strNewConfig.
	// strNewConfig configuration must already exist in the configuration map.
	BOOL	DeleteConfig ( const CString& strName , const CString& strNewConfig = "");

	// Create a new congugration.  Note that creation is a three step process:
	// 1. Create new config.  2. Initizlize new configs type and so on.
	// 2. Make new config active (even if you'll deactivate immediadly)
	BOOL 	CreateConfig ( const CString& strName );

	// CTargIncl: a list of per-target includes maintained by the project (ie: duplicates
	// from the properties) so that we can forward this information to the parser when
	// it calls ResolveIncludeDirectives() without Changing Configuration (the list
	// is protected by a critical section):
	CTargIncl	m_listTargIncl;
protected:
	ConfigurationRecord *CreateConfigRecordForConfig(
												const CString & strConfig);
	DECLARE_SLOBPROP_MAP()

public:
	// Return the platform object corresponding to the current target.
	EXPORTED CPlatform * GetCurrentPlatform();

	// Update the browser database file
	EXPORTED UpdateBrowserDatabase();

	// Makefile errored during open due to requirement to use MFC and MFC is not installed
	BOOL		m_bGotUseMFCError;

	// The Configuration manager api
	//
	// Set the currently active target configuration
	// If 'fQuite' is TRUE then no UI changes will be apparent.
	ConfigurationRecord * SetActiveConfig(ConfigurationRecord *, BOOL fQuite = TRUE);
	ConfigurationRecord * SetActiveConfig(const CString& strConfigName, BOOL fQuite = TRUE);

	// The Target manager api
	//
	// Get the target item associated with a given target name
 	CTargetItem* GetTarget(const TCHAR * pchTargetName);

	// Get the target item corresponding to the currently selected config
	CTargetItem* GetActiveTarget();

	// Register a target with the target manager. This is used during
	// project loading only
	BOOL RegisterTarget(const CString& strTargetName, CTargetItem* pTarget);

	// De-register a target with the target manager.
	BOOL DeregisterTarget(const CString& strTargetName, CTargetItem* pTarget);

	// Rename a target already registered with the target manager.
	BOOL RenameTarget(const CString& strTargetFrom, const CString& strTargetTo);

	// Creates a new target (actually creates a new config and a new
	// CTargetItem)
	BOOL CreateTarget(const CString& strTargetName, CProjType* pProjType, const CString& strMirrorFrom = _T(""));

	// Deletes an existing target
	BOOL DeleteTarget(const CString& strTargetName);

	ConfigurationRecord * FindTargetConfig(CString & strTargetName);

	// Target enumeration
	void InitTargetEnum() { m_posTarget = m_TargetMap.GetStartPosition(); }
	BOOL NextTargetEnum(CString& strTargetName, CTargetItem* & pTarget)
	{
		if (m_posTarget == (POSITION)NULL)
			return FALSE;
		m_TargetMap.GetNextAssoc(m_posTarget, strTargetName, (void* &)pTarget);

		// 2173: need to get name with correct case preserved
		VERIFY(FindTargetConfig(strTargetName)!=NULL);

		return TRUE;
	}

private:

	// This map contains the names of targets and the corresponding
	// CTargetItem ptrs.
	CMapStringToPtr m_TargetMap;
	POSITION		m_posTarget;

    // The project dirty flag. Corresponds to old project doc dirty flag
protected:
    BOOL    m_bProjectDirty;    // Is this project object dirty??
private:
    BOOL    m_bOkToDirty;       // Ok to dirty project

    COptionTreeCtl *    m_pOptTreeCtl;  // The Build.Settings 'view' (if active)    
	virtual void DirtyProjectEx();

	CRITICAL_SECTION m_critSection;

public:

    // Project dirty flag access functions
	__inline void DirtyProject()
	{
		if ((!m_bProjectDirty) && (m_bOkToDirty) && (!g_bInProjClose))
			DirtyProjectEx();
		m_bDirtyDeferred = !m_bProjectDirty;
	}
	__inline void CleanProject()
	{
		m_bProjectDirty = m_bDirtyDeferred = FALSE;
	}
	__inline BOOL IsDirty()
	{
		return m_bProjectDirty;
	}
	__inline BOOL IsOkToDirty()
	{
		return (m_bOkToDirty && !g_bInProjClose);
	}
	__inline BOOL IsDirtyDeferred()
	{
		return m_bDirtyDeferred;
	}

	__inline void SetOkToDirtyProject(BOOL bOk = TRUE)
	{
		m_bOkToDirty = bOk;
	}

	__inline void SetOptionTreeCtl(COptionTreeCtl * pOptTreeCtl)
	{
		m_pOptTreeCtl = pOptTreeCtl;
	}
	__inline COptionTreeCtl * GetOptionTreeCtl()
	{
		return m_pOptTreeCtl;
	}
    
	// Add/Delete file notification batching project wide. That is
	// if you want all notifications project wide to be batched use
	// these apis, rather than using the similar target item apis.
	__inline static void BeginBatch()
	{
		m_nBatch++;
	};
	void static EndBatch();
	BOOL IsNotifyBatching()
	{
		return (m_nBatch > 0);
	};

private:
	static int m_nBatch;
	BOOL m_bSettingsChanged;

public:
	// .MAK reading (conversion of old VC++ 2.0 projects)
	BOOL m_bConvertedVC20;
	// .MAK reading (conversion of old DS 4.x projects)
	BOOL m_bConvertedDS4x;
	// .DSP reading (conversion of old DS 5.x projects)
	BOOL m_bConvertedDS5x;
	CDir m_ActiveTargDir;

	CPath GetMrePath(ConfigurationRecord* pcr);
private:
	BOOL    m_bDirtyDeferred;   // Mark dirty, but do it "later"
	int		m_nDeferred;		// ref counting

public:
static const CObList * GetProjectList() { return &m_lstProjects; }
static void InitProjectEnum();
static const CProject * NextProjectEnum(CString & strBuilder, BOOL bOnlyLoaded = TRUE);
static void GlobalCleanup();
__inline BOOL IsLoaded() const { return m_bProjectComplete; /* REVIEW */ }
public:

private:
static POSITION m_posProjects;
static CObList m_lstProjects;

public:
	void ReleaseInterface( void ){
		if( m_pIProject ) {
			pCIProject->SetThis( NULL );
			m_pIProject->Release();
			m_pIProject = NULL;
		}
	};

	LPBSPROJECT GetInterface(void){
		if( m_pIProject ) {
			m_pIProject->AddRef();
		} else {
			pCIProject = new CProjectInterfaces;
			m_pIProject = pCIProject->GetInterface();
			pCIProject->SetThis(this);
		}
		return m_pIProject;
	}

private:
	LPBSPROJECT 		m_pIProject;
	CProjectInterfaces *pCIProject;

public:
	CProjConfigEnum m_ConfigEnum;

// Java interfaces:
public:
	// Java: return the class name to debug
	EXPORTED void GetJavaClassName(CString& str);
	// Java: return the full path to the class file
	EXPORTED BOOL GetJavaClassFileName(CString& str);
	// Java: return the tool to debug under
	EXPORTED int GetJavaDebugUsing();
	// Java: return the browser
	EXPORTED void GetJavaBrowser(CString& str);
	// Java: return the stand-alone interpreter
	EXPORTED void GetJavaStandalone(CString& str);
	// Java: return the stand-alone interpreter arguments
	EXPORTED void GetJavaStandaloneArgs(CString& str);
	// Java: return the HTML page
	EXPORTED BOOL GetJavaHTMLPage(CString& str);
	// Java: get the class path
	EXPORTED void GetJavaClassPath(CString& str);
	// Java: get the type of stand-alone debugging
	EXPORTED int GetJavaStandaloneDebug();

	// Display a dialog to obtain the class file and/or
	// app type for Java debugging/executing.
	EXPORTED BOOL GetInitialJavaInfoForDebug(BOOL bExecute = FALSE);


	// Used to read/convert old VC 4.x and prior .mdp/.vcp files
	BOOL LoadFromVCP(CStateSaver& stateSave);

protected:
	EXPORTED BOOL GetPreCompiledHeaderName(CString &strPch );
	BOOL LoadExternalFromVCP(CStateSaver& stateSave, BOOL bIsExternal);
	BOOL LoadInternalFromVCP(CStateSaver& stateSave, BOOL bIsExternal);
	BOOL ConvertVCPFile(CArchive & ar);
	BOOL ConvertDirs();
public:
	UINT GetGlyphIndex();
	const CString & GetTargetName();
	__inline void SetTargetName(const CString & str) { m_strTargetName = str; }
private:
	CString m_strTargetName;
	BOOL m_bPrivateDataInitializedFromOptFile;

public:
	static CString s_strWebBrowser;
	static CString s_strTestContainer;
	int m_nScannedConfigIndex;
	int GetScannedConfigIndex() { return m_nScannedConfigIndex; }
#ifdef VB_MAKEFILES
public:
	BOOL m_bVB;
	CString m_strVBProjFile;
	VBInfo *m_pVBinfo;
#endif
};	  


class BLD_IFACE CProjDeferDirty 
{
public:
	CProjDeferDirty(CProject * pProject)
		{
			m_pProject = pProject;
			if (m_pProject!=NULL)
			{
				
				m_pProject->m_nDeferred++;
				m_bWasOk = m_pProject->IsOkToDirty();
				m_pProject->SetOkToDirtyProject(FALSE);
			}

		}
	~CProjDeferDirty()
		{
			if (m_pProject!=NULL)
			{
				m_pProject->SetOkToDirtyProject(m_bWasOk);
				if ((--(m_pProject->m_nDeferred)==0) && (m_bWasOk) && (m_pProject->IsDirtyDeferred()))
					m_pProject->DirtyProject();
			}
		}
private:
	CProject * m_pProject;
	BOOL m_bWasOk;
};

// This object is to used whenever the project's configuration needs to be changed
// temporarily. Do not call SetActiveConfig directly, unless you want to permanently 
// change the active configuration. Declare a local instance of this object and call
// 'ChangeConfig' on it. The destructor of this object will restore the original config
// back. The primary purpose of this is to make the calls to SetActiveConfig thread safe.

class BLD_IFACE CProjTempConfigChange 
{
public:
	CProjTempConfigChange(CProject *pProject);
	// Will Release critical section and reset to original config.
	~CProjTempConfigChange();

	VOID ChangeConfig(ConfigurationRecord *);
	VOID ChangeConfig(const CString& strName);

	// Resets config to the original one, still holds the crit section.
	VOID Reset();	

	// releases critical section, if bReset is TRUE also resets to original config.
	VOID Release(BOOL bReset = TRUE); 

	CProject * m_pProject;

private:
	ConfigurationRecord * m_pcrOriginal;
	BOOL m_bCritSection ; // Do we have the critical section currently.
};


// This object is used when the active project needs to be temporarly changed
// usually during the build of a sub project.

class BLD_IFACE CProjTempProjectChange 
{
public:
	CProjTempProjectChange (CProject *pProject);
	~CProjTempProjectChange ();

	VOID Release (); 

	CProject *m_pPrevProject;
};

// This object is used when the UI display state needs to be disabled and rer enabled.

class BLD_IFACE CTempDisableUI
{
public:
	CTempDisableUI();
	~CTempDisableUI();
	BOOL m_bOldUI;
};


extern CProject *g_pActiveProject;
extern CProject *g_pConvertedProject;

// REVIEW: This should be made a member of CProject before Version 5.0
// as should g_pProjSysIFace. 4.1 restrictions make changes to CProject difficult
// at this time.  KPerry
extern LPPROJECTWORKSPACE g_pProjWksIFace;
extern LPPROJECTWORKSPACEWINDOW g_pProjWksWinIFace;
extern LPSOURCECONTROL g_pSccManager;

__inline LPPROJECTWORKSPACE FindProjWksIFace()
{
	ASSERT(g_pProjWksIFace != NULL);
	return(g_pProjWksIFace);
}
 
__inline LPPROJECTWORKSPACEWINDOW FindProjWksWinIFace()
{
	ASSERT(g_pProjWksWinIFace != NULL);
	return(g_pProjWksWinIFace);
}

#endif // __PROJECT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\vc6addon\ide\pkgs\bld\src\project.cpp ===
//
//	PROJECT.CPP
//
///////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#pragma hdrstop
#include <regstr.h>
#include "projcomp.h"
#include "dirmgr.h"
#include "resource.h"
#include "targdlg.h"
#include "optndlg.h"
#include "toolsdlg.h"
#include "batchdlg.h"
#include "miscdlg.h"
#include "exttarg.h"
#include "targctrl.h"
#include "bldslob.h"
#include "vwslob.h"
#include "bldnode.h"
#include "toolcplr.h"
#include "oleref.h"

#include <utilbld_.h>
#include <prjapi.h>
#include <prjguid.h>

#include "bldrfile.h"	// our CBuildFile

#ifdef DEPGRAPH_VIEW
#include "grview.h"		// our dependency graph view
#endif

#include "depgraph.h"	// our dependency graph
#include "awiface.h"    // appwz constants
#include "prjdlg.h"     // CNewProjectCopyDlg
#include "updepdlg.h"
#include "configs.h"

#include "optnlink.h"	// to include P_Profile constant
#include "toolbsc.h"		// so we can do bscmake even if link fails
#include "optnmtl.h"		// so we can automatically add /mktyplib203
#include "optnrc.h"
#include "optnlib.h"

#include "mrdepend.h"
#include "autoprj.h"

#include <bldapi.h>

#include "profdlg.h"
#include "projitem.h"

#include "utilauto.h" // For g_pAutomationState 

LPPROJECTWORKSPACE g_pProjWksIFace = NULL;
LPPROJECTWORKSPACEWINDOW g_pProjWksWinIFace = NULL;

LPSOURCECONTROL g_pSccManager = NULL;

IMPLEMENT_SERIAL (CProject, CProjContainer, SLOB_SCHEMA_VERSION)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

extern void RefreshTargetCombos(BOOL bEmpty = FALSE);


extern BOOL __cdecl DumpHeap();
extern CProjComponentMgr g_prjcompmgr;
extern CTestableSection g_sectionDepUpdateQ;
extern CTestableSection g_sectionFileChangeQ;
extern BOOL g_bFileDepULQInUse;
extern BOOL g_bHTMLLog;
extern BOOL g_bInProjLoad; // defined in pfilereg.cpp
extern UINT g_nNextIncompatibleVersion;	// defined in vproj.cpp
//extern BOOL LoadOPTFile ( const CPath* pPath, CProject *pAssociatedProject  );
//extern BOOL SaveOPTFile ( const CPath* pPath, CProject *pAssociatedProject );
extern CPackage * g_pBuildPackage; // defined in vproj.cpp
BOOL   g_bInProjClose=FALSE;
BOOL g_bNoUI = FALSE;
extern CBuildTool *g_pLastTool;  // defined in projitem.cpp

int CProject::m_nBatch = 0;
CProject * g_pConvertedProject = NULL;
BOOL g_bConvDontTranslate = FALSE;

BOOL GetPlatformDescriptionString(CString & strExeName, CString & strPlatDesc, BOOL * pbIsJava = NULL);

// {180C58F2-F704-11cf-927C-00A0C9138C45}
static const CLSID BuildProjCLSID = 
{ 0x180c58f2, 0xf704, 0x11cf, { 0x92, 0x7c, 0x0, 0xa0, 0xc9, 0x13, 0x8c, 0x45 } };

// REVIEW: find a better home for these

BOOL g_bBadConversion = FALSE;
BOOL g_bAlwaysExportMakefile = FALSE;
BOOL g_bAlwaysExportDeps = FALSE;
BOOL g_bExportMakefile = FALSE;
BOOL g_bExportDeps = FALSE;
BOOL g_bWriteProject = FALSE;
BOOL g_bWriteBuildLog = FALSE;
BOOL g_bAllowFastExport = FALSE;  // NYI
int  g_nSharability = SHARE_NORM;
int  g_nBuildProcessors = 1;
BOOL g_bErrorPrompted = FALSE;
BOOL g_bConversionPrompted = FALSE;
BOOL g_bConversionCanceled = FALSE;

// Java: private helper functions for Java functionality
BOOL GetBrowserPath(CString& strBrowserPath);
BOOL GetStandalonePath(CString& strStandalonePath);

void InitExternalDepFolders()
{
	CProject * pProject;
	CProject::InitProjectEnum();
	CString strProject;
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
	{
		ConfigurationRecord* pcrBase;
		CProjTempConfigChange projTempConfigChange(pProject);

		int nSize = pProject->GetConfigArray()->GetSize();
		for (int nConfig = 0; nConfig < nSize; nConfig++)
		{
			pcrBase = (ConfigurationRecord *)(*pProject->GetConfigArray())[nConfig];
			if (pcrBase->IsBuildable())	// only do this for supported/buildable configs
			{
				projTempConfigChange.ChangeConfig(pcrBase);
				BOOL bNeedsDepUpdate = FALSE;
				if (valid==pProject->GetIntProp(P_HasExternalDeps,bNeedsDepUpdate) && bNeedsDepUpdate)
				{
					CTargetItem* pTarget = pProject->GetActiveTarget();
					if (NULL!=pTarget)
						pTarget->SetIntProp(P_TargNeedsDepUpdate,TRUE);
				}
			
				pProject->RefreshDependencyContainer();
			}
		}
	}
}

// lifted from CFileSaver
static void RemoveFileIfPossible(LPCTSTR szFileName)
{
	TRY
	{
		CFile::Remove(szFileName);
	}
	CATCH_ALL(e)
	{
		// Just silently ignore if we cant remove the file.
	}
	END_CATCH_ALL
}

///////////////////////////////////////////////////////////////////////////////
//
// --------------------------------- CProject ---------------------------------
//
///////////////////////////////////////////////////////////////////////////////
//
//	Top level project class.  May be more than one if there are subprojects.
//

#define theClass CProject
BEGIN_SLOBPROP_MAP(CProject, CProjContainer)
	STR_PROP(ProjActiveConfiguration)
	STR_PROP (ProjItemName)
	BOOL_PROP(ProjMarkedForScan)
	BOOL_PROP(ProjMarkedForSave)
	BOOL_PROP(ProjHasNoOPTFile)
END_SLOBPROP_MAP()
#undef theClass

CString CProject::s_strWebBrowser;
CString CProject::s_strTestContainer;

BOOL CProject::OnCmdMsg(UINT nID, int nCode, void* pExtra,
	AFX_CMDHANDLERINFO* pHandlerInfo)
{
	// Enable deffered build tools items, don't do this for external projects!
	if	(!m_bProjIsExe &&
		 nCode == CN_UPDATE_COMMAND_UI &&
		 (nID >=IDM_PROJECT_TOOL_CMD_FIRST && nID <= IDM_PROJECT_TOOL_CMD_LAST)
		)
	{
		BOOL fAllowSchmoozeCmd = g_Spawner.CanSpawn();
		// Set menu text for the deferable Schmooze tools.  Get the tools
		// project type and iterate through the tools list, looking for
		// CSchmmooze tools.  For each one, ask it if its defereble.  If it
		// is, and its menu ID matches the one we want to update, then
		// go ahead and do the menu text update
		const CPtrList * pol = GetProjType ()->GetToolsList ();
		for (POSITION pos = pol->GetHeadPosition(); pos != NULL;)
		{
			CBuildTool * pTool = (CBuildTool *)pol->GetNext (pos);
			if (pTool->m_fDeferredTool && (pTool->GetMenuID() == nID))
			{
				CActionSlob action(this, pTool);

				CString str;
				(void)pTool->DeferredAction(&action, &str);
				if (!str.IsEmpty())
				{
					((CCmdUI *)pExtra)->SetText(str);
					break;	// found a match, there are no duplicates
				}
			}
		}

		((CCmdUI *)pExtra)->Enable(fAllowSchmoozeCmd);
		return TRUE;
	}

	// Is this a menu item to activate a defered schmooze tool?
	// We don't place these menu cmds on the menu popup for external
	// projects so this will never be invoked for external projects
	if (nCode == CN_COMMAND	&& pExtra == NULL &&
		(nID >=IDM_PROJECT_TOOL_CMD_FIRST && nID <=	IDM_PROJECT_TOOL_CMD_LAST)
	   )
	{
		ASSERT(!m_bProjIsExe);

		POSITION pos;
		const CPtrList * pol;
		CSchmoozeTool * pTool;
		CString str;

		// Bail if we're already doing a build:
		if (g_Spawner.SpawnActive()) return TRUE;

		pol = GetProjType ()->GetToolsList ();
		for ( pos = pol->GetHeadPosition(); pos != NULL; )
		{
			pTool = (CSchmoozeTool *) pol->GetNext (pos);
			if (!pTool->IsKindOf(RUNTIME_CLASS(CSchmoozeTool)))
				continue;
			if (pTool->GetMenuID ()== nID)
			{
				TopLevelRunDeferedBuildTool (pTool);
				return TRUE;
			}
		}

	}

	// WARNING! This does not fall through to a message map.  You must
	// handle both CN_COMMAND, and CN_UPDATE_COMMAND_UI if you want your
	// commands to be enabled.

	if (nCode == CN_COMMAND && pExtra == NULL)
	{
		switch (nID)
		{
		S_ON_COMMAND(IDM_PROJECT_DEFAULT_PROJ, OnSelectTarget)
#ifdef DEPGRAPH_VIEW
		S_ON_COMMAND(IDM_PROJECT_BUILDGRAPH, OnBuildGraph)
#endif // DEPGRAPH_VIEW
		S_ON_COMMAND(IDM_PROJECT_SETTINGS, OnSettings)
		S_ON_COMMAND(IDM_DEBUG_SETTINGS, OnSettings)
		S_ON_COMMAND(IDM_PROJECT_CONFIGURATIONS, OnConfigurations)
		S_ON_COMMAND(IDM_PROJECT_SUBPROJECTS, OnSubprojects)
		S_ON_COMMAND(IDM_PROJECT_TOOLS, OnTools)
		S_ON_COMMAND(IDM_PROJITEM_ADD_GROUP, OnNewGroup)
		S_ON_COMMAND(IDM_PROJECT_SETTINGS_POP, OnSettings)
		S_ON_COMMAND(IDM_INSERT_FILES_POP, OnPopupFilesIntoProject)
		S_ON_COMMAND(IDM_PROJITEM_COMPILE, OnCompilePostMsg)
		S_ON_COMMAND(IDM_PROJITEM_BUILD, OnBuildPostMsg)
		S_ON_COMMAND(IDM_PROJITEM_REBUILD_ALL, OnRebuildAllPostMsg)
		S_ON_COMMAND(IDM_PROJITEM_BATCH_BUILD, OnBatchBuildPostMsg)
		S_ON_COMMAND(IDM_PROJECT_STOP_BUILD, OnStopBuild)
		S_ON_COMMAND(IDM_BUILD_TOGGLE, OnToggleBuild)
		S_ON_COMMAND(IDM_PROJITEM_SCAN, OnScan)
		S_ON_COMMAND(IDM_PROJECT_SCAN_ALL, OnScanAll)
		S_ON_COMMAND(IDM_PROJECT_TOOL_MECR, OnToolMecr)
		S_ON_COMMAND(ID_TARGET_COMBO, OnSelectTarget)
		S_ON_COMMAND(ID_CONFIG_COMBO, OnSelectConfig)
		S_ON_COMMAND(ID_PROJITEM_COMPILE, OnCompile)
		S_ON_COMMAND(ID_PROJITEM_BUILD, OnBuild)
		S_ON_COMMAND(IDM_PROJECT_CLEAN_ACTIVE, OnClean)
		S_ON_COMMAND(ID_PROJITEM_REBUILD_ALL, OnRebuildAll)
		S_ON_COMMAND(ID_PROJITEM_BATCH_BUILD, OnBatchBuild)
		S_ON_COMMAND(IDM_PROJECT_EXPORT, OnExport)
		S_ON_COMMAND(IDM_PROJECT_WRITE, OnProjectWrite)
		S_ON_COMMAND(IDM_RUN_PROFILE, OnProfile)
		S_ON_COMMAND(IDM_DUMP_HEAP, OnDumpHeap)

		}
	}
	else if (nCode == CN_UPDATE_COMMAND_UI)
	{
		ASSERT(pExtra != NULL);
		CCmdUI* pCmdUI = (CCmdUI*)pExtra;
		ASSERT(pCmdUI->m_nID == nID);           // sanity assert

		switch (nID)
		{
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_DEFAULT_PROJ, OnUpdateTargetCombo)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJITEM_ADD_GROUP, OnUpdateNewGroup)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_SETTINGS, OnUpdateSettings)
		S_ON_UPDATE_COMMAND_UI(IDM_DEBUG_SETTINGS, OnUpdateSettings)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_CONFIGURATIONS, OnUpdateConfigurations)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_SUBPROJECTS, OnUpdateSubprojects)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_SETTINGS_POP, OnUpdateSettingsPop)
		S_ON_UPDATE_COMMAND_UI(IDM_INSERT_FILES_POP, OnUpdateFilesIntoProject)
#ifdef DEPGRAPH_VIEW
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_BUILDGRAPH, OnUpdateBuildGraph)
#endif // DEPGRAPH_VIEW
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_TOOLS, OnUpdateTools)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJITEM_COMPILE, OnUpdateCompile)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJITEM_BUILD, OnUpdateBuild)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_CLEAN_ACTIVE, OnUpdateClean)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJITEM_BATCH_BUILD, OnUpdateBatchBuild)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJITEM_REBUILD_ALL, OnUpdateRebuildAll)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_STOP_BUILD, OnUpdateStopBuild)
		S_ON_UPDATE_COMMAND_UI(IDM_BUILD_TOGGLE, OnUpdateToggleBuild)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJITEM_SCAN, OnUpdateScan)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_SCAN_ALL, OnUpdateScanAll)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_TOOL_MECR, OnUpdateToolMecr)
		S_ON_UPDATE_COMMAND_UI(ID_TARGET_COMBO, OnUpdateTargetCombo)
		S_ON_UPDATE_COMMAND_UI(ID_CONFIG_COMBO, OnUpdateConfigCombo)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_EXPORT, OnUpdateExport)
		S_ON_UPDATE_COMMAND_UI(IDM_PROJECT_WRITE, OnUpdateProjectWrite)
		S_ON_UPDATE_COMMAND_UI(IDM_RUN_PROFILE, OnUpdateProfile)
		S_ON_UPDATE_COMMAND_UI(IDM_DUMP_HEAP, OnUpdateDumpHeap)
		S_ON_UPDATE_COMMAND_UI(IDM_USE_WEBBROWSER, OnUpdateUseWebBrowser)
		S_ON_UPDATE_COMMAND_UI(IDM_USE_TESTCONTAINER, OnUpdateUseTestContainer)

		case IDM_BROWSE_FOR_DEBUG_EXE:
			pCmdUI->Enable(TRUE); 
			return TRUE;
		}
	}

	// pass on to the default handler
	return CProjContainer::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

void CProject::OnUpdateUseWebBrowser(CCmdUI *pCmdUI)
{
	static bFirst = TRUE;

	if (bFirst)
	{
#if 1
		if (!GetBrowserPath(s_strWebBrowser))
			s_strWebBrowser.Empty();
#else
		HKEY hKey;
		LONG lresult = RegOpenKeyEx(HKEY_CLASSES_ROOT, _T("http\\shell\\open\\command"), 0,
			KEY_READ, &hKey );
		if (ERROR_SUCCESS==lresult)
		{
			TCHAR szPath[2*_MAX_PATH];
			DWORD dwSize = 2*_MAX_PATH*sizeof(TCHAR);
			DWORD dwType;
			lresult = RegQueryValueEx( hKey, _T(""), NULL, &dwType, (LPBYTE)szPath, &dwSize);
			if (ERROR_SUCCESS==lresult && REG_SZ==dwType)
			{
				s_strWebBrowser = szPath;
			}
			VERIFY(ERROR_SUCCESS==RegCloseKey(hKey));

			//
			// Try to remove parameters from command-line.
			// If command line starts with a double quote, remove the double quote and
			// everything after the 2nd quote.
			// If not a double quote, just remove everything after next space.
			// 
			s_strWebBrowser.TrimLeft();
			int iEnd;
			if (0==s_strWebBrowser.Find(_T('"')))
			{
				s_strWebBrowser = s_strWebBrowser.Mid(1);
				iEnd = s_strWebBrowser.Find(_T('"'));
				if (0<iEnd)
					s_strWebBrowser = s_strWebBrowser.Left(iEnd);
			}
			else
			{
				iEnd = s_strWebBrowser.Find(_T("\t "));
				if (0<iEnd)
					s_strWebBrowser = s_strWebBrowser.Left(iEnd);
			}
			s_strWebBrowser.TrimRight();
		}

		//
		// Try to get this string.
		//
		if (s_strWebBrowser.IsEmpty() && !GetBrowserPath(s_strWebBrowser))
			s_strWebBrowser.Empty();
#endif
		bFirst = FALSE;
	}

	pCmdUI->Enable(!s_strWebBrowser.IsEmpty());
}

extern BOOL (WINAPI *g_pGetFileAttributesEx_DevBld)( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation);
__inline BOOL Compatible_GetFileAttributesEx_DevBld( LPCTSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId,
									 LPVOID lpFileInformation)
{
	return (*g_pGetFileAttributesEx_DevBld)( lpFileName, fInfoLevelId, lpFileInformation);
}

static BOOL GetTestContainerName(CString& strTestContainer)
{
	char szPath[2*_MAX_PATH];
	WIN32_FILE_ATTRIBUTE_DATA find;
	LPTSTR temp;
	DWORD dw;
	HKEY hKey;
	int iLastSlash;

	//
	// Search order:
	//	0) shared tools dir
	//	1) vc directory
	//	2) msdev.exe directory
	//	3) Use SearchPath()

	//
	// review(tomse): It would be nice to look in sharedIde\bin for tstcnt32.exe but
	// it can be installed in vc or vj.
	// Instead try looking in the vc path.
	//
	// shared tools dir
	//
	///////////////////////////////////
	// must build this key ourselves.  we can not use theApp.GetRegistryKeyName()
	// as this builds a key that takes into account the /i switch.  since these
	// settings are in HKLM and /i is an HKCU setting, we would end up with 
	// a bogus HKLM path.

	CString strKey = _T("Software\\Microsoft\\Shared Tools\\");
	strKey += _T("tstcon32.exe");

	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, strKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType, cbData = 2*MAX_PATH*sizeof(TCHAR);
		if (RegQueryValueEx (hKey, _T ("Path"), NULL,
				&dwType, (LPBYTE) szPath, &cbData) == ERROR_SUCCESS)
		{
			ASSERT (dwType == REG_SZ);
			szPath [cbData] = 0;
			strTestContainer = szPath;

			if ((!strTestContainer.IsEmpty()) && !Compatible_GetFileAttributesEx_DevBld( (LPCTSTR)strTestContainer, GetFileExInfoStandard, &find))
				strTestContainer.Empty();

		}
		VERIFY(ERROR_SUCCESS==RegCloseKey(hKey));

		if (!strTestContainer.IsEmpty())
			return TRUE;
	}	

	// Try vc\bin
	//
	///////////////////////////////////
	// must build this key ourselves.  we can not use theApp.GetRegistryKeyName()
	// as this builds a key that takes into account the /i switch.  since these
	// settings are in HKLM and /i is an HKCU setting, we would end up with 
	// a bogus HKLM path.

	strKey = _T("Software\\Microsoft\\");
	strKey += theApp.GetExeString(DefaultRegKeyName);
	strKey += _T("\\Products\\");
	strKey += _T("Microsoft Visual C++");

	if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, strKey, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
	{
		DWORD dwType, cbData = 2*MAX_PATH*sizeof(TCHAR);
		if (RegQueryValueEx (hKey, _T ("ProductDir"), NULL,
				&dwType, (LPBYTE) szPath, &cbData) == ERROR_SUCCESS)
		{
			ASSERT (dwType == REG_SZ);
			szPath [cbData] = 0;
			strTestContainer = szPath;

			// append backslash if necessary.
			iLastSlash = strTestContainer.ReverseFind(_T('\\'));
			if (strTestContainer.GetLength() != iLastSlash+1)
				strTestContainer += _T("\\");

			strTestContainer += _T("bin\\tstcon32.exe");
			if (!Compatible_GetFileAttributesEx_DevBld( (LPCTSTR)strTestContainer, GetFileExInfoStandard, &find))
				strTestContainer.Empty();

		}
		VERIFY(ERROR_SUCCESS==RegCloseKey(hKey));

		if (!strTestContainer.IsEmpty())
			return TRUE;
	}	

	//
	// Try msdev.exe directory
	//
	if (GetModuleFileName(NULL, szPath, sizeof(szPath)))
	{
		char szDrive[_MAX_DRIVE], szDir[_MAX_DIR];
		_splitpath(szPath, szDrive, szDir, NULL, NULL);
		_makepath(szPath, szDrive, szDir, _T("tstcon32.exe"), NULL);
	}
	strTestContainer = szPath;

	if (!Compatible_GetFileAttributesEx_DevBld( (LPCTSTR)strTestContainer, GetFileExInfoStandard, &find))
	{
		dw = SearchPath(NULL, _T("tstcon32.exe"),NULL, _MAX_PATH, szPath, &temp);
		if ( 0 < dw && _MAX_PATH > dw )
			strTestContainer = szPath;
		else
			strTestContainer.Empty();
	}

	return (!strTestContainer.IsEmpty());
}

void CProject::OnUpdateUseTestContainer(CCmdUI *pCmdUI)
{
	static bFirst = TRUE;

	if (bFirst)
	{
		if (!GetTestContainerName(s_strTestContainer))
			s_strTestContainer.Empty();

		bFirst = FALSE;
	}
	
	pCmdUI->Enable(!s_strTestContainer.IsEmpty());
}

BOOL ConvertPropPaths(CProjItem * pItem, UINT idIncludes, BOOL bIsDir = TRUE, BOOL bSubstComma = TRUE)
{
	BOOL retval = FALSE;
	CPath path;
	CDir dir;
	path.SetAlwaysRelative();
	CString strIncludes;
	if ((pItem->GetStrProp(idIncludes, strIncludes) == valid) && (!strIncludes.IsEmpty()))
	{
		// convert include paths
		BOOL bChanged = FALSE;
		CString strNewIncludes;
		LPTSTR pOldInclude = strIncludes.GetBuffer(0);
		LPTSTR pszInclude = _tcstok(pOldInclude, _T(",;"));
		while (pszInclude != NULL && *pszInclude != _T('\0'))
		{
			CString strOldPath = pszInclude;
			CString strNewPath;
			BOOL bRelative = ((*pszInclude != _T('\\')) && (*pszInclude != _T('/'))	&& (pszInclude[1] != _T(':')));
			// try to re-relativize this path;
			if (bRelative && (!bIsDir) && (_tcspbrk(pszInclude, _T("\\/"))==NULL))
			{
				// REVIEW: don't treat simple filenames as relative
				bRelative = FALSE;
			}
			BOOL bUsesMacro = (_tcspbrk(pszInclude, _T("$")) != NULL);
			if (bRelative && (!bUsesMacro))
			{
				if (bIsDir)
				{
					LPCTSTR pchLast = _tcsdec(pszInclude, pszInclude + _tcslen(pszInclude));
					if (*pchLast != _T('\\') && *pchLast != _T('/'))
						strOldPath += _T('\\');
					strOldPath += _T('a'); // dummy file name
				}
				if ((path.CreateFromDirAndFilename(g_pConvertedProject->GetWorkspaceDir(), strOldPath)) && (path.GetRelativeName(pItem->GetProject()->GetWorkspaceDir(), strNewPath)) && (strNewPath != strOldPath))
				{
					bChanged = TRUE;
					if (bIsDir)
					{
						int newlen = strNewPath.GetLength() - 2; // remove '\\a" again
						ASSERT(newlen > 0);
						strNewIncludes += strNewPath.Left(newlen);
					}
					else
					{
						strNewIncludes += strNewPath;
					}
				}
				else
				{
					strNewIncludes += pszInclude;
				}
			}
			// validate full paths too to avoid disappointment
			else if (bIsDir && (!bUsesMacro) && (strOldPath.GetLength() > 2 /* avoid 'c:' and '\' cases */) && (dir.CreateFromString(strOldPath)))
			{
				// VC6 #26261: make sure we don't add gratuitous drive letter
				if (_tcsnicmp((LPCTSTR)dir, (LPCTSTR)g_pConvertedProject->GetWorkspaceDir(), 3)==0)
				{
					strNewPath = LPCTSTR(dir) + 2; // strip off drive letter
				}
				else
				{
					strNewPath = dir;
				}
				bChanged =  bChanged || (strOldPath.CompareNoCase(strNewPath) != 0);
				strNewIncludes += strNewPath;
			}
			else
			{
				strNewIncludes += pszInclude;
			}
			
			pszInclude = _tcstok(NULL, _T(",;"));
			if (pszInclude != NULL)
			{
				if (bSubstComma)
					strNewIncludes += _T(',');
				else
					strNewIncludes += _T(';');
			}
		}
		
		strIncludes.ReleaseBuffer(-1);
		if (bChanged)
		{
			retval = TRUE;
			VERIFY(pItem->SetStrProp(idIncludes, strNewIncludes));
		}
	}
	return retval;
}

BOOL CProject::ConvertDirs()
{
	BOOL retval = FALSE;
	ASSERT(m_bConvertedVC20 || m_bConvertedDS4x);
	if (m_bConvertedVC20 || m_bConvertedDS4x)
	{
		COptionHandler * popthdlr;
		VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler), (CBldSysCmp *&)popthdlr));
		UINT idCplrIncludes = popthdlr->MapLogical(P_CplrIncludes);
		UINT idOutputCod = popthdlr->MapLogical(P_OutputDir_Cod);
		UINT idOutputSbr = popthdlr->MapLogical(P_OutputDir_Sbr);
		UINT idOutputPch = popthdlr->MapLogical(P_OutputDir_Pch);
		UINT idOutputObj = popthdlr->MapLogical(P_OutputDir_Obj);
		UINT idOutputPdb = popthdlr->MapLogical(P_OutputDir_Pdb);

		VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_MkTypLib), (CBldSysCmp *&)popthdlr));
		UINT idMTLIncludes = popthdlr->MapLogical(P_MTLIncludes);
		UINT idMTLOutputTlb = popthdlr->MapLogical(P_MTLOutputTlb);
		UINT idMTLOutputInc = popthdlr->MapLogical(P_MTLOutputInc);

		VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_RcCompiler), (CBldSysCmp *&)popthdlr));
		UINT idResIncludes = popthdlr->MapLogical(P_ResIncludes);
		UINT idOutNameRes = popthdlr->MapLogical(P_OutNameRes);

		CObList list;
		FlattenSubtree(list, flt_Normal | flt_ExcludeGroups | flt_ExcludeDependencies | flt_RespectTargetExclude);

		POSITION pos = list.GetHeadPosition();
		CProjItem* pItem;
		while (pos != NULL)
		{
			pItem = (CProjItem *)list.GetNext(pos);
			OptBehaviour optbehOld = pItem->GetOptBehaviour();
			pItem->SetOptBehaviour(optbehOld & ~(OBInherit|OBShowDefault|OBShowFake) | OBShowMacro);

			// call helper function to do the actual work
			// compiler props
			retval = ConvertPropPaths(pItem, idCplrIncludes) || retval;
			retval = ConvertPropPaths(pItem, idOutputCod) || retval;
			retval = ConvertPropPaths(pItem, idOutputSbr) || retval;
			retval = ConvertPropPaths(pItem, idOutputPch) || retval;
			retval = ConvertPropPaths(pItem, idOutputObj) || retval;
			retval = ConvertPropPaths(pItem, idOutputPdb) || retval;

			// mtl props
			retval = ConvertPropPaths(pItem, idMTLIncludes) || retval;
			retval = ConvertPropPaths(pItem, idMTLOutputTlb, FALSE) || retval;
			retval = ConvertPropPaths(pItem, idMTLOutputInc, FALSE) || retval;

			// res props
			retval = ConvertPropPaths(pItem, idResIncludes) || retval;
			retval = ConvertPropPaths(pItem, idOutNameRes, FALSE) || retval;

			// REVIEW: other props to convert?

			if (pItem->IsKindOf(RUNTIME_CLASS(CProject)))
			{
				// project-level only properties

				// linker props
				VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Linker), (CBldSysCmp *&)popthdlr));
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_OutName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_LibPath), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_UsePDBName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_DefName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_ImpLibName), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_MapName), FALSE) || retval;

				// lib props
				VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Lib), (CBldSysCmp *&)popthdlr));
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_DefNameLib), FALSE) || retval;
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_OutNameLib), FALSE) || retval;

				// bscmake props
				VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_BscMake), (CBldSysCmp *&)popthdlr));
				retval = ConvertPropPaths(pItem, popthdlr->MapLogical(P_BscMakeOutputFilename), FALSE) || retval;

				// REVIEW: other props to convert?
			}
			pItem->SetOptBehaviour(optbehOld);
		}
	}
	return retval;  // TRUE iff anything changed
}

CProject::CProject ()
{
	// our current project is us!
	m_pOwnerProject = this;

	m_hndFileReg = NULL;
 	m_bProjIsExe = FALSE;
	m_bClassWizAddedFiles = FALSE;
 	m_bPrivateDataInitialized = FALSE;
	m_bPrivateDataInitializedFromOptFile = FALSE;
	m_bProjectComplete = FALSE;
	m_bNotifyOnChangeConfig = FALSE;
	m_bProjMarkedForScan = FALSE;
	m_bProjMarkedForSave = FALSE;
	m_bProjHasNoOPTFile = FALSE;
	m_bCareAboutRCFiles = TRUE;
	m_bCareAboutDefFiles = TRUE;
	m_bProjWasReadOnly = FALSE;
	m_bProjConverted = FALSE;
	m_bConvertedVC20 = FALSE;
	m_bConvertedDS4x = FALSE;
	m_bConvertedDS5x = FALSE;
	m_bGotUseMFCError = FALSE;
	m_bProjIsSupported = TRUE;	// safe default
	m_hOPTData = NULL;
	m_bProjExtConverted = FALSE;
    m_pOptTreeCtl = NULL;
    m_bOkToDirty = TRUE;
    m_bProjectDirty = FALSE;
	m_bSettingsChanged = FALSE;
	m_bDirtyDeferred = FALSE;
	m_nDeferred = 0;
	m_bPostMakeFileRead = FALSE;
	m_pIProject = NULL;
	m_nScannedConfigIndex = -1;
	m_bProj_PerConfigDeps = FALSE;

#ifdef VB_MAKEFILES
	m_bVB = FALSE;
	m_pVBinfo=NULL;
#endif

 	if (m_lstProjects.IsEmpty()) // init these only for the first project
	{
		g_nIDOptHdlrUnknown = 10; // 0 is reserved fir CCustomBuildTool
		g_nIDToolUnknown = PROJ_PER_CONFIG_UNKNOWN;
		m_nBatch = 0;
	}
	m_lstProjects.AddTail((CObject *)this);

	::InitializeCriticalSection(&m_critSection);
}
///////////////////////////////////////////////////////////////////////////////
void CProject::Destroy()
{
	// destroying our project
	BOOL bOldComplete = m_bProjectComplete;
	BOOL bOldNotify = m_bNotifyOnChangeConfig;
	m_bProjectComplete = m_bNotifyOnChangeConfig = FALSE;
 	m_strProjActiveConfiguration.Empty();
	m_strProjDefaultConfiguration.Empty();
	m_strProjStartupConfiguration.Empty();
   	m_bProjIsSupported = FALSE;	// safe default

	m_bOkToDirty = FALSE; // can't do this from here on...

	// disable file registry file change notification during builder destroy
	BOOL bOldDisable = g_FileRegDisableFC;
	g_FileRegDisableFC = TRUE;

	if (m_bConvertedDS4x)
	{
		m_bConvertedDS4x = FALSE;

		// may also need to delete temp projects
		POSITION pos = CProject::m_lstProjects.GetTailPosition();  // use our own private pos pointer
		while (pos != NULL)
		{
			CProject * pProject = (CProject *)CProject::m_lstProjects.GetPrev(pos);
			if (pProject->m_bConvertedDS4x)
			{
				delete pProject;
			}
		}
	}
	
	// if we are an exe project, 
	// then delete our contents and any fake targets we might have created.
	// else delete each of the targets which in turn
	// will delete their contents
	if (m_bProjIsExe)
	{
		// external, ie. no targets
        HBLDTARGET hTarg;
        hTarg = g_BldSysIFace.GetActiveTarget((HBUILDER)this);
        ASSERT(hTarg != NO_TARGET);
        if( hTarg ){
            g_BldSysIFace.DeleteExeTarget(hTarg);
        }
		// external, ie. no targets
		DeleteContents();
	}
	else
	{
		// internal, ie. we have targets
		CString strTargetName; CTargetItem * pTarget; HBLDTARGET hTarg;
		POSITION pos;
		while ((pos = m_TargetMap.GetStartPosition()) != (POSITION)NULL)
		{
			m_TargetMap.GetNextAssoc(pos, strTargetName, (void* &)pTarget);
            hTarg = g_BldSysIFace.GetTarget(strTargetName, (HBUILDER)this);
            g_BldSysIFace.DeleteTarget(hTarg, (HBUILDER)this);
		}

		// now delete any configs that might not have been registered (read failed early)
		int n = GetPropBagCount();
		ConfigurationRecord * pcr;
		while (n-- > 0)	// work backwards so array is intact
		{
			pcr = (ConfigurationRecord*) m_ConfigArray[n];
			ASSERT(pcr);

			// Perform the delete...
			DeleteConfigFromRecord(pcr);
		}
	}

	// remove the dep update queues
	POSITION pos = g_FileForceUpdateListQ.GetHeadPosition();
	if (pos != (POSITION)NULL)
	{
		while (pos != (POSITION)NULL)
		{
			CDepUpdateRec *pdepRec = (CDepUpdateRec *)g_FileForceUpdateListQ.GetNext(pos);
			//remove the record with same file item and target
			delete pdepRec;
		}
		g_FileForceUpdateListQ.RemoveAll();
	}

	pos = g_FileDepUpdateListQ.GetHeadPosition();
	if (pos != (POSITION)NULL)
	{
		CritSectionT csFC(g_sectionFileChangeQ);
		CritSectionT cs(g_sectionDepUpdateQ);
		if (g_bFileDepULQInUse)
		{
			ASSERT(0);
			m_bProjectComplete = bOldComplete;
			m_bNotifyOnChangeConfig = bOldNotify;
			g_FileRegDisableFC = bOldDisable;
			return;
		}
		else
			g_bFileDepULQInUse = TRUE;
		pos = g_FileDepUpdateListQ.GetHeadPosition(); // must update after Crit
		while (pos != (POSITION)NULL)
		{
			CDepUpdateRec *pdepRec = (CDepUpdateRec *)g_FileDepUpdateListQ.GetNext(pos);
			delete pdepRec;
		} //while

		// done these, remove them
		g_FileDepUpdateListQ.RemoveAll();
	} //if

	// re-enable file registry file change notification
	g_FileRegDisableFC = bOldDisable;
	g_bFileDepULQInUse = FALSE;

	// finished destroying
	// restore previous state
	m_bProjectComplete = bOldComplete;
	m_bNotifyOnChangeConfig = bOldNotify;
}
///////////////////////////////////////////////////////////////////////////////
CProject::~CProject ()
{
	CWaitCursor wc;		// Display hourglass until this object destroyed
	
	if (m_lstProjects.GetCount()==1) // don't do this unless this is the last project!
	{
		g_bInProjClose = TRUE;

		// ** UI **
		// delete our deferred commands from the menu
		UpdateDeferredCmds(TRUE);
	}

	// ** DATA **
	// destroy the contents of the project
	Destroy();

	// ** OTHER DATA **
	// we cannot allow dynamic async. sections to remain registered
	
	// UNDONE: make this per-builder
	CBldrSection * pbldsect;
	g_BldSysIFace.InitSectionEnum();
	CString strName;
	while ((pbldsect = g_BldSysIFace.GetNextSection(strName)) != (CBldrSection *)NULL)
	{
		// dynamic async. sections?
		if (pbldsect->m_pfn == NULL && pbldsect->m_hBld == (HBUILDER)this) // This section must be from this project
		{
			VERIFY(g_BldSysIFace.DeregisterSection((const CBldrSection *)pbldsect));

			if (pbldsect->m_pch != (TCHAR *)NULL)
				free(pbldsect->m_pch);

			delete pbldsect;
		}
  	}

	POSITION pos = m_lstProjects.Find((CObject *)this);
	ASSERT(pos != NULL);
	m_lstProjects.RemoveAt(pos);
	// reset pos to make sure it's still valid
	m_posProjects = m_lstProjects.GetHeadPosition();

	if (m_posProjects == NULL)
		GlobalCleanup();	// only do this for the last project

	if (this == g_pActiveProject)
	{
		CProject * pProject;
		g_pActiveProject = NULL;  	// we may no longer have an active project!
		POSITION pos = m_lstProjects.GetHeadPosition();  // use our own private pos pointer
		while (pos != NULL)
		{
			pProject = (CProject *)m_lstProjects.GetNext(pos);
			if (pProject != NULL)
			{
				ASSERT_VALID(pProject);
				if (pProject->IsLoaded())
				{
					HBLDTARGET hTarget = g_BldSysIFace.GetActiveTarget((HBUILDER)pProject);
					if (hTarget==NO_TARGET)
					{
						CTargetItem * pTargetItem;
						CString strTargetName;
						pProject->InitTargetEnum();
						VERIFY(pProject->NextTargetEnum(strTargetName, pTargetItem));
						hTarget = g_BldSysIFace.GetTarget(strTargetName, (HBUILDER)pProject);
						ASSERT (hTarget);
					}
					g_BldSysIFace.SetActiveTarget(hTarget, (HBUILDER)pProject);
					break;
				}
				else
				{
					g_pActiveProject = pProject; // at least we have one
				}
			}
		}
	}

	::DeleteCriticalSection(&m_critSection);

#ifdef REFCOUNT_WORK
	if (m_hndFileReg)
	{
		m_hndFileReg->ReleaseFRHRef();
		m_hndFileReg = NULL;
	}
#endif
	ReleaseInterface();
	g_LinkAutoObjToProject.OnProjectDestroyed(this);
	g_bInProjClose = FALSE;

}

// this static function gets called only after all CProjects have been destroyed and deleted
void CProject::GlobalCleanup()
{
    // Clear out all unknown tools from all projtypes
    CProjType * pprojtype;
    g_prjcompmgr.InitProjTypeEnum();
    while (g_prjcompmgr.NextProjType(pprojtype))
        pprojtype->ClearUnknownTools();

}

///////////////////////////////////////////////////////////////////////////////
// we want to update the content of the 'Project' menu
// with our deferred commands. these will always exist
// if a tool has a deferred command, but it may be
// grayed if that deferred command is not applicable
// in the current project state
// by setting fNuke == TRUE, this function will
// Nuke them all

void CProject::UpdateDeferredCmds(BOOL fNuke)
{
	ASSERT(g_pBuildPackage != (CPack *)NULL);
	ASSERT(g_pBuildPackage == theApp.GetPackage(PACKAGE_VPROJ));

	// nuke them all
 	for (int nID = IDM_PROJECT_TOOL_CMD_FIRST; nID <= IDM_PROJECT_TOOL_CMD_LAST; nID++)
		g_pBuildPackage->SetVisibleMenuItem(nID, FALSE);

	// do we want to make any visible?
	// don't make any visible if we are external!
	if (fNuke || m_bProjIsExe)	return;	// no

	CProjType * pprojtype = GetProjType();
	if (pprojtype == (CProjType *)NULL)
		return;	// no project type->no commands

	// for all of our schmooze tools for this project type
	// we want to set the menu visible if we have a deferred command
	const CPtrList * pol = pprojtype->GetToolsList();
	for (POSITION pos = pol->GetHeadPosition(); pos != NULL;)
	{
		CBuildTool * pTool = (CBuildTool *)pol->GetNext (pos);
		if (pTool->m_fDeferredTool)
		{
			CActionSlob action(this, pTool);

			CString str;
			(void)pTool->DeferredAction(&action, &str);
			if (!str.IsEmpty())
				g_pBuildPackage->SetVisibleMenuItem(pTool->GetMenuID(), TRUE);
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
CProjItem * CProject::EnsureFileInProject(CPath * pPath, BOOL bAddIfNecessary)
{
	ASSERT(pPath != (CPath *)NULL);

	CFileItem * pItem = (CFileItem *)NULL;

	HFILESET hFileSet = g_BldSysIFace.GetFileSet(ACTIVE_BUILDER, g_BldSysIFace.GetActiveTarget());
	HBLDFILE hFile;
 	if (!g_BldSysIFace.GetFile((const CPath *)pPath, hFile, hFileSet, (HBUILDER)this))
	{
		CString strError;

		// not there?
		// want to add it?
		if (!bAddIfNecessary ||
			MsgBox(Question,
				   MsgText(strError, IDS_NOT_IN_PROJ_QUERY_ADD, pPath->GetFileName()),
				   MB_YESNO) == IDNO
		   )
			return (CProjItem *)NULL;

		hFile = g_BldSysIFace.AddFile(hFileSet, (const CPath *)pPath);
	}

	if (hFile != NO_FILE)
		pItem = g_BldSysIFace.CnvHBldFile(hFileSet, hFile);

	return pItem;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::SetFile (const CPath *pPath, BOOL  /* = FALSE */)
{
	ASSERT(pPath != (const CPath *)NULL);
	ASSERT(pPath->IsInit());

	if (m_hndFileReg)
#ifndef REFCOUNT_WORK
		g_FileRegistry.ReleaseRegRef (m_hndFileReg);
		
	if ((m_hndFileReg = g_FileRegistry.RegisterFile(pPath, TRUE)) != NULL)
#else
		m_hndFileReg->ReleaseFRHRef();
		
	if ((m_hndFileReg = CFileRegFile::GetFileHandle(*pPath)) != NULL)
#endif
	{
		// get new title as well
		char buf[_MAX_FNAME];
		if (::GetFileTitle((const char *) *GetFilePath(), buf, _MAX_FNAME)==0)
			m_strProjItemName = buf;
		else
			m_strProjItemName = GetFilePath()->GetFileName();

		// init m_ProjDir here as well
		VERIFY(m_ProjDir.CreateFromPath(*GetFilePath()));

		m_ActiveTargDir = m_ProjDir;

		// make sure we're watching file-changes
		// we force this even if we're reading the .mak
		// in which case g_FileRegDisableFC == TRUE
		BOOL oldFileRegDisableFC = g_FileRegDisableFC;
		g_FileRegDisableFC = FALSE;
		BOOL fDummy;
		((CFileRegFile *)g_FileRegistry.GetRegEntry(m_hndFileReg))->WatchFile(fDummy);
		g_FileRegDisableFC = oldFileRegDisableFC;

		return TRUE;
	}

	return FALSE;
}
///////////////////////////////////////////////////////////////////////////////
void CProject::FlattenQuery(int fo, BOOL& fAddContent, BOOL& fAddItem)
{
	if ((fo & flt_ExcludeProjects))
	{
		fAddItem = FALSE;
	}
	else
		fAddItem = TRUE;

	// Always consider contents regardless of whether we consider the
	// project node itself
	fAddContent = TRUE;
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::CanAct(ACTION_TYPE  action)
{
	switch (action)
	{
	default:
		return CProjContainer::CanAct(action);

	// case act_insert_into_undo_slob:
	case act_delete:
	case act_cut:
		return ((GetContainer()!=NULL) && (GetContainer()!=this));

	case act_copy:
	case act_paste:
		return FALSE;
	}
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::CanAdd ( CSlob * pAddSlob)
{
	// This method checks to see if the user
	// can add whatever is in the pAddSlob

#if 0	// can no longer add directly to the project
	// we should be able to add any group, since if the name conflicts we
	// just rename it
	if ( pAddSlob->IsKindOf ( RUNTIME_CLASS ( CProjGroup )) && !g_Spawner.SpawnActive())
		return TRUE;
#endif

	return CProjContainer::CanAdd (pAddSlob);
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::SetupPropertyPages(CSlob* , BOOL bSetCaption)
{
	// no pages

	if( bSetCaption )
		SetPropertyCaption(CString(MAKEINTRESOURCE(IDS_PROJECT)));

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
void CProject::CloneConfigs(const CProjItem * pItem)
{
//	Instead of creating or deleting configurations, just try to set ourselves
//  into one that matches pItem:
	MatchConfig((const ConfigurationRecord *)((CProjItem *)pItem)->GetActiveConfig());
}
///////////////////////////////////////////////////////////////////////////////
void CProject::MatchConfig(const ConfigurationRecord * )
{
//	Try to switch to configuation the "matches" pcr.  For subproject, this
//  means finding a confiugation that has the same name (but not nessesarily
//  the same project type as pcr.

	// FUTURE (karlsi): NYI
	ASSERT (FALSE);
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::GetResourceFileList(CObList & filelist, BOOL fOnlyBuildable /*= FALSE*/, const ConfigurationRecord *pcr /*= NULL*/)
{
	CTargetItem * pTarget;
	if (pcr == (ConfigurationRecord *)NULL)
		pTarget = GetTarget(GetActiveConfig()->GetConfigurationName());
	else
		pTarget = GetTarget(pcr->GetConfigurationName());

	if (pTarget == (CTargetItem *)NULL)
		return FALSE;
	
	CFileRegistry * pRegistry = pTarget->GetRegistry();
	return pRegistry->GetFileItemList(pTarget, pRegistry->GetRCFileList(), filelist, fOnlyBuildable, pcr);
}
///////////////////////////////////////////////////////////////////////////////
// Return the project's resource /I (includes) + Include Path for the specified
// resource file. Returns TRUE if can do, or FALSE if resource file not valid
BOOL CProject::GetResourceIncludePath(CFileItem * pFileItem, CString & strInclude)
{
	if (pFileItem == (CFileItem *)NULL)
	{
		ASSERT(FALSE);
		return FALSE;	// not valid!
	}

	ASSERT(pFileItem->GetFilePath());
	// should be an .RC file!
	if (_tcsicmp(pFileItem->GetFilePath()->GetExtension(), _TEXT(".rc")) != 0)
	{
		return FALSE;	// not an .RC file!
	}

	// get our semi-colon sep. list of include paths
	CProjType * pProjType; CBuildTool * pSrcTool;
	VERIFY (g_prjcompmgr.LookupProjTypeByName(GetActiveConfig()->GetOriginalTypeName(), pProjType));
	if( !pProjType || !pProjType->IsSupported())
		return FALSE;

	if (pProjType->GetUniqueTypeId() == CProjType::generic)
		return FALSE;

	// get the build tool for the .RC file
	if ((pSrcTool = pProjType->PickTool(pFileItem->GetFileRegHandle())) == (CBuildTool *)NULL)
		return FALSE;	// no build tool found (no resource compiler tool for config?)

	pSrcTool->GetIncludePaths(pFileItem, strInclude);

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::PreMoveItem(CSlob * & pContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// do the base-class thing
	if (!CProjContainer::PreMoveItem(pContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	return TRUE;	// success
}
  
BOOL CProject::PostMoveItem(CSlob * pContainer, CSlob * pOldContainer, BOOL fFromPrj, BOOL fToPrj, BOOL fPrjChanged)
{
	// do the base-class thing
	if (!CProjContainer::PostMoveItem(pContainer, pOldContainer, fFromPrj, fToPrj, fPrjChanged))
		return FALSE;

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
// Verb Commands

void CProject::OnUpdateNewGroup(CCmdUI * pCmdUI)
{
	// [patbr] this command should never be enabled from here
	BOOL bEnable = FALSE;
	pCmdUI->Enable(bEnable);
}

void CProject::OnUpdateSettings(CCmdUI * pCmdUI)
{
	// This is only available if we are an external makefile or a supported
	// internal projtype, and a build isn't in progress.
	pCmdUI->Enable(m_bProjIsSupported && !g_Spawner.SpawnActive());
}

void CProject::OnUpdateConfigurations(CCmdUI *pCmdUI)
{
	// This is only available if we are an external makefile or a supported
	// internal projtype, and a build isn't in progress.
	pCmdUI->Enable(!m_bProjIsExe && !g_Spawner.SpawnActive());
}

void CProject::OnUpdateSubprojects(CCmdUI *pCmdUI)
{
	// This is only available if we are an external makefile or a supported
	// internal projtype, and a build isn't in progress.
	pCmdUI->Enable(!m_bProjIsExe && !g_Spawner.SpawnActive());
}

void CProject::OnUpdateTools(CCmdUI * pCmdUI)
{
	// only available if we are an internal makefile
	// (ie. not an exe-only project) and a build isn't in progress
	pCmdUI->Enable(!m_bProjIsExe && !g_Spawner.SpawnActive());
}

void CProject::OnUpdateSettingsPop(CCmdUI * pCmdUI)
{
	// This is only available if we are an external makefile or a supported
	// internal projtype, and a build isn't in progress.

	pCmdUI->Enable((m_bProjIsExe || GetProjType()->IsSupported())
		 && m_bProjIsSupported && !g_Spawner.SpawnActive());
}


void CProject::OnUpdateFilesIntoProject(CCmdUI * pCmdUI)
{
	// The New Group command is available only if this is
	// an internal project and we're not building.
	CString strTarget;
	BOOL bEnable = FALSE;
	BOOL bContextMenu = ::IsContextMenu(pCmdUI);
	
	// Initialization.  If this is an external makefile, disable
	// always.  Also, no compiles are allowed from the browse window
	CWnd* pWndActiveView = CWnd::GetActiveWindow();
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	if (!m_bProjIsExe &&
		!g_Spawner.SpawnActive() &&
		!(pWndActiveView &&
		pWndActiveView->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd))))
	{
		// Find the current selection.
		BOOL bActive = pProjSysIFace->IsWindowActive() == S_OK;

		bEnable = bActive; // new behaviour
	}

	if (bContextMenu)
	{

		CString			strGroupMenu;
		CSlob * pSlob;
		CMultiSlob* pMultiSlob = NULL;
	
		VERIFY(SUCCEEDED(pProjSysIFace->GetSelectedSlob(&pMultiSlob)));
		pSlob = pMultiSlob->GetDominant();
		if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
			strGroupMenu.LoadString(IDS_ADD_FILES_INTO_FOLDER);
		else 	
			strGroupMenu.LoadString(IDS_ADD_FILES_INTO_PROJECT);
		pCmdUI->SetText(strGroupMenu);
	}

	pCmdUI->Enable(bEnable);
}

static TCHAR szTextEditorC[]	= _T("Text Editor\\Tabs/Language Settings\\C/C++");
static TCHAR szTextEditorFor[]	= _T("Text Editor\\Tabs/Language Settings\\Fortran");
static TCHAR szFileExtensions[]	= _T("FileExtensions");

#define MENU_TEXT_CCH 200

void CProject::OnUpdateCompile(CCmdUI * pCmdUI)
{
	CString strTarget;
	BOOL bEnable = FALSE;
	BOOL bMenu = ::IsMenu(pCmdUI);
	BOOL bContextMenu = ::IsContextMenu(pCmdUI);

	// This is the quickest test possible so short cut the longer test.
	CProjType *pPt = GetProjType();
	if( !bMenu && !( pPt && pPt->IsSupported() && pPt->GetPlatform() && pPt->GetPlatform()->GetBuildable() && g_Spawner.CanSpawn()) ){
		pCmdUI->Enable( FALSE );
		return;
	}

	// Initialization.  If this is an external makefile, disable
	// always.  Also, no compiles are allowed from the browse window
	CWnd* pWndActiveView = CWnd::GetActiveWindow();

	if (!m_bProjIsExe &&
		!(pWndActiveView &&
		pWndActiveView->IsKindOf(RUNTIME_CLASS(CFloatingFrameWnd))))
	{
		// Find the current selection.
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();

		CMultiSlob*	pMultiSlob = NULL;
		BOOL bActive = pProjSysIFace->IsWindowActive() == S_OK;
		if (bActive)
			VERIFY(SUCCEEDED(pProjSysIFace->GetSelectedSlob(&pMultiSlob)));


		// Enable if an appropriate file item is selected or if an
		// appropriate source window is selected.
		if (bActive)
		{
			CProjItem *		pProjItem = NULL;
			CBuildTool *	pTool;

			if (pMultiSlob != NULL)
			{
				// Note that we won't even consider enabling the command
				// if there is nothing in the selection, or if there is
				// more than one item in the selection.  Since doing a
				// compile is asynchronous, we'd have to keep a list of
				// the files to be compiled (much like the Batch Build
				// dialog), which is a lot more complication than this
				// feature probably merits.
				if (pMultiSlob->GetContentList()->GetCount() == 1)
				{
					CSlob * pSlob = pMultiSlob->GetDominant();
					if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
						pProjItem = ((CBuildSlob *)pSlob)->GetProjItem();
				}
			}

			if (pProjItem != (CProjItem *)NULL &&
				pProjItem->IsKindOf(RUNTIME_CLASS(CFileItem)) &&
				(pTool = pProjItem->GetSourceTool()) != (CBuildTool *)NULL
			   )
			{
				if (bMenu)
				{
					ASSERT(pProjItem->GetFilePath());
					strTarget = pProjItem->GetFilePath()->GetFileName();
				}
				bEnable = TRUE;
			}
		}
		else
		{
			CDocument *	pDoc = g_Spawner.GetLastDocWin();
			// We check here to see if the file is in the project,
			// Wait until the command is actually requested and deal with
			// the possibility that we don't know what to do with it then.

			if	(
				(pDoc != NULL) &&
				(!pDoc->GetPathName().IsEmpty())
				)
			{
				CString strPathName = pDoc->GetPathName();

				CPath *pPath = NULL;
#ifndef REFCOUNT_WORK
				FileRegHandle frh = g_FileRegistry.LookupFile( strPathName );
#else
				FileRegHandle frh = CFileRegFile::LookupFileHandleByName(strPathName);
#endif
				if (frh != NULL)
				{
					 pPath = (CPath *)g_FileRegistry.GetRegEntry(frh)->GetFilePath();
#ifdef REFCOUNT_WORK
					frh->ReleaseFRHRef();
#endif
				}


				// strPath.Create( strPathName );

				// now we must check if the file is part of the default project.
				// if it is, then thats good enough for now.
				// if it isn't then see if it can use a known supported tool.
				HFILESET 	hFileSet = NULL;
				HBLDFILE	hFile = NULL;
				HBUILDER 	hBld = g_BldSysIFace.GetActiveBuilder();

				HBLDTARGET  	hTarg = g_BldSysIFace.GetActiveTarget( hBld );
				if( hTarg != NULL ) {
					hFileSet = g_BldSysIFace.GetFileSet(hBld, hTarg);
				}

				if ((pPath!=NULL) && (g_BldSysIFace.GetFile ( pPath, hFile, hFileSet, hBld ))
					&& ( hFile != NULL )) {
					if (bMenu)
						strTarget = StripPath(strPathName);
					bEnable = TRUE;
				}
				else
				{	
					// the file is not the project. We still may know what to do.
					CString strExt = GetExtension(strPathName);
					CPath path; path.Create(strPathName);
					if	(g_BldSysIFace.LanguageSupported( CPlusPlus ))
					{
						CString strFileExts = GetRegString(szTextEditorC, szFileExtensions, _T("cpp;cxx;c;rc"));
						strFileExts += _T(";r;odl");
						if (FileNameMatchesExtension(&path, strFileExts))
						{
							if (bMenu)
								strTarget = StripPath(strPathName);
							bEnable = TRUE;
						}
					}
					if	(g_BldSysIFace.LanguageSupported( FORTRAN ))
					{
						CString strFileExts = GetRegString(szTextEditorFor, szFileExtensions, _T("f;for;f90;rc"));
						strFileExts += _T(";r;odl");
						if (FileNameMatchesExtension(&path, strFileExts))
						{
							if (bMenu)
								strTarget = StripPath(strPathName);
							bEnable = TRUE;
						}
					}
				}
			}
		}
	}

	if (bMenu)
	{
		TCHAR			szMenuText[MENU_TEXT_CCH];
		CString			strCompileMenu;

		if (bContextMenu)
			strCompileMenu.LoadString(IDS_CPOP_COMPILE);
		else
		{
			strCompileMenu.LoadString(IDS_PROJMENU_COMPILE);
			GetCmdKeyString(IDM_PROJITEM_COMPILE, strCompileMenu);
		}

		strTarget = strTarget.Left(MENU_TEXT_CCH - strCompileMenu.GetLength());
		MenuFileText(strTarget);
		wsprintf(szMenuText, strCompileMenu, (LPCTSTR) strTarget);
		pCmdUI->SetText(szMenuText);
	}

	pCmdUI->Enable(bEnable && GetProjType()->IsSupported() && g_Spawner.CanSpawn());
}

void CProject::OnUpdateBuild(CCmdUI * pCmdUI)
{

	BOOL bMenu = ::IsMenu(pCmdUI);
	BOOL bContextMenu = ::IsContextMenu(pCmdUI);

	if (bMenu)
	{
		TCHAR		szMenuText[MENU_TEXT_CCH];
		CString		strBuildMenu, strTarget;
		CPath *		pPath;

		if (bContextMenu)
			strBuildMenu.LoadString(IDS_CPOP_BUILD);
		else
		{
			strBuildMenu.LoadString(IDS_PROJMENU_BUILD);
			GetCmdKeyString(IDM_PROJITEM_BUILD, strBuildMenu);
		}

		pPath = GetTargetFileName();
		if (pPath == NULL)
		{
			CProjType * pProjType = GetProjType();

			if (pProjType && pProjType->GetUniqueTypeId() == CProjType::javaapplet)
			{
				const ConfigurationRecord* pcr = GetActiveConfig();

				strTarget = pcr->GetConfigurationName();
				int nSep = strTarget.Find (_T(" - "));
				if (nSep > 0)
					strTarget = strTarget.Left(nSep);
			}
		}
		else
		{
			strTarget = pPath->GetFileName();
			delete pPath;
		}
		strTarget = strTarget.Left(MENU_TEXT_CCH - strBuildMenu.GetLength());
		MenuFileText(strTarget);

		wsprintf(szMenuText, strBuildMenu, (LPCTSTR) strTarget);

		pCmdUI->SetText(szMenuText);
	}

	CProjType *pPt = GetProjType();
	if( !( pPt && pPt->GetPlatform() && pPt->GetPlatform()->GetBuildable()) ){
	    pCmdUI->Enable( FALSE );
		return;
	}

	pCmdUI->Enable((!m_bProjIsExe) && (GetProjType()->IsSupported()) && CanDoTopLevelBuild());
}

void CProject::OnUpdateRebuildAll(CCmdUI * pCmdUI)
{
	pCmdUI->Enable(!m_bProjIsExe && GetProjType()->IsSupported() && GetProjType()->GetPlatform() && GetProjType()->GetPlatform()->GetBuildable() && CanDoTopLevelBuild());
}

void CProject::OnUpdateClean(CCmdUI * pCmdUI)
{
	pCmdUI->Enable(!m_bProjIsExe && GetProjType()->IsSupported() && GetProjType()->GetPlatform() && GetProjType()->GetPlatform()->GetBuildable() && CanDoTopLevelBuild());
}

void CProject::OnUpdateBatchBuild(CCmdUI * pCmdUI)
{
	pCmdUI->Enable(!m_bProjIsExe && m_bProjIsSupported && CanDoTopLevelBuild());
}

void CProject::OnUpdateStopBuild(CCmdUI * pCmdUI)
{
	pCmdUI->Enable(g_Spawner.SpawnActive() > 0);
}

// A combined build and stop build command for the menus
void CProject::OnUpdateToggleBuild(CCmdUI * pCmdUI)
{
	BOOL bBuilding=g_Spawner.SpawnActive() > 0;
	if(bBuilding)
	{
		CString strBuild;
		strBuild.LoadString(IDS_BUILD_STOP);

		GetCmdKeyString(IDM_PROJECT_STOP_BUILD, strBuild);

		pCmdUI->SetText(strBuild);
		pCmdUI->Enable(TRUE);
	}
	else
	{
		// use the existing code to get the enabling and string
		OnUpdateBuild(pCmdUI);
	}
}

void CProject::OnUpdateExport(CCmdUI * pCmdUI)
{
	if (GetCurrentPlatform ()->GetUniqueId () == java)
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(!m_bProjIsExe && m_bProjIsSupported && CanDoTopLevelBuild());
}

void CProject::OnUpdateScan(CCmdUI * pCmdUI)
{
	// If this is an exe project, or we are an unknown 
	// target, or during a build then disable always.
	if (m_bProjIsExe ||					// exe project
		g_Spawner.SpawnActive()	||		// doing a build
		!GetProjType()->IsSupported()	// unknown target?
	   )
	{
		pCmdUI->Enable(FALSE);
		return;
	}


	// Enable if a file item is selected or if an appropriate source
	// window is selected.
	BOOL bEnable = FALSE;
	
	// UNDONE (colint): Need to fix test for active project view
	if (FALSE)
	{
		CMultiSlob *	pMultiSlob;
		CProjItem *		pProjItem = NULL;

		// Find the current selection.
		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
		VERIFY(SUCCEEDED(pProjSysIFace->GetSelectedSlob(&pMultiSlob)));

 		if (pMultiSlob != NULL)
		{
			// Note that we won't even consider enabling the command
			// if there is nothing in the selection, or if there is
			// more than one item in the selection.  This is done to
			// be consistent with the Compile command, where supporting
			// multiple selection is quite difficult.
			if (pMultiSlob->GetContentList()->GetCount())
            {
                CSlob * pSlob = pMultiSlob->GetDominant();
                if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
                    pProjItem = ((CBuildSlob *)pSlob)->GetProjItem();
            }
		}
		bEnable = TRUE;
	}
	else
	{
		CDocument *		pDoc = g_Spawner.GetLastDocWin();

		// We don't check here to see if the file is in the project,
		// because it can be somewhat expensive.  Wait until the
		// command is actually requested and deal with the possibility
		// that the file isn't in the project then.
		//
		// Because we don't check if the file is in the project or not
		// we don't check if the file has a tool either for the same reason
		// Hence, if you have .r file open but not a Macintosh project type
		// this is still enabled.
		if	((pDoc != NULL) &&
			 (!pDoc->GetPathName().IsEmpty())
			)
		{
			CString strPathName = pDoc->GetPathName();
			CString strExt = GetExtension(strPathName);
			bEnable = ((_tcsicmp(strExt, _T(".c")) == 0) ||
					   (_tcsicmp(strExt, _T(".cpp")) == 0) ||
				       (_tcsicmp(strExt, _T(".cxx")) == 0) ||
					   (_tcsicmp(strExt, _T(".r")) == 0) ||
					   (_tcsicmp(strExt, _T(".odl")) == 0)
			          );
		}
	}

	pCmdUI->Enable(bEnable);
}

void CProject::OnUpdateScanAll(CCmdUI * pCmdUI)
{
	// If this is an exe project, disable always.
	if (m_bProjIsExe)			// exe project
	{
		pCmdUI->Enable(FALSE);
		return;
	}

	// unknown target?
	CProjType * pProjType = GetProjType();
	ASSERT(pProjType != (CProjType *)NULL);

	// This is enabled if this is an internal makefile and the
	// project object itself can do a scan.
	pCmdUI->Enable(CanDoScan() &&			// can scan this item?
				   pProjType->IsSupported()	// supported platform
				  );
}

void CProject::OnUpdateToolMecr(CCmdUI * pCmdUI)
{
	CString str;
	BOOL bEnable = FALSE;

	// Set the text for the remote update tool menu option
	str.LoadString(IDS_DEFFERED_MECR);
	pCmdUI->SetText(str);

	CPlatform * pPlatform;

	// Enable the menu option if the platform associated with
	// the current project is the Macintosh 68k.
	if (m_bProjIsExe)
	{
 		CString strUIDescription;
 		VERIFY(GetStrProp(P_ExtOpts_Platform, strUIDescription));
		g_prjcompmgr.LookupPlatformByUIDescription(strUIDescription, pPlatform);
	}
	else
		pPlatform = (CPlatform *)GetProjType()->GetPlatform();

	// mfile is currently supported only on the mac (68k and ppc)
	bEnable = pPlatform->GetUniqueId() == mac68k ||
			  pPlatform->GetUniqueId() == macppc;

	// Enable only if we aren't building already
    if (!m_bProjIsExe)
    	bEnable = bEnable && CanDoTopLevelBuild();

	// Enable/Disable the menu option
	pCmdUI->Enable(bEnable);
}

void CProject::OnUpdateConfigCombo(CCmdUI * pCmdUI)
{
	// Not enabled for exe projects
	if (m_bProjIsExe || !CanDoTopLevelBuild())
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(TRUE);
}

void CProject::OnUpdateTargetCombo(CCmdUI * pCmdUI)
{
	// Not enabled for exe projects
	if (m_bProjIsExe || !CanDoTopLevelBuild())
		pCmdUI->Enable(FALSE);
	else
		pCmdUI->Enable(TRUE);
}

/////////////////////////////////////////////////////////////////////////////

void CProject::OnPopupFilesIntoProject()
{
	// Find the current selection.
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();

	BOOL bActive = pProjSysIFace->IsWindowActive() == S_OK;
	ASSERT(bActive);
	
	CSlob * pSlob;
	CSlob * pContainer;
	CMultiSlob* pMultiSlob = NULL;
	long lpPkgProject = NULL;
	CString strFolderName;
	BOOL bProject = TRUE;

	// Enable if an appropriate file item is selected or if an
	// appropriate source window is selected.
	if (bActive)
	{
		VERIFY(SUCCEEDED(pProjSysIFace->GetSelectedSlob(&pMultiSlob)));
		if (pMultiSlob != NULL)
		{
			// Note that we won't even consider enabling the command
			// if there is nothing in the selection
			if (pMultiSlob->GetContentList()->GetCount() > 0)
			{
				pSlob = pMultiSlob->GetDominant();
				if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
				{
					//pSlob = ((CBuildViewSlob *)pSlob)->GetBuildSlob();
					bProject = FALSE;
					pContainer = (CBuildViewSlob *)pSlob;
					while (pContainer)
					{
					// Did we get it?
						if (( ((CBuildViewSlob *)pContainer)->GetLongProp(P_IPkgProject, lpPkgProject) == valid) && (lpPkgProject != NULL))
							break;
						else
							pContainer = (CBuildViewSlob *)pContainer->GetContainer();
					}
				}
				else if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)))
				{
					bProject = TRUE;
					pContainer = pSlob;
					while (pContainer)
					{
						// Did we get it?
						if ((pContainer->GetLongProp(P_IPkgProject, lpPkgProject) == valid) && (lpPkgProject != NULL))
						//if (pIPkgProject != NULL)
							break;
						else
							pContainer = pContainer->GetContainer();
					}
				}
			}
		}
	}
	ASSERT(pContainer != NULL);
	ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CProjSlob)));
	if (pContainer != NULL )
	{
		// Build must not be in progress
		ASSERT(!g_Spawner.SpawnActive());

		pSlob->GetStrProp(P_Title, strFolderName);
		if (strFolderName == "")
			strFolderName = "Default";

		CAddFilesDialog dlg((IPkgProject *)lpPkgProject, strFolderName);

		if (dlg.DoModal() == IDOK)
		{

			USES_CONVERSION;

			int iMaxFile = dlg.m_saFileNames.GetSize();
			if (iMaxFile > 0)
			{
				LPOLESTR *ppszFiles = new LPOLESTR[iMaxFile];

				for (int iFile = 0; iFile < iMaxFile; iFile++)
				{
					LPOLESTR wstr = T2W(dlg.m_saFileNames[iFile]);
					ppszFiles[iFile] = (LPOLESTR)malloc((wcslen(wstr)+1) * sizeof(wchar_t));
					wcscpy(ppszFiles[iFile], wstr);
				}
				LPCOLESTR pszDefaultFolder = NULL;
				VERIFY(SUCCEEDED(dlg.GetProject()->AddFiles((LPCOLESTR *)ppszFiles, iMaxFile, (bProject)? NULL:T2W(strFolderName))));
				for (iFile = 0; iFile < iMaxFile; iFile++)
					free(ppszFiles[iFile]);
				delete[] ppszFiles;
			}
		}
	}
}


void CProject::OnNewGroup()
{
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();

	CMultiSlob* pMultiSlob = NULL;
	VERIFY(SUCCEEDED(pProjSysIFace->GetSelectedSlob(&pMultiSlob)));
	if (pMultiSlob != NULL)
	{
		// Note that we won't even consider enabling the command
		// if there is nothing in the selection
		if (pMultiSlob->GetContentList()->GetCount() > 0)
		{
			CSlob * pSlob = pMultiSlob->GetDominant();
			if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)))
			{
				 pSlob = ((CBuildViewSlob *)pSlob)->GetBuildSlob();
			}
			if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
			{
				CProjItem *pContainer = (CProjItem *)((CBuildSlob *)pSlob)->GetProjItem();
				while (pContainer != NULL)
				{
				 	if ((pContainer->IsKindOf(RUNTIME_CLASS(CProjGroup))) ||
				 		(pContainer->IsKindOf(RUNTIME_CLASS(CTargetItem))))
						break;
					pContainer = (CProjItem *)pContainer->GetContainer();
				}

				ASSERT(pContainer != NULL);
				ASSERT(pContainer->IsKindOf(RUNTIME_CLASS(CProjContainer)));
				if (pContainer != NULL)
					((CProjContainer *)pContainer)->CmdAddGroup();
			}
		}
	}
}


////////////////////////////////////////////////////////////////////
// Function OnXXXPostMsg() simply post message to the main window
// and in turn it will call the 'real' function OnXXX()
// The reason we do this (bug fix 11217) is	because MFC keeps these
// toolbar buttons down during the command execution, and we want the
// button to return to normal right away.
////////////////////////////////////////////////////////////////////
void CProject::OnCompilePostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_PROJITEM_COMPILE);
}

void CProject::OnBuildPostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_PROJITEM_BUILD);
}

void CProject::OnRebuildAllPostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_PROJITEM_REBUILD_ALL);
}

void CProject::OnCleanPostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_PROJITEM_CLEAN);
}

void CProject::OnBatchBuildPostMsg()
{
	AfxGetMainWnd()->PostMessage (WM_COMMAND, ID_PROJITEM_BATCH_BUILD);
}

void CProject::OnCompile()
{
	CProjItem * pItemToCompile = NULL;
	CBuildTool * pTool;

	// If the project window is NOT active, we must have been enabled
	// because of a last active source window.
	CDocument *	pDoc;
	CPath		path;

	// Is project window active?
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	BOOL bActive = pProjSysIFace->IsWindowActive() == S_OK;

	if	(bActive || 
		 ((pDoc = g_Spawner.GetLastDocWin()) == NULL) ||
		 pDoc->GetPathName().IsEmpty() ||
		 !path.Create(pDoc->GetPathName())
		)
	{
		CMultiSlob *	pMultiSlob = NULL;
		
		// Find the current selection.
		pProjSysIFace->GetSelectedSlob(&pMultiSlob);

		if( (pMultiSlob != NULL) && (pMultiSlob->GetContentList()->GetCount() == 1) )
		{
            CSlob * pSlob = pMultiSlob->GetDominant();
            if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob))) {
                pItemToCompile = ((CBuildSlob *)pSlob)->GetProjItem();
			}
		}

		if( pItemToCompile == NULL ){
			ASSERT(FALSE); // item should exist!
		    return;
		}

	}
	else if ((pItemToCompile = EnsureFileInProject(&path, TRUE)) == NULL)
	{
		CString	strError;

		MsgBox(	Information,
				MsgText(strError, IDS_FILE_NOT_IN_PROJ_CANT_COMPILE, path.GetFileName()));
		return;
	}

	// At this point, we have a CProjItem.  Before we try to compile it, we
	// need to make sure:
	//	- It's a CFileItem
	//	- It has an associated tool

	if (!pItemToCompile->IsKindOf(RUNTIME_CLASS(CFileItem)) ||
		((pTool = pItemToCompile->GetSourceTool()) == (CBuildTool *)NULL)
	   )
	{
		CString	strError;
		MsgBox(	Information,
				MsgText(strError,
						IDS_CANT_COMPILE_NO_TOOL,
						(const TCHAR *)*pItemToCompile->GetFilePath()));
		return;
	}

	// Also make sure the item itself thinks it's OK to build.
	if (!pItemToCompile->CanDoTopLevelBuild())
	{
		ASSERT(FALSE);	// Command should have been disabled
		return;
	}

	// FINALLY, we can compile the damn thing.
	pItemToCompile->CmdCompile(TRUE);
}

void CProject::OnBuild()
{
	if (g_Spawner.SpawnActive())
	  	g_Spawner.DoSpawnCancel();

	// UNDONE: need to wait for build to finish before restarting

	CmdBuild();
}

void CProject::OnRebuildAll()
{
	CmdReBuild();
}

void CProject::OnClean()
{
	CmdClean();
}

void CProject::OnBatchBuild()
{
	// get the batch build dialog
	static CBatchBldDlg dlg;

	dlg.m_pBuildConfigs = &m_BuildConfigs;
	dlg.m_pBuildConfigs->RemoveAll();

	if (dlg.DoModal() == IDOK)
		CmdBatchBuild(dlg.m_bRebuild, &m_BuildConfigs, !dlg.m_bSelectionOnly, dlg.m_bClean);
}

BOOL GetSelectedProjects(CSlob & SelectionSlob)
{
	SelectionSlob.GetContentList()->RemoveAll();

	// multi-select projects
	// Is project window active?
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	BOOL bActive = pProjSysIFace->IsWindowActive() == S_OK;

	if	(bActive)
	{
		CMultiSlob *	pMultiSlob = NULL;
		
		// Find the current selection.
		pProjSysIFace->GetSelectedSlob(&pMultiSlob);

		if( (pMultiSlob != NULL) && (pMultiSlob->GetContentList()->GetCount() > 0) )
		{
			
			POSITION pos = pMultiSlob->GetContentList()->GetHeadPosition();
			while (pos != NULL)
			{
				CSlob * pSlob = (CSlob *)pMultiSlob->GetContentList()->GetNext(pos);
				if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)))
					pSlob = ((CBuildViewSlob *)pSlob)->GetBuildSlob();
			
				else if (!pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
					continue; // ignore ones that aren't ours

				pSlob = ((CBuildSlob *)pSlob)->GetProjItem();
				if (pSlob->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
					pSlob = ((CProjectDependency *)pSlob)->GetProjectDep();
				else if (!pSlob->IsKindOf(RUNTIME_CLASS(CTargetItem)))
					continue;

				pSlob = ((CProjItem *)pSlob)->GetProject();

				SelectionSlob.GetContentList()->AddTail(pSlob);
			}
		}
	}
	return (!SelectionSlob.GetContentList()->IsEmpty());
}

void CProject::OnExport()
{
	g_bExportDeps = g_bAlwaysExportDeps;

	// skip calling the dialog if Automation or only 1 project
	int nProjects = m_lstProjects.GetCount();
	BOOL bUseDialog = ((nProjects > 0) && (g_pAutomationState->DisplayUI() && !g_bNoUI)); //ShellOM:State

	CProject * pProject;
	if (bUseDialog)
	{
		// need to make sure we're not counting Java projects
		POSITION pos = m_lstProjects.GetHeadPosition();
		while (pos != NULL)
		{
			// count only valid C projects
			pProject = (CProject *)m_lstProjects.GetNext(pos);
			if ((pProject == NULL) || (!pProject->IsLoaded()) || (pProject->GetCurrentPlatform()->GetUniqueId()==java))
				nProjects--;
		}
		bUseDialog = (nProjects > 0);
	}

	// REVIEW: ExportAs dialog?
	CProjectsDlg dlg;
	dlg.m_bExport = TRUE;
	dlg.m_bExportDeps = g_bAlwaysExportDeps;
	CMultiSlob SelectionSlob;

	// copy selection to dialog, if any; otherwise use saved value
	if (bUseDialog)
	{
		if (GetSelectedProjects(SelectionSlob))
		{
			dlg.m_mapSelectedProjects.RemoveAll();
			POSITION pos = SelectionSlob.GetContentList()->GetHeadPosition();
			while (pos != NULL)
			{
				CProject * pProject = (CProject *)SelectionSlob.GetContentList()->GetNext(pos);
				ASSERT(pProject->IsKindOf(RUNTIME_CLASS(CProject)));
				dlg.m_mapSelectedProjects.SetAt(pProject->GetTargetName(), pProject);
			}
			ASSERT(!dlg.m_mapSelectedProjects.IsEmpty());
			SelectionSlob.GetContentList()->RemoveAll();
		}

		ASSERT(SelectionSlob.GetContentList()->IsEmpty());

		if (dlg.DoModal() != IDOK)
			return;

		g_bExportDeps = dlg.m_bExportDeps;
	}

	ASSERT(!g_bWriteProject);

	// m_bProjectDirty = TRUE;

	BOOL bExportDeps = g_bExportDeps; // save for iteration
	
	CString strProject;
	BOOL bIsSccActive = (g_pSccManager->IsSccInstalled() == S_OK);
	if (bUseDialog && bIsSccActive)
	{
		CStringArray files;
		CProject::InitProjectEnum();
		while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
		{
			// use selected projects from dlg
			ASSERT(!dlg.m_mapSelectedProjects.IsEmpty());
			CProject * pCmpProject;
			if (!dlg.m_mapSelectedProjects.Lookup(strProject, (void * &)pCmpProject))
			{
				continue;
			}
			else
			{
				ASSERT(pProject == pCmpProject);
			}

			if( pProject->m_bProjIsExe ) 
			{
				continue;
			}

			CPath path = *pProject->GetFilePath();
			path.ChangeExtension(_T(".mak"));
			if (path.IsReadOnlyOnDisk() && (g_pSccManager->IsControlled((const TCHAR *)path) == S_OK))
			{
				files.Add((const TCHAR*)path);
			}
			path.ChangeExtension(_T(".dep"));
			if (bExportDeps && path.IsReadOnlyOnDisk() && (g_pSccManager->IsControlled((const TCHAR *)path) == S_OK))
			{
				files.Add((const TCHAR*)path);
			}
		}
		if (files.GetSize() > 0)
		{
			g_pSccManager->CheckOutReadOnly(files, TRUE, TRUE); // ignore errors
		}
	}

	CProject::InitProjectEnum();
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		// use selected projects from dlg
		ASSERT((!bUseDialog) || (!dlg.m_mapSelectedProjects.IsEmpty()));
		if (bUseDialog)
		{
			CProject * pCmpProject;
			if (!dlg.m_mapSelectedProjects.Lookup(strProject, (void * &)pCmpProject))
			{
				continue;
			}
			else
			{
				ASSERT(pProject == pCmpProject);
			}
		}

		if( pProject->m_bProjIsExe ) 
		{
			ASSERT(0);
			continue;
		}

		g_bExportMakefile = TRUE;
		g_bExportDeps = bExportDeps;

		BOOL bSavedDirty = pProject->m_bProjectDirty;

#if 0	// REVIEW
		// Also write project file if dirty
		if (m_bProjectDirty)
			g_bWriteProject = TRUE;
#endif
		// save as makefile
		pProject->DoSave();
#if 1
		pProject->m_bProjectDirty = bSavedDirty;
		// REVIEW: dirty status changed?
#endif

	}
}

void CProject::OnScan()
{
	CProjItem *pItemToScan;

	// If the project window is NOT active, we must have been enabled
	// because of a last active source window.
	// UNDONE (colint): Need to fix for testing if proj view active
	if (TRUE)
	{
		CDocument *pDoc;
		CPath	path;

		if	(((pDoc = g_Spawner.GetLastDocWin()) == NULL) ||
					(pDoc->GetPathName().IsEmpty()) ||
					(!path.Create(pDoc->GetPathName())))
		{
			// We shouldn't have gotten here.  (The command shouldn't
			// have been enabled.)
			ASSERT(FALSE);
			return;
		}

		if ((pItemToScan = EnsureFileInProject(&path, TRUE)) == NULL)
		{
			CString	strError;

			MsgBox(	Information,
					MsgText(strError, IDS_FILE_NOT_IN_PROJ_CANT_SCAN, path.GetFileName()));
			return;
		}

		// Also make sure the item itself thinks it can be scanned.
		if (!pItemToScan->CanDoScan())
		{
			ASSERT(FALSE);	// Command should have been disabled
			return;
		}

		g_ScannerCache.UpdateDependencies( pItemToScan );
	}
	else
	{
		CMultiSlob *pMultiSlob;

		LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
		VERIFY(SUCCEEDED(pProjSysIFace->GetSelectedSlob(&pMultiSlob)));

		if (!pMultiSlob->GetContentList()->GetCount())
		{
			ASSERT(FALSE);	// This command shouldn't have been enabled
			return;
		}

		// PERFORMANCE: Make sure pMultiSlob doesn't contain any CFileItem's groups
		// UNDONE (colint): Need to fix this up so that it gets a list of CProjItems
		// and not a list of CBuildSlobs
		//g_ScannerCache.UpdateDependencies( pMultiSlob );
	}
}

BOOL CProject::DoTopLevelScan(BOOL bWriteOutput)
{
#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "devbldd.dll", "DoTopLevelScan()", letypeBegin, 0);
#endif
	BOOL ret = g_ScannerCache.UpdateDependencies( this, FALSE, bWriteOutput );
#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "devbldd.dll", "DoTopLevelScan()", letypeEnd, 0);
#endif
	return ret;
}

void CProject::OnScanAll()
{
	if (g_Spawner.SpawnActive())
	{
		ASSERT(FALSE);	// Command should have been disabled
		return;
	}

	// save all before update all. Just in case.
	BOOL bQuery;
	if (g_Spawner.IsSaveBeforeRunningTools(&bQuery))
	{
		// save all files since we may have both internal and external
		theApp.SaveAll(bQuery, FILTER_DEBUG | FILTER_PROJECT | FILTER_NEW_FILE);
	}

	CUpdateDepDlg dlg;

	dlg.DoModal();
/*
	g_ScannerCache.UpdateDependencies( this );
*/

}

void CProject::OnSelectTarget()
{
	CSelectTargetDlg dlg(NULL, IDD_SELECT_TARGET, IDD_PROJ_SELECT_TARGET, NULL, FALSE);
	int rc = dlg.DoModal();
	if (rc == IDOK)
	{
		// Set the active target
		HBLDTARGET hTarget = g_BldSysIFace.GetTarget(dlg.m_strSelectedTarget, NO_BUILDER);
		ASSERT(hTarget);
		HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
		ASSERT(hBld != NO_BUILDER);
	
		g_BldSysIFace.SetActiveTarget(hTarget, hBld);
		
		// REVIEW: this should no longer be needed:
    	// Refresh the target combos
	    CObList * plstCombos = CTargetCombo::GetCombos();
    	POSITION pos = plstCombos->GetHeadPosition();
	    while (pos != NULL)
	    {
		    CTargetCombo * pTargetCombo = (CTargetCombo *)plstCombos->GetNext(pos);
    		pTargetCombo->UpdateView();
	    }
	}
	else if (rc == IDABORT)
	{
		// Put up message box and quit
		MsgBox(Information, IDS_NO_TARGET_DEPS_TO_ADD);
	}
}

void CProject::OnSelectConfig()
{
	CSelectTargetDlg dlg(NULL, IDD_SELECT_TARGET, IDD_PROJ_SELECT_TARGET, NULL, FALSE);
	int rc = dlg.DoModal();
	if (rc == IDOK)
	{
		// Set the active target
		HBLDTARGET hTarget = g_BldSysIFace.GetTarget(dlg.m_strSelectedTarget, NO_BUILDER);
		ASSERT(hTarget);
		HBUILDER hBld = g_BldSysIFace.GetBuilder(hTarget);
		ASSERT(hBld != NO_BUILDER);
	
		g_BldSysIFace.SetActiveTarget(hTarget, hBld);
		
		// REVIEW: this should no longer be needed:
    	// Refresh the target combos
	    CObList * plstCombos = CTargetCombo::GetCombos();
    	POSITION pos = plstCombos->GetHeadPosition();
	    while (pos != NULL)
	    {
		    CTargetCombo * pTargetCombo = (CTargetCombo *)plstCombos->GetNext(pos);
    		pTargetCombo->UpdateView();
	    }
	}
	else if (rc == IDABORT)
	{
		// Put up message box and quit
		MsgBox(Information, IDS_NO_TARGET_DEPS_TO_ADD);
	}
}

void CProject::OnToolMecr()
{
	UpdateRemoteTarget();
}

///////////////////////////////////////////////////////////////////////////////
// External interface for OnSettings()
BOOL CProject::ShowProjSettingsPage(ProjSettingsPage prjpage)
{
	switch (prjpage)
	{
		case Project_General:
		{
			// select IDS_GENERAL tab
			// in the Project Settings 'mondo' dialog
			// create the options dialog
			CProjOptionsDlg dlg(NULL, 0);	// first tab

			// do it
			dlg.DoModal();
			break;
		}

		case Project_DebugInfo_Settings:
		{
			if (m_bProjIsExe)
			{
				// select IDS_DEBUG_OPTIONS tab
				// in the Project Settings 'mondo' dialog
				// create the options dialog
				CProjOptionsDlg dlg(NULL, 1);	// second tab

				// do it
				dlg.DoModal();
			}
			else
			{
				// select IDS_GENERAL tab
				// in the Project Settings 'mondo' dialog
				// initial FOCUS is IDC_PROGARGS_OR_CALLER;
				CProjOptionsDlg dlg(NULL, 0);	// first tab

				// do it
				dlg.DoModal();
			}
			break;
		}

		default:
			ASSERT(FALSE);
			return FALSE;	// unknown page!
	}

	return TRUE;
}

// REVIEW (KPerry) this function is useless now. move the three lines
//         		   for CProjOptionsDlg to ::OnSettings
void CProject::OnSettingsCommon(CSlob * pSelection)
{
	// property notifications other than config. changing

	// o platform for exe projects
	// FUTURE (colint): Do we still need the platform field for exe projects
	CString strExtOptsPlatform;
	if (m_bProjIsExe)
		if (GetStrProp(P_ExtOpts_Platform, strExtOptsPlatform) != valid)
			strExtOptsPlatform = "";

	// create the options dialog
	CProjOptionsDlg dlg;

	dlg.SetSelection(pSelection);

	// do it
	dlg.DoModal();

	// o platform for exe projects
	CString strExtOptsPlatform_Post;
	if (m_bProjIsExe)
	{
		if (GetStrProp(P_ExtOpts_Platform, strExtOptsPlatform_Post) != valid)
			strExtOptsPlatform_Post = "";

		// has the platform changed?
		if (strExtOptsPlatform_Post != strExtOptsPlatform)
			theApp.NotifyPackages(PN_CHANGE_PLATFORM);
	}
}

void CProject::OnSettings()
{
	// multi-select targets
	// Is project window active?
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	BOOL bActive = pProjSysIFace->IsWindowActive() == S_OK;

	CMultiSlob SelectionSlob;
	CSlob * pSelection = NULL;
	if	(bActive)
	{
		CMultiSlob *	pMultiSlob = NULL;
		
		// Find the current selection.
		pProjSysIFace->GetSelectedSlob(&pMultiSlob);

		if( (pMultiSlob != NULL) && (pMultiSlob->GetContentList()->GetCount() > 0) )
		{
			
            CSlob * pDominantSlob = pMultiSlob->GetDominant();
			POSITION pos = pMultiSlob->GetContentList()->GetHeadPosition();
			while (pos != NULL)
			{
				CSlob * pSlob = (CSlob *)pMultiSlob->GetContentList()->GetNext(pos);
				if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)))
					pSlob = ((CBuildViewSlob *)pSlob)->GetBuildSlob();
			
				else if (!pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
					continue; // ignore ones that aren't ours
				pSlob = ((CBuildSlob *)pSlob)->GetProjItem();
				if ((pSlob->IsKindOf(RUNTIME_CLASS(CDependencyContainer))) ||
					(pSlob->IsKindOf(RUNTIME_CLASS(CDependencyFile))))
					continue;  // ignore deps
				if (pSlob->IsKindOf(RUNTIME_CLASS(CTargetItem)))
					pSlob = ((CProjItem *)pSlob)->GetProject();

				SelectionSlob.GetContentList()->AddTail(pSlob);
			}
		}
		if (!SelectionSlob.GetContentList()->IsEmpty())
			pSelection = &SelectionSlob;
	}

	OnSettingsCommon(pSelection);
}

void CProject::OnConfigurations()
{
	// Show the dialog.
	CProjectConfigurationsDlg dlg;

	dlg.DoModal();
}

void CProject::OnBuildGraph()
{
#ifdef DEPGRAPH_VIEW
	CGraphDialog grpdlg(g_buildengine.GetDepGraph(GetActiveConfig()));
	grpdlg.DoModal();
#endif
}

void CProject::OnUpdateBuildGraph(CCmdUI * pCmdUI)
{
	// This is only available if we are an internal makefile or a supported
	// internal projtype, and a build isn't in progress.
#ifdef DEPGRAPH_VIEW
	pCmdUI->Enable(!m_bProjIsExe && m_bProjIsSupported && !g_Spawner.SpawnActive());
#else
	pCmdUI->Enable(FALSE);
#endif
}

void CProject::OnDumpHeap()
{
#ifdef _DEBUG
	DumpHeap();
#endif
}


void CProject::OnProjectWrite()
{

	// skip calling the dialog if Automation or only 1 project
	int nProjects = m_lstProjects.GetCount();
	BOOL bUseDialog = ((nProjects > 1) && (g_pAutomationState->DisplayUI() && !g_bNoUI)); //ShellOM:State

	// REVIEW: ExportAs dialog?
	CProjectsDlg dlg;
	dlg.m_bExport = FALSE;
	CMultiSlob SelectionSlob;

	// copy selection to dialog, if any; otherwise use saved value
	if (bUseDialog)
	{
		if (GetSelectedProjects(SelectionSlob))
		{
			dlg.m_mapSelectedProjects.RemoveAll();
			POSITION pos = SelectionSlob.GetContentList()->GetHeadPosition();
			while (pos != NULL)
			{
				CProject * pProject = (CProject *)SelectionSlob.GetContentList()->GetNext(pos);
				ASSERT(pProject->IsKindOf(RUNTIME_CLASS(CProject)));
				dlg.m_mapSelectedProjects.SetAt(pProject->GetTargetName(), pProject);
			}
			ASSERT(!dlg.m_mapSelectedProjects.IsEmpty());
			SelectionSlob.GetContentList()->RemoveAll();
		}

		ASSERT(SelectionSlob.GetContentList()->IsEmpty());

		if (dlg.DoModal() != IDOK)
			return;
	}

	CProject::InitProjectEnum();
	CString strProject;
	CProject * pProject;
	while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, TRUE)) != NULL)
	{
		// use selected projects from dlg
		ASSERT((!bUseDialog) || (!dlg.m_mapSelectedProjects.IsEmpty()));
		if (bUseDialog)
		{
			CProject * pCmpProject;
			if (!dlg.m_mapSelectedProjects.Lookup(strProject, (void * &)pCmpProject))
			{
				continue;
			}
			else
			{
				ASSERT(pProject == pCmpProject);
			}
		}

		if( pProject->m_bProjIsExe ) 
		{
			ASSERT(0);
			continue;
		}

		// Always write the project file, even if it's not dirty
		g_bWriteProject = TRUE;
		pProject->m_bProjectDirty = TRUE;
		pProject->DoSave();
	}
}

void CProject::OnUpdateProjectWrite(CCmdUI * pCmdUI)
{
	// This is only available if we are an internal makefile or a supported
	// internal projtype, and a build isn't in progress.
#ifndef _SHIP
	pCmdUI->Enable(!m_bProjIsExe && m_bProjIsSupported && !g_Spawner.SpawnActive() && (GetFilePath()!=NULL));
#else
	pCmdUI->Enable(FALSE);
#endif
}

void CProject::OnUpdateDumpHeap(CCmdUI * pCmdUI)
{
	// This is only available if we are an internal makefile or a supported
	// internal projtype, and a build isn't in progress.
#ifndef _SHIP
	pCmdUI->Enable(TRUE);
#else
	pCmdUI->Enable(FALSE);
#endif
}

#if 0
void CProject::OnPopupSettings()
{
    // UNDONE (colint): Need to fix this to work with the new build view
	// create the options dialog
	//CSlobWnd * pSlobWnd = GetSlobWnd();
	//ASSERT(pSlobWnd->IsKindOf(RUNTIME_CLASS(CProjectView)));
	// copy the project window tree-control state
	//OnSettingsCommon(&((CProjectView *)pSlobWnd)->m_TreeWnd);

	// Is project window active?
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	BOOL bActive = pProjSysIFace->IsWindowActive() == S_OK;

	CMultiSlob SelectionSlob;
	CSlob * pSelection = NULL;
	if	(bActive)
	{
		CMultiSlob *	pMultiSlob = NULL;
		
		// Find the current selection.
		pProjSysIFace->GetSelectedSlob(&pMultiSlob);

		if( (pMultiSlob != NULL) && (pMultiSlob->GetContentList()->GetCount() > 0) )
		{
			
           	CSlob * pSlob = pMultiSlob->GetDominant();
			// UNDONE: not quite right
			{
				if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildViewSlob)))
					pSlob = ((CBuildViewSlob *)pSlob)->GetBuildSlob();
			
				if (pSlob->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
				{
					pSlob = ((CBuildSlob *)pSlob)->GetProjItem();
					// ignore deps
					if ((!pSlob->IsKindOf(RUNTIME_CLASS(CDependencyContainer))) &&
						(!pSlob->IsKindOf(RUNTIME_CLASS(CDependencyFile))))
					{
						// convert target to to project
						if (pSlob->IsKindOf(RUNTIME_CLASS(CTargetItem)))
							pSlob = ((CProjItem *)pSlob)->GetProject();

						SelectionSlob.GetContentList()->AddTail(pSlob);
					}
				}
			}
		}
		if (!SelectionSlob.GetContentList()->IsEmpty())
			pSelection = &SelectionSlob;
	}

    OnSettingsCommon(pSelection);
	// OnSettings();
}
#endif

void CProject::OnTools()
{
/*
R.I.P. for v4.0 with VBA?
	// get the tools dialog and show it as modal
	CToolsDlg dlg(this);
	dlg.DoModal();
*/
}

BOOL g_bStopBuild = FALSE;
BOOL g_bMultiBuild = FALSE;

void CProject::OnStopBuild()
{
	// only do this if spawner active!
	if (g_Spawner.SpawnActive())
	  	g_Spawner.DoSpawnCancel();

	if( g_bMultiBuild == TRUE)
		g_bStopBuild=TRUE;
}	 

// Start or stop a build
void CProject::OnToggleBuild()
{
	if (g_Spawner.SpawnActive() > 0)
	{
		OnStopBuild();
	}
	else
	{
		OnBuildPostMsg();
	}
}	 

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::InitNew(const CPtrList * plstProjType)
{
	m_listTargIncl.Init((HBUILDER)this); // REVIEW: do part of this in ctor

	if (plstProjType != (const CPtrList *)NULL)
	{
		POSITION pos = plstProjType->GetHeadPosition();
		ASSERT(pos != (POSITION)NULL);	// must have at least one projtype!

		HBLDTARGET hDebugTarg, hReleaseTarg;

		// create a pair of targets for each target type
		while (pos != NULL)
		{
			CProjType * pProjType = (CProjType *)plstProjType->GetNext(pos);
			(void) g_BldSysIFace.AddDefaultTargets
					(
						(const TCHAR *)*pProjType->GetPlatformName(),	// 'official' name of this target's platform
						(const TCHAR *)*pProjType->GetTypeName(),		// 'official' name of this target type
						hDebugTarg, hReleaseTarg,						// our new targets
						FALSE											// we're using 'official' names
					);
		}
	}

	m_bProjectComplete = TRUE;	// project is now ok to use...

	// add our deferred commands to the menu
	UpdateDeferredCmds(FALSE);

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////

// Given the name of a .EXE file (which need not exist), return our best
// guess as to the platform DESCRIPTION string (not the "official" platform
// string).  If the .EXE file doesn't exist, or if we can't figure out what
// type it is, return the platform description string for the primary platform.
BOOL GetPlatformDescriptionString(CString & strExeName, CString & strPlatDesc, BOOL * pbIsJava)
{
	// Default is the .EXE file doesn't exist, or we don't know its type.
	// Use the description string for the primary platform.
	strPlatDesc = *(g_prjcompmgr.GetPrimaryPlatform()->GetUIDescription());

	HANDLE hfile;
	DWORD dwBytes;
	IMAGE_DOS_HEADER doshdr;
	IMAGE_FILE_HEADER PEHeader;
	DWORD dwMagic;
	UINT nPlatformId;

	if ((hfile = CreateFile((const TCHAR *)strExeName, GENERIC_READ, FILE_SHARE_READ,
				NULL, OPEN_EXISTING, NULL, NULL)) == INVALID_HANDLE_VALUE)
		return TRUE;

	/* Look for XBE first */
	CString strExt = strExeName.Right(4);
	strExt.MakeLower();
	if(strExt == ".xbe") {
		ReadFile(hfile, &dwMagic, 4, &dwBytes, NULL);
		if(dwBytes == 4 && dwMagic == 0x48454258) {
			nPlatformId = xbox;
			goto GotPlatId;
		}
		SetFilePointer(hfile, 0, NULL, FILE_BEGIN);
	}

	ReadFile(hfile, (LPVOID) &doshdr, sizeof(IMAGE_DOS_HEADER), &dwBytes, NULL);
	if (dwBytes == sizeof(IMAGE_DOS_HEADER))
	{
		SetFilePointer(hfile, doshdr.e_lfanew, NULL, FILE_BEGIN);
		ReadFile(hfile, (LPVOID) &dwMagic, sizeof(dwMagic), &dwBytes, NULL);
		if (dwBytes == sizeof(dwMagic) || dwMagic != IMAGE_NT_SIGNATURE)
		{
			ReadFile(hfile, (LPVOID) &PEHeader, sizeof(IMAGE_FILE_HEADER), &dwBytes, NULL);
			if (dwBytes == sizeof(IMAGE_FILE_HEADER))
			{
				if (PEHeader.Machine != IMAGE_FILE_MACHINE_UNKNOWN)
				{
					// this may require putting the IMAGE_... value inside the CPlatform
					// object so that we can iterate through the CPlatform objects looking
					// for one with a matching value
					nPlatformId = g_prjcompmgr.GetIdFromMachineImage(PEHeader.Machine);
GotPlatId:
					if (nPlatformId != unknown_platform)
					{
						CPlatform *	pPlatform;

						g_prjcompmgr.InitPlatformEnum();
						while (g_prjcompmgr.NextPlatform(pPlatform))
						{
							if (pPlatform->GetUniqueId() == nPlatformId)
							{
								strPlatDesc = *(pPlatform->GetUIDescription());
								CloseHandle (hfile);
								return pPlatform->IsSupported();	// supported platform?
							}
						}
						// recognized but unsupported platform, so need to create
						// one dynamically and inform the caller of this fact (return FALSE)

						// register dynamic platform so deleted on exit
						pPlatform = new CPlatform(_T("<Unknown>"), nPlatformId);
						g_prjcompmgr.RegisterUnkProjObj(pPlatform);

						strPlatDesc = *(pPlatform->GetUIDescription());

						CloseHandle (hfile);
						return FALSE;	// unknown platform
					}
				}
				CloseHandle (hfile);
				return (TRUE);
			}
		}
	}
	// If we make it this far, the file exists and isn't an exe.  Maybe
	// its a java file.
	unsigned long ulMagic;

	SetFilePointer(hfile, 0, NULL, FILE_BEGIN);
	ReadFile(hfile, (LPVOID) &ulMagic, sizeof(unsigned long), &dwBytes, NULL);
	if (dwBytes == sizeof(unsigned long))
	{
		/*
		** Java: check for Java magic number 0xcafebabe
		*/
		if (ulMagic == 0xbebafeca)
		{

			// find the java platform...

			CPlatform *	pPlatform;

			g_prjcompmgr.InitPlatformEnum();
			while (g_prjcompmgr.NextPlatform(pPlatform))
			{
				if (pPlatform->GetUniqueId() == java)
				{
					strPlatDesc = *(pPlatform->GetUIDescription());
					CloseHandle (hfile);
					if (pbIsJava)
						*pbIsJava = TRUE;
					return pPlatform->IsSupported();	// supported platform?
				}
			}
			CloseHandle (hfile);
			return FALSE; // known but not supported.
		}
	}

	CloseHandle (hfile);
	return TRUE;	// unknown platform
}

void CProject::InitPrivateData()
{
	// Initailize private data based on makefile type:
	// If this is an external make file, create configurations named
	// "DEBUG" and "RELEASE", leaving DEBUG active, then prompt the
	// user for building info:
	CString str, str2;

    if (m_bProjIsExe)
	{
		CPath pathT;
		CPath pathTemp;

		pathT = *GetFilePath();
		pathTemp = pathT;

		// Setup the initial "Debug" target...

		str.LoadString (IDS_DEBUG_CONFIG);
		CreateConfig(str);
		SetStrProp ( P_ProjActiveConfiguration, str);

		// Set the default properties for the debug configuration:
		str = "NMAKE /f ";
		pathTemp.ChangeExtension(".mak");
		str += pathTemp.GetFileName();
		SetStrProp(P_ExtOpts_CmdLine, str);

		str = "/a";
		SetStrProp(P_ExtOpts_RebuildOpt, str);

		str = pathT.GetFileName();
		SetStrProp(P_ExtOpts_Targ, str);
		SetStrProp(P_Caller, str);

		// get the platform description string, if we
		// can't then this executable is known but unsupported
		// by an installed platform
		BOOL bIsJava = FALSE;

		if (!GetPlatformDescriptionString(str, str2, &bIsJava))
			InformationBox(IDS_EXE_NOT_SUPPORTED, str);
		SetStrProp(P_ExtOpts_Platform, str2);

		if (bIsJava)
		{
			// undo the exe stuff...

			str = _T("");

			SetStrProp(P_ExtOpts_CmdLine, str);
	   		SetStrProp(P_ExtOpts_RebuildOpt, str);
			SetStrProp(P_Caller, str);
		}

		pathTemp.ChangeExtension(".bsc");
		str = pathTemp.GetFileName();
		SetStrProp(P_ExtOpts_BscName, str);

		pathTemp.ChangeExtension(".clw");
		
		// This property is now defunct
		//str = pathTemp.GetFileName();
		//SetStrProp(P_ExtOpts_ClsWzdName, str);

		str = _T("");
		SetStrProp(P_WorkingDirectory, str);
		//SetStrProp(P_Args, str);
		SetIntProp(P_PromptForDlls, 1);
		SetStrProp(P_RemoteTarget, str);

		// set up default Java settings for .class projects
		if (bIsJava) {

			CString strEmpty = _T("");
			CString strTemp;

			// class name
			CString strClassName;
			pathT.GetBaseNameString(strClassName);
			SetStrProp(P_Java_ClassFileName, strClassName);

			// debug using browser/stand-alone interpreter
			SetIntProp(P_Java_DebugUsing, Java_DebugUsing_Standalone);

			// browser name
			// (GetStrProp will set this property as a side effect)
			GetStrProp(P_Java_Browser, strTemp);

			// stand-alone interpreter name
			// (GetStrProp will set this property as a side effect)
			GetStrProp(P_Java_Standalone, strTemp);
					
			// param source: html page or user
			SetIntProp(P_Java_ParamSource, Java_ParamSource_User);

			// HTML page
			SetStrProp(P_Java_HTMLPage, strEmpty);
					
			// temp HTML page
			GetStrProp(P_Java_TempHTMLPage, strTemp);
					
			// args in HTML form
			SetStrProp(P_Java_HTMLArgs, strEmpty);

			// command line args
			// set from command line args
			CString strArgs;
			GetStrProp(P_Args, strArgs);
			SetStrProp(P_Java_Args, strArgs);

			// stand-alone interpreter args
			SetStrProp(P_Java_StandaloneArgs, strEmpty);
						
			// debug stand-alone as applet or application
			SetIntProp(P_Java_DebugStandalone, Java_DebugStandalone_Application);
		}


		SetCurrentConfigAsBase() ;	// copying the current prop bag to the default
									// prop bag
	}
	else
	{
		// This is an internal makefile and we lost the OPT file, or
		// the project stream was out of date.  We'll  just quietly
		// generate default information as needed.

		if (!m_bProjHasNoOPTFile)
		{
			PFILE_TRACE("Couldn't read project stream from OPT file. Using defaults.\n");
		}
		else
		{
			PFILE_TRACE("As expected, we couldn't read project stream from OPT file.\n");

		}

		ASSERT_VALID (this);

		// we set the default configuration to  the first 'debug' one
		// or as read from the makefile
		CString strConfig;
		if ((GetStrProp(P_ProjActiveConfiguration, strConfig) != valid) || (strConfig.IsEmpty()))
		{
			if (!m_strProjStartupConfiguration.IsEmpty())
				SetStrProp(P_ProjActiveConfiguration,m_strProjStartupConfiguration);
			else
				SetStrProp(P_ProjActiveConfiguration,m_strProjDefaultConfiguration);
		}
	}

	// N.B. Can't touch m_bPrivateDataInitialized yet! (tree control uses it)
	m_bPrivateDataInitialized = TRUE;
	m_bNotifyOnChangeConfig = TRUE;
}
///////////////////////////////////////////////////////////////////////////////
void CProject::InitPrivateDataForExe ()
{
	// Currently this just does standard external makefile initialization.
	//
	// At some point, we may want to do something different, which is why
	// this method exists.
	InitPrivateData();
}

#ifdef VB_MAKEFILES

// vb project support
typedef enum {VBFILETYPE_NONE, VBFILETYPE_FORM, VBFILETYPE_MODULE, VBFILETYPE_CLASS, VBFILETYPE_DOCOBJ, VBFILETYPE_USERCTL, VBFILETYPE_PROPPAGE, VBFILETYPE_RES, VBFILETYPE_DESIGNER, VBFILETYPE_LASTVALUE } VBFILETYPE;


VBFILETYPE vbFileTypeFromHeaderName(CString headerName)
{
	if (headerName == "Form")
		return VBFILETYPE_FORM;
	else if (headerName == "Module")
		return VBFILETYPE_MODULE;
	else if (headerName == "Class")
		return VBFILETYPE_CLASS;
	else if (headerName == "UserDocument")
		return VBFILETYPE_DOCOBJ;
	else if (headerName == "UserControl")
		return VBFILETYPE_USERCTL;
	else if (headerName == "PropertyPage")
		return VBFILETYPE_PROPPAGE;
	else if (headerName == "ResFile32")
		return VBFILETYPE_RES;
	else if (headerName == "Designer")
		return VBFILETYPE_DESIGNER;
	else return VBFILETYPE_NONE;
}

int vbProjTypeFromHeaderName(CString value)
{
	if (value == "Type=Exe" || value == "Type=OleExe" )
		return 0;

	else if ( value == "Type=Control" )
		return 1;

	else if (value == "Type=OleDll"   )
		return 2;
	else
		return 0;
}

CString headerName(CString headerLine)
{
	return headerLine.Left(headerLine.Find('='));
}

CString headerValue(CString headerLine)
{
	CString result, newResult;

	result = headerLine.Right(headerLine.GetLength() - headerLine.ReverseFind('=') - 1);
	// remove quotation marks if necessary
	if (result[0] == '\"')
		result = result.Mid(1, result.GetLength() - 2);
	return result;
}

CString getStringFromLine(CString headerLine)
{
	CString result;

	result = headerLine.Right(headerLine.GetLength() - headerLine.ReverseFind('=') - 1);
	// remove quotation marks if necessary
	if (result[0] == '\"')
		result = result.Mid(1, result.GetLength() - 2);
	return result;
}

BOOL getBoolFromLine(CString headerLine)
{
	CString result;

	result = headerLine.Right(headerLine.GetLength() - headerLine.ReverseFind('=') - 1);
	// remove quotation marks if necessary
	if (result[0] == '0')
		return FALSE;
	return TRUE;
}

int getIntFromLine(CString headerLine)
{
	CString result;

	result = headerLine.Right(headerLine.GetLength() - headerLine.ReverseFind('=') - 1);
	// remove quotation marks if necessary
	if (result[0] == '0')
		return FALSE;
	return TRUE;
}

void CProject::OpenVBProject(const TCHAR *szFileName)
{
	CStdioFile projectFile(szFileName, CFile::modeRead | CFile::typeText);
	CString projectData, relativePath;
	CDir vbpDir;
	CPath filePath;
	VBFILETYPE fileType;
	int projType=0;
	
    int i;
	BOOL filesFound[VBFILETYPE_LASTVALUE];
	for(i=0;i<VBFILETYPE_LASTVALUE;i++)
		filesFound[i] = FALSE;

	
	CString vbExeName;
	CString vbExeRelativePath; 
	CString vbProjName;
	
	CStringList vbProjFileNames;
	m_pVBinfo = new VBInfo;

	vbpDir.CreateFromPath(szFileName);
	while (projectFile.ReadString(projectData)) {
		CString projectHeaderName = headerName(projectData);
		fileType = vbFileTypeFromHeaderName(projectHeaderName);
		if (fileType != VBFILETYPE_NONE) {
			if (fileType == VBFILETYPE_FORM || fileType == VBFILETYPE_DOCOBJ || fileType == VBFILETYPE_USERCTL || fileType == VBFILETYPE_PROPPAGE|| fileType == VBFILETYPE_RES|| fileType == VBFILETYPE_DESIGNER)
				relativePath = headerValue(projectData);
			else if (fileType == VBFILETYPE_MODULE || fileType == VBFILETYPE_CLASS)
				relativePath = projectData.Right(projectData.GetLength() - projectData.ReverseFind(';') - 2);

			filePath.CreateFromDirAndFilename(vbpDir, relativePath);
			vbProjFileNames.AddTail(filePath.GetFullPath());
			filesFound[fileType] = TRUE;

		} 
		else {
			if (projectHeaderName == "ExeName32"){
				vbExeName = headerValue(projectData);
				m_pVBinfo->m_ExeName32 = getStringFromLine(projectData);
			}
			else if (projectHeaderName == "Path32"){
				vbExeRelativePath = headerValue(projectData);
				m_pVBinfo->m_Path32 = getStringFromLine(projectData);
			}
			else if (projectHeaderName == "Name"){
				vbProjName = headerValue(projectData);
				m_pVBinfo->m_Name = getStringFromLine(projectData);
			}
			else if (projectHeaderName == "Type") {
				projType = vbProjTypeFromHeaderName(projectData);
				m_pVBinfo->m_Type = getStringFromLine(projectData);
			}
			else if (projectHeaderName == "IconForm")
				m_pVBinfo->m_IconForm = getStringFromLine(projectData);
			else if (projectHeaderName == "Startup")
				m_pVBinfo->m_Startup = getStringFromLine(projectData);
			else if (projectHeaderName == "HelpFile")
				m_pVBinfo->m_HelpFile = getStringFromLine(projectData);
			else if (projectHeaderName == "Title")
				m_pVBinfo->m_Title = getStringFromLine(projectData);
			else if (projectHeaderName == "Command32")
				m_pVBinfo->m_Command32 = getStringFromLine(projectData);
			else if (projectHeaderName == "HelpContextID")
				m_pVBinfo->m_HelpContextID = getStringFromLine(projectData);
			else if (projectHeaderName == "CompatibleMode")
				m_pVBinfo->m_CompatibleMode = getStringFromLine(projectData);
			else if (projectHeaderName == "MajorVer")
				m_pVBinfo->m_MajorVer = getBoolFromLine(projectData);
			else if (projectHeaderName == "MinorVer")
				m_pVBinfo->m_MinorVer = getBoolFromLine(projectData);
			else if (projectHeaderName == "RevisionVer")
				m_pVBinfo->m_RevisionVer = getBoolFromLine(projectData);
			else if (projectHeaderName == "AutoIncrementVer")
				m_pVBinfo->m_AutoIncrementVer = getBoolFromLine(projectData);
			else if (projectHeaderName == "ServerSupportFiles")
				m_pVBinfo->m_ServerSupportFiles = getBoolFromLine(projectData);
			else if (projectHeaderName == "VersionCompanyName")
				m_pVBinfo->m_VersionCompanyName = getStringFromLine(projectData);
			else if (projectHeaderName == "CompilationType")
				m_pVBinfo->m_CompilationType = getBoolFromLine(projectData);
			else if (projectHeaderName == "OptimizationType")
				m_pVBinfo->m_OptimizationType = getBoolFromLine(projectData);
			else if (projectHeaderName == "FavorPentiumPro(tm)")
				m_pVBinfo->m_FavorPentiumPro = getBoolFromLine(projectData);
			else if (projectHeaderName == "CodeViewDebugInfo")
				m_pVBinfo->m_CodeViewDebugInfo = getBoolFromLine(projectData);
			else if (projectHeaderName == "NoAliasing")
				m_pVBinfo->m_NoAliasing = getBoolFromLine(projectData);
			else if (projectHeaderName == "BoundsCheck")
				m_pVBinfo->m_BoundsCheck = getBoolFromLine(projectData);
			else if (projectHeaderName == "OverflowCheck")
				m_pVBinfo->m_OverflowCheck = getBoolFromLine(projectData);
			else if (projectHeaderName == "FlPointCheck")
				m_pVBinfo->m_FlPointCheck = getBoolFromLine(projectData);
			else if (projectHeaderName == "FDIVCheck")
				m_pVBinfo->m_FDIVCheck = getBoolFromLine(projectData);
			else if (projectHeaderName == "UnroundedFP")
				m_pVBinfo->m_UnroundedFP = getBoolFromLine(projectData);
			else if (projectHeaderName == "StartMode")
				m_pVBinfo->m_StartMode = getBoolFromLine(projectData);
			else if (projectHeaderName == "Unattended")
				m_pVBinfo->m_Unattended = getBoolFromLine(projectData);
			else if (projectHeaderName == "ThreadPerObject")
				m_pVBinfo->m_ThreadPerObject = getBoolFromLine(projectData);
			else if (projectHeaderName == "MaxNumberOfThreads")
				m_pVBinfo->m_MaxNumberOfThreads = getIntFromLine(projectData);
		}
	}
	projectFile.Close();

	CDir exeDir;
	CString relativeFilename;
	
	if (vbExeRelativePath.IsEmpty())
		relativeFilename = vbExeName;
	else relativeFilename = vbExeRelativePath + "\\" + vbExeName;

	CPath vbExeFullPath;
	vbExeFullPath.CreateFromDirAndFilename(m_ActiveTargDir, relativeFilename);
	
	// then make this a makefile/vb project
	
	// Reading an external makefile
	HBLDTARGET hDebugTarg = NO_TARGET;
	HBLDTARGET hReleaseTarg;
	CString strTypeName;
	strTypeName.LoadString(IDS_EXTTARG_PROJTYPE);

	// Create all the external targets
	CString strPlatformName;
	strPlatformName = "Win32";

	// Add debug and release targets
	(void) g_BldSysIFace.AddDefaultTargets
			((const TCHAR *) strPlatformName,
			(const TCHAR *)strTypeName,
			hDebugTarg, hReleaseTarg,
			TRUE, TRUE, TRUE, hDebugTarg
			);

	// At this point loop through creating folders if appropriate (with filters)
	if( filesFound[VBFILETYPE_FORM] == TRUE )
		GetActiveTarget()->AddNewGroup("Forms","frm");
	if( filesFound[VBFILETYPE_MODULE] == TRUE )
		GetActiveTarget()->AddNewGroup("Modules","bas");
	if( filesFound[VBFILETYPE_CLASS] == TRUE )
		GetActiveTarget()->AddNewGroup("Class Modules","cls");
	if( filesFound[VBFILETYPE_DOCOBJ] == TRUE )
		GetActiveTarget()->AddNewGroup("Doc Objects","dob");
	if( filesFound[VBFILETYPE_USERCTL] == TRUE )
		GetActiveTarget()->AddNewGroup("User Controls","ctl");
	if( filesFound[VBFILETYPE_PROPPAGE] == TRUE )
		GetActiveTarget()->AddNewGroup("Property Pages","pag");
	if( filesFound[VBFILETYPE_DESIGNER] == TRUE )
		GetActiveTarget()->AddNewGroup("Designers","dsr");
	if( filesFound[VBFILETYPE_RES] == TRUE )
		GetActiveTarget()->AddNewGroup("Resources","res");

	// Then loop through the files adding them
	HBUILDER hBld = g_BldSysIFace.GetActiveBuilder();
	HFILESET hFileSet = g_BldSysIFace.GetFileSet(hBld, hDebugTarg);
	POSITION pos = vbProjFileNames.GetHeadPosition();
	while (pos != NULL)
	{
		CPath pathFile;
		pathFile.Create(vbProjFileNames.GetNext(pos));
		g_BldSysIFace.AddFile(hFileSet, &pathFile, FALSE);
	}

	// then set the debug and make information.
	CProjType *pProjType = GetProjType();
	const CPtrArray * pCfgArray = GetConfigArray();
	int cCfgs = pCfgArray->GetSize();
	CProjTempConfigChange cfgChange(this);
	for ( i=0; i < cCfgs; i++)
	{
		cfgChange.ChangeConfig((ConfigurationRecord *)(*pCfgArray)[i]);
		((CProjTypeExternalTarget*)pProjType)->SetDefaultVBTargetOptions(this,GetActiveTarget(),projType,m_pVBinfo);
	}
	m_strVBProjFile = szFileName;
	m_bVB = TRUE;
}
#endif

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::InitFromFile (const char *pFileName, BOOL /* bLoadOPTFile  = TRUE */)
{
//	Read in the supplied makefile.  We dont' know yet if its internal or
//  external, and we won't know until we call ReadMakeFile (which looks for
//	the signature string).  If it is an internal file, load silently, regards
//  of whether or not the OPT file has been found.  If its external, and there
//  is a OPT file, also load silently, since presumably this file has been used
//  as external before.  If its an external makefile and there's no OPT, then
//  as if we should import:

	CPath NewPath;
	ReadMakeResults rmr;
	g_bErrorPrompted = FALSE;
	g_pConvertedProject = NULL;
	g_bConvDontTranslate = FALSE;
	g_bNoUI = theApp.m_bRunInvisibly || !g_pAutomationState->DisplayUI(); //ShellOM:State
	CString strMsg;
	CString	strCmdLine;		// holds command line for .exe on command line proj
	CWaitCursor wc ;		// Wait cursor while load is in progress
	BOOL	bProjectDirty = FALSE ;
	CPath::ResetDirMap(); // clear cache for new project
	
	// Dirty until load successfully:
    DirtyProject();

	if (!NewPath.Create (pFileName) || !SetFile (&NewPath) ) return FALSE;
	InformDependants (SN_FILE_NAME);

	// See if this is an exe file.  If so, there's no point in trying
	// to read the makefile.
	if (IsExecutableFile(pFileName))
	{
		m_bProjIsExe = TRUE;

		if (!theApp.m_argList.IsEmpty())
		{
			// indicates we are processing an exe on the command line!
			strCmdLine = theApp.m_lpCmdLine;
			CString	strDoc = theApp.m_strCurArg;

			strCmdLine.MakeUpper();
			strDoc.MakeUpper();

			int	ich = strCmdLine.Find(strDoc);

			ASSERT ( ich != -1 );	// we must find the substring in this case
			if ( ich >= 0 )
			{
				// get past the doc name
				ich += strDoc.GetLength();
				// skip one (and only one) blank after the doc name
				if (ich < strCmdLine.GetLength() && (_istspace(strCmdLine[ich]) || 
					(ich!=0 && !IsDBCSLeadByte(strCmdLine[ich-1]) && strCmdLine[ich] == _T('"'))))
					++ich;
				// extract the rest of the command line	after restoring the
				// command line to original form
				strCmdLine = theApp.m_lpCmdLine;
				CString	strT = strCmdLine.Right(strCmdLine.GetLength() - ich);
				strCmdLine = strT;
			}
		}
	}

#ifdef VB_MAKEFILES
	else if( !_tcsicmp( NewPath.GetExtension(),".vbp") )
	{
		// attempt to make a makefile type project out of this vb project
		OpenVBProject(NewPath.GetFullPath());
		
		NewPath.ChangeExtension(".dsp");
		SetFile(&NewPath);
		InformDependants (SN_FILE_NAME);
		// Mark project so that we will immediately save it
		m_bProjMarkedForSave = TRUE;
		m_bProjConverted = TRUE;
		m_bProjHasNoOPTFile  = TRUE;
		bProjectDirty = TRUE;
		::SetWorkspaceDocDirty();
	}
#endif

	else
	{
		// disable file registry file change notification during builder load
		//g_FileRegDisableFC = TRUE;

		rmr = ReadMakeFile (bProjectDirty);

		if (rmr == ReadExportedMakefile)
		{
			// if we opened an exported makefile, try again with the new filename
			rmr = ReadMakeFile(bProjectDirty);
		}
		// enable file registry file change notification
		//g_FileRegDisableFC = FALSE;

		if (rmr == ReadError)
		{
			// make sure we scc knows we failed
			if (g_pSccManager->IsSccInstalled() == S_OK)
			{
				g_pSccManager->CancelGetProject(pFileName);
			}

			return FALSE;
		}
		else if (rmr == ReadExternal)
		{
			// No longer is an external makefile

			// make sure scc knows we failed
			if (g_pSccManager->IsSccInstalled() == S_OK)
			{
				g_pSccManager->CancelGetProject(pFileName);
			}

			if ((g_prjcompmgr.GetSupportedPlatformCount () == 1) &&
				(g_prjcompmgr.GetPrimaryPlatform ()->GetUniqueId () == java))
			{
				CProjTempProjectChange projTempProjectChange (NULL);
				MsgBox (Error, IDS_CANT_WRAP_JAVA);
				return FALSE;
			}

			UINT nID = m_bProjConverted ? IDS_CONVERSION_FAILED : IDS_MAKEFILE_BAD_FORMAT;
			CString str1;
			MsgText (str1, nID, (const char *) NewPath);
			if (g_pAutomationState->DisplayUI() && !g_bNoUI) //ShellOM:State
			{
				// Give warning about opening this makefile as an external
				// makefile
				CString str;
				CProjTempProjectChange projTempProjectChange (NULL);
				if (MsgBox (Question, MsgText ( str, IDS_WRAP_MAKEFILE, (const TCHAR *) str1), MB_YESNO) == IDNO)
				{
					return FALSE;
				}
			}
			else
			{
				// This operation is being run by Automation.
				// We cannot put up UI, so we will answer NO to the prompt.
				g_pAutomationState->SetError(DS_E_PROJECT_EXTERNAL_MAKEFILE) ;
				if (theApp.m_bInvokedCommandLine)
				{
					theApp.WriteLog(str1, TRUE);
				}
				return FALSE ;
			}

			// come up with a name for this project
			CString strProjectName;
			NewPath.GetBaseNameString(strProjectName);
 			SetTargetName(strProjectName);
			ASSERT(GetPropBagCount() == 0); // should be cleaned up by now

			m_bProjConverted = m_bConvertedVC20 = FALSE;

 			// Put up the platforms dialog if we have more than one
			// platform installed on the system
			CStringList lstPlatforms;
			if (g_prjcompmgr.GetSupportedPlatformCount() > 1)
			{
				CPlatformsDlg dlg(&lstPlatforms);
				CProjTempProjectChange projTempProjectChange (NULL);
				if (dlg.DoModal() != IDOK)
					return FALSE;
			}
			else
			{
				// Create external targets for the primary platform
				CPlatform* pPlatform = g_prjcompmgr.GetPrimaryPlatform();
				const CString * pstrPlatformName = pPlatform->GetUIDescription();
				lstPlatforms.AddTail(*pstrPlatformName);
			}

			// Reading an external makefile
			HBLDTARGET hDebugTarg = NO_TARGET;
			HBLDTARGET hReleaseTarg;
			CString strTypeName;
			strTypeName.LoadString(IDS_EXTTARG_PROJTYPE);

            // Create all the external targets
			CString strPlatformName;
			POSITION pos = lstPlatforms.GetHeadPosition();
			while (pos != NULL)
			{
				strPlatformName = lstPlatforms.GetNext(pos);
			
				// Add debug and release targets
				(void) g_BldSysIFace.AddDefaultTargets
						((const TCHAR *) strPlatformName,
						(const TCHAR *)strTypeName,
						hDebugTarg, hReleaseTarg,
						TRUE, TRUE, TRUE, hDebugTarg
						);
			}

			// Add the external makefile as a file in the wrapper internal
			// makefile.
			HBUILDER hBld = g_BldSysIFace.GetActiveBuilder();
			HFILESET hFileSet = g_BldSysIFace.GetFileSet(hBld, hDebugTarg);
			g_BldSysIFace.AddFile(hFileSet, &NewPath, FALSE);
			NewPath.ChangeExtension(".dsp");
			SetFile(&NewPath);
			InformDependants (SN_FILE_NAME);

			// Mark project so that we will immediately save it
 			m_bProjMarkedForSave = TRUE;
			m_bProjConverted = TRUE;
			m_bProjHasNoOPTFile  = TRUE;
			bProjectDirty = TRUE;
			::SetWorkspaceDocDirty();

			// Flag that the current project was created by converting
			// an external makefile
			m_bProjExtConverted = TRUE;

			// Force us to ignore the OPT file if one exists

			// Try to get info from any existing OPT file
			//ConvertOPTFile(&lstDebugConfigs, &lstReleaseConfigs);
 		}
		else if (rmr == ReadInternal)
		{
		}
		else
		{
			ASSERT(FALSE);
			// make sure scc knows we failed
			if (g_pSccManager->IsSccInstalled() == S_OK)
			{
				g_pSccManager->CancelGetProject(pFileName);
			}

			return FALSE;
		}

		if (m_bConvertedVC20)
		{
			// If the imported VC2 project has any browse info turned on, we will ask the user whether
			// it should be turned off.
			//
			BOOL fQueriedUser = FALSE;
			BOOL fTurnOffBrowse;

			const CPtrArray * pCfgArray = GetConfigArray();
			int cCfgs = pCfgArray->GetSize();
			for (int i=0; i < cCfgs; i++)
			{
				ConfigurationRecord *pConfiguration = (ConfigurationRecord *)pCfgArray->GetAt(i);
				ASSERT_VALID(pConfiguration);

				POSITION pos = pConfiguration->GetActionList()->GetHeadPosition();
				while (pos != (POSITION)NULL)
				{
					CActionSlob * pAction = (CActionSlob *)
											pConfiguration->GetActionList()->GetNext(pos);
					ASSERT_VALID(pAction);

					pAction->m_dwEvent = FALSE;	// assume browse is off
					if (pAction->m_pTool != (CBuildTool *)NULL)
					{
						pAction->m_pTool->OnActionEvent(ACTEVT_QueryBrowse, pAction);
					}
					if (!pAction->m_dwEvent)
					{
						continue;	// ignore this action (browsing not turned on)
					}

					if (!fQueriedUser)
					{
						CString strMsg;
						strMsg.LoadString(IDS_TURN_OFF_BROWSE);
						CProjTempProjectChange projTempProjectChange (NULL);
						fTurnOffBrowse = (AfxMessageBox(strMsg, MB_YESNO) == IDYES);
						fQueriedUser = TRUE;
					}

					if (fTurnOffBrowse)
					{
						// Turn off compiler browsing for this action
						CProjTempConfigChange projTempConfigChange(this);
						projTempConfigChange.ChangeConfig(pConfiguration);

						pAction->m_dwEvent = FALSE;
						pAction->m_pTool->OnActionEvent(ACTEVT_SetBrowse, pAction);
						pAction->DirtyCommand();
					}
					else
					{
						// Turn on bscmake for this config

						CProjTempConfigChange projTempConfigChange(this);
						projTempConfigChange.ChangeConfig(pConfiguration);

						// get our browser database tool and create our action
						CBuildTool * pTool;
						VERIFY(g_prjcompmgr.LookupBldSysComp(
							GenerateComponentId(idAddOnGeneric, BCID_Tool_BscMake),
							(CBldSysCmp *&)pTool));
						CActionSlob action(this, pTool);
						pTool->SetDeferredAction(&action, dabNotDeferred);

						// we're done with this config
						break;
					}
				}
			}
		}

		RecheckReadOnly();	// See if the .MAK file is read-only
	}

    CleanProject();

    // UNDONE (colint): We need to get this to work properly under the
    // new project loading mechanism
 	//if (!m_bProjExtConverted && bLoadOPTFile)
 	//	LoadOPTFiles ();

	PFILE_TRACE ("Initialzing makefile from %s. ReadMakeFile returned %i, "
		"m_bPrivateDataInitialized = %i\n", pFileName, rmr,
		m_bPrivateDataInitialized );

	// add our deferred commands to the menu
	UpdateDeferredCmds(FALSE);

	#ifdef _DEBUG
	BOOL b = FALSE;
	if (b) AfxDump (this);
	#endif

	if (m_bProjIsExe)
 	{
		CString str;
		str.LoadString (IDS_DEBUG_CONFIG);
		CreateConfig(str);
		g_BldSysIFace.GetTarget(str,(HBUILDER)this);

		// we will always initialize P_Args here
		SetStrProp(P_Args, strCmdLine);
	}

	// Make sure that we have initialised the current target on view
//	if (m_pPSWnd->m_TreeWnd.GetContainer() == (CSlob *)NULL)
//	{
		// Tree-control
		//SetActiveConfig(m_strProjActiveConfiguration, FALSE);

		// Active configuration
		//InformDependants(P_ProjActiveConfiguration);
//	}

	// we can set the project to dirty by now
	if (bProjectDirty)
	{
		// set project as dirty
        DirtyProject();
	}

	BOOL bFoundNonJavaProject = FALSE;
	CString str, strProjects;
	if (m_bConvertedDS4x)
	{
		ASSERT(IsKindOf(RUNTIME_CLASS(CProject)));
		CProject * pProject;
		CProject::InitProjectEnum();
		while ((pProject = (CProject *)CProject::NextProjectEnum(str, FALSE)) != NULL)
		{
			// only consider the recently converted ones
			if (pProject->m_bConvertedDS4x)
			{
				pProject->m_bProjectComplete = TRUE;	// projects are now ok to use...
				// get the current platform
				CPlatform* pPlatform = pProject->GetCurrentPlatform();
				ASSERT(pPlatform != NULL);
				if ((pPlatform == NULL) || (pPlatform->GetUniqueId() != java))
				{
					bFoundNonJavaProject = TRUE; // found non-Java project
				}

				strProjects += '\t';
				strProjects += *pProject->GetFilePath();
				strProjects += '\n';
			}
		}
	}
	else
	{
		bFoundNonJavaProject = TRUE; // no Java until 4.x
 		m_bProjectComplete = TRUE;	// project is now ok to use...
		strProjects += '\t';
		strProjects += *GetFilePath();
		strProjects += '\n';
	}

	// skip this dialog when doing minor conversion from 5.x
	if ((m_bProjConverted) && (rmr == ReadInternal) && (!m_bConvertedDS5x))
	{
		CString strOut, str2, str3, str4, str5;
		MsgText(strOut, IDS_CONVERTED1, NewPath.GetFileName());
		strOut += strProjects;

		if (bFoundNonJavaProject) // if not just Java
		{
			MsgText(str2, IDS_CONVERTED2, (LPCSTR)BUILDER_EXT, (LPCSTR)BUILDER_EXT);
			MsgText(str3, IDS_CONVERTED3);
			MsgText(str4, IDS_CONVERTED4);
			MsgText(str5, IDS_CONVERTED5);
			strOut += str2 + str3 + str4 + str5;
		}
		CProjTempProjectChange projTempProjectChange (NULL);
		MsgBox(Information, strOut);
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
void CProject::GetOPTFileName(CPath & OptPath)
{
 	const CPath *pPath;
	pPath = GetFilePath ();
	ASSERT (pPath);
	//	Get app to save OPT file:
	OptPath = *pPath;
	ProjNameToOptName (OptPath);
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::DoSave (BOOL /* bSavePrivate */ )
{
	ASSERT (!m_bProjIsExe);
	if( m_bProjIsExe ) 
		return TRUE;

	// This will change the active project.  The destructor will change it back.
	CProjTempProjectChange projTempProjectChange (this); 
	
	ASSERT (GetFilePath() != NULL);	// Should have a file name by now.

	// Only save if the project is dirty
	if (!IsDirty() && !g_bExportMakefile)
	{
		// reset flag for next time
		g_bWriteProject = FALSE;
		return TRUE;
	}

	CPath path = *GetFilePath();
	CIgnoreFile ignoreDspFile(GetFileChange(), path, BldSrcFileChangeCallBack);

	// just in case, do the .mak file too
	path.ChangeExtension(_T(".mak"));
	CIgnoreFile ignoreMakFile(GetFileChange(), path, BldSrcFileChangeCallBack);

	// disable file registry file change notification during builder save
	BOOL bOldDisable = g_FileRegDisableFC;
	g_FileRegDisableFC = TRUE;

#if 0
	// FUTURE: this should really be handled using notifications
	BOOL bIsSccInstalled = (g_pSccManager->IsSccInstalled() == S_OK);
	if (bIsSccInstalled)
	{
		g_pSccManager->OnProjSave((HPROJECT)this); // may dirty project
	}
#endif

	ASSERT(g_bExportMakefile || g_bWriteProject || g_bExportDeps);
	if (!g_bExportMakefile && !g_bExportDeps)
		g_bWriteProject = TRUE; // default

	// always write external makefile if user requests this behavior
	if (g_bAlwaysExportMakefile)
		g_bExportMakefile = TRUE;

 	CProjType *pProjType = GetProjType();
	if( pProjType ) {
		if ( pProjType->GetUniqueTypeId() == CProjType::exttarget ||
			 pProjType->GetUniqueTypeId() == CProjType::javaapplet 
		   )
		{
			// can't do this for makefile projects or java projects
			g_bExportMakefile = FALSE;
		}
	}


	CPath pathDep = *GetFilePath();
	pathDep.ChangeExtension("dep");
	// always write a .dep file if we're writing a .mak and it doesn't exist
	if (g_bExportMakefile && !pathDep.ExistsOnDisk())
		g_bExportDeps = TRUE;

	//
	// review(tomse): This is the slow part!
	//
	if (g_bExportDeps)
	{
		CWaitCursor waitCur;

		// Calling BeginCache/EndCache prevents scanner cache from being cleared
		// in-between configurations.  This prevents files from being scanned for
		// each configuration.
		//
		g_ScannerCache.BeginCache();

		const CPtrArray * pCfgArray = GetConfigArray();
		int icfg, size = pCfgArray->GetSize();

//
// #ifdef USE_LATEST_IDB code is used if CFileItem::ScanDependencies supports
// adding minimal rebuild dependencies to the scanner cache.
//
	if (!m_bProj_PerConfigDeps)	// fast export if not per-config deps
	{
		//
		// review(tomse) : checked in disabled because of risk that special files
		// such as the .pch that are configuration specific could be erroneously added
		// as a dependency to another configuration.  This would be bad for files that
		// were dependent only one the source and the pch files.
		//
		int iLatestBuiltCfg = -1; // default if no .idb
		int iSupportedConfig = -1;
		FILETIME ftLatest = {0,0};

		//
		// Find configuration with most recent .idb first
		//
		for (icfg = 0; icfg < size; icfg++)
		{
			ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(icfg);
			CProjTempConfigChange projTempConfigChange(this);
			projTempConfigChange.ChangeConfig(pcr);

			if ((iSupportedConfig == -1) && (pcr->IsSupported()) && (pcr->IsBuildable()))
				iSupportedConfig = icfg;

			CPath pathIdb = GetMrePath(pcr);
			FileRegHandle frh = CFileRegFile::LookupFileHandleByName(pathIdb);
			if (NULL!=frh)
			{
				FILETIME ft;
				if (frh->GetFileTime(ft))
				{
					//
					// New canidate for most recent build
					//
					if (ft > ftLatest)
					{
						iLatestBuiltCfg = icfg;
						ftLatest = ft;
					}
				}
				frh->ReleaseFRHRef();
			}
		}

		// make sure we have a good default
		if (iLatestBuiltCfg == -1)
			iLatestBuiltCfg = (iSupportedConfig == -1) ? 0 : iSupportedConfig;

		//
		// Scan configuration with most recent .idb first
		//
		if (iLatestBuiltCfg != m_nScannedConfigIndex)
		{
			m_nScannedConfigIndex = iLatestBuiltCfg;
			ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(iLatestBuiltCfg);
			CProjTempConfigChange projTempConfigChange(this);
			projTempConfigChange.ChangeConfig(pcr);
			ScanDependencies(TRUE,FALSE);
		}
	}
	else	// if per-config deps, get the rest too
	{
	// don't need this with fast exports
		//
		// Update dependencies for all configurations using any method available before exporting
		// makefile.
		//
		for (icfg = 0; icfg < size; icfg++)
		{
#ifdef USE_LATEST_IDB
			// Skip iLatestBuiltCfg since it has alredy been scanned.
			if (icfg==iLatestBuiltCfg)
				continue;
#endif

			ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(icfg);
			CProjTempConfigChange projTempConfigChange(this);
			projTempConfigChange.ChangeConfig(pcr);

			ScanDependencies(TRUE,FALSE);
		}
	}	// if per-config deps
	}

	BOOL bRetVal = TRUE;
	// Rewrite the builder's makefile.
	if (g_bExportMakefile || g_bWriteProject)
	{
		if (g_buildfile.WriteBuildFile(this))
			CleanProject();
		else
			bRetVal = FALSE;
	}

	if (g_bExportDeps)
	{
		g_ScannerCache.EndCache();
	}

	// reset flags for next time
	g_bWriteProject = g_bExportMakefile = g_bExportDeps = FALSE;

	// update timestamp now so we'll be sure to ignore bogus file change notification
	((CFileRegFile *)g_FileRegistry.GetRegEntry(GetFileRegHandle()))->RefreshAttributes();

	// enable file registry file change notification
	g_FileRegDisableFC = bOldDisable;

	return bRetVal;
}

static UINT projIDS[] = { IDS_FILTER_PROJECTS, 0 };

class CTempProjDoc : public CPartDoc
{
public:
	CTempProjDoc() { }
	~CTempProjDoc() { }
	virtual BOOL GetValidFilters(UINT** paIDS, UINT * pnInitial) { *paIDS = projIDS; *pnInitial = 0; return TRUE; }
};

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::DoSaveAs (BOOL /* bSavePrivate */)
{
	ASSERT (!m_bProjIsExe);
	ASSERT (!m_strProjItemName.IsEmpty ());

	CPath NewPath;
	CString newName;

	if (GetFilePath())
	{
		newName = (const char *) *GetFilePath ();
	}
	else
	{
		newName = m_strProjItemName;

		if (newName.GetLength() > 8)
			newName.ReleaseBuffer(8);
		int iBad = newName.FindOneOf(" #%;/\\");    // dubious filename
		if (iBad != -1)
			newName.ReleaseBuffer(iBad);

		ASSERT ( iBad == -1 || iBad > 0 );
		// append the default suffix if there is one
	}

	if (m_bProjExtConverted)
	{
		// Change default so that it is not the same as the existing external
		// makefile
        if (!NewPath.Create(newName))
            return FALSE;

        NewPath.PostFixNumber();
        NewPath.ChangeExtension(_T(BUILDER_EXT));
        newName = (const char *)NewPath;
	}

	// Try to get an ok file name to use to do the save
	CPath OriginalPath = NewPath;
	BOOL bNameOK;
	do
	{
		bNameOK = TRUE;

		// Do prompt will add the extension .bld even if an extension already exists
		if (!NewPath.Create(newName))
			return FALSE;

 
        NewPath.ChangeExtension(_T("."));
        newName = (const char *)NewPath;

		// UNDONE: need a doc template for last argument
#if 0
		if (!AfxGetApp()->DoPromptFileName(newName, AFX_IDS_SAVEFILE,
			OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_NOREADONLYRETURN, FALSE, NULL))
 			return FALSE;
#else
		UINT nSaveType;
		CTempProjDoc projDoc;
		if (!theApp.DoPromptFileSave(newName, AFX_IDS_SAVEFILE,
			OFN_HIDEREADONLY | OFN_PATHMUSTEXIST | OFN_NOREADONLYRETURN, &projDoc, &nSaveType))
 			return FALSE;
#endif

		
		if (!NewPath.Create(newName))
			return FALSE;

		NewPath.ChangeExtension(_T(BUILDER_EXT));
   
		// If we are saving an internal makefile created by loading an external makefile
		// then we do NOT allow the user to save using the file name of the external
		// makefile.
		if (m_bProjExtConverted && NewPath == *GetFilePath())
		{
			CString strMsg;
			MsgBox(Information, MsgText(strMsg, IDS_EXTTARG_BAD_PROJ_NAME, (const TCHAR *) *GetFilePath()));
			bNameOK = FALSE;
	        newName = (const char *)OriginalPath;
			continue;
		}

		if (m_bProjExtConverted)
		{
			// this assumes the all external makefiles generate ".exe" 's !!! 
			CPath pathExe = NewPath;

			CString strExe;
			pathExe.ChangeExtension(_T(".exe"));
			strExe = pathExe.GetFileName();

			CTargetItem* pTarget = GetActiveTarget();
			CString strProjectName;

			NewPath.GetBaseNameString(strProjectName);
			SetTargetName(strProjectName);
			ASSERT(pTarget != NULL);
			if (pTarget != NULL)
				pTarget->SetTargetName(strProjectName);

			CString strBsc;
			pathExe.ChangeExtension(_T(".bsc"));
			strBsc = pathExe.GetFileName();

			const CPtrArray * pCfgArray = GetConfigArray();
			for (int nConfig = 0; nConfig < pCfgArray->GetSize(); nConfig++)
			{
				CProjTempConfigChange projTempConfigChange(this);
				projTempConfigChange.ChangeConfig((ConfigurationRecord *)pCfgArray->GetAt(nConfig));

				SetStrProp(P_Proj_Targ, strExe);
				SetStrProp(P_Caller, strExe);
				SetStrProp(P_Proj_BscName, strBsc);

				CString strName;
				pathExe.GetBaseNameString( strName );

				CString strFrom = GetActiveConfig()->GetConfigurationName();

				int nFirst = strFrom.Find(_T('-'));
				ASSERT(nFirst != -1);
				strName += strFrom.Right(strFrom.GetLength() - nFirst + 1 );

				RenameTarget(strFrom, strName);

			}

		}

		// Must set the path after doing the external makefile check
		if (!SetFile(&NewPath))
			return FALSE;
	} while (!bNameOK);

	// SetPathName adds new name to MRU list
	InformDependants(SN_FILE_NAME);

	::SetWorkspaceDocDirty();

	// inform dependents of this builder filename change
	CString str; CTargetItem * pTarget;
	InitTargetEnum();
	while (NextTargetEnum(str, pTarget))
	{
		const CPtrArray * pConfigArray = pTarget->GetConfigArray();
		int nSize = pConfigArray->GetSize();
		
		ConfigurationRecord * pcr = NULL;
		for (int i = 0; i < nSize; i++)
		{
			pcr = (ConfigurationRecord *)pConfigArray->GetAt(i);
			CActionSlob::InformActions(pTarget, P_ToolOutput, pcr);
		}
	}

    // UNDONE (colint): This will be done by the project package
	//if (bSavePrivate)
	//	SaveOPTFiles();

	// do the save
	DoSave();

	return TRUE;
}
///////////////////////////////////////////////////////////////////////////////
// Get version info for App studio:
void CProject::GetVersionInfo(PROJECT_VERSION_INFO* ppvi)
{
	ppvi->dwBuildType = VS_FF_DEBUG;		// 0 for release.


	int i = GetTargetAttributes ();
	if (i & ImageExe ) 				ppvi->dwTargetType = VFT_APP;
	else if (i & ImageDLL )			ppvi->dwTargetType = VFT_DLL;
	else if (i & ImageStaticLib )	ppvi->dwTargetType = VFT_STATIC_LIB;
	else 							ppvi->dwTargetType = VFT_UNKNOWN;

	ppvi->dwTargetSubtype = VFT2_UNKNOWN;	// only nonzero for font/drv types
	ppvi->dwTargetOS = VOS_NT_WINDOWS32;
	ppvi->dwVersionNumberLS = MAKELONG(1, 0);
	ppvi->dwVersionNumberMS = MAKELONG(0, 1);

	CString str;

	CPath * pPath = GetTargetFileName();
	if (pPath)
	{
		str = pPath->GetFileName();
		delete pPath;
	}

	strncpy(ppvi->szTargetFileName, str, CCHMAX_TARGET_FILE_NAME);
	ppvi->szTargetFileName[CCHMAX_TARGET_FILE_NAME - 1] = '\0';

	// strip off the extension and build the product name field
	int iBad = str.Find('.');
	if (iBad != -1)
		str.ReleaseBuffer(iBad);

	strncpy(ppvi->szTargetProductName, str, CCHMAX_TARGET_PRODUCT_NAME);
	ppvi->szTargetProductName[CCHMAX_TARGET_PRODUCT_NAME - 1] = '\0';
}

///////////////////////////////////////////////////////////////////////////////
// Obtain the toolset for this projects platform type.
INT CProject::GetProjectToolset()
{
	CDirMgr * pDirMgr = GetDirMgr();
	CProjType * pProjType;
	INT nToolset;

	if (m_bProjIsExe)
	{
		CString str;
		CPlatform * pPlatform;

		// FUTURE (colint): Do we still need this for exe projects. Will anyone
		// ever ask for the toolset for an exe project, I think not!
		VERIFY(GetStrProp(P_ExtOpts_Platform, str) == valid);
		g_prjcompmgr.LookupPlatformByUIDescription((const TCHAR *)str, pPlatform);

		// If the current toolset is unsupported then we pick the primary platform as a default
		if (!pPlatform->IsSupported())
			pPlatform = g_prjcompmgr.GetPrimaryPlatform();

		nToolset = pDirMgr->GetPlatformToolset(*(pPlatform->GetName()));
	}
	else
	{
		// Get the toolset for the current project platform
		VERIFY (g_prjcompmgr.LookupProjTypeByName(GetActiveConfig()->GetOriginalTypeName(), pProjType));

		// If the current toolset is unsupported then we pick the primary platform as a default
		if (!pProjType->IsSupported())
		{
			CPlatform * pPlatform = g_prjcompmgr.GetPrimaryPlatform();
			nToolset = pDirMgr->GetPlatformToolset(*(pPlatform->GetName()));
		}
		else
			nToolset = pDirMgr->GetPlatformToolset(*(pProjType->GetPlatformName()));
	}

	return nToolset;
}

///////////////////////////////////////////////////////////////////////////////
// Setup the project's envirnoment variables.  Right now, we just copy them out
// of the dir manager, but this function is here in case we someday want per
// project or per config paths:
void CProject::GetEnvironmentVariables (CEnvironmentVariableList *pEnvList)
{
	CDirMgr * pDirMgr = GetDirMgr();
    CPlatform * pPlatform = GetCurrentPlatform();
	CString str;

	pDirMgr->GetDirListString ( str, DIRLIST_PATH );
	pEnvList->AddVariable ("path", str );

    if (pPlatform && (pPlatform->GetUniqueId() == java))
    {
        // for Java, we "steal" the INCLUDE slot for the classpath...
        pDirMgr->GetDirListString ( str, DIRLIST_INC );
        pEnvList->AddVariable ("classpath" , str );
    }
    else
    {
		pDirMgr->GetDirListString ( str, DIRLIST_INC );
		pEnvList->AddVariable ("include", str );

		pDirMgr->GetDirListString ( str, DIRLIST_LIB );
		pEnvList->AddVariable ("lib",str);
	}

	// Add OUTDIR and INTDIR to environment
	CString strMacro;
	if (GetOutDirString(strMacro, P_OutDirs_Target, &str, FALSE))
		pEnvList->AddVariable (strMacro, str);
	if (GetOutDirString(strMacro, P_OutDirs_Intermediate, &str, FALSE))
		pEnvList->AddVariable (strMacro, str);
}

///////////////////////////////////////////////////////////////////////////////
#ifdef PROJ_LOG
void LogProjectState (
					const CObList &rlist,
					CProjItem	*pItemStart,
					CProject *pProject
					);
#endif

CProject::BuildResults CProject::DoBuild
(
	CProjItem * pItemStart,
	UINT buildType,
	BOOL bContinueAfterErrors,
	FlagsChangedAction & fca,
	CTempMaker & rTM,
	CErrorContext & EC,
	BuildType bt /* = NormalBuild */,
	BOOL bVerbose /* = TRUE */,
	BOOL bRecurse /* = TRUE */
)
{
	//	Called to build part of a project starting at the specified item (which
	//	may be the project itself).  Note that this routine may recurse.
	BuildResults brResult = NoBuild;

    UINT cmdRet;
    FileRegHandle frhStart;
    DWORD aob;
    CProjType * pProjType;
    CString str;

	// This will change the active project.  The destructor will change it back.
	CProjTempProjectChange projTempProjectChange (this); 

	// Spawner should be active:
	ASSERT (g_Spawner.SpawnActive ());

	// Get flattened list of all items, with subprojects at the front, but
	// not expanded
   	CObList lstItems;
	pItemStart->FlattenSubtree(lstItems, bt == Compile ? flt_Normal | flt_ExcludeDependencies :
	                           flt_Normal | flt_ExcludeGroups | flt_RespectItemExclude | flt_ExcludeDependencies | flt_RespectTargetExclude);

    CPtrList lstprojdeprefs;
	CString strCurrentConfig = GetActiveConfig()->GetConfigurationName();

	pProjType = GetProjType();
	BOOL bIsExternalTarget = (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)));
	if (buildType != TOB_Clean && !bIsExternalTarget && CheckForDuplicateTargets(lstItems, IDS_SAME_TARGET) && !bContinueAfterErrors )
	{
		brResult = BuildError;
		goto EndBuild;
	}

	{
		// Build all target dependencies first...
		for (POSITION pos = lstItems.GetHeadPosition(); pos != NULL;)
 		{
			CProjItem * pItem = (CProjItem *) lstItems.GetNext (pos) ;
			if (pItem->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			{
 				ConfigurationRecord * pcrProjDep = ((CProjectDependency*)pItem)->GetCompatibleTargetConfig(GetActiveConfig());
				if (pcrProjDep != NULL)
				{
					PROJDEPREFINFO * pProjDepRefInfo = new PROJDEPREFINFO;
					pProjDepRefInfo->pProjDep = pItem;
					pProjDepRefInfo->pcr = GetActiveConfig();

					lstprojdeprefs.AddTail(pProjDepRefInfo);

					CPtrList lstOutputs;
					CActionSlob::AddRefFileItem(pItem,&lstOutputs);

					if( bRecurse ){
						CString strConfigName = pcrProjDep->GetConfigurationName();
						void *pDummy=NULL;
						if (!CBuildIt::m_mapConfigurationsBuilt.Lookup(strConfigName, pDummy))
						{
							CBuildIt::m_mapConfigurationsBuilt.SetAt(strConfigName, NULL);

							// Build the target dependency?
							CProject * pDepProject = (CProject *)pcrProjDep->m_pBaseRecord->m_pOwner;
							ASSERT(pDepProject);
							ASSERT(pDepProject->IsKindOf(RUNTIME_CLASS(CProject)));
	
							CProjTempConfigChange tempChange(pDepProject);
							tempChange.ChangeConfig(pcrProjDep);
	
							pProjType = pDepProject->GetProjType();
	
							// If the dependency is on an external target type then it is always
							// out of date.
							CObList lstPath;
							if (pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)) || 
								buildType != TOB_Build ||
								g_BldSysIFace.TargetState(NULL, NULL, NO_TARGET, (HBUILDER)pDepProject) != TRG_STAT_Current
							   )
							{
								// int type;
								//if( buildType == TOB_ReBuild ) type = TOB_Build;
								//else type = buildType;
								brResult = pDepProject->DoBuild (pDepProject,
													buildType,
													bContinueAfterErrors,
													fca,
													rTM,
													EC,
													bt,
													bVerbose);
	
								if (brResult == BuildCanceled ||
									(brResult == BuildError && !bContinueAfterErrors)) 
								{
									// SetStrProp(P_ProjActiveConfiguration, strCurrentConfig);
									goto EndBuild;
								}
							}
						}
						// Stat the outputs here
						POSITION pos = lstOutputs.GetHeadPosition();
						while (pos)
						{
							FileRegHandle frh = (FileRegHandle) lstOutputs.GetNext( pos );
							frh->RefreshAttributes();
						}
					}
				}
			}
		}
	}

	// Continue building the current target
	// SetStrProp(P_ProjActiveConfiguration, strCurrentConfig);
	
	if (buildType != TOB_Clean)
	{
		if(g_bHTMLLog )
			LogTrace("<h3>\n");
		EC.AddString(MsgText(str, IDS_BUILD_TARGETNAME, (const char *) strCurrentConfig));
		if(g_bHTMLLog )
			LogTrace("</h3>\n");
	}
	else
	{
		EC.AddString(MsgText(str, IDS_DESC_CLEANING, (const char *) strCurrentConfig));
	}

	// If this is an external makefile then spawn make and go:
	pProjType = GetProjType();
	if (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
	{

		if (buildType != TOB_Clean)
		{
			brResult = BuildAsExternalMakefile (buildType, EC );
		}
		goto EndBuild;
	}

	ASSERT (!GetContentList()->IsEmpty());

	// \/ Fake v3.0 API hooking

	aob = bContinueAfterErrors ? AOB_Default | AOB_IgnoreErrors : AOB_Default;

	if (bt == Compile)
		aob |= AOB_Forced;  

	// /\ Fake v3.0 API hooking

	if( g_bWriteBuildLog ){
		CString strLog;
		strLog.LoadString(IDS_BUILD_LOG);
		SetPrompt(strLog, TRUE);
		// LogProjectState (lstItems, pItemStart, this);
		SetPrompt("", TRUE);
	}


	frhStart = (FileRegHandle)NULL;
	if (pItemStart->IsKindOf(RUNTIME_CLASS(CFileItem)))
	{
		// FUTURE: 
		// short term fix .. build an output
		ConfigurationRecord * pcr = pItemStart->GetActiveConfig();
		if (pcr == (ConfigurationRecord *)NULL)
		{
			brResult = BuildError;
			goto EndBuild;
		}

		CActionSlobList * pActions = pcr->GetActionList();
		if (pActions->IsEmpty())
		{
			brResult = BuildError;
			goto EndBuild;
		}

		ASSERT(pActions->GetCount() == 1);

		CFileRegSet * pfrsOutput = ((CActionSlob *)pActions->GetHead())->GetOutput();
#ifndef REFCOUNT_WORK
		if (pfrsOutput->GetContent()->IsEmpty())
#else
		if (pfrsOutput->IsEmpty())
#endif
		{
			brResult = BuildComplete;
			goto EndBuild;
		}

		pfrsOutput->InitFrhEnum();
		frhStart = pfrsOutput->NextFrh();
#ifdef REFCOUNT_WORK
		// Not sure where this should be released.  Here to be safe.
		if (NULL!=frhStart)
			frhStart->ReleaseFRHRef();
#endif
	}

	cmdRet = g_buildengine.DoBuild
	(
		GetProject()->GetActiveConfig(),
		EC,					// error context
		frhStart,			// file to build
		aob,				// attribs of build, eg. forced?
		buildType,			// build or rebuild
		(bt != Compile),	// recurse
		bVerbose			// verbose
	);

#if 0
#pragma message( "Using temporary code to enable/disable new update dependency code")
	{
		if (g_bNewUpdateDepModel)
		{
			// Get IMreDependencies* so that it is cached.
			IMreDependencies* pMreDepend = NULL;
			CPath pathIdb = GetMrePath(GetActiveConfig());
			if (!pathIdb.IsEmpty())
			{
				// Minimal rebuild dependency interface.
				pMreDepend = 
					IMreDependencies::GetMreDependenciesIFace((LPCTSTR)pathIdb);
			}

			// Update dependencies.
			// Set up a new cache for this target			
			g_ScannerCache.BeginCache();

			CTargetItem* pTarget = GetActiveTarget();

			CObList SubList;
			pTarget->GetBuildableItems(SubList);
			if (!SubList.IsEmpty())
			{
				// Test for a /Yc file, and parse the PCH file first.
				CProjItem *pYcItem = NULL;

				int nTotal = SubList.GetCount();
				int nCurr = 0;
				int nLast = 0;
				BOOL fRefreshDepCtr = FALSE;
				POSITION pos = SubList.GetHeadPosition();
				while (pos)
				{
					CProjItem *pTempItem = (CProjItem *) SubList.GetNext( pos );
					ASSERT( pTempItem->IsKindOf( RUNTIME_CLASS(CProjItem) ) );

					if( pTempItem == pYcItem ) continue;

					ASSERT_VALID( pTempItem );
					nCurr++;
					if (pTempItem->IsKindOf( RUNTIME_CLASS(CFileItem) ))
					{
						pTempItem->ScanDependencies();
						fRefreshDepCtr = TRUE;

						// update the indicator 20 times at most
						int nNew = nCurr * 100 / nTotal;
						if( (nNew/5) > nLast ){
							StatusPercentDone( nNew );
							nLast = nNew/5;
						}
					}
				}
				if (fRefreshDepCtr)
					pTarget->RefreshDependencyContainer();
			}
			g_ScannerCache.EndCache();
			if (NULL!=pMreDepend)
				pMreDepend->Release();
		}
	}
#endif	// Use dependencies??

	switch (cmdRet)
	{
		case CMD_Complete:	brResult = BuildComplete;	break;
		case CMD_Canceled:	brResult = BuildCanceled;	break;
		case CMD_Error:		brResult = BuildError;		break;

		default:
			ASSERT(FALSE);	
			break;
	}

EndBuild:
	CProjTempConfigChange projTempConfigChange(this);

	while (!lstprojdeprefs.IsEmpty())
	{
		PROJDEPREFINFO * pProjDepRefInfo = (PROJDEPREFINFO *)lstprojdeprefs.RemoveHead();
		projTempConfigChange.ChangeConfig(pProjDepRefInfo->pcr);
		CActionSlob::ReleaseRefFileItem(pProjDepRefInfo->pProjDep);
		delete pProjDepRefInfo;
	}
	return brResult;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::TopLevelRunDeferedBuildTool (CSchmoozeTool *pTool, BOOL fAlways /* = FALSE */)
{
//  Called to run a defered build tool like BSCMAKE.  Function sets up spawner
//  and calls RunDeferedBuildTool.
	CErrorContext *pEC;
	DWORD errs,warns;
	CProject::BuildResults br;
	CString str, strName;
	CFileRegSet regset;
	BuildStates bs;
	CEnvironmentVariableList ProjEnvironment;
	CPath * pPath ;


	ASSERT (!m_bProjIsExe);

	if (!theApp.NotifyPackages(PN_QUERY_BEGIN_BUILD) ||
		!g_Spawner.CanSpawn ()) return FALSE;

	// if we can't get the primary output name
	// then just use the filename
	CPtrList plOutput;
	FileRegHandle frh;

	// FUTURE: remove this hack
	CActionSlobList lstActions;
	CActionSlob action(this, pTool);
	lstActions.AddTail(&action);
	pTool->GenerateOutput(AOGO_Default, lstActions, g_DummyEC);

	CFileRegSet * pSet = action.GetOutput();
#ifndef REFCOUNT_WORK
	if (!pSet->GetContent()->IsEmpty())
	{
		frh = (FileRegHandle)pSet->GetContent()->GetHead();
		pPath = (CPath *)g_FileRegistry.GetRegEntry(frh)->GetFilePath();
#else
	if (!pSet->IsEmpty())
	{
		frh = (FileRegHandle)pSet->GetFirstFrh();
		pPath = (CPath *)g_FileRegistry.GetRegEntry(frh)->GetFilePath();
		frh->ReleaseFRHRef();
#endif
		ASSERT(pPath);
		strName = pPath->GetFileName() ;
	}
	else
	{
    	GetStrProp(P_ProjItemName, strName);
	}

	// HACK HACK HACK
	// Since we don't support proper remote targets we have to
	// special case the mecr tool's output name, since it fakes the
	// build system using a pseudo target which we don't really
	// want the user to know about!!!!

	// UNDONE
	if (pTool->IsMecrTool())
	{
		TRACE("UNDONE: Use of CBuildTool::IsMecrTool() in %s @ %d", __FILE__, __LINE__);
		CPath* pPath = GetTargetFileName();
		ASSERT(NULL!=pPath);
		strName = pPath->GetFileName();
		delete pPath;
	}

	// Initialize the spawner and output window:
	ASSERT (!g_Spawner.SpawnActive ());
	if ((pEC = g_Spawner.InitSpawn ()) == NULL ) return FALSE;
	theApp.NotifyPackages (PN_BEGIN_BUILD, (void *) FALSE);

	// Get the build state of the tool.  If a consumable file is missing,
	// then suggest a regular build instead:
	ConfigCacheEnabler Cacher;	// No properties can change

	// What is the build state of this action?
 	bs = fAlways ? OutOfDate : GetBuildStateForTool(pTool, *action.GetInput(), *pEC);

	if (bs == SourceMissing)
	{
		CString str;
		int rv = QuestionBox (IDS_SOURCE_MISSING,
							 MB_YESNO,
						     (const TCHAR *) *pTool->GetName()
						    );
		theApp.NotifyPackages (PN_END_BUILD, (void *) FALSE);
		g_Spawner.TermSpawn ();

		if (rv == IDYES)
		{
			DAB dab = pTool->DeferredAction(&action);

			Cacher.EndCacheNow();
			pTool->SetDeferredAction(&action, dabNotDeferred);
			rv = DoTopLevelBuild (FALSE);

			// reset
			pTool->SetDeferredAction(&action, dab);
			return rv;
		}
		else
			return FALSE;
	}
	else if (bs != Current)
	{
		GetEnvironmentVariables ( &ProjEnvironment );
		ProjEnvironment.SetVariables ();

		CTempMaker TM;

		br = RunSchmoozeTool (pTool, TRUE, GetWorkspaceDir(), TM, *pEC);

		TM.NukeFiles (*pEC );

		ProjEnvironment.ResetVariables ();	// May do nothing.
	}
	g_Spawner.GetErrorCount ( errs, warns );

	pEC->AddString(_T(""));

	if (br == BuildCanceled)
		pEC->AddString(IDS_USERCANCELED);
	else
		pEC->AddString(MsgText(str, IDS_BUILD_COMPLETE, (const char *) strName, errs, warns));
	theApp.NotifyPackages (PN_END_BUILD, (void *) FALSE);
	g_Spawner.TermSpawn ();
	Cacher.EndCacheNow ();
	MessageBeep (UINT(-1));
	return (br == CProject::BuildComplete ) ? TRUE : FALSE;
}
///////////////////////////////////////////////////////////////////////////////
CProject::BuildResults CProject::RunSchmoozeTool
(
	CSchmoozeTool * pTool,
	BOOL /* bContinueAfterErrors */,
	CDir & rMyDir,
	CTempMaker & /*rTM*/,
	CErrorContext & EC
)
{
	CPtrList plCommandLines;
	BuildResults brResult = NoBuild;

	// find the action for this tool
	CActionSlobList * pActions = GetActiveConfig()->GetActionList();
	POSITION pos = pActions->GetHeadPosition();
	CActionSlobList lstActions;
	while (pos != (POSITION)NULL)
	{
		CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos); 
		if (pAction->m_pTool == pTool)
		{
			BOOL fDummy;
			pAction->RefreshCommandOptions(fDummy);

			lstActions.AddTail(pAction);
			break;
		}
	}

	if (!pTool->GetCommandLines(lstActions,	plCommandLines, 0, EC))
	{
		// display the notification that the
		// 'get command-line' operation failed
		CString str;
		EC.AddString (::MsgText (
								str,
								IDS_GET_COMMAND_LINE_FAILED,
								(const TCHAR *) *pTool->GetName ()
								));
		// log this as an error
		g_Spawner.m_dwProjError++;
	}
	// nothing to do?
	else if (!plCommandLines.IsEmpty())
	{

		// execute them...
		UINT cmd = g_Spawner.DoSpawn(plCommandLines, rMyDir, FALSE, FALSE, EC);

		if (cmd != CMD_Canceled && cmd != CMD_Complete)
			cmd = CMD_Error; 

		if (cmd == CMD_Canceled)
			brResult = BuildCanceled;

		else if (cmd == CMD_Complete)
			brResult = BuildComplete;

		else if (cmd == CMD_Error)
			brResult = BuildError;
	}

	// clean up to avoid leaks
	while (!plCommandLines.IsEmpty())
	{
		CCmdLine * pCmdLine = (CCmdLine *)plCommandLines.RemoveTail();
		delete pCmdLine;
	}

	return brResult;
}
///////////////////////////////////////////////////////////////////////////////
BuildStates CProject::GetBuildStateForTool
(
	CSchmoozeTool * pSTool,
	CFileRegSet & regset,
	CErrorContext& /* EC =g_DummyEC */
)
{
	FILETIME ft, ftConsumable;
	BOOL bHaveConsumables = FALSE;

 	// Flush any pending file change events
	FileChangeDeQ();

	//and possible dep update
	FileItemDepUpdateDeQ();

	// Do we have any consumables that the tool wants?
	FileRegHandle frh;
	regset.InitFrhEnum();
	while ((frh = regset.NextFrh()) != (FileRegHandle)NULL)
	{
		if (pSTool != NULL &&
			!pSTool->IsConsumableFile (g_FileRegistry.GetRegEntry(frh)->GetFilePath()))
#ifndef REFCOUNT_WORK
			continue;
#else
		{
			frh->ReleaseFRHRef();
			continue;
		}
		frh->ReleaseFRHRef();
#endif

		bHaveConsumables = TRUE;
	}

	// If we don't have any consumables then the tool is upto date
	if (!bHaveConsumables)
	{
		#ifdef PROJ_LOG
		PBUILD_TRACE ("Project \"%s\" build state declared current for"
			" tool %s\n", (const TCHAR *) *GetFilePath (), (const TCHAR *) *pSTool->GetName());
		#endif
		return Current;
	}

	// Compare each of the consumables files and get the time of the newest consumable
	//
	ftConsumable.dwLowDateTime = 0;
	ftConsumable.dwHighDateTime = 0;
	regset.InitFrhEnum();
	while ((frh = regset.NextFrh()) != (FileRegHandle)NULL)
	{
		if (pSTool != NULL &&
			!pSTool->IsConsumableFile (g_FileRegistry.GetRegEntry(frh)->GetFilePath()))
#ifndef REFCOUNT_WORK
			continue;
#else
		{
			frh->ReleaseFRHRef();
			continue;
		}
#endif

		if (!g_FileRegistry.GetRegEntry(frh)->GetFileTime(ft))
		{
			#ifdef PROJ_LOG
			PBUILD_TRACE ("Project \"%s\" build state declared SourceMissing for"
				" tool %s because of consumable \"%s\"\n",
				(const TCHAR *) *GetFilePath (),
				(const TCHAR *) *pSTool->GetName(),
				(const TCHAR *) *g_FileRegistry.GetRegEntry(frh)->GetFilePath());
			#endif
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif

			return SourceMissing;
		}

		if (CompareFileTime(&ft, &ftConsumable) > 0)
			ftConsumable = ft;

#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif
	}

	CFileRegSet * pregset = GetTargetPaths();
	pregset->InitFrhEnum();
	while ((frh = pregset->NextFrh()) != (FileRegHandle)NULL)
	{
		// Skip files tool doesn't make:	
 		if (pSTool != NULL &&
			!pSTool->IsProductFile (g_FileRegistry.GetRegEntry(frh)->GetFilePath()))
#ifndef REFCOUNT_WORK
			continue;
#else
		{
			frh->ReleaseFRHRef();
			continue;
		}
#endif

		if (!g_FileRegistry.GetRegEntry(frh)->GetFileTime(ft))
		{		
			#ifdef PROJ_LOG
			PBUILD_TRACE ("Project \"%s\" build state declared OutOfDate for"
				" tool %s because couldn't access target \"%s\"\n",
				(const TCHAR *) *GetFilePath(),
				(const TCHAR *) *pSTool->GetName(),
				(const TCHAR *) *g_FileRegistry.GetRegEntry(frh)->GetFilePath());
			#endif
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif
			return OutOfDate	;
		}
  		// Compare each target against newest consumable:
		if (CompareFileTime (&ft, &ftConsumable) < 0) // intentionally "< 0" not "<= 0"
		{
			#ifdef PROJ_LOG
			PBUILD_TRACE ("Project \"%s\" build state declared OutOfDate for"
				" tool %s because of consumable \"%s\"\n",
				(const TCHAR *) *GetFilePath(),
				(const TCHAR *) *pSTool->GetName(),
				(const TCHAR *) *g_FileRegistry.GetRegEntry(frh)->GetFilePath());
 			#endif
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif
			return OutOfDate;
		}

#ifdef REFCOUNT_WORK
		frh->ReleaseFRHRef();
#endif
	}
	

	#ifdef PROJ_LOG
	PBUILD_TRACE ("Project \"%s\" build state declared current for"
		" tool %s\n", (const TCHAR *) *GetFilePath (), (const TCHAR *) *pSTool->GetName());
	#endif

	return Current;
}
///////////////////////////////////////////////////////////////////////////////
CProject::BuildResults CProject::BuildAsExternalMakefile
(
	BOOL bBuildAll,
	CErrorContext & EC
)
{
	CEnvironmentVariableList environProj;
	CString strCmdLine, str;

	// Get the external target working directory, and
	// stick a dummy file name on the end
	CDir spawnDir;

    CProjType * pProjType = GetProjType();
    if (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
    {
		spawnDir = GetProjDir();
	}
	else
	{
		spawnDir = GetWorkspaceDir();
	}

    if (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
        GetStrProp (P_Proj_CmdLine, strCmdLine);
    else 
    	GetStrProp (P_ExtOpts_CmdLine, strCmdLine);

	if (bBuildAll)
	{
        if (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
            GetStrProp(P_Proj_RebuildOpt, str);
        else
    		GetStrProp(P_ExtOpts_RebuildOpt, str);
		strCmdLine = strCmdLine + " " + str;
	}

	ASSERT (GetFilePath());

	GetEnvironmentVariables(&environProj);
	environProj.SetVariables();

	CPtrList plCmds;
	CCmdLine *pCmdLine = new CCmdLine;
	pCmdLine->slCommandLines.AddHead(strCmdLine);

	// our description
	pCmdLine->slDescriptions.AddHead("");
	pCmdLine->nProcessor = 1;
	plCmds.AddTail(pCmdLine);

	UINT cmd = g_Spawner.DoSpawn(plCmds, spawnDir, TRUE, FALSE, EC);

	environProj.ResetVariables();	// May do nothing.

	// this external build may have modified the target NT image
	// -> dirty the target attributes
	GetActiveConfig()->DirtyTargetAttributes();

	BuildResults brResult;

	if (cmd != CMD_Canceled && cmd != CMD_Complete)
		cmd = CMD_Error; 

	if (cmd == CMD_Complete)
		brResult = BuildComplete;

	else if (cmd == CMD_Canceled)
		brResult = BuildCanceled;

	else if (cmd == CMD_Error)
		brResult = BuildError;

	return brResult;
}

#define dwExtEOR	((DWORD)0x47414D00)

BOOL CProject::LoadFromOPT(CStateSaver& stateSave)
{
	BOOL bRetVal;

	if (m_bPrivateDataInitializedFromOptFile)
	{
		// don't reread this (in case we're reloading another project)
		ASSERT(m_bPrivateDataInitialized);
		return TRUE;
	}

	// Figure out if the .mak is newer than the .mdp.
	ASSERT(stateSave.GetFileName());
	
	CPath  MDPPath;
	BOOL bNewerMak = TRUE;

	if (MDPPath.Create(stateSave.GetFileName()) && MDPPath.ExistsOnDisk())
	{
		FILETIME ftMdp, ftMak;

		VERIFY(MDPPath.GetFileTime(&ftMdp));

		CFileRegFile * pRegFile = (CFileRegFile *)g_FileRegistry.GetRegEntry(m_hndFileReg);
		if (pRegFile->GetFileTime(ftMak))
		{
		 	if (CFileRegEntry::MyCompareFileTime(&ftMak, &ftMdp) <= 0)
				bNewerMak = FALSE;
		}
	}

	// If the .mak is newer than the .mdp, the cached CActionSlob option strings
	// are not valid. Tell the CActionSlob's to ignore them. 

#if 0 // Olympus:1556, Don't ever read cached options. 
	if (bNewerMak)
		CActionSlob::IgnoreCachedOptions(TRUE);
#else
	CActionSlob::IgnoreCachedOptions(TRUE);
#endif

  	// Load from appropriate stream.
	if (IsExeProject())
		bRetVal = LoadExternalFromOPT(stateSave, IsExeProject());
	else
		bRetVal = LoadInternalFromOPT(stateSave, IsExeProject(), FALSE );
 
#if 0   // See above.
	CActionSlob::IgnoreCachedOptions(FALSE);
#endif

 	// Note: At this point, if bRetval is false, then the OPT file is only
	// partially loaded and we may be in some sort of weird state, especially
	// w.r.t Conifiguration.
	if (bRetVal)
	{
		ASSERT_VALID (this);

		m_bProjectComplete = TRUE;
		m_bPrivateDataInitialized = TRUE;
		m_bPrivateDataInitializedFromOptFile = TRUE;
	}
	else
	{
		COptionTreeCtl::sm_TreeState.Clear();

		if (!m_bProjIsExe)
			InitPrivateData();
		else
			InitPrivateDataForExe();
	}

	//  At this point, we can enable the change config notification
	SetActiveConfig(m_strProjActiveConfiguration, FALSE);
	m_bNotifyOnChangeConfig = TRUE;
    	if (FindProjWksIFace()->IsWorkspaceInitialised() == S_OK)
		theApp.NotifyPackages (PN_CHANGE_CONFIG);

	PFILE_TRACE ( "CProject::LoadFromOPT returning %i\n",bRetVal);
	return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// Helper function for setting string props when converting a OPT file for an
// external makefile
BOOL CProject::SetStrPropConfigs(CPtrList * plstpcr, UINT idProp, const CString & val)
{
	BOOL bRetVal = TRUE;
	ConfigurationRecord * pcr;

	if (plstpcr)
	{
		POSITION pos = plstpcr->GetHeadPosition();
		while (pos != NULL)
		{
			pcr = (ConfigurationRecord *)plstpcr->GetNext(pos);

			CProjTempConfigChange projTempConfigChange(this);
			projTempConfigChange.ChangeConfig(pcr);

			bRetVal = bRetVal && SetStrProp(idProp, val);
		}
	}

	return bRetVal;
}

BOOL CProject::SetIntPropConfigs(CPtrList * plstpcr, UINT idProp, int val)
{
	BOOL bRetVal = TRUE;
	ConfigurationRecord * pcr;

	if (plstpcr)
	{
		POSITION pos = plstpcr->GetHeadPosition();
		while (pos != NULL)
		{
			pcr = (ConfigurationRecord *)plstpcr->GetNext(pos);

			CProjTempConfigChange projTempConfigChange(this);
			projTempConfigChange.ChangeConfig(pcr);

			bRetVal = bRetVal && SetIntProp(idProp, val);
		}
	}

	return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// Convert the OPT file for an external makefile so that the contained
// settings can be retained on a corresponding internal makefile generated
// when the external makefile is loaded.
BOOL CProject::ConvertOPTFile(CArchive & ar)
{
	CPtrList lstDebugConfigs;
    CPtrList lstReleaseConfigs;
	BOOL bRetval = TRUE;
	BOOL bDataExists = FALSE;
	CString strDebugConfig, strReleaseConfig, str;

	VERIFY(strDebugConfig.LoadString(IDS_DEBUG_CONFIG));
	VERIFY(strReleaseConfig.LoadString(IDS_RELEASE_CONFIG));
 
	// Construct lists of debug/release configs
	ConfigurationRecord * pcr;
	CString strConfigName;
	const CPtrArray & ppcr = *GetConfigArray();
	int ccr = m_ConfigArray.GetSize();
	for (int icr = 0; icr < ccr; icr++)
	{
		pcr = (ConfigurationRecord *)ppcr[icr];
		strConfigName = pcr->GetConfigurationName();
		if (strConfigName.Find(strDebugConfig) > 0)
			lstDebugConfigs.AddTail(pcr);
		if (strConfigName.Find(strReleaseConfig) > 0)
			lstReleaseConfigs.AddTail(pcr);
	}

  	// Is there any data in this stream.
	ar >> ((long&) bDataExists);

	if (!bDataExists)
	{
		// No data, so we may need to fail the operation
		// so that we will init this data.
  	}
	else
	{
 		BOOL		bHasReleaseConfig = FALSE;
 		DWORD		iConfig, cConfigs;
		CPtrList *	plstpcr;

		// Load the state of the builder
		if (!CActionSlob::LoadFromArchive(ar))
	 		AfxThrowArchiveException (CArchiveException::badSchema);

		// Load the state of the Project.Settings option tree-control
		if (!COptionTreeCtl::LoadOptTreeStore(ar))
 	 		AfxThrowArchiveException (CArchiveException::badSchema);

 		ar >> cConfigs;

		for (iConfig=0 ; iConfig<cConfigs ; ++iConfig)
		{
			// Read the name of the configuration, create that
			// configuration, and make it active:
			ar >> str;

 			// Do we recognize the configuration name as one of our
			// standard configs, i.e. debug/release, if so then we
			// can retain the information
			if (str == strDebugConfig)
 				plstpcr = &lstDebugConfigs;
  			else if (str == strReleaseConfig)
 				plstpcr = &lstReleaseConfigs;
			else
				plstpcr = NULL;
 
			// Set the other properties for this configuration:
			ar >> str;
			SetStrPropConfigs(plstpcr, P_Proj_CmdLine, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_Proj_RebuildOpt, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_Proj_Targ, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_Proj_BscName, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_ProjClsWzdName, str);

 			// Skip over platform name, we cannot change the platform
			// for projects in internal makefiles.
			ar >> str;

			// Set debug page properties
  			ar >> str;
			SetStrPropConfigs(plstpcr, P_Caller, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_WorkingDirectory, str);
			ar >>  str;
 			SetStrPropConfigs(plstpcr, P_Args, str);
			
			// Read the additional DLLs but we don't set them like
			// we used to
			ar >> str;
 			
			ar >> str;
			SetStrPropConfigs(plstpcr, P_RemoteTarget, str);
		}

		// Get the name of the current configuration:
		ar >> str;  // We don't use it!
 
		// Check the EOR marker.
		DWORD dwT;

		ar >> dwT;
		if (dwT != dwExtEOR)
			AfxThrowArchiveException (CArchiveException::badSchema);
	}

	return bRetval;
}


///////////////////////////////////////////////////////////////////////////////
#define STREAM_PROJINTINFO	"IPI_"
#define STREAM_PROJEXTINFO	"External_Project_Info"
///////////////////////////////////////////////////////////////////////////////
// Load from our external project stream.
BOOL CProject::LoadExternalFromOPT(CStateSaver& stateSave, BOOL bIsExternal)
{
	BOOL bRetval = TRUE;
	BOOL bDataExists = FALSE;
	CString strDebugConfig, strReleaseConfig;
	CInitFile fileInit;
	ASSERT(stateSave.IsLoading());

	ASSERT(bIsExternal);
	if (!stateSave.OpenStream(fileInit, STREAM_PROJEXTINFO ))
		return FALSE;

	CArchive ar ( &fileInit, CArchive::load | CArchive::bNoFlushOnDelete);
	CString str, str2;
	int fPromptForDlls;
	UINT nFormatVersion;
	// Have to set this to 0 because of a bug in CRuntimeClass::Load which
	// only loads a word:
	UINT wSchemaNum = 0l;

	const UINT nDolphinVersionNumber = 0x00020054;
	const UINT nDolphinReleaseVersion = 0x00020000;
	const UINT nDolphinLastCompatOPT = 0x00020051;

	VERIFY(strDebugConfig.LoadString(IDS_DEBUG_CONFIG));
	VERIFY(strReleaseConfig.LoadString(IDS_RELEASE_CONFIG));

	TRY
	{
		ar >> ((long&) nFormatVersion);

		// For the OPT files, the formats must match exactly.
		if ((nFormatVersion != nVersionNumber) && (nFormatVersion < nLastCompatibleOPTFile || nFormatVersion > nVersionNumber))
		{
			if ((nFormatVersion != nDolphinReleaseVersion) && (nFormatVersion < nDolphinLastCompatOPT|| nFormatVersion > nDolphinVersionNumber))
				AfxThrowArchiveException (CArchiveException::badSchema);
			else
			{
				// Convert old vc 2.0 settings here, but only if we are loading 
				// an external project--if so then we can read the data properly.
				if (bIsExternal)
					ConvertOPTFile(ar);
			}
		}


		// Is there any data in this stream.
		ar >> ((long&) bDataExists);

		if (!bDataExists)
		{
			// No data, so we may need to fail the operation
			// so that we will init this data.
			m_hOPTData = NULL;
			bRetval = !bIsExternal;
 		}
		else
		{
			// We have data, but are we loading an external
			// project, if so then we can read it properly.
			if (bIsExternal)
			{
				// Load the state of the builder
//				if (!CActionSlob::LoadFromArchive(ar))
//	 				AfxThrowArchiveException (CArchiveException::badSchema);

				// Load the state of the Project.Settings option tree-control
				if (!COptionTreeCtl::LoadOptTreeStore(ar))
		 			AfxThrowArchiveException (CArchiveException::badSchema);

				BOOL	bHasReleaseConfig = FALSE;
				DWORD	iConfig, cConfigs;

				ar >> cConfigs;

				for (iConfig=0 ; iConfig<cConfigs ; ++iConfig)
				{
					// Read the name of the configuration, create that
					// configuration, and make it active:
					ar >> str;

					// Keep a count of whether we have
					// a config named release or not.
					bHasReleaseConfig = (bHasReleaseConfig || (str == strReleaseConfig));

					CreateConfig(str);
					SetStrProp(P_ProjActiveConfiguration, str);

					// Set the other properties for this configuration:
					ar >> str;
					SetStrProp(P_ExtOpts_CmdLine, str);
					ar >> str;
					SetStrProp(P_ExtOpts_RebuildOpt, str);
					ar >> str;
					SetStrProp(P_ExtOpts_Targ, str);
					ar >> str;
					SetStrProp(P_ExtOpts_BscName, str);
					
					// This property is now defunct
					// ar >> str;
					//SetStrProp(P_ExtOpts_ClsWzdName, str);

                    ar >> str2;

					ar >> str;
					SetStrProp(P_Caller, str);

		 			CPlatform *	pPlatform;
					// need to translate from "official name" to "UI description"
					// also, platform may not exist
 					if (g_prjcompmgr.LookupPlatformByOfficialName(str2, pPlatform))
					{
						SetStrProp(P_ExtOpts_Platform, *(pPlatform->GetUIDescription()));
						if (!pPlatform->IsSupported())
 							InformationBox(IDS_EXE_NOT_SUPPORTED, str);
					}
					else
					{
						// Display a message box stating that we don't support this
						// platform
 						InformationBox(IDS_EXE_NOT_SUPPORTED, str);

						CPlatform * pPlatform = new CPlatform(str2, unknown_platform);
						// Register dynamic platform so deleted on exit
						g_prjcompmgr.RegisterUnkProjObj(pPlatform);

						SetStrProp(P_ExtOpts_Platform, *pPlatform->GetUIDescription());
					}

					ar >> str;
					SetStrProp(P_WorkingDirectory, str);
					ar >> str;

					// If the args are already set then we don't
					// override them. This allows args from the cmd line to
					// override those in the OPT file
					CString strOldArgs;
					GetStrProp(P_Args, strOldArgs);
					if (strOldArgs.IsEmpty())
						SetStrProp(P_Args, str);

					ar >> (LONG&)fPromptForDlls;
					SetIntProp(P_PromptForDlls, fPromptForDlls);
					ar >> str;
					SetStrProp(P_RemoteTarget, str);

					// read in the Java properties

					// get the current platform
//					CPlatform* pPlatform = GetCurrentPlatform();
					ASSERT(pPlatform != NULL);
					if (pPlatform != NULL && pPlatform->GetUniqueId() == java)
					{
						int nValue;

						// class name
						ar >> str;
						SetStrProp(P_Java_ClassFileName, str);

						// debug using browser/stand-alone interpreter
						ar >> (LONG&)nValue;
						SetIntProp(P_Java_DebugUsing, nValue);

						// browser name
						ar >> str;
						SetStrProp(P_Java_Browser, str);

						// stand-alone interpreter name
						ar >> str;
						SetStrProp(P_Java_Standalone, str);
					
						// param source: html page or user
						ar >> (LONG&)nValue;
						SetIntProp(P_Java_ParamSource, nValue);

						// HTML page
						ar >> str;
						SetStrProp(P_Java_HTMLPage, str);
					
						// temp HTML page
						ar >> str;
						SetStrProp(P_Java_TempHTMLPage, str);
					
						// args in HTML form
						ar >> str;
						SetStrProp(P_Java_HTMLArgs, str);

						// command line args
						ar >> str;
						// allow command line args to override those in the VCP file
						CString strJavaOldArgs;
						GetStrProp(P_Java_Args, strJavaOldArgs);
						if (strJavaOldArgs.IsEmpty())
							SetStrProp(P_Java_Args, str);

						// stand-alone interpreter args
						ar >> str;
						SetStrProp(P_Java_StandaloneArgs, str);
						
						// debug stand-alone as applet or application
						ar >> (LONG&)nValue;
						SetIntProp(P_Java_DebugStandalone, nValue);
					}
				}

				// Did we find a release config, if not
				// and we are not an exe-project then we
				// had better create a release config.
				if (!m_bProjIsExe && !bHasReleaseConfig)
				{
					// Add the release config!

					CPath pathT;

					pathT = *GetFilePath();

					CreateConfig(strReleaseConfig);
					SetStrProp(P_ProjActiveConfiguration, strReleaseConfig);

					// Set the default properties for the release configuration
					str = "NMAKE /f ";
					pathT.ChangeExtension(".mak");
					str += pathT.GetFileName();
					SetStrProp(P_ExtOpts_CmdLine, str);

					str = "/a";
					SetStrProp(P_ExtOpts_RebuildOpt, str);

					pathT.ChangeExtension(".exe");
					str = pathT.GetFileName();
					SetStrProp(P_ExtOpts_Targ, str);
					SetStrProp(P_Caller, str);

					(void) GetPlatformDescriptionString(str, str2);
					SetStrProp(P_ExtOpts_Platform, str2);

					pathT.ChangeExtension(".bsc");
					str = pathT.GetFileName();
					SetStrProp(P_ExtOpts_BscName, str);

					pathT.ChangeExtension(".clw");
				
					// This property is now defunct.
					//str = pathT.GetFileName();
					//SetStrProp(P_ExtOpts_ClsWzdName, str);

					str = _T("");
					SetStrProp(P_WorkingDirectory, str);
					SetStrProp(P_Args, str);
					SetIntProp(P_PromptForDlls, 1);
					SetStrProp(P_RemoteTarget, str);
					SetCurrentConfigAsBase();
				}

				// Get the name of the current configuration:
				ar >> str;
				SetStrProp(P_ProjActiveConfiguration, str);

				// Check the EOR marker.
				DWORD dwT;

				ar >> dwT;
				if (dwT != dwExtEOR)
					AfxThrowArchiveException (CArchiveException::badSchema);
			}
			else
			{
				// We found data but we are not really
				// loading an external project so just
				// get a pointer to the external data
				// so we can write it back later.
				m_hOPTData = fileInit.GetInitData();
			}
		}

		ar.Close ();
		fileInit.Close();
	}
	CATCH_ALL(e)
	{
		#ifdef _DEBUG
		AfxDump(e);
		TRACE("\n");
		#endif
		fileInit.Abort();
		bRetval = FALSE;
	}
	END_CATCH_ALL

	return bRetval;
}

///////////////////////////////////////////////////////////////////////////////
// Load from out internal project stream
BOOL CProject::LoadInternalFromOPT(CStateSaver& stateSave, BOOL bIsExternal, BOOL bWorkspace )
{
	BOOL bRetval = TRUE;
	BOOL bDataExists = FALSE;
	CInitFile fileInit;
	ASSERT(stateSave.IsLoading());

	ConfigurationRecord * pcr = GetActiveConfig();
	CString strProjectName;
	if(pcr)
		pcr->GetProjectName(strProjectName);

	CString strStream;
	if( bWorkspace ){
		strStream = STREAM_PROJINTINFO;
	} else {
		strStream = STREAM_PROJINTINFO + strProjectName;
	}
	if (!stateSave.OpenStream(fileInit, strStream ))
		return FALSE;

	CArchive ar ( &fileInit, CArchive::load | CArchive::bNoFlushOnDelete);
	CString str, str2, strFirstConfig, strCurConfig;
	UINT nFormatVersion;
	// Have to set this to 0 because of a bug in CRuntimeClass::Load which
	// only loads a word:
	UINT wSchemaNum = 0l;

	TRY
	{
		ar >> ((long&) nFormatVersion);

		// For the OPT files, the formats must match exactly
		if ((nFormatVersion != nVersionNumber) && (nFormatVersion < nLastCompatibleOPTFile || nFormatVersion > nVersionNumber))
			AfxThrowArchiveException (CArchiveException::badSchema);

		// Do we have any data in this stream.
		ar >> ((long&) bDataExists);
		if (!bDataExists)
		{
			// No we don't have any data, so we
			// may have to fail the loading of the
			// OPT file in order to init the data
			m_hOPTData = NULL;
			bRetval = bIsExternal;
 		}
		else
		{
			// We have some data in the stream but
			// are we attempting to load an internal
			// project, if so then we load the data
			if (!bIsExternal)
			{
				if( bWorkspace ){
					// Load the state of the Project.Settings option tree-control
					if (!COptionTreeCtl::LoadOptTreeStore(ar))
						AfxThrowArchiveException (CArchiveException::badSchema);

					// Load the state of the BatchBuild dialog
					if (!CBatchBldDlg::LoadBatchBldOpt(ar))
						AfxThrowArchiveException (CArchiveException::badSchema);

					// Load the state of the UpdateDeps dialog
					if (!CUpdateDepDlg::LoadSelFromOpt(ar))
						AfxThrowArchiveException (CArchiveException::badSchema);

					// Load the state of the Export dialog
					if (!CProjectsDlg::LoadProjectsSelOpt(ar))
						AfxThrowArchiveException (CArchiveException::badSchema);

					// Load the state of the Profiler dialog
					if (!CProfileDlg::LoadProfOptStore(ar))
						AfxThrowArchiveException (CArchiveException::badSchema);

				} else {
					// Load the state of the builder
					//if (!CActionSlob::LoadFromArchive(ar))
					//	AfxThrowArchiveException (CArchiveException::badSchema);

					ar >> strCurConfig;
					if (ConfigRecordFromConfigName ( strCurConfig ) == NULL )
					{
						CString strmes;
						GetStrProp  (P_ProjActiveConfiguration, strFirstConfig);
						MsgBox (  Information,
								  MsgText ( strmes,
											IDS_OPT_UNKNOWN_CONFIG,
											(const TCHAR *) strCurConfig,
											(const TCHAR *) strFirstConfig
										   )
								);
						strmes.Empty ();
						strCurConfig = strFirstConfig;
	
					}

				// Make sure this stream is for us:
					ar >> str;
					GetMoniker (str2);
					if (CompareMonikers(str, str2) != 0 ||
						CRuntimeClass::Load (ar, &wSchemaNum) != GetRuntimeClass() ||
						wSchemaNum != GetRuntimeClass()->m_wSchema
					   )
						AfxThrowArchiveException(CArchiveException::badSchema);

					if (!SerializeProps(ar))
						AfxThrowArchiveException(CArchiveException::generic);
				}
			}
			else
			{
				// Not loading an internal project so
				// just get a pointer to the stream
				// data so we can later restore it.
				m_hOPTData = fileInit.GetInitData();
			}
		}

		ar.Close ();
		fileInit.Close();
	}
	CATCH_ALL(e)
	{
		#ifdef _DEBUG
		AfxDump(e);
		TRACE("\n");
		#endif
		fileInit.Abort();
		bRetval = FALSE;
	}
	END_CATCH_ALL

#if 0
	//  If the current configuration read in from the make is different from what
	//  we got from the MSF file, we need to set it again with SetStrProp.  This is
	//  Because Serialize props doesn't call SetXXXProp as it reads the props in:
	if (bRetval &&
		!bIsExternal &&	// don't need to check this for external makefiles
		(GetActiveConfig()->GetConfigurationName () != strCurConfig ||
		 m_strProjActiveConfiguration != strCurConfig)
	   )
	{			   
		SetStrProp(P_ProjActiveConfiguration, strCurConfig);
	}
#endif

	return bRetval;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::SaveToOPT(CStateSaver& stateSave)
{
	BOOL bRetVal;

	// We may need to save to both internal and external streams.
	if (IsExeProject())
		bRetVal = SaveExternalToOPT(stateSave, IsExeProject());
	else
		bRetVal = SaveInternalToOPT(stateSave, IsExeProject(),FALSE);

	PFILE_TRACE ( "CProject::SaveToOPT returning %i\n",bRetVal);
	return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// Save to external project stream.
BOOL CProject::SaveExternalToOPT(CStateSaver& stateSave, BOOL bIsExternal)
{
	BOOL bRetval = TRUE;
	CInitFile fileInit;

	ASSERT(stateSave.IsStoring());

	ASSERT(bIsExternal);
	if (!stateSave.OpenStream(fileInit, STREAM_PROJEXTINFO ))
	{
		SetFileError(CFileException::generic);
		return FALSE;
	}

	CArchive ar ( &fileInit, CArchive::store | CArchive::bNoFlushOnDelete );
	CString str;

	TRY
	{
		// Save format version:
		if (bIsExternal || m_hOPTData == NULL)
		{
 			ar << ((long) nVersionNumber);
			ar << ((long) (bIsExternal || m_hOPTData != NULL));
		}

		// If we are saving an external project then let's
		// really save the data.
		if (bIsExternal)
		{
			// Save the state of the builder
//			if (!CActionSlob::SaveToArchive(ar))
//	 			AfxThrowArchiveException (CArchiveException::badSchema);

			// Save the state of the Project.Settings option tree-control
			if (!COptionTreeCtl::SaveOptTreeStore(ar))
	 			AfxThrowArchiveException (CArchiveException::badSchema);

			int icr, ccr;
			CStringProp *pProp;
			ConfigurationRecord *pcr;
			const CPtrArray & ppcr = *GetConfigArray();

			ccr = m_ConfigArray.GetSize();
			ar << (DWORD)ccr;

			// Loop through all configurations, writing out information about each.
			for (icr=0 ; icr<ccr ; ++icr)
			{
				pcr = (ConfigurationRecord *)ppcr[icr];
				ar << pcr->GetConfigurationName();

 				// Get the 'current' property bag for this configuration
				CPropBag * pBag = pcr->GetPropBag(CurrBag);

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_ExtOpts_CmdLine));
				ASSERT(pProp->m_nType == string );
				ar << pProp->m_strVal;

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_ExtOpts_RebuildOpt));
				ASSERT(pProp->m_nType == string );
				ar << pProp->m_strVal;

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_ExtOpts_Targ));
				ASSERT(pProp->m_nType == string );
				ar << pProp->m_strVal;

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_ExtOpts_BscName));
				ASSERT(pProp->m_nType == string );
				ar << pProp->m_strVal;

				// This property is now defunct
				//VERIFY(pProp = (CStringProp *)pBag->FindProp(P_ExtOpts_ClsWzdName));
				//ASSERT(pProp->m_nType == string );
				//ar << pProp->m_strVal;

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_ExtOpts_Platform));
				ASSERT(pProp->m_nType == string);
				{
					CPlatform *	pPlatform;
					// the prop val is the "UI description" of the platform
					// we want to write the official name
					VERIFY(g_prjcompmgr.LookupPlatformByUIDescription(pProp->m_strVal, pPlatform));
					ar << *(pPlatform->GetName());
				}

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_Caller));
				ASSERT(pProp->m_nType == string);
				ar << pProp->m_strVal;

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_WorkingDirectory));
				ASSERT(pProp->m_nType == string);
				ar << pProp->m_strVal;

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_Args));
				ASSERT(pProp->m_nType == string);
				ar << pProp->m_strVal;

				CIntProp *pIntProp;
				VERIFY(pIntProp = (CIntProp *)pBag->FindProp(P_PromptForDlls));
				ASSERT(pIntProp->m_nType == integer);
				ar << (LONG)pIntProp->m_nVal;

				VERIFY(pProp = (CStringProp *)pBag->FindProp(P_RemoteTarget));
				ASSERT(pProp->m_nType == string);
				ar << pProp->m_strVal;

				// write out the Java properties

				// get the current platform
				CPlatform* pPlatform = GetCurrentPlatform();
				ASSERT(pPlatform != NULL);
				if (pPlatform != NULL && pPlatform->GetUniqueId() == java)
				{
					// class name
					VERIFY(pProp = (CStringProp*)pBag->FindProp(P_Java_ClassFileName));
					ASSERT(pProp->m_nType == string);
					ar << pProp->m_strVal;

					// debug using browser/stand-alone interpreter
					VERIFY(pIntProp = (CIntProp*)pBag->FindProp(P_Java_DebugUsing));
					ASSERT(pIntProp->m_nType == integer);
					ar << (LONG)pIntProp->m_nVal;

					// browser name
					VERIFY(pProp = (CStringProp*)pBag->FindProp(P_Java_Browser));
					ASSERT(pProp->m_nType == string);
					ar << pProp->m_strVal;

					// stand-alone interpreter name
					VERIFY(pProp = (CStringProp*)pBag->FindProp(P_Java_Standalone));
					ASSERT(pProp->m_nType == string);
					ar << pProp->m_strVal;
				
					// param source: html page or user
					VERIFY(pIntProp = (CIntProp*)pBag->FindProp(P_Java_ParamSource));
					ASSERT(pIntProp->m_nType == integer);
					ar << (LONG)pIntProp->m_nVal;

					// HTML page
					VERIFY(pProp = (CStringProp*)pBag->FindProp(P_Java_HTMLPage));
					ASSERT(pProp->m_nType == string);
					ar << pProp->m_strVal;
				
					// temp HTML page
					VERIFY(pProp = (CStringProp*)pBag->FindProp(P_Java_TempHTMLPage));
					ASSERT(pProp->m_nType == string);
					ar << pProp->m_strVal;
				
					// args in HTML form
					VERIFY(pProp = (CStringProp*)pBag->FindProp(P_Java_HTMLArgs));
					ASSERT(pProp->m_nType == string);
					ar << pProp->m_strVal;

					// command line args
					VERIFY(pProp = (CStringProp*)pBag->FindProp(P_Java_Args));
					ASSERT(pProp->m_nType == string);
					ar << pProp->m_strVal;

					// stand-alone interpreter args
					VERIFY(pProp = (CStringProp*)pBag->FindProp(P_Java_StandaloneArgs));
					ASSERT(pProp->m_nType == string);
					ar << pProp->m_strVal;
					
					// debug stand-alone as applet or application
					VERIFY(pIntProp = (CIntProp*)pBag->FindProp(P_Java_DebugStandalone));
					ASSERT(pIntProp->m_nType == integer);
					ar << (LONG)pIntProp->m_nVal;
				}
			}

			// Write the name of the active configuration.
			GetStrProp  (P_ProjActiveConfiguration, str);
			ar << str;

			// Write the end-of-record marker.
			ar << dwExtEOR;
		}
		else
		{
			// Not really saving an external project, so do
			// we have any data that we need to preserve.
			if (m_hOPTData != NULL && !m_bProjConverted)
			{
				// Just write out the data we read in.
				WORD FAR* lpw = (WORD FAR*) ::GlobalLock(m_hOPTData);
				UINT nFileSize = (WORD) *lpw++;
				ar.Write(lpw, nFileSize);
				::GlobalUnlock(m_hOPTData);
			}
		}

		ar.Close ();
		fileInit.Close ();
	}
	CATCH_ALL(e)
	{
		#ifdef _DEBUG
		AfxDump(e);
		TRACE("\n");
		#endif

		if (e->IsKindOf(RUNTIME_CLASS(CFileException)))
			SetFileError(((CFileException*) e)->m_cause);
		else
			SetFileError(CFileException::generic);

		fileInit.Abort(); // will not throw an exception
		bRetval = FALSE;
	}
	END_CATCH_ALL

	return bRetval;
}

///////////////////////////////////////////////////////////////////////////////
// Save to internal project stream.
BOOL CProject::SaveInternalToOPT(CStateSaver& stateSave, BOOL bIsExternal, BOOL bWorkspace)
{
	BOOL bRetval = TRUE;
	CInitFile fileInit;

	ASSERT(stateSave.IsStoring());

	ConfigurationRecord * pcr = GetActiveConfig();
	CString strProjectName;
	if(pcr)
		pcr->GetProjectName(strProjectName);

	CString strStream;

	if( bWorkspace ){
		strStream = STREAM_PROJINTINFO;
	} else {
		strStream = STREAM_PROJINTINFO + strProjectName;
	}

	if (!stateSave.OpenStream(fileInit, strStream ))
	{
		SetFileError(CFileException::generic);
		return FALSE;
	}

	CArchive ar ( &fileInit, CArchive::store | CArchive::bNoFlushOnDelete );
	CString str;

	TRY
	{
		// Save format version:
		if (!bIsExternal || m_hOPTData == NULL)
		{
 			ar << ((long) nVersionNumber);
			ar << ((long) (!bIsExternal || m_hOPTData != NULL));
		}

		// If we are saving an internal project then let's
		// really save the data.
		if (!bIsExternal)
		{
			if( bWorkspace ){
					
				// Load the state of the Project.Settings option tree-control
				if (!COptionTreeCtl::SaveOptTreeStore(ar))
					AfxThrowArchiveException (CArchiveException::badSchema);

				// Save the state of the BatchBuild dialog
				if (!CBatchBldDlg::SaveBatchBldOpt(ar))
					AfxThrowArchiveException (CArchiveException::badSchema);
		
				// Save the state of the UpdateDeps dialog
				if (!CUpdateDepDlg::SaveSelToOpt(ar))
					AfxThrowArchiveException (CArchiveException::badSchema);

				// Save the state of the Export dialog
				if (!CProjectsDlg::SaveProjectsSelOpt(ar))
					AfxThrowArchiveException (CArchiveException::badSchema);

				// (WinslowF) Save the state of the Profiler dialog
				if (!CProfileDlg::SaveProfOptStore(ar))
					AfxThrowArchiveException (CArchiveException::badSchema);

			} else {
				// Save the state of the builder
				// if (!CActionSlob::SaveToArchive(ar))
				//	AfxThrowArchiveException (CArchiveException::badSchema);

				// do this for all subprojects
				GetStrProp  (P_ProjActiveConfiguration, str);
				ar << str;
				
				GetMoniker (str);
				ar << str;
				GetRuntimeClass()->Store (ar);
	
				if (!SerializeProps(ar))
					AfxThrowArchiveException(CArchiveException::generic);
			}

		}
		else
		{
			// Not saving an internal project but we
			// may have some data that need's to be
			// preserved!
			if (m_hOPTData != NULL)
			{
				// Just write out the data we read in.
				WORD FAR* lpw = (WORD FAR*) ::GlobalLock(m_hOPTData);
				UINT nFileSize = (WORD) *lpw++;
				ar.Write(lpw, nFileSize);
				::GlobalUnlock(m_hOPTData);
			}
		}

		ar.Close ();
		fileInit.Close ();
	}
	CATCH_ALL(e)
	{
		#ifdef _DEBUG
		AfxDump(e);
		TRACE("\n");
		#endif

		if (e->IsKindOf(RUNTIME_CLASS(CFileException)))
			SetFileError(((CFileException*) e)->m_cause);
		else
			SetFileError(CFileException::generic);

		fileInit.Abort(); // will not throw an exception
		bRetval = FALSE;
	}
	END_CATCH_ALL

	return bRetval;
}

///////////////////////////////////////////////////////////////////////////////
CProject::ReadMakeResults CProject::ReadMakeFile (BOOL &bProjectDirty)
{
//	Open the project's makefile and try to read it in as an internal makefile.
//	The makefile reader determines this by looking for our special header in
//	the file.

	// 04-10-96 jimsc  SuckMacro uses this, so we have to make sure it doesn't
	// point to a deleted object.

	g_pLastTool = NULL;
	g_bErrorPrompted = FALSE;
	g_bConversionCanceled = FALSE;
	static UINT idConvReply;
	BOOL bIsWorkspaceInit = (FindProjWksIFace()->IsWorkspaceInitialised() == S_OK);

#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "devbldd.dll", "ReadMakeFile()", letypeBegin, 0);
#endif

	BOOL bRetval = TRUE, bOkAsInternal = FALSE;
	const CPath *pPath = GetFilePath();
	ASSERT (pPath);
	CObject *pObject = NULL;
	CString strMsg, str, str1, str2, str3, strDSSig;
	ReadMakeResults rmr = ReadInternal;

	CMakFileReader mr;

	// FUTURE: remove this when move to CBuildFile in bldrfile.cpp
	g_buildfile.m_pmr = &mr;
	
	CFileException excptFile;
	if (!mr.Open(*pPath, CFile::modeRead | CFile::shareDenyWrite, &excptFile))
	{
		// If e.m_cause == CFileException::none, we didn't even get to the open,
		// meaning the path is bad somehow...

		CProjTempProjectChange projTempProjectChange (NULL);
		if (excptFile.m_cause == CFileException::none)
			MsgBox(Error, IDS_BAD_DIR_SPEC);
		else if (excptFile.m_cause == CFileException::hardIO)
			MsgBox (Error, MsgText (strMsg, IDS_INVALID_PROJECT_LOCALPATH, *pPath));
		else
			MsgBox(Error, MsgText (strMsg, *pPath, IDS_OPEN_PROJECT_FILE, &excptFile));

		rmr = ReadError;
	}
	else																
	{
		CException e;

		TRY
		{
			pObject = mr.GetNextElement();
			ASSERT (pObject);

			// Skip over "Microsoft Developer Studio Project File" signature
			VERIFY (strDSSig.LoadString (IDS_DSPROJ_SIG_STRING));
			if ((pObject->IsKindOf(RUNTIME_CLASS(CMakComment))) &&
				 (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)strDSSig, strDSSig.GetLength()) == 0))
			{
				// UNDONE: check/assert that the package id is 4
				delete pObject;
				pObject = mr.GetNextElement();
				ASSERT (pObject);
			}

			// look for a comment with the signature string
			// to see if it is a Dolphin or Olympus makefile
			// or an Orion project file
			VERIFY (str.LoadString (IDS_MAKEFILE_SIG_STRING));
            VERIFY (str1.LoadString (IDS_BUILDPRJ_SIG_STRING));
            VERIFY (str2.LoadString (IDS_OLD_MAKEFILE_SIG_STRING));
            VERIFY (str3.LoadString (IDS_EXPORT_SIG_STRING));
			if ((!pObject->IsKindOf(RUNTIME_CLASS(CMakComment))) ||
				 ((_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str, str.GetLength()) != 0) && 
				 (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str1, str1.GetLength()) != 0) && 
				 (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str2, str2.GetLength()) != 0) && 
				 (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str3, str3.GetLength()) != 0))
			   )
			{
				//					  
				// not a Dolphin makefile can we convert this pre- v2.0 builder makefile?
				// We'll ask each builder converter registered to make a check.
				//

 				// parse it whilst ignoring line continuation characters and not showing a status bar
				// (old v1.x makefiles incorrectly use '\' in their macro values, eg. 'PROJPATH=c:\tmp\appwiz\')
				mr.SetAttributes((MakRW_Default | MakR_IgnLineCont) & ~MakRW_ShowStatus);

				// unget this comment line
				mr.UngetElement(pObject);

				// builder conversion information block
				CNV_INFO cnvinfo = {0};		// blank out

				cnvinfo.pPath = (const CPath *)pPath;	// path to builder
				cnvinfo.pProject = this;				// builder object
				cnvinfo.nUseMFC = g_prjcompmgr.MFCIsInstalled() ? UseMFCInLibrary : NoUseMFC;

				CBuilderConverter * pbldrcnvtr;

				// initialise each converter
				// our list to try the conversion on
				CPtrList lstBldrCnvtrs;
				g_prjcompmgr.InitBuilderConverterEnum();
				while (g_prjcompmgr.NextBuilderConverter(pbldrcnvtr))
				{
					if (pbldrcnvtr->FInitialise())
						lstBldrCnvtrs.AddTail((void *)pbldrcnvtr);
				}

				rmr = ReadExternal;
				// read through the makefile until converters exhausted
				BOOL fEOF = FALSE;

				while (!fEOF)
				{
					pObject = mr.GetNextElement();
					ASSERT (pObject);

					// EOF makefile?
					fEOF = pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile));

					// ask each converter in turn...
					POSITION pos = lstBldrCnvtrs.GetHeadPosition();

					// out of converters?
					fEOF = fEOF || (pos == (POSITION)NULL);
					if (!fEOF)
					{
						while (pos != (POSITION)NULL)
						{
							POSITION posbldrcnvtr = pos;
							pbldrcnvtr = (CBuilderConverter *)lstBldrCnvtrs.GetNext(pos);

							// is this converter still attempting to recognise this builder?
							if (pbldrcnvtr->CanConvert(pObject, mr.GetCurrentLine(), &cnvinfo))
							{
								// yes and
								// wants to convert?
								if (cnvinfo.nStatus == 1)
								{
									// yes
									cnvinfo.pbldrcnvtr = pbldrcnvtr;
									fEOF = TRUE;
								}
								// wants to abort?
								else if (cnvinfo.nStatus == -1)
								{
									// yes, flag this as makefile read error
									rmr = ReadError;
									fEOF = TRUE;
								}
							}
							else
							{
								// no, so remove from our list
								lstBldrCnvtrs.RemoveAt(posbldrcnvtr);
							}
						}
					}

  					delete pObject;
					pObject = (CObject *)NULL;
				}

				// have to jump out of the previous percent-dones before
				// starting the conversion, or else the status bar will
				// not reflect the progress of the conversion.
				StatusEndPercentDone();

				// doesn't look like a Visual C++ makefile?
				if (cnvinfo.pbldrcnvtr == (CBuilderConverter *)NULL)
					AfxThrowFileException (CFileException::generic);

				// re-open the makefile so that we parse from the beginning again
				// show the status
				mr.SetAttributes(MakRW_Default | MakR_IgnLineCont);
				mr.ReOpen();

				// read through the makefile until error or EOF
				fEOF = FALSE;

				while (!fEOF)
				{
					pObject = mr.GetNextElement();
					ASSERT (pObject);

					// EOF makefile?
					fEOF = pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile));

					// have the builder converter perform the conversion
					if (!fEOF)
					{
						if (!cnvinfo.pbldrcnvtr->DoConvert(pObject, mr.GetCurrentLine(), &cnvinfo))
						AfxThrowFileException (CFileException::generic);
					}

  					delete pObject;
					pObject = (CObject *)NULL;
				}

				// is this makefile we are to convert wanting to use MFC?
				if (cnvinfo.nUseMFC != NoUseMFC && !g_prjcompmgr.MFCIsInstalled())
				{
					// flag this error
					m_bGotUseMFCError = TRUE;

					if (QuestionBox(IDS_MFC_NOT_INSTALLED, MB_YESNO) == IDNO)
						AfxThrowFileException (CFileException::generic);

					cnvinfo.nUseMFC = NoUseMFC;	// best of luck!
					bProjectDirty = TRUE;
				}

				// finish the conversion
				if (!cnvinfo.pbldrcnvtr->FinishConvert(&cnvinfo))
					AfxThrowFileException (CFileException::generic);

				// scanning and saving gets done later
				m_bProjMarkedForScan = TRUE;
				m_bProjMarkedForSave = !cnvinfo.fSilent;
				m_bProjHasNoOPTFile  = TRUE;

				// flag the fact that we just converted,
				// and ok the builder as internal (we're converting it!)
				m_bProjConverted = bOkAsInternal = TRUE;
				rmr = ReadInternal;

				if (!cnvinfo.fSilent)
					// we want to dirty the project if it is not "silent convert"
					bProjectDirty = TRUE;
			}
			else if (_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str3, str3.GetLength()) == 0)
			{
				CDir dir;
				CPath path;
				dir.CreateFromPath(*pPath);
				VERIFY(path.CreateFromDirAndFilename(dir, ((const TCHAR *)((CMakComment *)pObject)->m_strText) + str3.GetLength()));
				delete pObject;
				pObject = (CObject *)NULL;
				if (!path.ExistsOnDisk())
				{
					// file doesn't exist, so give up
					g_bErrorPrompted = TRUE;
					CProjTempProjectChange projTempProjectChange (NULL);
					MsgText (strMsg, IDS_READ_EXPORTED_FILE, (const char *) path);
					MsgBox(Error, strMsg);
					rmr = ReadExternal;
				}
				else
				{
					SetFile(&path, TRUE);
					InformDependants (SN_FILE_NAME);
					rmr = ReadExportedMakefile;
				}
			}
			else
			{
				//
				// A Dolphin or Olympus makefile
				//

				// FUTURE: UNICODE
				BOOL bV4xSigString = !(_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str, str.GetLength())); 
				BOOL bNewSigString = !(_tcsncmp((const TCHAR *)((CMakComment *) pObject)->m_strText, (const TCHAR *)str1, str1.GetLength())); 
 				TCHAR * pend;
				UINT fileVer = strtoul ((const TCHAR *)((CMakComment *)pObject)->m_strText
									    + ((bNewSigString ? str1 : (bV4xSigString ? str : str2)).GetLength () / sizeof (TCHAR)), &pend, 10);
				
				// Makefile version parsing. Makefile versions can be of two formats
				// 1. Release format, the version number is of the form "m.nn"
				// 2. Internal format, the version number if of the form mnnii
				// where m = major version number
				//       n = minor version number
				//       i = internal version number
				// We must have the correct major version number but allow a lower
				// limit on the minor & internal version numbers
 				UINT nMajor, nMinor, nFormat;
				BOOL bFutureFormat = FALSE;

#define MAJOR_VERSION_MATCH_NOT_REQUIRED
#ifdef MAJOR_VERSION_MATCH_NOT_REQUIRED
#pragma message ("Same major version not yet required for internal format reading")
#endif
				if ((*pend)==_T('.'))
				{
					// Release format makefile version number as it contains a period
					// So get the major and minor versions and check the validity
					nMajor = fileVer;
					nMinor = strtoul(++pend, NULL, 10);
#ifdef MAJOR_VERSION_MATCH_NOT_REQUIRED
					bOkAsInternal = ( (10000*nMajor+100*nMinor) >= nLastCompatibleMakefile);
#else
					bOkAsInternal = ((nMajor == nVersionMajor) && (nMinor >= nLastCompatibleMakefileMinor));
#endif
  				}
				else
				{
					// Internal format makefile version number. So get the major version
					// number and compare it no the last compatible makefile version.
					nMajor = fileVer / 10000;
					nMinor = fileVer / 100 - (nMajor * 100);
#ifdef MAJOR_VERSION_MATCH_NOT_REQUIRED
 					bOkAsInternal = (fileVer >= nLastCompatibleMakefile);
#else
 					bOkAsInternal = ((nMajor == nVersionMajor) &&(fileVer >= nLastCompatibleMakefile));
#endif
 				}
				nFormat = nMajor * 10000 + nMinor * 100;
				bFutureFormat = ((nFormat > nVersionNumber) && (nFormat >= (g_nNextIncompatibleVersion * 100))); // defaults to 700
				bOkAsInternal = bOkAsInternal && !bFutureFormat;

				m_bConvertedVC20 = FALSE;
				m_bConvertedDS4x = FALSE;
				m_bConvertedDS5x = FALSE;

				if ((nMajor >= 2) && (nMajor < nVersionMajor))  // REVIEW
				{
					// If assert this fires, need to add 6.x conversion code
					ASSERT(nVersionMajor <= 6);

					UINT idMsg = (nMajor == 2) ? IDS_CONVERT_MAKEFILE : IDS_CONVERT_MAKEFILE4;

					CString strMsg, strMsg2, strMsg3, strMsg4;
					VERIFY(strMsg2.LoadString(IDS_CONVERT_PORT2));
					if (!bIsWorkspaceInit)
					{
						// for workspace load, Yes applies to all projects
						VERIFY(strMsg4.LoadString(IDS_CONVERT_PORT4));
						strMsg2 += strMsg4;
					}
					CPath backup(*pPath);
					CString strBackExt;
					UINT n = 1;
					do {
						strBackExt.Format(_T(".%03d"), n);
						backup.ChangeExtension(strBackExt);
					} while ((!backup.CanCreateOnDisk()) && (++n < 1000));
					ASSERT(n < 1000);  // write failure

					MsgText(strMsg3,IDS_BACKUP_MAKEFILE,(const TCHAR *)backup);
					g_pActiveProject = NULL;
					MsgText(strMsg, idMsg, (const TCHAR *)*pPath);
					if (g_pAutomationState->DisplayUI() && !g_bNoUI) //ShellOM:State
					{
						g_pActiveProject = this;
						CProjTempProjectChange projTempProjectChange (NULL);
						if (!g_bConversionPrompted)
						{
							idConvReply = MsgBox(Question, strMsg +strMsg3 +strMsg2, MB_YESNOCANCEL);
							// avoid prompting for conversion multiple times
							// during workspace load
							// FUTURE: add true YESTOALL UI
							g_bConversionPrompted = ((idConvReply == IDYES) && (!bIsWorkspaceInit));
						}
					}
					else
					{
						if (theApp.m_bInvokedCommandLine && (nMajor >= 5))
						{
							idConvReply = IDYES; // just convert it
							theApp.WriteLog(strMsg, TRUE);
							theApp.WriteLog(strMsg3 + _T("\n"), TRUE);
						}
						else
						{
							// The automation engine cannot cope with this error message.
							// The safest thing is to return an error and quit.
							g_pAutomationState->SetError((nMajor == 2) ? DS_E_PROJECT_OLD_MAKEFILE_VC : DS_E_PROJECT_OLD_MAKEFILE_DEVSTUDIO) ;

							// Pretend that the user pressed Cancel.
							idConvReply = IDCANCEL ;
							if (theApp.m_bInvokedCommandLine)
							{
								// REVIEW: should we support this?
								CString strOut;
								MsgText(strOut, IDS_ERR_CANT_CONVERT, (LPCTSTR)*pPath);
								theApp.WriteLog(strOut, TRUE);
							}
						}
					}

					// Want to convert?
					if (idConvReply == IDYES)
					{
						// REVIEW (KiP: 10/96) we should offer a checkbox on the previous dialog asking if we should backup.
						CopyFile( (const TCHAR *)*pPath, (const TCHAR *)backup, TRUE );
						
						if (nMajor < 5) // REVIEW
						{
							// make sure we get rid of any .opt files from a previous conversion attempt
							CPath OPTPath(*pPath);
							OPTPath.ChangeExtension(WSOPTIONS_EXT);
							if (OPTPath.ExistsOnDisk())
								RemoveFileIfPossible(OPTPath);
						}
						
						// Prepare to convert
						// VC++ 2.0/4.0 makefile
						if (nMajor == 2)
						{
						
							m_bConvertedVC20 = TRUE;
						}
						else if (nMajor < 5)
						{
							m_bConvertedDS4x = TRUE;
						}
						else if (nMajor == 5)
						{
							m_bConvertedDS5x = TRUE;
						}

						// Don't use OemToAnsi translation for versions < 6.0
						if (nMajor < 6)
						{
							g_bConvDontTranslate = TRUE;
						}

						// Flag bOkAsInternal as TRUE, we are converting!!
						m_bProjConverted = bOkAsInternal = TRUE;

						// we'll need this later...
						g_pConvertedProject = (CProject *)this;
					}
					else if ((idConvReply == IDCANCEL) || (nMajor >= 5))
					{
						g_pAutomationState->SetSavePromptCanceled() ; // Inform automation engine that operation was canceled

						// flag this as makefile read error
						bOkAsInternal = FALSE;
						rmr = ReadError;
						g_bConversionCanceled = (idConvReply == IDCANCEL);
					}
					else
					{
						ASSERT(nMajor < 5);
						// offer to wrap it
						bOkAsInternal = FALSE;
						rmr = ReadExternal;
					}
				}
				else if (bFutureFormat)
				{
					// give error if trying to load with old product
					ASSERT(!bOkAsInternal);
					rmr = ReadError;
					UINT idReply ;
					CString strMsg;
					MsgText(strMsg, IDS_READ_FUTURE_FORMAT, (const TCHAR *)*pPath);
					if (g_pAutomationState->DisplayUI() && !g_bNoUI) //ShellOM:State
					{
						g_pActiveProject = this;
						CProjTempProjectChange projTempProjectChange (NULL);
						idReply = MsgBox(Error, strMsg, MB_OKCANCEL);
					}
					else
					{
						if (theApp.m_bInvokedCommandLine)
						{
							idReply = IDOK; // just ignore it
							theApp.WriteLog(strMsg, TRUE);
						}
						else
						{
							// The automation engine cannot cope with this error message.
							// The safest thing is to return an error and quit.
							g_pAutomationState->SetError(DS_E_PROJECT_FUTURE_FORMAT);
							g_pAutomationState->SetSavePromptCanceled() ; // Inform automation engine that operation was canceled

							// Pretend that the user pressed Cancel.
							idReply = IDCANCEL ;
						}
					}
					g_bConversionCanceled = (idReply == IDCANCEL);

				}

				// Ok this is the latest and greatest makefile format
				if (!bOkAsInternal)
 					AfxThrowFileException (CFileException::generic);
 
				delete (pObject); pObject = (CObject *)NULL;
				ASSERT(bOkAsInternal);	// ok as internal (we saw a signature)

				// Read in configurations:
				if (!ReadConfigurationHeader(mr))
				{
					if (m_bConvertedDS5x)
						rmr = ReadError; // don't try to wrap
					AfxThrowFileException(CFileException::generic);
				}

				ASSERT(this == g_pActiveProject);

				// we'll break when we hit the '# Project' delimiter or EOF
				for (;;)
				{
					if (pObject)
					{
						delete pObject;
						pObject = (CObject *)NULL;
					}

					pObject = mr.GetNextElement();
					ASSERT(pObject != (CObject *)NULL);

					// reached end of builder file prematurely?
					if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
	                	AfxThrowFileException(CFileException::generic);

					// read in our sections
					if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
					{
						const TCHAR * pchComment = (const TCHAR *)((CMakComment *)pObject)->m_strText;

						// got the '# Project' comment?
						if (GetRTCFromNamePrefix(pchComment) == GetRuntimeClass())
							break;
					}
				}

				mr.UngetElement(pObject); pObject = (CObject *)NULL;
				
				// Init the dep caches before really reading anything.
				InitDependencyCaches();

				// Read in the bulk of the makefile
				if (!ReadFromMakeFile (mr, GetWorkspaceDir()))
		        	AfxThrowFileException (CFileException::generic);

				// Read in our sections
				// We'll break when we hit EOF
				for (;;)
				{
					if (pObject)
					{
						delete pObject;
						pObject = (CObject *)NULL;
					}

					pObject = mr.GetNextElement();
					ASSERT(pObject != (CObject *)NULL);

					// reached end of builder file?
					if (pObject->IsKindOf(RUNTIME_CLASS(CMakEndOfFile)))
	                	break;

					// read in our sections
					if (pObject->IsKindOf(RUNTIME_CLASS(CMakComment)))
					{
						const TCHAR * pchComment = (const TCHAR *)((CMakComment *)pObject)->m_strText;

						// got a '# Section <name>' comment?
						// FUTURE: replace this with the szSectionMark in bldrfile.cpp when move there
						if (!_tcsnicmp(pchComment, _TEXT("Section"), 7))
							if (!g_buildfile.ReadSectionForNMake((const TCHAR *)(pchComment + 8)))
								AfxThrowFileException(CFileException::generic);
					}
				}

				if (pObject)
				{
					delete pObject;
					pObject = (CObject *)NULL;
				}


				// Post-'read bulk' VC++ 2.0 conversion?
				// FUTURE: move this into a CBuilderConverter::FinishConvert()
				// when (if) we develop a 'true' v2.x .mak converter
#if 0
				if (m_bConvertedVC20)
				{
					// Collect any groups in the project together
					CObList ol;
					POSITION pos = GetHeadPosition();
					while (pos != NULL)
					{
						CProjGroup* pGroup = (CProjGroup*)GetNext(pos);
						if (pGroup->IsKindOf(RUNTIME_CLASS(CProjGroup)))
 							ol.AddTail(pGroup);	
 					}

#if 0
					CProjGroup * pGroup;
					CTargetItem * pTarget;
					CString strTargetName;
#endif
					// process the groups
					while (!ol.IsEmpty())
					{
						CProjGroup* pGroup = (CProjGroup*)ol.RemoveHead();
#if 1
						// Delete the groups
						pGroup->MoveInto(NULL);
#else
						// UNDONE: We now keep any groups since v5 can handle them
				        InitTargetEnum();
      					VERIFY(NextTargetEnum(strTargetName, pTarget));
						pGroup->MoveInto(pTarget);
#endif
					}
				}
#endif

				CProject * pProject = GetProject();
				ASSERT(pProject == this);
				CString strProj;
				if (m_bConvertedDS4x)
				{
					CProject::InitProjectEnum();
					pProject = (CProject *)CProject::NextProjectEnum(strProj, FALSE);
				}
				do {
					const CPtrArray * pCfgArray = pProject->GetConfigArray();
					int icfg, size = pCfgArray->GetSize();
					int nDeletedJavaCfg = 0;
#if 1
					if ((pProject->m_bConvertedDS5x) || (pProject->m_bConvertedDS4x) || m_bConvertedVC20)
					{
						CStringList lststrPlatforms;
						CString strPlatformName;
						strPlatformName.LoadString(IDS_V4_MACPMC_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);
						// strPlatformName.LoadString(IDS_V2_WIN32MIPS_PLATFORM);
						// lststrPlatforms.AddTail(strPlatformName);
						strPlatformName.LoadString(IDS_V4_MIPS_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);
						strPlatformName.LoadString(IDS_V2_MAC68K_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);
						strPlatformName.LoadString(IDS_V2_MACPPC_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);
						strPlatformName.LoadString(IDS_V4_PPC_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);

						// don't support Java in DevStudio anymore
						CString strJavaPlatformName;
						strJavaPlatformName.LoadString(IDS_V5_JAVA_PLATFORM);
						lststrPlatforms.AddTail(strJavaPlatformName);
					
						BOOL bFoundSupported = FALSE;
						CString strEmpty;
						icfg = size;
						while (icfg-- > 0)
						{
							ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(icfg);
							CString strOriginalName = pcr->GetConfigurationName();
							CString strDebugness = strOriginalName;
							CProjType * pprojtype = NULL;
							CString strOrgType = pcr->GetOriginalTypeName();
							VERIFY(g_prjcompmgr.LookupProjTypeByName(strOrgType, pprojtype));
							if (pprojtype->IsSupported())
							{
								bFoundSupported = TRUE;
								continue;
							}

							int index = strOriginalName.Find(_T(" - "));
							if (index != -1)
								strDebugness = strOriginalName.Mid(index + 3);
							POSITION pos = lststrPlatforms.GetHeadPosition();
							while (pos != NULL)
							{
								strPlatformName = lststrPlatforms.GetNext(pos);
								int nLength = strPlatformName.GetLength();
								if 	((_tcsncmp((LPCTSTR)strPlatformName, (LPCTSTR)strOrgType, nLength)==0) ||
									 (_tcsncmp((LPCTSTR)strPlatformName, (LPCTSTR)strDebugness, nLength)==0))
								{
									if (strPlatformName == strJavaPlatformName)
									{
										nDeletedJavaCfg++;
									}
									// delete old configs
									HBLDTARGET hTarg = g_BldSysIFace.GetTarget(strOriginalName, (HBUILDER)pProject);
									ASSERT(hTarg != NO_TARGET);
									VERIFY(g_BldSysIFace.DeleteTarget(hTarg, (HBUILDER)pProject));
									// pProject->DeleteConfig(strDebugness, strEmpty);
									break;
								}
							}
						}
					}
#endif
					size = pCfgArray->GetSize();
					ASSERT(m_bProjConverted || (size != 0));
					
					if ((nDeletedJavaCfg > 0) && (size > 0))
					{
						// give belated warning that we're deleting Java configs from a VC makefile project
						// REVIEW: use a more specific error message?
						CString strMsg;
						int i = IDS_DISCARD_UNSUPPORTED;
						strMsg.LoadString(i);
						CProjTempProjectChange projTempProjectChange (NULL);
						MsgBox (Information, strMsg, MB_OK);
					}
					else if ((size == 0) && (m_bProjConverted))
					{
						// we deleted everything on conversion!
						CProjTempProjectChange projTempProjectChange (NULL);
						UINT mbButtons = (g_pAutomationState->DisplayUI() && !g_bNoUI) ? MB_OKCANCEL : MB_OK;
						if (MsgBox (Error, IDS_NOGOOD_PLATFORMS, mbButtons)==IDCANCEL)
							g_bConversionCanceled = TRUE;
						else
							g_bBadConversion = TRUE;

						g_bErrorPrompted = TRUE;
						rmr = ReadError;
						AfxThrowFileException (CFileException::generic);
					}

					for (icfg = 0; icfg < size; icfg++)
					{
						ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(icfg);
						CProjTempConfigChange projTempConfigChange(pProject);
						projTempConfigChange.ChangeConfig(pcr);

						// Post-'read custom build' assignment for target-level
						// we couldn't do this during the read because we hadn't set
						// up our targets as we were reading in the project-level blurb....
						// we'll fix this for v4.0 ;-)
						// we'll send this one, we only need one, P_CustomCommand or P_CustomOutputSpec
						// both are supported by custom build
						pProject->InformDependants(P_CustomCommand); 

						// FUTURE: move this into a CBuilderConverter::FinishConvert()
						// when (if) we develop a 'true' v2.x .mak converter
						if (m_bConvertedVC20 || pProject->m_bConvertedDS4x)
						{
							// Set minimum build and/or MRE deps flags for compiler
							COptionHandler * popthdlr;
							VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler),
																 (CBldSysCmp *&)popthdlr));

							if (m_bConvertedVC20)
								pProject->SetIntProp(popthdlr->MapLogical(P_Enable_MR), TRUE);

							pProject->SetIntProp(popthdlr->MapLogical(P_Enable_FD), TRUE);

							// convert include paths for subprojects
							if (pProject->m_bConvertedDS4x)
								pProject->ConvertDirs();

							// Enable the /mktylib203 flag.
							VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_MkTypLib),
															 (CBldSysCmp *&)popthdlr));

							pProject->SetIntProp(popthdlr->MapLogical(P_MTLMtlCompatible), TRUE);
						}

						if (m_bConvertedVC20 || pProject->m_bConvertedDS4x || m_bConvertedDS5x)
						{
							// V5 -> V6 conversion goes here

							COptionHandler * popthdlr;
							VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler),
																 (CBldSysCmp *&)popthdlr));


							// set ENC options for debug targets
							int val;
							// only set for debug configs  (check for /Od)
							if ((pProject->GetIntProp(popthdlr->MapLogical(P_Optimize), val) == valid) && (val == 1))
							{
								UINT nId = popthdlr->MapLogical(P_DebugInfo);
								if ((pProject->GetIntProp(nId, val) == valid) && (val == DebugInfoPdb))
								{
									// also not compatible with /dlp (internal)
									if ((pProject->GetIntProp(popthdlr->MapLogical(P_Enable_dlp), val) != valid) || (val == 0))
									{
										pProject->SetIntProp(nId, DebugInfoENC);
									}
								}
							}
						}
					}
				} while (m_bConvertedDS4x && ((pProject = (CProject *)CProject::NextProjectEnum(strProj, FALSE)) != NULL));

				// Post-'read bulk' VC++ 2.0 conversion?
				// Convert VC++ 2.x target names 
				if (m_bConvertedVC20)
				{
					// Ok. Loop through all targets and turn the v2 names into v3 names.
					// The conversion algorithm, goes like this,
					// v3 names are of the form
					// <project name> - <platform> <debugness bit>
					// so we get the project name from the base name of the v2 makefile.
					// The platform we can determine from the config mgr.
					// Finally we take the original v2 name, strip hyphens from it, and
					// then try to strip a platform name from the front, and the remaining
					// string we set as the debugness bit

					// Get the project name from the makefiles base name
					CString strProjectName;
					pPath->GetBaseNameString(strProjectName);


					// Load the old v2 platform names for later
					CStringList lststrPlatforms;
					CString strPlatformName;
					
					// (WinslowF) When I remove MIPS targets, I commented the following line.
					// We still might need this string to remove MIPS target from impot makefile.
					// If so, you might wannt to take the commnts out of this string in Vproj.rc
					// and resource.h as well.
					strPlatformName.LoadString(IDS_V2_WIN32X86_PLATFORM);
					lststrPlatforms.AddTail(strPlatformName);
					strPlatformName.LoadString(IDS_V2_WIN3280X86_PLATFORM);
					lststrPlatforms.AddTail(strPlatformName);
					strPlatformName.LoadString(IDS_V2_WIN32_PLATFORM);
					lststrPlatforms.AddTail(strPlatformName);
					
					// Loop through all the targets and rename each of them
					const CPtrArray * pCfgArray = GetProject()->GetConfigArray();
					int icfg, size = pCfgArray->GetSize();
					for (icfg = 0; icfg < size; icfg++)
					{
						ConfigurationRecord * pcr = (ConfigurationRecord *)pCfgArray->GetAt(icfg);
						CProjTempConfigChange projTempConfigChange(this);
						projTempConfigChange.ChangeConfig(pcr);

						// The original v2 target name
						CString strOriginalName = pcr->GetConfigurationName();
 					
						// Get the new platform name
						CPlatform * pPlatform = GetCurrentPlatform();
						CString strPlatform = *(pPlatform->GetUIDescription());

						// If we recognise an old v2 platform name at the front of the old
						// v2 target name then we strip it off
						CString strDebugness = strOriginalName;
						POSITION pos = lststrPlatforms.GetHeadPosition();
						while (pos != NULL)
						{
							strPlatformName = lststrPlatforms.GetNext(pos);
							int nLength = strPlatformName.GetLength();
							if (!strPlatformName.Compare(strDebugness.Left(nLength)))
							{
								strDebugness = strDebugness.Right(strOriginalName.GetLength() - nLength);
								break;
							}
						}

						// If there is a space at the start of the v2 target name then remove it
						if (!strDebugness.IsEmpty() && strDebugness[0] == _T(' '))
							strDebugness = strDebugness.Right(strDebugness.GetLength() - 1);

						// Construct the new name from the basename of the makefile, the new platform name,
						// and the remaining portion of the old v2 target name
						CString strNewName = strProjectName + _T(" - ") + strPlatform + _T(" ") + strDebugness;

						CTargetItem* pTarget = GetTarget(strOriginalName);
						SetTargetName(strProjectName);
						ASSERT(pTarget != NULL);
						if (pTarget != NULL)
							pTarget->SetTargetName(strProjectName);

						// Rename the target
 						RenameTarget(strOriginalName, strNewName);

						// There are some consistency requirements for VC 4.0 projects that were not
						// meaningful in VC 2.0 projects. For example debug MFC requires debug CRT's
						// but there were no debug CRT's in VC 2.0. We call PerformWizardSettings 
						// to do the validity checking and make the neccessary changes.

						int iUseMFC;
						GetIntProp(P_ProjUseMFC, iUseMFC);
					
						GetProjType()->PerformSettingsWizard(this, iUseMFC);
					}

					// saving gets done later
					m_bProjMarkedForSave = TRUE;
					m_bProjHasNoOPTFile  = TRUE;
					m_bProjConverted = TRUE;

					// we want to dirty the project because it is not "silent convert"
					bProjectDirty = TRUE;
					::SetWorkspaceDocDirty();
				}

				// Post-'read bulk' VC++ 4.x conversion?
				if (m_bConvertedDS4x)
				{
					// saving gets done later
					m_bProjMarkedForSave = TRUE;
					m_bProjHasNoOPTFile  = TRUE;
					m_bProjConverted = TRUE;

					// we want to dirty the project because it is not "silent convert"
					bProjectDirty = TRUE;
					::SetWorkspaceDocDirty();
				}

				// Post-'read bulk' VC++ 5.x conversion?
				if (m_bConvertedDS5x)
				{
					// saving gets done later
					m_bProjMarkedForSave = TRUE;
					m_bProjHasNoOPTFile  = TRUE; // REVIEW
					m_bProjConverted = TRUE;

					// we want to dirty the project because it is not "silent convert"
					bProjectDirty = TRUE;
					::SetWorkspaceDocDirty();
				}
			}

			mr.Close();
			if (m_bProjConverted)
			{
				CPath newPath = *pPath;
				newPath.ChangeExtension(BUILDER_EXT);
				SetFile(&newPath, TRUE);
				InformDependants (SN_FILE_NAME);
			}
		}
		CATCH (CException, e)
		{
			if (pObject)
			{
				delete pObject;
			}

			mr.Abort();	// Safely close the reader.

			// restore the project to an empty state
			// since we may try to read in an old OPT file
			// for it and use the project as an external project
			Destroy();

			bRetval = FALSE;
		}
		END_CATCH
	}

	// We are not going to read any dependency information
	// after this point so free these up.
	FreeDependencyCaches( );

	if ((rmr != ReadError) && (rmr != ReadExportedMakefile))
	{
		if (!bRetval || !bOkAsInternal)
		{
			// if we don't have a particular error flagged then
			// this looks like a failure to read one of our projects -> likely to have been modified
			if (bOkAsInternal && (!m_bGotUseMFCError) && (!g_bErrorPrompted) && (!m_bProjConverted))
			{
				CProjTempProjectChange projTempProjectChange (NULL);
				MsgBox (Error, MsgText (strMsg, IDS_READ_PROJECT_FILE, (const char *) *pPath));
				g_bErrorPrompted = TRUE;
			}

			// If we failed to load this project because the
			// project uses mfc and we haven't got mfc installed
			// and the user explicitly said don't load it, then
			// flag the problem as a read error
			// OTHERWISE
			// we flag the problem as being the makefile is
			// external (and will later try to load it as such)
			if (bOkAsInternal && m_bGotUseMFCError)
				rmr = ReadError;
			else if (rmr != ReadExternal)
			{
				// don't offer to wrap unless converted .mak
 				rmr = m_bProjConverted ? ReadExternal : ReadError;
			}
		}
		else if (m_bGotUseMFCError)
		{
			bProjectDirty = TRUE;
		}
	}

#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "devbldd.dll", "ReadMakeFile()", letypeEnd, 0);
#endif
	return rmr;
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::ReadFromMakeFile(CMakFileReader& mr, const CDir &BaseDir)
{
	CObject *pObject = NULL;
	CString str;
	CProject * pProject;
	if (m_bConvertedDS4x)
	{
		LPCSTR pszPath;
		if ((!(SUCCEEDED(g_pProjWksIFace->GetWorkspaceDocPathName(&pszPath)))) || (pszPath == NULL) || (!*pszPath))
		{
			// need this for conversion to work properly
			CPath path = *GetFilePath();
			ProjNameToWksName(path);
			g_pProjWksIFace->SetWorkspaceDoc(path);
		}
		ASSERT(IsKindOf(RUNTIME_CLASS(CProject)));
		CProject * pProject;
		CProject::InitProjectEnum();
		while ((pProject = (CProject *)CProject::NextProjectEnum(str, FALSE)) != NULL)
		{
			pProject->m_cp = EndOfConfigs;
		}
	}
	else
	{
		m_cp = EndOfConfigs;
	}
	
	pProject = (CProject *)this;

	TRY
    {
		// disabled FileRegistry notifications during load
		g_bInProjLoad = TRUE;

		pObject = mr.GetNextElement ();
		if (!pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
				AfxThrowFileException (CFileException::generic);

 		delete (pObject); pObject = NULL;

		for (; pObject = mr.GetNextElement ();)
	   	{

			if (pProject->IsPropComment(pObject))
				continue;
			else if (pProject->IsAddSubtractComment(pObject))
				continue;
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakDirective)))
			{
				pProject->ReadConfigurationIfDef((CMakDirective *)pObject, m_bConvertedDS4x);
				if (m_bConvertedDS4x)
					pProject = g_pActiveProject;	// may have changed
			}
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakMacro)))
			{
				if (!pProject->SuckMacro ((CMakMacro *) pObject, BaseDir))
					AfxThrowFileException (CFileException::generic);
			}
			else if (pObject->IsKindOf(RUNTIME_CLASS(CMakDescBlk)))
			{
				if ((!pProject->ReadMasterDepsLine((CMakDescBlk *)pObject, BaseDir)) ||
				   (!pProject->SuckDescBlk((CMakDescBlk *)pObject)))
					AfxThrowFileException (CFileException::generic);
			}
			else if (pProject->IsCustomBuildMacroComment(pObject)) {
				pProject->ReadCustomBuildMacros(mr);
			}
			// Comment marks start of children:
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakComment)))
			{
				ASSERT( pProject->m_cp==EndOfConfigs);
				mr.UngetElement ( pObject );
				pObject = NULL;
				break;
			}
			else if (pObject->IsKindOf ( RUNTIME_CLASS(CMakEndOfFile)))
			{
				AfxThrowFileException (CFileException::generic);
			}

	   		delete (pObject); pObject = NULL;
		}

		// Pre-'read bulk' VC++ 2.0 conversion?
		if (m_bConvertedVC20)
		{
   			ConfigurationRecord* pcr;
			CString strTargetName;
			CTargetItem* pNewTarget;

			// All the remaining configs are also mapped to the
			// newly created target node, i.e. they are mirrors
			int iNumConfig = m_ConfigArray.GetSize();
			for (int i = 0 ; i < iNumConfig; i++)
			{
				pcr = (ConfigurationRecord *) m_ConfigArray[i] ;
				strTargetName = pcr->GetConfigurationName();

				if (i == 0)
				{
					pNewTarget = new CTargetItem();
					pNewTarget->MoveInto(this);
				}

				// force the target into it's own config.
				CProjTempConfigChange projTempConfigChange(this);
				projTempConfigChange.ChangeConfig(strTargetName);
				ConfigurationRecord * pcrProject = GetActiveConfig();
								
				pNewTarget->GetActiveConfig()->SetValid(TRUE);
		
				// create a build instance
				g_buildengine.AddBuildInst(pcrProject);

			 	// inform the graph of this target that it is being created
				g_buildengine.GetDepGraph(pcrProject)->SetGraphMode(Graph_Creating);

			 	// assign the build actions
				CActionSlob::AssignActions(pNewTarget, (CPtrList *)NULL, pcrProject);

				// reset the project config.
				projTempConfigChange.Release();

				// Register this target with the project target manager
				VERIFY(RegisterTarget(strTargetName, pNewTarget));
			}
		}

		g_pActiveProject = (CProject *)this;

		// read in children from the makefile
		if (!ReadInChildren(mr, BaseDir))
			AfxThrowFileException (CFileException::generic);

		g_pActiveProject = (CProject *)this;

		CProjTempConfigChange projTempConfigChange(this);

		// We are now in the post read section
		m_bPostMakeFileRead = TRUE;

		// reenable FileRegistry notifications before DepGraph calculations
		g_bInProjLoad = FALSE;

		SetPrompt(IDS_UPDATING_DEPENDENCIES); // truth in advertising

		projTempConfigChange.Reset();

		pProject = (CProject *)this;
		CString strProject;
		if (m_bConvertedDS4x)
		{
			CProject::InitProjectEnum();
			VERIFY(pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE));
		}
		do {
			CProjTempConfigChange projTempConfigChange(pProject);
			g_pActiveProject = pProject;

			// We are now in the post read section
			pProject->m_bPostMakeFileRead = TRUE;

			// custom build assignment (post-project read!)
			CBuildTool * pTool;
			VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_CustomBuild), (CBldSysCmp *&)pTool));
			CPtrList lstSelectTools;
			lstSelectTools.AddTail(pTool);

			// special build tool(pre-link/post-build steps)
			VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_SpecialBuild), (CBldSysCmp *&)pTool));
			lstSelectTools.AddTail(pTool);

			// perform some post-read target processing
			CString strTargetName;
			CTargetItem* pTarget;
			pProject->InitTargetEnum();
			while (pProject->NextTargetEnum(strTargetName, pTarget))
			{
				ConfigurationRecord * pcrTarget = pProject->ConfigRecordFromConfigName(strTargetName);
				projTempConfigChange.ChangeConfig(pcrTarget);

                // no longer necessary
				// try to assign a custom build tools
				// to both project-level and target files

				//
				// REVIEW(tomse); I added UnAssignActions and re-enabled AssignActions on the
				// project because everything but the 4.0 makfile conversion sniff test seemed to
				// work after changing the order of tools in CProjType(prjconfg.cpp).  I'm adding
				// a hack back, but it fixes a dogfood bug.
				//
				// assign to contained = TRUE
				CActionSlob::UnAssignActions(pProject, &lstSelectTools, (ConfigurationRecord  *)NULL, TRUE);
				CActionSlob::AssignActions(pProject, &lstSelectTools, (ConfigurationRecord  *)NULL, TRUE);

//				CActionSlob::UnAssignActions(pTarget, &lstSelectTools, (ConfigurationRecord  *)NULL, TRUE);
//				CActionSlob::AssignActions(pTarget, &lstSelectTools, (ConfigurationRecord  *)NULL, TRUE, TRUE);

		 		// inform the graph of this target that it is now stable
				g_buildengine.GetDepGraph(pcrTarget)->SetGraphMode(Graph_Stable);
				
				// is this makefile wanting to use MFC?
				if (!g_prjcompmgr.MFCIsInstalled())
				{
					// trying to use MFC?
					int fUseMFC;
					CProject * pProject = pTarget->GetProject();
					if (pProject->GetIntProp(P_ProjUseMFC, fUseMFC) == valid && fUseMFC)
					{
						// flag this error
						BOOL bOldGotUseMFCError = pProject->m_bGotUseMFCError;
						pProject->m_bGotUseMFCError = TRUE;

						if (!bOldGotUseMFCError && QuestionBox(IDS_MFC_NOT_INSTALLED, MB_YESNO) == IDNO)
							AfxThrowFileException (CFileException::generic);

						// best of luck!
						pProject->SetIntProp(P_ProjUseMFC, FALSE);
					}
				}
			}
		} while (m_bConvertedDS4x && ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL));

 	}
	CATCH (CException, e)
	{
		// reenable FileRegistry notifications
		g_bInProjLoad = FALSE;
		g_pActiveProject = (CProject *)this;
		m_bPostMakeFileRead = FALSE;
		if (pObject) delete (pObject);
		return FALSE;	// failure
	}
	END_CATCH

	g_pActiveProject = (CProject *)this;
	m_bPostMakeFileRead = FALSE;

	return TRUE;	// success
}

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::ReadMasterDepsLine(CMakDescBlk * pObject, const CDir & BaseDir)
{
	// special case: process master Deps line ALL:
	// for unsupported project types
	if (_tcsicmp(_T("ALL"), pObject->m_strTargets) != 0)
		return TRUE;

	BOOL retVal = TRUE;
	ConfigurationRecord * pcr = GetActiveConfig();
	CProjType * pprojtype = GetProjType();

	int i = 0, nMax = 1;
	
	TRY
	{
		if (m_cp == EndOfConfigs)
		{
			nMax = GetPropBagCount();
			pcr = (ConfigurationRecord *)m_ConfigArray[0];
			ASSERT_VALID(pcr);
			VERIFY(g_prjcompmgr.LookupProjTypeByName(pcr->GetOriginalTypeName(), pprojtype));
		}
		for (;;) // iterate through configs if necessary based on m_cp
		{
			if (!pprojtype->IsSupported())
			{
				FileRegHandle frh;
				CPath pt;
				CString str;
				const CString * pstrDeps = &(pObject->m_strDeps);
				int index = 0, len, nMaxIndex = pstrDeps->GetLength();
				while (index < nMaxIndex)
				{
					if (_istspace((*pstrDeps)[index]))
					{
						index++; // skip white
						continue;
					}
					str = pstrDeps->Mid(index);
					if (str[0]==_T('"'))
					{
						// strip quotes
						str = str.Mid(1);
						str = str.SpanExcluding(_T("\""));
						len = str.GetLength() + 2;	// two quotes!
					} 
					else 
					{
						str = str.SpanExcluding(_T(" \t\r\n"));
						len = str.GetLength() + 1;
					}

					// substitute for $(OUTDIR) macro if nessessary
					SubstOutDirMacro(str, pcr);
					
					if (!pt.CreateFromDirAndFilename(BaseDir, str))
						AfxThrowFileException (CFileException::generic);

#ifndef REFCOUNT_WORK
					if ((frh = g_FileRegistry.RegisterFile(&pt)) != (FileRegHandle)NULL)
#else
					if ((frh = CFileRegFile::GetFileHandle(pt)) != (FileRegHandle)NULL)
#endif
					{
						if (NULL == pcr->m_pTargetFiles )
							pcr->m_pTargetFiles = new CFileRegSet(1);
						VERIFY(pcr->m_pTargetFiles->AddRegHandle(frh));
#ifdef REFCOUNT_WORK
						frh->ReleaseFRHRef();
#endif
					}
					index += len;
				}
			}

			// repeat for next config, if necessary
			if (++i >= nMax)
				break;

			pcr = (ConfigurationRecord *)m_ConfigArray[i];
			ASSERT_VALID(pcr);
			VERIFY(g_prjcompmgr.LookupProjTypeByName(pcr->GetOriginalTypeName(), pprojtype));
		}
	}
	CATCH (CException, e)
	{
		retVal = FALSE;	// failure
	}
	END_CATCH

	return retVal;
}

int g_nProjTypesToWrite; // used in projtool.cpp

///////////////////////////////////////////////////////////////////////////////
BOOL CProject::WriteConfigurationHeader ( CMakFileWriter& mw )
{
//	Write out header to makefile which lists the configrations and will warn
//  then user if he doesn't specify one:

	CString str;
	CStringProp *pProp;
	int j,k;
	CMapStringToPtr mapTargTypes;
	const CPtrArray & ppcr = *GetConfigArray();
	j = m_ConfigArray.GetSize();

	TRY
	{
		if (!mw.IsMakefile())
		{
			void * pVoid;
			_TCHAR buf[256];
			POSITION pos;
			CProjType * pProjType;

			// Write list of all projtypes and UniqueId's (for compatibility)
			// N.B. we now depend on this to support reading unknown platforms
			for (k=0 ;k < j ; k++)
			{
				str = ((ConfigurationRecord *)ppcr[k])->GetOriginalTypeName();
				if (g_prjcompmgr.LookupProjTypeByName(str,pProjType))
				{
					// record each Projtype and (valid) UniqueId in use by this makefile
					if (pProjType->GetUniqueTypeId() && pProjType->GetUniquePlatformId())
						mapTargTypes.SetAt(str, (void *)pProjType->GetUniqueId());
				}
			}

			g_nProjTypesToWrite = mapTargTypes.GetCount();

			if (!mapTargTypes.IsEmpty()) // write all target types
			{
				pos = mapTargTypes.GetStartPosition();
				while (pos != NULL)
				{
					mapTargTypes.GetNextAssoc(pos, str, pVoid);
					_stprintf(buf,_T("TARGTYPE \"%s\" %#06x"), (LPCTSTR)str, (UINT)pVoid);
					mw.WriteComment(buf);	// Write target-type name & id
				}
				mw.EndLine ( );
			}
			mapTargTypes.RemoveAll();
		}

		CPath MakPath = *GetFilePath(); // REVIEW: get from actual path
		MakPath.ChangeExtension(".mak");

		if (mw.IsMakefile())
		{
			// Form string "!IF "$(CFG)" != ""
			// str = "\"$(CFG)\" == \"\"";
			str.LoadString ( IDS_CONFIG_DEFAULT_HEADER0 );
			mw.WriteDirective (CMakDirective::DTYP_IF, str);

			// Form string	CFG = DEBUG
			str.LoadString ( IDS_CONFIG_DEFAULT_HEADER1 );
			mw.WriteMacro (str, (const TCHAR *) m_strProjDefaultConfiguration);

			// Form string !MESSAGE No configuation specified Defaulting to configuration DEBUG
			MsgText ( str, IDS_CONFIG_DEFAULT_HEADER2,
					(const TCHAR *) m_strProjDefaultConfiguration);
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);

			mw.WriteDirective (CMakDirective::DTYP_ENDIF, NULL);
			mw.EndLine ();

			// Form string "!IF "$(CFG)" != "DEBUG" && "$(CFG)" != "RELEASE"
			str = _TEXT("\"$(CFG)\" != \"");
			for (k=0 ;k <j ; k++)
			{
				str += ((ConfigurationRecord *)ppcr[k])->GetConfigurationName ();
				if (k < j-1) str += _TEXT("\" && \"$(CFG)\" != \"");
			}
			str += _TEXT("\"");

			mw.WriteDirective (CMakDirective::DTYP_IF, str);

			// Invalid configuration "Ladeda" specified.
			str.LoadString ( IDS_CONFIG_HEADER0 );
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);
		}
		else
		{
			// Form string	CFG = DEBUG
			str.LoadString ( IDS_CONFIG_DEFAULT_HEADER1 );
			mw.WriteMacro (str, (const TCHAR *) m_strProjDefaultConfiguration);
			str.LoadString ( IDS_CONFIG_HEADER0_INT );
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);
			str.LoadString ( IDS_CONFIG_HEADER1_INT );
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, NULL);
			str.LoadString ( IDS_CONFIG_HEADER2_INT );
			str += MakPath.GetFileName();
			str += _T("\".");
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, NULL);
		}

		// You can specify a configuration when running NMAKE on this makefile
		str.LoadString ( IDS_CONFIG_HEADER1 );
		mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);

		// by defining the macro CFG on the command line.  For example:
		str.LoadString ( IDS_CONFIG_HEADER2 );
		mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);
		mw.WriteDirective (CMakDirective::DTYP_MESSAGE, NULL);

		// NMAKE /f "filename" CFG="DEBUG".
		CString strDefaultCfg = m_strProjDefaultConfiguration;
		MsgText ( str, IDS_CONFIG_HEADER3, MakPath.GetFileName(),
							 (const TCHAR *)strDefaultCfg);
		mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);
		mw.WriteDirective (CMakDirective::DTYP_MESSAGE, NULL);

		// Possible choices for configuration are:
		str.LoadString ( IDS_CONFIG_HEADER4 );
		mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str);
		mw.WriteDirective (CMakDirective::DTYP_MESSAGE, NULL);

		// "Ladeeda" (based on "Windows 32 bit exe")
		for (k=0 ;k <j ; k++)
		{
			pProp = (CStringProp *) ((ConfigurationRecord *)ppcr[k])->GetPropBag(CurrBag)->FindProp (P_ProjOriginalType);
			ASSERT (pProp);
			ASSERT (pProp->m_nType == string );
			CString strCfg = ((ConfigurationRecord *)ppcr[k])->GetConfigurationName();
			MsgText ( str, IDS_CONFIG_HEADER5,
							 (const TCHAR *) strCfg,
							 (const TCHAR *) pProp->m_strVal);
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str );
		}
		mw.WriteDirective (CMakDirective::DTYP_MESSAGE, NULL);

		if (mw.IsMakefile())
		{
			// !ERROR No configuration specified.
			str.LoadString ( IDS_CONFIG_HEADER6 );
			mw.WriteDirective (CMakDirective::DTYP_ERROR, str );

			// !ENDIF
			mw.WriteDirective (CMakDirective::DTYP_ENDIF, NULL);
			mw.EndLine ();

			// Write out hack for checking for existance of directories.
	 		// !IF "$(OS)" == "Windows_NT"
			str.LoadString ( IDS_OUTDIR_NULL );
			mw.WriteDirective (CMakDirective::DTYP_IF, str);

			// Write the macro for windows nt
			// NULL=
	 		CString strNull;
			str.LoadString ( IDS_NULL );
			mw.WriteMacro (str, (const TCHAR *)strNull);

			// !ELSE
			mw.WriteDirective (CMakDirective::DTYP_ELSE, NULL);
			
			// Write the win95 macro
			// NULL=nul
			strNull.LoadString ( IDS_WIN95_NULL );
			mw.WriteMacro (str, (const TCHAR *)strNull);

			// !ENDIF
			mw.WriteDirective (CMakDirective::DTYP_ENDIF, NULL);

#if 0	// moved to bldrfile.cpp
	 		// !IF "$(NO_EXTERNAL_DEPS)" != "1"
			mw.EndLine ();
			str = "\"$(NO_EXTERNAL_DEPS)\" != \"1\"";
			mw.WriteDirective (CMakDirective::DTYP_IF, str);

			CPath makPathDep = *GetFilePath(); // REVIEW: get from actual path
			makPathDep.ChangeExtension(".dep");
			str = makPathDep.GetFileName();
			str = "\"" + str + "\"";

			// !IF EXISTS("foo.dep")
			CString str2 = "EXISTS("; str2 += str; str2 += ")";
			mw.WriteDirective (CMakDirective::DTYP_IF, str2);

			// !INCLUDE "foo.dep"
			mw.WriteDirective (CMakDirective::DTYP_INCLUDE, str);

			// !ELSE
			mw.WriteDirective (CMakDirective::DTYP_ELSE, NULL);

			// !MESSAGE Warning: cannot find "devbld.dep"
			str2 = "Warning: cannot find " + str;
			mw.WriteDirective (CMakDirective::DTYP_MESSAGE, str2);

			mw.WriteDirective (CMakDirective::DTYP_ENDIF, NULL);
			mw.WriteDirective (CMakDirective::DTYP_ENDIF, NULL);
#endif

		}
		mw.EndLine ();

	}
	CATCH (CException, e)
	{
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::ReadConfigurationHeader  ( CMakFileReader& mr )
{

//	Look through the configuration header area and try to figure out what
//  configurations there and, along with there project type.  This function
//  leaves us in the last defined configuration:

	CMakDirective *pmd = NULL;
	const TCHAR *pc;
	TCHAR *pstart, *pend;
	CString str, strCfg, strBase, strTarget, strProjName;
	CMapStringToPtr mapTargTypes;
	UINT uniqueId;
	CString strDefaultConfig, strSupportedConfig;
	BOOL bSetDefaultConfig = FALSE;
	BOOL bFoundSupportedConfig = FALSE;
	BOOL bFoundUnsupportedConfig = FALSE;
	CPath pathProjFileName;
	CString strProjBaseName;
	CProjType * pSupportedProjType = NULL;
	
	pathProjFileName.CreateFromDirAndFilename(m_ProjDir, m_strProjItemName);
	pathProjFileName.GetBaseNameString(strProjBaseName);
	
	TRY
	{
		// Look for a message directive whose first non-blank is a quote:
		// directives:
		for (;;)
		{
			pmd = (CMakDirective *) mr.GetNextElement ();
			if ((((CMakMacro*)pmd)->IsKindOf ( RUNTIME_CLASS (CMakMacro)))
				&&
				(!((CMakMacro*)pmd)->m_strName.Compare("CFG")))
			{
				// set default config
				if (!m_bConvertedDS4x) // may not be valid if converting		
					m_strProjDefaultConfiguration = ((CMakMacro*)pmd)->m_strValue;
			}
			if (((CMakComment*)pmd)->IsKindOf ( RUNTIME_CLASS (CMakComment))
				&&
					(!((CMakComment*)pmd)->m_strText.Left(9).Compare(_T("TARGTYPE "))))
					{
						str = ((CMakComment*)pmd)->m_strText.Mid(9); // rest of line
						pstart = str.GetBuffer(1);

						if (GetQuotedString (pstart, pend))
						{
							*(pend++) = 0;	// nul terminate
							strTarget = pstart;	// target-type name
							mapTargTypes.SetAt(strTarget, (void *)_tcstoul(pend, NULL, 0));
						}
						else ASSERT(0);
						str.Empty();
					}
			if (pmd->IsKindOf ( RUNTIME_CLASS (CMakDirective))
				&&
				pmd->m_dtyp	== CMakDirective::DTYP_MESSAGE
				&&
				!pmd->m_strRemOfLine.IsEmpty ()
				)
			{
				pc = pmd->m_strRemOfLine;
				SkipWhite (pc);
              			if (*pc == _T('"'))  break;
			}
			if (pmd->IsKindOf ( RUNTIME_CLASS (CMakEndOfFile)))
				AfxThrowFileException (CFileException::generic);
			delete (pmd); pmd = NULL;
		}
		
		if (m_bConvertedVC20)
		{
			// come up with a name for this project
			const CPath* ppathProj = GetFilePath();
			CString strProjectName;
			ppathProj->GetBaseNameString(strProjectName);
 			SetTargetName(strProjectName);
		}
		
		BOOL bUsedThisProject = FALSE;
		CProject * pBestFitForThisProject = NULL;
		BOOL bFoundGoodMatch = FALSE;
		BOOL bDelConfigsPrompted = FALSE;
		// Try to read in configs until we see something that's not
		// a message directive.  Each config message line has the config
		// name in the first quoted string and the config orginal type
		// in the second string:
		do
		{
			if (pmd->m_strRemOfLine.GetLength() > 1 )
			{
				// Config name:
				pstart =  pmd->m_strRemOfLine.GetBuffer (1);
				if (!GetQuotedString (pstart, pend ))
					AfxThrowFileException (CFileException::generic);

				*pend = _T('\0');
				strCfg = pstart;
				CProject * pProject = (CProject *)this;
				
				if (m_bConvertedDS4x)
				{
					// if not the current project, create new one to match
					// Form the whole configuration name
					int cbLen = strCfg.GetLength();
					int nFirst = strCfg.Find(_T(" - "));
					ASSERT(nFirst != -1);
					if (nFirst < 1)
						AfxThrowFileException(CFileException::generic);

					// strip out project name for this config
					CString strTarget = strCfg.Left(nFirst);

					// make sure there wasn't already a project of ths name
					// in the workspace
					void * pProjID;
					if (g_pProjWksIFace->CanAddProject(strTarget) != S_OK)
					{
						g_bErrorPrompted = TRUE;
						{
							CProjTempProjectChange projTempProjectChange (NULL);
							MsgBox(Error, IDS_ERR_DUPE_PROJ);
						}
						AfxThrowArchiveException(CArchiveException::generic);
					}
					CPath pathProj; //, pathProjMak;
					pathProj.CreateFromDirAndFilename(GetWorkspaceDir(), strTarget);
					BOOL bDirExists = (pathProj.ExistsOnDisk() && (!FileExists(pathProj)));

					// If the project we are converting has the same name as the .mak
					// don't try to create the .dsp in the sub-dir even if one exists.
					BOOL bFoundMatchingMak = (strTarget.CompareNoCase(strProjBaseName)==0);
					if (bFoundMatchingMak)
					{
						bDirExists = FALSE;		// REVIEW: remove this test?
					}

					if (TRUE)
					{
						// this might be a subproject config so create a new one
						CString strProject = pathProj;

						// put project in subdir if it exists
						if (bDirExists)
						{
							strProject +=  _T('\\');
							strProject += strTarget;
							VERIFY(pathProj.Create(strProject));
						}
						pathProj.ChangeExtension(_T(BUILDER_EXT));
						// pathProjMak = pathProj; pathProjMak.ChangeExtension(".mak");
						BOOL bFound = FALSE;
						CProject::InitProjectEnum();
						ASSERT(!strTarget.IsEmpty());

						if (strTarget.CompareNoCase(strProjName)==0)
						{
							// matches the 'main' project
							bFound = TRUE;
						}
						else
						{
							// first see if we already have a project with this name
							while ((pProject = (CProject *)CProject::NextProjectEnum(strProject, FALSE)) != NULL)
							{
								if ((*(pProject->GetFilePath()) == pathProj) ||
									(strTarget.CompareNoCase(strProject)==0))
								{
									if (pProject->m_bConvertedDS4x)
									{
										bFound = TRUE;
										break;
									}
									else
									{
										// REVIEW
										g_bErrorPrompted = TRUE;
										CProjTempProjectChange projTempProjectChange (NULL);
										MsgBox(Error, IDS_ERR_DUPE_PROJ);
										AfxThrowFileException(CFileException::generic);
									}
								}
							}
						
							if (!bFound)
							{
								pProject = (CProject *)g_BldSysIFace.CreateBuilder(pathProj, FALSE, FALSE);
								ASSERT(pProject != NULL);
								if (!pProject)
								{
									AfxThrowFileException(CFileException::generic);
								}
	
								pProject->m_bConvertedDS4x = TRUE;
 								pProject->m_bProjMarkedForSave = TRUE;
								pProject->m_bProjConverted = TRUE;
								pProject->m_bProjHasNoOPTFile  = TRUE;			
								pProject->m_strProjDefaultConfiguration = strCfg;
								pProject->m_strProjStartupConfiguration.Empty();
								pProject->m_bProjectComplete = FALSE;  // not done yet!								
								pProject->SetTargetName(strTarget);
								if ((pBestFitForThisProject == NULL) || ((!bDirExists) && (!bFoundGoodMatch)) || bFoundMatchingMak)
								{
									bFoundGoodMatch = bFoundMatchingMak || !bDirExists;
									// worst case we just use the first one
									pBestFitForThisProject = pProject;
								}
							}
						}
					}
					else
					{
						ASSERT(0); // dead code
#if 0
						// just use this project
						bUsedThisProject = TRUE;
						strProjName = strTarget;  // save for later comparison
						SetTargetName(strTarget);
						pBestFitForThisProject = this;
						m_strProjStartupConfiguration.Empty();
						bSetDefaultConfig = FALSE;
						strSupportedConfig.Empty();
#endif
					}
					// REVIEW: any other tests necessary?
				}
				g_pActiveProject = pProject;
				if (!pProject->CreateConfig(strCfg))
					AfxThrowFileException(CFileException::generic);

				if (((!bSetDefaultConfig) && ((pProject==this) || (pProject==pBestFitForThisProject))) /* || (m_bConvertedDS4x && !bUsedThisProject) */) // if no valid CFG= read, use first one
				{
					strDefaultConfig = strCfg;
					bSetDefaultConfig = TRUE;
				}

				// Orginal config name:
				pstart = _tcsinc ( pend );
				if (!GetQuotedString (pstart, pend ))
								AfxThrowFileException (CFileException::generic);
				*pend = _T('\0');
			   	strBase = pstart;
				uniqueId = 0;

				CProjType * pProjType = NULL;
				if ((!g_prjcompmgr.LookupProjTypeByName (strBase, (CProjType *&) pProjType)) || (pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeUnknown))))
				{
					if ((!bDelConfigsPrompted) && (m_bConvertedVC20 || m_bConvertedDS4x))
					{
						CStringList lststrPlatforms;
						CString strPlatformName;
						strPlatformName.LoadString(IDS_V4_MACPMC_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);
						// strPlatformName.LoadString(IDS_V2_WIN32MIPS_PLATFORM);
						// lststrPlatforms.AddTail(strPlatformName);
						strPlatformName.LoadString(IDS_V4_MIPS_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);
						strPlatformName.LoadString(IDS_V2_MAC68K_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);
						strPlatformName.LoadString(IDS_V2_MACPPC_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);
						strPlatformName.LoadString(IDS_V4_PPC_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);

						// don't support Java in DevStudio anymore
						strPlatformName.LoadString(IDS_V5_JAVA_PLATFORM);
						lststrPlatforms.AddTail(strPlatformName);

						POSITION pos = lststrPlatforms.GetHeadPosition();
						while (pos != NULL)
						{
							strPlatformName = lststrPlatforms.GetNext(pos);
							int nLength = strPlatformName.GetLength();
							if (_tcsncmp((LPCTSTR)strPlatformName, (LPCTSTR)strBase, nLength)==0)
							{
								bDelConfigsPrompted = TRUE;
								CString strT, strMsg;
								int i;
								i = IDS_DISCARD_UNSUPPORTED;
								while (i < IDS_DISCARD_UNSUPPORTED_LAST)
								{
									strT.LoadString(i);
									strMsg += strT;
									i++;
								}
								if (g_pAutomationState->DisplayUI() && !g_bNoUI) //ShellOM:State
								{
									// append question
									strT.LoadString(IDS_DISCARD_UNSUPPORTED_LAST);
									strMsg += strT;

									CProjTempProjectChange projTempProjectChange (NULL);
									if (MsgBox (Question, strMsg, MB_YESNO) != IDYES)
									{
										g_bErrorPrompted = TRUE;
										AfxThrowFileException (CFileException::generic);
									}
								}
								else if (theApp.m_bInvokedCommandLine)
								{
									theApp.WriteLog(strMsg, TRUE);
								}
								break;
							}
						}
					}
					if (pProjType==NULL || !pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeUnknown)))
					{
						// Unrecognized ProjType string so try mapping by UniqueId
						if (!mapTargTypes.Lookup(strBase, (void * &)uniqueId) ||
							!g_prjcompmgr.LookupProjTypeByUniqueId(uniqueId, (CProjType *&)pProjType))
						{
							// try to get the platform from the unique id
							CPlatform * pPlatform = NULL;
							if ((uniqueId >> 8) & 255)
								g_prjcompmgr.LookupPlatformByUniqueId(((uniqueId >> 8) & 255), pPlatform);

							/*
							// [matthewt] 05/11/95
							// we will have FORTRAN project types for the Intelx86 platform
							// so we can't do this for post v2.x
							//
							if (pPlatform != (CPlatform *)NULL &&
								pPlatform->IsSupported())
							{
								// Unknown application for supported platform, so give error
								g_bErrorPrompted = TRUE;
								{
									CProjTempProjectChange projTempProjectChange (NULL);
									MsgBox (
									Information,
									MsgText (
											str,
											IDS_MAKEFILE_UNKNOWN_BASE,
											(const TCHAR *) strBase,
											(const TCHAR *) strCfg
											)
									);
								}
								AfxThrowFileException (CFileException::generic);
							}
							else
							*/

							{
								//
						 		// unknown platform and/or project type so create
								// it to avoid trashing makefile
								//

								// derive platfrom and type names from available information
								int index;

								// 1) By default, strip up to first whitespace or last ')'
								if (((index = strBase.Find(_T(')')))) == -1)
									VERIFY((index = strBase.FindOneOf(_T(" \t"))) > 0);
								else
									index++;

								CString strType = strBase.Mid(index+1); // default

	#if 0
								// 2) Also look up known application types, and compare against end of string
								int newindex, savedindex = 9999;
								const CStringList * pTypeList = g_prjcompmgr.GetListOfTypes();
								POSITION pos = pTypeList->GetHeadPosition();
								while (pos != NULL)
								{
									newindex = strType.Find(pTypeList->GetNext(pos));
									if ((newindex != -1) && (newindex < savedindex))
										savedindex = newindex;
								}
								if ((savedindex != 0) && (savedindex != 9999))
								{
									index += savedindex;
									strType = strBase.Mid(index+1);
								}
	#endif

								if (pPlatform==NULL)
								{
									CString strPlatform = strBase.Left(index);
									pPlatform = new CPlatform(strPlatform, (uniqueId>>8) & 255);
									// Register dynamic platform so deleted on exit
									g_prjcompmgr.RegisterUnkProjObj(pPlatform);
								}
								pProjType = new CProjTypeUnknown(strType, uniqueId & 255, pPlatform);
								// Register dynamic projtype so deleted on exit
								g_prjcompmgr.RegisterUnkProjObj(pProjType);

								// update name in case it changed
								strBase = *pProjType->GetName();
							}
						}
						else
						{
							// must update to new (supported) targtype name
							// ignore id if either byte is 0
							ASSERT(uniqueId & 255); ASSERT(uniqueId>>8);
							strBase = *pProjType->GetName();
						}
					}
				}
				BOOL bIsExternalTarget = (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)));
				if ((m_bConvertedDS5x) && (!bIsExternalTarget)) // must allow makefile projects still
				{
					// don't support Java in DevStudio anymore
					CString strPlatformName;
					strPlatformName.LoadString(IDS_V5_JAVA_PLATFORM);
					int nLength = strPlatformName.GetLength();
					if (_tcsncmp((LPCTSTR)strPlatformName, (LPCTSTR)strBase, nLength)==0)
					{
						CString strT, strMsg;
						int i = IDS_DISCARD_JAVA;
						while (i <= IDS_DISCARD_JAVA_LAST)
						{
							strT.LoadString(i);
							strMsg += strT;
							i++;
						}
						CProjTempProjectChange projTempProjectChange (NULL);
						UINT mbButtons = (g_pAutomationState->DisplayUI() && !g_bNoUI) ? MB_OKCANCEL : MB_OK;
						if (MsgBox (Error, strMsg, mbButtons) == IDCANCEL)
							g_bConversionCanceled = TRUE;
						else
							g_bBadConversion = TRUE;

						g_bErrorPrompted = TRUE;
						AfxThrowFileException (CFileException::generic);
					}
				}
				// note if we read at least one (un)supported target
				if (pProjType->IsSupported())
				{
					bFoundSupportedConfig = TRUE;
					
					if (pSupportedProjType == NULL)
						pSupportedProjType = pProjType;

					// note the first supported config (default, if supported)
					if (((pProject == this) || (pProject==pBestFitForThisProject)) && ((strSupportedConfig.IsEmpty()) || (strCfg==m_strProjDefaultConfiguration)))
						strSupportedConfig = strCfg;
				}
				else
				{
					bFoundUnsupportedConfig = TRUE;
				}

				// note the first Primary platform we encounter (if any)
				if (pProjType->GetPlatform()->IsPrimaryPlatform() &&
					(pProject->m_strProjStartupConfiguration.IsEmpty() ||	strCfg == pProject->m_strProjDefaultConfiguration))
				{
					pProject->m_strProjStartupConfiguration = strCfg;
				}

				// make this configuration active
				pProject->SetStrProp (P_ProjOriginalType, strBase);
 				pProject->SetStrProp (P_ProjActiveConfiguration, strCfg);
			}

			delete (pmd); pmd = NULL;
			VERIFY (pmd = (CMakDirective *) mr.GetNextElement ());

		} while (pmd->IsKindOf ( RUNTIME_CLASS (CMakDirective)) &&
				 pmd->m_dtyp == CMakDirective::DTYP_MESSAGE);

		if (m_bConvertedDS4x && !bUsedThisProject)
		{
			if (!pBestFitForThisProject)
			{
				ASSERT(0);
				AfxThrowFileException(CFileException::generic);
			}
			strSupportedConfig.Empty();
			strDefaultConfig = pBestFitForThisProject->m_strProjDefaultConfiguration;
			SetTargetName(pBestFitForThisProject->GetTargetName());
			// copy pBestFitForThisProject to this and delete
			const CPtrArray & ppcr = *pBestFitForThisProject->GetConfigArray();
			ConfigurationRecord * pcr;

			{
				CProjTempConfigChange projTempConfigChange(pBestFitForThisProject);

				CString strConfig, strType;
				int ccr = ppcr.GetSize();
				for (int icr = 0; icr < ccr; icr++)
				{
					pcr = (ConfigurationRecord *)ppcr[icr];
					projTempConfigChange.ChangeConfig(pcr);
					strConfig = pcr->GetConfigurationName();
			
					if ((!CreateConfig(strConfig)) || (pBestFitForThisProject->GetStrProp(P_ProjOriginalType, strType)!=valid))
						AfxThrowFileException(CFileException::generic);
					// make this configuration active
					SetStrProp (P_ProjOriginalType, strType);
 					SetStrProp (P_ProjActiveConfiguration, strConfig);

					if (strSupportedConfig.IsEmpty() && m_pActiveConfig->IsSupported())
						strSupportedConfig = strConfig;

				}
			}
			pBestFitForThisProject->m_bConvertedDS4x = FALSE;
			delete pBestFitForThisProject;
		}

		// make sure we saw at least one projtype we can support
		if (!bFoundSupportedConfig)
		{
			ASSERT(bFoundUnsupportedConfig);
			m_bProjIsSupported = FALSE;
			CProjTempProjectChange projTempProjectChange (NULL);
			MsgBox(Information, IDS_MAKEFILE_NO_KNOWN_TARGETS);
		}
#if 0	// this is too cumbersome, since all samples now contain unknown targs
		else if (bFoundUnsupportedConfig)
		{
			MsgBox(Information, IDS_MAKEFILE_UNKNOWN_TARGETS);
		}
#endif

		// Last things are the !ERROR and the !ENDIF.  Don't need them, so
		// skip unitl we hit comments:
		while (!pmd->IsKindOf ( RUNTIME_CLASS (CMakComment))
				&&
			   !pmd->IsKindOf ( RUNTIME_CLASS (CMakEndOfFile)))
		{
			delete (pmd); pmd = NULL;
			pmd = (CMakDirective *) mr.GetNextElement ();
		}
		// Put the comment back:
		mr.UngetElement ( pmd );

		// valid CFG= if read, else use default
		if (m_strProjDefaultConfiguration.IsEmpty() ||
			(!ConfigRecordFromConfigName(m_strProjDefaultConfiguration)))
		{
			if (strDefaultConfig.IsEmpty())
				m_strProjDefaultConfiguration = strSupportedConfig;
			else
				m_strProjDefaultConfiguration = strDefaultConfig;
			ASSERT(ConfigRecordFromConfigName(m_strProjDefaultConfiguration));
		}

		if (m_strProjStartupConfiguration.IsEmpty())
		{
			m_strProjStartupConfiguration = strSupportedConfig;
			// could still be empty; use m_strProjDefaultConfiguration if so
		}
	}
	CATCH (CException, e)
	{
		g_pActiveProject = (CProject *)this;
		strBase.Empty(); strCfg.Empty(); str.Empty(); strTarget.Empty();
		strDefaultConfig.Empty(); strSupportedConfig.Empty();
		mapTargTypes.RemoveAll();
		if (pmd) delete (pmd);
		return FALSE;
	}
	END_CATCH
	g_pActiveProject = (CProject *)this;
	mapTargTypes.RemoveAll();
	ASSERT (bSetDefaultConfig);
	ASSERT (GetActiveConfig());
	ASSERT (!m_ConfigMap.IsEmpty());
	ASSERT (m_ConfigArray.GetSize());
	ASSERT (m_ConfigArray.GetSize()==m_ConfigMap.GetCount());
	ASSERT_VALID (this);
	return TRUE;
}

static FileRegHandle frhCustom = NULL;
///////////////////////////////////////////////////////////////////////////////
// Filter function for writing the ALL dependency line in the makefile.
// If you don't want a target to appear on this line here is the place to
// filter it out.
BOOL FilterMasterDepsLine ( DWORD /* dw */, FileRegHandle frh)
{
	// check for custom step for custom appwiz, quick fix
	// if the location are not standard such as Template, then, it won't write out macro
	CPath * pPath = (CPath *)g_FileRegistry.GetRegEntry(frh)->GetFilePath();
	CProject *pProject = (CProject *)g_BldSysIFace.GetActiveBuilder();
	ASSERT(pPath);
	
	if (_tcsicmp(pPath->GetExtension(), _TEXT(".awx")) == 0)
	{
		CString strOut;
		CString strCustomOutSpec;
		const CPtrArray & ppcr = *pProject->GetConfigArray();
		ConfigurationRecord * pcr;

		CProjTempConfigChange projTempConfigChange(pProject);

		int ccr = ppcr.GetSize();
		{
			for (int icr = 0; icr < ccr; icr++)
			{
				pcr = (ConfigurationRecord *)ppcr[icr];
				projTempConfigChange.ChangeConfig(pcr);
				pProject->GetStrProp(P_CustomOutputSpec, strCustomOutSpec);
				if (!strCustomOutSpec.IsEmpty())
				{
					int nLen = _tcslen(strCustomOutSpec);
					TCHAR *tcsStr = _tcsdec( strCustomOutSpec, (const TCHAR *)strCustomOutSpec + nLen );
					if( *tcsStr == _TCHAR('\t') ) {
						ASSERT( nLen > 1 );
						strCustomOutSpec = strCustomOutSpec.Left( nLen-1 );
					}

					CActionSlobList * pActions = pcr->GetActionList();
					CActionSlob * pAction = (CActionSlob *)pActions->GetHead();
					ExpandMacros(&strOut, strCustomOutSpec, pAction);
					break;
				}
 			}
		}

		if (strOut.CompareNoCase(pPath->GetFullPath()) == 0)
		{
			frhCustom = frh;
			return FALSE;
		}
	}
	else if (_tcsicmp(pPath->GetExtension(), _TEXT(".trg")) == 0)
	{
		int i;
		VERIFY(pProject->GetIntProp(P_DeferredMecr, i));
		if (i != dabNotDeferred)
		{
			return FALSE;
		}
	}


	// All other files are ok.
	return TRUE;
}

int __cdecl CmpCStrings(const void * pstr1, const void * pstr2);

BOOL CProject::WriteMasterDepsLine(CMakFileWriter & mw, const CDir & BaseDir, BOOL bPostBuildDep)
{
	CString str;  // the all line
	CString strCustomOutSpec;
	CStringArray strOutArray;

	TRY
	{
		CObList lstItem; lstItem.AddHead(this);

		// write the ALL : targets .MAK line
		// FUTURE: given targets that are in the $(INTDIR) directory
		// this will not work, we prepend them here with $(OUTDIR)
		// , we pass in the project object. This is fine for V2
		// 'cos the targets are .bsc and .exe/.lib/.dll

		CProjType *pProjType = GetProjType();
		if (pProjType && pProjType->GetUniqueTypeId() == CProjType::exttarget) {
			CFileRegSet * pregset = GetTargetPaths();
			MakeQuotedString(
							 pregset,
							 str, &BaseDir,
							 TRUE, FilterMasterDepsLine, NULL,
							 NULL, TRUE,		// only first item
							 (const CObList *)&lstItem
							,FALSE	// must not be sorted!!
							);

		} else {
			CFileRegSet setTargets;
			DWORD dw = (DWORD)&setTargets;
			g_buildengine.GetDepGraph(GetActiveConfig())->PerformOperation(CFileDepGraph::GetPrimaryTargetNoCustom, dw);
			
			CMapStringToPtr mapStrCustomOut;
			DWORD dw2=(DWORD)&mapStrCustomOut;
			g_buildengine.GetDepGraph(GetActiveConfig())->PerformOperation(CFileDepGraph::GetCustomOutput, dw2);
	
			MakeQuotedString(
							 &setTargets,
							 str, &BaseDir,
							 TRUE, FilterMasterDepsLine, NULL,
							 NULL, FALSE,		// all items
							 (const CObList *)&lstItem
							,FALSE	// must not be sorted!!
							);
			if (frhCustom)
			{
				CProject *pProject = g_pActiveProject;
				const CPtrArray & ppcr = *pProject->GetConfigArray();
	
				ConfigurationRecord * pcr;
				CProjTempConfigChange projTempConfigChange(pProject);
				int ccr = ppcr.GetSize();
	
				{
					for (int icr = 0; icr < ccr; icr++)
					{
						pcr = (ConfigurationRecord *)ppcr[icr];
						projTempConfigChange.ChangeConfig(pcr);
						pProject->GetStrProp(P_CustomOutputSpec, strCustomOutSpec);
						if (!strCustomOutSpec.IsEmpty())
							break;
					}
				}

				BOOL bAlreadyQuoted = (strCustomOutSpec[0] == _T('"'));
				LPCTSTR pch = strCustomOutSpec;
				if (bAlreadyQuoted) pch++;
				const TCHAR c = *pch;
				BOOL bMakeRel = ((c != _T('\\') && c != _T('/') && (!(c == _T('.') && pch[1] == _T('\\'))) && c != _T('$') &&
					(!IsDBCSLeadByte(c) && (pch[1] != _T(':')))) || (IsDBCSLeadByte(c)));
//					(!(!IsDBCSLeadByte(c)) && (pch[1] == _T(':')))) || (IsDBCSLeadByte(c)));
				if (bMakeRel && bAlreadyQuoted)
				{
					strCustomOutSpec = _T("\".\\") + strCustomOutSpec.Mid(1);
				}
				else
				{
					if (bMakeRel)
						strCustomOutSpec = _T(".\\") + strCustomOutSpec;
					// quote if not already
					if (!bAlreadyQuoted)
						strCustomOutSpec = _T('\"') + strCustomOutSpec + _T('\"');
				}

				str += _T(' ');
				str += strCustomOutSpec;
			}

			POSITION pos;
			pos = mapStrCustomOut.GetStartPosition();
			while ( pos != (POSITION)NULL)
			{
				CString strCustomOut;
				void *end;
				mapStrCustomOut.GetNextAssoc(pos, strCustomOut, end);
				strOutArray.Add(strCustomOut);
			}
			qsort(strOutArray.GetData(), strOutArray.GetSize(), sizeof(CString *), CmpCStrings);
			
			int i;
			for( i=0; i<strOutArray.GetSize();i++)
			{
				CString strCustomOut;
				strCustomOut = strOutArray.GetAt(i);

				// custom build steps on files go at the front.
				// custom steps on outputs go at the back
				void *end;
				mapStrCustomOut.Lookup( strCustomOut, end);
				BOOL bAlreadyQuoted = (strCustomOut[0] == _T('"'));
				LPCTSTR pch = strCustomOut;
				if (bAlreadyQuoted) pch++;
				TCHAR c = *pch;
				BOOL bMakeRel = ((c != _T('\\') && c != _T('/') && !(c == _T('.') ) && c != _T('$') &&
					(!IsDBCSLeadByte(c) && (pch[1] != _T(':')))) || (IsDBCSLeadByte(c)));
//					(!(!IsDBCSLeadByte(c)) && (pch[1] == _T(':')))) || (IsDBCSLeadByte(c)));
				if (bMakeRel && bAlreadyQuoted)
				{
					strCustomOut = _T("\".\\") + strCustomOut.Mid(1);
				}
				else
				{
					if (bMakeRel)
						strCustomOut = _T(".\\") + strCustomOut;
					// quote if not already
					if (!bAlreadyQuoted)
						strCustomOut = _T('\"') + strCustomOut + _T('\"');
				}

				if( (BOOL)end ){
					str += _T(' ');
					str += strCustomOut;
				} else {

					str = strCustomOut + _T(' ') + str;
				}
			}
		}

		// If one of the ALL dependencies is built by a custom build
		// rule, then we need to write out any macros used by the
		// custom build rule (since the macros are used to specify the
		// dependency).
		WriteCustomBuildMacros(mw, str);


		// add in any per-target dependencies
		CObList list;
		FlattenSubtree(list, flt_Normal | flt_ExcludeGroups | flt_RespectItemExclude | 
						flt_ExcludeDependencies | flt_RespectTargetExclude);

		CString strNoDeps = str;
		BOOL bDeps = FALSE;
		POSITION pos = list.GetHeadPosition();
		CProjectDependency* pProjDep;
		while (pos != NULL)
		{
			pProjDep = (CProjectDependency *)list.GetNext(pos);
			if (pProjDep->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
			{
				// Add to the master deps line
                ConfigurationRecord * pcrProjDep = pProjDep->GetTargetConfig();

                if (pcrProjDep != NULL)
				    str = _T('"') + pcrProjDep->GetConfigurationName() + _T("\" ") + str;

				bDeps = TRUE;
			}
		}
		if ( GetProjType()->IsSupported() ){

			if (!bPostBuildDep)
			{
				if (bDeps)
				{
					CString strIf;
					strIf = _TEXT("\r\n!IF \"$(RECURSE)\" == \"0\" ");
					mw.WriteString(strIf);
					mw.WriteDesc(_TEXT ("ALL"), strNoDeps);
					strIf = _TEXT("\r\n!ELSE ");
					mw.WriteString(strIf);
					mw.WriteDesc(_TEXT ("ALL"), str);
					strIf = _TEXT("\r\n!ENDIF ");
					mw.WriteString(strIf);
					mw.EndLine();
				}
				else
				{
 					ASSERT(str == strNoDeps);
					mw.WriteDesc(_TEXT ("ALL"), str);
					mw.EndLine();
				}
			}
			else
				mw.WriteDesc(_TEXT ("$(DS_POSTBUILD_DEP)"), str);

			// write the CLEAN : line
			if (!bPostBuildDep)
			{
				CFileRegSet setOutputs;
				DWORD dw = (DWORD)&setOutputs;
				g_buildengine.GetDepGraph(GetActiveConfig())->PerformOperation(CFileDepGraph::GetAllOutputExceptCustom, dw);

				CObList fileItems;
				CActionSlobList lstActions;
				CProjItem * pItem = this;
				fileItems.AddHead(this); // CProject at head defines ActiveConfig

				FileRegHandle frh;
				setOutputs.InitFrhEnum();
				while ((frh = setOutputs.NextFrh()) != (FileRegHandle)NULL)
				{
					if ((g_buildengine.GetDepGraph(GetActiveConfig())->RetrieveOutputActions(lstActions, g_DummyEC, frh)==CMD_Complete) && (lstActions.GetCount() >= 1))
					{
						// okay for this to be NULL
						pItem = ((CActionSlob *)lstActions.GetHead())->Item();
					}
					else
					{
						pItem = NULL;
					}
					fileItems.AddTail(pItem); // must always add something

#ifdef REFCOUNT_WORK
					frh->ReleaseFRHRef();
#endif
				}

				if (mw.IsMakefile())
				{
					// initialise our string
					str = _TEXT("\r\n\t-@erase ");

					// get a quoted string
					MakeQuotedString(
									 &setOutputs,
									 str, &BaseDir,
									 TRUE, FilterMasterDepsLine, NULL,
									 _TEXT("\r\n\t-@erase "), FALSE	// all items
									,&fileItems
									,TRUE // sorted
									);

					if (frhCustom)
					{
						frhCustom = NULL;
						BOOL bQuote = (strCustomOutSpec[0] != _T('\"'));
						str += _TEXT("\r\n\t-@erase ");
						if (bQuote)
							str += _TEXT('\"');
						str += strCustomOutSpec;
						if (bQuote)
							str += _TEXT('\"');
					}
					
				    int i;
					for( i=0; i<strOutArray.GetSize();i++)
					{
						CString strCustomOut;
						strCustomOut = strOutArray.GetAt(i);

						BOOL bQuote = (strCustomOut[0] != _T('\"'));
						str += _TEXT("\r\n\t-@erase ");
						if (bQuote)
							str += _TEXT('\"');
						str += strCustomOut;
						if (bQuote)
							str += _TEXT('\"');
					}

					POSITION pos = list.GetHeadPosition();
					CProjectDependency* pProjDep;
					if( bDeps ){
						CString strHead;
						strHead = _TEXT("\r\n!IF \"$(RECURSE)\" == \"1\" ");
						strHead += _TEXT("\r\nCLEAN :");
						while (pos != NULL)
						{
							pProjDep = (CProjectDependency *)list.GetNext(pos);
							if (pProjDep->IsKindOf(RUNTIME_CLASS(CProjectDependency)))
							{
								// Add to the master deps line
								ConfigurationRecord * pcrProjDep = pProjDep->GetTargetConfig();
	
								if (pcrProjDep != NULL)
									strHead += _T("\"") + pcrProjDep->GetConfigurationName() + _T("CLEAN\" ");
							}
						}
						strHead += _TEXT("\r\n!ELSE ");
						strHead += _TEXT("\r\nCLEAN :");
						strHead += _TEXT("\r\n!ENDIF ");
						str = strHead + str +_TEXT("\r\n");
					}
					else {
						str = _TEXT("\r\nCLEAN :") + str +_TEXT("\r\n");
					}
					mw.WriteString(str);
				}
			}
		}

		if (!bPostBuildDep)
			mw.EndLine();
	}
	CATCH (CException, e)
	{
		return FALSE;	// failure
	}
	END_CATCH

	return TRUE;	// success
}
///////////////////////////////////////////////////////////////////////////////
void SkipInitialWSpace(CString & strSrc, CString & strDest)
{
	// strip initial whitespace
	int cchWhiteSpace = 0;
	TCHAR * pch = (TCHAR *)(const char *)strSrc; TCHAR ch = *pch;
	while (ch != _T('\0'))
	{
		// is this whitespace?
		if (ch != _T(' ') && ch != _T('\t') &&
			ch != _T('\r') && ch != _T('\n')) break;

		cchWhiteSpace += _tclen(pch);
		ch = *(pch + cchWhiteSpace);
	}

	strDest = (TCHAR *)(const char *)strSrc + cchWhiteSpace;
}
/////////////////////////////////////////////////////////////////////////////////
void GetFirstFile (CString & strSrc, CString & strFirstFile, CString & strRemainder)
{
	// get rid of white space first
	CString	strTemp ;
	SkipInitialWSpace (strSrc, strTemp) ;
	if (!strTemp.IsEmpty() && strTemp[0]==_T('\"')) // For NTFS command args, need to handled quoted names
	{
	   	strFirstFile = _T('\"') + strTemp.Mid(1).SpanExcluding(_T("\"")) + _T('\"');
		BOOL bBatchFile = (strFirstFile.Find(_TEXT(".bat")) != -1) ||
						  (strFirstFile.Find(_TEXT(".cmd")) != -1);
		if (strFirstFile.CompareNoCase(_TEXT("\"\""))==0)
		{
			bBatchFile = (strTemp.Find(_TEXT(".bat")) != -1) ||
						  (strTemp.Find(_TEXT(".cmd")) != -1);
		}
		if (bBatchFile && (strTemp.GetAt(strTemp.GetLength()-1) == _T('\"')))
		{
			// we are looking at batch file, we need to take the whole command
			strFirstFile = strTemp;
		}
	}
	else
		strFirstFile = strTemp.SpanExcluding (_TEXT(" \r\t\n")) ;
	strRemainder = strTemp.Mid(strFirstFile.GetLength());
}
///////////////////////////////////////////////////////////////////////////////
GPT CProject::GetIntProp(UINT idProp, int& val)
{
	// If this isn't a prop we're interested in, just
	// return what our parent does.
	if (idProp != P_NoDeferredBscmake &&
		idProp != P_DeferredMecr &&
		idProp != P_Java_DebugUsing &&
		idProp != P_Java_ParamSource &&
		idProp != P_IPkgProject &&
#ifdef VB_MAKEFILES
		idProp != P_Proj_IsVB &&
#endif
		idProp != P_Java_DebugStandalone)
		return CProjContainer::GetIntProp(idProp, val);

	// UNDONE: this is much to slow
	// need to pull this into CProject!!!

	if (idProp == P_IPkgProject)
	{
		IBSProject *pBSProj = GetInterface();
		COleRef<IPkgProject> pPkgProj;
		pBSProj->QueryInterface(IID_IPkgProject, (void **)&pPkgProj);
		pBSProj->Release();
		val = (int)(IPkgProject *)pPkgProj; // REVIEW: refcount?
		return valid;
	}

#ifdef VB_MAKEFILES
	if ( idProp == P_Proj_IsVB ){
		val = m_bVB;
		return valid;
	}
#endif

	// See if this is in our prop bag.
	GPT gpt = CProjContainer::GetIntProp(idProp, val);

	// Java: we only want to check for specific Java properties if this is a Java project.

	// for EXE projects, before attempting to get the current platform, make sure the
	// platform is set; it's possible for GetStrProp to be called before P_ExtOpts_Platform is set.
	// So, if we don't know the platform, assume it's not Java.

	CString strDummyPlatform;
	if (!m_bProjIsExe || (m_bProjIsExe && GetStrProp(P_ExtOpts_Platform, strDummyPlatform) == valid))
	{

		// only check Java-specific properties if this is a Java project
		if (GetCurrentPlatform()->GetUniqueId() == java)
		{

			// do we want to fake P_Java_DebugUsing?
			if (gpt == invalid && idProp == P_Java_DebugUsing)
			{
				// if debug app using is not in our prop bag,
				// default to debug app using browser if a browser name is specified
				// otherwise default to debug using stand-alone interpreter
				CString strBrowser;
				GetStrProp(P_Java_Browser, strBrowser);
				val = strBrowser.IsEmpty() ? Java_DebugUsing_Standalone : Java_DebugUsing_Browser;
				return valid;
			}

			// do we want to fake P_Java_ParamSource?
			if (gpt == invalid && idProp == P_Java_ParamSource)
			{
				// if the param source is not in our prop bag,
				// default to HTML page, if one exists; otherwise, default to user params

				// first, set the param source to be the HTML page
				SetIntProp(P_Java_ParamSource, Java_ParamSource_HTMLPage);

				// get the HTML page
				CString strHTMLPage;
				GetStrProp(P_Java_HTMLPage, strHTMLPage);
				val = Java_ParamSource_HTMLPage;

				// if the HTML page is empty, set the param source to be the param grid (user)
				if (strHTMLPage.IsEmpty()) {

					// set the param source
					SetIntProp(P_Java_ParamSource, Java_ParamSource_User);
					val = Java_ParamSource_User;
				}

				return valid;
			}

			// do we want to fake P_Java_DebugStandalone?
			if (gpt == invalid && idProp == P_Java_DebugStandalone)
			{
				// default to application debugging
				val = Java_DebugStandalone_Application;
				return valid;
			}

		}
	}

	// If the return value wasn't 'valid', the prop isn't
	// in the prop bag (only place it could be).  Return
	// 0 by default, meaning that BSCMAKEs are NOT deferred.
	if (gpt != valid)
		val = 0;

	return valid;
}
///////////////////////////////////////////////////////////////////////////////
GPT CProject::GetStrProp(UINT idProp, CString& val)
{
	if (idProp == P_ProjSccProjName) {
		val = m_strProjSccProjName;
		return valid;
	}
	else if (idProp == P_ProjSccRelLocalPath) {
		val = m_strProjSccRelLocalPath;
		return valid;
	}
#ifdef VB_MAKEFILES
	else if (idProp == P_VBProjName) {
		if( !m_bVB )
			return invalid;

		val = m_strVBProjFile;
		return valid;
	}
#endif
//	else if (idProp == P_ProjSccProjAux) {
//		val = m_strProjSccProjAux;
//		return valid;
//	}
	else if (idProp == P_ProjItemFullPath)
	{
		const CPath * pPath = GetFilePath();

		if (pPath != NULL)
		{
			val = pPath->GetFullPath();
			return valid;
		}
		return invalid;
	}
	else if (idProp == P_ProjItemDate)
	{
		const CPath *pPath = GetFilePath();
		if (pPath != NULL)
		{
#ifndef REFCOUNT_WORK
			FileRegHandle frh = g_FileRegistry.LookupFile(*pPath);
#else
			FileRegHandle frh = CFileRegFile::LookupFileHandleByName(*pPath);
#endif
			if (frh != NULL)
			{
				FILETIME ft;
				CTime time;

				if (g_FileRegistry.GetRegEntry(frh)->GetFileTime(ft))
				{
					time = ft;
					CString strDate = theApp.m_CPLReg.Format(time, DATE_ALL);
					CString strTime = theApp.m_CPLReg.Format(time, TIME_ALL);
					val = strTime + _TEXT(" ") + strDate;
				}
				else
					VERIFY(val.LoadString(IDS_PROJ_TRG_NONEXISTANT));

#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
				return valid;
			}
		}
		return invalid;
	}
	else if ((m_optbeh & OBShowMacro) &&
			((idProp==P_OutDirs_Intermediate) || (idProp==P_OutDirs_Target)))
		{
			return (GetOutDirString(val, idProp)) ? valid : invalid;
		}
	else if (m_bProjIsExe &&
		 	 (idProp == P_ExtOpts_CmdLine || idProp == P_ExtOpts_RebuildOpt)
			)
	{
		// These props aren't valid for an external "EXE" makefile.
		return invalid;
	}

	// At this point, we're only interested in a couple of props.  If
	// this isn't one of those, return what our base class does.
	if (idProp != P_Caller && 
		idProp != P_PromptForDlls &&
		idProp != P_WorkingDirectory &&
		idProp != P_Args && 
		idProp != P_RemoteTarget &&
        idProp != P_Proj_Targ &&
        idProp != P_ExtOpts_Targ &&
		idProp != P_Java_ClassFileName &&
		idProp != P_Java_Browser &&
		idProp != P_Java_Standalone &&
		idProp != P_Java_HTMLPage &&
		idProp != P_Java_TempHTMLPage &&
		idProp != P_Java_Args &&
		idProp != P_Java_HTMLArgs &&
		idProp != P_Java_StandaloneArgs
	   )
		return CProjContainer::GetStrProp(idProp, val);

	// See if this is in our prop bag.
	GPT gpt = CProjContainer::GetStrProp(idProp, val);

	// do we want to fake P_ExtOpts_Targ/P_Proj_Targ?
    if (gpt == invalid && (idProp == P_Proj_Targ || idProp == P_ExtOpts_Targ))
    {
        CPath TargetPath = *GetFilePath();
        TargetPath.ChangeExtension(_T(".exe"));
        val = TargetPath.GetFileName();
        return valid;
    }

	// do we want to fake P_Caller?
	//
	// * internal project *
	// -> shouldn't happen to * exe project *
	// This is expensive for them 'cos we hit the disk to
	// look at the executable in GetTargetAttributes().
	// I figure its more important to track the internal project
	// target (this can change more with output directories etc.)
	//
	// o pick the target name if .EXE
	if (gpt == invalid && idProp == P_Caller)
	{
		ASSERT(!m_bProjIsExe);

		// HACK - by default, set this check box
		int nVal;
		GPT gpt = CProjContainer::GetIntProp(P_PromptForDlls, nVal);
		if (gpt == invalid) {
 			CProjContainer::SetIntProp(P_PromptForDlls, 1);
		}

		int iAttrib = GetTargetAttributes();

		// only use the target if we think it is an .EXE
		if (iAttrib & ImageExe)
		{
		// link to linker/lib output name. Can't do GetTargetFileName in setting dialog because not yet committed
	
			CPath path;	
			COptionHandler * popthdlr;
			CString strOutput;

			if(iAttrib & ImageXbe) {
				/* This is an Xbox image, so see if we can find the XBE builder
				 * and ask it what its output is */
				/* THIS IS A HACK IF I EVER SAW ONE */
				WORD idAddOnXbox =
					g_prjcompmgr.GenerateBldSysCompPackageId("Microsoft Xbox C/C++ v1.0");
				if(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnXbox,
						523), (CBldSysCmp*&)popthdlr))
					GetStrProp(popthdlr->MapLogical(0), strOutput);
			}

			if(strOutput.IsEmpty()) {
				VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Linker),
														 (CBldSysCmp *&)popthdlr));
				GetStrProp(popthdlr->MapLogical(P_OutName), strOutput);
			}
			if (!strOutput.IsEmpty())
			{
				path.CreateFromDirAndFilename(GetWorkspaceDir(), strOutput);
				val = path.GetFullPath();
				return valid;
			}
			
		}
	}

	// Java: we only want to check for specific Java properties if this is a Java project.

	// for EXE projects, before attempting to get the current platform, make sure the
	// platform is set; it's possible for GetStrProp to be called before P_ExtOpts_Platform is set.
	// So, if we don't know the platform, assume it's not Java.

	CString strDummyPlatform;
	if (!m_bProjIsExe || (m_bProjIsExe && GetStrProp(P_ExtOpts_Platform, strDummyPlatform) == valid))
	{

		// only check Java-specific properties if this is a Java project
		if (GetCurrentPlatform()->GetUniqueId() == java)
		{

			// do we want to fake P_Java_Browser?
			if (gpt == invalid && idProp == P_Java_Browser)
			{
				GetBrowserPath(val);
				// set this property so we don't have to compute it every time
				SetStrProp(P_Java_Browser, val);

				return valid;
			}

			// do we want to fake P_Java_Standalone?
			if (gpt == invalid && idProp == P_Java_Standalone)
			{
				GetStandalonePath(val);
				// set this property so we don't have to compute it every time
				SetStrProp(P_Java_Standalone, val);

				return valid;
			}

			// do we want to fake P_Java_HTMLPage?
			if (idProp == P_Java_HTMLPage)
			{
				// what is the param source?
				int nParamSource = Java_ParamSource_Unknown;
				GetIntProp(P_Java_ParamSource, nParamSource);
				if (nParamSource == Java_ParamSource_HTMLPage)
				{

					// fake this property if it doesn't already have a value
					if (gpt == invalid)
					{
						CPath pathHTMLPage;

						// first try the class name.html
						CString strClassName;
						GetStrProp(P_Java_ClassFileName, strClassName);
						pathHTMLPage.CreateFromDirAndFilename(GetProjDir(), strClassName + _T(".html"));
						if (pathHTMLPage.ExistsOnDisk())
						{
							val = pathHTMLPage.GetFileName();
						}
						else
						{
							// try the project name.html
							const CPath* ppathProj = GetFilePath();
							CString strBaseName;
							ppathProj->GetBaseNameString(strBaseName);
							pathHTMLPage.CreateFromDirAndFilename(GetProjDir(), strBaseName + _T(".html"));
							if (pathHTMLPage.ExistsOnDisk())
							{
								val = pathHTMLPage.GetFileName();
							}
							else
							{
								val = "";
							}
						}

						// store the HTML name in the P_Java_HTMLPage prop
						SetStrProp(P_Java_HTMLPage, val);

						return valid;
					}
				}
				else
				{
					// this prop is invalid except when param source is from HTML page
					val = "";
					return invalid;
				}
			}

			// do we want to fake P_Java_TempHTMLPage?
			if (gpt == invalid && idProp == P_Java_TempHTMLPage)
			{
				// generate a unique name
				TCHAR szTempHTMLPage[_MAX_PATH];
				if (GetTempFileName((LPCTSTR)GetProjDir(), _T("VJ"), 0, szTempHTMLPage))
				{

					// delete the file that's created on the disk
					VERIFY(DeleteFile(szTempHTMLPage));

					// create a path
					CPath pathTempHTMLPage;
					pathTempHTMLPage.Create(szTempHTMLPage);

					// change the extension to .html
					pathTempHTMLPage.ChangeExtension(_T(".html"));

					val = pathTempHTMLPage.GetFullPath();

					// store the temp name in the P_Java_TempHTMLPage prop
					SetStrProp(P_Java_TempHTMLPage, val);
				}
				else
				{
					val = "";
				}

				return valid;
			}

		}
	}

	// If the return value wasn't 'valid', the prop isn't
	// in the prop bag (only place it could be).  Return
	// an empty string by default.
	if (gpt != valid)
		val = "";

	return valid;
}


///////////////////////////////////////////////////////////////////////////////
BOOL CProject::SetStrProp(UINT idProp, const CString& val)
{
	// Cached property bag pointer
	ConfigurationRecord *pcr;

	// Property bag list
	CPtrList m_listPropBag;

	if (idProp == P_ProjSccProjName) {
		if (((m_strProjSccProjName.IsEmpty()) && (!val.IsEmpty()))
			|| ((!m_strProjSccProjName.IsEmpty()) && (val.IsEmpty())))
		{
		// these scc props are write once for sharability, but
		// this seems too severe.
		// can be changed to empty, perhaps a stepping stone to a real change.
			m_strProjSccProjName = val;
			DirtyProject();
		}
		return TRUE; //??
	}
	else if (idProp == P_ProjSccRelLocalPath) {
		if (((m_strProjSccRelLocalPath.IsEmpty()) && (!val.IsEmpty()))
			|| ((!m_strProjSccRelLocalPath.IsEmpty()) && (val.IsEmpty())))
		{
		// these scc props are write once for sharability, but
		// this seems too severe.
		// can be changed to empty, perhaps a stepping stone to a real change.
			m_strProjSccRelLocalPath = val;
			DirtyProject();
		}
		return TRUE; //??
	}
//	else if (idProp == P_ProjSccProjAux) {
//		m_strProjSccProjAux = val;
//		return TRUE; //??
//	}
	// is the configuration changing?
	else if (idProp == P_ProjActiveConfiguration)
	{
		// is this different to our current config.?
		if (m_strProjActiveConfiguration.CompareNoCase(val) != 0)
		{
			BOOL fInformOfConfigChanged = FALSE;
 
			// do we have this configuration?
			if ((pcr = ConfigRecordFromConfigName(val)) == NULL)
			{
				// we must be initialising the project
				pcr = CreateConfigRecordForConfig(val);
 			}
			else
			{
				// this is changing most likely due to user-interaction
				// with UI that allows the picking of a config.
				// from a list of choices

				// can we do this?
				if (!theApp.NotifyPackages(PN_QUERY_CHANGE_CONFIG))
				{
					// if we have the prop. browser up make sure
					// we undo the recent control change
					RefreshTargetCombos();
					InformDependants(idProp);
					return FALSE;
				}

				fInformOfConfigChanged = m_bPrivateDataInitialized && (FindProjWksIFace()->IsWorkspaceInitialised() == S_OK);
			}

			// set ourselves in this config. (update the view)
			SetActiveConfig(pcr, FALSE);

		 	// do we want to inform the packages of this config. change?
			if (fInformOfConfigChanged && m_bNotifyOnChangeConfig)
 				theApp.NotifyPackages(PN_CHANGE_CONFIG);
 
			// Update the deferred tool menu items
			UpdateDeferredCmds(FALSE);
		}
	}

	// is the target file name changing?
	else if (idProp == P_ExtOpts_Targ || idProp == P_Proj_Targ)
	{
		// Cannot set the property to an empty string, as we must fake it.
		CString temp = val;
		temp.TrimLeft();
		temp.TrimRight();
		if (temp.IsEmpty())
		{
			CPropBag * pBag = GetPropBag();
			ASSERT(pBag != (CPropBag *)NULL);

			pBag->RemoveProp(idProp);
			InformDependants(P_ProjItemFullPath);

			return TRUE;
		}

		InformDependants(P_ProjItemFullPath);
	}
#ifdef VB_MAKEFILES
	else if (idProp == P_VBProjName) {
		m_strVBProjFile = val;
		return TRUE;
	}
#endif

	// do the base-class (CProjContainer) thing
	return CProjContainer::SetStrProp(idProp, val);
}

BOOL CProject::SetIntProp(UINT idProp, int val)
{
#ifdef VB_MAKEFILES
	if ( idProp == P_Proj_IsVB ){
		m_bVB = val;
		return TRUE;
	}
#endif
	return CProjContainer::SetIntProp (idProp, val);
}

ConfigurationRecord *CProject::CreateConfigRecordForConfig(
												const CString & strConfig)
{
	//	Create a configuration record for the supplied name:
	if (ConfigRecordFromConfigName (strConfig) != NULL) return NULL;

	ConfigurationRecord *pcr = new ConfigurationRecord (0, this);
	pcr->m_pBaseRecord = pcr;	// Record is base for itself.

	m_ConfigArray.Add(pcr);
	m_ConfigMap.SetAt ( pcr, pcr );

	PCFG_TRACE (" CProject at %p creating new config %s at %p.\n",
												this, strConfig, pcr);

	// Set the new configuration as active:
	pcr->GetPropBag(CurrBag)->SetStrProp ( this, P_ProjConfiguration, (CString &) strConfig);
	return pcr;
}

BOOL CProject::DeleteConfig ( const CString& strName, const CString& strNewConfig)
{
//	Nuke this configuration.  Note that this is not undoable, so the caller
//  needs to flush the undo stack after doing this.  Also, we don't say
//	anything about subprojects.

	// Find the configuration record to delete?
	ConfigurationRecord * pcr;
	if ((pcr = ConfigRecordFromConfigName(strName)) == (ConfigurationRecord *)NULL)
		return FALSE;

	// killing the active configuration?
	BOOL fKillingActive = pcr == GetActiveConfig();

	// Perform the delete...
	DeleteConfigFromRecord(pcr);

	// Set the active configuration to something other than this deleted one
	if (!m_ConfigMap.IsEmpty())
	{
		ASSERT(m_ConfigArray.GetSize());
		ASSERT(m_ConfigArray.GetSize() == m_ConfigMap.GetCount());

		// Switch if we killed current....
		if (fKillingActive)
		{
			// If not got one to set as the current, then use first
			if (strNewConfig.IsEmpty())
			{
				SetStrProp(P_ProjActiveConfiguration, ((ConfigurationRecord *)m_ConfigArray[0])->GetConfigurationName());
			}
			else
			{
				SetStrProp(P_ProjActiveConfiguration, strNewConfig);
			}
		}

		// Changed the configuration property
		InformDependants (P_ProjConfiguration);
	}

	return TRUE;
}

BOOL CProject::CreateConfig(const CString& strName)
{
	// Create a config. and make it the active one.
	ConfigurationRecord * pcrNewConfig = CreateConfigRecordForConfig(strName);
	if (pcrNewConfig == NULL)
		return FALSE;

 	m_pActiveConfig = pcrNewConfig;
	return TRUE;
}

////////////////////////////////////////////////////////////////////////////////////
// IDE support functions:
void CProject::ScanAllDependencies ()
{
#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "devbldd.dll", "ScanAllDependencies()", letypeBegin, 0);
#endif
	OnScanAll();
#ifdef _INSTRAPI
	LogNoteEvent(g_ProjectPerfLog, "devbldd.dll", "ScanAllDependencies()", letypeEnd, 0);
#endif
}

BOOL CProject::ScanItemDependencies(CFileItem * pItem)
{
	g_ScannerCache.UpdateDependencies( pItem );

	// Success!
	return TRUE;
}

void CProject::SetProjectState ()
{
	// NYI
}

int CProject::GetTargetAttributes()
{
	// get the target attributes from the cache for the current config.
	ConfigurationRecord * pConfig = (ConfigurationRecord *)GetActiveConfig();
	ASSERT(pConfig);
	return pConfig->GetTargetAttributes();
}

BOOL CProject::TargetIsCaller()
{
	CPath pathCaller;

	CString strCaller;
	GetStrProp(P_Caller, strCaller);

	if (!strCaller.IsEmpty())
		pathCaller.CreateFromDirAndFilename(GetWorkspaceDir(), strCaller);

	// are they the same?
	CPath * ppathTrg = GetTargetFileName();
	if (ppathTrg == (const CPath *)NULL)
		return FALSE;

	BOOL bResult = pathCaller == *ppathTrg;
	delete ppathTrg;
	return bResult;
}

CPath * CProject::GetTargetFileName()
{
	CProjType * pProjType = GetProjType();
	FileRegHandle frh = (FileRegHandle)NULL;
	
	if (m_bProjIsExe)
	{
		CString strTargetFile;
		if (GetStrProp(P_ExtOpts_Targ, strTargetFile) == valid)
		{
			CPath path;
			if (path.CreateFromDirAndFilename(GetWorkspaceDir(), strTargetFile))
#ifndef REFCOUNT_WORK
				frh = g_FileRegistry.RegisterFile((const CPath *)&path);
#else
				frh = CFileRegFile::GetFileHandle(path);
#endif
		}
	}
	else if (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)))
    {
        CString strTargetFile;
        if (GetStrProp(P_Proj_Targ, strTargetFile) == valid)
        {
            CPath path;
            if (path.CreateFromDirAndFilename(GetWorkspaceDir(), strTargetFile))
#ifndef REFCOUNT_WORK
				frh = g_FileRegistry.RegisterFile((const CPath *)&path);
#else
				frh = CFileRegFile::GetFileHandle(path);
#endif
        }
    }
	else
	{
		// try looking right at our actions
		// we may not have a dependency graph so enumerating it will not work
		CActionSlobList * pActions = GetActiveConfig()->GetActionList();
		POSITION pos = pActions->GetHeadPosition();
		while (pos != (POSITION)NULL)
		{
			CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos);

			// primary output tool?
			if (!pAction->m_pTool->HasPrimaryOutput())
				continue;	// no

			CFileRegSet * pSet = pAction->GetOutput();
#ifndef REFCOUNT_WORK
			const CPtrList * plstFile = pSet->GetContent();

			if (plstFile->GetCount())
			{
				frh = (FileRegHandle)plstFile->GetHead();
				if (!pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
					break;
			}
#else
			if (pSet->GetCount())
			{
				if (frh != NULL)
					frh->ReleaseFRHRef();
				frh = (FileRegHandle)pSet->GetFirstFrh();
				if (!pAction->m_pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool)))
					break;
			}
#endif
		}
	}

#ifndef REFCOUNT_WORK
	return frh != (FileRegHandle)NULL ? new CPath(*g_FileRegistry.GetRegEntry(frh)->GetFilePath()) : (CPath *)NULL;
#else
	CPath* pPathReturned = NULL;
	if (NULL!=frh)
	{
		pPathReturned = new CPath(*g_FileRegistry.GetRegEntry(frh)->GetFilePath());
		frh->ReleaseFRHRef();
	}
	return pPathReturned;
#endif
}

const CPath * CProject::GetBrowserDatabaseName()
{
	if (!m_bProjIsSupported)
		return NULL;

	CFileRegSet * pregset = GetTargetPaths();

	FileRegHandle frh;
	pregset->InitFrhEnum();
	while ((frh = pregset->NextFrh()) != (FileRegHandle)NULL)
	{
		const CPath * pPath = g_FileRegistry.GetRegEntry(frh)->GetFilePath();

		if (pPath && FileNameMatchesExtension (pPath, _TEXT ("bsc")))
#ifndef REFCOUNT_WORK
			return pPath;
#else
		{
			frh->ReleaseFRHRef();
			return pPath;
		}
		frh->ReleaseFRHRef();
#endif
	}

	// No bsc file!
	return NULL;
}

#include "optncplr.h"
BOOL CProject::GetPreCompiledHeaderName(CString &strPch)
{
	if (!m_bProjIsSupported)
		return FALSE;

	COptionHandler * popthdlr;
	VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Compiler),
										 (CBldSysCmp *&)popthdlr));
	// UNDONE:
	if (GetStrProp (popthdlr->MapLogical(P_PchUseUptoHeader), strPch) == valid){
		if (!strPch.IsEmpty() )
			return TRUE;
	}
	
	return FALSE;
}

void CProject::GetCallingProgramName(CString &str)
{
	// Java: the calling program name in Java is stored in the
	// P_Java_ClassFileName property instead of P_Caller

	// determine which property to use; get the platform type
	if (GetCurrentPlatform()->GetUniqueId() == java)
	{
		// For Java, we can't get the full path to the class file, because
		// it may not exist on the user's machine (i.e. it could be
		// on the web).
		GetStrProp(P_Java_ClassFileName, str);
	}
	else
	{
		CPath pt;
		CString strCaller, strQuote;
		GetStrProp(P_Caller, strCaller);

		// strip quotes before passing to CPath
		if (!strCaller.IsEmpty() && strCaller[0]==_T('\"'))
		{
			strQuote = _T('\"');
			strCaller = strCaller.Mid(1, strCaller.GetLength()-2);
		}

		if (!strCaller.IsEmpty() &&
			pt.CreateFromDirAndFilename(GetWorkspaceDir(), strCaller)
		   )
		{
			str = strQuote + (const _TCHAR *)pt + strQuote;	// reattach any quotes
		}
		else
		{
			str.Empty ();
		}
	}
}

void CProject::GetWorkingDirectory (CString &str)
{
	CString strWorkingDir;
	GetStrProp(P_WorkingDirectory, strWorkingDir);

	if (!strWorkingDir.IsEmpty())
	{
		CPath path;
		// Deal with the case where the directory specified ends with a '\', etc
		if (strWorkingDir.Right (1) == _TEXT("\\"))
			strWorkingDir = strWorkingDir.Left(strWorkingDir.GetLength () - 1);

		if (path.CreateFromDirAndFilename(GetWorkspaceDir(), strWorkingDir + _T("\\x")))
		{
			CDir dirWorking;
			dirWorking.CreateFromPath(path);

			str = dirWorking;
		}
		else
			str.Empty();
	}
	else
	{
		str.Empty();
	}
}

void CProject::GetProgramRunArguments (CString &str)
{
	// if this is a Java project, we'll return P_Java_Args
	GetStrProp((GetCurrentPlatform()->GetUniqueId() == java) ? P_Java_Args : P_Args, str);
}

void CProject::SetProgramRunArguments (CString &str)
{
	SetStrProp(P_Args, str);
}

BOOL CProject::FPromptForDlls (void)
{
	int fPrompt;
	GetIntProp(P_PromptForDlls, fPrompt);
	return (BOOL) fPrompt;
}

VOID CProject::SetPromptForDlls (BOOL fPrompt)
{
	SetIntProp(P_PromptForDlls, fPrompt);
}

void CProject::GetJavaClassName(CString& str)
{
	GetStrProp(P_Java_ClassFileName, str);
}

void CProject::GetJavaClassPath(CString& str)
{
	// concatonate: output directory + project directory + extra class path + class path

	// get the directory manager
	CDirMgr* pDirMgr = GetDirMgr();

	// get the class path
	pDirMgr->GetDirListString(str, DIRLIST_INC);

	// get the extra class path
	CString strExtraClassPath;
	GetStrProp(P_Java_ExtraClasses, strExtraClassPath);
	if (!strExtraClassPath.IsEmpty())
	{
		str = strExtraClassPath + _T(";") + str;
	}

	// get the output directory
	CString strOutputDir;
	GetStrProp(P_OutDirs_Target, strOutputDir);

	// get the project directory
	CString strProjDir = GetProjDir();
	if (!strProjDir.IsEmpty())
	{
		str = strProjDir + _T(";") + str;

		if (!strOutputDir.IsEmpty())
		{
			// Only prepend the project dir if the output dir is relative.

			// In order for CPath to work right, it has to have a filename, so
			// append a bogus one here.
			// (We use CPath because it's the safest way to do this path munging stuff.)
			CPath pathOutputDir;
			CDir dirProjDir;
			dirProjDir.CreateFromString(strProjDir);

			// if strOutputDir has a trailing \ then CreateFromDirAndFilename has problems 
			if (strOutputDir.Right (1) == _TEXT ("\\"))
				strOutputDir = strOutputDir.Left (strOutputDir.GetLength () - 1);
			pathOutputDir.CreateFromDirAndFilename(dirProjDir, strOutputDir + _T("\\x"));

			// We just need the path part, not the full path + file name.
			CDir dirOutputDir;
			dirOutputDir.CreateFromPath(pathOutputDir);
			strOutputDir = dirOutputDir;
		}
	}

	// Add on the output directory.
	if (!strOutputDir.IsEmpty())
	{
		str = strOutputDir + _T(";") + str;
	}
}

BOOL CProject::GetJavaClassFileName(CString& str)
{
	str.Empty();

	// get the class name
	CString strClassName;
	GetStrProp(P_Java_ClassFileName, strClassName);

	// get the class path
	CString strClassPath;
	GetJavaClassPath(strClassPath);

	// search the class path for the class
	TCHAR szClassFileName[_MAX_PATH];
	if (SearchPath(strClassPath, strClassName, _T(".class"), _MAX_PATH, szClassFileName, NULL) != 0)
	{
		str = CString(szClassFileName);
		return TRUE;
	}

	return FALSE;
}

int CProject::GetJavaDebugUsing()
{
	// this should only be called if the project is Java
	ASSERT(GetCurrentPlatform()->GetUniqueId() == java);

	int nDebugUsing = Java_DebugUsing_Unknown;
	GetIntProp(P_Java_DebugUsing, nDebugUsing);

	return nDebugUsing;
}

void CProject::GetJavaBrowser(CString& str)
{
	// this should only be called if the project is Java
	ASSERT(GetCurrentPlatform()->GetUniqueId() == java);

	CString strBrowser;
	GetStrProp(P_Java_Browser, strBrowser);

	// ensure the browser has an extension (if it doesn't add .exe)
	TCHAR szExt[_MAX_EXT];
	_tsplitpath(strBrowser, NULL, NULL, NULL, szExt);
	if (szExt[0] == _T('\0')) {
		strBrowser += _T(".exe");
	}

	str = strBrowser;
}

void CProject::GetJavaStandalone(CString& str)
{
	// this should only be called if the project is Java
	ASSERT(GetCurrentPlatform()->GetUniqueId() == java);

	CString strStandalone;
	GetStrProp(P_Java_Standalone, strStandalone);

	// ensure the stand-alone interpreter has an extension
	// (if it doesn't add .exe)
	TCHAR szExt[_MAX_EXT];
	_tsplitpath(strStandalone, NULL, NULL, NULL, szExt);
	if (szExt[0] == _T('\0')) {
		strStandalone += _T(".exe");
	}

	str = strStandalone;
}

void CProject::GetJavaStandaloneArgs(CString& str)
{
	// this should only be called if the project is Java
	ASSERT(GetCurrentPlatform()->GetUniqueId() == java);

	// this should only be called if we're debugging using a stand-alone interpreter
#ifdef _DEBUG
	int nDebugUsing = Java_DebugUsing_Unknown;
	GetIntProp(P_Java_DebugUsing, nDebugUsing);
	ASSERT(nDebugUsing == Java_DebugUsing_Standalone);
#endif

	GetStrProp(P_Java_StandaloneArgs, str);
}

int CProject::GetJavaStandaloneDebug()
{
	// this should only be called if the project is Java
	ASSERT(GetCurrentPlatform()->GetUniqueId() == java);

	// this should only be called if we're debugging using a stand-alone interpreter
#ifdef _DEBUG
	int nDebugUsing = Java_DebugUsing_Unknown;
	GetIntProp(P_Java_DebugUsing, nDebugUsing);
	ASSERT(nDebugUsing == Java_DebugUsing_Standalone);
#endif

	int nDebugStandalone = Java_DebugStandalone_Unknown;
	GetIntProp(P_Java_DebugStandalone, nDebugStandalone);

#ifndef STANDALONE_APPLET
	nDebugStandalone = Java_DebugStandalone_Application;
#endif

	return nDebugStandalone;
}

// this function is guaranteed to return an HTML page;
// it is intented to be used with the src package for debug/execution.
// If no page is specified by P_Java_HTMLPage, we'll generate a page with
// the name specified by P_Java_TempHTMLPage. If no page is specified
// by P_Java_TempHTMLPage, we'll generate a temporary name.
// If we're unable to generate the HTML page, this function returns FALSE.
BOOL CProject::GetJavaHTMLPage(CString& str)
{
	// this should only be called if the project is Java
	ASSERT(GetCurrentPlatform()->GetUniqueId() == java);

	// this should only be called if we're debugging using a browser
#ifdef _DEBUG
	int nDebugUsing = Java_DebugUsing_Unknown;
	GetIntProp(P_Java_DebugUsing, nDebugUsing);
	ASSERT(nDebugUsing == Java_DebugUsing_Browser);
#endif

	str.Empty();

	// do we need to generate a temporary HTML page (P_Java_ParamSource == Java_ParamSource_User)?
	int nParamSource = Java_ParamSource_Unknown;
	GetIntProp(P_Java_ParamSource, nParamSource);
	BOOL bUseTempHTMLPage = (nParamSource == Java_ParamSource_User);

	CString strHTMLPage;
	
	// are we using a user-specified HTML page (i.e. not a temp HTML page)
	if (!bUseTempHTMLPage)
	{
		// get the user's HTML page
		GetStrProp(P_Java_HTMLPage, strHTMLPage);

		// if no page is specified, use the temp HTML page
		if (strHTMLPage.IsEmpty())
		{
			bUseTempHTMLPage = TRUE;
		}
	}

	// are we using a temp HTML page
	if (bUseTempHTMLPage)
	{
		// get the temp HTML page
		GetStrProp(P_Java_TempHTMLPage, strHTMLPage);

		// if no temp name is specified, we can't return an HTML page
		if (strHTMLPage.IsEmpty())
			return FALSE;

		// set the P_Java_ParamSource prop
		// (do this because we may be using a temp HTML page
		// because the user never specified an actual HTML page)
		SetIntProp(P_Java_ParamSource, Java_ParamSource_User);
	}

	// get a full path to the page, if one's not specified
	CPath pathHTMLPage;
	if (pathHTMLPage.CreateFromDirAndFilename(GetProjDir(), strHTMLPage))
	{
		strHTMLPage = pathHTMLPage.GetFullPath();
	}

	// are we using a temp HTML page?
	if (bUseTempHTMLPage)
	{
		// if the temporary file is read only, generate a new temporary file
		CFileStatus statusHTMLPage;
		if (CFile::GetStatus(strHTMLPage, statusHTMLPage))
		{
			if (statusHTMLPage.m_attribute & CFile::readOnly)
			{
				// generate a new temporary file
				// generate a unique name
				TCHAR szTempHTMLPage[_MAX_PATH];
				if (GetTempFileName((LPCTSTR)GetProjDir(), _T("VJ"), 0, szTempHTMLPage))
				{
					// delete the file that's created on the disk
					VERIFY(DeleteFile(szTempHTMLPage));

					// create a path
					CPath pathTempHTMLPage;
					pathTempHTMLPage.Create(szTempHTMLPage);

					// change the extension to .html
					pathTempHTMLPage.ChangeExtension(_T(".html"));

					strHTMLPage = pathTempHTMLPage.GetFullPath();

					// store the temp name in the P_Java_TempHTMLPage prop
					SetStrProp(P_Java_TempHTMLPage, strHTMLPage);
				}
			}
		}

		// generate HTML that describes the applet

		// open the file
		CFile fileTempHTMLPage;
		if (fileTempHTMLPage.Open(strHTMLPage, CFile::modeCreate | CFile::modeWrite))
		{

			// get the class file name
			CString strClassFileName;
			GetStrProp(P_Java_ClassFileName, strClassFileName);
			// get the params
			CString strHTMLArgs;
			GetStrProp(P_Java_HTMLArgs, strHTMLArgs);

			// generate the page
			CString strHTMLFormat;
			CString strT;
			int i;

			i = IDS_JAVA_TEMP_HTML_PAGE;
			while (i <= IDS_JAVA_TEMP_HTML_PAGE_LAST)
			{
				strT.LoadString(i);
				strHTMLFormat += strT;
				i++;
			}
			CString strHTML;
			strHTML.Format(strHTMLFormat, (LPCSTR)strClassFileName, (LPCSTR)strClassFileName, (LPCSTR)strHTMLArgs);

			// write out the HTML
			fileTempHTMLPage.Write(strHTML, strHTML.GetLength());

			// close the file
			fileTempHTMLPage.Close();
		}
		else
		{
			return FALSE;
		}
	}

	str = strHTMLPage;

	return TRUE;
}

BOOL CProject::ClassWizardName (CPath & path)
{
	CString strName;

    CProjType * pProjType = GetProjType();

	if (m_bProjIsExe)
	{
		// The P_ExtOpts_ClsWzdName property is now defunct
   		//VERIFY (GetStrProp (P_ExtOpts_ClsWzdName, strName) == valid);
		//if (strName.IsEmpty())
			path = *GetFilePath();	// use the basename of project
		//else
		//	path.Create (strName);				// use user-supplied name
	}
	else
	{
		if (GetStrProp (P_ProjClsWzdName, strName) != valid ||
			strName.IsEmpty()
		   )
		{
			// try to find a buildable .RC file
			CObList oblistRCFile;
			g_FileRegistry.GetFileItemList(GetActiveTarget(), g_FileRegistry.GetRCFileList(),
										   oblistRCFile);
			if (oblistRCFile.GetCount() == 1)
				path = *((CFileItem *)oblistRCFile.GetHead())->GetFilePath();	// use basename of .RC
			else
				path = *GetFilePath();	// use the basename of project
		}
		else
			path.Create (strName);			// use user-supplied name
	}

	// make sure we have the right extension
	path.ChangeExtension(".clw");
	return TRUE;
}

void CProject::GetRemoteTargetFileName(CString &str)
{
	GetStrProp(P_RemoteTarget, str);
}

void CProject::SetRemoteTargetFileName (CString &str)
{
	SetStrProp(P_RemoteTarget, str);
}

void CProject::AddFile (const CPath *pPath )
{
	FileRegHandle frh;
 	CFileItem *pItem;
	POSITION pos;
	
	CTargetItem* pTarget = GetActiveTarget();
	ASSERT(pTarget != NULL);

#ifndef REFCOUNT_WORK
	frh = g_FileRegistry.LookupFile(*pPath);
#else
	frh = CFileRegFile::LookupFileHandleByName(*pPath);
#endif
	if (frh != NULL)
	{
	 	for (pos = pTarget->GetHeadPosition (); pos != NULL;)
		{
			pItem = (CFileItem *) pTarget->GetNext (pos);
			ASSERT (pItem->IsKindOf ( RUNTIME_CLASS ( CProjItem )));
			if (pItem->GetFileRegHandle () == frh )	   // BINGO
			{
				ASSERT (pItem->IsKindOf ( RUNTIME_CLASS ( CFileItem )));
#ifdef REFCOUNT_WORK
				frh->ReleaseFRHRef();
#endif
				return;
			}
		}
#ifdef REFCOUNT_WORK
		frh->ReleaseFRHRef();
#endif
	}

	// Make the build pane active and set the focus to it
	GetBuildNode()->ShowBuildPane(TRUE);

	// N.B. must explicitly pass our ProjView, since we may not be active
	LPPROJECTWORKSPACEWINDOW pProjSysIFace = FindProjWksWinIFace();
	pProjSysIFace->BeginUndo(IDS_UNDO_ADD_FILES);

	pItem = new CFileItem ();
	pItem->SetFile (pPath);
	pItem->MoveInto (pTarget);

	pProjSysIFace->EndUndo();
}

BOOL CProject::IsProjectFile (const CPath *pPath )
{
	// Can't simply look to see if the file appears in the file registry,
	// since it could be on the Clipboard or on the Undo stack.
	// Second check is designed to do this.

#ifndef REFCOUNT_WORK
	FileRegHandle frh = g_FileRegistry.LookupFile(*pPath);
#else
	FileRegHandle frh = CFileRegFile::LookupFileHandleByName(*pPath);
	if (NULL!=frh)
		frh->ReleaseFRHRef();
#endif

	CTargetItem* pTarget = GetActiveTarget();
	return NULL==pTarget?FALSE:pTarget->IsFileInTarget(frh);

}

BOOL CProject::IsExeProject () const
{
	// (Added after several requests):
	// FUTURE (colint): Need to remove reliance on this as much as possible
	return m_bProjIsExe;
}

BOOL CProject::IsExternalTarget() 
{
	CProjType * pProjType = GetProjType();
	return (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)));
}

CPlatform * CProject::GetCurrentPlatform()
{
	if (m_bProjIsExe)
	{
		CString		strPlatform;
		CPlatform *	pPlatform;
		CPlatform *	pPlatformRet = NULL;

		VERIFY(GetStrProp(P_ExtOpts_Platform, strPlatform) == valid);

		// Search based on the "UI description" string (that's what's
		// stored in P_ExtOpts_Platform).

		g_prjcompmgr.InitPlatformEnum();

		while (g_prjcompmgr.NextPlatform(pPlatform))
		{
			if (*pPlatform->GetUIDescription() == strPlatform)
			{
				pPlatformRet = pPlatform;
				break;
			}
		}

		return pPlatformRet;
	}
	else
	{
		return (CPlatform *)GetProjType()->GetPlatform();
	}
}

BOOL CProject::CanContain(CSlob* pSlob)
{
	if (pSlob->IsKindOf(RUNTIME_CLASS(CProjGroup)) ||
		pSlob->IsKindOf(RUNTIME_CLASS(CTargetItem)) )
		return TRUE;

	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Drag and Drop support

CSlobDragger* CProject::CreateDragger(CSlob* /*pDragObject*/, CPoint /*screenPoint*/)
{
	return NULL;
}

void CProject::DoDrop(CSlob * /*pSlob*/, CSlobDragger * /*pDragger */)
{
	return;
}

void CProject::DoDrag(CSlob * /*pSlob*/, CSlobDragger * /*pDragger*/, CPoint /*screenPoint*/)
{
	return;
}

BOOL CProject::AreFilesUnique(const CSlob * pSlob, BOOL bTopLevel /* = TRUE */)
{
	BOOL retval = TRUE;
	FileRegHandle hndFileReg;
	static CMapPtrToPtr mapFileRegs;
	if (bTopLevel)
	{
		ASSERT(mapFileRegs.IsEmpty());
	}
	CProjItem * pItem, *pDupItem;
	POSITION pos = ((CSlob *)pSlob)->GetContentList()->GetHeadPosition();
	while (pos != NULL)
	{
		pItem = (CProjItem *)((CSlob *)pSlob)->GetContentList()->GetNext(pos);
		if (pItem->IsKindOf(RUNTIME_CLASS(CBuildSlob)))
		{
			pItem = ((CBuildSlob *)pItem)->GetProjItem();
			ASSERT(pItem != NULL);
		}

		if (pItem->IsKindOf(RUNTIME_CLASS(CFileItem)))
		{
			hndFileReg = pItem->GetFileRegHandle();
			if (mapFileRegs.Lookup((void *)hndFileReg, (void * &) pDupItem))
			{
				ASSERT(pDupItem!=pItem);
				retval = FALSE;
				break;
			}
			else
			{
				mapFileRegs.SetAt((void *)hndFileReg, (void *)pItem);
			}
		}
		else if ((pItem->IsKindOf(RUNTIME_CLASS(CProjGroup))) && (!pItem->GetContentList()->IsEmpty()))
		{
			retval = AreFilesUnique(pItem, FALSE);
			if (!retval)
				break;
		}
	}
	if (bTopLevel)
		mapFileRegs.RemoveAll();

	return retval;
}

///////////////////////////////////////////////////////////////////////////////
#ifdef EXT_FILES
BOOL CProject::BuildFilesList ()
{
	return TRUE;
}
#endif
#if (0)
BOOL SpawnToolAndGetFiles (
						const CDir &rDir,
						CPtrList &pl,
						const TCHAR *pCommandLine
						);
/*
class CPossibleGroup : public CObject
{
public:
	CPossibleGroup ( const TCHAR *pGroupName, const TCHAR *pGroupExtensions );
*/
BOOL CProject::BuildFilesList ()
{
	CPtrList pl(100);		// List of file reghangles.

	if (!SpawnToolAndGetFiles (GetWorkspaceDir(), pl, )) return FALSE;

}
BOOL SpawnToolAndGetFiles (
						const CDir &rDir,
						CPtrList &pl,
						const TCHAR *pCommandLine
						)
{
}
#endif

///////////////////////////////////////////////////////////////////////////////
// UpdateBrowserDatabase
//
// This function will update the browser database, tho' a link
// will also happen. 
// FUTURE: when all this old build system code goes perhaps
// we can just call g_buildengine.DoBuild("foobar.bsc") ;-)

// Dialog we use
class CUpdateBrowserDlg : public C3dDialog
{
	DECLARE_MESSAGE_MAP()

public:
	CUpdateBrowserDlg(CWnd* pParent /*=NULL*/)
	: C3dDialog(IDD_UPDATE_BROWSE, pParent)
	{
	}

	virtual BOOL OnInitDialog();
	virtual BOOL OnCommand(WPARAM, LPARAM);

	const TCHAR * m_pchBscFile;
};

BEGIN_MESSAGE_MAP(CUpdateBrowserDlg, C3dDialog)
END_MESSAGE_MAP()

BOOL CUpdateBrowserDlg::OnInitDialog()
{
	if (!C3dDialog::OnInitDialog())
		return FALSE;

	// set our title
	SetWindowText(theApp.m_pszAppName);

	// set our exclamation mark icon
	((CStatic *)GetDlgItem(IDC_UPATE_BROWSE_ICON))->SetIcon(::LoadIcon(NULL, IDI_EXCLAMATION));

	// set our .bsc file name text
	GetDlgItem(IDC_BSCNAME)->SetWindowText(m_pchBscFile);

	return TRUE;	// ok
}

BOOL CUpdateBrowserDlg::OnCommand(WPARAM wParam, LPARAM lParam)
{
	// not a 'response' button
	if (wParam != IDYES && wParam != IDNO && wParam != IDCANCEL)
		return C3dDialog::OnCommand(wParam, lParam);

	// end the dialog on this response
	EndDialog(wParam);
	return TRUE;
}

BOOL CProject::UpdateBrowserDatabase()
{
	// can't explicitly update the database
	// o for external targets
	// o for .EXE projects
	// o if we can't do a build for some other reason
	CProjType * pProjType;

	if (m_bProjIsExe ||
		(pProjType = GetProjType()) == (CProjType *)NULL ||
		pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)) ||
		!CanDoTopLevelBuild()
	   )
	{
	   return TRUE;		// nothing to do
	}

	// get the browser database name
	const CPath * pPath = GetBrowserDatabaseName();
	if (pPath == (const CPath *)NULL)
		return FALSE;	// don't have a project .bsc!

	BOOL fSuccess = TRUE;	// assume .bsc is up-to-date

	// is it up to date?
	UINT trgState = g_BldSysIFace.TargetState((CObList *)NULL, (const TCHAR *)*pPath);
	if (trgState == TRG_STAT_Out_Of_Date || trgState == TRG_STAT_Unknown)
	{	
		// get our browser database tool
		// and create our action
		CBuildTool * pTool;
		VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_Tool_BscMake),
											 (CBldSysCmp *&)pTool));
		CActionSlob action(this, pTool);

		// actions have browser on?
		CActionSlobList * pActions = GetActiveConfig()->GetActionList();
		CActionSlob * pAction;

		POSITION pos;

		// ask user if wants to build before browse
		CUpdateBrowserDlg dlg(theApp.m_pMainWnd);
		dlg.m_pchBscFile = (const TCHAR *)*pPath;

		// do it
		WORD wResult = dlg.DoModal();

		// do build?
		if (wResult == IDYES)
		{
			// tmp. change browser options
			pTool->SetDeferredAction(&action, dabNotDeferred);

			pos = pActions->GetHeadPosition();
			while (pos != (POSITION)NULL)
			{
				pAction = (CActionSlob *)pActions->GetNext(pos);
				pAction->m_dwEvent = TRUE;	// turn-on browse
				if (pAction->m_pTool != (CBuildTool *)NULL)
					pAction->m_pTool->OnActionEvent(ACTEVT_SetBrowse, pAction);
			}

			// possible option change due to the above set-browse change
			CActionSlob::DirtyAllCommands(GetActiveTarget());

			// do the build
			fSuccess = DoTopLevelBuild(FALSE, NULL, fcaRebuild, FALSE);
		}
	}

	return fSuccess;
}

///////////////////////////////////////////////////////////////////////////////
// UpdateRemoteTarget
//
// This function attempts to update the copy of the target on the
// remote platform. This will be called when we try to load the
// debuggee and find that the debuggee is out of date.
//
// NOTE: currently we can only do this for the mac.

BOOL CProject::UpdateRemoteTarget()
{
#if 0
	// this is no longer supported

	// Currently we can only do this for the mac
	CPlatform * pPlatform;

	// Make sure we have a remote executable name...
	if (!GetInitialRemoteTarget())
		return FALSE;

	BOOL bIsExternalTarget;
	CProjType* pProjType = GetProjType();
	bIsExternalTarget = (pProjType && pProjType->IsKindOf(RUNTIME_CLASS(CProjTypeExternalTarget)));
	if (m_bProjIsExe || bIsExternalTarget)
	{
		CString str;

		if (m_bProjIsExe)
		{
 			VERIFY(GetStrProp(P_ExtOpts_Platform, str));
			g_prjcompmgr.LookupPlatformByUIDescription(str, pPlatform);
		}
		else
			pPlatform = (CPlatform *)pProjType->GetPlatform();
 
 		if (pPlatform->GetUniqueId() == mac68k ||
			pPlatform->GetUniqueId() == macppc)
 		{
			CErrorContext *pEC;
			CEnvironmentVariableList ProjEnvironment;
			CProject::BuildResults brResult;
			DWORD errs,warns;

			// Mfile tool output file
			CPath pathOutput;
			if (!GetStrProp(bIsExternalTarget ? P_Proj_Targ : P_ExtOpts_Targ, str) ||
				!pathOutput.CreateFromDirAndFilename(GetWorkspaceDir(), str)
			   )
				return FALSE;

			// Mfile tool input file
			CPath* pPath = GetTargetFileName();
			ASSERT(NULL!=pPath);
			CString strName(pPath->GetFileName());
			delete pPath;

#ifndef REFCOUNT_WORK
			FileRegHandle frh = g_FileRegistry.RegisterFile(&pathOutput);
#else
			FileRegHandle frh = CFileRegFile::GetFileHandle(pathOutput);
#endif

			if (!theApp.NotifyPackages(PN_QUERY_BEGIN_BUILD) ||
				!g_Spawner.CanSpawn()
			   )
				return FALSE;

			// UNDONE
			// find the any old damn mfile tool we want....
			CBuildTool * ptool = (CBuildTool *)NULL;
			g_prjcompmgr.InitBuildToolEnum();
			while (g_prjcompmgr.NextBuildTool(ptool))
			{
				if (ptool->IsMecrTool())
					break;
			}
			ASSERT(ptool != (CBuildTool *)NULL);

			// Initialize the spawner and output window:
			ASSERT (!g_Spawner.SpawnActive());

			if ((pEC = g_Spawner.InitSpawn ()) == NULL)
				return FALSE;

			theApp.NotifyPackages (PN_BEGIN_BUILD, (void *) FALSE);

			ConfigCacheEnabler Cacher;	// No properties can change

			GetEnvironmentVariables ( &ProjEnvironment );
			ProjEnvironment.SetVariables ();

			CTempMaker TM;

			CActionSlob * pAction = new CActionSlob(this, ptool);

			pAction->DirtyInput(FALSE);
			CFileRegSet * psetInput = pAction->GetInput();
			psetInput->AddRegHandle(frh, FALSE);
#ifdef REFCOUNT_WORK
			frh->ReleaseFRHRef();
#endif

			CActionSlobList lstActions;
			lstActions.AddTail(pAction);

			CStringList slCommandLines, slDescriptions;
			if (!ptool->GetCommandLines(lstActions,	slCommandLines, slDescriptions, 0, *pEC))
			{
				// display the notification that the
				// 'get command-line' operation failed
				CString str;
				pEC->AddString(::MsgText(str,
										 IDS_GET_COMMAND_LINE_FAILED,
										 (const TCHAR *) *ptool->GetName ()
										));
				// log this as an error
				g_Spawner.m_dwProjError++;
			}

			// anything to do?
			if (!slCommandLines.IsEmpty())
			{
				UINT cmd = g_Spawner.DoSpawn(slCommandLines, slDescriptions, GetWorkspaceDir(), FALSE, FALSE, *pEC);

				if (cmd != CMD_Canceled && cmd != CMD_Complete)
					cmd = CMD_Error; 

				if (cmd == CMD_Canceled)
					brResult = BuildCanceled;

				else if (cmd == CMD_Complete)
					brResult = BuildComplete;

				else if (cmd == CMD_Error)
					brResult = BuildError;
			}

			delete pAction;

			TM.NukeFiles (*pEC );

			ProjEnvironment.ResetVariables ();	// May do nothing.
			g_Spawner.GetErrorCount ( errs, warns );

			pEC->AddString(_T(""));

			if (brResult == BuildCanceled)
				pEC->AddString(IDS_USERCANCELED);
			else
				pEC->AddString(MsgText(str, IDS_BUILD_COMPLETE, (const char *) strName, errs, warns));
			theApp.NotifyPackages (PN_END_BUILD, (void *) FALSE);
			g_Spawner.TermSpawn ();

			return (brResult == CProject::BuildComplete ) ? TRUE : FALSE;
		}
	}
	else
	{
		pPlatform = (CPlatform *)pProjType->GetPlatform();
		if (pPlatform->GetUniqueId() == mac68k ||
			pPlatform->GetUniqueId() == macppc)
		{
			// Get the build tools for this platform only
 			CPtrList * pToolsList = pProjType->GetToolsList();

			// Now look for the mecr/mfile tool, of which we
			// should only have one.
			CBuildTool * pTool;
 			POSITION pos = pToolsList->GetHeadPosition();
			while (pos != NULL)
			{
				pTool = (CBuildTool *)pToolsList->GetNext(pos);
				if (pTool->IsMecrTool())
				{	
					TRACE("UNDONE: Use of CBuildTool::IsMecrTool() in %s @ %d", __FILE__, __LINE__);
					ASSERT(pTool->IsKindOf(RUNTIME_CLASS(CSchmoozeTool)));
					return TopLevelRunDeferedBuildTool((CSchmoozeTool *)pTool, TRUE);
				}
			}
			return FALSE;
		}
	}
#endif
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// GetInitialRemoteTarget

BOOL CProject::GetInitialRemoteTarget(BOOL bBuild /* = FALSE */, BOOL fAlways /* = FALSE */)
{
	// don't ask for the name if we're runable or debugable!
	CProjType * pProjType = GetProjType();
	if (pProjType != (CProjType *)NULL && !(pProjType->GetAttributes() & TargetIsDebugable))
		return TRUE;	// no need to!

	// don't ask for name if not empty and we don't want to always 
	// ask for the name
	CString strRemote;
	if (GetStrProp(P_RemoteTarget, strRemote))
		if (!(fAlways || strRemote.IsEmpty()))
			return TRUE;	// no need to!

	// ask for name
	CRemoteTargetDlg dlg(bBuild);

	return dlg.DoModal() == IDOK;
}

///////////////////////////////////////////////////////////////////////////////
// GetInitialExeForDebug

BOOL CProject::GetInitialExeForDebug(BOOL bExecute /* = FALSE */)
{
	CCallingExeDlg dlg(bExecute);

	if (dlg.DoModal() == IDOK)
		return TRUE;

	// User didn't tell us what the executable file name is!
	return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// GetInitialJavaInfoForDebug

BOOL CProject::GetInitialJavaInfoForDebug(BOOL bExecute /*= FALSE*/)
{
	CJavaDebugInfoDlg dlg(bExecute);

	return (dlg.DoModal() == IDOK);
}

///////////////////////////////////////////////////////////////////////////////
// check if P_Profile is set or not
// NOTE: P_Profile is common linker property
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::IsProfileEnabled()
{
	BOOL bProfile ;

	// UNDONE:
	TRACE("\r\nUNDONE: Reference to P_MTLOutputTlb in %s @ %d", __FILE__, __LINE__);
	
	COptionHandler * popthdlr;
	VERIFY(g_prjcompmgr.LookupBldSysComp(GenerateComponentId(idAddOnGeneric, BCID_OptHdlr_Linker),
										 (CBldSysCmp *&)popthdlr));
	// UNDONE:
	if (GetIntProp (popthdlr->MapLogical(P_Profile), bProfile) == valid)
		return bProfile ;
	else
		return FALSE ;
}

///////////////////////////////////////////////////////////////////////////////
// SetActiveConfig()
///////////////////////////////////////////////////////////////////////////////
ConfigurationRecord * CProject::SetActiveConfig(ConfigurationRecord * pcr, BOOL /*fQuite*/)
{
	::EnterCriticalSection(&m_critSection);

	// make sure this is compatible with us, ie. a project-level config. rec.
	ASSERT(pcr != (const ConfigurationRecord *)NULL);
	ASSERT(pcr->m_pBaseRecord == pcr);

	ConfigurationRecord * pcrOldActive = m_pActiveConfig;
	m_pActiveConfig = pcr;

	::LeaveCriticalSection(&m_critSection);
	return pcrOldActive;	// success, return old active configuration
}

ConfigurationRecord * CProject::SetActiveConfig(const CString& strConfigName, BOOL fQuite)
{
	CString strTarget = strConfigName;
	ConfigurationRecord * pcr = FindTargetConfig(strTarget);
	if (pcr != NULL)
		return SetActiveConfig(pcr, fQuite);	// success?

	ASSERT (FALSE);
	return (ConfigurationRecord *)NULL;	// failure
}

///////////////////////////////////////////////////////////////////////////////
// FindTargetConfig() - Find the configuration matching the input string
//						and fix up the case to match the actual config name
///////////////////////////////////////////////////////////////////////////////
ConfigurationRecord * CProject::FindTargetConfig(CString & strTargetName)
{
	ConfigurationRecord * pcr;
	int i, cSize = GetPropBagCount();
	for (i = 0; i < cSize; i++)
	{
		pcr = (ConfigurationRecord *)m_ConfigArray[i];
		if (pcr->GetConfigurationName().CompareNoCase(strTargetName) == 0)
		{
			strTargetName = pcr->GetConfigurationName();
			return pcr;
		}
	}
	return NULL;
}

///////////////////////////////////////////////////////////////////////////////
// CProjTempConfigChange - used to temporarily change config of the project
//	                       in a thread-safe manner.
///////////////////////////////////////////////////////////////////////////////

CProjTempConfigChange::CProjTempConfigChange(CProject *pProject)
{
	ASSERT(pProject != NULL);
	::EnterCriticalSection(&pProject->m_critSection);
	m_bCritSection = TRUE;
	m_pProject = pProject;
	m_pcrOriginal = pProject->m_pActiveConfig;
}

CProjTempConfigChange::~CProjTempConfigChange( )
{
	Release();
}

// Release resets the original configuration and frees up the critical section
void CProjTempConfigChange::Release(BOOL bReset /* = TRUE*/)
{
	if (m_bCritSection)
	{
		if (bReset)
			Reset();

		m_bCritSection = FALSE;
		::LeaveCriticalSection(&m_pProject->m_critSection);
	}
}

// Reset just sets the config back to the original. We still hold the
// critical section though.
void CProjTempConfigChange::Reset()
{
	ASSERT(m_bCritSection);
	ChangeConfig(m_pcrOriginal);
}


void CProjTempConfigChange::ChangeConfig(ConfigurationRecord *pcr)
{
	ASSERT(m_bCritSection);
	m_pProject->SetActiveConfig(pcr);
}

void CProjTempConfigChange::ChangeConfig(const CString& strConfigName)
{
	ASSERT(m_bCritSection);
	m_pProject->SetActiveConfig(strConfigName);
}

///////////////////////////////////////////////////////////////////////////////
// CProjTempProjectChange - used to temporarily change the active project
///////////////////////////////////////////////////////////////////////////////

CProjTempProjectChange::CProjTempProjectChange (CProject *pProject)
{

	m_pPrevProject = g_pActiveProject;
	g_pActiveProject = pProject;
}

CProjTempProjectChange::~CProjTempProjectChange ()
{
	Release ();
}

// Release resets the original project
void CProjTempProjectChange::Release ()
{
	g_pActiveProject = m_pPrevProject;
	m_pPrevProject = NULL; // probably doesn't matter, but what the hell...
}

///////////////////////////////////////////////////////////////////////////////
// GetTarget()
///////////////////////////////////////////////////////////////////////////////
CTargetItem* CProject::GetTarget(const TCHAR * pchTargetName)
{
	// Find the target item corresponding to a target name
	CTargetItem* pTarget;
	CString strKey = pchTargetName;
	strKey.MakeUpper();		// Case insensitive lookup
	if (!m_TargetMap.Lookup(strKey, (void* &)pTarget))
		return NULL;
	else
		return pTarget;
}

///////////////////////////////////////////////////////////////////////////////
// GetActiveTarget()
///////////////////////////////////////////////////////////////////////////////
CTargetItem* CProject::GetActiveTarget()
{
	ConfigurationRecord * pcr = GetActiveConfig();
	if (pcr == NULL)
		return NULL;

	return GetTarget(pcr->GetConfigurationName());
}

///////////////////////////////////////////////////////////////////////////////
// RegisterTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::RegisterTarget(const CString& strTargetName, CTargetItem* pTarget)
{
	// Check we have a configuration that matches the target
	int i;
	ConfigurationRecord* pcr;
	BOOL bFoundConfig = FALSE;
	int size = GetPropBagCount();
	for (i=0; i < size; i++)
	{
		pcr = (ConfigurationRecord*) m_ConfigArray[i];
		ASSERT(pcr);
		if (pcr->GetConfigurationName().CompareNoCase(strTargetName) == 0)
			bFoundConfig = TRUE;
	}
	if (!bFoundConfig)
		return FALSE;

	// Check the target item node
	ASSERT_VALID(pTarget);
	
	// Add this target to the target map
	CString strKey = strTargetName;
	strKey.MakeUpper();		// Case insensitive lookup
	m_TargetMap.SetAt(strKey, pTarget);

	// Make sure that this target is known by the build system interface
	g_BldSysIFace.GetTarget(strTargetName, (HBUILDER)this);

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// DeregisterTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::DeregisterTarget(const CString& strTargetName, CTargetItem* /*pTarget*/)
{
	// Remove the target from the target map
	CString strKey = strTargetName;
	strKey.MakeUpper();		// Case insensitive lookup
 	return m_TargetMap.RemoveKey(strKey);
}

///////////////////////////////////////////////////////////////////////////////
// RenameTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::RenameTarget(const CString& strTargetFrom, const CString& strTargetTo)
{
	// Get the old Target info structure
	CTargetItem* pTarget = GetTarget(strTargetFrom);

 	if (pTarget == NULL)
		return FALSE;

	// Remove the old entry in the map
	CString strKey = strTargetFrom;
	strKey.MakeUpper();
	m_TargetMap.RemoveKey(strKey);

	// Add the new entry	
	strKey = strTargetTo;
	strKey.MakeUpper();
	m_TargetMap.SetAt(strKey, pTarget);
	ASSERT(pTarget == GetTarget(strTargetTo));

	g_BldSysIFace.RenameTarget(strTargetFrom, strTargetTo);

	ConfigurationRecord * pcrConfig = ConfigRecordFromConfigName(strTargetFrom);
	ASSERT(pcrConfig != (ConfigurationRecord *)NULL);

	CProjTempConfigChange projTempConfigChange(this);
	projTempConfigChange.ChangeConfig(pcrConfig);
	VERIFY(SetStrProp(P_ProjConfiguration, strTargetTo));
	projTempConfigChange.Release();

	// are we renaming the active configuration?
	CString strActiveProject;
	GetStrProp(P_ProjActiveConfiguration, strActiveProject);

 	if (strTargetFrom == strActiveProject)
		SetStrProp(P_ProjActiveConfiguration, strTargetTo);

	// if we just renamed the default config, update it
	if (!m_strProjDefaultConfiguration.CompareNoCase(strTargetFrom))
		m_strProjDefaultConfiguration = strTargetTo;

	if (!m_strProjStartupConfiguration.CompareNoCase(strTargetFrom))
		m_strProjStartupConfiguration = strTargetTo;

	// Refresh the target combos
	CObList * plstCombos = CTargetCombo::GetCombos();
	POSITION pos = plstCombos->GetHeadPosition();
	while (pos != NULL)
	{
		CTargetCombo * pTargetCombo = (CTargetCombo *)plstCombos->GetNext(pos);
		pTargetCombo->RefreshTargets();
	}

	return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
// CreateTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::CreateTarget(const CString& strTargetName, CProjType* pProjType, const CString& strMirrorFrom /* = _T("") */)
{
	// Create the configuration for this target
	BOOL bRetVal = CreateConfig(strTargetName);

	CTargetItem* pTarget;
	if (strMirrorFrom.IsEmpty())
	{
		if (pProjType && 
		   (pProjType->GetUniqueTypeId() == CProjType::staticlib))
		{
			m_bCareAboutDefFiles = FALSE;
		}
		// Create the target item node for this target and
		// move it into the project tree
		pTarget = new CTargetItem();
	}
	else
	{
		// Mirroring a target
		pTarget = GetTarget(strMirrorFrom);
	}

	ASSERT(pTarget != NULL);

	// make this the target's config. current
	CProjTempConfigChange projTempConfigChange(this);
	projTempConfigChange.ChangeConfig(strTargetName);	

	// Set up the project type
	if (pProjType->IsSupported()) // may be adding first supported projtype
		m_bProjIsSupported = TRUE;

	SetStrProp(P_ProjOriginalType, *pProjType->GetName());

	if (strMirrorFrom.IsEmpty())
	{
		// move this new target into the project
		// (this will un-assign the build actions)
		pTarget->MoveInto(this);
	}
	else
	{
		// already got the target in the project, no
		// need for a move
	}

	// make this config. valid
	ConfigurationRecord * pcrTarg = pTarget->GetActiveConfig(TRUE);	// create
	ASSERT(pcrTarg != NULL);
	pcrTarg->SetValid(TRUE);

	// create a build instance
	g_buildengine.AddBuildInst(GetActiveConfig());

	// reset the project's config.
	projTempConfigChange.Release();

	bRetVal = RegisterTarget(strTargetName, pTarget);

	// Get the state of the workspace window
	LPPROJECTWORKSPACE pProjSysIFace = FindProjWksIFace();
    BOOL bWorkspaceInitialised = pProjSysIFace->IsWorkspaceInitialised() == S_OK;

	// If we have done the PN_WORKSPACE_INIT and we are not initialising or destroying the
	// project and we are creating a new fileset then send a notification
	if (bWorkspaceInitialised && m_bProjectComplete && strMirrorFrom.IsEmpty())
        theApp.NotifyPackages(PN_ADD_FILESET, (void *)pTarget);

    return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// DeleteTarget()
///////////////////////////////////////////////////////////////////////////////
BOOL CProject::DeleteTarget(const CString& strTargetName)
{
	// Delete a target, by first removing any references
	// to the target, and by removing the target item node
	// itself

	// If we only have 1 valid config for this target item
	// then we can remove the target item, otherwise not
	HBLDTARGET hTarget = g_BldSysIFace.GetTarget(strTargetName, (HBUILDER)this);
	HBLDTARGET hTargetNew = NO_TARGET;
	int nTargets = 0;
	CTargetItem* pTarget = GetTarget(strTargetName);
	ASSERT(pTarget != NULL);
	const CPtrArray* pConfigArray = pTarget->GetConfigArray();
	int nSize = pConfigArray->GetSize();
	for (int i = 0; i < nSize; i++)
	{
		ConfigurationRecord* pcr = (ConfigurationRecord*)pConfigArray->GetAt(i);
		if (pcr->IsValid())
		{
			nTargets++;
			if (hTargetNew == NO_TARGET)
			{
				// remember the target other than to be delted one
				CString strConfigName = pcr->GetConfigurationName();
				hTargetNew = g_BldSysIFace.GetTarget(strConfigName, (HBUILDER)this);
				if (hTargetNew == hTarget)
					hTargetNew = NO_TARGET;	
			}
		}
	} 
	
	// make this the target's config. current
	CProjTempConfigChange projTempConfigChange(this);
	ConfigurationRecord * pcrOld = GetActiveConfig();

	projTempConfigChange.ChangeConfig(strTargetName);
	ConfigurationRecord * pcrProj = GetActiveConfig();

	ConfigurationRecord * pcrTarg = pTarget->GetActiveConfig();

	// inform the graph of this target that it is being deleted
	g_buildengine.GetDepGraph(pcrProj)->SetGraphMode(Graph_Destroying);

	if (nTargets == 1)
	{
        // If we are not initialising or destroying the project then
		// send a notification to say that we have deleted a fileset
		if (!theApp.NotifyPackages(PN_QUERY_DEL_FILESET, (void *)pTarget))
				return FALSE;

		// Remove any dependencies on this fileset
		CProject * pProject;
		POSITION pos1 = m_lstProjects.GetHeadPosition();  // use our own private pos pointer
		while (pos1 != NULL)
		{
			pProject = (CProject *)m_lstProjects.GetNext(pos1);
			if ((pProject == NULL) || (!pProject->IsLoaded()))
			{
				continue ;
			}

			// Search the project tree for any nodes to delete
			CObList ol;
			int fo = CProjItem::flt_OnlyTargRefs;
			pProject->FlattenSubtree(ol, fo);

			POSITION pos = ol.GetHeadPosition();
			while (pos != NULL)
			{
				CProjectDependency * pProjDep = (CProjectDependency *)ol.GetNext(pos);
				
				// Is this a dependency on the fileset we are deleting if so then remove
				// the dependency
				if (pProjDep->GetProjectDep() == pTarget)
					pProjDep->MoveInto(NULL);
			}
		}
 
		if (m_bProjectComplete)
            theApp.NotifyPackages(PN_DEL_FILESET, (void *)pTarget);

		// move this old target out of the project
		// (this will un-assign the build actions)
		pTarget->MoveInto(NULL);
	}
	else
	{
		// un-assign the build actions for this mirored target
		CActionSlob::UnAssignActions(pTarget, (CPtrList *)NULL, pcrProj);
	}

	// remove pending dep update for this target
	RemoveItemsFromUpdateQueue((UINT)hTarget);

	// delete the build instance (graph + project)
	g_buildengine.RemoveBuildInst(pcrProj);

	// Reset only if pcrOld is not NULL, it might have been deleted already.
	projTempConfigChange.Release(pcrOld != (const ConfigurationRecord *)NULL);

	// filter the node that represent the target to be deleted if there is more target to show
	CBuildNode* pBldNode = GetBuildNode();
	CBuildViewSlob * pTargetSlob;
	pBldNode->InitBldNodeEnum();
	while (pBldNode->NextBldNodeEnum((void **)&pTargetSlob))
	{
		if (pTargetSlob->GetTarget() == hTarget)
		{
			if (nTargets > 1)
			{
				pTargetSlob->SetFilterTarget(hTargetNew);
				break;
			}
		}
	}

	BOOL bRetVal = DeregisterTarget(strTargetName, pTarget);

	// If the delete operation succeeded then save the target
	// so other packages can be notified.
	HBLDTARGET hSaveTarget;
	if (m_bProjectComplete)
		hSaveTarget = g_BldSysIFace.GetTarget(strTargetName, (HBUILDER)this);

	// Delete the configuration associated with this target
	bRetVal = bRetVal && DeleteConfig(strTargetName, "");

	// Refresh the target combos
	CObList * plstCombos = CTargetCombo::GetCombos();
	POSITION pos = plstCombos->GetHeadPosition();
	while (pos != NULL)
	{
		CTargetCombo * pTargetCombo = (CTargetCombo *)plstCombos->GetNext(pos);
		pTargetCombo->RefreshTargets();
	}

	// If we have deleted the default config then set the default config
	// to be a different one
	if (!m_strProjDefaultConfiguration.CompareNoCase(strTargetName))
	{
		CString strActiveProject;
		GetStrProp(P_ProjActiveConfiguration, strActiveProject);
		m_strProjDefaultConfiguration = strActiveProject;
	}

	return bRetVal;
}

void CProject::EndBatch()
{
	if (--m_nBatch <= 0)
	{
		CString strTarget;
		CTargetItem * pTarget;
		CString strProject;
		HBUILDER hBld;

	 	// For all filesets we force the corresponding target items
		// to empty their notfication lists
		// iterate over all projects
		g_BldSysIFace.InitBuilderEnum();
		while ((hBld = g_BldSysIFace.GetNextBuilder(strProject, TRUE)) != NO_BUILDER)
		{
			g_BldSysIFace.InitFileSetEnum(hBld);
			HFILESET hFileSet = g_BldSysIFace.GetNextFileSet(hBld);
			while (hFileSet)
			{
				pTarget = g_BldSysIFace.CnvHFileSet(hBld, hFileSet);
				pTarget->EmptyNotifyLists();
				hFileSet = g_BldSysIFace.GetNextFileSet(hBld);
			}
		}
	
		// Turn off batching
		m_nBatch = 0;
	}
}
void CProject::DirtyProjectEx()
{
	ASSERT(!m_bProjectDirty);
	m_bOkToDirty = FALSE; // prevents recursion
	if (m_bProjectComplete)
	{
		const CPath * pPath = GetFilePath();
		if (pPath->IsReadOnlyOnDisk() &&
			(!m_bProjIsExe) &&
			(_tcsicmp(pPath->GetExtension(), ".exe") != 0))
		{
			BOOL bIsSccActive = (g_pSccManager->IsBuilderControlled(HPROJECT(this)) == S_OK);

			CStringArray files;
			files.Add((const TCHAR*)*pPath);
			// if (g_bAlwaysExportMakefile)  // always do this
			{
				CPath path = *pPath;
				path.ChangeExtension(_T(".mak"));
				if (path.IsReadOnlyOnDisk() && (g_pSccManager->IsControlled((const TCHAR *)path) == S_OK))
				{
					files.Add((const TCHAR*)path);
				}
				path.ChangeExtension(_T(".dep"));
				if (g_bAlwaysExportDeps && path.IsReadOnlyOnDisk() && (g_pSccManager->IsControlled((const TCHAR *)path) == S_OK))
				{
					files.Add((const TCHAR*)path);
				}
			}
			if ((!m_bProjExtConverted) && ((!bIsSccActive) || (g_pSccManager->CheckOutReadOnly(files, FALSE, FALSE) != S_OK) || (pPath->IsReadOnlyOnDisk())))
			{
				CString strMsg;
				MsgBox(Information, MsgText(strMsg, IDS_WARN_PROJ_READ_ONLY, (const TCHAR *)*pPath));
			}
		}
	}
	m_bOkToDirty = TRUE;
	m_bProjectDirty = TRUE;
}

CDir & CProject::GetProjDir(ConfigurationRecord * pcr)
{
    if (pcr == NULL)
        pcr = GetActiveConfig();

    // Make sure we are dealing with a base config record
    pcr = (ConfigurationRecord *)pcr->m_pBaseRecord;

	CTargetItem * pTarget = GetTarget(pcr->GetConfigurationName());
	if (pTarget != (CTargetItem *)NULL)
	{
		const TCHAR * pchTargDir = (const TCHAR *)pTarget->GetTargDir();
		if (*pchTargDir != _T('\0'))
		{
			m_ActiveTargDir.CreateFromString(pchTargDir);
			return m_ActiveTargDir;
		}
	}

	m_ActiveTargDir = m_ProjDir;

	// it is reset by specific target, init in SetFile w/ m_ProjDir
	return m_ActiveTargDir;  
}

BOOL CProject::IsCustomBuildMacroComment(CObject* pObject)
{
	// the object must be a comment
	if (!pObject->IsKindOf(RUNTIME_CLASS(CMakComment))) {
		return FALSE;
	}
	CMakComment* pMakComment = (CMakComment *)pObject;

	// get the comment text and remove leading white space
	TCHAR* pc = pMakComment->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// look for the 'Begin Custom Macros' prefix
	CString strBeginMacros;
	strBeginMacros.LoadString(IDS_MAK_CUSTOM_BEGIN);
	if (_tcsnicmp(strBeginMacros, pc, strBeginMacros.GetLength()) == 0) {
		return TRUE;
	}
	return FALSE;
}

CCustomBuildTool g_DefaultCustomBuildTool;

BOOL CProject::ReadCustomBuildMacros(CMakFileReader& mr)
{
	// we can just ignore these macros because they're only
	// written out to satisfy nmake

	// read until we hit a comment (should be 'End Custom Macros')
	for (CObject* pObject = mr.GetNextElement();
		!pObject->IsKindOf(RUNTIME_CLASS(CMakComment));
		pObject = mr.GetNextElement()) {
		delete pObject;
	}

	// verify the ending comment is 'End Custom Macros'
	CMakComment* pMakComment = (CMakComment *)pObject;

	// get the comment text and remove leading white space
	TCHAR* pc = pMakComment->m_strText.GetBuffer(1);
	SkipWhite(pc);

	// look for the 'End Custom Macros' prefix
	BOOL bResult = FALSE;
	CString strEndMacros;
	strEndMacros.LoadString(IDS_MAK_CUSTOM_END);
	if (_tcsnicmp(strEndMacros, pc, strEndMacros.GetLength()) == 0) {
		bResult = TRUE;
	}

	delete pObject;
	return bResult;
}

BOOL CProject::WriteCustomBuildMacros(CMakFileWriter& mw, CString &strFiles )
{
	// Iterate through all the actions/tools for the current configuration
	// and set up the array of macros to write out.

	// The array of macros (fMacros) is a set of all possible macros.
	// Only those flagged are written to the makefile. This allows us
	// to easily combine multiple custom build rules and filter out
	// macros we don't want.

	BYTE fMacros[IDMACRO_LAST-IDMACRO_FIRST];
	memset(fMacros, 0, sizeof(BYTE)*(IDMACRO_LAST-IDMACRO_FIRST));

	// mark all macros unused initially
	SetMacroIdUsage(FALSE);
	
    // We need a custom build step from this project anyone will do.
	// This only checks the project level.
	CActionSlob* pCustomAction = NULL;
	CActionSlobList* pActions = GetActiveConfig()->GetActionList();
	for (POSITION pos = pActions->GetHeadPosition(); pos != NULL; ) {
		// get the action
		CActionSlob * pAction = (CActionSlob *)pActions->GetNext(pos);
		pCustomAction = pAction;
		break;

#if 0

		// get the action's tool
		CBuildTool* pTool = pAction->m_pTool;

		// macros are only valid for custom build tools
		if (pTool->IsKindOf(RUNTIME_CLASS(CCustomBuildTool))) {

			pCustomAction = pAction;

			// To figure out which macros are used, we get the command
			// and output strings for the custom build rule, mark all
			// macros as unused, expand the macros (which marks those
			// used), and then call GetMacroIdUsage.
			
			// get custom build outputs
			CProjItem* pItem = pAction->Item();
			CString strOutput;
			if (!((CCustomBuildTool*)pTool)->GetCustomBuildStrProp(pItem, P_CustomOutputSpec, strOutput))
				continue;	// can't get the outputs
		}

#endif

	}

	if (ExpandMacros((CString *)NULL, strFiles, NULL)) {

		// write out any macros the custom build rule might need
		for (int idMacro = IDMACRO_FIRST; idMacro <= IDMACRO_LAST; idMacro++) {
			// Don't write IDEDIR (it's in the environment).
			// Only write macros that are used.
			// Always write INPUTFILE because it's always used by $(SOURCE)
			if (idMacro != IDMACRO_IDEDIR &&
				(idMacro == IDMACRO_INPTFILE || GetMacroIdUsage(idMacro))) {
				fMacros[idMacro-IDMACRO_FIRST] = TRUE;
			}
		}
	}
			
	// Filter out those macros we don't want.
	// For now, we don't want: IDMACRO_INPTDIR, IDMACRO_INPTFILE, IDMACRO_INPTBASE
	fMacros[IDMACRO_INPTDIR-IDMACRO_FIRST] = 0;
	fMacros[IDMACRO_INPTFILE-IDMACRO_FIRST] = 0;
	fMacros[IDMACRO_INPTBASE-IDMACRO_FIRST] = 0;

	// determine if there are any macros to write
	BOOL bMacros = FALSE;
	for (int i = 0; i < IDMACRO_LAST-IDMACRO_FIRST; i++) {
		if (fMacros[i]) {
			bMacros = TRUE;
			break;
		}
	}

	// write out the macros
	if (pCustomAction && bMacros) {
		CString strComment;
		strComment.LoadString(IDS_MAK_CUSTOM_BEGIN);
		mw.WriteComment(strComment);
		g_DefaultCustomBuildTool.WriteMacros(mw, fMacros, pCustomAction);
		// ((CCustomBuildTool*)(pCustomAction->m_pTool))->WriteMacros(mw, fMacros, pCustomAction);
		strComment.LoadString(IDS_MAK_CUSTOM_END);
		mw.WriteComment(strComment);
	}

	return TRUE;
}

CPath CProject::GetMrePath(ConfigurationRecord* pcr)
{
	CPath pathIdb;

	pcr = (ConfigurationRecord*)pcr->m_pBaseRecord;

	// Get compiler tool.
	CBuildTool* pTool = NULL;
	CActionSlobList* pActions = pcr->GetActionList();
	if (NULL==pActions)
		return pathIdb;

	POSITION pos = pActions->GetHeadPosition();
	if (NULL==pos)
		return pathIdb;

	// Get CActionSlob* from pcr that matches this tool.  Assume that
	// the CActionSlobList can have multiple CActionSlob's since we
	// may be allowing more than one tool to be associated with a tool
	// eventually.
	while (NULL!=pos)
	{
		CActionSlob* pLastAction = (CActionSlob*)pActions->GetNext(pos);

		if (pLastAction->m_pTool->IsKindOf(RUNTIME_CLASS(CCCompilerTool)))
		{
			pTool = pLastAction->m_pTool;
			break;
		}
	}

	if (NULL==pTool)
		return pathIdb;


	// Get filename of minimal rebuild file(vc40.idb).
	CString strIdbFile;
	if (GetStrProp (pTool->MapLogical(P_OutputDir_Pdb), strIdbFile) == valid && !strIdbFile.IsEmpty() )
	{
		// Create target directory.
		CDir dirProj = GetWorkspaceDir();

        /* If this is an Xbox project, we need to use vc70 instead of
         * vc60 */
    	CProjType * pprojtype;
        pprojtype = pcr->m_pOwner->GetProjType();
        ASSERT(pprojtype);
        if(pprojtype && pprojtype->GetPlatform()->GetUniqueId() == xbox)
            strIdbFile += "vc70";
        else
		    strIdbFile += CActionSlob::szDefVCFile;
		VERIFY(pathIdb.CreateFromDirAndFilename(dirProj,strIdbFile));
		pathIdb.ChangeExtension(_T(".idb"));
	}
	return pathIdb;
}

POSITION CProject::m_posProjects = NULL;
CObList CProject::m_lstProjects;

void CProject::InitProjectEnum()
{
	m_posProjects = m_lstProjects.GetHeadPosition();
}

const CProject * CProject::NextProjectEnum(CString & strProject, BOOL bOnlyLoaded /* = TRUE */)
{
	// FUTURE: handle bOnlyLoaded flag

	// serious hack
	BOOL bNoName = FALSE;
	if (strProject.Compare(_T("<no name>"))==0)
		bNoName = TRUE;
	else
		strProject.Empty();

	const CProject * pProject;
	const CPath * pPath;
	while (m_posProjects!=NULL)
	{
		pProject = (const CProject *)m_lstProjects.GetNext(m_posProjects);
		if ((pProject != NULL) && (!bOnlyLoaded || pProject->IsLoaded()))
		{
			if (!bNoName) // hack: fails during destruction
			{
				// pProject->GetStrProp(P_ProjItemName, strProject);
				strProject = ((CProject *)pProject)->GetTargetName();
			}

			return pProject;
		}
	}
	
	return (const CProject *)NULL;
}

const CString & CProject::GetTargetName() { return m_bProjIsExe ? GetActiveConfig()->GetConfigurationName() : m_strTargetName; }

void ProjNameToWksName(CPath &rPath)
{
	// Get proper workspace dir
	ASSERT(g_pProjWksIFace);
	LPCSTR pszPath;
	VERIFY(SUCCEEDED(g_pProjWksIFace->GetWorkspaceDocPathName(&pszPath)));
	CPath pathWkspc;
	if ((pszPath!=NULL) && (*pszPath) && (pathWkspc.Create(pszPath)))
		rPath = pathWkspc;
	else
		rPath.ChangeExtension(WORKSPACE_EXT); // default for brand new workspace
}

///////////////////////////////////////////////////////////////////////////////
// WinslowF   Adding profiler back.

void CProject::OnUpdateProfile (CCmdUI* pCmdUI)
{
CString strMenuText;

	strMenuText.LoadString (FProfiling() ? IDS_STOP_PROFILE : IDS_PROFILE);

	pCmdUI->SetText (strMenuText);

	COleRef<IBuildSystem> pBldSysIFace;
	theApp.FindInterface(IID_IBuildSystem, (void**) pBldSysIFace.InOut());
// crappy to findinterface(self) but at least it fixes leak

	UINT tfl;
	UINT iTL;
	uniq_platform upID;
	COleRef<IBuildPlatforms> pIBldPlatforms;
	
	if (SUCCEEDED(theApp.FindInterface(IID_IBuildPlatforms, (void **)pIBldPlatforms.InOut()))) {
		pIBldPlatforms->GetCurrentPlatform(ACTIVE_BUILDER, &upID);
		pIBldPlatforms->GetPlatformLocalTLIndex(upID, &iTL);
//	    ASSERT(iTL != -1);	// iTL==-1 for unsupported platforms.
		if (iTL == -1)
		{
			pCmdUI->Enable(FALSE);
			return;
		}
		pIBldPlatforms->GetPlatformTLFlags(upID, iTL, &tfl);
	}
	
	BOOL fMtrcRemoteTL = !(tfl & TFL_LOCAL);

	BOOL g_fProfilerInstalled = TRUE;

	// Is the profiler installed?
	CString strProf;
	strProf.LoadString(INI_ProfilerInstalled);
	g_fProfilerInstalled = theApp.GetProfileInt("General", strProf, 0);

	int iAttrs;
	// now we want to keep the profile menu enabled al the time.
	pCmdUI->Enable (g_fProfilerInstalled && (FProfiling() ||
					((pBldSysIFace != NULL && (pBldSysIFace->IsActiveBuilderValid() == S_OK) &&
						(SUCCEEDED(pBldSysIFace->GetTargetAttributes(ACTIVE_BUILDER, &iAttrs))) &&
							(iAttrs & ImageExe))&&
								/*(pBldSysIFace->IsProfileEnabled(ACTIVE_BUILDER) == S_OK) && */
									!(pIBldPlatforms && fMtrcRemoteTL))));

}


///////////////////////////////////////////////////////////////////////////////
void CProject::OnProfile()
{
	CProfileDlg pDlg;

	// no build system or active project?
	COleRef<IBuildSystem> pBldSysIFace; // makes no sense in build package JAYK
	theApp.FindInterface(IID_IBuildSystem, (void **)pBldSysIFace.InOut());

	if (pBldSysIFace == NULL || (pBldSysIFace->IsActiveBuilderValid() != S_OK))
	{
		InformationBox(IDS_NO_PROFILE);
		return;
	}

	if (FProfiling())
	{
		ASSERT(g_pSpawner != NULL);
		g_pSpawner->CancelSpawn();
	}
	else
	{
		int iBuildType;
		pBldSysIFace->GetBuilderType(ACTIVE_BUILDER, &iBuildType);
		if (iBuildType == InternalBuilder)
		{
			UINT uState;
			pBldSysIFace->TargetState(&uState, NULL, NULL, NO_TARGET, ACTIVE_BUILDER);
			if (pBldSysIFace->IsProfileEnabled(ACTIVE_BUILDER) == S_OK && (uState == TRG_STAT_Current))
				pDlg.DoModal();
			else
				InformationBox(IDS_NO_PROFILE);
		}
		else
		{
			pDlg.DoModal();

		}
	}
}

// the following code is for loading old MDP and VCP files -- do not modify

BOOL CProject::LoadFromVCP(CStateSaver& stateSave)
{
	BOOL bRetVal;

	// Figure out if the .mak is newer than the .mdp.
	ASSERT(stateSave.GetFileName());
	
	CPath  MDPPath;
	BOOL bNewerMak = TRUE;

	if (MDPPath.Create(stateSave.GetFileName()) && MDPPath.ExistsOnDisk())
	{
		FILETIME ftMdp, ftMak;

		VERIFY(MDPPath.GetFileTime(&ftMdp));

		CFileRegFile * pRegFile = (CFileRegFile *)g_FileRegistry.GetRegEntry(m_hndFileReg);
		if (pRegFile->GetFileTime(ftMak))
		{
		 	if (CFileRegEntry::MyCompareFileTime(&ftMak, &ftMdp) <= 0)
				bNewerMak = FALSE;
		}
	}

	// If the .mak is newer than the .mdp, the cached CActionSlob option strings
	// are not valid. Tell the CActionSlob's to ignore them. 

	CActionSlob::IgnoreCachedOptions(TRUE);

  	// Try to load from both streams.
	bRetVal = LoadExternalFromVCP(stateSave, IsExeProject());
	bRetVal = LoadInternalFromVCP(stateSave, IsExeProject()) && bRetVal;
 
 	// Note: At this point, if bRetval is false, then the VCP file is only
	// partially loaded and we may be in some sort of weird state, especially
	// w.r.t Conifiguration.
	if (bRetVal)
	{
		ASSERT_VALID (this);

		m_bProjectComplete = TRUE;
		m_bPrivateDataInitialized = TRUE;
		m_bPrivateDataInitializedFromOptFile = TRUE;
	}
	else
	{
		COptionTreeCtl::sm_TreeState.Clear();

		if (!m_bProjIsExe)
			InitPrivateData();
		else
			InitPrivateDataForExe();
	}

	//  At this point, we can enable the change config notification
	SetActiveConfig(m_strProjActiveConfiguration, FALSE);

	m_bNotifyOnChangeConfig = TRUE;
    	if (FindProjWksIFace()->IsWorkspaceInitialised() == S_OK)
		theApp.NotifyPackages (PN_CHANGE_CONFIG) ;

	PFILE_TRACE ( "CProject::LoadFromVCP returning %i\n",bRetVal);
	return bRetVal;
}

///////////////////////////////////////////////////////////////////////////////
// Convert the vcp file for an external makefile so that the contained
// settings can be retained on a corresponding internal makefile generated
// when the external makefile is loaded.
BOOL CProject::ConvertVCPFile(CArchive & ar)
{
	CPtrList lstDebugConfigs;
    CPtrList lstReleaseConfigs;
	BOOL bRetval = TRUE;
	BOOL bDataExists = FALSE;
	CString strDebugConfig, strReleaseConfig, str;

	VERIFY(strDebugConfig.LoadString(IDS_DEBUG_CONFIG));
	VERIFY(strReleaseConfig.LoadString(IDS_RELEASE_CONFIG));
 
	// Construct lists of debug/release configs
	ConfigurationRecord * pcr;
	CString strConfigName;
	const CPtrArray & ppcr = *GetConfigArray();
	int ccr = m_ConfigArray.GetSize();
	for (int icr = 0; icr < ccr; icr++)
	{
		pcr = (ConfigurationRecord *)ppcr[icr];
		strConfigName = pcr->GetConfigurationName();
		if (strConfigName.Find(strDebugConfig) > 0)
			lstDebugConfigs.AddTail(pcr);
		if (strConfigName.Find(strReleaseConfig) > 0)
			lstReleaseConfigs.AddTail(pcr);
	}

  	// Is there any data in this stream.
	ar >> ((long&) bDataExists);

	if (!bDataExists)
	{
		// No data, so we may need to fail the operation
		// so that we will init this data.
  	}
	else
	{
 		BOOL		bHasReleaseConfig = FALSE;
 		DWORD		iConfig, cConfigs;
		CPtrList *	plstpcr;

		// Load the state of the builder
//		if (!CActionSlob::LoadFromArchiveVCP(ar))
//	 		AfxThrowArchiveException (CArchiveException::badSchema);

		// Load the state of the Project.Settings option tree-control
		if (!COptionTreeCtl::LoadOptTreeStore(ar))
 	 		AfxThrowArchiveException (CArchiveException::badSchema);

 		ar >> cConfigs;

		for (iConfig=0 ; iConfig<cConfigs ; ++iConfig)
		{
			// Read the name of the configuration, create that
			// configuration, and make it active:
			ar >> str;

 			// Do we recognize the configuration name as one of our
			// standard configs, i.e. debug/release, if so then we
			// can retain the information
			if (str == strDebugConfig)
 				plstpcr = &lstDebugConfigs;
  			else if (str == strReleaseConfig)
 				plstpcr = &lstReleaseConfigs;
			else
				plstpcr = NULL;
 
			// Set the other properties for this configuration:
			ar >> str;
			SetStrPropConfigs(plstpcr, P_Proj_CmdLine, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_Proj_RebuildOpt, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_Proj_Targ, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_Proj_BscName, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_ProjClsWzdName, str);

 			// Skip over platform name, we cannot change the platform
			// for projects in internal makefiles.
			ar >> str;

			// Set debug page properties
  			ar >> str;
			SetStrPropConfigs(plstpcr, P_Caller, str);
			ar >> str;
			SetStrPropConfigs(plstpcr, P_WorkingDirectory, str);
			ar >>  str;
 			SetStrPropConfigs(plstpcr, P_Args, str);
			
			// Read the additional DLLs but we don't set them like
			// we used to
			ar >> str;
 			
			ar >> str;
			SetStrPropConfigs(plstpcr, P_RemoteTarget, str);
		}

		// Get the name of the current configuration:
		ar >> str;  // We don't use it!
 
		// Check the EOR marker.
		DWORD dwT;

		ar >> dwT;
		if (dwT != dwExtEOR)
			AfxThrowArchiveException (CArchiveException::badSchema);
	}

	return bRetval;
}

///////////////////////////////////////////////////////////////////////////////
// Load from our external project stream.
BOOL CProject::LoadExternalFromVCP(CStateSaver& stateSave, BOOL bIsExternal)
{
	BOOL bRetval = TRUE;
	BOOL bDataExists = FALSE;
	CString strDebugConfig, strReleaseConfig;
	CInitFile fileInit;
	ASSERT(stateSave.IsLoading());
	// Open file usually takes two strings in case we are writing to
	// the reg DB, but the project should never write to the reg DB.
	//
	if (!stateSave.OpenFile(fileInit, PROJ_MSF_PROJEXTINFO, NULL, NULL))
		return FALSE;

	CArchive ar ( &fileInit, CArchive::load | CArchive::bNoFlushOnDelete);
	CString str, str2;
	int fPromptForDlls;
	UINT nFormatVersion;
	// Have to set this to 0 because of a bug in CRuntimeClass::Load which
	// only loads a word:
	UINT wSchemaNum = 0l;

	const UINT nDolphinVersionNumber = 0x00020054;
	const UINT nDolphinReleaseVersion = 0x00020000;
	const UINT nDolphinLastCompatVCP = 0x00020051;

	VERIFY(strDebugConfig.LoadString(IDS_DEBUG_CONFIG));
	VERIFY(strReleaseConfig.LoadString(IDS_RELEASE_CONFIG));

	TRY
	{
		ar >> ((long&) nFormatVersion);

		// For the VCP files, the formats must match exactly.
		if (nFormatVersion < 40000)
		{
			if ((nFormatVersion != nDolphinReleaseVersion) && (nFormatVersion < nDolphinLastCompatVCP|| nFormatVersion > nDolphinVersionNumber))
				AfxThrowArchiveException (CArchiveException::badSchema);
			else
			{
				// Convert old vc 2.0 settings here, but only if we are loading 
				// an external project--if so then we can read the data properly.
				if (bIsExternal)
					ConvertVCPFile(ar);
			}
		}
		else if (nFormatVersion >= 50000)
		{
			// This is more or a feel good kind of thing.  This will probably never pass this test,
			// but it's a good sanity check
			AfxThrowArchiveException (CArchiveException::badSchema);
		}

		// Is there any data in this stream.
		ar >> ((long&) bDataExists);

		if (!bDataExists)
		{
			// No data, so we may need to fail the operation
			// so that we will init this data.
			m_hOPTData = NULL;
			bRetval = !bIsExternal;
 		}
		else
		{
			// We have data, but are we loading an external
			// project, if so then we can read it properly.
			if (bIsExternal)
			{
				// Load the state of the builder
				if (!CActionSlob::LoadFromArchiveVCP(ar))
	 				AfxThrowArchiveException (CArchiveException::badSchema);

				// Load the state of the Project.Settings option tree-control
				if (!COptionTreeCtl::LoadOptTreeStore(ar))
		 			AfxThrowArchiveException (CArchiveException::badSchema);

				BOOL	bHasReleaseConfig = FALSE;
				DWORD	iConfig, cConfigs;

				ar >> cConfigs;

				for (iConfig=0 ; iConfig<cConfigs ; ++iConfig)
				{
					// Read the name of the configuration, create that
					// configuration, and make it active:
					ar >> str;

					// Keep a count of whether we have
					// a config named release or not.
					bHasReleaseConfig = (bHasReleaseConfig || (str == strReleaseConfig));

					CreateConfig(str);
					SetStrProp(P_ProjActiveConfiguration, str);

					// Set the other properties for this configuration:
					ar >> str;
					SetStrProp(P_ExtOpts_CmdLine, str);
					ar >> str;
					SetStrProp(P_ExtOpts_RebuildOpt, str);
					ar >> str;
					SetStrProp(P_ExtOpts_Targ, str);
					ar >> str;
					SetStrProp(P_ExtOpts_BscName, str);
					
					// This property is now defunct
					// ar >> str;
					//SetStrProp(P_ExtOpts_ClsWzdName, str);

                    ar >> str2;

					ar >> str;
					SetStrProp(P_Caller, str);

		 			CPlatform *	pPlatform;
					// need to translate from "official name" to "UI description"
					// also, platform may not exist
 					if (g_prjcompmgr.LookupPlatformByOfficialName(str2, pPlatform))
					{
						SetStrProp(P_ExtOpts_Platform, *(pPlatform->GetUIDescription()));
						if (!pPlatform->IsSupported())
 							InformationBox(IDS_EXE_NOT_SUPPORTED, str);
					}
					else
					{
						// Display a message box stating that we don't support this
						// platform
 						InformationBox(IDS_EXE_NOT_SUPPORTED, str);

						CPlatform * pPlatform = new CPlatform(str2, unknown_platform);
						// Register dynamic platform so deleted on exit
						g_prjcompmgr.RegisterUnkProjObj(pPlatform);

						SetStrProp(P_ExtOpts_Platform, *pPlatform->GetUIDescription());
					}

					ar >> str;
					SetStrProp(P_WorkingDirectory, str);
					ar >> str;

					// If the args are already set then we don't
					// override them. This allows args from the cmd line to
					// override those in the vcp file
					CString strOldArgs;
					GetStrProp(P_Args, strOldArgs);
					if (strOldArgs.IsEmpty())
						SetStrProp(P_Args, str);

					ar >> (LONG&)fPromptForDlls;
					SetIntProp(P_PromptForDlls, fPromptForDlls);
					ar >> str;
					SetStrProp(P_RemoteTarget, str);

					// read in the Java properties

					// get the current platform
//					CPlatform* pPlatform = GetCurrentPlatform();
					ASSERT(pPlatform != NULL);
					if (pPlatform != NULL && pPlatform->GetUniqueId() == java)
					{
						int nValue;

						// class name
						ar >> str;
						SetStrProp(P_Java_ClassFileName, str);

						// debug using browser/stand-alone interpreter
						ar >> (LONG&)nValue;
						SetIntProp(P_Java_DebugUsing, nValue);

						// browser name
						ar >> str;
						SetStrProp(P_Java_Browser, str);

						// stand-alone interpreter name
						ar >> str;
						SetStrProp(P_Java_Standalone, str);
					
						// param source: html page or user
						ar >> (LONG&)nValue;
						SetIntProp(P_Java_ParamSource, nValue);

						// HTML page
						ar >> str;
						SetStrProp(P_Java_HTMLPage, str);
					
						// temp HTML page
						ar >> str;
						SetStrProp(P_Java_TempHTMLPage, str);
					
						// args in HTML form
						ar >> str;
						SetStrProp(P_Java_HTMLArgs, str);

						// command line args
						ar >> str;
						// allow command line args to override those in the VCP file
						CString strJavaOldArgs;
						GetStrProp(P_Java_Args, strJavaOldArgs);
						if (strJavaOldArgs.IsEmpty())
							SetStrProp(P_Java_Args, str);

						// stand-alone interpreter args
						ar >> str;
						SetStrProp(P_Java_StandaloneArgs, str);
						
						// debug stand-alone as applet or application
						ar >> (LONG&)nValue;
						SetIntProp(P_Java_DebugStandalone, nValue);
					}

				}

				// Did we find a release config, if not
				// and we are not an exe-project then we
				// had better create a release config.
				if (!m_bProjIsExe && !bHasReleaseConfig)
				{
					// Add the release config!

					CPath pathT;

					pathT = *GetFilePath();

					CreateConfig(strReleaseConfig);
					SetStrProp(P_ProjActiveConfiguration, strReleaseConfig);

					// Set the default properties for the release configuration
					str = "NMAKE /f ";
					pathT.ChangeExtension(".mak");
					str += pathT.GetFileName();
					SetStrProp(P_ExtOpts_CmdLine, str);

					str = "/a";
					SetStrProp(P_ExtOpts_RebuildOpt, str);

					pathT.ChangeExtension(".exe");
					str = pathT.GetFileName();
					SetStrProp(P_ExtOpts_Targ, str);
					SetStrProp(P_Caller, str);

					(void) GetPlatformDescriptionString(str, str2);
					SetStrProp(P_ExtOpts_Platform, str2);

					pathT.ChangeExtension(".bsc");
					str = pathT.GetFileName();
					SetStrProp(P_ExtOpts_BscName, str);

					pathT.ChangeExtension(".clw");
				
					// This property is now defunct.
					//str = pathT.GetFileName();
					//SetStrProp(P_ExtOpts_ClsWzdName, str);

					str = _T("");
					SetStrProp(P_WorkingDirectory, str);
					SetStrProp(P_Args, str);
					SetIntProp(P_PromptForDlls, 1);
					SetStrProp(P_RemoteTarget, str);
					SetCurrentConfigAsBase();
				}

				// Get the name of the current configuration:
				ar >> str;
				SetStrProp(P_ProjActiveConfiguration, str);

				// Check the EOR marker.
				DWORD dwT;

				ar >> dwT;
				if (dwT != dwExtEOR)
					AfxThrowArchiveException (CArchiveException::badSchema);
			}
			else
			{
				// We found data but we are not really
				// loading an external project so just
				// get a pointer to the external data
				// so we can write it back later.
				m_hOPTData = fileInit.GetInitData();
			}
		}

		ar.Close ();
		fileInit.Close();
	}
	CATCH_ALL(e)
	{
		#ifdef _DEBUG
		AfxDump(e);
		TRACE("\n");
		#endif
		fileInit.Abort();
		bRetval = FALSE;
	}
	END_CATCH_ALL

	return bRetval;
}

///////////////////////////////////////////////////////////////////////////////
// Load from out internal project stream
BOOL CProject::LoadInternalFromVCP(CStateSaver& stateSave, BOOL bIsExternal)
{
	BOOL bRetval = TRUE;
	BOOL bDataExists = FALSE;
	CInitFile fileInit;
	ASSERT(stateSave.IsLoading());
	// Open file usually takes two strings in case we are writing to
	// the reg DB, but the project should never write to the reg DB.
	//
	if (!stateSave.OpenFile(fileInit, PROJ_MSF_PROJINTINFO, NULL, NULL))
		return FALSE;

	CArchive ar ( &fileInit, CArchive::load | CArchive::bNoFlushOnDelete);
	CString str, str2, strFirstConfig, strCurConfig;
	UINT nFormatVersion;
	// Have to set this to 0 because of a bug in CRuntimeClass::Load which
	// only loads a word:
	UINT wSchemaNum = 0l;

	TRY
	{
		ar >> ((long&) nFormatVersion);

		if ((nFormatVersion < 40000) || (nFormatVersion >= 50000))
			AfxThrowArchiveException (CArchiveException::badSchema);

		// Do we have any data in this stream.
		ar >> ((long&) bDataExists);
		if (!bDataExists)
		{
			// No we don't have any data, so we
			// may have to fail the loading of the
			// vcp file in order to init the data
			m_hOPTData = NULL;
			bRetval = bIsExternal;
 		}
		else
		{
			// We have some data in the stream but
			// are we attempting to load an internal
			// project, if so then we load the data
			if (!bIsExternal)
			{
				// Load the state of the builder
				if (!CActionSlob::LoadFromArchiveVCP(ar))
	 				AfxThrowArchiveException (CArchiveException::badSchema);

				// Load the state of the Project.Settings option tree-control
				if (!COptionTreeCtl::LoadOptTreeStore(ar))
		 			AfxThrowArchiveException (CArchiveException::badSchema);

				ar >> strCurConfig;
				if (ConfigRecordFromConfigName ( strCurConfig ) == NULL )
				{
					CString strmes;
					GetStrProp  (P_ProjActiveConfiguration, strFirstConfig);
/* no longer meaningful
					MsgBox (  Information,
							  MsgText ( strmes,
										IDS_VCP_UNKNOWN_CONFIG,
										(const TCHAR *) strCurConfig,
										(const TCHAR *) strFirstConfig
									   )
							);
 */
					strmes.Empty ();
					strCurConfig = strFirstConfig;

				}

				// Make sure this stream is for us:
				ar >> str;
				GetMoniker (str2);
				// GetMonker will most likely return a .dsp file.  The problem is that we are looking
				// for a .mak file.  Solution: hack hack hack and change the extension.

				CPath cpTmp;
				cpTmp.Create (str2);
				cpTmp.ChangeExtension ("mak");
				str2 = cpTmp.GetFileName ();

				if (CompareMonikers(str, str2) != 0 ||
					CRuntimeClass::Load (ar, &wSchemaNum) != GetRuntimeClass() ||
					wSchemaNum != GetRuntimeClass()->m_wSchema
				   )
					AfxThrowArchiveException(CArchiveException::badSchema);

				if (!SerializeProps(ar))
					AfxThrowArchiveException(CArchiveException::generic);
			}
			else
			{
				// Not loading an internal project so
				// just get a pointer to the stream
				// data so we can later restore it.
				m_hOPTData = fileInit.GetInitData();
			}
		}

		ar.Close ();
		fileInit.Close();
	}
	CATCH_ALL(e)
	{
		#ifdef _DEBUG
		AfxDump(e);
		TRACE("\n");
		#endif
		fileInit.Abort();
		bRetval = FALSE;
	}
	END_CATCH_ALL

	//  If the current configuration read in from the make is different from what
	//  we got from the MSF file, we need to set it again with SetStrProp.  This is
	//  Because Serialize props doesn't call SetXXXProp as it reads the props in:
	if (bRetval &&
		!bIsExternal &&	// don't need to check this for external makefiles
		(GetActiveConfig()->GetConfigurationName () != strCurConfig ||
		 m_strProjActiveConfiguration != strCurConfig)
	   )
	{			   
		SetStrProp(P_ProjActiveConfiguration, strCurConfig);
	}

	return bRetval;
}

UINT CProject::GetGlyphIndex()
{
	if (IsExeProject() || (GetProjType() == NULL))
		return 0;
	else if (GetProjType()->GetPlatform()->GetUniqueId() == java)
		return 2;
#ifdef VB_MAKEFILES
	else if ( GetProjType()->GetUniqueTypeId() == CProjType::exttarget && m_bVB == TRUE )
		return 1;
#endif
	else if ( /* UNDONE: test for C++ project */ 0 )
		return 1;


	return 0;
}
///////////////////////////////////////////////////////////////////////////////
#ifdef PROJ_LOG
void LogProjectState (
					const CObList &rlist,
					CProjItem	*pItemStart,
					CProject *pProject
					)
{
#if 0
	POSITION pos;
	CProjType *pProjType;
	const CPtrList *pol;
	CString str, str1;
	CBuildTool * pSchTool;
	COptionHandler *popthdlr;


	if (pProject == pItemStart)
	{
	    CString strName;
	    pProject->GetName(strName);
		PBUILD_TRACE ("Begining build with project \"%s\"\n", (const TCHAR *)strName );
		ASSERT (!pProject->m_bProjIsExe);
	}
	else
	{
		pItemStart->GetStrProp ( P_ProjItemName, str );
		PBUILD_TRACE ("Begining build with project \"%s\", with item \"%s\"\n",
			(const TCHAR *) *pProject->GetFilePath(), (const TCHAR *) str );

	}
	pItemStart->GetStrProp (P_ProjOriginalType, str );
	pItemStart->GetStrProp (P_ProjOriginalType, str1 );
	PBUILD_TRACE ("Active configuration is %s (based on %s)\n\n",
		(const TCHAR *) str, (const TCHAR *) str1 );

	if (pProject == pItemStart)
	{
		PBUILD_TRACE ("Project's tools are:\n");
		VERIFY ( g_prjcompmgr.LookupProjTypeByName( str1, pProjType ));

		pol = pProjType->GetToolsList ();
		for ( pos = pol->GetHeadPosition (); pos != NULL; )
		{
			pSchTool = (CBuildTool *) pol->GetNext (pos);
			// if (!pSchTool->IsKindOf ( RUNTIME_CLASS ( CSchmoozeTool ))) continue;
			popthdlr = pSchTool->GetOptionHandler();
			str.Empty();
			if (popthdlr)
			{
				g_prjoptengine.SetOptionHandler (popthdlr);
				g_prjoptengine.SetPropertyBag (pProject);
				g_prjoptengine.GenerateString (str);
			}
			else str = " (No Flags) ";

			PBUILD_TRACE ("			\"%s\" with flags \"%s\"\n",
						  (const TCHAR *) *pSchTool->GetName(), (const TCHAR *) str);
		}
	}
	PBUILD_TRACE ("\n");
#endif
#if 0
	for (pos = rlist.GetHeadPosition (); pos != NULL; )
	{
		pItem = (CFileItem *) rlist.GetNext (pos);
		if (!pItem->IsKindOf ( RUNTIME_CLASS ( CFileItem ))) continue;
		PBUILD_TRACE ("File Item: \"%s\"\n",
			(const TCHAR *) *pItem->GetFilePath () );
		str = "";
		MakeQuotedString (pItem->GetActiveConfig()->GetTargetFilesArray (), str );
		PBUILD_TRACE ("       Targets: %s\n", (const TCHAR *) str);

		PBUILD_TRACE ("\n");
	}
#endif
}

#endif // PROJ_LOG

//////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////
CTargIncl::CTargIncl()
{
	m_pHead = NULL;
	m_hBld = NO_BUILDER;
}
///////////////////////////////////////////
// destructor:
// remove all elements
///////////////////////////////////////////
CTargIncl::~CTargIncl()
{
	RemoveAll();
}

///////////////////////////////////////////
// remove all elements
///////////////////////////////////////////
void CTargIncl::RemoveAll()
{
	m_cs.Lock();
	CItem * pCur = m_pHead;
	while (pCur)
	{
		m_pHead = pCur->m_pNext;
		delete pCur;
		pCur = m_pHead;
	}
	m_pHead = NULL;
	m_cs.Unlock();
}

///////////////////////////////////////////
// lookup for a particular target
///////////////////////////////////////////
BOOL CTargIncl::Lookup (HBLDTARGET hTarget, CString & strIncls)
{
	BOOL bRet = FALSE;
	m_cs.Lock();
	CItem * pCur = m_pHead;
	while (pCur)
	{
		if (pCur->m_hTarget == hTarget)
		{
			strIncls = pCur->m_strIncls;
			bRet = TRUE;
			break;
		}
		pCur = pCur->m_pNext;
	}
	m_cs.Unlock();
	return bRet;
}

/////////////////////////////////////
// remove an element given a target
/////////////////////////////////////
BOOL CTargIncl::Remove (HBLDTARGET hTarget)
{
	BOOL bRet = FALSE;
	m_cs.Lock();
	CItem * pCur = m_pHead;
	CItem * pPrev = m_pHead;
	while (pCur)
	{
		// found the element
		// so must remove
		if (pCur->m_hTarget == hTarget)
		{
			// if it is in the head position
			// adjust head location,
			// otherwise connect prev with
			// the next element
			if (pCur == m_pHead)
				m_pHead = pCur->m_pNext;
			else
			{
				ASSERT (pPrev);
				pPrev->m_pNext = pCur->m_pNext;
			}
			bRet = TRUE;
			// removing the element
			delete pCur;
			break;
		}
		// still not found, so move
		// forward.
		pPrev = pCur;
		pCur = pCur->m_pNext;
	}
	m_cs.Unlock();
	return bRet;
}

////////////////////////////////////
// insert an element in the list
// replacing it if the hTarget is already
// in the list
////////////////////////////////////
void CTargIncl::SetAt (HBLDTARGET hTarget, CString & strIncls)
{
	BOOL bFound = FALSE;
	m_cs.Lock();
	CItem * pCur = m_pHead;
	// search if hTarget element is in the list
	while (pCur)
	{
		// if it is in the list, just
		// replace the string includes:
		if (pCur->m_hTarget == hTarget)
		{
			pCur->m_strIncls = strIncls;
			bFound = TRUE;
			break;
		}
		pCur = pCur->m_pNext;
	}
	// not in the list, so must create a new item.
	if (!bFound)
	{
		pCur = new CItem;
		pCur->m_hTarget = hTarget;
		pCur->m_strIncls = strIncls;
		pCur->m_pNext = m_pHead;
		m_pHead = pCur;
	}
	m_cs.Unlock();
}
////////////////////////////////////
// Initialize the list with hTarget and includes
////////////////////////////////////
void CTargIncl::Init (HBUILDER hBld)
{
	// clean up:
	CString strIncls;
	HBLDTARGET hTarget;
	CString strTargetName;
	CTargetItem * pTargetItem;
	CBuildTool * pTool;
	BOOL bFoundTool = FALSE;
	m_cs.Lock();
	RemoveAll();
	ASSERT(hBld);
	m_hBld = hBld;
	CProject * pProject = (CProject *)hBld;
	if (m_hBld)
	{
		ASSERT_VALID(pProject);
		pProject->InitTargetEnum();
		while (pProject->NextTargetEnum (strTargetName, pTargetItem))
		{
			hTarget = g_BldSysIFace.GetTarget(strTargetName, m_hBld);
			ASSERT (hTarget);
			CProjTempConfigChange projTempConfigChange(pProject);
			projTempConfigChange.ChangeConfig(strTargetName);
			ASSERT (pTargetItem);
			bFoundTool = FALSE;
			g_prjcompmgr.InitBuildToolEnum();
			while (g_prjcompmgr.NextBuildTool(pTool))
			{
				if (pTool->IsKindOf(RUNTIME_CLASS (CCCompilerTool)))
				{
					bFoundTool = TRUE;
					break;
				}
			}
			if (bFoundTool)
			{
				pTool->GetIncludePathFromOptions(pTargetItem, strIncls);
				SetAt (hTarget, strIncls);
				strIncls.Empty();
			}
			hTarget = NULL;
		}
	}
	m_cs.Unlock();

}
///////////////////////////////////////////////////////////////
// Initialize the list with hTarget and includes
////////////////////////////////////
void CTargIncl::AddTarget (HBLDTARGET hTarget)
{
	// clean up:
	CString strIncls;
	CString strTargetName;
	CTargetItem * pTargetItem;
	CBuildTool * pTool;
	BOOL bFoundTool = FALSE;
	m_cs.Lock();

	// Get the active project:
	ASSERT (hTarget);
	ASSERT (m_hBld);
	pTargetItem = g_BldSysIFace.CnvHTarget(NULL, hTarget);
	g_BldSysIFace.GetTargetName(hTarget, strTargetName, m_hBld);
	CProjTempConfigChange projTempConfigChange((CProject *)m_hBld);
	projTempConfigChange.ChangeConfig(strTargetName);
	ASSERT (pTargetItem);
	bFoundTool = FALSE;
	g_prjcompmgr.InitBuildToolEnum();
	while (g_prjcompmgr.NextBuildTool(pTool))
	{
		if (pTool->IsKindOf(RUNTIME_CLASS (CCCompilerTool)))
		{
			bFoundTool = TRUE;
			break;
		}
	}
	if (bFoundTool)
	{
		pTool->GetIncludePathFromOptions(pTargetItem, strIncls);
		SetAt (hTarget, strIncls);
	}
	m_cs.Unlock();

}
///////////////////////////////////////////////////////////////

static TCHAR szInterpreters[] = _T("Interpreters");
static TCHAR szBrowser[] = _T("Browser");
static TCHAR szStandalone[] = _T("Stand-alone interpreter");
static TCHAR szDefault[] = _T("<unknown>");

BOOL GetBrowserPath(CString& strBrowserPath)
{
	strBrowserPath.Empty();

	// get the name of the browser from the registry
	CString strBrowser = GetRegString(szInterpreters, szBrowser, szDefault);

	// is the browser name specified in the registry?
	if (strBrowser == szDefault)
	{
		// default to IE
		VERIFY(strBrowser.LoadString(IDS_JAVA_BROWSER_EXE));

		// fill in the registry
		WriteRegString(szInterpreters, szBrowser, strBrowser);
	}

	// do we have a full path the browser already, or do we need to search for it?
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szDir[_MAX_DIR];
	_tsplitpath(strBrowser, szDrive, szDir, NULL, NULL);
	if (_tcslen(szDrive) > 0 && _tcslen(szDir) > 0)
	{
		strBrowserPath = strBrowser;
	}
	else
	{
		// construct the path to the registry entry we want
		// HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\App Paths\iexplore.exe
		TCHAR szIERegPath[_MAX_PATH];
		_tcscpy(szIERegPath, REGSTR_PATH_APPPATHS);
		_tcscat(szIERegPath, _T("\\"));
		_tcscat(szIERegPath, strBrowser);

		// open the registry
		HKEY hkeyIE;
		if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szIERegPath, 0, KEY_READ, &hkeyIE) == ERROR_SUCCESS)
		{

			// get the full path to IE
			DWORD dwType;
			TCHAR szIEFileName[_MAX_PATH];
			DWORD dwData = _MAX_PATH;
			if (RegQueryValueEx(hkeyIE, NULL, NULL, &dwType, (unsigned char*)szIEFileName, &dwData) == ERROR_SUCCESS)
			{

				BOOL bVersionOk = FALSE;

				// we only want to do a version check if the browser is iexplore.exe
				CString strBrowserT = strBrowser;
				strBrowserT.MakeLower();
				CString strBrowserExe;
				VERIFY(strBrowserExe.LoadString(IDS_JAVA_BROWSER_EXE));
				if (strBrowserT.Find(strBrowserExe) != -1)
				{

					// get the version number of this copy of IE

					// get the version info size
					DWORD dwHandle;
					DWORD dwVerInfoSize = GetFileVersionInfoSize(szIEFileName, &dwHandle);
					if (dwVerInfoSize != 0)
					{

						// get the version info
						void* pvVerInfo = new BYTE[dwVerInfoSize];
						if (GetFileVersionInfo(szIEFileName, dwHandle, dwVerInfoSize, pvVerInfo))
						{

							// get the VS_FIXEDFILEINFO from the version info
							VS_FIXEDFILEINFO* pFileInfo;
							UINT nLen;
							if (VerQueryValue(pvVerInfo, _T("\\"), (void**)&pFileInfo, &nLen))
							{

								UINT nMajorVersion = pFileInfo->dwFileVersionMS;
								UINT nMinorVersion = pFileInfo->dwFileVersionLS;

								// only use versions that support Java
								if (nMajorVersion > 0x040000 && nMinorVersion > 0x0425)
								{
									bVersionOk = TRUE;
								}
							}
						}

						delete [] pvVerInfo;
					}
				}
				else
				{
					bVersionOk = TRUE;
				}

				// is the version of the browser specified okay?
				if (bVersionOk)
				{

					// at this point we may have the Win95 shortened 8.3 path here.
					// so we need to expand the path to its long file name counterpart

					// there's no easy way to expand a path that contains short file
					// names to long file names

					// here, we'll expand each file name/directory using FindFirstFile
					// and munge them all together. At the end, we'll verify this
					// expanded path exists.

					// expand each directory in the path
					TCHAR szPath[_MAX_PATH];
					_tcscpy(szPath, szIEFileName);
					BOOL bDone = FALSE;
					while (!bDone)
					{
						// we're done if there's no file name part of the path left
						TCHAR szDrive[_MAX_DRIVE];
						TCHAR szDir[_MAX_PATH];
						TCHAR szFileName[_MAX_FNAME];
						_tsplitpath(szPath, szDrive, szDir, szFileName, NULL);
						if (_tcslen(szFileName) > 0 || _tcslen(szDir) > 0)
						{
							// do a FindFirstFile on each directory;
							// the cFileName part of the data returned is the expanded name
							WIN32_FIND_DATA findFileData;
							HANDLE hFile = FindFirstFile(szPath, &findFileData);
							if (hFile != INVALID_HANDLE_VALUE)
							{
								// add the expanded name to the path we're building
								if (strBrowserPath.IsEmpty())
								{
									strBrowserPath = CString(findFileData.cFileName);
								}
								else
								{
									strBrowserPath = CString(findFileData.cFileName) + _T("\\") + strBrowserPath;
								}

								// there should only be one file that matches the name we're looking for
								ASSERT(!FindNextFile(hFile, &findFileData));

								VERIFY(FindClose(hFile));

								// remove the ending file name from the path
								_tcscpy(szPath, szDrive);
								_tcscat(szPath, szDir);

								// remove any trailing backslash
								int nLastChar = _tcslen(szPath) - 1;
								if (!_ismbblead(szPath[nLastChar]) && szPath[nLastChar] == _T('\\'))
								{
									szPath[nLastChar] = _T('\0');
								}
							}
							else
							{
								bDone = TRUE;
							}
						}
						else
						{
							bDone = TRUE;
						}
					}

					// did we successfully expand the path?
					if (!strBrowserPath.IsEmpty())
					{
						// prepend the drive letter onto the path
						TCHAR szDrive[_MAX_DRIVE];
						_tsplitpath(szIEFileName, szDrive, NULL, NULL, NULL);
						strBrowserPath = CString(szDrive) + _T("\\") + strBrowserPath;

						// after all this path munging, make sure the name we now have exists on disk
						WIN32_FIND_DATA findFileData;
						HANDLE hFile = FindFirstFile(strBrowserPath, &findFileData);
						if (hFile == INVALID_HANDLE_VALUE)
						{
							// go back to using the original path
							strBrowserPath = szIEFileName;
						}
						else
						{
							VERIFY(FindClose(hFile));
						}
					}
				}

				RegCloseKey(hkeyIE);
			}
		}
		// no registry entry for the browser specified,
		// so we'll search the path for it
		else {

			// get the directory manager
			CDirMgr* pDirMgr = GetDirMgr();

			// get the executable path from the shell
			CString strPath;
			pDirMgr->GetDirListString(strPath, DIRLIST_PATH);

			// search the path for the browser
			TCHAR szBrowserPath[_MAX_PATH];
			if (SearchPath(strPath, strBrowser, NULL, _MAX_PATH, szBrowserPath, NULL) != 0)
			{
				strBrowserPath = szBrowserPath;
			}
		}
	}

	return !strBrowserPath.IsEmpty();
}

BOOL GetStandalonePath(CString& strStandalonePath)
{
	strStandalonePath.Empty();

	// get the name of the stand-alone interpreter from the registry
	CString strStandalone = GetRegString(szInterpreters, szStandalone, szDefault);

	// is the stand-alone interpreter name specified in the registry?
	if (strStandalone == szDefault)
	{
		// default to jview
		VERIFY(strStandalone.LoadString(IDS_JAVA_STANDALONE_EXE));

		// fill in the registry
		WriteRegString(szInterpreters, szStandalone, strStandalone);
	}

	// do we have a full path the stand-alone interpreter already, or do we need to search for it?
	TCHAR szDrive[_MAX_DRIVE];
	TCHAR szDir[_MAX_DIR];
	_tsplitpath(strStandalone, szDrive, szDir, NULL, NULL);
	if (_tcslen(szDrive) > 0 && _tcslen(szDir) > 0)
	{
		strStandalonePath = strStandalone;
	}
	else
	{
		// We want to search for the stand-alone interpreter in the Windows directory first.
		TCHAR szWinDir[_MAX_PATH];
		if (GetWindowsDirectory(szWinDir, _MAX_PATH))
		{
			TCHAR szStandalonePath[_MAX_PATH];
			if (SearchPath(szWinDir, strStandalone, NULL, _MAX_PATH, szStandalonePath, NULL) != 0)
			{
				strStandalonePath = CString(szStandalonePath);
			}
		}

		if (strStandalonePath.IsEmpty())
		{
			// get the directory manager
			CDirMgr* pDirMgr = GetDirMgr();

			// get the executable path from the shell
			CString strPath;
			pDirMgr->GetDirListString(strPath, DIRLIST_PATH);

			// search the path for our standalone interpreter
			TCHAR szStandalonePath[_MAX_PATH];
			if (SearchPath(strPath, strStandalone, NULL, _MAX_PATH, szStandalonePath, NULL) != 0)
			{
				strStandalonePath = CString(szStandalonePath);
			}
		}
	}

	return !strStandalonePath.IsEmpty();
}

//////////////////////////////////////////////////////////