  factor /= TrinomialCoefficient(derivU->rows+uorder-2, derivRow+vertRow, derivCol+vertCol);

                            result = &derivUTemp->data[derivRow+vertRow][derivCol+vertCol][0];

                            // Accumulate
                            result[0] += factor*(derivPoint[0]*vert[3] - derivPoint[3]*vert[0]);
                            result[1] += factor*(derivPoint[1]*vert[3] - derivPoint[3]*vert[1]);
                            result[2] += factor*(derivPoint[2]*vert[3] - derivPoint[3]*vert[2]);
                        }
                    }
                }
            }

            // derivV <-- derivV.xyz * vertices.w - derivV.w * vertices.xyz
            for (derivRow = 0; derivRow < derivV->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivV->columns-derivRow; derivCol++) {
                    float derivPoint[4];

                    derivPoint[0] = derivV->data[derivRow][derivCol][0];
                    derivPoint[1] = derivV->data[derivRow][derivCol][1];
                    derivPoint[2] = derivV->data[derivRow][derivCol][2];
                    derivPoint[3] = derivV->data[derivRow][derivCol][3];

                    for (vertRow = 0; vertRow < vorder; vertRow++) {
                        for (vertCol = 0; vertCol < uorder-vertRow; vertCol++) {
                            float vert[4], *result;
                            float factor;

                            vert[0] = rawData[4*(vertRow*pitch + vertCol) + 0];
                            vert[1] = rawData[4*(vertRow*pitch + vertCol) + 1];
                            vert[2] = rawData[4*(vertRow*pitch + vertCol) + 2];
                            vert[3] = rawData[4*(vertRow*pitch + vertCol) + 3];

                            factor  = TrinomialCoefficient(derivV->rows-1, derivRow, derivCol);
                            factor *= TrinomialCoefficient(uorder-1, vertRow, vertCol);
                            factor /= TrinomialCoefficient(derivV->rows+uorder-2, derivRow+vertRow, derivCol+vertCol);

                            result = &derivVTemp->data[derivRow+vertRow][derivCol+vertCol][0];

                            // Accumulate
                            result[0] += factor*(derivPoint[0]*vert[3] - derivPoint[3]*vert[0]);
                            result[1] += factor*(derivPoint[1]*vert[3] - derivPoint[3]*vert[1]);
                            result[2] += factor*(derivPoint[2]*vert[3] - derivPoint[3]*vert[2]);
                        }
                    }
                }
            }

            EV_SWAP(derivU, temp[2], pFDMatrix);
            EV_SWAP(derivV, temp[3], pFDMatrix);
        }

        for (uRow = 0; uRow < derivU->rows; uRow++) {
            for (uCol = 0; uCol < derivU->columns-uRow; uCol++) {
                float uPoint[3];

                uPoint[0] = derivU->data[uRow][uCol][0];
                uPoint[1] = derivU->data[uRow][uCol][1];
                uPoint[2] = derivU->data[uRow][uCol][2];

                for (vRow = 0; vRow < derivV->rows; vRow++) {
                    for (vCol = 0; vCol < derivV->columns-vRow; vCol++) {
                        float vPoint[3];
                        int normalIndex = 4*(normalUOrder*(uRow+vRow) + uCol + vCol);
                        float factor;

                        vPoint[0] = derivV->data[vRow][vCol][0];
                        vPoint[1] = derivV->data[vRow][vCol][1];
                        vPoint[2] = derivV->data[vRow][vCol][2];

                        factor  = TrinomialCoefficient(derivU->rows-1, uRow, uCol);
                        factor *= TrinomialCoefficient(derivV->rows-1, vRow, vCol);
                        factor /= TrinomialCoefficient(derivU->rows+derivV->rows-2, uRow+vRow, uCol+vCol);

                        // Accumulate x: uy*vz - uz*vy
                        normalPatch[normalIndex + 0] += factor*(uPoint[1]*vPoint[2] - uPoint[2]*vPoint[1]);
                        // Accumulate y: uz*vx - ux*vz
                        normalPatch[normalIndex + 1] += factor*(uPoint[2]*vPoint[0] - uPoint[0]*vPoint[2]);
                        // Accumulate z: ux*vy - uy*vx
                        normalPatch[normalIndex + 2] += factor*(uPoint[0]*vPoint[1] - uPoint[1]*vPoint[0]);
                    }
                }
            }
        }
    } else {
        if (rational) {
            normalUOrder = 4*uorder - 4;
            normalVOrder = 4*vorder - 4;
        } else {
            normalUOrder = 2*uorder - 2;
            normalVOrder = 2*vorder - 2;
        }

        // Compute derivatives in u
        derivU->columns = uorder-1;
        derivU->rows = vorder;
        for (j = 0; j < vorder; j++) {
            FillColumnVectorMatrix(uorder, ufStride*sizeof(float), pRawData(info, map, rawData, j, 0), temp[0], 0);
            for (i = 0; i < uorder-1; i++) {
                derivU->data[j][i][0] = temp[0]->data[i+1][0][0] - temp[0]->data[i][0][0];
                derivU->data[j][i][1] = temp[0]->data[i+1][0][1] - temp[0]->data[i][0][1];
                derivU->data[j][i][2] = temp[0]->data[i+1][0][2] - temp[0]->data[i][0][2];
                derivU->data[j][i][3] = temp[0]->data[i+1][0][3] - temp[0]->data[i][0][3];
            }
        }

        // Compute derivatives in v
        derivV->columns = uorder;
        derivV->rows = vorder-1;
        for (i = 0; i < uorder; i++) {
            FillColumnVectorMatrix(vorder, vfStride * sizeof(float), pRawData(info, map, rawData, 0, i), temp[0], 0);
            for (j = 0; j < vorder-1; j++) {
                derivV->data[j][i][0] = temp[0]->data[j+1][0][0] - temp[0]->data[j][0][0];
                derivV->data[j][i][1] = temp[0]->data[j+1][0][1] - temp[0]->data[j][0][1];
                derivV->data[j][i][2] = temp[0]->data[j+1][0][2] - temp[0]->data[j][0][2];
                derivV->data[j][i][3] = temp[0]->data[j+1][0][3] - temp[0]->data[j][0][3];
            }
        }

        if (rational) {
            int derivRow, derivCol, vertRow, vertCol;

            // This code makes the assumption that type == NV_PATCH_VERTEX_FORMAT_FLOAT_4.
            // Seeing as the patch is rational, this is probably safe, unless people start
            // using unsigned byte types for rational patches.

            derivUTemp = temp[4];
            derivVTemp = temp[5];

            // Initialize matrices
            derivUTemp->columns = 2*uorder - 2;
            derivUTemp->rows    = 2*vorder - 1;
            derivVTemp->columns = 2*uorder - 1;
            derivVTemp->rows    = 2*vorder - 2;
            for (derivRow = 0; derivRow < derivUTemp->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivUTemp->columns; derivCol++) {
                    derivUTemp->data[derivRow][derivCol][0] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][1] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][2] = 0.0f;
                    derivUTemp->data[derivRow][derivCol][3] = 0.0f;
                }
            }
            for (derivRow = 0; derivRow < derivVTemp->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivVTemp->columns; derivCol++) {
                    derivVTemp->data[derivRow][derivCol][0] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][1] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][2] = 0.0f;
                    derivVTemp->data[derivRow][derivCol][3] = 0.0f;
                }
            }

            // derivU <-- derivU.xyz * vertices.w - derivU.w * vertices.xyz
            for (derivRow = 0; derivRow < derivU->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivU->columns; derivCol++) {
                    float derivPoint[4];

                    derivPoint[0] = derivU->data[derivRow][derivCol][0];
                    derivPoint[1] = derivU->data[derivRow][derivCol][1];
                    derivPoint[2] = derivU->data[derivRow][derivCol][2];
                    derivPoint[3] = derivU->data[derivRow][derivCol][3];

                    for (vertRow = 0; vertRow < vorder; vertRow++) {
                        for (vertCol = 0; vertCol < uorder; vertCol++) {
                            float vert[4], *result;
                            float factor;
                            int idx;
                            idx = 4*(vertRow*pitch + vertCol);
                            vert[0] = rawData[idx + 0];
                            vert[1] = rawData[idx + 1];
                            vert[2] = rawData[idx + 2];
                            vert[3] = rawData[idx + 3];

                            factor  = BinomialCoefficient(derivU->rows-1, derivRow);
                            factor /= BinomialCoefficient(derivU->rows+vorder-2, derivRow+vertRow);
                            factor *= BinomialCoefficient(derivU->columns-1, derivCol);
                            factor *= BinomialCoefficient(vorder-1, vertRow);
                            factor /= BinomialCoefficient(derivU->columns+uorder-2, derivCol+vertCol);
                            factor *= BinomialCoefficient(uorder-1, vertCol);

                            result = &derivUTemp->data[derivRow+vertRow][derivCol+vertCol][0];

                            // Accumulate
                            result[0] += factor*(derivPoint[0]*vert[3] - derivPoint[3]*vert[0]);
                            result[1] += factor*(derivPoint[1]*vert[3] - derivPoint[3]*vert[1]);
                            result[2] += factor*(derivPoint[2]*vert[3] - derivPoint[3]*vert[2]);
                        }
                    }
                }
            }

            // derivV <-- derivV.xyz * vertices.w - derivV.w * vertices.xyz
            for (derivRow = 0; derivRow < derivV->rows; derivRow++) {
                for (derivCol = 0; derivCol < derivV->columns; derivCol++) {
                    float derivPoint[4];

                    derivPoint[0] = derivV->data[derivRow][derivCol][0];
                    derivPoint[1] = derivV->data[derivRow][derivCol][1];
                    derivPoint[2] = derivV->data[derivRow][derivCol][2];
                    derivPoint[3] = derivV->data[derivRow][derivCol][3];

                    for (vertRow = 0; vertRow < vorder; vertRow++) {
                        for (vertCol = 0; vertCol < uorder; vertCol++) {
                            float vert[4], *result;
                            float factor;

                            vert[0] = rawData[4*(vertRow*pitch + vertCol) + 0];
                            vert[1] = rawData[4*(vertRow*pitch + vertCol) + 1];
                            vert[2] = rawData[4*(vertRow*pitch + vertCol) + 2];
                            vert[3] = rawData[4*(vertRow*pitch + vertCol) + 3];

                            factor  = BinomialCoefficient(derivV->rows-1, derivRow);
                            factor *= BinomialCoefficient(derivV->columns-1, derivCol);
                            factor *= BinomialCoefficient(vorder-1, vertRow);
                            factor *= BinomialCoefficient(uorder-1, vertCol);
                            factor /= BinomialCoefficient(derivV->rows+vorder-2, derivRow+vertRow);
                            factor /= BinomialCoefficient(derivV->columns+uorder-2, derivCol+vertCol);

                            result = &derivVTemp->data[derivRow+vertRow][derivCol+vertCol][0];

                            // Accumulate
                            result[0] += factor*(derivPoint[0]*vert[3] - derivPoint[3]*vert[0]);
                            result[1] += factor*(derivPoint[1]*vert[3] - derivPoint[3]*vert[1]);
                            result[2] += factor*(derivPoint[2]*vert[3] - derivPoint[3]*vert[2]);
                        }
                    }
                }
            }

            EV_SWAP(derivU, temp[4], pFDMatrix);
            EV_SWAP(derivV, temp[5], pFDMatrix);
        }

        for (uRow = 0; uRow < derivU->rows; uRow++) {
            for (uCol = 0; uCol < derivU->columns; uCol++) {
                float uPoint[3];

                uPoint[0] = derivU->data[uRow][uCol][0];
                uPoint[1] = derivU->data[uRow][uCol][1];
                uPoint[2] = derivU->data[uRow][uCol][2];

                for (vRow = 0; vRow < derivV->rows; vRow++) {
                    for (vCol = 0; vCol < derivV->columns; vCol++) {
                        float vPoint[3];
                        int normalIndex = 4*(normalUOrder*(uRow+vRow) + uCol+vCol);
                        float factor;

                        vPoint[0] = derivV->data[vRow][vCol][0];
                        vPoint[1] = derivV->data[vRow][vCol][1];
                        vPoint[2] = derivV->data[vRow][vCol][2];

                        factor  = BinomialCoefficient(derivU->rows-1, uRow);
                        factor *= BinomialCoefficient(derivV->rows-1, vRow);
                        factor *= BinomialCoefficient(derivU->columns-1, uCol);
                        factor *= BinomialCoefficient(derivV->columns-1, vCol);
                        factor /= BinomialCoefficient(derivU->rows+derivV->rows-2, uRow+vRow);
                        factor /= BinomialCoefficient(derivU->columns+derivV->columns-2, uCol+vCol);

                        // Accumulate x: uy*vz - uz*vy
                        normalPatch[normalIndex + 0] += factor*(uPoint[1]*vPoint[2] - uPoint[2]*vPoint[1]);

                        // Accumulate y: uz*vx - ux*vz
                        normalPatch[normalIndex + 1] += factor*(uPoint[2]*vPoint[0] - uPoint[0]*vPoint[2]);

                        // Accumulate z: ux*vy - uy*vx
                        normalPatch[normalIndex + 2] += factor*(uPoint[0]*vPoint[1] - uPoint[1]*vPoint[0]);
                    }
                }
            }
        }
    }

computeNormalPatchEnd:
    EV_FREE(derivU, info->context);
    EV_FREE(derivU, info->context);
    EV_FREE(temp[0], info->context);
    EV_FREE(temp[1], info->context);
    EV_FREE(temp[2], info->context);
    EV_FREE(temp[3], info->context);
    EV_FREE(temp[4], info->context);
    EV_FREE(temp[5], info->context);
}

const static struct {
    int uSide;
    int vSide;
    int uDir;
    int vDir;
    int reverse;
    int centerCurve;
} TriPatchLayout[3] = {
    { 0, 2, 0, 1, 0, 0 },
    { 0, 1, 1, 0, 1, 1 },
    { 1, 2, 1, 0, 1, 1 },
};

// Compute the step size and number of segments in fractional tessellation
void ComputeFracStepInfo(float steps, float *du, int *segs)
{
    *du = 1.0f / steps;
    if (segs) {
        *segs = (int)(steps/2.0f + 0.999f);
    }
}

/*****************************************************************************/
// needs adjustment for 64-bit machines
#define SIZEOF_NV_PATCH_QUAD_INFO EV_ROUND(sizeof(NV_PATCH_QUAD_INFO))

int nvAllocInfoScratch(NV_PATCH_INFO *info)
{
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int attr, bytes;
    EV_ALLOC_DECL();

    bytes = info->nAttr * (sizeof(FDMatrix) + 2*info->bytesGuardCurve);

    if (doFrac) {
        bytes += info->nAttr * (2*info->bytesGuardCurve);
    }

    EV_ALLOC_INIT_WITH_CACHE(info->context, bytes, nvAllocInfoScratchEnd, info->pCache[EV_CACHE_INFO_SCRATCH]);
    info->pScratchBase = evMemory.pBase;

    for (attr = 0; attr < info->maxAttr; attr++) {
        if (!(info->evalEnables & (1 << attr))) {
            continue;
        }

        EV_ALLOC(info->ppMatrixSetSS0[attr], info->context, sizeof(FDMatrix));

        // for guard curves at begin or end of matrix stepping
        EV_ALLOC(info->tempVBegin[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(info->tempVEnd[attr], info->context, info->bytesGuardCurve);

        if (doFrac) {
            EV_ALLOC(info->guardSetUInnerFrac[attr], info->context, info->bytesGuardCurve);
            EV_ALLOC(info->guardSetVInnerFrac[attr], info->context, info->bytesGuardCurve);
            continue;
        }
    }
    EV_ALLOC_FULL(info->context);

    info->ppGuardSetUInnerFrac1[0] = &info->guardSetUInnerFrac;
    info->ppGuardSetVInnerFrac1[0] = &info->guardSetVInnerFrac;

    info->ppGuardSetUInnerFrac = &info->ppGuardSetUInnerFrac1[0];
    info->ppGuardSetVInnerFrac = &info->ppGuardSetVInnerFrac1[0];

nvAllocInfoScratchEnd:
    return retVal;
}

// alloc FDMatrices and other things for imm mode rendering
int nvAllocFDMatricesEtc(NV_PATCH_INFO *info)
{
    unsigned int retVal = NV_PATCH_EVAL_OK;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int attr, matrixBytes, totalBytes;
    NV_PATCH_QUAD_INFO *quadInfo;
    EV_ALLOC_DECL();

    // all styles need quadInfo
    totalBytes = SIZEOF_NV_PATCH_QUAD_INFO;

    if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
        if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
            matrixBytes = 3*sizeof(FDMatrix) + sizeof(NV_PATCH_FRAC_TRI_GUARD_INFO);
        } else {
            matrixBytes = 4*sizeof(FDMatrix) + sizeof(NV_PATCH_FRAC_QUAD_GUARD_INFO);
        }
    } else {
        matrixBytes = 1*sizeof(FDMatrix);
        totalBytes += 4 * info->bytesGuardCurve * info->nAttr;
    }
    matrixBytes = EV_ROUND(matrixBytes);

    // always alloc Inner guard curves
    totalBytes += 2 * info->bytesGuardCurve * info->nAttr;

    // all styles need matrices and guardInfo
    totalBytes += matrixBytes * info->nAttr;

    EV_ALLOC_INIT_WITH_CACHE(info->context, totalBytes, nvAllocFDMatricesEnd, info->pCache[EV_CACHE_QUADINFO_ETC]);

    //THIS MUST ALWAYS BE THE FIRST ALLOCATION FROM THIS GROUP!!!!!!!!!
    EV_ALLOC(info->quadInfo, info->context, SIZEOF_NV_PATCH_QUAD_INFO);
    quadInfo = info->quadInfo;

    for (attr = 0; attr < info->maxAttr; attr++) {
        if (!(info->evalEnables & (1 << attr))) {
            continue;
        }

        quadInfo->m00[attr] = quadInfo->m01[attr] = quadInfo->m10[attr] = quadInfo->m11[attr] = NULL;
        EV_ALLOC(quadInfo->m00[attr], info->context, matrixBytes);

        // alloc Inner for all cases
        EV_ALLOC(quadInfo->pUInner[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(quadInfo->pVInner[attr], info->context, info->bytesGuardCurve);

        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
            quadInfo->m01[attr] = &quadInfo->m00[attr][1];
            quadInfo->m10[attr] = &quadInfo->m00[attr][2];
            if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
                quadInfo->guardTF[attr] = (NV_PATCH_FRAC_TRI_GUARD_INFO *)&quadInfo->m00[attr][3];
            } else {
                quadInfo->m11[attr] = &quadInfo->m00[attr][3];
                quadInfo->guardQF[attr] = (NV_PATCH_FRAC_QUAD_GUARD_INFO *)&quadInfo->m00[attr][4];
            }
            continue;
        }

        // INT cases
        EV_ALLOC(quadInfo->pU0[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(quadInfo->pU1[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(quadInfo->pV0[attr], info->context, info->bytesGuardCurve);
        EV_ALLOC(quadInfo->pV1[attr], info->context, info->bytesGuardCurve);

        quadInfo->pCorners[attr][0][0] = quadInfo->cornAttr[attr].corners[0][0];
        quadInfo->pCorners[attr][0][1] = quadInfo->cornAttr[attr].corners[0][1];
        quadInfo->pCorners[attr][1][0] = quadInfo->cornAttr[attr].corners[1][0];
        quadInfo->pCorners[attr][1][1] = quadInfo->cornAttr[attr].corners[1][1];
    }
    EV_ALLOC_FULL(info->context);

nvAllocFDMatricesEnd:
    return retVal;
}

/*****************************************************************************/
//int bFirstTimeInit = 0x1;              //global value to indicate if we've built dynamic inner loops yet or not.
float fracFudge = .01f;
unsigned int nvEvalPatchSetup(NV_PATCH_INFO *info)
{
    int ii;
    unsigned int retVal = NV_PATCH_EVAL_OK;
    float *normalPatch = NULL;
    float *UVPatch = NULL;
    float segmin = 1.f;
    EV_ALLOC_DECL();
    static int onceOnlyDone = 0;

    EV_DRAW(onColor = 0);
    if (g_FDGlobalData.bFirstTimeInit) {
        nvPatchInitFD(info);
        g_FDGlobalData.bFirstTimeInit = 0;
    }    

    info->reverse = 0;
    info->usingHW = !g_FDGlobalData.bForceSoftware & (info->backendType == NV_PATCH_BACKEND_KELVIN ? 1 : 0); // identifies places that probably need code for HW version

    NV_TRACE_CODE(
        if (!info->usingHW) {
            nvControlOptions |= NCO_DID_SW;
        }
    );

    //INITIALIZE HERE BECAUSE Compute Normal Patch will read these.
    info->flipT = 0;
    info->flipU = 0;
    info->flipV = 0;
    info->flipTUV = 0;
    info->flipUV = 0;
    info->nAttr = 0;
    info->maxAttr = -1;
    info->maxOrder = 0;
    info->firstAttr = -1;

    if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
        // enforce minimums as required
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) { segmin = 2.f + fracFudge; }
        info->tess.tri.n1 = MAX(info->tess.tri.n1, segmin);
        info->tess.tri.n2 = MAX(info->tess.tri.n2, segmin);
        info->tess.tri.n3 = MAX(info->tess.tri.n3, segmin);

    } else {
        // enforce minimums as required
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
            segmin = 2.f;
            if ((info->tess.tensor.nu0 == 2.f  &&  info->tess.tensor.nu1 == 2.f)
                    ||  (info->tess.tensor.nv0 == 2.f  &&  info->tess.tensor.nv1 == 2.f)) {
                segmin += fracFudge;
            }
        }
        info->tess.tensor.nu0 = MAX(info->tess.tensor.nu0, segmin);
        info->tess.tensor.nu1 = MAX(info->tess.tensor.nu1, segmin);
        info->tess.tensor.nv0 = MAX(info->tess.tensor.nv0, segmin);
        info->tess.tensor.nv1 = MAX(info->tess.tensor.nv1, segmin);
    }

    nvAssert(16 == NV_PATCH_NUMBER_OF_ATTRIBS); // fix all 16's if we hit this... fundamental assumption has changed
    NV_TRACE_CODE(nUniqueVertices = 0);

    // note: must use same value for HW & SW to use the same big<-->small matrices
    info->maxSwatch = NV_PATCH_KELVIN_SWATCH_SIZE;

#if defined(IS_OPENGL)
 #if defined(FREDS_DEBUG_CODE)
    NV_TRACE_CODE(if (nvDebugLevel & 1))
    {
        info->maxSwatch = 4;
    }
    //ffnvDebugMask |= TR_PUSHBUFFER;
    //ffnvDebugOptions &= ~(TRO_TEMP1 | TRO_TEMP2 | TRO_TEMP3 | TRO_TEMP4);
 #endif

    if (info->usingHW) {
        glBegin(GL_POINTS);     // perform validation for HW
        glEnd();
        info->backendType = NV_PATCH_BACKEND_KELVIN;
    }
#endif
    if (onceOnlyDone != info->maxSwatch) {
        evalFillRetessMatrices(info);
        onceOnlyDone = info->maxSwatch;     // note: setting after fill makes it thread safe
    }

//ff#ifdef DCR_SEMAPHORE
    if (info->usingHW) {info->backend->beginPatch(info);}
//ff#endif

    if (info->flags & NV_PATCH_FLAG_AUTO_NORMAL) {
        NV_PATCH_MAP_INFO *map;
        int uorder, vorder;
        int normalUOrder, normalVOrder;

        // init for ComputeNormalPatch
        map = &info->maps[info->srcNormal];
        uorder = map->uorder;
        vorder = map->vorder;
        map->ufStride = map->stride/sizeof(float);
        map->vfStride = map->ufStride * map->pitch;

        nvAssert(info->srcNormal >= 0 && info->srcNormal <= NV_PATCH_NUMBER_OF_ATTRIBS);
        nvAssert(info->dstNormal >= 0 && info->dstNormal <= NV_PATCH_NUMBER_OF_ATTRIBS);
        if (info->maps[info->srcNormal].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
            info->rational = IsPatchRational(info, info->srcNormal);
        }

        if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
            if (info->rational) {
                normalUOrder = normalVOrder = 4*uorder - 5;
            } else {
                normalUOrder = normalVOrder = 2*uorder - 3;
            }
        } else {
            if (info->rational) {
                normalUOrder = 4*uorder - 4;
                normalVOrder = 4*vorder - 4;
            } else {
                normalUOrder = 2*uorder - 2;
                normalVOrder = 2*vorder - 2;
            }
        }

        // If control points are dirty, recalculate the actual normal patch
        if (info->maps[info->srcNormal].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
            int bytes;

            //init some storage
            if (normalUOrder == 1) {
                //degree lifting -- HW doesn't allow for a order1/degree0/constant function in the FD unit,
                //so allocate extra space here so I can lift it to linear later
                bytes = 4*(normalUOrder+1)*(normalVOrder+1)*sizeof(float);
            } else {
                bytes = 4*normalUOrder*normalVOrder*sizeof(float);
            }
            EV_ALLOC_INIT_WITH_CACHE(info->context, bytes, nvPatchSetupEnd, info->pCache[EV_CACHE_AUTO_NORMAL_SETUP]);
            EV_ALLOC(info->normalPatch, info->context, bytes);
            normalPatch = info->normalPatch;
            for (ii = 0; ii < 4*normalUOrder*normalVOrder; ii++) {
                if ((ii & 3) != 3) {
                    normalPatch[ii] = 0.0f;
                } else {
                    normalPatch[ii] = 1.0f;
                }
            }

            // XXXmjc We aren't handling constant position in one direction properly yet
            nvAssert(uorder > 1);
            nvAssert(vorder > 1);
            ComputeNormalPatch(info, normalPatch, uorder, vorder, info->rational); //type passed here is the data src type
            if (normalUOrder == 1) {
                float pt[4];
                //degree lifting -- HW doesn't allow for a order1/degree0/constant function in the FD unit,
                //expand the normal patch data here.
                pt[0] = normalPatch[0]; pt[1] = normalPatch[1]; pt[2] = normalPatch[2];
                for (ii=4; ii < 12; ii+=4) {
                    normalPatch[ii+0] = pt[0];
                    normalPatch[ii+1] = pt[1];
                    normalPatch[ii+2] = pt[2];
                    normalPatch[ii+3] = 1.f;
                }
            }
        }

        if (normalUOrder == 1) {
            //if the order is actually 1 then bump it up one because I lifted the degree
            //when the control pts were dirty.
            normalUOrder++;
            normalVOrder++;
        }

        // Force evaluation of the normal
        info->evalEnables |= (1 << info->dstNormal);
        info->maps[info->dstNormal].uorder = normalUOrder;
        info->maps[info->dstNormal].vorder = normalVOrder;
        info->maps[info->dstNormal].rawData = normalPatch;
        info->maps[info->dstNormal].stride = 4*sizeof(float);
        info->maps[info->dstNormal].pitch  = normalUOrder;
    }

    if (info->flags & NV_PATCH_FLAG_AUTO_UV) {
        int order = 2;
        int bytes = 0;
        for (ii=0; ii < 8; ii++) {
            if (info->dstUV[ii] != 0xFFFFffff) {
                if (info->maps[info->dstUV[ii]].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                    if (bytes == 0) {
                        //if this is the first UV coord build patch data for it
                        bytes = 4*order*order*sizeof(float);
                        EV_ALLOC_INIT_WITH_CACHE2(info->context, bytes, nvPatchSetupEnd, info->pCache[EV_CACHE_UV_SETUP]);
                        EV_ALLOC(UVPatch , info->context, bytes);
                        if (info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR) {
                            // DO THIS BECAUSE THERE IS AN IMPLICIT MIRROR IN THE
                            // FORMATS OF D3D/OGL        D3D= 0      OGL=2
                            //                                |\         |\
                            //                                1-2        0-1
                            // texture coordinates need to be mirrored in y.
                            // likewise winding needs to be inverted
                            UVPatch[0] = info->endu;   UVPatch[1] = info->endv;     UVPatch[2] = 0.f;   UVPatch[3] = 1.f;
                            UVPatch[4] = info->startu; UVPatch[5] = info->endv;     UVPatch[6] = 0.f;   UVPatch[7] = 1.f;
                            UVPatch[8] = info->startu; UVPatch[9] = info->startv;   UVPatch[10] = 0.f;  UVPatch[11] = 1.f;
                            UVPatch[12] = 0x0;         UVPatch[13] = 0x0;           UVPatch[14] = 0.f;  UVPatch[15] = 1.f;
                        } else {
                            UVPatch[0] = info->startu; UVPatch[1] = info->startv;   UVPatch[2] = 0.f;   UVPatch[3] = 1.f;
                            UVPatch[4] = info->endu;   UVPatch[5] = info->startv;   UVPatch[6] = 0.f;   UVPatch[7] = 1.f;
                            UVPatch[8] = info->startu; UVPatch[9] = info->endv;     UVPatch[10] = 0.f;  UVPatch[11] = 1.f;
                            UVPatch[12] = info->endu;   UVPatch[13] = info->endv;   UVPatch[14] = 0.f;  UVPatch[15] = 1.f;
                        }
                    }
                    info->UVPatch = UVPatch;
                }

                // Force evaluation of the texturecoord
                info->evalEnables |= (1 << info->dstUV[ii]);
                info->maps[info->dstUV[ii]].uorder = info->maps[info->dstUV[ii]].vorder = order;
                info->maps[info->dstUV[ii]].rawData = UVPatch;
                info->maps[info->dstUV[ii]].stride = 4*sizeof(float);
                info->maps[info->dstUV[ii]].pitch = order;
            }
        }
    }

    // ensure some flags are initialized
    info->flags &= ~(NV_PATCH_FLAG_SOME_DIRTY_TESS | NV_PATCH_FLAG_TRANSPOSE
                        | NV_PATCH_FLAG_FLIPPED_U | NV_PATCH_FLAG_FLIPPED_V);
    for (ii = 0;  ii < NV_PATCH_NUMBER_OF_ATTRIBS;  ii++) {
        if (info->evalEnables & (1 << ii)) {
            NV_PATCH_MAP_INFO *map = &info->maps[ii];

            if (!(map->dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS)) {
                if (map->dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                    info->flags |= NV_PATCH_FLAG_SOME_DIRTY_TESS;
                }
            }

            map->ufStride = map->stride/sizeof(float);
            map->vfStride = map->ufStride * map->pitch;

            if (map->uorder == 1) {
                map->uorder = 2;
                map->ufStride = 0;
            }
            if (map->vorder == 1) {
                map->vorder = 2;
                map->vfStride = 0;
            }

            EV_DRAW( if (0  &&  !ii  &&  (nvDebugLevel >= 4)) {
                unsigned int row;
                unsigned int col;

                /* draw lines through all the control points */
                glColor3f(1, 0, 1);
                for (row = 0; row < map->vorder;  row++) {
                    glBegin(GL_LINE_STRIP);
                    for (col = 0;  col < map->uorder;  col++) {
                        glVertex3fv(pRawData(info, map, map->rawData, row, col));
                    }
                    glEnd();
                }
            } );

            // calc MAX values
            info->nAttr++;
            if (info->firstAttr == -1) {
                info->firstAttr = ii;
            }
            if (ii > info->maxAttr) {
                info->maxAttr = ii;
            }
            if (map->uorder > info->maxOrder) {
                info->maxOrder = map->uorder;
            }
            if (map->vorder > info->maxOrder) {
                info->maxOrder = map->vorder;
            }
        }
    }
    info->maxAttr = info->maxAttr + 1;

    info->bytesGuardCurve = EV_ROUND(PATCH_CURVE_HEADER_SIZE + (info->maxOrder * 4) * sizeof(float)); // truncated NV_PATCH_CURVE_INFO
    info->bytesGuardCurveAllAttr = info->nAttr * info->bytesGuardCurve;                   // just the set of curve info

    if (!(info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR)) {
        // setup QUADRILATERAL PATCH

        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
        } else {    // setup QUADRILATERAL INTEGER TESSELLATION
        }

    } else {
        // setup TRIANGULAR PATCH
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
        } else {    // setup TRIANGULAR INTEGER TESSELLATION
        }
    }

    return retVal;

nvPatchSetupEnd:
    nvEvalPatchCleanup(info);
    return retVal;
}

unsigned int nvEvalPatchCleanup(NV_PATCH_INFO *info)
{
    int ii;

    if (info->normalPatch && !info->pCache[EV_CACHE_AUTO_NORMAL_SETUP]) {
        __NV_FREE(info->context, info->normalPatch);
        info->normalPatch = NULL;
    }
    if (info->UVPatch && !info->pCache[EV_CACHE_UV_SETUP]) {
        __NV_FREE(info->context, info->UVPatch);
        info->UVPatch = NULL;
    }

    // indicate that all cache's are not in use
    for (ii = 0;  ii < MAX_EV_CACHE;  ii++) {
        if (info->pCache[ii]) {
            info->pCache[ii]->inUse = 0;
        }
    }

//ff#ifdef DCR_SEMAPHORE    
    if (info->usingHW) info->backend->endPatch(info);
//ff#endif

    info->backend->setFrontFace(info, 0);
#if defined(COMPILE_TRACE_LIBRARY) && defined(FREDS_DEBUG_CODE)
    nvDebugMask &= ~TR_PUSHBUFFER;
#endif


    return info->retVal;
}

/*****************************************************************************/
int noflip = 0;

int MaybeTransposeFlipQuad(NV_PATCH_INFO *info)
{
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;
    int doFrac = !!(info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL);
    int index, ii;
    int stitchLeft;
    int stitchBottom;
    float fnuMax, fnvMax, ftemp;

    quadInfo->nu0 = (int)(info->tess.tensor.nu0 + 0.999f);
    quadInfo->nu1 = (int)(info->tess.tensor.nu1 + 0.999f);
    quadInfo->nv0 = (int)(info->tess.tensor.nv0 + 0.999f);
    quadInfo->nv1 = (int)(info->tess.tensor.nv1 + 0.999f);
    if (!doFrac) {
        fnuMax = MAX(quadInfo->nu0, quadInfo->nu1);
        fnvMax = MAX(quadInfo->nv0, quadInfo->nv1);
    } else {
        fnuMax = (info->tess.tensor.nu0 + info->tess.tensor.nu1) / 2.0f;
        fnvMax = (info->tess.tensor.nv0 + info->tess.tensor.nv1) / 2.0f;
    }

if (noflip) {
    quadInfo->uMaxSegs = MAX(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMaxSegs = MAX(quadInfo->nv0, quadInfo->nv1);
    quadInfo->uMinSegs = MIN(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMinSegs = MIN(quadInfo->nv0, quadInfo->nv1);

    return 1;
}
    if (fnvMax > fnuMax) {
        info->flipT = 1;
        info->flags |= NV_PATCH_FLAG_TRANSPOSE;
        EV_SWAP(quadInfo->nu0, quadInfo->nv0, ii);
        EV_SWAP(quadInfo->nu1, quadInfo->nv1, ii);
        EV_SWAP(info->tess.tensor.nu0, info->tess.tensor.nv0, ftemp);
        EV_SWAP(info->tess.tensor.nu1, info->tess.tensor.nv1, ftemp);
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                EV_SWAP(info->maps[index].uorder, info->maps[index].vorder, ii);
                EV_SWAP(info->maps[index].vfStride, info->maps[index].ufStride, ii);
            }
        }
        NV_TRACE_COND(TR_EVAL, 20,
            TPRINTF(("\n\n***** transpose alert %g <--> %g\n\n", fnuMax, fnvMax));
        );
    }

    stitchLeft = (quadInfo->nv0 < quadInfo->nv1);
    if (stitchLeft  &&  !doFrac) {
        info->flags |= NV_PATCH_FLAG_FLIPPED_U;
        info->flipU = 1;
        EV_SWAP(quadInfo->nv0, quadInfo->nv1, ii);
        EV_SWAP(info->tess.tensor.nv0, info->tess.tensor.nv1, ftemp);
    }

    stitchBottom = (quadInfo->nu0 < quadInfo->nu1);
    if (stitchBottom  &&  !doFrac) {
        info->flags |= NV_PATCH_FLAG_FLIPPED_V;
        info->flipV = 1;
        EV_SWAP(quadInfo->nu0, quadInfo->nu1, ii);
        EV_SWAP(info->tess.tensor.nu0, info->tess.tensor.nu1, ftemp);
    }

    info->flipUV = info->flipU ^ info->flipV;
    info->flipTUV = info->flipU ^ info->flipV ^ !!(info->flags & NV_PATCH_FLAG_TRANSPOSE);

    if (!info->usingHW) {
        if (info->flipT) {
            info->reverse ^= 1;
        }

    } else {
        info->reverse ^= info->flipTUV;
    }

    quadInfo->uMaxSegs = MAX(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMaxSegs = MAX(quadInfo->nv0, quadInfo->nv1);
    quadInfo->uMinSegs = MIN(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMinSegs = MIN(quadInfo->nv0, quadInfo->nv1);

    return 1;
}


int MaybeTransposeFlipTri(NV_PATCH_INFO *info)
{
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;
    int index, ii;
    int stitchLeft;
    float ftemp;

    quadInfo->nu0 = (int)(info->tess.tri.n1 + 0.999f);
    quadInfo->nu1 = 1;
    quadInfo->nv0 = (int)(info->tess.tri.n3 + 0.999f);
    quadInfo->nv1 = (int)(info->tess.tri.n2 + 0.999f);

    quadInfo->uMaxSegs = MAX(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMaxSegs = MAX(quadInfo->nv0, quadInfo->nv1);
    quadInfo->uMinSegs = MIN(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMinSegs = MIN(quadInfo->nv0, quadInfo->nv1);

return 1;
    if (quadInfo->nv0 > quadInfo->nu0) {
        info->flipT = 1;
        info->flags |= NV_PATCH_FLAG_TRANSPOSE;
        EV_SWAP(quadInfo->nv0, quadInfo->nu0, ii);
        EV_SWAP(info->tess.tri.n3, info->tess.tri.n1, ftemp);
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                assert(info->maps[index].uorder == info->maps[index].vorder);
                EV_SWAP(info->maps[index].uorder, info->maps[index].vorder, ii);
                EV_SWAP(info->maps[index].vfStride, info->maps[index].ufStride, ii);
            }
        }
    }

    stitchLeft = (quadInfo->nv0 < quadInfo->nv1);
    if (stitchLeft) {
        //ffinfo->flags |= NV_PATCH_FLAG_FLIPPED_U;
        //ffinfo->flipU = 1;
        EV_SWAP(quadInfo->nv0, quadInfo->nu0, ii);
        EV_SWAP(info->tess.tri.n3, info->tess.tri.n1, ftemp);
        for (index = 0; index < info->maxAttr; index++) {
            if (info->evalEnables & (1 << index)) {
                NV_PATCH_MAP_INFO *map = &info->maps[index];
                float *rawData = map->rawData, *dst, *src;
                int uorder = map->uorder;
                int vorder = map->vorder;
                int row, col;
                float diag[4];

                assert(info->maps[index].uorder == info->maps[index].vorder);
                for (row = 0; row < vorder; row++) {
                    src = rawData + row*uorder*4;
                    dst = rawData + ((vorder-1)*uorder + (uorder-1-row)) * 4;
                    for (col = 0; col < uorder - row - 1; col++) {
                        CopyPoint(dst, src);
                        src += 4;
                        dst -= uorder;
                    }
                    CopyPoint(diag, src);
                    CopyPoint(src, dst);
                    CopyPoint(dst, diag);
                }

                map->rawData = rawData + (vorder*uorder - 1) * 4;
                info->maps[index].ufStride = -info->maps[index].ufStride;
                info->maps[index].vfStride = -info->maps[index].vfStride;
            }
        }
    }

    info->flipUV = info->flipU ^ info->flipV;
    info->flipTUV = info->flipU ^ info->flipV ^ !!(info->flags & NV_PATCH_FLAG_TRANSPOSE);

    if (!info->usingHW) {
        if (info->flipT) {
            info->reverse ^= 1;
        }

    } else {
        info->reverse ^= info->flipTUV;
    }

    quadInfo->uMaxSegs = MAX(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMaxSegs = MAX(quadInfo->nv0, quadInfo->nv1);
    quadInfo->uMinSegs = MIN(quadInfo->nu0, quadInfo->nu1);
    quadInfo->vMinSegs = MIN(quadInfo->nv0, quadInfo->nv1);

    return 1;
}

/*****************************************************************************/
// common setup code for patches
static void evalCommonSetup(NV_PATCH_INFO *info, float uMaxSegs, float  vMaxSegs)
{
    // determine if swathing is required

    if ((uMaxSegs > info->maxSwatch)  ||  (vMaxSegs > info->maxSwatch)) {
        info->swatchFlags = NV_PATCH_SWATCH;    // for lower level routine to know "swatch mode"
        // calc swatches including the Begin and End stitches
        info->nSwatchU = (uMaxSegs - 1) / info->maxSwatch + 1;
        info->nSwatchV = (vMaxSegs - 1) / info->maxSwatch + 1;

    } else {
        info->swatchFlags = (NV_PATCH_SWATCH_FIRST_ROW | NV_PATCH_SWATCH_LAST_ROW | NV_PATCH_SWATCH_FIRST_COL | NV_PATCH_SWATCH_LAST_COL);
        info->nSwatchU = 1;
        info->nSwatchV = 1;
    }
}

/*****************************************************************************/
unsigned int nvEvalPatch(NV_PATCH_INFO *info)
{
    int i, j;
    unsigned int retVal = NV_PATCH_EVAL_OK;
    NV_PATCH_QUAD_INFO *quadInfo = info->quadInfo;

    if ((info->evalEnables & EV_GUARD_BIT_VERTEX) != EV_GUARD_BIT_VERTEX) {
        nvAssert(0);    //HW absolutely requires position 0 to be active -- if we don't have one bail.
        return NV_PATCH_EVAL_ERR_NOT_HANDLED;

    }

    if (info->backendType == NV_PATCH_BACKEND_CELSIUS) {
        if (info->backend->InitBackend) info->backend->InitBackend(info);
    }

    if (!(info->flags & NV_PATCH_FLAG_TYPE_TRIANGULAR)) {
        // QUAD FRACTIONAL TESSELLATION

        // Tensor product patch
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
            int transpose = MaybeTransposeFlipQuad(info);
            float nu0 = info->tess.tensor.nu0;
            float nv0 = info->tess.tensor.nv0;
            float nu1 = info->tess.tensor.nu1;
            float nv1 = info->tess.tensor.nv1;
            float nuMid = (nu0 + nu1) / 2.0f;
            float nvMid = (nv0 + nv1) / 2.0f;
            float nu0Old = info->originaltess.tensor.nu0;
            float nv0Old = info->originaltess.tensor.nv0;
            float nu1Old = info->originaltess.tensor.nu1;
            float nv1Old = info->originaltess.tensor.nv1;
            float nuMidOld = (nu0Old + nu1Old) / 2.0f;
            float nvMidOld = (nv0Old + nv1Old) / 2.0f;
            float du0, du1, dv0, dv1, duMid, dvMid;
            float du0Old, du1Old, dv0Old, dv1Old, duMidOld, dvMidOld;
            int u0Segs, u1Segs, v0Segs, v1Segs, uMidSegs, vMidSegs;
            float curvePoints[NV_PATCH_MAX_ORDER][4];

            ComputeFracStepInfo(nu0, &du0, &u0Segs);
            ComputeFracStepInfo(nu1, &du1, &u1Segs);
            ComputeFracStepInfo(nv0, &dv0, &v0Segs);
            ComputeFracStepInfo(nv1, &dv1, &v1Segs);

            ComputeFracStepInfo(nuMid, &duMid, &uMidSegs);
            ComputeFracStepInfo(nvMid, &dvMid, &vMidSegs);

            ComputeFracStepInfo(nu0Old, &du0Old, NULL);
            ComputeFracStepInfo(nu1Old, &du1Old, NULL);
            ComputeFracStepInfo(nv0Old, &dv0Old, NULL);
            ComputeFracStepInfo(nv1Old, &dv1Old, NULL);

            ComputeFracStepInfo(nuMidOld, &duMidOld, NULL);
            ComputeFracStepInfo(nvMidOld, &dvMidOld, NULL);

            evalCommonSetup(info, MAX(u0Segs, u1Segs), MAX(v0Segs, v1Segs));      // various common init for patches

            if (info->swatchFlags & NV_PATCH_SWATCH) {
                // scale to init all matrices and curves to big steps
                du0 *= info->maxSwatch;
                du1 *= info->maxSwatch;
                dv0 *= info->maxSwatch;
                dv1 *= info->maxSwatch;
                duMid *= info->maxSwatch;
                dvMid *= info->maxSwatch;
            }
            if (MAX(u0Segs,u1Segs) > info->maxSwatch || MAX(v0Segs,v1Segs) > info->maxSwatch) {
                du0Old *= info->maxSwatch;
                du1Old *= info->maxSwatch;
                dv0Old *= info->maxSwatch;
                dv1Old *= info->maxSwatch;
                duMidOld *= info->maxSwatch;
                dvMidOld *= info->maxSwatch;
            }

            // Compute FD matrices in each of the 4 orientations
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int uorder = map->uorder;
                    int vorder = map->vorder;
                    int ufStride = map->ufStride;
                    int vfStride = map->vfStride;

                    nvAssert(quadInfo->m00[i]);
                    nvAssert(quadInfo->m10[i]);
                    nvAssert(quadInfo->m01[i]);
                    nvAssert(quadInfo->m11[i]);
                    nvAssert(quadInfo->guardQF[i]);

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // Compute FD matrix for each subpatch
                        ComputeFDMatrixFlip(info, map, uorder, vorder, duMid, dvMid, quadInfo->m00[i],
                                                rawData, 0, 0, info->maps[i].ufStride, info->maps[i].vfStride);
                        ComputeFDMatrixFlip(info, map, uorder, vorder, duMid, dvMid, quadInfo->m10[i],
                                                rawData, 0, uorder-1, -info->maps[i].ufStride, info->maps[i].vfStride);
                        ComputeFDMatrixFlip(info, map, uorder, vorder, duMid, dvMid, quadInfo->m01[i],
                                                rawData, vorder-1, 0, info->maps[i].ufStride, -info->maps[i].vfStride);
                        ComputeFDMatrixFlip(info, map, uorder, vorder, duMid, dvMid, quadInfo->m11[i],
                                                rawData, vorder-1, uorder-1, -info->maps[i].ufStride, -info->maps[i].vfStride);

                        // Compute guard curves /

                        //  |-u10-->|<--u11-|
                        //  |       |       |
                        // v01 m01  |  m11 v11
                        //  |       |       |
                        // \|/      |      \|/
                        //  --------+--------
                        // /|\      |      /|\
                        //  |       |       |
                        // v00 m00  |  m10 v10
                        //  |       |       |
                        //  |-u00-->|<--u01-|
                        //

                        // u00, u01
                        quadInfo->guardQF[i]->guardU00.order = uorder;
                        quadInfo->guardQF[i]->guardU01.order = uorder;
                        ComputeFDCurveFlip(info, uorder, du0, &quadInfo->guardQF[i]->guardU00,
                            pRawData(info, map, rawData, 0, 0), info->maps[i].ufStride * sizeof(float), 1, info->flipU);
                        ComputeFDCurveFlip(info, uorder, du0, &quadInfo->guardQF[i]->guardU01,
                            pRawData(info, map, rawData, 0, 0), info->maps[i].ufStride * sizeof(float), 0, info->flipU);

                        // u10, u11
                        quadInfo->guardQF[i]->guardU10.order = uorder;
                        quadInfo->guardQF[i]->guardU11.order = uorder;
                        ComputeFDCurveFlip(info, uorder, du1, &quadInfo->guardQF[i]->guardU10,
                            pRawData(info, map, rawData, vorder-1, 0), info->maps[i].ufStride * sizeof(float), 1, info->flipU);
                        ComputeFDCurveFlip(info, uorder, du1, &quadInfo->guardQF[i]->guardU11,
                            pRawData(info, map, rawData, vorder-1, 0), info->maps[i].ufStride * sizeof(float), 0, info->flipU);

                        // v00, v01
                        quadInfo->guardQF[i]->guardV00.order = vorder;
                        quadInfo->guardQF[i]->guardV01.order = vorder;
                        ComputeFDCurveFlip(info, vorder, dv0, &quadInfo->guardQF[i]->guardV00,
                            pRawData(info, map, rawData, 0, 0), info->maps[i].vfStride * sizeof(float), 1, info->flipV);
                        ComputeFDCurveFlip(info, vorder, dv0, &quadInfo->guardQF[i]->guardV01,
                            pRawData(info, map, rawData, 0, 0), info->maps[i].vfStride * sizeof(float), 0, info->flipV);

                        // v10, v11
                        quadInfo->guardQF[i]->guardV10.order = vorder;
                        quadInfo->guardQF[i]->guardV11.order = vorder;
                        ComputeFDCurveFlip(info, vorder, dv1, &quadInfo->guardQF[i]->guardV10,
                            pRawData(info, map, rawData, 0, uorder-1), info->maps[i].vfStride * sizeof(float), 1, info->flipV);
                        ComputeFDCurveFlip(info, vorder, dv1, &quadInfo->guardQF[i]->guardV11,
                            pRawData(info, map, rawData, 0, uorder-1), info->maps[i].vfStride * sizeof(float), 0, info->flipV);

                        // uCenter0, uCenter1
                        quadInfo->guardQF[i]->guardUCenter0.order = uorder;
                        quadInfo->guardQF[i]->guardUCenter1.order = uorder;
                        for (j = 0; j < uorder; j++) {
                            ComputeCurvePoint(vorder, &curvePoints[j][0], pRawData(info, map, rawData, 0, j), vfStride * sizeof(float), .5);
                        }
                        ComputeFDCurveFlip(info, uorder, duMid, &quadInfo->guardQF[i]->guardUCenter0,
                            &curvePoints[0][0], 4 * sizeof(float), 1, 0);
                        ComputeFDCurveFlip(info, uorder, duMid, &quadInfo->guardQF[i]->guardUCenter1,
                            &curvePoints[0][0], 4 * sizeof(float), 0, 0);

                        // vCenter0, vCenter1
                        quadInfo->guardQF[i]->guardVCenter0.order = vorder;
                        quadInfo->guardQF[i]->guardVCenter1.order = vorder;
                        for (j = 0; j < vorder; j++) {
                            ComputeCurvePoint(uorder, &curvePoints[j][0], pRawData(info, map, rawData, j, 0),
                                                ufStride*sizeof(float),.5);
                        }
                        ComputeFDCurveFlip(info, vorder, dvMid, &quadInfo->guardQF[i]->guardVCenter0,
                            &curvePoints[0][0], 4 * sizeof(float), 1, 0);
                        ComputeFDCurveFlip(info, vorder, dvMid, &quadInfo->guardQF[i]->guardVCenter1,
                            &curvePoints[0][0], 4 * sizeof(float), 0, 0);

                        // Compute points
                        // DCR seems to me we computed these already above!!! why duplicate it here?
                        // u0Mid
                        ComputeCurvePoint(uorder, quadInfo->guardQF[i]->u0Mid, pRawData(info, map, rawData, 0, 0),
                                                ufStride * sizeof(float), .5);

                        // u1Mid
                        ComputeCurvePoint(uorder, quadInfo->guardQF[i]->u1Mid, pRawData(info, map, rawData, vorder-1, 0),
                                                ufStride * sizeof(float), .5);

                        // v0Mid
                        ComputeCurvePoint(vorder, quadInfo->guardQF[i]->v0Mid, pRawData(info, map, rawData, 0, 0),
                                                vfStride * sizeof(float), .5);

                        // v1Mid
                        ComputeCurvePoint(vorder, quadInfo->guardQF[i]->v1Mid, pRawData(info, map, rawData, 0, uorder-1),
                                                vfStride * sizeof(float), .5);

                        // center
                        for (j = 0; j < uorder; j++) {
                            ComputeCurvePoint(vorder, &curvePoints[j][0], pRawData(info, map, rawData, 0, j),
                                                vfStride * sizeof(float), .5);
                        }
                        ComputeCurvePoint(uorder, quadInfo->guardQF[i]->center, &curvePoints[0][0],
                                                4*sizeof(float), .5);

                        info->originaltess = info->tess;
                        info->maps[i].dirtyFlags = 0;

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        RetessellateFDMatrix(info, duMidOld, dvMidOld, duMid, dvMid, quadInfo->m00[i]);
                        RetessellateFDMatrix(info, duMidOld, dvMidOld, duMid, dvMid, quadInfo->m10[i]);
                        RetessellateFDMatrix(info, duMidOld, dvMidOld, duMid, dvMid, quadInfo->m01[i]);
                        RetessellateFDMatrix(info, duMidOld, dvMidOld, duMid, dvMid, quadInfo->m11[i]);

                        RetessellateFDCurve(info, du0Old, du0, &quadInfo->guardQF[i]->guardU00, 0);
                        RetessellateFDCurve(info, du0Old, du0, &quadInfo->guardQF[i]->guardU01, 0);
                        RetessellateFDCurve(info, du1Old, du1, &quadInfo->guardQF[i]->guardU10, 0);
                        RetessellateFDCurve(info, du1Old, du1, &quadInfo->guardQF[i]->guardU11, 0);
                        RetessellateFDCurve(info, dv0Old, dv0, &quadInfo->guardQF[i]->guardV00, 0);
                        RetessellateFDCurve(info, dv0Old, dv0, &quadInfo->guardQF[i]->guardV01, 0);
                        RetessellateFDCurve(info, dv1Old, dv1, &quadInfo->guardQF[i]->guardV10, 0);
                        RetessellateFDCurve(info, dv1Old, dv1, &quadInfo->guardQF[i]->guardV11, 0);

                        RetessellateFDCurve(info, duMidOld, duMid, &quadInfo->guardQF[i]->guardUCenter0, 0);
                        RetessellateFDCurve(info, duMidOld, duMid, &quadInfo->guardQF[i]->guardUCenter1, 0);
                        RetessellateFDCurve(info, dvMidOld, dvMid, &quadInfo->guardQF[i]->guardVCenter0, 0);
                        RetessellateFDCurve(info, dvMidOld, dvMid, &quadInfo->guardQF[i]->guardVCenter1, 0);

                        info->originaltess = info->tess;
                        info->maps[i].dirtyFlags &= ~NV_PATCH_DIRTY_TESSELLATION;
                    }
                }
            }

            // DCR: should we be guard curving ALL attributes?  HW doesn't.
            // FBF: the names are mis-leading. They are actually full attribute curves
            // used when doing the regular grid and transitions. But, they are also "guards"
            // in the sense that they are used to provide a consistent set of values
            // for position and normal along the various sub-patch directions.
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    // Curves
                    quadInfo->pU0[i] = &quadInfo->guardQF[i]->guardU00;
                    quadInfo->pV0[i] = &quadInfo->guardQF[i]->guardV00;
                    quadInfo->pU1[i] = &quadInfo->guardQF[i]->guardUCenter0;
                    quadInfo->pV1[i] = &quadInfo->guardQF[i]->guardVCenter0;

                    // Points
                    quadInfo->pCorners[i][0][0] = quadInfo->m00[i]->data[0][0];
                    quadInfo->pCorners[i][0][1] = quadInfo->guardQF[i]->u0Mid;
                    quadInfo->pCorners[i][1][0] = quadInfo->guardQF[i]->v0Mid;
                    quadInfo->pCorners[i][1][1] = quadInfo->guardQF[i]->center;
                }
            }

            retVal |= DrawFracPatch(info, u0Segs, uMidSegs, v0Segs, vMidSegs, 0, quadInfo->m00);
            NV_TRACE_CODE(
                if (skipQuads) {
                    goto nvEvalPatchEnd;
                }
                //ffevalTrace = 0;
            );

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    // Curves
                    quadInfo->pU0[i] = &quadInfo->guardQF[i]->guardU01;
                    quadInfo->pV0[i] = &quadInfo->guardQF[i]->guardV10;
                    quadInfo->pU1[i] = &quadInfo->guardQF[i]->guardUCenter1;
                    quadInfo->pV1[i] = &quadInfo->guardQF[i]->guardVCenter0;

                    // Points
                    quadInfo->pCorners[i][0][0] = quadInfo->m10[i]->data[0][0];
                    quadInfo->pCorners[i][0][1] = quadInfo->guardQF[i]->u0Mid;
                    quadInfo->pCorners[i][1][0] = quadInfo->guardQF[i]->v1Mid;
                    quadInfo->pCorners[i][1][1] = quadInfo->guardQF[i]->center;
                }
            }

            retVal |= DrawFracPatch(info, u0Segs, uMidSegs, v1Segs, vMidSegs, 1, quadInfo->m10);

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    // Curves
                    quadInfo->pU0[i] = &quadInfo->guardQF[i]->guardU10;
                    quadInfo->pV0[i] = &quadInfo->guardQF[i]->guardV01;
                    quadInfo->pU1[i] = &quadInfo->guardQF[i]->guardUCenter0;
                    quadInfo->pV1[i] = &quadInfo->guardQF[i]->guardVCenter1;

                    // Points
                    quadInfo->pCorners[i][0][0] = quadInfo->m01[i]->data[0][0];
                    quadInfo->pCorners[i][0][1] = quadInfo->guardQF[i]->u1Mid;
                    quadInfo->pCorners[i][1][0] = quadInfo->guardQF[i]->v0Mid;
                    quadInfo->pCorners[i][1][1] = quadInfo->guardQF[i]->center;
                }
            }

            retVal |= DrawFracPatch(info, u1Segs, uMidSegs, v0Segs, vMidSegs, 1, quadInfo->m01);

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    // Curves
                    quadInfo->pU0[i] = &quadInfo->guardQF[i]->guardU11;
                    quadInfo->pV0[i] = &quadInfo->guardQF[i]->guardV11;
                    quadInfo->pU1[i] = &quadInfo->guardQF[i]->guardUCenter1;
                    quadInfo->pV1[i] = &quadInfo->guardQF[i]->guardVCenter1;

                    // Points
                    quadInfo->pCorners[i][0][0] = quadInfo->m11[i]->data[0][0];
                    quadInfo->pCorners[i][0][1] = quadInfo->guardQF[i]->u1Mid;
                    quadInfo->pCorners[i][1][0] = quadInfo->guardQF[i]->v1Mid;
                    quadInfo->pCorners[i][1][1] = quadInfo->guardQF[i]->center;
                }
            }

            retVal |= DrawFracPatch(info, u1Segs, uMidSegs, v1Segs, vMidSegs, 0, quadInfo->m11);

        /*****************************************************************************/
        } else {    // QUAD INTEGER TESSELLATION
            int transpose = MaybeTransposeFlipQuad(info);
            int stitchBottom = (quadInfo->nu0 < quadInfo->nu1);
            int stitchTop = (quadInfo->nu0 > quadInfo->nu1);
            int stitchLeft = (quadInfo->nv0 < quadInfo->nv1);
            int stitchRight = (quadInfo->nv0 > quadInfo->nv1);

            float du0 = 1.0f / quadInfo->nu0;
            float du1 = 1.0f / quadInfo->nu1;
            float dv0 = 1.0f / quadInfo->nv0;
            float dv1 = 1.0f / quadInfo->nv1;

            float duMax = 1.0f / quadInfo->uMaxSegs;
            float dvMax = 1.0f / quadInfo->vMaxSegs;

            int nu0Old;
            int nv0Old;
            int nu1Old;
            int nv1Old;
            int nuMaxOld;
            int nvMaxOld;
            float du0Old;
            float du1Old;
            float dv0Old;
            float dv1Old;
            float duMaxOld;
            float dvMaxOld;
            int uMaxDir, vMaxDir;
            int stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd;

            if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                ComputeEdgeDirections(info, 0, &info->maps[ATTR_V], &quadInfo->u0Dir, &quadInfo->u1Dir, &quadInfo->v0Dir, &quadInfo->v1Dir);
            }
            else if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                ComputeEdgeDirectionsFromCorners(info, 0, &quadInfo->u0Dir, &quadInfo->u1Dir, &quadInfo->v0Dir, &quadInfo->v1Dir);
            }

            if (quadInfo->uMaxSegs == 1) {
                // then reverse transitions in U do not matter
                quadInfo->u0Dir = quadInfo->u1Dir = 1;
            }
            if (quadInfo->vMaxSegs == 1) {
                // then reverse transitions in V do not matter
                quadInfo->v0Dir = quadInfo->v1Dir = 1;
            }

            // Fill in directions of max and min edges
            if (quadInfo->nu0 >= quadInfo->nu1) {
                uMaxDir = quadInfo->u0Dir;
            } else {
                uMaxDir = quadInfo->u1Dir;
            }
            if (quadInfo->nv0 >= quadInfo->nv1) {
                vMaxDir = quadInfo->v0Dir;
            } else {
                vMaxDir = quadInfo->v1Dir;
            }

            if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                quadInfo->olduMaxDir = quadInfo->uMaxDir;
                quadInfo->oldvMaxDir = quadInfo->vMaxDir;
                quadInfo->oldu0Dir   = quadInfo->u0Dir;
                quadInfo->oldu1Dir   = quadInfo->u1Dir;
                quadInfo->oldv0Dir   = quadInfo->v0Dir;
                quadInfo->oldv1Dir   = quadInfo->v1Dir;
            }

            if (info->flags & NV_PATCH_FLAG_SOME_DIRTY_TESS) {
                // compute the du/dvMaxOld for retessellations
                nu0Old = (int)(info->originaltess.tensor.nu0 + 0.999f);
                nv0Old = (int)(info->originaltess.tensor.nv0 + 0.999f);
                nu1Old = (int)(info->originaltess.tensor.nu1 + 0.999f);
                nv1Old = (int)(info->originaltess.tensor.nv1 + 0.999f);
                nuMaxOld = MAX(nu0Old,nu1Old);
                nvMaxOld = MAX(nv0Old,nv1Old);
                du0Old = 1.0f / nu0Old;
                du1Old = 1.0f / nu1Old;
                dv0Old = 1.0f / nv0Old;
                dv1Old = 1.0f / nv1Old;
                duMaxOld = 1.0f / nuMaxOld;
                dvMaxOld = 1.0f / nvMaxOld;
            }

            info->originaltess = info->tess;
            quadInfo->uMaxDir = uMaxDir;
            quadInfo->vMaxDir = vMaxDir;
            quadInfo->du0 = du0;
            quadInfo->du1 = du1;
            quadInfo->dv0 = dv0;
            quadInfo->dv1 = dv1;
            quadInfo->duMax = duMax;
            quadInfo->dvMax = dvMax;

            evalCommonSetup(info, quadInfo->uMaxSegs, quadInfo->vMaxSegs);      // various common init for patches

            if (info->swatchFlags & NV_PATCH_SWATCH) {
                // scale to init all matrices and curves to big steps
                du0 *= info->maxSwatch;
                du1 *= info->maxSwatch;
                dv0 *= info->maxSwatch;
                dv1 *= info->maxSwatch;
                duMax *= info->maxSwatch;
                dvMax *= info->maxSwatch;
            }
            if (nuMaxOld > info->maxSwatch || nvMaxOld > info->maxSwatch) {
                du0Old *= info->maxSwatch;
                du1Old *= info->maxSwatch;
                dv0Old *= info->maxSwatch;
                dv1Old *= info->maxSwatch;
                duMaxOld *= info->maxSwatch;
                dvMaxOld *= info->maxSwatch;
            }

            // We always tessellate in the "MaxDir" direction
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int uorder = map->uorder;
                    int vorder = map->vorder;

                    nvAssert(quadInfo->m00[i]);
                    nvAssert(quadInfo->pU0[i]);
                    nvAssert(quadInfo->pU1[i]);
                    nvAssert(quadInfo->pV0[i]);
                    nvAssert(quadInfo->pV1[i]);
                    nvAssert(quadInfo->pVInner[i]);
                    nvAssert(quadInfo->pVInner[i]);

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // compute FDMatrix given the modified origin according to u/vDir
                        if (vMaxDir == 1) {
                            if (uMaxDir == 1) {
                                ComputeFDMatrixFlip(info, map, uorder, vorder, duMax, dvMax, quadInfo->m00[i],
                                    rawData, 0, 0, info->maps[i].ufStride, info->maps[i].vfStride);
                            } else {
                                ComputeFDMatrixFlip(info, map, uorder, vorder, duMax, dvMax, quadInfo->m00[i],
                                    rawData, 0, uorder-1, -info->maps[i].ufStride, info->maps[i].vfStride);
                            }
                        } else {
                            if (uMaxDir == 1) {
                                ComputeFDMatrixFlip(info, map, uorder, vorder, duMax, dvMax, quadInfo->m00[i],
                                    rawData, vorder-1, 0, info->maps[i].ufStride, -info->maps[i].vfStride);
                            } else {
                                ComputeFDMatrixFlip(info, map, uorder, vorder, duMax, dvMax, quadInfo->m00[i],
                                    rawData, vorder-1, uorder-1, -info->maps[i].ufStride, -info->maps[i].vfStride);
                            }
                        }

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        RetessellateFDMatrix(info, duMaxOld, dvMaxOld, duMax, dvMax, quadInfo->m00[i]);
                    }
                }
            }

            // Reverse transitions may cause stitches
            // If dir's are not equal, AND there are no stitches for other reasons,
            // AND it's not degenerate in this direction, then ...
            if ((quadInfo->u0Dir != quadInfo->u1Dir) && !stitchBottom && !stitchTop && (quadInfo->nu0 > 1)) {
                nvAssert(quadInfo->nu0 == quadInfo->nu1);
                stitchTop = 1;          // make a stitch for the reversal
            }
            if ((quadInfo->v0Dir != quadInfo->v1Dir) && !stitchLeft && !stitchRight && (quadInfo->nv0 > 1)) {
                nvAssert(quadInfo->nv0 == quadInfo->nv1);
                stitchRight = 1;        // make a stitch for the reversal
            }

            // Decide where the stitching occurs w.r.t. the regular region
            if (uMaxDir == 1) {
                stitchUBegin = stitchLeft;
                stitchUEnd = stitchRight;
            } else {
                stitchUBegin = stitchRight;
                stitchUEnd = stitchLeft;
            }
            if (vMaxDir == 1) {
                stitchVBegin = stitchBottom;
                stitchVEnd = stitchTop;
            } else {
                stitchVBegin = stitchTop;
                stitchVEnd = stitchBottom;
            }

            quadInfo->stitchLeft   = stitchLeft;
            quadInfo->stitchRight  = stitchRight;
            quadInfo->stitchBottom = stitchBottom;
            quadInfo->stitchTop    = stitchTop;
            quadInfo->stitchUBegin = stitchUBegin;
            quadInfo->stitchUEnd   = stitchUEnd;
            quadInfo->stitchVBegin = stitchVBegin;
            quadInfo->stitchVEnd   = stitchVEnd;

            // calc if U/V inner guards required
            quadInfo->needUInner = (quadInfo->vMaxSegs > 1) && (stitchBottom || stitchTop);
            quadInfo->needVInner = (quadInfo->uMaxSegs > 1) && (stitchLeft || stitchRight);

            NV_TRACE_COND(TR_EVAL, 25,
                TPRINTF(("dir BTLR=[%d %d %d %d]  uMaxDir=%d vMaxDir=%d\n",
                        quadInfo->u0Dir, quadInfo->u1Dir, quadInfo->v0Dir, quadInfo->v1Dir, uMaxDir, vMaxDir));
                TPRINTF(("  stitch BTLR=[%d %d %d %d]  stitch UBE=[%d %d] VBE=[%d %d]\n",
                        stitchBottom, stitchTop, stitchLeft, stitchRight,
                        stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd ));
                TPRINTF(("force rev bits=%d %d %d %d\n",
                        (nvDebugOptions & TRO_TEMP1) != 0,
                        (nvDebugOptions & TRO_TEMP2) != 0,
                        (nvDebugOptions & TRO_TEMP3) != 0,
                        (nvDebugOptions & TRO_TEMP4) != 0));
            );

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int uorder = map->uorder;
                    int vorder = map->vorder;

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // Store the corner points
                        getRawData(info, &info->maps[i], rawData, 0,               0, quadInfo->pCorners[i][0][0]);
                        getRawData(info, &info->maps[i], rawData, 0,        uorder-1, quadInfo->pCorners[i][0][1]);
                        getRawData(info, &info->maps[i], rawData, vorder-1, 0,        quadInfo->pCorners[i][1][0]);
                        getRawData(info, &info->maps[i], rawData, vorder-1, uorder-1, quadInfo->pCorners[i][1][1]);

                        // Compute U boundary curves
                        quadInfo->pU0[i]->order = uorder;
                        quadInfo->pU1[i]->order = uorder;
                        ComputeFDCurveFlip(info, uorder, du0, quadInfo->pU0[i],
                            pRawData(info, map, rawData, 0, 0),
                            info->maps[i].ufStride * sizeof(float), quadInfo->u0Dir, info->flipU);
                        ComputeFDCurveFlip(info, uorder, du1, quadInfo->pU1[i],
                            pRawData(info, map, rawData, vorder-1, 0),
                            info->maps[i].ufStride * sizeof(float), quadInfo->u1Dir, info->flipU);

                        // Compute V boundary curves
                        quadInfo->pV0[i]->order = vorder;
                        quadInfo->pV1[i]->order = vorder;
                        ComputeFDCurveFlip(info, vorder, dv0, quadInfo->pV0[i],
                            pRawData(info, map, rawData, 0, 0),
                            info->maps[i].vfStride * sizeof(float), quadInfo->v0Dir, info->flipV);
                        ComputeFDCurveFlip(info, vorder, dv1, quadInfo->pV1[i],
                            pRawData(info, map, rawData, 0, uorder-1),
                            info->maps[i].vfStride * sizeof(float), quadInfo->v1Dir, info->flipV);

                        info->maps[i].dirtyFlags = 0;

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        // Recompute U boundary curves
                        if (quadInfo->oldu0Dir == quadInfo->u0Dir) RetessellateFDCurve(info, du0Old, du0, quadInfo->pU0[i], 0);
                        else                                       RetessellateFDCurve(info, du0Old, du0, quadInfo->pU0[i], 1);                        
                        if (quadInfo->oldu1Dir == quadInfo->u1Dir) RetessellateFDCurve(info, du1Old, du1, quadInfo->pU1[i], 0);
                        else                                       RetessellateFDCurve(info, du1Old, du1, quadInfo->pU1[i], 1);

                        // Recompute V boundary curves
                        if (quadInfo->oldv0Dir == quadInfo->v0Dir) RetessellateFDCurve(info, dv0Old, dv0, quadInfo->pV0[i], 0);
                        else                                       RetessellateFDCurve(info, dv0Old, dv0, quadInfo->pV0[i], 1);
                        if (quadInfo->oldv1Dir == quadInfo->v1Dir) RetessellateFDCurve(info, dv1Old, dv1, quadInfo->pV1[i], 0);
                        else                                       RetessellateFDCurve(info, dv1Old, dv1, quadInfo->pV1[i], 1);

                        info->maps[i].dirtyFlags &= ~NV_PATCH_DIRTY_TESSELLATION;
                    }
                }
            }
            
            //save off current diretions so we can assess if the traversal direction
            //changed on a subsequent render
            quadInfo->olduMaxDir = quadInfo->uMaxDir;
            quadInfo->oldvMaxDir = quadInfo->vMaxDir;               
            quadInfo->oldu0Dir   = quadInfo->u0Dir;
            quadInfo->oldu1Dir   = quadInfo->u1Dir;
            quadInfo->oldv0Dir   = quadInfo->v0Dir;
            quadInfo->oldv1Dir   = quadInfo->v1Dir;
            retVal |= DrawIntPatch(info, quadInfo, quadInfo->m00);
        }

    /*****************************************************************************/
    } else {
        // TRI FRAC TESSELLATION
        if (info->flags & NV_PATCH_FLAG_TESS_FRACTIONAL) {
            int transpose = MaybeTransposeFlipTri(info);
            float n1 = info->tess.tri.n1;
            float n2 = info->tess.tri.n2;
            float n3 = info->tess.tri.n3;
            float nMid = (n1 + n2 + n3)/3.0f;
            float n1Old = info->originaltess.tri.n1;
            float n2Old = info->originaltess.tri.n2;
            float n3Old = info->originaltess.tri.n3;
            float nMidOld = (n1 + n2 + n3)/3.0f;
            float duv[3], duvMid, duvOld[3], duvMidOld;
            int segs[3], midSegs, vMax;
            FDMatrix *m[3][NV_PATCH_NUMBER_OF_ATTRIBS];

            //guard = NULL;
            for (i = 0; i < info->maxAttr; i++) {
                m[0][i] = quadInfo->m00[i];
                m[1][i] = quadInfo->m10[i];
                m[2][i] = quadInfo->m01[i];
            }

            ComputeFracStepInfo(n1, &duv[0], &segs[0]);
            ComputeFracStepInfo(n2, &duv[1], &segs[1]);
            ComputeFracStepInfo(n3, &duv[2], &segs[2]);

            ComputeFracStepInfo(nMid, &duvMid, &midSegs);
            duvMid *= 2;

            ComputeFracStepInfo(n1Old, &duvOld[0], NULL);
            ComputeFracStepInfo(n2Old, &duvOld[1], NULL);
            ComputeFracStepInfo(n3Old, &duvOld[2], NULL);

            ComputeFracStepInfo(nMidOld, &duvMidOld, NULL);
            duvMidOld *= 2;

            vMax = MAX(segs[1], segs[2]);
            evalCommonSetup(info, MAX(segs[0], midSegs), MAX(vMax, midSegs));        // various common init for patches

            if (info->swatchFlags & NV_PATCH_SWATCH) {
                // scale to init all matrices and curves to big steps
                duv[0] *= info->maxSwatch;
                duv[1] *= info->maxSwatch;
                duv[2] *= info->maxSwatch;
                duvMid *= info->maxSwatch;
            }

            // Compute FD matrices in each of the 3 orientations
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int order = map->uorder;
                    int ufStride = map->ufStride;
                    int vfStride = map->vfStride;
                    int k, l;

                    nvAssert(info->maps[i].uorder == info->maps[i].vorder);

                    // Compute FD matrix for each subpatch
                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        for (j = 0; j < 3; j++) {
                            info->reparam.rows = info->reparam.columns = order;
                            for (l = 0; l < order; l++) {       // V order
                                for (k = 0; k < order-l; k++) { // U order
                                    getRawData(info, &info->maps[i], rawData, l, k, info->reparam.data[l][k]);
                                }
                            }
                            ReparameterizeTriPatch(info, &info->reparam, m[j][i], j, 1);

                            quadInfo->guardTF[i]->guardCenter[j].order = order;
                            if (TriPatchLayout[j].centerCurve) {
                                ComputeFDCurveFlip(info, order, duvMid, &quadInfo->guardTF[i]->guardCenter[j],
                                    &m[j][i]->data[order-1][0][0],
                                    4 * sizeof(float), 1, 0);
                            } else {
                                ComputeFDCurveFlip(info, order, duvMid, &quadInfo->guardTF[i]->guardCenter[j],
                                    &m[j][i]->data[0][order-1][0],
                                    4*NV_PATCH_MAX_ORDER*sizeof(float), 1, 0);
                            }

                            ComputeFDMatrixFlip(info, 0, order, order, duvMid, duvMid, m[j][i],
                                &m[j][i]->data[0][0][0], 0, 0, 4, 4*NV_PATCH_MAX_ORDER);
                        }

                        // Compute guard curves /

                        //  |\
                        //  | \
                        //  |  \
                        // 20   11
                        //  |     \
                        //  |      \|
                        // \|/     -\
                        //  +        +
                        // /|\-    _/ \-
                        //  |  \-+/   |\
                        //  |     \     \
                        // 21      |    10
                        //  |      \      \
                        //  |       |      \
                        //  |--00-->|<---01-|
                        //
                        // 00, 01
                        quadInfo->guardTF[i]->guard[0][0].order = order;
                        quadInfo->guardTF[i]->guard[0][1].order = order;

                        ComputeFDCurveFlip(info, order, duv[0], &quadInfo->guardTF[i]->guard[0][0],
                            pRawData(info, map, rawData, 0, 0),
                            ufStride * sizeof(float), 1, info->flipU);
                        ComputeFDCurveFlip(info, order, duv[0], &quadInfo->guardTF[i]->guard[0][1],
                            pRawData(info, map, rawData, 0, 0),
                            ufStride * sizeof(float), 0, info->flipU);

                        // 10, 11
                        quadInfo->guardTF[i]->guard[1][0].order = order;
                        quadInfo->guardTF[i]->guard[1][1].order = order;
                        ComputeFDCurveFlip(info, order, duv[1], &quadInfo->guardTF[i]->guard[1][0],
                            pRawData(info, map, rawData, 0, order-1),
                            (vfStride-4) * sizeof(float), 1, info->flipU);
                        ComputeFDCurveFlip(info, order, duv[1], &quadInfo->guardTF[i]->guard[1][1],
                            pRawData(info, map, rawData, 0, order-1),
                            (vfStride-4) * sizeof(float), 0, info->flipU);

                        // 20, 21
                        quadInfo->guardTF[i]->guard[2][0].order = order;
                        quadInfo->guardTF[i]->guard[2][1].order = order;
                        ComputeFDCurveFlip(info, order, duv[2], &quadInfo->guardTF[i]->guard[2][0],
                            pRawData(info, map, rawData, 0, 0),
                            vfStride * sizeof(float), 0, info->flipU);
                        ComputeFDCurveFlip(info, order, duv[2], &quadInfo->guardTF[i]->guard[2][1],
                            pRawData(info, map, rawData, 0, 0),
                            vfStride * sizeof(float), 1, info->flipU);

                        // Compute points
                        // mid0,1,2
                        ComputeCurvePoint(order, quadInfo->guardTF[i]->mid[0],
                                            pRawData(info, map, rawData, 0, 0),
                                            ufStride * sizeof(float), .5);
                        ComputeCurvePoint(order, quadInfo->guardTF[i]->mid[1],
                                            pRawData(info, map, rawData, 0, order-1),
                                            (vfStride-4) * sizeof(float), .5);
                        ComputeCurvePoint(order, quadInfo->guardTF[i]->mid[2],
                                            pRawData(info, map, rawData, 0, 0),
                                            vfStride * sizeof(float), .5);

                        // center
                        ComputeTriPatchCenter(order, quadInfo->guardTF[i]->center, pRawData(info, map, rawData, 0, 0),
                            ufStride * sizeof(float), vfStride * sizeof(float));

                        info->maps[i].dirtyFlags = 0;
                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        for (j = 0; j < 3; j++) {
                            RetessellateFDMatrix(info, duvMidOld, duvMidOld, duvMid, duvMid, m[j][i]);
                            //BUG BUG WE NEED TO ASSES IF CURVES CHANGED DIRECTION
                            RetessellateFDCurve(info, duvOld[j], duv[j], &quadInfo->guardTF[i]->guard[j][0], 0);
                            RetessellateFDCurve(info, duvOld[j], duv[j], &quadInfo->guardTF[i]->guard[j][1], 0);

                            RetessellateFDCurve(info, duvMidOld, duvMid, &quadInfo->guardTF[i]->guardCenter[j], 0);
                        }

                        info->maps[i].dirtyFlags &= ~NV_PATCH_DIRTY_TESSELLATION;
                    }
                }
            }
            info->originaltess = info->tess;

            for (j = 0; j < 3; j++) {
                int uSide   = TriPatchLayout[j].uSide;
                int vSide   = TriPatchLayout[j].vSide;
                int uDir    = TriPatchLayout[j].uDir;
                int vDir    = TriPatchLayout[j].vDir;
                int reverse = TriPatchLayout[j].reverse;

                for (i = 0; i < info->maxAttr; i++) {
                    if (info->evalEnables & (1 << i)) {
                        // Curves
                        quadInfo->pU0[i] = &quadInfo->guardTF[i]->guard[uSide][uDir];
                        quadInfo->pV0[i] = &quadInfo->guardTF[i]->guard[vSide][vDir];
                        quadInfo->pU1[i] = &quadInfo->guardTF[i]->guardCenter[vSide];
                        quadInfo->pV1[i] = &quadInfo->guardTF[i]->guardCenter[uSide];

                        // Points
                        quadInfo->pCorners[i][0][0] = m[j][i]->data[0][0];
                        quadInfo->pCorners[i][0][1] = quadInfo->guardTF[i]->mid[uSide];
                        quadInfo->pCorners[i][1][0] = quadInfo->guardTF[i]->mid[vSide];
                        quadInfo->pCorners[i][1][1] = quadInfo->guardTF[i]->center;
                    }
                }

                retVal |= DrawFracPatch(info, segs[uSide], midSegs, segs[vSide], midSegs, reverse, m[j]);
                NV_TRACE_CODE(
                    if (skipQuads) {
                        break;
                    }
                    //ffevalTrace = 0;
                );
            }

        /*****************************************************************************/
        } else {    // TRI INTEGER TESSELLATION
            int transpose = MaybeTransposeFlipTri(info);

            float du0 = 1.0f / quadInfo->nu0;
            float du1 = 1.0f;
            float dv0 = 1.0f / quadInfo->nv0;
            float dv1 = 1.0f / quadInfo->nv1;
            float duMax = 1.0f / quadInfo->uMaxSegs;
            float dvMax = 1.0f / quadInfo->vMaxSegs;

            int n1Old = (int)(info->originaltess.tri.n1 + 0.999f);
            int n2Old = (int)(info->originaltess.tri.n2 + 0.999f);
            int n3Old = (int)(info->originaltess.tri.n3 + 0.999f);
            int nuMaxOld = n1Old;
            int nvMaxOld = MAX(n2Old,n3Old);

            float du0Old = 1.0f / n1Old;
            float du1Old = 1.0f;
            float dv0Old = 1.0f / n3Old;
            float dv1Old = 1.0f / n2Old;
            float duMaxOld = 1.0f / nuMaxOld;
            float dvMaxOld = 1.0f / nvMaxOld;

            int uMaxDir, vMaxDir;
            int stitchBottom = 0;
            int stitchTop = (quadInfo->nu0 > 1);
            int stitchLeft = (quadInfo->nv0 < quadInfo->nv1);
            int stitchRight = (quadInfo->nv0 > quadInfo->nv1);
            int stitchUBegin, stitchUEnd, stitchVBegin, stitchVEnd;

            if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                //only compute edge directions when I have some map info around
                ComputeEdgeDirections(info, 1, &info->maps[ATTR_V],
                        &quadInfo->u0Dir, &quadInfo->u1Dir, &quadInfo->v0Dir, &quadInfo->v1Dir);
            }
            /*if (info->maps[ATTR_V].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                ComputeEdgeDirectionsFromCorners(info, 1, &quadInfo->u0Dir, &quadInfo->u1Dir, &quadInfo->v0Dir, &quadInfo->v1Dir);
            }*/

            if (quadInfo->uMaxSegs == 1) {
                // then reverse transitions in U do not matter
                quadInfo->u0Dir = quadInfo->u1Dir = 1;
            }
            if (quadInfo->vMaxSegs == 1) {
                // then reverse transitions in V do not matter
                quadInfo->v0Dir = quadInfo->v1Dir = 1;
            }

            // Fill in directions of max and min edges
            uMaxDir = quadInfo->u0Dir;
            if (quadInfo->nv0 >= quadInfo->nv1) {
                vMaxDir = quadInfo->v0Dir;
            } else {
                vMaxDir = quadInfo->v1Dir;
            }

            info->originaltess = info->tess;
            quadInfo->uMaxDir = uMaxDir;
            quadInfo->vMaxDir = vMaxDir;
            quadInfo->du0 = du0;
            quadInfo->du1 = du1;
            quadInfo->dv0 = dv0;
            quadInfo->dv1 = dv1;
            quadInfo->duMax = duMax;
            quadInfo->dvMax = dvMax;

            evalCommonSetup(info, quadInfo->uMaxSegs, quadInfo->vMaxSegs);      // various common init for patches

            if (info->swatchFlags & NV_PATCH_SWATCH) {
                // scale to init all matrices and curves to big steps
                du0 *= info->maxSwatch;
                du1 *= info->maxSwatch;
                dv0 *= info->maxSwatch;
                dv1 *= info->maxSwatch;
                duMax *= info->maxSwatch;
                dvMax *= info->maxSwatch;
            }
            if (nuMaxOld > info->maxSwatch || nvMaxOld > info->maxSwatch) {      // various common init for patches
                du0Old *= info->maxSwatch;
                du1Old *= info->maxSwatch;
                dv0Old *= info->maxSwatch;
                dv1Old *= info->maxSwatch;
                duMaxOld *= info->maxSwatch;
                dvMaxOld *= info->maxSwatch;
            }

            // Compute FD matrices in each of the 3 orientations
            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int order = map->uorder;
                    int ufStride = map->ufStride;
                    int vfStride = map->vfStride;
                    int k, l;

                    nvAssert(info->maps[i].uorder == info->maps[i].vorder);

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // Compute FD matrix for each subpatch
                        info->reparam.rows = info->reparam.columns = order;
                        for (l = 0; l < order; l++) {
                            for (k = 0; k < order-l; k++) {
                                getRawData(info, &info->maps[i], rawData, l, k, info->reparam.data[l][k]);
                            }
                        }

                        ReparameterizeTriPatch(info, &info->reparam, quadInfo->m00[i], 0, 0);

                        if (vMaxDir == 1) {
                            if (uMaxDir == 1) {
                                ComputeFDMatrixFlip(info, 0, order, order, duMax, dvMax, quadInfo->m00[i],
                                    &quadInfo->m00[i]->data[0][0][0], 0, 0, 4, 4 * NV_PATCH_MAX_ORDER);
                            } else {
                                ComputeFDMatrixFlip(info, 0, order, order, duMax, dvMax, quadInfo->m00[i],
                                    &quadInfo->m00[i]->data[0][order-1][0], 0, 0, -4, 4 * NV_PATCH_MAX_ORDER);
                            }
                        } else {
                            if (uMaxDir == 1) {
                                ComputeFDMatrixFlip(info, 0, order, order, duMax, dvMax, quadInfo->m00[i],
                                    &quadInfo->m00[i]->data[order-1][0][0], 0, 0, 4, -4 * NV_PATCH_MAX_ORDER);
                            } else {
                                ComputeFDMatrixFlip(info, 0, order, order, duMax, dvMax, quadInfo->m00[i],
                                    &quadInfo->m00[i]->data[order-1][order-1][0], 0, 0, -4, -4 * NV_PATCH_MAX_ORDER);
                            }
                        }

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        RetessellateFDMatrix(info, duMaxOld, dvMaxOld, duMax, dvMax, quadInfo->m00[i]);
                    }

                }
            }

            // Reverse transitions may cause stitches
            // If dir's are not equal, AND there are no stitches for other reasons,
            // AND it's not degenerate in this direction, then ...
            if ((quadInfo->u0Dir != quadInfo->u1Dir) && !stitchBottom && !stitchTop && (quadInfo->nu0 > 1)) {
                stitchTop = 1;          // make a stitch for the reversal
            }
            if ((quadInfo->v0Dir != quadInfo->v1Dir) && !stitchLeft && !stitchRight && (quadInfo->nv1 > 1)) {
                nvAssert(quadInfo->nv1 == quadInfo->nv0);
                stitchRight = 1;        // make a stitch for the reversal
            }

            // Decide where the stitching occurs w.r.t. the regular region
            if (uMaxDir == 1) {
                stitchUBegin = stitchLeft;
                stitchUEnd = stitchRight;
            } else {
                stitchUBegin = stitchRight;
                stitchUEnd = stitchLeft;
            }
            if (vMaxDir == 1) {
                stitchVBegin = stitchBottom;
                stitchVEnd = stitchTop;
            } else {
                stitchVBegin = stitchTop;
                stitchVEnd = stitchBottom;
            }

            quadInfo->stitchLeft   = stitchLeft;
            quadInfo->stitchRight  = stitchRight;
            quadInfo->stitchBottom = stitchBottom;
            quadInfo->stitchTop    = stitchTop;
            quadInfo->stitchUBegin = stitchUBegin;
            quadInfo->stitchUEnd   = stitchUEnd;
            quadInfo->stitchVBegin = stitchVBegin;
            quadInfo->stitchVEnd   = stitchVEnd;

            // calc if U/V inner guards required
            quadInfo->needUInner = (quadInfo->vMaxSegs > 1) && (stitchBottom || stitchTop);
            quadInfo->needVInner = (quadInfo->uMaxSegs > 1) && (stitchLeft || stitchRight);

            for (i = 0; i < info->maxAttr; i++) {
                if (info->evalEnables & (1 << i)) {
                    NV_PATCH_MAP_INFO *map = &info->maps[i];
                    float *rawData = map->rawData;
                    int uorder = map->uorder;
                    int vorder = map->vorder;

                    if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_CONTROL_POINTS) {
                        // Store the corner points
                        getRawData(info, &info->maps[i], rawData, 0,        0,        quadInfo->pCorners[i][0][0]);
                        getRawData(info, &info->maps[i], rawData, 0,        uorder-1, quadInfo->pCorners[i][0][1]);
                        getRawData(info, &info->maps[i], rawData, vorder-1, 0,        quadInfo->pCorners[i][1][0]);

                        CopyPoint(quadInfo->pCorners[i][1][1], quadInfo->pCorners[i][1][0]);

                        // Compute U boundary curves
                        quadInfo->pU0[i]->order = uorder;
                        quadInfo->pU1[i]->order = uorder;
                        ComputeFDCurveFlip(info, uorder, du0, quadInfo->pU0[i],
                            pRawData(info, map, rawData, 0, 0),
                            info->maps[i].ufStride * sizeof(float),quadInfo->u0Dir, info->flipU);
                        ComputeFDCurveFlip(info, uorder, du1, quadInfo->pU1[i],
                            pRawData(info, map, rawData, vorder-1, 0),
                            0 /* stride at top */, quadInfo->u1Dir, info->flipU);

                        // Compute V boundary curves
                        quadInfo->pV0[i]->order = vorder;
                        quadInfo->pV1[i]->order = vorder;
                        ComputeFDCurveFlip(info, vorder, dv0, quadInfo->pV0[i],
                            pRawData(info, map, rawData, 0, 0),
                            info->maps[i].vfStride * sizeof(float), quadInfo->v0Dir, info->flipV);
                        ComputeFDCurveFlip(info, vorder, dv1, quadInfo->pV1[i],
                            pRawData(info, map, rawData, 0, uorder-1),
                            (info->maps[i].vfStride-4) * sizeof(float), quadInfo->v1Dir, info->flipV);

                        info->maps[i].dirtyFlags = 0;

                    } else if (info->maps[i].dirtyFlags & NV_PATCH_DIRTY_TESSELLATION) {
                        //BUG BUG WE NEED TO ASSES IF CURVES CHANGED DIRECTION
                        // Compute U boundary curves
                        RetessellateFDCurve(info, du0Old, du0, quadInfo->pU0[i], 0);
                        RetessellateFDCurve(info, du1Old, du1, quadInfo->pU1[i], 0);
                        // Compute V boundary curves
                        RetessellateFDCurve(info, dv0Old, dv0, quadInfo->pV0[i], 0);
                        RetessellateFDCurve(info, dv1Old, dv1, quadInfo->pV1[i], 0);

                        info->maps[i].dirtyFlags &= ~NV_PATCH_DIRTY_TESSELLATION;
                    }
                }
            }

            retVal |= DrawIntPatch(info, quadInfo, quadInfo->m00);
        }
    }

NV_TRACE_CODE(
  nvEvalPatchEnd:
);

    if (info->backendType == NV_PATCH_BACKEND_CELSIUS) {
        if (info->backend->DestroyBackend) info->backend->DestroyBackend(info);
    }
    return retVal;
}

/*****************************************************************************/
int evAllocInitWithCache(NV_PATCH_INFO *info, void *context, NV_PATCH_ALLOC_CONTROL *pevMemory,
                            int tBytes, NV_PATCH_ALLOC_CACHE *pCache)
{
    nvAssert(!(tBytes & (sizeof(void *) - 1)));
    if (pCache && pCache->pBaseCache) {
        if (pCache->bytesAllocCache >= tBytes) {
            // requested allocation fit in cached allocation
            nvAssert(!pCache->inUse);
#if defined(IS_OPENGL)
            nvAssert(pCache->contextCache == context);
#endif
            pCache->inUse = 1;
            pCache->countFreeCheck = 0;
            pevMemory->context = context;
            pevMemory->pBase = pevMemory->pAvail = pCache->pBaseCache;
            pevMemory->bytesAlloc = tBytes;
            pevMemory->bytesUsed = 0;
            pevMemory->pCache = pCache;
            return 0;
        }
        // need new alloc, free up the old
        __NV_FREE(pevMemory->context, pCache->pBaseCache);
    }

    // must do new alloc
    pevMemory->context = context;
    pevMemory->pBase = __NV_MALLOC(context, tBytes);
    pevMemory->pAvail = pevMemory->pBase;
    pevMemory->bytesAlloc = tBytes;
    pevMemory->bytesUsed = 0;
    pevMemory->pCache = pCache;

    if (pCache) {
        pCache->contextCache = context;
        pCache->pBaseCache = pevMemory->pBase;
        pCache->bytesAllocCache = tBytes;
        pCache->inUse = 1;
        pCache->countFreeCheck = 0;
    }
    if (pevMemory->pBase) {
        return 0;
    }
    return 1;
}

/*****************************************************************************/
#if !defined(IS_OPENGL)
#undef nvAssert
#endif

#if 1 && defined(IS_OPENGL)
const int attrHwToSw[NV_PATCH_NUMBER_OF_ATTRIBS] = {
        NV_PATCH_ATTRIB_POSITION,
        NV_PATCH_ATTRIB_VERTEX_WEIGHT,
        NV_PATCH_ATTRIB_NORMAL,
        NV_PATCH_ATTRIB_COLOR,
        NV_PATCH_ATTRIB_SECONDARY_COLOR,
        NV_PATCH_ATTRIB_FOG_COORD,
        NV_PATCH_ATTRIB_UNUSED0,
        NV_PATCH_ATTRIB_UNUSED1,
        NV_PATCH_ATTRIB_TEXCOORD7,
        NV_PATCH_ATTRIB_TEXCOORD0,
        NV_PATCH_ATTRIB_TEXCOORD1,
        NV_PATCH_ATTRIB_TEXCOORD2,
        NV_PATCH_ATTRIB_TEXCOORD3,
        NV_PATCH_ATTRIB_TEXCOORD4,
        NV_PATCH_ATTRIB_TEXCOORD5,
        NV_PATCH_ATTRIB_TEXCOORD6,
    };

const int attrSwToHw[NV_PATCH_NUMBER_OF_ATTRIBS] = {
        NV_PATCH_ATTRIB_POSITION,
        NV_PATCH_ATTRIB_VERTEX_WEIGHT,
        NV_PATCH_ATTRIB_NORMAL,
        NV_PATCH_ATTRIB_COLOR,
        NV_PATCH_ATTRIB_SECONDARY_COLOR,
        NV_PATCH_ATTRIB_FOG_COORD,
        NV_PATCH_ATTRIB_UNUSED0,
        NV_PATCH_ATTRIB_UNUSED1,
        NV_PATCH_ATTRIB_TEXCOORD1,
        NV_PATCH_ATTRIB_TEXCOORD2,
        NV_PATCH_ATTRIB_TEXCOORD3,
        NV_PATCH_ATTRIB_TEXCOORD4,
        NV_PATCH_ATTRIB_TEXCOORD5,
        NV_PATCH_ATTRIB_TEXCOORD6,
        NV_PATCH_ATTRIB_TEXCOORD7,
        NV_PATCH_ATTRIB_TEXCOORD0,
    };

#else
const int attrHwToSw[NV_PATCH_NUMBER_OF_ATTRIBS] = {
        0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 10, 11, 12, 13, 14, 15,
    };

const int attrSwToHw[NV_PATCH_NUMBER_OF_ATTRIBS] = {
        0, 1, 2, 3, 4, 5, 6, 7,
        8, 9, 10, 11, 12, 13, 14, 15,
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvPriv.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#if (NVARCH >= 0x04)

#include "nvprecomp.h"
#include "wincommon.h"
#include "nvPriv.h"
#include "nvProcMan.h"
#pragma hdrstop


//extern BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID);
//extern BOOL pmDeleteProcess(DWORD processID);

// this is really global, do not move to pDriverData
// each element contains a pDriverData associated with an adapter
extern "C" 
{
	NV_ADAPTER_TYPE g_adapterData[MAX_ADAPTERS];
}

#if (IS_WIN9X || IS_WINNT5)
// -----------------------------------------------------------------------------
DWORD nvGetTextureFromSystemMemAddress(GLOBALDATA *pDriverData, FLATPTR fpVidMem)
{
    CNvObject *pNvObject = global.pNvObjectHead;
    while (pNvObject)
    {
        CTexture *pTexture = pNvObject->getTexture();
        if (pTexture)
        {
            if (pTexture->getLinear()->isValid())
            {
                if (pTexture->getLinear()->getAddress() == fpVidMem)
                {
                    CSimpleSurface *pSurf = pNvObject->getTexture()->getSwizzled();
                    return pSurf->getOffset();
                }
            }
        }
        pNvObject = pNvObject->getNext();
    }
    return -1;
}
#endif

static GLOBALDATA *getGlobalDataPtr(NvU32 dwDevice)
{
#if (IS_WINNT5)
    return g_adapterData[dwDevice].pDriverData;
#elif (IS_WINNT4)
    // device is always zero under winnt4
    return g_adapterData[0].pDriverData;
#else
    int i;
    if (dwDevice > MAX_ADAPTERS)
    {
        return NULL;
    }
    if (dwDevice != 0)
    {
        dwDevice -= 1;
    }
    for (i=0; i < MAX_ADAPTERS; i++)
    {
        if (g_adapterData[i].pDriverData &&
           (g_adapterData[i].pDriverData->dwDeviceIDNum == (dwDevice + 1)))
        {
            return g_adapterData[i].pDriverData;
        }
    }
    return NULL;
#endif
}


#ifdef __cplusplus
extern "C" {
#endif

// -----------------------------------------------------------------------------
// nvOverlayControl
//      Controls various overlay features
//      Commands:
//          GETCAPS - Returns overlay capabilities
//          SETCOLORCONTROL - Sets the colour controls
//          GETCOLORCONTROL - Returns colour control state
//          SETFEATURE - Sets overlay features
//          GETFEATURE - Gets overlay features

NVOCERROR __stdcall nvOverlayControl(LPNVOCDATATYPE lpOCData)
{
GLOBALDATA* pDriverData = NULL;          // override the global pDriverData
NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS displayParams[NV_MAX_HEADS];
int i;

    if (lpOCData->dwSize < sizeof(NVOCDATATYPE) || lpOCData->dwSize > 4096) {
        return NVOCERR_INVALID_PARMS;
    }

    pDriverData = getGlobalDataPtr(lpOCData->dwDevice);
    if (pDriverData == NULL) {
        return NVOCERR_BAD_DEVICE;
    }
    Vpp_t &vpp = pDriverData->vpp;

    // If the VPP constructor hasn't been called, don't return any info.
    if (!VppIsConstructed(&pDriverData->vpp))
    {
        return NVOCERR_BAD_DEVICE;
    }

    switch (lpOCData->cmd) {
    case NVOCCMD_NOOP:
        return NVOCERR_OK;

    case NVOCCMD_IDENTIFY:
        vpp.dwDecoderIdentity = lpOCData->caps.dwCaps1;
        vpp.dwDecoderCaps     = lpOCData->caps.dwCaps2;
        return NVOCERR_OK;

    case NVOCCMD_GETCAPS:
        lpOCData->caps.dwCaps1 = 0;
        lpOCData->caps.dwCaps2 = 0;
        lpOCData->caps.dwCaps3 = 0;
        lpOCData->caps.dwCaps4 = 0;
        lpOCData->caps.dwCaps5 = 0;
        if (vpp.regOverlayColourControlEnable ||
            pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            lpOCData->caps.dwCaps1 = NVOCCAPS1_BRIGHTNESS |
                                     NVOCCAPS1_CONTRAST |
                                     NVOCCAPS1_HUE |
                                     NVOCCAPS1_SATURATION;
        }

        lpOCData->caps.dwCaps2 |= NVOCCAPS2_TFILTER |
                                  NVOCCAPS2_OVLZOOM;
        if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
            lpOCData->caps.dwCaps2 |= NVOCCAPS2_HQVUPSCALE;
        } else {
            lpOCData->caps.dwCaps2 |= NVOCCAPS2_DFILTER;
        }
        if (pDriverData->dwHeads > 1) {
            lpOCData->caps.dwCaps2 |= NVOCCAPS2_FSMIRROR;
        }

        lpOCData->caps.dwCaps3 |= NVOCCAPS3_SUBPICTURE;
        lpOCData->caps.dwCaps3 |= NVOCCAPS3_LATEFLIPSYNC;
        if (vpp.pSysInfo->dwNVClasses & NVCLASS_0004_TIMER) {
            lpOCData->caps.dwCaps3 |= NVOCCAPS3_DELIVERYCONTROL;
        }
        lpOCData->caps.dwCaps3 |= NVOCCAPS3_BLTCAPS;

        // TODO: figure out whether this is an SMA configuration
        lpOCData->caps.dwCaps4 |= NVOCCAPS4_IMB;
        if (vpp.dwOverlaySurfaces) {
            // set if this device has an open overlay
            lpOCData->caps.dwCaps4 |= NVOCCAPS4_DEVICEHASOVL;
        }
        lpOCData->caps.dwCaps4 |= (pDriverData->dwHeads & 0xF) << 16;
        lpOCData->caps.dwCaps4 |= (pDriverData->dwDesktopState & 0xF) << 20;

        for (i = 0; i < (int)pDriverData->dwHeads; i++) {
            displayParams[i].Head = i;
            NvRmConfigGetEx(pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                            NV_CFGEX_GET_DISPLAY_TYPE_MULTI,
                            &displayParams[i], sizeof(displayParams));
        }
        lpOCData->caps.dwCaps4 |= (displayParams[0].Type & 0xF) << 24;
        if (pDriverData->dwHeads > 1) {
            lpOCData->caps.dwCaps4 |= (displayParams[1].Type & 0xF) << 28;
        }

        lpOCData->caps.dwCaps5 |= NVOCCAPS5_BLT_YUV9_2_YUV422
                               |  NVOCCAPS5_BLT_YUV12_2_YUV422
                               |  NVOCCAPS5_BLT_YC12_2_YUV422
                               |  NVOCCAPS5_BLT_YUV422_2_YUV422
                               |  NVOCCAPS5_BLT_YUV422_2_RGB16
                               |  NVOCCAPS5_BLT_YUV422_2_RGB32
                               |  NVOCCAPS5_BLT_RGB16_2_RGB32
                               |  NVOCCAPS5_BLT_RGB32_2_RGB32
                               |  NVOCCAPS5_BLT_SYUV2VYUV
                               |  NVOCCAPS5_BLT_VYUV2SYUV
                               |  NVOCCAPS5_BLT_SYUV2VRGB
                               |  NVOCCAPS5_BLT_VYUV2VRGB
                               |  NVOCCAPS5_BLT_SRGB2VRGB
                               |  NVOCCAPS5_BLT_VRGB2VRGB
                               |  NVOCCAPS5_BLT_2RGBTEX;
        return NVOCERR_OK;

    case NVOCCMD_SETCOLORCONTROL:
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            // NV10 ranges
            if (lpOCData->ccData.dwCCFlags & NVOCCC_CONTRAST) {
                vpp.colorCtrl.lContrast = min(max(lpOCData->ccData.lContrast * 20000 / 200, 0), 20000);
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_BRIGHTNESS) {
                vpp.colorCtrl.lBrightness = min(max(lpOCData->ccData.lBrightness * 10000 / 255, -10000), 10000);
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_HUE) {
                vpp.colorCtrl.lHue = lpOCData->ccData.lHue;
                while (vpp.colorCtrl.lHue < -180) vpp.colorCtrl.lHue += 360;
                while (vpp.colorCtrl.lHue >= 180) vpp.colorCtrl.lHue -= 360;
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_SATURATION) {
                vpp.colorCtrl.lSaturation = min(max(lpOCData->ccData.lSaturation * 20000 / 200, 0), 20000);
            }
            VppSetOverlayColourControl(&vpp);
        } else {
            // NV4/5 ranges
            if (lpOCData->ccData.dwCCFlags & NVOCCC_CONTRAST) {
                vpp.colorCtrl.lContrast = min(max(lpOCData->ccData.lContrast * 511 / 200, 0), 511);
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_BRIGHTNESS) {
                vpp.colorCtrl.lBrightness = min(max(lpOCData->ccData.lBrightness, -256), 255);
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_HUE) {
                vpp.colorCtrl.lHue = lpOCData->ccData.lHue;
                while (vpp.colorCtrl.lHue < 0)    vpp.colorCtrl.lHue += 360;
                while (vpp.colorCtrl.lHue >= 360) vpp.colorCtrl.lHue -= 360;
            }
            if (lpOCData->ccData.dwCCFlags & NVOCCC_SATURATION) {
                vpp.colorCtrl.lSaturation = min(max(lpOCData->ccData.lSaturation * 512 / 200, 0), 512);
            }
            vpp.regOverlayColourControlEnable    = lpOCData->ccData.dwEnable;
        }
        return NVOCERR_OK;

    case NVOCCMD_GETCOLORCONTROL:
        lpOCData->ccData.dwCCFlags = NVOCCC_CONTRAST |
                                     NVOCCC_BRIGHTNESS |
                                     NVOCCC_HUE |
                                     NVOCCC_SATURATION;
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            // NV10 ranges
            lpOCData->ccData.lContrast = vpp.colorCtrl.lContrast / 100;
            lpOCData->ccData.lBrightness = vpp.colorCtrl.lBrightness * 255 / 10000;
            lpOCData->ccData.lHue = vpp.colorCtrl.lHue;
            lpOCData->ccData.lSaturation = vpp.colorCtrl.lSaturation / 100;
            lpOCData->ccData.dwEnable = 3;
        } else {
            // NV4/5 ranges
            lpOCData->ccData.lContrast = vpp.colorCtrl.lContrast * 200 / 511;
            lpOCData->ccData.lBrightness = vpp.colorCtrl.lBrightness;
            lpOCData->ccData.lHue = vpp.colorCtrl.lHue;
            lpOCData->ccData.lSaturation = vpp.colorCtrl.lSaturation * 200 / 512;
            lpOCData->ccData.dwEnable = vpp.regOverlayColourControlEnable;
        }
        return NVOCERR_OK;

    case NVOCCMD_SETFEATURE:
        // turn on high quality vertical upscaling
        if (lpOCData->featureData.dwFeature1 & NVOCF1_HQVUPSCALE) {
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                return NVOCERR_NOT_SUPPORTED;
            }
            /*
            if (pDriverData->dwOverlaySurfaces > 0 &&
               (pDriverData->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)==0) {
                // if an overlay app is already running, and we are going from off to on,
                // no can do, must quit app first
                return NVOCERR_ALREADY_ACTIVE;
            }
            */
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_VUPSCALE;
        }
        // turn on temporal filtering
        if (lpOCData->featureData.dwFeature1 & NVOCF1_TFILTER) {
            if (lpOCData->featureData.lCoefficient[0] < 0 ||
                lpOCData->featureData.lCoefficient[0] > 255) {
                return NVOCERR_INVALID_PARMS;
            }
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_TFILTER;
            vpp.regOverlayMode &= ~0xFF00;
            vpp.regOverlayMode |= lpOCData->featureData.lCoefficient[0] << 8;
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_NOTFIRST;  // first frame
            if (lpOCData->dwCmdFlags & NVOCF_TF_PRECOPY) {
                vpp.regOverlayMode |= NV4_REG_OVL_MODE_TF_PRECOPY;
            } else {
                vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TF_PRECOPY;
            }
        }
        // turn on deinterlace filter
        if (lpOCData->featureData.dwFeature1 & NVOCF1_DFILTER) {
            if (lpOCData->featureData.lCoefficient[1] < 0 ||
                lpOCData->featureData.lCoefficient[1] > 255) {
                return NVOCERR_INVALID_PARMS;
            }
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_DFILTER;
            vpp.regOverlayMode &= ~0xFF0000;
            vpp.regOverlayMode |= lpOCData->featureData.lCoefficient[1] << 16;
            if (lpOCData->dwCmdFlags & NVOCF_DF_PRECOPY) {
                vpp.regOverlayMode |= NV4_REG_OVL_MODE_DF_PRECOPY;
            } else {
                vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DF_PRECOPY;
            }
        }
        // turn on fullscreen mirror
        if (lpOCData->featureData.dwFeature1 & NVOCF1_FSMIRROR) {
            DWORD vppInvMaskSave;
            BOOL bNewDevice = (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) != (DWORD)(lpOCData->featureData.lCoefficient[4] & NV4_REG_OVL_MODE2_FSDEVICEMASK);
            if (vpp.dwOverlayFSNumSurfaces == 0 || bNewDevice ||
               (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSASPECTMASK) != (DWORD)(lpOCData->featureData.lCoefficient[4] & NV4_REG_OVL_MODE2_FSASPECTMASK)) {
                // only reenable if already disabled, or aspect, or device change
                vpp.regOverlayMode2 = (vpp.regOverlayMode2 & ~NV4_REG_OVL_MODE2_FSMASK) |
                                               (lpOCData->featureData.lCoefficient[4] & NV4_REG_OVL_MODE2_FSMASK);
                if (vpp.dwOverlaySurfaces) {
                    vppInvMaskSave = vpp.regVPPInvMask;
                    vpp.regVPPInvMask = 0xFFFFFFFF;    // shut off VPP pipe
#if IS_WINNT4
                    nvSpin(vpp.pSysInfo->dwSpinLoopCount * 3);
#else
                    Sleep(VPP_TIMEOUT_TIME * 3);                // make sure all flips are flushed
#endif
                    VppDestroyFSMirror(&vpp);
                    if (bNewDevice) {
                        // device changed, we need to reinstantiate the overlay too
                        VppDestroyOverlay(&vpp);
                        VppCreateOverlay(&vpp);
#ifndef WINNT
                        pmDeleteAllProcesses(pDriverData);
                        pmAddProcess(pDriverData, GetCurrentProcessId());
#endif
                    }
                    VppCreateFSMirror(&vpp, vpp.dwOverlayFSSrcWidth, vpp.dwOverlayFSSrcHeight);
                    vpp.regVPPInvMask = vppInvMaskSave;    // turn on VPP pipe again
                }
                if (bNewDevice && pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE &&
                   (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) == 0) {
                    // user has just disabled video mirror in clone mode, we must now tag all overlays as lost
                    vpp.dwOverlayFSOvlLost = TRUE;
                }
            } else {
                vpp.regOverlayMode2 = (vpp.regOverlayMode2 & ~NV4_REG_OVL_MODE2_FSMASK) |
                                               (lpOCData->featureData.lCoefficient[4] & NV4_REG_OVL_MODE2_FSMASK);
            }
        }
        // turn on overlay zoom
        if (lpOCData->featureData.dwFeature1 & NVOCF1_OVLZOOM) {
            vpp.regOverlayMode3 = (vpp.regOverlayMode3 & ~NV4_REG_OVL_MODE3_OVLZOOMMASK) |
                                           (lpOCData->featureData.lCoefficient[5] & NV4_REG_OVL_MODE3_OVLZOOMMASK);
        }
        // turn on frame delivery control
        if (lpOCData->featureData.dwFeature1 & NVOCF1_DELIVERYCONTROL) {
            NvNotification *pPioFlipOverlayNotifier = vpp.m_obj_a[OVERLAY_NDX].notifier_a;
            volatile NvNotification *pTimerNotifier = vpp.m_obj_a[TIMER_NDX].notifier_a;
            
            nvAssert(pTimerNotifier != NULL);

            vpp.llDeliveryPeriod = (__int64)lpOCData->featureData.lCoefficient[6] | 
                                              ((__int64)lpOCData->featureData.lCoefficient[7] << 32);

            // stop current timer
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_VPP_TIMER_IID);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_STOP_TRANSFER | 0x40000);
            vpp.pPusher->push(3, NV004_STOP_TRANSFER_VALUE);
            vpp.pPusher->adjust(4);
            vpp.pPusher->start(TRUE);

            // get current time
            while (pTimerNotifier->status == NV_IN_PROGRESS);
            pTimerNotifier->status = NV_IN_PROGRESS;
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_VPP_TIMER_IID);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_TIME_RELATIVE | 0x80000);
            vpp.pPusher->push(3, 1); // wait a token nanosecond
            vpp.pPusher->push(4, 0);
            vpp.pPusher->push(5, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_NOTIFY | 0x40000);
            vpp.pPusher->push(6, NV004_SET_ALARM_NOTIFY_WRITE_ONLY);
            vpp.pPusher->adjust(7);
            vpp.pPusher->start(TRUE);
            pDriverData->dDrawSpareSubchannelObject = NV_VPP_TIMER_IID;
            while (pTimerNotifier->status == NV_IN_PROGRESS);
            vpp.llDeliveryStart = (__int64)pTimerNotifier->timeStamp.nanoseconds[0] |
                                             ((__int64)pTimerNotifier->timeStamp.nanoseconds[1] << 32);

            // next frame will be delivered at this time
            vpp.llDeliveryTime = vpp.llDeliveryStart + vpp.llDeliveryPeriod;

            // return pointers to overlay flip timecodes
            lpOCData->featureData.lCoefficient[6] = (long) &(pPioFlipOverlayNotifier[1].timeStamp.nanoseconds[0]);
            lpOCData->featureData.lCoefficient[7] = (long) &(pPioFlipOverlayNotifier[2].timeStamp.nanoseconds[0]);
        }
        // turn on late flip sync
        if (lpOCData->featureData.dwFeature1 & NVOCF1_LATEFLIPSYNC) {
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_LATEFLIPSYNC;
        }
        // set maximum number of VPP work surfaces
        if (lpOCData->featureData.dwFeature2 & NVOCF2_VPPMAXSURFACES) {
            vpp.regVPPMaxSurfaces = lpOCData->featureData.lCoefficient[2];
        }
        return NVOCERR_OK;

    case NVOCCMD_RESETFEATURE:
        if (lpOCData->featureData.dwFeature1 & NVOCF1_HQVUPSCALE) {
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_TFILTER) {
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
            vpp.regOverlayMode |= 0xFF00;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_DFILTER) {
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
            vpp.regOverlayMode |= 0xFF0000;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_FSMIRROR) {
            DWORD vppInvMaskSave = vpp.regVPPInvMask;
            vpp.regVPPInvMask = 0xFFFFFFFF;    // shut off VPP pipe
#if IS_WINNT4
            nvSpin(vpp.pSysInfo->dwSpinLoopCount * 3);
#else
            Sleep(VPP_TIMEOUT_TIME * 3);                // make sure all flips are flushed
#endif
            vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSMASK;
            VppDestroyFSMirror(&vpp);
            vpp.regVPPInvMask = vppInvMaskSave;    // turn on VPP pipe again
            if (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
                // user has just disabled video mirror in clone mode, we must now tag all overlays as lost
                vpp.dwOverlayFSOvlLost = TRUE;
            }
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_OVLZOOM) {
            vpp.regOverlayMode3 &= ~NV4_REG_OVL_MODE3_OVLZOOMMASK;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_DELIVERYCONTROL) {
            vpp.llDeliveryPeriod = 0;
        }
        if (lpOCData->featureData.dwFeature1 & NVOCF1_LATEFLIPSYNC) {
            vpp.regOverlayMode &= NV4_REG_OVL_MODE_LATEFLIPSYNC;
        }
        return NVOCERR_OK;

    case NVOCCMD_GETFEATURE:
        lpOCData->featureData.dwFeature1 = 0;
        lpOCData->featureData.dwFeature2 = 0;
        lpOCData->featureData.dwFeature3 = 0;
        lpOCData->featureData.dwFeature4 = 0;
        if (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_HQVUPSCALE;
        }
        if (vpp.regOverlayMode & NV4_REG_OVL_MODE_TFILTER) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_TFILTER;
            lpOCData->featureData.lCoefficient[0] = (vpp.regOverlayMode >> 8) & 0xFF;
        }
        if (vpp.regOverlayMode & NV4_REG_OVL_MODE_DFILTER) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_DFILTER;
            lpOCData->featureData.lCoefficient[1] = (vpp.regOverlayMode >> 16) & 0xFF;
        }
        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_FSMIRROR;
            lpOCData->featureData.lCoefficient[4] = vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSMASK;
        }
        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_OVLZOOM;
            lpOCData->featureData.lCoefficient[5] = vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMMASK;
        }
        if (vpp.llDeliveryPeriod != 0) {
            NvNotification *pPioFlipOverlayNotifier = vpp.m_obj_a[OVERLAY_NDX].notifier_a;
            lpOCData->featureData.dwFeature1 |= NVOCF1_DELIVERYCONTROL;
            lpOCData->featureData.lCoefficient[6] = (DWORD)vpp.llDeliveryPeriod;
            lpOCData->featureData.lCoefficient[7] = (DWORD)(vpp.llDeliveryPeriod >> 32);
            lpOCData->featureData.lCoefficient[8]  = pPioFlipOverlayNotifier[1].timeStamp.nanoseconds[0];
            lpOCData->featureData.lCoefficient[9]  = pPioFlipOverlayNotifier[1].timeStamp.nanoseconds[1];
            lpOCData->featureData.lCoefficient[10] = pPioFlipOverlayNotifier[2].timeStamp.nanoseconds[0];
            lpOCData->featureData.lCoefficient[11] = pPioFlipOverlayNotifier[2].timeStamp.nanoseconds[1];
        }
        if (vpp.regOverlayMode & NV4_REG_OVL_MODE_LATEFLIPSYNC) {
            lpOCData->featureData.dwFeature1 |= NVOCF1_LATEFLIPSYNC;
        }
        lpOCData->featureData.dwFeature2 = NVOCF2_VPPMAXSURFACES;
        lpOCData->featureData.lCoefficient[2] = vpp.regVPPMaxSurfaces;
        lpOCData->featureData.lCoefficient[3] = vpp.extraNumSurfaces;
        return NVOCERR_OK;

    default:
        return NVOCERR_BAD_COMMAND;
    }
}

#if (IS_WIN9X || IS_WINNT5)

// -----------------------------------------------------------------------------
// nvMoComp
//      Copies system YC12 data to video yuv422.  Returns error code
//      Event is shared with OCC.  Could affect QUERY_IDLE or WAIT_FOR_IDLE
//      Commands:
//          NOOP - Does nothing
//          INIT - Creates system memory DMA context and attaches it to necessary objects
//          RELEASE - Kills DMA context
//          BLIT - Does the system to video blit
//          QUERY_IDLE - Returns BUSY or OK
//          WAIT_FOR_IDLE - Waits for event to trigger

NVS2VERROR __stdcall nvMoComp(LPNVS2VDATATYPE lpS2VData)
{
NvNotification *dmaPusherSyncNotifier;
DWORD dwDstYOffset, dwDstCOffset, dwSrcYOffset, dwSrcCOffset, dwSrcUOffset, dwSrcVOffset, dwSurfSize;
DWORD dwFourCC, dwVPPFlags;
LPDDRAWI_DDRAWSURFACE_INT lpDstSurf;
FLATPTR fpDstSys;
static DWORD dwYPhase = 0;
static FLATPTR fpSrcSurf[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
static FLATPTR fpDstSurf[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
LPPROCESSINFO lpProcInfo;
GLOBALDATA* pDriverData = NULL;          // override global pDriverData
DWORD dwSrcContextDma, dwDstContextDma;

    if (lpS2VData->dwSize < sizeof(NVS2VDATATYPE) || lpS2VData->dwSize > 4096)
        return NVS2VERR_INVALID_PARMS;

    pDriverData = getGlobalDataPtr(lpS2VData->dwDevice);
    if (pDriverData == NULL) {
        return NVS2VERR_BAD_DEVICE;
    }
    Vpp_t &vpp = pDriverData->vpp;

    lpProcInfo = pmGetProcess(pDriverData, GetCurrentProcessId());

    dmaPusherSyncNotifier = pDriverData->pDmaPusherSyncNotifierFlat;

    switch (lpS2VData->dwCmd) {
// ************************************************************************
    case NVS2VCMD_BLIT:
// ************************************************************************

		// This sometimes uses the VPP_DMABLT_TO_VID object... which is only ready for use if 
		// we've gotten vppEnable()
		nvAssert(vpp.dwFlags & VPP_FLAG_ENABLED);

		if (!(vpp.dwFlags & VPP_FLAG_ENABLED))
		{
			return NVS2VERR_NOT_READY;
		}

        if (lpS2VData->dwIndex >= 16)
            return NVS2VERR_INVALID_PARMS;

        if (vpp.regVPPInvMask & (NV4_REG_VPP_DMABLIT_DISABLE | NV4_REG_VPP_MASTER_DISABLE)) {
            return NVS2VERR_OK;
        }

        switch (lpS2VData->dwDstType) {
        case NVS2V_RGB32:
        case NVS2V_RGB16:
            dwSurfSize = lpS2VData->dwDstPitch * lpS2VData->dwHeight;
            fpDstSys = (FLATPTR) lpS2VData->fpDst;
            dwYPhase = 0;
            break;

        case NVS2V_YUYV:
            dwSurfSize = lpS2VData->dwDstPitch * lpS2VData->dwHeight;
            fpDstSys = (FLATPTR) lpS2VData->fpDst;
            dwYPhase = 0;
            break;

        case NVS2V_UYVY:
            dwSurfSize = lpS2VData->dwDstPitch * lpS2VData->dwHeight;
            fpDstSys = (FLATPTR) lpS2VData->fpDst;
            dwYPhase = 1;
            break;

        case NVS2V_DDSURF:
            dwSurfSize = lpS2VData->dwDstPitch * lpS2VData->dwHeight;
            lpDstSurf = (LPDDRAWI_DDRAWSURFACE_INT) lpS2VData->lpDstDirectDrawSurface;
            if (lpDstSurf->lpLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY ||
                lpDstSurf->lpLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYNV) {
                dwYPhase = 1;
            } else {
                dwYPhase = 0;
            }
            fpDstSys = lpDstSurf->lpLcl->lpGbl->fpVidMem;
            break;

        case NVS2V_INDEXED:
            dwSurfSize = lpS2VData->dwDstSize;
            fpDstSys = fpDstSurf[lpS2VData->dwIndex];
            dwYPhase = 0;
            break;

        default:
            return NVS2VERR_INVALID_PARMS;
        }

        if (lpS2VData->dwDstFlags & NVS2VF_SYSTEM) {
            FLATPTR fpSrcSys = (FLATPTR)lpS2VData->fpSrc;

            if (lpS2VData->dwSrcFlags & NVS2VF_OFFSET)
                fpSrcSys += pDriverData->BaseAddress;

            if (fpSrcSys < pDriverData->BaseAddress ||
               (fpSrcSys + dwSurfSize) >= (pDriverData->BaseAddress + pDriverData->TotalVRAM))
                return NVS2VERR_INVALID_PARMS;

            dwSrcContextDma = NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY;
            dwDstContextDma = NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex;
            dwDstYOffset = dwDstCOffset = fpDstSys - fpSrcSurf[lpS2VData->dwIndex];
            dwDstYOffset += dwYPhase;
            dwDstCOffset += dwYPhase ^ 1;
            if (lpS2VData->dwSrcFlags & NVS2VF_OFFSET) {
                dwSrcYOffset = (FLATPTR)lpS2VData->SrcYC12.fpY;
                dwSrcCOffset = (FLATPTR)lpS2VData->SrcYC12.fpC;
                dwSrcUOffset = (FLATPTR)lpS2VData->SrcYUV12.fpU;
                dwSrcVOffset = (FLATPTR)lpS2VData->SrcYUV12.fpV;
            } else {
                dwSrcYOffset = (FLATPTR)lpS2VData->SrcYC12.fpY - pDriverData->BaseAddress;
                dwSrcCOffset = (FLATPTR)lpS2VData->SrcYC12.fpC - pDriverData->BaseAddress;
                dwSrcUOffset = (FLATPTR)lpS2VData->SrcYUV12.fpU - pDriverData->BaseAddress;
                dwSrcVOffset = (FLATPTR)lpS2VData->SrcYUV12.fpV - pDriverData->BaseAddress;
            }
        } else {
            if (lpS2VData->dwDstFlags & NVS2VF_OFFSET)
                fpDstSys += pDriverData->BaseAddress;

            if (fpDstSys < pDriverData->BaseAddress ||
               (fpDstSys + dwSurfSize) >= (pDriverData->BaseAddress + pDriverData->TotalVRAM))
                return NVS2VERR_INVALID_PARMS;

            dwSrcContextDma = NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex;
            dwDstContextDma = NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY;
            dwDstYOffset = dwDstCOffset = fpDstSys - pDriverData->BaseAddress;
            dwDstYOffset += dwYPhase;
            dwDstCOffset += dwYPhase ^ 1;
            dwSrcYOffset = (FLATPTR)lpS2VData->SrcYC12.fpY - fpSrcSurf[lpS2VData->dwIndex];
            dwSrcCOffset = (FLATPTR)lpS2VData->SrcYC12.fpC - fpSrcSurf[lpS2VData->dwIndex];
            dwSrcUOffset = (FLATPTR)lpS2VData->SrcYUV12.fpU - fpSrcSurf[lpS2VData->dwIndex];
            dwSrcVOffset = (FLATPTR)lpS2VData->SrcYUV12.fpV - fpSrcSurf[lpS2VData->dwIndex];
        }

        switch (lpS2VData->dwSrcType) {
        case NVS2V_YC12:
        case NVS2V_YUV12:
        case NVS2V_YV12:
            // move luma
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);    // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcYOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstYOffset);                        // OffsetOut
            vpp.pPusher->push (9, lpS2VData->dwSrcPitch);               // PitchIn
            vpp.pPusher->push (10, lpS2VData->dwDstPitch);              // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth);                 // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight);                // LineCount
            vpp.pPusher->push (13, 0x201);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);
            break;

        case NVS2V_YUYV:
        case NVS2V_UYVY:
        case NVS2V_RGB32:
        case NVS2V_RGB16:
            // move all

            VppResetNotification(
                &vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1],
                lpProcInfo->hDMABlitToVid3
                );

            // NvResetEvent(lpProcInfo->hDMABlitToVid3);
            // pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;

            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, vpp.m_obj_a[DMABLT_TO_VID_NDX].contextIID); // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                         // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                         // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcYOffset);                            // OffsetIn
            vpp.pPusher->push (8, dwDstYOffset);                            // OffsetOut
            vpp.pPusher->push (9, lpS2VData->dwSrcPitch);                   // PitchIn
            vpp.pPusher->push (10, lpS2VData->dwDstPitch);                  // PitchOut
            if (lpS2VData->dwSrcType == NVS2V_RGB32) {
                vpp.pPusher->push (11, lpS2VData->dwWidth << 2);            // LineLengthIn
            } else {
                vpp.pPusher->push (11, lpS2VData->dwWidth << 1);            // LineLengthIn
            }
            vpp.pPusher->push (12, lpS2VData->dwHeight);                    // LineCount
            vpp.pPusher->push (13, 0x101);                                  // Format
            vpp.pPusher->push (14, VPP_NOTIFY_TYPE);                        // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID;
            break;

        default:
            return NVS2VERR_INVALID_PARMS;
        }

        // move chroma
        switch (lpS2VData->dwSrcType) {
        case NVS2V_YUYV:
        case NVS2V_UYVY:
        case NVS2V_RGB32:
        case NVS2V_RGB16:
            // already moved everything
            break;

        case NVS2V_YC12:
            // move chroma, even lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY); // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcCOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset);                        // OffsetOut
            vpp.pPusher->push (9, lpS2VData->dwSrcPitch);               // PitchIn
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);         // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth);                 // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);           // LineCount
            vpp.pPusher->push (13, 0x201);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

//            NvResetEvent(lpProcInfo->hDMABlitToVid3);
//            pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;
            VppResetNotification(
                &vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1],
                lpProcInfo->hDMABlitToVid3
                );

            // move chroma, odd lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, vpp.m_obj_a[DMABLT_TO_VID_NDX].contextIID); // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                         // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                         // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcCOffset);                            // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset + lpS2VData->dwDstPitch);    // OffsetOut
            vpp.pPusher->push (9, lpS2VData->dwSrcPitch);                   // PitchIn
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);             // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth);                     // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);               // LineCount
            vpp.pPusher->push (13, 0x201);                                  // Format
            vpp.pPusher->push (14, VPP_NOTIFY_TYPE);                        // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID;
            break;

        case NVS2V_YUV12:
        case NVS2V_YV12:
            // move U, even lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);    // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcUOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset);                        // OffsetOut
            if (lpS2VData->dwSrcType == NVS2V_YUV12) {
                vpp.pPusher->push (9, lpS2VData->dwSrcPitch >> 1);      // PitchIn
            } else {
                vpp.pPusher->push (9, lpS2VData->dwSrcYV12ChromaPitch); // PitchIn
            }
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);         // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth >> 1);            // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);           // LineCount
            vpp.pPusher->push (13, 0x401);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            // move V, even lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);    // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcVOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset + 2);                    // OffsetOut
            if (lpS2VData->dwSrcType == NVS2V_YUV12) {
                vpp.pPusher->push (9, lpS2VData->dwSrcPitch >> 1);      // PitchIn
            } else {
                vpp.pPusher->push (9, lpS2VData->dwSrcYV12ChromaPitch); // PitchIn
            }
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);         // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth >> 1);            // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);           // LineCount
            vpp.pPusher->push (13, 0x401);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            // move U, odd lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY);    // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                     // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                     // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcUOffset);                        // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset + lpS2VData->dwDstPitch);// OffsetOut
            if (lpS2VData->dwSrcType == NVS2V_YUV12) {
                vpp.pPusher->push (9, lpS2VData->dwSrcPitch >> 1);      // PitchIn
            } else {
                vpp.pPusher->push (9, lpS2VData->dwSrcYV12ChromaPitch); // PitchIn
            }
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);         // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth >> 1);            // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);           // LineCount
            vpp.pPusher->push (13, 0x401);                              // Format
            vpp.pPusher->push (14, NV039_BUFFER_NOTIFY_WRITE_ONLY);     // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

//            NvResetEvent(lpProcInfo->hDMABlitToVid3);
//            pPioColourControlEventNotifier[1].status = NV_IN_PROGRESS;
            VppResetNotification(
                &vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1],
                lpProcInfo->hDMABlitToVid3
                );

            // move V, odd lines
            vpp.pPusher->push (0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push (1, vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID);
            vpp.pPusher->push (2, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_NOTIFIES | 0xC0000);
            vpp.pPusher->push (3, vpp.m_obj_a[DMABLT_TO_VID_NDX].contextIID); // SetContextDmaNotifies
            vpp.pPusher->push (4, dwSrcContextDma);                         // SetContextDmaBufferIn
            vpp.pPusher->push (5, dwDstContextDma);                         // SetContextDmaBufferOut
            vpp.pPusher->push (6, SUB_CHANNEL(vpp.spareSubCh) | NV039_OFFSET_IN | 0x200000);
            vpp.pPusher->push (7, dwSrcVOffset);                            // OffsetIn
            vpp.pPusher->push (8, dwDstCOffset + lpS2VData->dwDstPitch + 2);// OffsetOut
            if (lpS2VData->dwSrcType == NVS2V_YUV12) {
                vpp.pPusher->push (9, lpS2VData->dwSrcPitch >> 1);          // PitchIn
            } else {
                vpp.pPusher->push (9, lpS2VData->dwSrcYV12ChromaPitch);     // PitchIn
            }
            vpp.pPusher->push (10, lpS2VData->dwDstPitch << 1);             // PitchOut
            vpp.pPusher->push (11, lpS2VData->dwWidth >> 1);                // LineLengthIn
            vpp.pPusher->push (12, lpS2VData->dwHeight >> 1);               // LineCount
            vpp.pPusher->push (13, 0x401);                                  // Format
            vpp.pPusher->push (14, VPP_NOTIFY_TYPE);                       // BufferNotify
            vpp.pPusher->adjust (15);
            vpp.pPusher->start (TRUE);

            pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID;
            break;

        default:
            return NVS2VERR_INVALID_PARMS;
        }

        // TBD: how do we get here with no event?  Is that normal?  How 
        // do I distinguish the case where we have no events period.
        if (lpS2VData->bWaitForCompletion) {

#ifdef VPP_USE_EVENT_NOTIFIERS
            if (lpProcInfo && lpProcInfo->hDMABlitToVid3) {

                if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hDMABlitToVid3, lpS2VData->dwTimeoutTime))) {
                    EVENT_ERROR;
                    return NVS2VERR_TIMEOUT;
                }
            } else {
                while (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS) 
                {
#if IS_WINNT4
                    nvSpin(vpp.pSysInfo->dwSpinLoopCount); // TBD: is this right? @mjl@
#else
                    Sleep(0);
#endif
                }
                return NVS2VERR_NO_EVENT;
            }
#else
            if (VppWaitForNotification(&vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1], lpProcInfo->hDMABlitToVid3,lpS2VData->dwTimeoutTime))
            {
                EVENT_ERROR;
                return NVS2VERR_TIMEOUT;
            }

#endif // USE EVENT NOTIFIERS
        }
        return NVS2VERR_OK;
// ************************************************************************
    case NVS2VCMD_INIT:
// ************************************************************************
        DWORD dwPitch;
        PVOID fpSys;
        NVS2VSURFTYPE surfType;

        if (lpS2VData->dwIndex >= 16)
            return NVS2VERR_INVALID_PARMS;

        if (lpS2VData->dwDstFlags & NVS2VF_SYSTEM) {
            // system surface they want to initialize is in destination
            dwPitch = lpS2VData->dwDstPitch;
            fpSys = lpS2VData->DstYC12.fpY;
            surfType = lpS2VData->dwDstType;
        } else {
            // system surface they want to initialize is in source
            dwPitch = lpS2VData->dwSrcPitch;
            fpSys = lpS2VData->SrcYC12.fpY;
            surfType = lpS2VData->dwSrcType;
        }

        switch (surfType) {
        case NVS2V_YC12:
        case NVS2V_YUV12:
        case NVS2V_YV12:
            dwSurfSize = dwPitch * lpS2VData->dwHeight * 3 / 2;
            break;
        case NVS2V_YUYV:
        case NVS2V_UYVY:
        case NVS2V_RGB16:
        case NVS2V_RGB32:
            dwSurfSize = dwPitch * lpS2VData->dwHeight;
            break;
        default:
            return NVS2VERR_INVALID_PARMS;
        }
        dwSurfSize += 4096;     // to prevent MTMF fault

        if (NvRmAllocContextDma(pDriverData->dwRootHandle,
                                NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex,
                                NV01_CONTEXT_DMA,
                                DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_WRITE) |
                                DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                                DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                fpSys,
                                (dwSurfSize - 1)) == 0) {

            // cache surface pointer
            fpSrcSurf[lpS2VData->dwIndex] = (FLATPTR) fpSys;

            // cache destination surface pointer (only used for indexed blits)
            switch (lpS2VData->dwDstType) {
            case NVS2V_YUYV:
                fpDstSurf[lpS2VData->dwIndex] = (FLATPTR) lpS2VData->fpDst;
                dwYPhase = 0;
                break;

            case NVS2V_UYVY:
                fpDstSurf[lpS2VData->dwIndex] = (FLATPTR) lpS2VData->fpDst;
                dwYPhase = 1;
                break;

            case NVS2V_DDSURF:
                lpDstSurf = (LPDDRAWI_DDRAWSURFACE_INT) lpS2VData->lpDstDirectDrawSurface;
                if (lpDstSurf->lpLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYVY ||
                    lpDstSurf->lpLcl->lpGbl->ddpfSurface.dwFourCC == FOURCC_UYNV) {
                    dwYPhase = 1;
                } else {
                    dwYPhase = 0;
                }
                fpDstSurf[lpS2VData->dwIndex] = lpDstSurf->lpLcl->lpGbl->fpVidMem;
                break;
            }
            if (lpS2VData->dwDstFlags & NVS2VF_OFFSET)
                fpDstSurf[lpS2VData->dwIndex] += pDriverData->BaseAddress;

            if (!lpProcInfo || lpProcInfo->hDMABlitToVid3 == 0 || lpProcInfo->hDMABlitToVid0 == 0)
                return NVS2VERR_NO_EVENT;
            return NVS2VERR_OK;
        } else
            return NVS2VERR_INIT_FAILED;

// ************************************************************************
    case NVS2VCMD_RELEASE:
// ************************************************************************
        if (lpS2VData->dwIndex >= 16)
            return NVS2VERR_INVALID_PARMS;

        fpSrcSurf[lpS2VData->dwIndex] = 0;
        fpDstSurf[lpS2VData->dwIndex] = 0;

        NvRmFree(pDriverData->dwRootHandle, pDriverData->dwRootHandle,
                 NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex);
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_QUERY_IDLE:
// ************************************************************************
        if (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS)
            return NVS2VERR_BUSY;
        else
            return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_WAIT_FOR_IDLE:
// ************************************************************************
        if (lpProcInfo && lpProcInfo->hDMABlitToVid3) {
            if (!IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hDMABlitToVid3, lpS2VData->dwTimeoutTime))) {
                return NVS2VERR_OK;
            } else {
                EVENT_ERROR;
                return NVS2VERR_TIMEOUT;
            }
        } else {
            while (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS)
            {
#if IS_WINNT4
                    nvSpin(vpp.pSysInfo->dwSpinLoopCount); // TBD: is this right? @mjl@
#else
                    Sleep(0);
#endif
            };
            return NVS2VERR_NO_EVENT;
        }

// ************************************************************************
    case NVS2VCMD_SET_SUBPICTURE:
// ************************************************************************
        if (lpS2VData->fpSP == 0) {
            // disable subpicture
            vpp.subPicture.offset = 0;
            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                vpp.subPicture.format = NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT;
            } else {
                vpp.subPicture.format = NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT;
            }
            return NVS2VERR_OK;
        }
        if (lpS2VData->dwSPType == NVS2V_YUVA16) {
            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                vpp.subPicture.format = NV038_OVERLAY_FORMAT_COLOR_LE_A4V6YB6A4U6YA6;
            } else {
                vpp.subPicture.format = NV088_OVERLAY_FORMAT_COLOR_LE_A4CR6YB6A4CB6YA6;
            }
        } else if (lpS2VData->dwSPType == NVS2V_YUVA32) {
            if (pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
                vpp.subPicture.format = NV038_OVERLAY_FORMAT_COLOR_LE_A8V8U8Y8;
            } else {
                vpp.subPicture.format = NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8;
            }
        } else {
            return NVS2VERR_INVALID_PARMS;
        }
        if (lpS2VData->dwSPFlags & NVS2VF_OFFSET) {
            vpp.subPicture.offset = lpS2VData->fpSP;
        } else {
            vpp.subPicture.offset = lpS2VData->fpSP - pDriverData->BaseAddress;
        }
        vpp.subPicture.pitch = lpS2VData->dwSPPitch;
        if (lpS2VData->dwSPFlags & NVS2VF_SP_SUBRECT) {
            vpp.subPicture.pitch  |= NVS2VF_SP_SUBRECT;
            vpp.subPicture.originX = lpS2VData->dwSubRectX;
            vpp.subPicture.originY = lpS2VData->dwSubRectY;
            vpp.subPicture.width   = lpS2VData->dwSubRectWidth;
            vpp.subPicture.height  = lpS2VData->dwSubRectHeight;
        } else {
            vpp.subPicture.originX = 0xFFFFFFFF;
            vpp.subPicture.originY = 0xFFFFFFFF;
            vpp.subPicture.width   = 0xFFFFFFFF;
            vpp.subPicture.height  = 0xFFFFFFFF;
        }
        if (lpS2VData->dwSPFlags & NVS2VF_SP_ODD) {
            vpp.subPicture.pitch |= NVS2VF_SP_ODD;
        }
        if (lpS2VData->dwSPFlags & NVS2VF_SP_EVEN) {
            vpp.subPicture.pitch |= NVS2VF_SP_EVEN;
        }
        if ((lpS2VData->dwSPFlags & (NVS2VF_SP_ODD | NVS2VF_SP_EVEN)) == 0) {
            vpp.subPicture.pitch |= NVS2VF_SP_ODD | NVS2VF_SP_EVEN;
        }
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_VPP_START:
// ************************************************************************
        if (lpS2VData->dwSrcFlags & NVS2VF_OFFSET) {
            dwSrcYOffset = (DWORD) lpS2VData->fpSrc;
        } else {
            dwSrcYOffset = (DWORD) lpS2VData->fpSrc - pDriverData->BaseAddress;
        }
        switch (lpS2VData->dwSrcType) {
        case NVS2V_YUYV: dwFourCC = FOURCC_YUY2; break;
        case NVS2V_UYVY: dwFourCC = FOURCC_UYVY; break;
        default: return NVS2VERR_INVALID_PARMS;
        }
        dwVPPFlags = VPP_ALL | VPP_SAVE_STATE;
        if (lpS2VData->dwSrcFlags & NVS2VF_VPP_ODD) {
            dwVPPFlags |= VPP_ODD;
        }
        if (lpS2VData->dwSrcFlags & NVS2VF_VPP_EVEN) {
            dwVPPFlags |= VPP_EVEN;
        }
        if (lpS2VData->dwSrcFlags & NVS2VF_VPP_BOB) {
            dwVPPFlags |= VPP_BOB;
        }
        if (lpS2VData->dwSrcFlags & NVS2VF_VPP_INTERLEAVED) {
            dwVPPFlags |= VPP_INTERLEAVED;
        }
        VppDoFlip(&(vpp),dwSrcYOffset, lpS2VData->dwSrcPitch, lpS2VData->dwWidth, lpS2VData->dwHeight, dwFourCC, dwVPPFlags);
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_VPP_QUERY:
// ************************************************************************
        if (vpp.pipeState.dwOpCount > 0 && vpp.pipeState.hLastStage) {
            if (IS_EVENT_ERROR(NvWaitEvent(vpp.pipeState.hLastStage, 0))) {
                return NVS2VERR_BUSY;
            }
        } else if (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS) {
            // wait for any DMA blits to flush out before processing
            if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hDMABlitToVid3, 0))) {
                return NVS2VERR_BUSY;
            }
        }
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_VPP_FLIP:
// ************************************************************************
        VppDoFlip(&(vpp),0, 0, 0, 0, 0, VPP_RESTORE_STATE);
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_4CC_TO_VRGB:
// ************************************************************************
        DWORD dwSrcOffset, dwDstOffset;
        DWORD dwSrcFormat, dwDstFormat;
        DWORD dwSrcSize, dwDstSize;
        DWORD dwDeltaX, dwDeltaY;
        DWORD dwCombinedPitch;
        DWORD dwSrcContextDma;

        if ((lpS2VData->dwDstFlags & NVS2VF_SYSTEM) ||
            (lpS2VData->dwSrcFlags & NVS2VF_SWIZZLED)) {
            return NVS2VERR_INVALID_PARMS;
        }

        pDriverData->blitCalled = TRUE;
        pDriverData->TwoDRenderingOccurred = 1;

        dwDeltaX = ((lpS2VData->dwWidth - 1) << 20)  / (lpS2VData->DstRGB.dwDstWidth - 1);    // 12.20 fixed point
        dwDeltaY = ((lpS2VData->dwHeight - 1) << 20)  / (lpS2VData->DstRGB.dwDstHeight - 1);    // 12.20 fixed point
        dwSrcSize = (lpS2VData->dwHeight << 16) | lpS2VData->dwWidth;
        dwDstSize = (lpS2VData->DstRGB.dwDstHeight << 16) | lpS2VData->DstRGB.dwDstWidth;

        // get surfaces info
        if (lpS2VData->dwIndex == 0xFFFFFFFF) {
            dwSrcContextDma = vpp.hInVideoMemContextDma;
            if (lpS2VData->dwSrcFlags & NVS2VF_OFFSET) {
                dwSrcOffset = (DWORD)lpS2VData->fpSrc;
            } else {
                dwSrcOffset = VIDMEM_OFFSET((DWORD)lpS2VData->fpSrc);
            }
        } else {
            dwSrcContextDma = NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V + lpS2VData->dwIndex;
            dwSrcOffset = 0;
        }
        if (lpS2VData->dwDstFlags & NVS2VF_OFFSET) {
            dwDstOffset = (DWORD)lpS2VData->fpDst;
        } else {
            dwDstOffset = VIDMEM_OFFSET((DWORD)lpS2VData->fpDst);
        }
        switch (lpS2VData->dwSrcType) {
        case NVS2V_YUYV:  dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8; break;
        case NVS2V_UYVY:  dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8; break;
        case NVS2V_RGB16: dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_R5G6B5;       break;
        case NVS2V_RGB32: dwSrcFormat = NV089_SET_COLOR_FORMAT_LE_X8R8G8B8;     break;
        default:         return NVS2VERR_INVALID_PARMS;
        }

        if (lpS2VData->dwDstFlags & NVS2VF_SWIZZLED) {
            // swizzled
            DWORD dwLSBIndex, dwMSBIndex, dwLogWidth, dwLogHeight;

            // find log width
            dwLSBIndex = dwMSBIndex = lpS2VData->DstRGB.dwDstWidth;
            ASM_LOG2(dwLSBIndex);
            ASM_LOG2_R(dwMSBIndex);
            if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
            dwLogWidth = dwMSBIndex;

            // find log height
            dwLSBIndex = dwMSBIndex = lpS2VData->DstRGB.dwDstHeight;
            ASM_LOG2(dwLSBIndex);
            ASM_LOG2_R(dwMSBIndex);
            if (dwMSBIndex != dwLSBIndex) { dwMSBIndex++; } // this wasn't an even power of 2. round up.
            dwLogHeight = dwMSBIndex;

            // find surface format
            switch (lpS2VData->dwDstType) {
                case NVS2V_RGB16:  dwDstFormat = NV052_SET_FORMAT_COLOR_LE_R5G6B5;    break;
                case NVS2V_RGB32:  dwDstFormat = NV052_SET_FORMAT_COLOR_LE_A8R8G8B8;  break;
                default:           return NVS2VERR_INVALID_PARMS;
            }

            // set up swizzled surface
            // for now, assume destination is always in video memory
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, D3D_CONTEXT_SURFACE_SWIZZLED);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV052_SET_FORMAT | 0x80000);
            vpp.pPusher->push(3, dwDstFormat     |                     // SetFormat
                                  (dwLogWidth << 16) |
                                  (dwLogHeight << 24));
            vpp.pPusher->push(4, dwDstOffset);                         // SetOffset
            vpp.pPusher->adjust(5);

            // set mono pattern mask
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_DD_CONTEXT_PATTERN);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
            vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
            switch (lpS2VData->dwDstType) {
            case NVS2V_RGB32:
                vpp.pPusher->push(4,NV_ALPHA_1_032);
                vpp.pPusher->push(5,NV_ALPHA_1_032);
                break;
            case NVS2V_RGB16:
                vpp.pPusher->push(4,NV_ALPHA_1_016);
                vpp.pPusher->push(5,NV_ALPHA_1_016);
                break;
            default: return NVS2VERR_INVALID_PARMS;
            }
            vpp.pPusher->adjust(6);
            pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_PATTERN;
        } else {
            // not swizzled
            switch (lpS2VData->dwDstType) {
            case NVS2V_RGB16: dwDstFormat = NV063_SET_COLOR_FORMAT_LE_R5G6B5;   break;
            case NVS2V_RGB32: dwDstFormat = NV063_SET_COLOR_FORMAT_LE_X8R8G8B8; break;
            default:          return NVS2VERR_INVALID_PARMS;
            }
            dwCombinedPitch = (lpS2VData->dwDstPitch << 16) | lpS2VData->dwSrcPitch;
            if (lpS2VData->dwDstFlags & NVS2VF_SYSTEM) {
                dwCombinedPitch &= 0x0000FFFF;
                dwCombinedPitch |= dwCombinedPitch << 16;
            }
            if (lpS2VData->dwSrcFlags & NVS2VF_SYSTEM) {
                dwCombinedPitch &= 0xFFFF0000;
                dwCombinedPitch |= dwCombinedPitch >> 16;
            }
            if (pDriverData->bltData.dwLastColourFormat != dwDstFormat ||
                pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
                pDriverData->bltData.dwLastSrcOffset != dwSrcOffset ||
                pDriverData->bltData.dwLastDstOffset != dwDstOffset) {
                vpp.pPusher->push(0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
                vpp.pPusher->push(1, dwDstFormat);     // SetColorFormat
                vpp.pPusher->push(2, dwCombinedPitch); // SetPitch
                vpp.pPusher->push(3, dwSrcOffset);     // SetSrcOffset
                vpp.pPusher->push(4, dwDstOffset);     // SetDstOffset
                vpp.pPusher->adjust(5);

                if (pDriverData->bltData.dwLastColourFormat != dwDstFormat) {
                    // set mono pattern mask
                    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
                    vpp.pPusher->push(1, NV_DD_CONTEXT_PATTERN);
                    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
                    vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
                    switch (lpS2VData->dwDstType) {
                    case NVS2V_RGB32:
                        vpp.pPusher->push(4,NV_ALPHA_1_032);
                        vpp.pPusher->push(5,NV_ALPHA_1_032);
                        break;
                    case NVS2V_RGB16:
                        vpp.pPusher->push(4,NV_ALPHA_1_016);
                        vpp.pPusher->push(5,NV_ALPHA_1_016);
                        break;
                    default: return NVS2VERR_INVALID_PARMS;
                    }
                    vpp.pPusher->adjust(6);
                    pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_PATTERN;
                }

                pDriverData->bltData.dwLastColourFormat = dwDstFormat;
                pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
                pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
                pDriverData->bltData.dwLastDstOffset = dwDstOffset;
            }
        }

        // update clip
        bltUpdateClip(pDriverData);

        // set blt state
        if (SRCCOPYINDEX != pDriverData->bltData.dwLastRop) {
            vpp.pPusher->push(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
            vpp.pPusher->push(1, SRCCOPYINDEX);
            vpp.pPusher->adjust(2);
            pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
        }
        // source key is disabled
        if (pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hContextColorKey);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SET_TRANSCOLOR_OFFSET | 0x40000);
            vpp.pPusher->push(3, 0);
            vpp.pPusher->adjust(4);
            pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
            pDriverData->dDrawSpareSubchannelObject = vpp.hContextColorKey;
        }

        NvResetEvent(lpProcInfo->hFourCCBlt3);
        if (!lpProcInfo || !lpProcInfo->hFourCCBlt3) {
            vpp.pPusher->flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
            dmaPusherSyncNotifier->status = NV_IN_PROGRESS;
        }

        // frame delivery control
        if ((lpS2VData->dwCmdFlags & NVS2VF_USE_DELIVERY_CTL) &&
             vpp.llDeliveryPeriod != 0) {
            NvResetEvent(lpProcInfo->hTimer3);
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_VPP_TIMER_IID);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_TIME | 0x80000);
            vpp.pPusher->push(3, (DWORD)(vpp.llDeliveryTime & 0x00000000FFFFFFFF));
            vpp.pPusher->push(4, (DWORD)(vpp.llDeliveryTime >> 32));
            vpp.pPusher->push(5, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_NOTIFY | 0x40000);
            vpp.pPusher->push(6, NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN);
            vpp.pPusher->adjust(7);
            vpp.pPusher->start(TRUE);
            pDriverData->dDrawSpareSubchannelObject = NV_VPP_TIMER_IID;
            vpp.llDeliveryTime += vpp.llDeliveryPeriod;
            if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hTimer3, lpS2VData->dwTimeoutTime))) {
                DPF(" *** TIMER event failure ***");
                EVENT_ERROR;
            }
        }

        // wait for the scanline to hit the right place
        if ((lpS2VData->dwCmdFlags & NVS2VF_CRTC_SYNC) && 
             getDC()->flipPrimaryRecord.nvTimingInfo[lpS2VData->dwHead].Head != 0xFFFFFFFF &&
            (vpp.pSysInfo->dwNVClasses & NVCLASS_0004_TIMER)) {
            NV_CFGEX_CURRENT_SCANLINE_MULTI_PARAMS cfgParams;
            DWORD dwScanDelta;
            __int64 llWaitTime;

            NvResetEvent(lpProcInfo->hTimer3);

            // get current scanline
            cfgParams.Head = lpS2VData->dwHead;
            NvRmConfigGetEx (pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                             NV_CFGEX_CURRENT_SCANLINE_MULTI, &cfgParams, sizeof(cfgParams));

            // calculate how many scanlines we have to wait for
            if (cfgParams.RasterPosition > lpS2VData->dwScanline) {
                dwScanDelta = lpS2VData->dwScanline + getDC()->flipPrimaryRecord.nvTimingInfo[lpS2VData->dwHead].VTotal - cfgParams.RasterPosition;
            } else {
                dwScanDelta = lpS2VData->dwScanline - cfgParams.RasterPosition;
            }

            // calculate how long that is in ns
            llWaitTime = (LONGLONG)dwScanDelta * getDC()->flipPrimaryRecord.llFlipDurationNs[lpS2VData->dwHead] / getDC()->flipPrimaryRecord.nvTimingInfo[lpS2VData->dwHead].VTotal;

            // Sleep and don't wake up until that time has elapsed
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, NV_VPP_TIMER_IID);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_TIME_RELATIVE | 0x80000);
            vpp.pPusher->push(3, (DWORD)(llWaitTime & 0x00000000FFFFFFFF));
            vpp.pPusher->push(4, (DWORD)(llWaitTime >> 32));
            vpp.pPusher->push(5, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_NOTIFY | 0x40000);
            vpp.pPusher->push(6, NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN);
            vpp.pPusher->adjust(7);
            vpp.pPusher->start(TRUE);
            pDriverData->dDrawSpareSubchannelObject = NV_VPP_TIMER_IID;
            if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hTimer3, lpS2VData->dwTimeoutTime))) {
                DPF(" *** TIMER event failure ***");
                EVENT_ERROR;
            }
        }

        // do the fourcc blit
        vpp.pPusher->push(0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
        vpp.pPusher->push(1, NV_VPP_SCALED_IMAGE2_IID);
        vpp.pPusher->push(2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
        vpp.pPusher->push(3, dwSrcContextDma);     // SetContextDmaImage
        vpp.pPusher->push(4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_SURFACE_OFFSET | 0x40000);
        if (lpS2VData->dwDstFlags & NVS2VF_SWIZZLED) {
            vpp.pPusher->push(5, D3D_CONTEXT_SURFACE_SWIZZLED);    // SetContextSurface
        } else {
            vpp.pPusher->push(5, NV_DD_SURFACES_2D);               // SetContextSurface
        }
        vpp.pPusher->push(6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
        vpp.pPusher->push(7, dwSrcFormat);         // SetColorFormat
        vpp.pPusher->push(8, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
        vpp.pPusher->push(9, 0);              // ClipPoint
        vpp.pPusher->push(10, dwDstSize);     // ClipSize
        vpp.pPusher->push(11, 0);             // ImageOutPoint
        vpp.pPusher->push(12, dwDstSize);     // ImageOutSize
        vpp.pPusher->push(13, dwDeltaX);      // DsDx
        vpp.pPusher->push(14, dwDeltaY);      // DtDy
        vpp.pPusher->push(15, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
        vpp.pPusher->push(16, dwSrcSize);     // ImageInSize
        vpp.pPusher->push(17, (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                                   (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                                    lpS2VData->dwSrcPitch);
        vpp.pPusher->push(18, dwSrcOffset);   // ImageInOffset
        vpp.pPusher->push(19, lpS2VData->dwSrcPixelBias);  // ImageInPoint
        vpp.pPusher->push(20, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_NOTIFY_OFFSET | 0x40000);
        vpp.pPusher->push(21, NV089_NOTIFY_WRITE_THEN_AWAKEN);
        vpp.pPusher->push(22, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_NO_OPERATION | 0x40000);
        vpp.pPusher->push(23, 0);
        vpp.pPusher->adjust(24);
        vpp.pPusher->start(TRUE);

        if (lpS2VData->bWaitForCompletion) {
            if (lpProcInfo && lpProcInfo->hFourCCBlt3) {
                if (IS_EVENT_ERROR(NvWaitEvent(lpProcInfo->hFourCCBlt3, lpS2VData->dwTimeoutTime))) {
                    EVENT_ERROR;
                    return NVS2VERR_TIMEOUT;
                }
            } else {
                vpp.pPusher->flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
                return NVS2VERR_NO_EVENT;
            }
        }
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_GET_TEXTURE_OFFSET:
// ************************************************************************
        lpS2VData->fpTexture = (LPVOID) nvGetTextureFromSystemMemAddress(pDriverData, (FLATPTR)lpS2VData->fpTexture);
        if ((DWORD)lpS2VData->fpTexture == 0xFFFFFFFF) {
            return NVS2VERR_GENERIC_FATAL;
        }
        return NVS2VERR_OK;

// ************************************************************************
    case NVS2VCMD_NOOP:
// ************************************************************************
        return NVS2VERR_OK;
    }

    return NVS2VERR_BAD_COMMAND;
}

#endif

// -----------------------------------------------------------------------------
// nvSetOverlayColorControl
//      Sets the colour control for the hardware overlay.  This is a private
//      interface for changing the controls without owning the overlay.  The
//      colour controls will be applied to any flippable overlay to the target
//      surface. If the lpDDCC is NULL, then capabilities are returned,
//      otherwise returns TRUE if succeeded.

DWORD __stdcall nvSetOverlayColorControl(DWORD dwDevice, Nv_ColorControl_t *lpDDCC)
{
    GLOBALDATA* pDriverData = NULL; // override global pDriverData

    pDriverData = getGlobalDataPtr(dwDevice);
    if (pDriverData == NULL) {
        return NVS2VERR_INIT_FAILED;  // We cannot handle this -- we need a context ptr
    }
    Vpp_t &vpp = pDriverData->vpp;

    if (lpDDCC) {
        if (lpDDCC->dwSize != sizeof(Nv_ColorControl_t)) return FALSE;
        if ((lpDDCC->dwFlags & ~(NV_VPP_COLOR_CONTRAST | NV_VPP_COLOR_BRIGHTNESS | NV_VPP_COLOR_HUE | NV_VPP_COLOR_SATURATION)) != 0)
            return (FALSE);
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            while (lpDDCC->lHue < -180) lpDDCC->lHue += 360;
            while (lpDDCC->lHue >= 180) lpDDCC->lHue -= 360;
            if (lpDDCC->dwFlags & NV_VPP_COLOR_CONTRAST)
                vpp.colorCtrl.lContrast   = min(max(lpDDCC->lContrast * 20000 / 200, 0), 20000);
            if (lpDDCC->dwFlags & NV_VPP_COLOR_BRIGHTNESS)
                vpp.colorCtrl.lBrightness = min(max(lpDDCC->lBrightness * 100, -10000), 10000);
            if (lpDDCC->dwFlags & NV_VPP_COLOR_HUE)
                vpp.colorCtrl.lHue        = lpDDCC->lHue;
            if (lpDDCC->dwFlags & NV_VPP_COLOR_SATURATION)
                vpp.colorCtrl.lSaturation = min(max(lpDDCC->lSaturation * 20000 / 200, 0), 20000);
        } else {
            while (lpDDCC->lHue < 0)    lpDDCC->lHue += 360;
            while (lpDDCC->lHue >= 360) lpDDCC->lHue -= 360;
            if (lpDDCC->dwFlags & NV_VPP_COLOR_CONTRAST)
                vpp.colorCtrl.lContrast   = min(max(lpDDCC->lContrast * 511 / 200, 0), 511);
            if (lpDDCC->dwFlags & NV_VPP_COLOR_BRIGHTNESS)
                vpp.colorCtrl.lBrightness = min(max(lpDDCC->lBrightness, -256), 255);
            if (lpDDCC->dwFlags & NV_VPP_COLOR_HUE)
                vpp.colorCtrl.lHue        = lpDDCC->lHue;
            if (lpDDCC->dwFlags & NV_VPP_COLOR_SATURATION)
                vpp.colorCtrl.lSaturation = min(max(lpDDCC->lSaturation * 512 / 200, 0), 512);
            vpp.regOverlayColourControlEnable    = lpDDCC->dwReserved1 & 0x0000FFFF;
            vpp.regOverlayMode                   = lpDDCC->dwReserved1 >> 16;
        }
        return (TRUE);
    }
    else {
        if (!vpp.regOverlayColourControlEnable) return 0;
        return (NV_VPP_COLOR_CONTRAST | NV_VPP_COLOR_BRIGHTNESS | NV_VPP_COLOR_HUE | NV_VPP_COLOR_SATURATION);
    }
}

#ifdef __cplusplus
}       // extern "C"
#endif

#endif  // NVARCH >= 0x04
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvprocman.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"
#pragma hdrstop

// Local function
BOOL pmDeleteProcessPDD       (GLOBALDATA *pDriverData, DWORD processID);

// NB: This file is broken into 3 parts.  One for Win9x, Win2k, and WinNT4.
//     All functions are implemented in each section.

#if IS_WIN9X
// Event Services (Set,Reset,Wait)
//
HRESULT NvResetEvent(HDRVEVENT hEvent)
{
    return ResetEvent(hEvent);
}

HRESULT NvSetEvent(HDRVEVENT hEvent)
{
    return SetEvent(hEvent);
}

HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout)
{
    return WaitForSingleObject(hEvent,timeout);
}

// ------------------------------------------------------------------------------------------
// ConvertRing3EventToRing0
//      Converts a ring3 event handle to a ring0 event handle that RM can understand
HANDLE ConvertRing3EventToRing0 ( HANDLE hEventRing3 )
{
    HANDLE  hEventRing0;

#ifdef IKOS
    return (NULL);
#endif

    if ( hEventRing3 == NULL || global.pfOpenVxDHandle == NULL)
        return (NULL);

    /*
     * Create a ring0 event
     */
    hEventRing0 = (*global.pfOpenVxDHandle)(hEventRing3);

    return(hEventRing0);
}

// ------------------------------------------------------------------------------------------
// CloseRing0Handle
//      Closes the ring0 event handle
BOOL CloseRing0Handle( HANDLE hEventRing0 )
{
    HINSTANCE hKernel32Dll;
    HANDLE  (WINAPI *pfCloseVxDHandle)(HANDLE);

    if (hEventRing0 == NULL) return (FALSE);

    hKernel32Dll = LoadLibrary("kernel32.dll");
    if (!hKernel32Dll)
        return (FALSE);

    pfCloseVxDHandle = (HANDLE (WINAPI *)(HANDLE))GetProcAddress(hKernel32Dll, "CloseVxDHandle");
    if (!pfCloseVxDHandle) {
        FreeLibrary(hKernel32Dll);
        return (FALSE);
    }

    (*pfCloseVxDHandle)(hEventRing0);
    FreeLibrary(hKernel32Dll);

    return (TRUE);
}


// -------------------------------------------------------------------------
// pmGetProcess
//      Returns a pointer to the PROCESSINFO structure of the associated
//      process ID.  Returns NULL if not found.
LPPROCESSINFO pmGetProcess(GLOBALDATA *pDriverData, DWORD processID)
{
LPPROCESSINFO lpProcInfo;
static DWORD state=0;
DWORD mask;

    switch (pDXShare->dwHeadNumber) {
    case 1:  mask = 0x00000002; break;
    case 0:
    default: mask = 0x00000001; break;
    }

    // to prevent infinite recursion
    if ((pDXShare->dwHeadNumber == 0 && (state & 0x00000001)) ||
        (pDXShare->dwHeadNumber == 1 && (state & 0x00000002))) {
        return NULL;
    }

    for (lpProcInfo=pDriverData->lpProcessInfoHead; lpProcInfo!=NULL; lpProcInfo=lpProcInfo->lpNext) {
        if (lpProcInfo->dwProcessID == processID)
            return lpProcInfo;
    }

    state |= mask;
    pmAddProcess(pDriverData, processID);
    state &= ~mask;
    return pmGetProcess(pDriverData, processID);
}

// -------------------------------------------------------------------------
// pmAddProcess
//      Adds a process to the linked list, creates events and attaches them
//      to their respective objects.  Returns TRUE if succeeded.
BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID)
{
LPPROCESSINFO lpProcInfo;
SECURITY_ATTRIBUTES sec = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};

    if (pmGetProcess(pDriverData, processID) != NULL)
        return FALSE;

    lpProcInfo = (LPPROCESSINFO) AllocIPM(sizeof(PROCESSINFO));
    if (lpProcInfo == NULL)
        return FALSE;

    lpProcInfo->lpNext          = pDriverData->lpProcessInfoHead;
    lpProcInfo->dwProcessID     = processID;

    // under Win9x, events are created once under the parent process
    // all subsequent processes open the same user event

    if (pDriverData->lpProcessInfoHead == 0) {
        // first one, create and attach events
        // Idle event
        lpProcInfo->hIdleSyncEvent3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_IDLE);
        lpProcInfo->hIdleSyncEvent0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hIdleSyncEvent3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_ROP_GDI_RECT_AND_TEXT,
                       NV_DD_EVENT_IDLE_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV04A_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hIdleSyncEvent0);
        NvSetEvent(lpProcInfo->hIdleSyncEvent3);

        // Timer event
        if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0004_TIMER) {
            lpProcInfo->hTimer3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_TIMER);
            lpProcInfo->hTimer0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hTimer3);
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_TIMER_IID,
                           NV_DD_EVENT_TIMER, NV01_EVENT_WIN32_EVENT,
                           NV004_NOTIFIERS_SET_ALARM_NOTIFY, (void*) lpProcInfo->hTimer0);
            NvSetEvent(lpProcInfo->hTimer3);
        }

        // Overlay flip events
        lpProcInfo->hOvlFlipEvenEvent3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_OVL_FLIP_EVEN);
        lpProcInfo->hOvlFlipEvenEvent0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hOvlFlipEvenEvent3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OVERLAY_IID,
                       NV_DD_EVENT_OVL_FLIP1, NV01_EVENT_WIN32_EVENT,
                       NV07A_NOTIFIERS_SET_OVERLAY(0), (void*) lpProcInfo->hOvlFlipEvenEvent0);
        NvSetEvent(lpProcInfo->hOvlFlipEvenEvent3);

        lpProcInfo->hOvlFlipOddEvent3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_OVL_FLIP_ODD);
        lpProcInfo->hOvlFlipOddEvent0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hOvlFlipOddEvent3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OVERLAY_IID,
                       NV_DD_EVENT_OVL_FLIP2, NV01_EVENT_WIN32_EVENT,
                       NV07A_NOTIFIERS_SET_OVERLAY(1), (void*) lpProcInfo->hOvlFlipOddEvent0);
        NvSetEvent(lpProcInfo->hOvlFlipOddEvent3);

        // DMA to Video memory event
        lpProcInfo->hDMABlitToVid3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_DMA_TO_VID);
        lpProcInfo->hDMABlitToVid0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hDMABlitToVid3);
        NvRmAllocEvent(pDriverData->dwRootHandle, pDriverData->vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID,
                       NV_DD_EVENT_DMABLT_TO_VID, NV01_EVENT_WIN32_EVENT,
                       NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) lpProcInfo->hDMABlitToVid0);
        NvSetEvent(lpProcInfo->hDMABlitToVid3);

        // Format conversion to YUV422 event
        lpProcInfo->hConvert3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_CONVERT);
        lpProcInfo->hConvert0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hConvert3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_V2V_FORMAT_Y_IID,
                       NV_DD_EVENT_CONVERT_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) lpProcInfo->hConvert0);
        NvSetEvent(lpProcInfo->hConvert3);

        // DVD subpicture
        lpProcInfo->hSubPicture3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_SUBPICTURE);
        lpProcInfo->hSubPicture0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hSubPicture3);
        NvRmAllocEvent(pDriverData->dwRootHandle, pDriverData->vpp.m_obj_a[DVDPICT_NDX].classIID,
                       NV_DD_EVENT_DVD_SUBPICTURE, NV01_EVENT_WIN32_EVENT,
                       NV038_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hSubPicture0);
        NvSetEvent(lpProcInfo->hSubPicture3);

        // Colour control events
        lpProcInfo->hColourControl3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_COLOURCONTROL);
        lpProcInfo->hColourControl0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hColourControl3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_V2OSH_FORMAT_IID,
                       NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) lpProcInfo->hColourControl0);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OSH2V_FORMAT_IID,
                       NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) lpProcInfo->hColourControl0);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_ALPHA_BLIT_IID,
                       NV_DD_EVENT_ALPHA_BLIT_SYNC, NV01_EVENT_WIN32_EVENT,
                       NV05F_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hColourControl0);
        NvSetEvent(lpProcInfo->hColourControl3);

        // Temporal filter event
        lpProcInfo->hTFilter3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_TFILTER);
        lpProcInfo->hTFilter0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hTFilter3);
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20) {
            NvRmAllocEvent(pDriverData->dwRootHandle, D3D_KELVIN_PRIMITIVE,
                           NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV097_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hTFilter0);
        } else if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            NvRmAllocEvent(pDriverData->dwRootHandle, D3D_CELSIUS_PRIMITIVE,
                           NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV056_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hTFilter0);
        } else {
            NvRmAllocEvent(pDriverData->dwRootHandle, D3D_DX6_MULTI_TEXTURE_TRIANGLE,
                           NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV055_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hTFilter0);
        }
        NvSetEvent(lpProcInfo->hTFilter3);

        // Skip this on NV4/NV5
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
        {
            // Deinterlace filter event
            lpProcInfo->hDFilter3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_DFILTER);
            lpProcInfo->hDFilter0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hDFilter3);
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20) {
                NvRmAllocEvent(pDriverData->dwRootHandle, D3D_KELVIN_PRIMITIVE,
                               NV_DD_EVENT_DFILTER_SYNC, NV01_EVENT_WIN32_EVENT,
                               NV097_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hDFilter0);
            } else if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                NvRmAllocEvent(pDriverData->dwRootHandle, D3D_CELSIUS_PRIMITIVE,
                               NV_DD_EVENT_DFILTER_SYNC, NV01_EVENT_WIN32_EVENT,
                               NV056_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hDFilter0);
            }
            NvSetEvent(lpProcInfo->hDFilter3);
        }

        // Full screen mirror event
        lpProcInfo->hFSMirror3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_FSMIRROR);
        lpProcInfo->hFSMirror0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hFSMirror3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_SCALED_IMAGE1_IID,
                       NV_DD_EVENT_FSMIRROR, NV01_EVENT_WIN32_EVENT,
                       NV089_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hFSMirror0);
        NvSetEvent(lpProcInfo->hFSMirror3);

        // 4CC blt event
        lpProcInfo->hFourCCBlt3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_FOURCCBLT);
        lpProcInfo->hFourCCBlt0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hFourCCBlt3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_SCALED_IMAGE2_IID,
                       NV_DD_EVENT_FOURCCBLT, NV01_EVENT_WIN32_EVENT,
                       NV089_NOTIFIERS_NOTIFY, (void*) lpProcInfo->hFourCCBlt0);
        NvSetEvent(lpProcInfo->hFourCCBlt0);

        // Primary flip events
        lpProcInfo->hPrimary0FlipEven3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_PRIMARY0_FLIP_EVEN);
        lpProcInfo->hPrimary0FlipEven0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hPrimary0FlipEven3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC,
                       NV_DD_EVENT_PRIMARY0_FLIP1, NV01_EVENT_WIN32_EVENT,
                       NV067_NOTIFIERS_SET_IMAGE(0), (void*) lpProcInfo->hPrimary0FlipEven0);
        NvSetEvent(lpProcInfo->hPrimary0FlipEven3);

        lpProcInfo->hPrimary0FlipOdd3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_PRIMARY0_FLIP_ODD);
        lpProcInfo->hPrimary0FlipOdd0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hPrimary0FlipOdd3);
        NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC,
                       NV_DD_EVENT_PRIMARY0_FLIP2, NV01_EVENT_WIN32_EVENT,
                       NV067_NOTIFIERS_SET_IMAGE(1), (void*) lpProcInfo->hPrimary0FlipOdd0);
        NvSetEvent(lpProcInfo->hPrimary0FlipOdd3);

        if (pDriverData->dwHeads > 1)
        {
            lpProcInfo->hPrimary1FlipEven3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_PRIMARY1_FLIP_EVEN);
            lpProcInfo->hPrimary1FlipEven0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hPrimary1FlipEven3);
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC + 1,
                           NV_DD_EVENT_PRIMARY1_FLIP1, NV01_EVENT_WIN32_EVENT,
                           NV067_NOTIFIERS_SET_IMAGE(0), (void*) lpProcInfo->hPrimary1FlipEven0);
            NvSetEvent(lpProcInfo->hPrimary1FlipEven3);

            lpProcInfo->hPrimary1FlipOdd3 = CreateEvent(&sec, TRUE, TRUE, EVENTNAME_PRIMARY1_FLIP_ODD);
            lpProcInfo->hPrimary1FlipOdd0 = ConvertRing3EventToRing0((HANDLE)lpProcInfo->hPrimary1FlipOdd3);
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC + 1,
                           NV_DD_EVENT_PRIMARY1_FLIP2, NV01_EVENT_WIN32_EVENT,
                           NV067_NOTIFIERS_SET_IMAGE(1), (void*) lpProcInfo->hPrimary1FlipOdd0);
            NvSetEvent(lpProcInfo->hPrimary1FlipOdd3);
        }

    } else {
        lpProcInfo->hIdleSyncEvent3      = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_IDLE);
        lpProcInfo->hIdleSyncEvent0      = 0;
        lpProcInfo->hTimer3              = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_TIMER);
        lpProcInfo->hTimer0              = 0;
        lpProcInfo->hOvlFlipEvenEvent3   = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_OVL_FLIP_EVEN);
        lpProcInfo->hOvlFlipEvenEvent0   = 0;
        lpProcInfo->hOvlFlipOddEvent3    = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_OVL_FLIP_ODD);
        lpProcInfo->hOvlFlipOddEvent0    = 0;
        lpProcInfo->hDMABlitToVid3       = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_DMA_TO_VID);
        lpProcInfo->hDMABlitToVid0       = 0;
        lpProcInfo->hConvert3            = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_CONVERT);
        lpProcInfo->hConvert0            = 0;
        lpProcInfo->hSubPicture3         = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_SUBPICTURE);
        lpProcInfo->hSubPicture0         = 0;
        lpProcInfo->hColourControl3      = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_COLOURCONTROL);
        lpProcInfo->hColourControl0      = 0;
        lpProcInfo->hTFilter3            = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_TFILTER);
        lpProcInfo->hTFilter0            = 0;
        // Skip this on NV4/NV5
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
        {
            lpProcInfo->hDFilter3            = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_DFILTER);
            lpProcInfo->hDFilter0            = 0;
        }
        lpProcInfo->hFSMirror3           = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_FSMIRROR);
        lpProcInfo->hFSMirror0           = 0;
        lpProcInfo->hFourCCBlt0          = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_FOURCCBLT);
        lpProcInfo->hFourCCBlt3          = 0;
        lpProcInfo->hPrimary0FlipEven3   = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_PRIMARY0_FLIP_EVEN);
        lpProcInfo->hPrimary0FlipEven0   = 0;
        lpProcInfo->hPrimary0FlipOdd3    = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_PRIMARY0_FLIP_ODD);
        lpProcInfo->hPrimary0FlipOdd0    = 0;
        if (pDriverData->dwHeads > 1)
        {
            lpProcInfo->hPrimary1FlipEven3   = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_PRIMARY1_FLIP_EVEN);
            lpProcInfo->hPrimary1FlipEven0   = 0;
            lpProcInfo->hPrimary1FlipOdd3    = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_PRIMARY1_FLIP_ODD);
            lpProcInfo->hPrimary1FlipOdd0    = 0;
        }
    }

    pDriverData->lpProcessInfoHead = lpProcInfo;
    return TRUE;
}

// -------------------------------------------------------------------------
// pmDeleteProcess
//      Deletes a process from the info list.  Destroy all associated
//      events.  Returns TRUE if succeeded
BOOL pmDeleteProcess(DWORD processID)
{
    return pmDeleteProcessPDD(pDriverData, processID);
}

BOOL pmDeleteProcessPDD(GLOBALDATA *pDriverData, DWORD processID)
{
    LPPROCESSINFO lpProcInfo, lpPrevProcInfo;

    for (lpProcInfo=pDriverData->lpProcessInfoHead; lpProcInfo!=NULL; lpProcInfo=lpProcInfo->lpNext) {
        if (lpProcInfo->dwProcessID == processID) {
            if (lpProcInfo == pDriverData->lpProcessInfoHead) {
                pDriverData->lpProcessInfoHead = lpProcInfo->lpNext;
            } else {
                lpPrevProcInfo->lpNext = lpProcInfo->lpNext;
            }

            /*  Rely on process termination to kill these, closing them seems to screw up Windows for unknown reasons
            if (lpProcInfo->hIdleSyncEvent3)
                WAITFORSINGLEOBJECT((HANDLE)lpProcInfo->hIdleSyncEvent3, 100);
            if (lpProcInfo->hIdleSyncEvent0) {
                CloseRing0Handle((HANDLE)lpProcInfo->hIdleSyncEvent0);
                lpProcInfo->hIdleSyncEvent0 = 0;
            }
            if (lpProcInfo->hIdleSyncEvent3) {
                CLOSE_HANDLE((HANDLE)lpProcInfo->hIdleSyncEvent3);
                lpProcInfo->hIdleSyncEvent3 = 0;
            }
            */

            FreeIPM(lpProcInfo);
            return TRUE;
        } else {
            lpPrevProcInfo = lpProcInfo;
        }
    }
    return FALSE;
}

// -------------------------------------------------------------------------
// pmDeleteAllProcesses
//      Deletes all processes
void pmDeleteAllProcesses(GLOBALDATA *pDriverData)
{
    LPPROCESSINFO lpProcInfo;

    // tells the ring0 code to not run any more!
    pDriverData->vpp.regRing0ColourCtlInterlockFlags = pDriverData->vpp.regRing0ColourCtlInterlockFlags & 0xFFFFFFFE;
    {
        DWORD aCount = 16;
        while((pDriverData->vpp.regRing0ColourCtlInterlockFlags & 0x02) && aCount-- ) {
            Sleep(1);  // waits 1 millisecond
        }
    }

    while (pDriverData->lpProcessInfoHead != 0) {
        lpProcInfo = pDriverData->lpProcessInfoHead;
        pmDeleteProcessPDD(pDriverData, lpProcInfo->dwProcessID);
    }
}

#elif IS_WINNT5

// Event Services (Set,Reset,Wait)
//
HRESULT NvResetEvent(HDRVEVENT hEvent)
{
    LARGE_INTEGER timeOut;
    timeOut.LowPart = -2000000;
    timeOut.HighPart = -1;
    return EngWaitForSingleObject(hEvent, &timeOut);
}

HRESULT NvSetEvent(HDRVEVENT hEvent)
{
    return EngSetEvent(hEvent);
}

HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout)
{
    HRESULT ddrval;
    LARGE_INTEGER bigTimeOut;
    bigTimeOut.LowPart = -((int)timeout) * 10000;   // measured in units of 100 fs in NT
    bigTimeOut.HighPart = (timeout == 0) ? 0:(-1);  // negative means relative to current time

    // note: DDK docs are wrong, it returns an error code, not a TRUE/FALSE result
    ddrval = EngWaitForSingleObject(hEvent, &bigTimeOut);
    EngSetEvent(hEvent);
    return ddrval;
}

LPPROCESSINFO pmGetProcess(GLOBALDATA *pDriverData, DWORD processID)
{
	if (pDriverData->lpProcessInfoHead == NULL) {
		pmAddProcess(pDriverData, processID);
	}

    return(pDriverData->lpProcessInfoHead);
}
   
BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID)
{
    LPPROCESSINFO lpProcInfo;

    lpProcInfo = &(pDriverData->procInfo);

    lpProcInfo->lpNext      = NULL;
    lpProcInfo->dwProcessID = processID;

    // under WIN2k, all driver events are shared among all processes
    // cannot use standard user event services, must use EngEvent services
    // set the ring3 event member to equal the ring0 event to make thing easier to macrotize

    // idle event
    if (lpProcInfo->hIdleSyncEvent0 == NULL) {
        EngCreateEvent(&lpProcInfo->hIdleSyncEvent0);
        lpProcInfo->hIdleSyncEvent3 = lpProcInfo->hIdleSyncEvent0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_ROP_GDI_RECT_AND_TEXT,
                           NV_DD_EVENT_IDLE_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV04A_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hIdleSyncEvent0)))) {
            EngDeleteEvent(pDriverData->procInfo.hIdleSyncEvent0);
            lpProcInfo->hIdleSyncEvent0 = NULL;
            lpProcInfo->hIdleSyncEvent3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hIdleSyncEvent3);
        }
    }

    // timer event
    if (lpProcInfo->hTimer0 == NULL &&
       (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_0004_TIMER)) {
        EngCreateEvent(&lpProcInfo->hTimer0);
        lpProcInfo->hTimer3 = lpProcInfo->hTimer0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_TIMER_IID,
                           NV_DD_EVENT_TIMER, NV01_EVENT_WIN32_EVENT,
                           NV004_NOTIFIERS_SET_ALARM_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hTimer0)))) {
            EngDeleteEvent(pDriverData->procInfo.hTimer0);
            lpProcInfo->hTimer0 = NULL;
            lpProcInfo->hTimer3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hTimer3);
        }
    }

    // DMA to Video memory event
    if (lpProcInfo->hDMABlitToVid0 == NULL) {
        EngCreateEvent(&lpProcInfo->hDMABlitToVid0);
        lpProcInfo->hDMABlitToVid3 = lpProcInfo->hDMABlitToVid0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, pDriverData->vpp.m_obj_a[DMABLT_TO_VID_NDX].classIID,
                           NV_DD_EVENT_DMABLT_TO_VID, NV01_EVENT_WIN32_EVENT,
                           NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hDMABlitToVid0)))) {
            EngDeleteEvent(pDriverData->procInfo.hDMABlitToVid0);
            lpProcInfo->hDMABlitToVid0 = NULL;
            lpProcInfo->hDMABlitToVid3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hDMABlitToVid3);
        }
    }

    // Full screen mirror event
    if (lpProcInfo->hFSMirror0 == NULL) {
        EngCreateEvent(&lpProcInfo->hFSMirror0);
        lpProcInfo->hFSMirror3 = lpProcInfo->hFSMirror0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_SCALED_IMAGE1_IID,
                           NV_DD_EVENT_FSMIRROR, NV01_EVENT_WIN32_EVENT,
                           NV089_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hFSMirror0)))) {
            EngDeleteEvent(pDriverData->procInfo.hFSMirror0);
            lpProcInfo->hFSMirror0 = NULL;
            lpProcInfo->hFSMirror3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hFSMirror3);
        }
    }

    // FourCCBlt event
    if (lpProcInfo->hFourCCBlt0 == NULL) {
        EngCreateEvent(&lpProcInfo->hFourCCBlt0);
        lpProcInfo->hFourCCBlt3 = lpProcInfo->hFourCCBlt0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_SCALED_IMAGE2_IID,
                           NV_DD_EVENT_FOURCCBLT, NV01_EVENT_WIN32_EVENT,
                           NV089_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hFourCCBlt0)))) {
            EngDeleteEvent(pDriverData->procInfo.hFourCCBlt0);
            lpProcInfo->hFourCCBlt0 = NULL;
            lpProcInfo->hFourCCBlt3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hFourCCBlt3);
        }
    }

    // don't try to create overlay events if an overlay doesn't exist
    if (pDriverData->vpp.dwOverlaySurfaces == 0)
    {
        return TRUE;
    }

    // Overlay flip events
    if (lpProcInfo->hOvlFlipEvenEvent0 == NULL) {
        EngCreateEvent(&lpProcInfo->hOvlFlipEvenEvent0);
        lpProcInfo->hOvlFlipEvenEvent3 = lpProcInfo->hOvlFlipEvenEvent0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OVERLAY_IID,
                           NV_DD_EVENT_OVL_FLIP1, NV01_EVENT_WIN32_EVENT,
                           NV07A_NOTIFIERS_SET_OVERLAY(0), (void*) (*((LPDWORD)lpProcInfo->hOvlFlipEvenEvent0)))) {
            // error because overlay not created yet, so do this later
            EngDeleteEvent(pDriverData->procInfo.hOvlFlipEvenEvent0);
            lpProcInfo->hOvlFlipEvenEvent0 = NULL;
            lpProcInfo->hOvlFlipEvenEvent3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hOvlFlipEvenEvent3);
        }
    }

    if (lpProcInfo->hOvlFlipOddEvent0 == NULL) {
        EngCreateEvent(&lpProcInfo->hOvlFlipOddEvent0);
        lpProcInfo->hOvlFlipOddEvent3 = lpProcInfo->hOvlFlipOddEvent0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OVERLAY_IID,
                           NV_DD_EVENT_OVL_FLIP2, NV01_EVENT_WIN32_EVENT,
                           NV07A_NOTIFIERS_SET_OVERLAY(1), (void*) (*((LPDWORD)lpProcInfo->hOvlFlipOddEvent0)))) {
            // error because overlay not created yet, so do this later
            EngDeleteEvent(pDriverData->procInfo.hOvlFlipOddEvent0);
            lpProcInfo->hOvlFlipOddEvent0 = NULL;
            lpProcInfo->hOvlFlipOddEvent3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hOvlFlipOddEvent3);
        }
    }

    // Format conversion to YUV422 event
    if (lpProcInfo->hConvert0 == NULL) {
        EngCreateEvent(&lpProcInfo->hConvert0);
        lpProcInfo->hConvert3 = lpProcInfo->hConvert0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_V2V_FORMAT_Y_IID,
                           NV_DD_EVENT_CONVERT_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hConvert0)))) {
            EngDeleteEvent(pDriverData->procInfo.hConvert0);
            lpProcInfo->hConvert0 = NULL;
            lpProcInfo->hConvert3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hConvert3);
        }
    }

    // DVD subpicture
    if (lpProcInfo->hSubPicture0 == NULL) {
        EngCreateEvent(&lpProcInfo->hSubPicture0);
        lpProcInfo->hSubPicture3 = lpProcInfo->hSubPicture0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, pDriverData->vpp.m_obj_a[DVDPICT_NDX].classIID,
                           NV_DD_EVENT_DVD_SUBPICTURE, NV01_EVENT_WIN32_EVENT,
                           NV038_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hSubPicture0)))) {
            EngDeleteEvent(pDriverData->procInfo.hSubPicture0);
            lpProcInfo->hSubPicture0 = NULL;
            lpProcInfo->hSubPicture3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hSubPicture3);
        }
    }

    // Colour control events
    if (lpProcInfo->hColourControl0 == NULL) {
        EngCreateEvent(&lpProcInfo->hColourControl0);
        lpProcInfo->hColourControl3 = lpProcInfo->hColourControl0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_V2OSH_FORMAT_IID,
                           NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hColourControl0))) ||
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_OSH2V_FORMAT_IID,
                           NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV039_NOTIFIERS_BUFFER_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hColourControl0))) ||
            NvRmAllocEvent(pDriverData->dwRootHandle, NV_VPP_ALPHA_BLIT_IID,
                           NV_DD_EVENT_ALPHA_BLIT_SYNC, NV01_EVENT_WIN32_EVENT,
                           NV05F_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hColourControl0)))) {
            EngDeleteEvent(pDriverData->procInfo.hColourControl0);
            lpProcInfo->hColourControl0 = NULL;
            lpProcInfo->hColourControl3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hColourControl3);
        }
    }

    // Temporal filter event
    if (lpProcInfo->hTFilter0 == NULL) {
        DWORD result;
        EngCreateEvent(&lpProcInfo->hTFilter0);
        lpProcInfo->hTFilter3 = lpProcInfo->hTFilter0;
        if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20) {
            result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_KELVIN_PRIMITIVE,
                                    NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                                    NV097_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hTFilter0)));
        } else if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
            result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_CELSIUS_PRIMITIVE,
                                    NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                                    NV056_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hTFilter0)));
        } else {
            result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_DX6_MULTI_TEXTURE_TRIANGLE,
                                    NV_DD_EVENT_COMBINER_SYNC, NV01_EVENT_WIN32_EVENT,
                                    NV055_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hTFilter0)));
        }
        if (result) {
            EngDeleteEvent(pDriverData->procInfo.hTFilter0);
            lpProcInfo->hTFilter0 = NULL;
            lpProcInfo->hTFilter3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hTFilter3);
        }
    }

    // Skip this on NV4/NV5
    if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10)
    {
        // Deinterlace filter event
        if (lpProcInfo->hDFilter0 == NULL) {
            DWORD result;
            EngCreateEvent(&lpProcInfo->hDFilter0);
            lpProcInfo->hDFilter3 = lpProcInfo->hDFilter0;
            if (pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_20) {
                result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_KELVIN_PRIMITIVE,
                                        NV_DD_EVENT_DFILTER_SYNC, NV01_EVENT_WIN32_EVENT,
                                        NV097_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hDFilter0)));
            } else {
                result = NvRmAllocEvent(pDriverData->dwRootHandle, D3D_CELSIUS_PRIMITIVE,
                                        NV_DD_EVENT_DFILTER_SYNC, NV01_EVENT_WIN32_EVENT,
                                        NV056_NOTIFIERS_NOTIFY, (void*) (*((LPDWORD)lpProcInfo->hDFilter0)));
            }
            if (result) {
                EngDeleteEvent(pDriverData->procInfo.hDFilter0);
                lpProcInfo->hDFilter0 = NULL;
                lpProcInfo->hDFilter3 = NULL;
            } else {
                EngSetEvent(lpProcInfo->hDFilter3);
            }
        }
    }

    // Primary flip events
    if (lpProcInfo->hPrimary0FlipEven0 == NULL) {
        EngCreateEvent(&lpProcInfo->hPrimary0FlipEven0);
        lpProcInfo->hPrimary0FlipEven3 = lpProcInfo->hPrimary0FlipEven0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC,
                           NV_DD_EVENT_PRIMARY0_FLIP1, NV01_EVENT_WIN32_EVENT,
                           NV067_NOTIFIERS_SET_IMAGE(0), (void*) (*((LPDWORD)lpProcInfo->hPrimary0FlipEven0)))) {
            EngDeleteEvent(pDriverData->procInfo.hPrimary0FlipEven0);
            lpProcInfo->hPrimary0FlipEven0 = NULL;
            lpProcInfo->hPrimary0FlipEven3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hPrimary0FlipEven3);
        }
    }

    if (lpProcInfo->hPrimary0FlipOdd0 == NULL) {
        EngCreateEvent(&lpProcInfo->hPrimary0FlipOdd0);
        lpProcInfo->hPrimary0FlipOdd3 = lpProcInfo->hPrimary0FlipOdd0;
        if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC,
                           NV_DD_EVENT_PRIMARY0_FLIP2, NV01_EVENT_WIN32_EVENT,
                           NV067_NOTIFIERS_SET_IMAGE(1), (void*) (*((LPDWORD)lpProcInfo->hPrimary0FlipOdd0)))) {
            EngDeleteEvent(pDriverData->procInfo.hPrimary0FlipOdd0);
            lpProcInfo->hPrimary0FlipOdd0 = NULL;
            lpProcInfo->hPrimary0FlipOdd3 = NULL;
        } else {
            EngSetEvent(lpProcInfo->hPrimary0FlipOdd3);
        }
    }

    // Conditionally create events for primary on 2nd head
    if (pDriverData->dwHeads > 1)
    {
        if (lpProcInfo->hPrimary1FlipEven0 == NULL) {
            EngCreateEvent(&lpProcInfo->hPrimary1FlipEven0);
            lpProcInfo->hPrimary1FlipEven3 = lpProcInfo->hPrimary1FlipEven0;
            if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC + 1,
                               NV_DD_EVENT_PRIMARY1_FLIP1, NV01_EVENT_WIN32_EVENT,
                               NV067_NOTIFIERS_SET_IMAGE(0), (void*) (*((LPDWORD)lpProcInfo->hPrimary1FlipEven0)))) {
                EngDeleteEvent(pDriverData->procInfo.hPrimary1FlipEven0);
                lpProcInfo->hPrimary1FlipEven0 = NULL;
                lpProcInfo->hPrimary1FlipEven3 = NULL;
            } else {
                EngSetEvent(lpProcInfo->hPrimary1FlipEven3);
            }
        }

        if (lpProcInfo->hPrimary1FlipOdd0 == NULL) {
            EngCreateEvent(&lpProcInfo->hPrimary1FlipOdd0);
            lpProcInfo->hPrimary1FlipOdd3 = lpProcInfo->hPrimary1FlipOdd0;
            if (NvRmAllocEvent(pDriverData->dwRootHandle, NV_DD_VIDEO_LUT_CURSOR_DAC + 1,
                               NV_DD_EVENT_PRIMARY1_FLIP2, NV01_EVENT_WIN32_EVENT,
                               NV067_NOTIFIERS_SET_IMAGE(1), (void*) (*((LPDWORD)lpProcInfo->hPrimary1FlipOdd0)))) {
                EngDeleteEvent(pDriverData->procInfo.hPrimary1FlipOdd0);
                lpProcInfo->hPrimary1FlipOdd0 = NULL;
                lpProcInfo->hPrimary1FlipOdd3 = NULL;
            } else {
                EngSetEvent(lpProcInfo->hPrimary1FlipOdd3);
            }
        }
    }

    pDriverData->lpProcessInfoHead = lpProcInfo;
    return TRUE;
}

BOOL pmDeleteProcess(DWORD processID)
{
    return pmDeleteProcessPDD(pDriverData, processID);
}

BOOL pmDeleteProcessPDD(GLOBALDATA *pDriverData, DWORD processID)
{
    if (pDriverData->procInfo.hIdleSyncEvent0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_IDLE_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hIdleSyncEvent0);
        pDriverData->procInfo.hIdleSyncEvent0 = NULL;
        pDriverData->procInfo.hIdleSyncEvent3 = NULL;
    }
    
    if (pDriverData->procInfo.hTimer0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_TIMER);
        EngDeleteEvent(pDriverData->procInfo.hTimer0);
        pDriverData->procInfo.hTimer0 = NULL;
        pDriverData->procInfo.hTimer3 = NULL;
    }
    
    if (pDriverData->procInfo.hOvlFlipEvenEvent0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_OVL_FLIP1);
        EngDeleteEvent(pDriverData->procInfo.hOvlFlipEvenEvent0);
        pDriverData->procInfo.hOvlFlipEvenEvent0 = NULL;
        pDriverData->procInfo.hOvlFlipEvenEvent3 = NULL;
    }
    
    if (pDriverData->procInfo.hOvlFlipOddEvent0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_OVL_FLIP2);
        EngDeleteEvent(pDriverData->procInfo.hOvlFlipOddEvent0);
        pDriverData->procInfo.hOvlFlipOddEvent0 = NULL;
        pDriverData->procInfo.hOvlFlipOddEvent3 = NULL;
    }
    
    if (pDriverData->procInfo.hDMABlitToVid0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_DMABLT_TO_VID);
        EngDeleteEvent(pDriverData->procInfo.hDMABlitToVid0);
        pDriverData->procInfo.hDMABlitToVid0 = NULL;
        pDriverData->procInfo.hDMABlitToVid3 = NULL;
    }
    
    if (pDriverData->procInfo.hConvert0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_CONVERT_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hConvert0);
        pDriverData->procInfo.hConvert0 = NULL;
        pDriverData->procInfo.hConvert3 = NULL;
    }
    
    if (pDriverData->procInfo.hSubPicture0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_DVD_SUBPICTURE);
        EngDeleteEvent(pDriverData->procInfo.hSubPicture0);
        pDriverData->procInfo.hSubPicture0 = NULL;
        pDriverData->procInfo.hSubPicture3 = NULL;
    }
    
    if (pDriverData->procInfo.hColourControl0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC);
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC);
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_ALPHA_BLIT_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hColourControl0);
        pDriverData->procInfo.hColourControl0 = NULL;
        pDriverData->procInfo.hColourControl3 = NULL;
    }
    
    if (pDriverData->procInfo.hTFilter0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_COMBINER_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hTFilter0);
        pDriverData->procInfo.hTFilter0 = NULL;
        pDriverData->procInfo.hTFilter3 = NULL;
    }
    
    if (pDriverData->procInfo.hDFilter0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_DFILTER_SYNC);
        EngDeleteEvent(pDriverData->procInfo.hDFilter0);
        pDriverData->procInfo.hDFilter0 = NULL;
        pDriverData->procInfo.hDFilter3 = NULL;
    }
    
    if (pDriverData->procInfo.hFSMirror0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_FSMIRROR);
        EngDeleteEvent(pDriverData->procInfo.hFSMirror0);
        pDriverData->procInfo.hFSMirror0 = NULL;
        pDriverData->procInfo.hFSMirror3 = NULL;
    }

    if (pDriverData->procInfo.hFourCCBlt0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_FOURCCBLT);
        EngDeleteEvent(pDriverData->procInfo.hFourCCBlt0);
        pDriverData->procInfo.hFourCCBlt0 = NULL;
        pDriverData->procInfo.hFourCCBlt3 = NULL;
    }
    
    if (pDriverData->procInfo.hPrimary0FlipEven0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_PRIMARY0_FLIP1);
        EngDeleteEvent(pDriverData->procInfo.hPrimary0FlipEven0);
        pDriverData->procInfo.hPrimary0FlipEven0 = NULL;
        pDriverData->procInfo.hPrimary0FlipEven3 = NULL;
    }
    
    if (pDriverData->procInfo.hPrimary0FlipOdd0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_PRIMARY0_FLIP2);
        EngDeleteEvent(pDriverData->procInfo.hPrimary0FlipOdd0);
        pDriverData->procInfo.hPrimary0FlipOdd0 = NULL;
        pDriverData->procInfo.hPrimary0FlipOdd3 = NULL;
    }
    
    if (pDriverData->procInfo.hPrimary1FlipEven0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_PRIMARY1_FLIP1);
        EngDeleteEvent(pDriverData->procInfo.hPrimary1FlipEven0);
        pDriverData->procInfo.hPrimary1FlipEven0 = NULL;
        pDriverData->procInfo.hPrimary1FlipEven3 = NULL;
    }
    
    if (pDriverData->procInfo.hPrimary1FlipOdd0)
    {
        NvRmFree(pDriverData->dwRootHandle, NV_DD_DEV_DMA, NV_DD_EVENT_PRIMARY1_FLIP2);
        EngDeleteEvent(pDriverData->procInfo.hPrimary1FlipOdd0);
        pDriverData->procInfo.hPrimary1FlipOdd0 = NULL;
        pDriverData->procInfo.hPrimary1FlipOdd3 = NULL;
    }
    
    pDriverData->lpProcessInfoHead = NULL;
    return(TRUE);
}

void pmDeleteAllProcesses(GLOBALDATA *pDriverData)
{
    pmDeleteProcessPDD(pDriverData, NULL);
    return;
}

#elif IS_WINNT4

// Events are not available for use by the WinNT4 driver,
// but since the 98 and 2k drivers use them, we stub these
// functions so that a valid pointer to a process structure is 
// returned.
//
// That makes the calling code more uniform across platforms.
//

HRESULT NvResetEvent(HDRVEVENT hEvent)               { return STATUS_WAIT_0; }
HRESULT NvSetEvent(HDRVEVENT hEvent)                 { return STATUS_WAIT_0; }
HRESULT NvWaitEvent(HDRVEVENT hEvent, DWORD timeout) { return STATUS_WAIT_0; }


LPPROCESSINFO pmGetProcess(GLOBALDATA *pDriverData, DWORD processID)
{
	if (pDriverData->lpProcessInfoHead == NULL) {
		pmAddProcess(pDriverData, processID);
	}

    return(pDriverData->lpProcessInfoHead);
}
   
BOOL pmAddProcess(GLOBALDATA *pDriverData, DWORD processID)
{
    LPPROCESSINFO lpProcInfo;

    lpProcInfo = &(pDriverData->procInfo);

    // Make sure all event handles are NULL
    memset(lpProcInfo,0,sizeof(*lpProcInfo));

    lpProcInfo->lpNext      = NULL;
    lpProcInfo->dwProcessID = processID;

    pDriverData->lpProcessInfoHead = lpProcInfo;
    return TRUE;
}

BOOL pmDeleteProcess(DWORD processID)
{
    return TRUE;
}

void pmDeleteAllProcesses(GLOBALDATA *pDriverData)
{
    return;
}

#endif // OS determination
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvPusher.cpp ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvPusher.cpp
//      routines for creating, destroying, and interacting with a push buffer
//
// **************************************************************************
//
//  History:
//      Ben DeWaal              07Apr1999         original code
//      Craig Duttweiler        05Apr2000         cleanup, consolidation,
//                                                and C++'ification
//
// **************************************************************************

// #define LOG_GETPUT

#if (NVARCH >= 0x04)

#include "nvprecomp.h"
#pragma hdrstop

#ifdef _PC_CAPTURE
HANDLE hPusherFileBinary;
HANDLE hPusherFileAscii;
BOOL   bPusherCapture = FALSE;
#endif

#if IS_WINNT4
/*
 * Map System Memory Allocation to display driver functions.  Ignore heap-create/destroy.
 */
#define HeapCreate(nop, nop1, nop2)       (!NULL)
#define HeapDestroy(heap)                 (TRUE)
#define HeapAlloc(nop, nop1, size)            EngAllocMem(FL_ZERO_MEMORY, (size), ALLOC_TAG)
#define HeapFree(nop, nop1, ptr)              { \
    if (ptr != NULL)            \
    {                           \
    EngFreeMem((ptr));          \
    }                           \
}
#endif

//---------------------------------------------------------------------------

#ifdef LOG_GETPUT
// Store put/get/time

#define MAX_INDEX 25000

DWORD dwGet[MAX_INDEX];
DWORD dwPut[MAX_INDEX];
LARGE_INTEGER dwTime[MAX_INDEX];
DWORD dwIndex = 0;

void SaveData(void)
{
    static int FileNum = 0;
    char buff[128];

    nvSprintf (buff, "GPData%02d.txt", FileNum);
    FileNum++;
    HANDLE hFile = NvCreateFile(buff, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD dwWritten;
    LARGE_INTEGER dwFreq;
    QueryPerformanceFrequency(&dwFreq);
    nvSprintf (buff, "%9s %8s %8s Freq = %u\n", "Time", "Get", "Put", dwFreq.LowPart);
    NvWriteFile (hFile, buff, nvStrLen(buff), &dwWritten, NULL);
    for(DWORD i = 0; i < dwIndex; i++) {
        nvSprintf (buff, "%9u %08u %08u\n", dwTime[i].LowPart, dwGet[i], dwPut[i]);
        WriteFile (hFile, buff, nvStrLen(buff), &dwWritten, NULL);
    }
    NvCloseHandle(hFile);
    dwIndex = 0;
    _asm int 3
}

#define STORE_GETPUT()                                                                              \
{                                                                                                   \
    DWORD dwHWGet = _pdwHWGet;                                                                      \
    dwGet[dwIndex] = dwHWGet;                                                                       \
    dwPut[dwIndex] = m_dwPutLast - m_dwBase;                                                        \
    QueryPerformanceCounter((LARGE_INTEGER*)&dwTime[dwIndex]);                                      \
    dwIndex++;                                                                                      \
    if (dwIndex == MAX_INDEX) {                                                                     \
        SaveData();                                                                                 \
    }                                                                                               \
}

#endif // LOG_GETPUT

//---------------------------------------------------------------------------

// pusher debug helpers

#ifdef _PC_BREAK
DWORD dwPutOffsetBreak = ~0;
#endif //_PC_BREAK
#ifdef _PC_CHECK
DWORD dwPusherCount = ~0;
#endif //_PC_CHECK

//---------------------------------------------------------------------------
// public functions
//---------------------------------------------------------------------------

// CPushBuffer::allocate

BOOL CPushBuffer::allocate
(
    DWORD dwChannel
)
{
    setChannel (dwChannel);

    if (allocateMemory()     &&
        allocateContextDMA() &&
        openChannel())
    {
        m_dwFlags |= PB_FLAG_VALID;
        resetPut();
        return (TRUE);
    }

    return (FALSE);
}

//---------------------------------------------------------------------------

// CPushBuffer::free
// returns TRUE on success, FALSE on failure

BOOL CPushBuffer::free
(
    void
)
{
#if IS_WIN9X
    nvAssert (!global.b16BitCode);
#endif

    closeChannel();
    freeContextDMA();
    freeMemory();

    // mark buffer as being invalid
    m_dwFlags &= ~PB_FLAG_VALID;

    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::start
// kicks off the current push buffer. if bRequired is FALSE then this
// routine will only kick it off when there is NVPUSHER_MINIMUM bytes
// in the buffer

void CPushBuffer::start
(
    BOOL bRequired
)
{
#ifdef _PC_CHECK
#if IS_WIN9X
    if (!global.b16BitCode)
#endif
    {
        if (!isValid()) {
            DPF ("caught attempt to start an invalid push buffer.");
            __asm int 3;
            return;
        }
        if (dwPusherCount != ~0) {
            DPF ("adjust() or inc() not called, data lost.");
            DPF ("F10 to return to caller.");
            __asm int 3;
            return;
        }
    }
#endif //_PC_CHECK

    // return if nothing has been buffered
    if (m_dwPutLast == m_dwPut) {
        return;
    }

    // handle optional case
    if (!bRequired) {
        if ((m_dwPut - m_dwPutLast) < NVPUSHER_MINIMUM) {
            return;
        }
    }

    // handle proper kick-off
    kickOff();
}

//---------------------------------------------------------------------------

// CPushBuffer::flush
// kicks off the push buffer and spin until it is consumed. If bWaitForHWIdle
// is specified, we also wait for the HW to go idle afterwards

void CPushBuffer::flush
(
    BOOL  bWaitForHWIdle,
    DWORD dwMode
)
{
    // kick off buffer
    start (TRUE);

    //
    // capture driver
    //
#ifdef CAPTURE
    if (!global.b16BitCode)
    {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_SYNC3 sync;
            sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            sync.dwExtensionID        = CAPTURE_XID_SYNC3;
            sync.dwType               = bWaitForHWIdle ? CAPTURE_SYNC3_TYPE_CHIPIDLE : CAPTURE_SYNC3_TYPE_ZEROCOMMANDS;
            sync.dwCtxDMAHandle       = 0;
            sync.dwOffset             = 0;
            sync.dwValue              = 0;
            captureLog (&sync,sizeof(sync));
        }
    }
#endif

    // wait for idle
            #ifdef NV_PROFILE_PUSHER
            if (!global.b16BitCode) {
                NVP_START(NVP_T_FLUSH);
            }
            #endif

    switch (dwMode) {

        case FLUSH_WITH_DELAY:
            while (!isIdle(bWaitForHWIdle)) {
                nvSpin(_systemInfo.dwSpinLoopCount);
            }
            break;

        case FLUSH_HEAVY_POLLING:
            while (!isIdle(bWaitForHWIdle));
            break;

        default:
            DPF ("unknown flush mode");
            dbgError("NV Error!");
            break;

    }  // switch

            #ifdef NV_PROFILE_PUSHER
            if (!global.b16BitCode) {
                NVP_STOP(NVP_T_FLUSH);
                nvpLogTime (NVP_T_FLUSH,nvpTime[NVP_T_FLUSH]);
            }
            #endif
}

//---------------------------------------------------------------------------

// CPushBuffer::resetPut
// called to initialize a new, empty push buffer.
// sets up the put pointer, get pointer, and threshold

void CPushBuffer::resetPut
(
    void
)
{
#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("invalid push buffer in resetPut");
        __asm int 3;
        return;
    }
    if (dwPusherCount != ~0) {
        DPF ("Pusher not kicked off, data lost.");
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
#endif //_PC_CHECK

    // initialize to base temporarily to make CPushBuffer::calcThreshold happy
    m_dwPut = m_dwPutLast = m_dwBase;
    calcThreshold();
    // set put to get since technically, there is no strict guarantee
    // that the get pointer starts out at the beginning of a new buffer
    m_dwPut = m_dwPutLast = m_dwGet;

#ifdef _PC_PRINT
    DPF ("CPushBuffer::resetPut: base = %08x",m_dwBase);
    DPF ("                       put  = %08x",m_dwPut);
    DPF ("                       get  = %08x",m_dwGet);
#endif
}

//---------------------------------------------------------------------------

// CPushBuffer::isIdle
// returns TRUE if the push buffer is idle

BOOL CPushBuffer::isIdle
(
    BOOL bCheckHWAlso
)
{
    // pDriverData, dwFullScreenDOSStatus and the flag value are not available
    // on NT4.
#if !IS_WINNT4
    // degenerate case: monitor shutdown could occur with dma pending
    if (pDriverData->dwFullScreenDOSStatus & FSDOSSTATUS_RECOVERYNEEDED_D3D) {
        return TRUE;
    }
#endif

    // is push buffer consumed?
    // STORE_GETPUT();
    m_dwGet = m_dwBase + _pdwHWGet;
    if (m_dwGet != m_dwPutLast) {
        return FALSE;
    }

    // is HW idle?
    if (bCheckHWAlso) {

        // check for stuff pending in the cache
        // (DCT clipping test fails on Win2K dual CPU without this test)
        if (((_ffCache1Push1  & 0x1f) == _dmaPusherChannelIndex) &&
            ((_ffCache1Status & 0x10) == 0)) {
            // we own the cache and it's got stuff in it
            return FALSE;
        }

        // check the graphics engine itself
        if (_pbHWBusy) {
            return FALSE;
        }

    }

    // idle
    return TRUE;
}

//---------------------------------------------------------------------------

// CPushBuffer::waitForOtherChannels
// waits for other channels to go idle before returning

void CPushBuffer::waitForOtherChannels
(
    void
)
{
    volatile DWORD *npNvBase;
    DWORD *pDW;

#ifdef _PC_CHECK
#if IS_WIN9X
    if (!global.b16BitCode)
#endif
    {
        if (!_pDriverData) {
            DPF ("pDriverData not yet initialized in CPushBuffer::waitForOtherChannels.");
            __asm int 3;
            return;
        }
    }
#endif //_PC_CHECK
#ifdef CAPTURE
    if (!global.b16BitCode) {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            CAPTURE_SYNC3 sync;
            sync.dwJmpCommand         = CAPTURE_JMP_COMMAND;
            sync.dwExtensionSignature = CAPTURE_EXT_SIGNATURE;
            sync.dwExtensionID        = CAPTURE_XID_SYNC3;
            sync.dwType               = CAPTURE_SYNC3_TYPE_CHANNELS;
            sync.dwCtxDMAHandle       = 0;
            sync.dwOffset             = 0;
            sync.dwValue              = 0;
            captureLog (&sync,sizeof(sync));
        }
    }
#endif

    m_dwFlags &= ~PB_FLAG_CHANNEL_SYNC;

    npNvBase = _nvBaseFlat;
    pDW      = _pCurrentChannelID;

    if (*pDW != _dmaPusherChannelIndex)
    {
        *pDW = _dmaPusherChannelIndex;
        while ((npNvBase[(NV_PFIFO_DMA >> 2)] & (~(1<<_dmaPusherChannelIndex))) != 0);
        if ((npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT)
         && ((npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & 0x1F) != (WORD)_dmaPusherChannelIndex))
        {
            while ((npNvBase[NV_PFIFO_CACHE1_DMA_PUSH >> 2] & NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY_BIT) == 0);
        }
    }
}

//---------------------------------------------------------------------------

// CPushBuffer::makeSpace
// makes space for at least dwCount words in the push buffer

void CPushBuffer::makeSpace
(
    DWORD dwCount
)
{
    BOOL  bFirst = TRUE;
    DWORD dwMax  = m_dwBase                     // start
                 + m_dwSize                     // + base         -> end
                 - NVPUSHER_THRESHOLD_SIZE * 4  // - assumed      -> largest allowed end (with zero space)
                 - dwCount * 4;                 // - dwCount * 4  -> largest allowed end (with dwCount words)

#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("caught attempt to make space in an invalid push buffer.");
        __asm int 3;
        return;
    }
    if (dwPusherCount != ~0) {
        DPF ("Pusher not kicked off, data lost.");
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
#endif //_PC_CHECK

            #ifdef NV_PROFILE_PUSHER
            NVP_START(NVP_T_MAKESPACE);
            #endif
    // see if this size can fit between put and end of buffer
    if (m_dwPut >= dwMax) {
        // wrap around
        wrapAround();
#ifdef _PC_CHECK
        dwPusherCount = ~0; // reset
#endif //_PC_CHECK
        calcThreshold();
        bFirst = FALSE;
    }

    // wait until threshold is far enough away
    dwCount *= 4; // words -> bytes
    while (m_dwThreshold < (m_dwPut + dwCount)) {
        if (bFirst) {
            bFirst = FALSE;
        }
        else {
            nvSpin(_systemInfo.dwSpinLoopCount);
        }
        calcThreshold();
    }
            #ifdef NV_PROFILE_PUSHER
            NVP_STOP(NVP_T_MAKESPACE);
            nvpLogTime (NVP_T_MAKESPACE,nvpTime[NVP_T_MAKESPACE]);
            #endif
}

//---------------------------------------------------------------------------

#ifdef _NO_INLINE

// CPushBuffer::push
// push dwData at put + offset (in words)

void CPushBuffer::push
(
    DWORD dwOffset,
    DWORD dwData
)
{
#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("caught attempt to push data to an invalid push buffer.");
        __asm int 3;
        return;
    }
    if (dwOffset) {
        dwPusherCount ++;
        if (dwPusherCount != dwOffset) {
            DPF ("CPushBuffer::push: gap in offset sequence.");
            DPF ("ZAP or F5 to continue.");
            __asm int 3;
        }
    }
    else {
        dwPusherCount = 0;
        //memset ((void*)m_dwPut,0x55,NVPUSHER_THRESHOLD_SIZE * 4);
    }
#endif
#ifdef _PC_BREAK
    if ((m_dwPut - m_dwBase + dwOffset * 4) == dwPutOffsetBreak) {
        DPF ("CPushBuffer::push: desired put reached.");
        DPF ("ZAP or F5 to continue.");
        __asm int 3;
    }
#endif //_PC_BREAK

    ((DWORD*)m_dwPut)[dwOffset] = dwData;
}

//---------------------------------------------------------------------------

// CPushBuffer::adjust
// advance put by dwCount words

BOOL CPushBuffer::adjust
(
    DWORD dwCount
)
{
    BOOL bKickedOff;

#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("caught attempt to adjust an invalid push buffer.");
        __asm int 3;
        return (FALSE);
    }

    if (dwCount) {

        // check for push / adjust mismatch
        if (dwCount != (dwPusherCount + 1)) {
            dwPusherCount = ~0; // reset
            DPF ("CPushBuffer::adjust: incorrect amount adjusted.");
            DPF ("                     current object address: %08x",m_dwPut);
            DPF ("F10 to return to caller.");
            __asm int 3;
            return (FALSE);
        }

        else {
            // check for proper object size
            //  complete objects must be pushed since this may kick-off unexpectedly
            DWORD dwAddr = m_dwPut;
            DWORD dwCnt  = dwCount;

            while (dwCnt) {
                // get push buffer data
                DWORD dwValue = *(DWORD*)dwAddr;

                // process JMP command
                if (dwValue & 0x20000000) {
                    // extract jmp dest
                    DWORD dwDest = dwAddr & 0x1fffffff;
                    // test valid
                    //  - for now we assume only zero to be valid since we do not
                    //    jump anywhere else. Later we can make the test simply check
                    //    that dwDest lies within limits
                    if (dwDest > 0) {// (dwDest < m_dwSize)
                        dwPusherCount = ~0; // reset
                        DPF ("CPushBuffer::adjust: JUMP command out of range.");
                        DPF ("                     JUMP target    : %08x", dwDest);
                        DPF ("                     object address : %08x", dwAddr);
                        DPF ("F10 to return to caller.");
                        __asm int 3;
                        return (FALSE);
                    }
                    // apply jump
                    dwCnt  -= 1;
                    dwAddr  = m_dwBase + dwDest;
                }

                else if (dwValue & 0x00000002) {
                    // call command. just skip over it
                    // (maybe later we can be fancy by sanity checking the function)
                    dwCnt  -= 1;
                    dwAddr += 4;
                }

                else {
                    DWORD dwAdd = 1 + ((dwValue >> 18) & 0x7f);  // data count + 1 for the method itself
                    dwCnt -= dwAdd;
                    if (dwCnt > dwCount) { // includes going negative
                        dwPusherCount = ~0; // reset
                        DPF ("CPushBuffer::adjust: partial or incorrect object pushed.");
                        DPF ("                     object address: %08x", dwAddr);
                        DPF ("F10 to return to caller.");
                        __asm int 3;
                        return (FALSE);
                    }
                    dwAddr += dwAdd * 4;
                }
            }
        }
    }  // if (dwCount)...

    dwPusherCount = ~0; // reset
#endif

    // increment put
    inc (dwCount);

    // spin until we have enough space in the push buffer
    bKickedOff = getSpace();

#ifdef _PC_FLUSH_ON_ADJUST
    flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
#endif // _PC_FLUSH_ON_ADJUST

    return (bKickedOff);
}

//---------------------------------------------------------------------------

// CPushBuffer::inc
// increments put pointer

void CPushBuffer::inc
(
    DWORD dwCount
)
{
#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("caught attempt to increment an invalid push buffer.");
        __asm int 3;
        return;
    }
    DWORD dwDest = m_dwPut + (dwCount << 2);
    /*
    -- DO NOT REMOVE -- tests for put running past get but slows down too much
    DWORD dwGet = m_dwBase + _pdwHWGet;
    if (dwGet > m_dwPut)
    {
        if (dwDest >= dwGet)
        {
            DPF ("CPushBuffer::inc: increment past end of push buffer (current get).");
            DPF ("                  current put address: %08x",m_dwPut);
            DPF ("F10 to return to caller.");
            __asm int 3;
            return;
        }
    }
    */
    if (dwDest >= m_dwBase + m_dwSize) {
        DPF ("CPushBuffer::inc: increment past end of push buffer (top).");
        DPF ("                  current put address: %08x", m_dwPut);
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
    dwPusherCount = ~0; // reset
#endif //_PC_CHECK
    m_dwPut += (dwCount << 2);
}

#endif  // _NO_INLINE

//---------------------------------------------------------------------------
// private functions
//---------------------------------------------------------------------------

// CPushBuffer::setBase
// set the pusher base.
// put & get are discarded, leaving the push buffer in an invalid state;
// resetPut must be called subsequently to re-initialize things

void CPushBuffer::setBase
(
    DWORD dwBase
)
{
#ifdef _PC_CHECK
    if (dwPusherCount != ~0) {
        DPF ("Pusher not kicked off, data lost.");
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
#endif //_PC_CHECK

    m_dwBase      = dwBase;
    m_dwGet       = 0;
    m_dwPut       = 0;
    m_dwPutLast   = 0;
    m_dwThreshold = 0;

#ifdef _PC_PRINT
    DPF ("CPushBuffer::setBase: base = %08x", dwBase);
#endif
}

//---------------------------------------------------------------------------

// CPushBuffer::setSize
// set the pusher size.
// put & get are discarded, leaving the push buffer in an invalid state;
// resetPut must be called subsequently to re-initialize things

void CPushBuffer::setSize
(
    DWORD dwSize
)
{
#ifdef _PC_CHECK
    if (!_pDriverData) {
        DPF ("pDriverData not yet initialized in CPushBuffer::setSize.");
        __asm int 3;
        return;
    }
    if (dwPusherCount != ~0) {
        DPF ("Pusher not kicked off, data lost.");
        DPF ("F10 to return to caller.");
        __asm int 3;
        return;
    }
#endif //_PC_CHECK

    m_dwSize      = dwSize;
    m_dwGet       = 0;
    m_dwPut       = 0;
    m_dwPutLast   = 0;
    m_dwThreshold = 0;

#ifdef _PC_PRINT
    DPF ("CPushBuffer::setSize: size = %08x",dwSize);
#endif
}

//---------------------------------------------------------------------------

// CPushBuffer::allocateMemory

BOOL CPushBuffer::allocateMemory
(
    void
)
{
    // check to see if the push buffer was already allocated (probably via updateNonLocalHeap)
    if (!m_dwBase) {
        // Ensure size of pushbuffer is initialized properly. Previously done in
        // DriverInit, but under NT DriverInit is only called once when GLOBALDATA
        // is created. Push buffer size is being reset on every mode change.
        setSize (_systemInfo.dwRecommendedPushBufferSize);

        if ((_pDriverData->regPBLocale == NV_REG_SYS_PB_LOCATION_VIDEO) ||
            (_systemInfo.dwPerformanceStrategy & PS_PUSH_VID)) {

            // allocate push buffer in video memory
            DWORD dwStatus, dwVidMemBase;
            NVHEAP_ALLOC (dwStatus, dwVidMemBase, m_dwSize, TYPE_IMAGE);
            nvAssert (dwStatus == 0);
            setBase (VIDMEM_ADDR(dwVidMemBase));

            m_dwHeap &= ~(CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI);
            m_dwHeap |=  CSimpleSurface::HEAP_VID;

        }

#if (!IS_WINNT4)	// AGP pushbuffer is not (yet) available on WinNT4

        else if (((_pDriverData->regPBLocale == NV_REG_SYS_PB_LOCATION_AGP) ||
                  (_pDriverData->regPBLocale == NV_REG_SYS_PB_LOCATION_DEFAULT))
                 &&
                 (_pDriverData->GARTLinearBase != NULL)) {

            // allocate push buffer from AGP memory
#ifdef NV_AGP			
            DWORD dwAgpAddr = (DWORD)nvAGPAlloc(m_dwSize);
            if (dwAgpAddr == ERR_DXALLOC_FAILED) {
                DPF ("CPushBuffer::allocateMemory: warning - failed to allocate required");
                DPF ("                             amount of AGP mem for pushbuffer!");
            }
            else {
                setBase (dwAgpAddr);
            }
#else
            DWORD dwAgpOffset = (DWORD)nvAGPAlloc(m_dwSize);
            if (dwAgpOffset == ERR_DXALLOC_FAILED) {
                DPF ("CPushBuffer::allocateMemory: warning - failed to allocate required");
                DPF ("                             amount of AGP mem for pushbuffer!");
            }
            else {
                setBase (AGPMEM_ADDR(dwAgpOffset));
            }

            if (!m_dwBase) {
                // mark AGP as invalid so that further allocations go to PCI memory
#ifdef WINNT
                NvWin2KUnmapAgpHeap(_pDriverData);
#endif // !WINNT
                _pDriverData->GARTLinearBase = 0;
            }
#endif

            m_dwHeap &= ~(CSimpleSurface::HEAP_PCI | CSimpleSurface::HEAP_VID);
            m_dwHeap |=  CSimpleSurface::HEAP_AGP;
        }
#endif // NT4

        if (!m_dwBase) {
            // we still haven't allocated a push buffer. this is either because we failed to do so
            // or because we didn't want it in video / AGP. either way, try now to put it in PCI

            if (m_dwPCIHeapHandle == 0) {

                // not allocated for PCI yet
                m_dwPCIHeapHandle = (DWORD) HeapCreate (HEAP_SHARED, m_dwSize, 0);
                m_dwPCIHeapBase   = (DWORD) HeapAlloc  ((HANDLE)m_dwPCIHeapHandle, HEAP_ZERO_MEMORY, m_dwSize);

                if (m_dwPCIHeapBase) {
                    // align things properly. both the base and limit need to be aligned to make nv10 happy.
                    DWORD dwAlignedBase  = (m_dwPCIHeapBase + NV_TEXTURE_OFFSET_ALIGN) & ~NV_TEXTURE_OFFSET_ALIGN;
                    DWORD dwAlignedLimit = (m_dwPCIHeapBase + m_dwSize) & ~NV_TEXTURE_OFFSET_ALIGN;
                    DWORD dwAlignedSize  = dwAlignedLimit - dwAlignedBase;
                    setBase (dwAlignedBase);
                    setSize (dwAlignedSize);
                    m_dwHeap &= ~(CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_VID);
                    m_dwHeap |=  CSimpleSurface::HEAP_PCI;
                } else {
                    // may see system alloc failure in win2k + 1G RAM
                    HeapDestroy((HANDLE)m_dwPCIHeapHandle);
                    m_dwPCIHeapHandle = 0;

                    // last resort, allocate push buffer in video memory
                    DWORD dwStatus, dwVidMemBase;
                    NVHEAP_ALLOC (dwStatus, dwVidMemBase, m_dwSize, TYPE_IMAGE);
                    nvAssert (dwStatus == 0);
                    setBase (VIDMEM_ADDR(dwVidMemBase));

                    m_dwHeap &= ~(CSimpleSurface::HEAP_AGP | CSimpleSurface::HEAP_PCI);
                    m_dwHeap |=  CSimpleSurface::HEAP_VID;
                }
            }
            else {
                DPF ("what the heck does this mean??");
                dbgError("NV Error!");
            }

        }

    }  // !m_dwBase

    return (m_dwBase ? TRUE : FALSE);
}

//---------------------------------------------------------------------------

// CPushBuffer::freeMemory

BOOL CPushBuffer::freeMemory
(
    void
)
{
    if (m_dwBase) {

#if (!IS_WINNT4)	// AGP pushbuffer is not (yet) available on WinNT4

        if (_pDriverData->GARTLinearBase && (m_dwHeap & CSimpleSurface::HEAP_AGP)) {
            nvAGPFree((void*)getfpVidMem());
        }
        else 
#endif // NT4
		if (m_dwHeap & CSimpleSurface::HEAP_VID)
		{
            NVHEAP_FREE (getfpVidMem());
        }
        else {
            // DMA push buffer in system mem
            HeapFree    ((HANDLE) m_dwPCIHeapHandle, 0, (PVOID) m_dwPCIHeapBase);
            HeapDestroy ((void*) m_dwPCIHeapHandle);
            m_dwPCIHeapHandle = m_dwPCIHeapBase = 0;
        }

        setBase (0);

    }

    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::allocateContextDMA

BOOL CPushBuffer::allocateContextDMA
(
    void
)
{
    NvU32 status;

    if (!m_dwContextDMASize) {
        status = NvRmAllocContextDma (_dwRootHandle,
                                 m_dwContextDMA,
                                 NV01_CONTEXT_DMA,
                                 DRF_DEF(OS03, _FLAGS, _ACCESS, _READ_ONLY) |
                                 DRF_DEF(OS03, _FLAGS, _LOCKED, _ALWAYS) |
                                 DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
                                 (PVOID) m_dwBase,
                                 m_dwSize - 1);
        if (status!=0)
        {
            DPF("Failed... Status = 0x%08x",status);
            return(FALSE);
        }
        m_dwContextDMASize = m_dwSize;
    }
    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::freeContextDMA

BOOL CPushBuffer::freeContextDMA
(
    void
)
{
    if (m_dwContextDMASize) {
        NvRmFree (_dwRootHandle, _dwRootHandle, m_dwContextDMA);
        m_dwContextDMASize = 0;
    }
    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::openChannel

BOOL CPushBuffer::openChannel
(
    void
)
{
    if (!m_dwControlDMA) {
        DWORD dwChannelFlavor = (_systemInfo.dwNVClasses1 & NVCLASS1_206E_CHANNELDMA) ?
                                    NV20_CHANNEL_DMA :
                                    (_systemInfo.dwNVClasses1 & NVCLASS1_006E_CHANNELDMA) ?
                                        NV10_CHANNEL_DMA :
                                        NV04_CHANNEL_DMA;
        if (NvRmAllocChannelDma (_dwRootHandle, _hDevice,
                                 m_dwChannel, dwChannelFlavor, 0,
                                 m_dwContextDMA, 0,
                                 (PVOID*)&m_dwControlDMA)) {
            return(FALSE);
        }
    }
    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::closeChannel

BOOL CPushBuffer::closeChannel
(
    void
)
{
    if (m_dwControlDMA) {
        NvRmFree (_dwRootHandle, _hDevice, m_dwChannel);
        m_dwControlDMA = 0;
    }
    return (TRUE);
}

//---------------------------------------------------------------------------

// CPushBuffer::getfpVidMem
// returns the FLATPTR base of the push buffer

FLATPTR CPushBuffer::getfpVidMem
(
    void
)
{
#ifdef WINNT
    if (!m_dwBase) { return (NULL); }
#ifndef NV_AGP
    if (m_dwHeap & CSimpleSurface::HEAP_AGP) {
        return (m_dwBase - _pDriverData->GARTLinearBase);
    }
#endif
    else if (m_dwHeap & CSimpleSurface::HEAP_VID) {
#if IS_WINNT4
        return (m_dwBase - (ULONG) m_ppdev->pjFrameBufbase);
#else
        return (m_dwBase - (ULONG) ppdev->pjFrameBufbase);
#endif
    }
    else
#endif // WINNT
    return (m_dwBase);
}


//---------------------------------------------------------------------------

// CPushBuffer::syncAndFlushWC
// do a WC flush

inline void CPushBuffer::syncAndFlushWC (void)
{
    waitForOtherChannels();

    // wait for flip to complete if the flag is set
    if (m_dwFlags & PB_FLAG_FLIP_SYNC) {
#if IS_WINNT4
        // Flip sync is not implemented on NT4 -- need to port getFrameStatus...
        nvAssert(FALSE);
#else
        while (getFlipStatus (m_dwFlipSurfaceAddr, m_dwFlipSurfaceFlags) != DD_OK) {
            nvSpin(_systemInfo.dwSpinLoopCount);
        }
        m_dwFlags &= ~PB_FLAG_FLIP_SYNC;
#endif
    }

    // flush WC (Write Combine - not Water Closet)
    if (_hasSFENCE) {
        __asm _emit 0x0f
        __asm _emit 0xae
        __asm _emit 0xf8 // sfence
    }
    else {
        __asm mov edx,0x3d0
        __asm xor eax,eax
        __asm out dx,al
    }
}

//---------------------------------------------------------------------------

// CPushBuffer::kickOff
// writes put

void CPushBuffer::kickOff
(
    void
)
{
    DWORD dwPutOffset;

#ifdef _PC_PRINTPUT
#if IS_WIN9X
    if (!global.b16BitCode)
#endif
        {
        DPF ("CPushBuffer::kickOff: put = %08x (rel %08x)", m_dwBase + dwPutOffset, dwPutOffset);
    }
#endif

#ifdef _PC_CHECK
#if IS_WIN9X
    if (!global.b16BitCode)
#endif
        {
        if (!validate (m_dwPutLast, m_dwPut)) {
            DPF ("CPushBuffer::kickOff: warning - put was not written due to parse error.");
            return;
        }
    }
#endif

#if 0
    {
        static HANDLE h = 0;

        static DWORD totl = 0;
        static DWORD last = 0;
        if (!last) last = GetTickCount();
        DWORD now = GetTickCount();

        totl += (m_dwPut > m_dwPutLast)
                ? (m_dwPut - m_dwPutLast)
                : 0;

        //if ((now - last) > 50)
        {
            DWORD x = now - last;
            DWORD y = totl;
            totl = 0;

            last = now;

            if (!h) {
                h = NvCreateFile("c:\\data.txt",GENERIC_WRITE,0,0,OPEN_ALWAYS,0,0);
                if (h == INVALID_HANDLE_VALUE) {
                    h = 0;
                }
                else {
                    SetFilePointer (h,0,NULL,FILE_END);
                }
            }

            if (h) {
                char sz[256];
                wsprintf (sz,"%d\t%d\r\n",x,y);
                NvWriteFile (h,sz,strlen(sz),&x,NULL);
            }

            static DWORD t = 0;
            if (!t) t = GetTickCount();
            DWORD n = GetTickCount();

            if ((n - t) > 1000) {
                t = n;
                NvCloseHandle (h);
                h = 0;
            }
        }
    }
#endif // 0

    // write put & update last put address
    syncAndFlushWC();

#ifdef CAPTURE
    if (!global.b16BitCode) {
        if (getDC()->nvD3DRegistryData.regCaptureEnable & D3D_REG_CAPTUREENABLE_RECORD) {
            if (m_dwPutLast < m_dwPut) {
                captureLog ((void*)m_dwPutLast, m_dwPut - m_dwPutLast);
            }
        }
    }
#endif

    dwPutOffset = m_dwPut - m_dwBase;
    m_dwPutLast = m_dwPut;

//    STORE_GETPUT();

            #ifdef NV_PROFILE_PUSHER
            if (!global.b16BitCode) {
                DWORD dwGetOffset = _pdwHWGet;
                DWORD dwPending;
                if (dwGetOffset > dwPutOffset) {
                    dwPending = m_dwSize - (dwGetOffset - dwPutOffset);
                }
                else {
                    dwPending = dwPutOffset - dwGetOffset;
                }
                // static int   first = 1;
                // static DWORD dwLast;
                // if (first)
                // {
                    // first = 0;
                // }
                // else
                // {
                    // NVP_STOP(NVP_C_VELOCITY);
                // }
                // DWORD dwNow = dwGetOffset;
                // double vel  = double(int(dwNow) - int(dwLast)) * 1000.0 * double(global.dwProcessorSpeed) / double(nvpTime[NVP_C_VELOCITY]);
                // if (vel < 0) vel = 0;
                // if (vel > 10000) vel = 10000;
                // nvpLogCount (NVP_C_VELOCITY,DWORD(vel));

                 if (nvpGetLogPusher())
                 {
                    nvpLogCount (NVP_C_PENDINGSIZE,dwPending);
                    
                 }
                // nvpLogCount (NVP_C_PUT,dwPutOffset);
                // nvpLogCount (NVP_C_GET,dwGetOffset);
                // dwLast = dwNow;
                // NVP_START(NVP_C_VELOCITY);
            }
            #endif  // NV_PROFILE_PUSHER

    _pdwHWPut = dwPutOffset;

            #ifdef NV_PROFILE
            if (!global.b16BitCode) {
            #ifdef NV_PROFILE_PUSHER
                if (nvpGetLogPusher())
            #endif
                nvpLogEvent (NVP_E_PUT);
            }
            #endif  // NV_PROFILE

//    memset((void*)m_dwPutLast, 0xFA, (NVPUSHER_THRESHOLD_SIZE - 1)*4);
}

//---------------------------------------------------------------------------

// CPushBuffer::getSpace
// spins until we have space in push buffer

BOOL CPushBuffer::getSpace
(
    void
)
{
    #ifdef NV_PROFILE_PUSHER
    NVP_START(NVP_T_ADJUST);
    #endif

    BOOL bFirst     = TRUE;
    BOOL bKickedOff = FALSE;

    while (m_dwPut >= m_dwThreshold) {
        if (bFirst) {
            bFirst = FALSE;
        }
        else {
            nvSpin(_systemInfo.dwSpinLoopCount);
        }
        bKickedOff |= calcThreshold();
    }

    #ifdef NV_PROFILE_PUSHER
    NVP_STOP(NVP_T_ADJUST);
    nvpLogTime (NVP_T_ADJUST,nvpTime[NVP_T_ADJUST]);
    #endif

    return (bKickedOff);
}

//---------------------------------------------------------------------------

// CPushBuffer::calcThreshold
// recalculate pusher threshold

BOOL CPushBuffer::calcThreshold
(
    void
)
{
    BOOL  bKickedOff;
    DWORD dwMax;

#ifdef _PC_CHECK
    if (!isValid()) {
        DPF ("invalid push buffer in CPushBuffer::calcThreshold");
        __asm int 3;
        return (FALSE);
    }
#endif //_PC_CHECK

    dwMax = m_dwBase + m_dwSize - (4*NVPUSHER_THRESHOLD_SIZE);

    // have we crossed the largest possible threshold?
    if (m_dwPut >= dwMax) {
        // wrap push buffer around
        wrapAround();
#ifdef _PC_CHECK
        dwPusherCount = ~0; // reset
#endif //_PC_CHECK
        bKickedOff    = TRUE;
    }

    // read get pointer
//    STORE_GETPUT();
    m_dwGet = m_dwBase + _pdwHWGet;

    // figure out who is chasing whom
    if (m_dwPut >= m_dwGet) {
        // get is chasing put -- .....G*******P....T.
        m_dwThreshold = dwMax;
    }
    else {
        // put is chasing get -- *******P...T.G*****.
        // note that the threshold can actually be less that the push buffer base. this is okay.
        m_dwThreshold = m_dwGet - (4*NVPUSHER_THRESHOLD_SIZE);
    }

    return bKickedOff;
}

//---------------------------------------------------------------------------

// CPushBuffer::wrapAround
// wraps pushbuffer around. This is the only place where we can get put
// to chase get.

void CPushBuffer::wrapAround
(
    void
)
{
            #ifdef NV_PROFILE_PUSHER
            NVP_START(NVP_T_WRAPAROUND);
            #endif

    // in the case where get already points to the push buffer base
    // we have to first get it going before we can write put to the
    // base again. This is because writing put to the same value
    // as get will do nothing instead of running through the whole
    // push buffer like we want it to.
    if (m_dwGet == m_dwBase)
    {
        // check get again
        // STORE_GETPUT();
        m_dwGet = m_dwBase + _pdwHWGet;
        if (m_dwGet == m_dwBase) {
            // kick off buffer
            kickOff();
            // wait until get has progressed at least one word
            while (m_dwGet == m_dwBase) {
                // STORE_GETPUT();
                m_dwGet = m_dwBase + _pdwHWGet;
            }
        }
    }

    // wait for get to wrap around

    // the following line used to be:
    // while ((m_dwGet > m_dwPutLast) && (m_dwGet != m_dwBase)) {
    // but i'm almost certain the second check is meaningless. dwGet can't possibly
    // be both ==base and >putlast. this would imply (putlast < base)  -- CRD 16jun00
    while (m_dwGet > m_dwPutLast) {
        nvSpin(_systemInfo.dwSpinLoopCount);
        // STORE_GETPUT();
        m_dwGet = m_dwBase + _pdwHWGet;
    }

#ifdef CAPTURE
    // if capturing, write out the tail end of the push buffer now,
    // since we won't do it after issuing the jump and resetting put
    kickOff();
#endif

    // write the jump and start puller
    push (0, NVPUSHER_JUMP(0));
    m_dwPut = m_dwBase;
    m_dwWrapCount ++;
    kickOff();

            #ifdef NV_PROFILE_PUSHER
            NVP_STOP(NVP_T_WRAPAROUND);
            nvpLogTime (NVP_T_WRAPAROUND,nvpTime[NVP_T_WRAPAROUND]);
            #endif
}

//---------------------------------------------------------------------------

#ifdef _PC_CHECK

// CPushBuffer::validate
// walks a push buffer and check that we have no parser or other
// common pusher errors. This is a second check, since CPushBuffer::adjust
// does a simple pass already.

BOOL CPushBuffer::validate
(
    DWORD dwStart,
    DWORD dwEnd
)
{
    DWORD dwLastAddr     = 0;
    DWORD dwLastJumpAddr = 0;
    DWORD dwAddr         = dwStart;
    DWORD dwCount        = m_dwSize; // allow 4 times the number of commands before we time out

#ifdef _PC_CAPTURE
    if (bPusherCapture) {
        DWORD dwJunk;
        char  sz[256];

        for (DWORD dwAddr = dwStart; dwAddr != dwEnd;) {
            DWORD dwMethod = *(DWORD*)dwAddr;
            dwAddr += 4;

            // save method
            NvWriteFile (hPusherFileBinary, (LPBYTE)(&dwMethod), 4, &dwJunk, 0);
            nvSprintf (sz, "%08x: method %08x ----\r\n", dwAddr, dwMethod);
            NvWriteFile (hPusherFileAscii, sz, nvStrLen(sz), &dwJunk, 0);

            if (dwMethod & 0x20000000) {
                // jmp
                dwAddr = m_dwBase + (dwMethod & 0x1fffffff);
            }
            else {
                for (DWORD dwCount = ((dwMethod & 0x1fff0000) >> 18); dwCount; dwCount--) {
                    DWORD dwData = *(DWORD*)dwAddr;
                    dwAddr += 4;
                    // save data
                    NvWriteFile (hPusherFileBinary, (LPBYTE)(&dwData), 4, &dwJunk, 0);
                    nvSprintf (sz, "%08x:   data %08x\r\n", dwAddr, dwData);
                    NvWriteFile (hPusherFileAscii, sz, nvStrLen(sz), &dwJunk, 0);
                }
            }
        }
    }
#endif

    while (dwCount && (dwAddr != dwEnd)) {

        DWORD dwCommand;

        // check if we are still in range
        if ((dwAddr < m_dwBase) || (dwAddr >= m_dwBase + m_dwSize)) {
            DPF ("CPushBuffer::validate: Pointer out of push buffer range.");
            DPF ("                       Bad address  : %08x", dwAddr);
            DPF ("                       Last address : %08x", dwLastAddr);
            DPF ("F10 to return to caller.");
            __asm int 3;
            return (FALSE);
        }

        // get command
        dwLastAddr = dwAddr;
        dwCommand = *(DWORD*)dwAddr;

        // process
        if (dwCommand & 0x00000001) {
            PF("dwCommand = %08x", dwCommand);
            PF("Invalid low-order bit");
            _asm int 3;
        }
        else if (dwCommand & 0x00000002) {
            // call command
            dwAddr += 4;
        }
        else if (dwCommand & 0x20000000) {
            // jump instruction
            dwLastJumpAddr = dwAddr;
            dwAddr = m_dwBase + (dwCommand & 0x1fffffff);
        }
        else {
#ifdef _PC_CAPTURE_METHOD_DATA
            // capture data
            parseMethod (dwAddr);
#endif
            // skip past this method header and its data
            dwAddr += 4 * (1 + ((dwCommand & ~0xe0000000) >> 18));
        }

        dwCount--;

    }

    // if we timed out then we assume the push buffer has some kind of infine loop
    //  that does not cause the pointer to go out of range but will hang
    //  or cause other failures
    if (!dwCount) {
        DPF ("CPushBuffer::validate: Validation timed out.");
        DPF ("                       Current address   : %08x", dwAddr);
        DPF ("                       Last address      : %08x", dwLastAddr);
        DPF ("                       Last JUMP address : %08x", dwLastJumpAddr);
        DPF ("F10 to return to caller.");
        __asm int 3;
        return FALSE;
    }

    return TRUE;
}

#endif //_PC_CHECK

//---------------------------------------------------------------------------

#ifdef _PC_CAPTURE_METHOD_DATA

static DWORD g_adwMax[8] = {0,0,0,0,0,0,0,0};
static DWORD g_adwState[8][0x2000 / 4]; // a whole bunch of method info

#define _SUBCHANNEL(x)          (((x) >> 13) & 7)
#define _SIZE(x)                (((x) >> 18) & 0x7ff)
#define _METHOD(x)              (((x) >>  2) & 0x7ff)
#define _NOINC(x)               ((x) & 0x40000000)
#define _JMP(x)                 ((x) & 0x20000000)

// CPushBuffer::parseMethod

DWORD CPushBuffer::parseMethod (DWORD dwAddress)
{
    DWORD dwMethod     = *(DWORD*)dwAddress;
    DWORD dwSubChannel = _SUBCHANNEL(dwMethod);
    DWORD dwAdd        = _NOINC(dwMethod) ? 0 : 1;
    DWORD dwCount      = _SIZE(dwMethod);
          dwMethod     = _METHOD(dwMethod);

    dwAddress += 4;

    for (; dwCount; dwCount--) {
        DWORD dwData = *(DWORD*)dwAddress;

        // handle new object
        if ((dwMethod == 0)
            && (g_adwState[dwSubChannel][0] != dwData)) {
            memset (g_adwState[dwSubChannel],0xdd,sizeof(g_adwState[dwSubChannel]));
            g_adwMax[dwSubChannel] = 0;
        }

        // store state
        g_adwState[dwSubChannel][dwMethod] = dwData;
        if (dwMethod > g_adwMax[dwSubChannel]) {
            g_adwMax[dwSubChannel] = dwMethod;
        }

        // next
        dwMethod  += dwAdd;
        dwAddress += 4;
    }

    return dwAddress;
}

//---------------------------------------------------------------------------

// CPushBuffer::captureState

void CPushBuffer::captureState (DWORD dwSubChannel)
{
    char sz[512];

    nvSprintf (sz,"\\state_%d.txt",dwSubChannel);
    HANDLE f = NvCreateFile(sz, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    DWORD  dw;

    for (DWORD i = 0; i < g_adwMax[dwSubChannel]; i++) {
        nvSprintf (sz,"%08x: %08x\r\n",i * 4,g_adwState[dwSubChannel][i]);
        NvWriteFile (f,sz,nvStrLen(sz),&dw,0);
    }
    FlushFileBuffers (f);
    NvCloseHandle (f);
}

#endif  // !_PC_CAPTURE_METHOD_DATA

#endif  // (NVARCH >= 0x04)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvRegTool.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/
#include "nvprecomp.h"
#include "nvRegTool.h"

NvU8 CRegTool::Open(NV_DRIVER_HANDLE driverHandle, int logicalHeadID, char *subKeyName)
{
#if IS_WIN9X
    char regStr[NV_MAX_REG_KEYNAME_LEN];
    MyExtEscape (logicalHeadID, NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, NV_MAX_REG_KEYNAME_LEN, regStr);
    nvStrCat(&(regStr[4]),"\\");
    nvStrCat(&(regStr[4]), subKeyName);

    if (RegOpenKeyEx((HKEY)(*((LPDWORD)&regStr[0])), &regStr[4], 0, KEY_QUERY_VALUE, (HKEY *)&m_hKey) != ERROR_SUCCESS) {
        m_hKey = 0;
    }
    return (m_hKey!=0);
#elif IS_WINNT
    m_hDriver = driverHandle;
    return TRUE;
#endif
    dbgError("Unhandled case\n");
    return FALSE;
}


NvU8 CRegTool::Read(char *keyName, NvU32 &val)
{
    NvU32 readValue;
    NvU32 retStatus;
    NvU32 valueSize = sizeof(NvU32);
#if IS_WIN9X
    NvU32  dwType = REG_DWORD;

    retStatus = RegQueryValueEx((HKEY)m_hKey, keyName, NULL, &dwType, (LPBYTE)&readValue, &valueSize);

#elif IS_WINNT
    WCHAR cUniKeyName[NV_MAX_REG_KEYNAME_LEN];
    NvU32 dwUniKeyLen;
    NvU32 dwRetSize;

    EngMultiByteToUnicodeN((LPWSTR)cUniKeyName, NV_MAX_REG_KEYNAME_LEN*sizeof(WCHAR), &dwUniKeyLen,
                           keyName, (nvStrLen(keyName)+1)*sizeof(CHAR));
    retStatus = EngDeviceIoControl(m_hDriver, IOCTL_VIDEO_QUERY_REGISTRY_VAL, (LPVOID)cUniKeyName,
                                   dwUniKeyLen, (LPVOID) &readValue, valueSize, &dwRetSize);
#endif
    if (retStatus == ERROR_SUCCESS)
    {
        val = readValue;
    }
    return (retStatus == ERROR_SUCCESS);
}

NvU8 CRegTool::Read(char *keyName, NvS32 &signedVal)
{
    NvU32 unsignedVal;
    NvU8  bSuccess;

    bSuccess = Read(keyName, unsignedVal);
    if (bSuccess)
    {
        signedVal = (NvS32)unsignedVal;
    }
    return bSuccess;
}

void CRegTool::Close()
{
#if IS_WIN9X
    RegCloseKey((HKEY)m_hKey);
    m_hKey = 0;
#else
    m_hDriver = 0;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvUtil.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2000 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#include "nvprecomp.h" // Needed for winddi etc.

#include "nvUtil.h"
#include "nvDbg.h"
#include <ctype.h>  // For tolower()
#include <math.h>

EXTERN_C void nvSpin(NvU32 loopCount)
{
    __asm
    {
    push ecx
        mov ecx,[loopCount]
xxx:
        loop xxx
    pop ecx
    }
}

//-------------------------------------------------------------------------
// NV STRING UTILITIES
//-------------------------------------------------------------------------

EXTERN_C int __cdecl nvStrCmp (char *szStr1, char *szStr2)
{
    while (*szStr1 != '\0' && *szStr2 != '\0') {
        if (*szStr1 != *szStr2) {
            return *szStr1 - *szStr2;
        }
        szStr1++;
        szStr2++;
    }
    return *szStr1 - *szStr2;
}

//-------------------------------------------------------------------------

EXTERN_C int __cdecl nvStrLen (char *szStr)
{
    int dwLen = 0;
    while (*szStr != '\0') {
        dwLen ++;
        szStr ++;
    }
    return (dwLen);
}

//-------------------------------------------------------------------------

// strlen up to a maximum of n characters

EXTERN_C int __cdecl nvStrNLen (char *szStr, int n)
{
    int dwLen = 0;

    // normal NULL terminated string
    if (n == 0) return nvStrLen(szStr);

    // length limited string
    while ((*szStr != '\0') && (dwLen < n)) {
        dwLen ++;
        szStr ++;
    }
    return (dwLen);
}

//-------------------------------------------------------------------------

// NV analog to strcpy

EXTERN_C void __cdecl nvStrCpy (char *szDst, char *szSrc)
{
    while (*szSrc != '\0') {
        *szDst = *szSrc;
        szDst ++;
        szSrc ++;
    }
    *szDst = '\0';
}

//-------------------------------------------------------------------------

// NV analog to strncpy

EXTERN_C void __cdecl nvStrNCpy (char *szDst, char *szSrc, int n)
{
    int dwCount=0;
    while ((*szSrc != '\0') && (dwCount < n)) {
        *szDst = *szSrc;
        szDst ++;
        szSrc ++;
        dwCount ++;
    }
    if (dwCount < n) *szDst = '\0';
}

//-------------------------------------------------------------------------

// NV analog to strcat

EXTERN_C void __cdecl nvStrCat (char *szStr1, char *szStr2)
{
    szStr1 += nvStrLen (szStr1);
    nvStrCpy (szStr1, szStr2);
}

//-------------------------------------------------------------------------

// NV analog to strchr

EXTERN_C char* __cdecl nvStrChr(char *szStr, NvU8 c)
{
    while (szStr[0])
    {
        if (szStr[0] == c)
            return szStr;
        szStr++;
    }
    return NULL;
}

//-------------------------------------------------------------------------

// NV analog to strrchr

EXTERN_C char* __cdecl nvStrRChr(char *szStr, unsigned char c)
{
    int dwLen = nvStrLen(szStr);
    char *szStr1 = szStr + dwLen - 1;
    while (szStr1 >= szStr)
    {
        if (szStr1[0] == c)
            return szStr1;
        szStr1--;
    }
    return NULL;
}

//-------------------------------------------------------------------------

void nvPrintPad (char **pDst, char cPad, int iLen)
{
    int i;
    for (i=0; i < iLen; i++) {
         **pDst = cPad;
         (*pDst) ++;
    }
}

//-------------------------------------------------------------------------

// print a formatted string or number (decimal or hex)
// allowed format types are: %[0][1-9]{d,u,x,c,s}

// *pDst is a pointer to the destination string
// *pFormatStr is a pointer to the format string (positioned AFTER the %)
// dwData is the numerical data or a pointer to a constant string

// at function exit, *pFormatStr and *pData will both have been advanced

typedef enum _varType {vtInt, vtDouble, vtChar, vtString, vtPercent, vtUnknown} varType;

static varType nvPrintFormattedThing (char **pDst, char **pFormatStr, NvU8 *pData)
{
    // formatting variables
    BOOL    bLeftJustify;
    char    cFillChar;
    int     iFieldSize;
    int     iPrecision;
    // things to which pData might point
    NvU32   dwData;
    double  dData;
    char    cData;
    char   *szData;
    // other helpers
    NvU32   dwBase, dwDigit, dwInt, dwFrac;
    int     iIndex, i, iStrLen, iSize;
    char    szNumStr[64], szFmt[8];
    char    *pFmt;
    float   fData;
    varType vt;

    // check for left justification
    if (**pFormatStr == '-') {
        bLeftJustify = TRUE;
        (*pFormatStr) ++;   // yes, ++ binds tighter than *. #@&!$^!
    }
    else {
        bLeftJustify = FALSE;
    }

    // determine fill character
    if (**pFormatStr == '0') {
        cFillChar = '0';
        (*pFormatStr) ++;
    }
    else {
        cFillChar = ' ';
    }

    // get field size
    if ((**pFormatStr >= '1') && (**pFormatStr <= '9')) {
        iFieldSize = (int)(**pFormatStr) - (int)('0');
        (*pFormatStr) ++;
    }
    else {
        iFieldSize = 0;
    }

    // check for precision specifier
    iPrecision = 0;
    if (**pFormatStr == '.') {
        (*pFormatStr) ++;
        if ((**pFormatStr >= '1') && (**pFormatStr <= '9')) {
            iPrecision = (int)(**pFormatStr) - (int)('0');
            (*pFormatStr) ++;
        }
    }

    switch (tolower(**pFormatStr)) {

        case 'i':
        case 'd':
        case 'u':
        case 'x':
        case 'p':
            dwData = *(NvU32 *)pData;
            if (**pFormatStr == 'd') {
                if ((int)dwData < 0) {
                    // emit the '-' sign
                    **pDst = '-';
                    (*pDst) ++;
                    dwData = -((int)dwData);
                }
            }
            dwBase = ((**pFormatStr == 'x') || (**pFormatStr == 'p')) ? 16 : 10;
            iIndex = 0;
            if (dwData) {
                while (dwData) {
                    dwDigit = dwData % dwBase;
                    szNumStr[iIndex] = (dwDigit < 10) ?
                                       '0' + (char)dwDigit :
                                       'a' + (char)dwDigit - (char)10;
                    iIndex ++;
                    dwData /= dwBase;
                }
            }
            else {
                // 0 is a special case
                szNumStr[0] = '0';
                iIndex = 1;
            }
            // left fill as needed
            if (!bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-iIndex);
            }
            // copy the number into the destination
            for (i=iIndex-1; i>=0; i--) {
                **pDst = szNumStr[i];
                (*pDst) ++;
            }
            // right fill as needed
            if (bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-iIndex);
            }
            vt = vtInt;
            break;

        case 'f':
            dData = *(double *)pData;
            fData = (float)dData;
            // check for special floating point values first
            if ((FP_EXP_VAL(fData) == 0) && (FP_MAN_VAL(fData) != 0)) {
                // denormal
                nvStrCpy (*pDst, "denormal  ");
                (*pDst) += nvStrLen("denormal  ");
            }
            else if (DWORD_FROM_FLOAT(fData) == FP_INFINITY_BITS) {
                // infinity
                nvStrCpy (*pDst, "infinity  ");
                (*pDst) += nvStrLen("infinity  ");
            }
            else if (DWORD_FROM_FLOAT(fData) == FP_MIN_INFINITY_BITS) {
                // infinity
                nvStrCpy (*pDst, "-infinity ");
                (*pDst) += nvStrLen("-infinity ");
            }
            else if ((FP_EXP_VAL(fData) == 0xff) && (FP_MAN_VAL(fData) != 0)) {
                // NaN
                nvStrCpy (*pDst, "NaN       ");
                (*pDst) += nvStrLen("NaN       ");
            }
            else {
                // a 'normal' floating point number
                if (fData < 0.0) {
                    // emit the '-' sign
                    **pDst = '-';
                    (*pDst) ++;
                    fData = -fData;
                }
                dwInt  = (NvU32)fData;
                dwFrac = (NvU32)(100000000.0*(fData-dwInt)+0.5);
                if (dwFrac==100000000) { dwInt+=1; dwFrac=0; }
                nvStrCpy (szFmt, "d");
                pFmt = szFmt;
                nvPrintFormattedThing (pDst, &pFmt, (NvU8 *)(&dwInt));
                **pDst = '.';
                (*pDst) ++;
                nvStrCpy (szFmt, "08d");
                pFmt = szFmt;
                nvPrintFormattedThing (pDst, &pFmt, (NvU8 *)(&dwFrac));
            }
            vt = vtDouble;
            break;

        case 'c':
            cData = *(char *)(pData);
            // left fill as needed
            if (!bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-1);
            }
            **pDst = cData;
            (*pDst) ++;
            // right fill as needed
            if (bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-1);
            }
            vt = vtChar;
            break;

        case 's':
            szData = *(char **)pData;
            iStrLen = (int) nvStrNLen (szData, iPrecision);
            iSize = iPrecision ? MIN(iPrecision,iStrLen) : iStrLen;
            // left fill as needed
            if (!bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-iSize);
            }
            for (i=0; i < iSize; i++) {
                **pDst = *szData;
                (*pDst) ++;
                szData ++;
            }
            // right fill as needed
            if (bLeftJustify) {
                nvPrintPad (pDst, cFillChar, iFieldSize-iSize);
            }
            vt = vtString;
            break;

        case '%':
            **pDst = '%';
            (*pDst) ++;
            vt = vtPercent;
            break;

        default:
            DPF ("got unknown format type '%c' in nvPrintFormattedThing", **pFormatStr);
            dbgError("NV Error!");
            vt = vtUnknown;
            break;
    }

    (*pFormatStr) ++;

    return (vt);
}

//-------------------------------------------------------------------------

// NV analog to sprintf in two flavors: va_list and ...

EXTERN_C void __cdecl nvSprintfVAL (char *szDest, char *szFormat, va_list vaList)
{
    char   *pDst, *pSrc;
    varType vt;

    pDst = szDest;
    pSrc = szFormat;

    while (*pSrc != '\0') {

        if (*pSrc == '%') {
            pSrc ++;
            vt = nvPrintFormattedThing (&pDst, &pSrc, (NvU8 *)vaList);
            // advance to the next argument
            switch (vt) {
                case vtInt:
                    va_arg (vaList, int);
                    break;
                case vtDouble:
                    va_arg (vaList, double);
                    break;
                case vtChar:
                    va_arg (vaList, char);
                    break;
                case vtString:
                    va_arg (vaList, char *);
                    break;
                case vtPercent:
                    break;
                case vtUnknown:
                    *pDst = '\0';
                    return;
                default:
                    DPF ("got unknown return type from nvPrintFormattedThing");
                    dbgError("NV Error!");
                    *pDst = '\0';
                    return;
            }
        }
        else {
            *pDst = *pSrc;
            pSrc ++;
            pDst ++;
        }
    }

    *pDst = '\0';
}

EXTERN_C void __cdecl nvSprintf (char *szDest, char *szFormat, ...)
{
    va_list vaList;
    va_start (vaList, szFormat);
    nvSprintfVAL (szDest, szFormat, vaList);
    va_end (vaList);
}

#pragma warning(disable: 4035)  // no return value
EXTERN_C NvU32 nvGetCurrentProcessId()
{
#if IS_WINNT4
  __asm
  {
    mov eax, fs:[0x18]
    mov eax, [eax + 0x20] // return value in eax
  }
#elif IS_WINNT5
  return (NvU32)EngGetCurrentProcessId();
#elif IS_WIN9X
  return GetCurrentProcessId();
#endif
}
#pragma warning(default: 4035)  // no return value

EXTERN_C void nvQueryPerformanceCounter(__int64  *pPerformanceCount)
{
#if IS_WINNT4 || IS_WINNT5
  EngQueryPerformanceCounter(pPerformanceCount);
#elif IS_WIN9X
  QueryPerformanceCounter((LARGE_INTEGER *)pPerformanceCount);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\targa.c ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: targa.c
//      routines for reading and writing targa files
//
// **************************************************************************
//
//  History:
//      Craig Duttweiler        12Jun00         filched from architects
//
// **************************************************************************

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <assert.h>
#include "targa.h"

static FILE *ft = NULL;

static char itype_names[12][16] = {"NULL", "MAP", "RGB", "MONO", "4", "5", "6", "7", "8", "RLE-MAP", "RLE-RGB", "RLE-MONO"};
static char mess[200];

static int  decode_rgb     (HANDLE hFile, int width, int height, DWORD dwBPP, unsigned char *dest);
static int  decode_rgb_rle (HANDLE hFile, int width, int height, DWORD dwBPP, unsigned char *dest);

// Read targa file "filename"
// Put pixels into **xbgr, and set *width and *height
// Pixels are xbgr words on the PC
// This routine copes with raw RGB and run-length encoded RGB targa files only

int read_targa_file (char *filename, unsigned char **xbgr, int *width, int *height)
{
    HANDLE     hFile;
    DWORD      dwBytesRead;
    int        err;
    TGA_Header header;
    char       id[2560];
    DWORD      dwBPP;

    *xbgr = NULL;

    hFile = CreateFile (filename, GENERIC_READ, 0,0, OPEN_EXISTING, 0,0);

    if (hFile == INVALID_HANDLE_VALUE) {
        return(-1);
    }

    ReadFile (hFile, &header, sizeof(TGA_Header), &dwBytesRead, NULL);
    if (!dwBytesRead) {
        return(-2);
    }

    if (header.ImageIDLength > 0) {
        ReadFile (hFile, id, header.ImageIDLength, &dwBytesRead, NULL);
        if (!dwBytesRead) {
            return(-3);
        }
    }

    if ((header.ImgType != TGA_RGB) && (header.ImgType != TGA_RLERGB)) {
        return(-4);
    }

    if ((header.PixelSize != 16) && (header.PixelSize != 24) && (header.PixelSize != 32)) {
        return(-5);
    }

    if (((header.Desc & TGA_DESC_ORG_MASK) != TGA_ORG_TOP_LEFT) &&
        ((header.Desc & TGA_DESC_ORG_MASK) != TGA_ORG_BOTTOM_LEFT)) {
        return(-6);
    }

    *width =  ((header.Width_hi)  << 8) | header.Width_lo;
    *height = ((header.Height_hi) << 8) | header.Height_lo;

    *xbgr = (unsigned char *) GlobalAlloc (GMEM_FIXED, *width * *height * sizeof(int));

    if (!(*xbgr)) {
        return (-100);
    }

    dwBPP = header.PixelSize >> 3;

    if ((header.ImgType == TGA_RGB) && ((header.Desc & TGA_DESC_ORG_MASK) == TGA_ORG_TOP_LEFT)) {
        err = decode_rgb (hFile, *width, *height, dwBPP, *xbgr);
    }
    else if ((header.ImgType == TGA_RLERGB) ) {
        err = decode_rgb_rle (hFile, *width, *height, dwBPP, *xbgr);
    }
    CloseHandle (hFile);

    return (err);
}

// Convert from 24 bits/pixel to 32 bits/pixel

static int decode_rgb
(
    HANDLE  hFile,
    int     width,
    int     height,
    DWORD   dwBPP,
    unsigned char *dest_array
)
{
    unsigned char *src, *dest, *scanline;
    int            y, x;
    DWORD          dwBytesRead;

    scanline = (unsigned char *) GlobalAlloc (GMEM_FIXED, width * dwBPP + 1);
    if (scanline == NULL) {
        return(-7);
    }

    for (y=0; y<height; y++) {

        dest = &dest_array[y * width * 4];

        ReadFile (hFile, scanline, dwBPP*width, &dwBytesRead, NULL);
        if (!dwBytesRead) {
            return(-8);
        }

        src = scanline;
        for (x=0; x<width; x++) {
#ifdef   WIN32
            dest[3] = 0;
            dest[2] = src[0];
            dest[1] = src[1];
            dest[0] = src[2];
#else
            dest[0] = 0;
            dest[1] = src[0];
            dest[2] = src[1];
            dest[3] = src[2];
#endif
            src += dwBPP;
            dest += 4;
        }
    }

    GlobalFree (scanline);

    return(0);
}

// Decode run-length encoded Targa into 32-bit pixels

static int decode_rgb_rle
(
    HANDLE  hFile,
    int     width,
    int     height,
    DWORD   dwBPP,
    unsigned char *dest_array)
{
    unsigned char *src, *dest, packet[520];
    int            i, j, count, raw;
    DWORD          dwBytesRead;
    int            dest_count = width*height;

    dest = dest_array;
    
    for (i=0; i<dest_count;) {
        
        
        ReadFile (hFile, packet, dwBPP+1, &dwBytesRead, NULL); // Read repetition count and first color value
        if (!dwBytesRead) {
            return(-9);
        }
        
        raw = (packet[0] & 0x80) == 0;     // Is this packet raw pixels or a repeating color
        count = (packet[0] & 0x7f) + 1;    // How many raw pixels or color repeats
        i += count;
        src = &packet[1];                  // src[0-(dwBPP-1)] are first color value
        
        if (raw && count > 1) {
            ReadFile (hFile, &packet[dwBPP+1], dwBPP*(count-1), &dwBytesRead, NULL); // Read remainder of raw packet into src[3+]
            if (!dwBytesRead) {
                return(-10);
            }
        }
        
        for (j=0; j<count; j++) {
            
            dest[3] = (dwBPP == 4) ? src[3] : 0;
            dest[2] = src[2];
            dest[1] = src[1];
            dest[0] = src[0];
            
            if (raw)                   // In raw mode, keep advancing "src" to subsequent values
                src += dwBPP;          // In RLE mode, just repeat the packet[1] RGB color
            dest += 4;
        }
        if (!raw) 
            src += dwBPP;             // In RLE mode, advance src beyond color
    }
    
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\Surfaces.inc ===
; This file should mirror info in Surfaces.h ,vpcallnk.h, and VidTex.h where necessary

ifndef __SURFACES_INCLUDED__
__SURFACES_INCLUDED__   EQU     1


VDD_IOCTL_NV_FILLTABLE     EQU     20000667H
VDD_IOCTL_NV_GETSETCALLBACK	EQU     20000668H		
VDD_IOCTL_NV_SETVIDTEXSURF	EQU     20000669H		
 		

_NVVDDPROCTABLE STRUC
dwPDDDriver					DWORD   <>
getStoragePointer   		DD      ?
handleBufferInterrupts	DD      ?

_NVVDDPROCTABLE ENDS
LPNVVDDPROCTABLE STRUC  
        DD      ?
LPNVVDDPROCTABLE ENDS


endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\vpoptimize.c ===
/*
 * vpoptimize.c
 *
 * Copyright 2000 NVIDIA, Corporation.  All rights reserved.
 * 
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
** This file is shared between OpenGL and D3D so don't mess with it!
*/

/*
** This file should only be compiled if it's needed.  The normal OpenGL ifdefs:
**
**      #if defined(GL_NV_vertex_program) && __NV_ACCEL>=10
**      #ifdef __GL_USE_OG_INTEL_ASM
**
** and any OpenGL includes like:
**
**      #include "context.h"
**
** can't be used since this is used by D3D as well.
**
*/

#include <stddef.h>

#include "vtxpgmconsts.h"
#include "vtxpgmcomp.h"

#if !defined(TPRINTF)
#define TPRINTF(X)
#define NV_TRACE(X, Y, Z)
#define NV_TRACE_COND(X, Y, Z)
#endif

typedef struct vpOptimize_Rec {
    unsigned char LiveDead[__GL_NUMBER_OF_TEMPORARY_REGISTERS][4];
    unsigned char LiveMask[__GL_MAX_NUMBER_OF_INSTRUCTIONS];
    unsigned char resultRegsWritten[__GL_NUMBER_OF_RESULT_REGISTERS];
    int optimizeMask;
} vpOptimize;

/*
** lPrintVertexProgram() - Print a vertex program using TPRINTF.
*/

#if defined(_DEBUG)

static char *opcodes[] = { VERTEX_PROGRAM_OPCODE_NAMES };

static void lPrintReg(int freg, int Relative, int Offset)
{
    switch (freg) {
    case VA_0:  case VA_1:  case VA_2:  case VA_3:
    case VA_4:  case VA_5:  case VA_6:  case VA_7:
    case VA_8:  case VA_9:  case VA_10: case VA_11:
    case VA_12: case VA_13: case VA_14: case VA_15:
        TPRINTF(("v[%i]", freg - VA_0));
        break;
    case VR_0:  case VR_1:  case VR_2:  case VR_3:
    case VR_4:  case VR_5:  case VR_6:  case VR_7:
    case VR_8:  case VR_9:  case VR_10: case VR_11:
    case VR_12: case VR_13: case VR_14: case VR_15:
        TPRINTF(("o[%i]", freg - VR_0));
        break;
    case PR_0:  case PR_1:  case PR_2:  case PR_3:
    case PR_4:  case PR_5:  case PR_6:  case PR_7:
    case PR_8:  case PR_9:  case PR_10: case PR_11:
    case PR_12: case PR_13: case PR_14: case PR_15:
    case PR_16: case PR_17: case PR_18: case PR_19:
    case PR_20: case PR_21: case PR_22: case PR_23:
    case PR_24: case PR_25: case PR_26: case PR_27:
    case PR_28: case PR_29: case PR_30: case PR_31:
    case PR_32: case PR_33: case PR_34: case PR_35:
    case PR_36: case PR_37: case PR_38: case PR_39:
    case PR_40: case PR_41: case PR_42: case PR_43:
    case PR_44: case PR_45: case PR_46: case PR_47:
    case PR_48: case PR_49: case PR_50: case PR_51:
    case PR_52: case PR_53: case PR_54: case PR_55:
    case PR_56: case PR_57: case PR_58: case PR_59:
    case PR_60: case PR_61: case PR_62: case PR_63:
    case PR_64: case PR_65: case PR_66: case PR_67:
    case PR_68: case PR_69: case PR_70: case PR_71:
    case PR_72: case PR_73: case PR_74: case PR_75:
    case PR_76: case PR_77: case PR_78: case PR_79:
    case PR_80: case PR_81: case PR_82: case PR_83:
    case PR_84: case PR_85: case PR_86: case PR_87:
    case PR_88: case PR_89: case PR_90: case PR_91:
    case PR_92: case PR_93: case PR_94: case PR_95:
        if (Relative) {
            TPRINTF(("c[A0.x+%i]", Offset));
        } else {
            TPRINTF(("c[%i]", freg - PR_0));
        }
        break;
    case TR_0:  case TR_1:  case TR_2:  case TR_3:
    case TR_4:  case TR_5:  case TR_6:  case TR_7:
    case TR_8:  case TR_9:  case TR_10: case TR_11:
    case TR_12: case TR_13: case TR_14: case TR_15:
        TPRINTF(("R%i", freg - TR_0));
        break;
    default:
        TPRINTF(("<<Bad Reg #%02x>>", freg));
    }
} // lPrintSrcReg

static void lPrintScalarSrcReg(ScalarSrcReg *reg)
{
    if (reg->Signed)
        TPRINTF((", -"));
    else
        TPRINTF((", "));
    lPrintReg(reg->reg.reg, reg->reg.AddrReg, reg->reg.addrRegOffset);
    TPRINTF((".%c", "xyzw"[reg->com & 3]));
} // lPrintScalarSrcReg

static void lPrintSwizzleSrcReg(SwizzleSrcReg *reg)
{
    char s[6];

    if (reg->Signed)
        TPRINTF((", -"));
    else
        TPRINTF((", "));
    lPrintReg(reg->reg.reg, reg->reg.AddrReg, reg->reg.addrRegOffset);
    if (reg->com4 != XYZW) {
        s[0] = '.';
        s[1] = "xyzw"[reg->com4 & 3];
        s[2] = "xyzw"[(reg->com4 >> 2) & 3];
        s[3] = "xyzw"[(reg->com4 >> 4) & 3];
        s[4] = "xyzw"[(reg->com4 >> 6) & 3];
        s[5] = '\0';
        TPRINTF(("%s", s));
    }
} // lPrintSwizzleSrcReg

static void lPrintMaskedDstReg(MaskedDstReg *reg)
{
    int mask;

    lPrintReg(reg->reg, 0, 0);
    if (reg->mask != DST_XYZW_BITS) {
        mask = reg->mask;
        TPRINTF(("."));
        if (mask & DST_X_BIT)
            TPRINTF(("x"));
        if (mask & DST_Y_BIT)
            TPRINTF(("y"));
        if (mask & DST_Z_BIT)
            TPRINTF(("z"));
        if (mask & DST_W_BIT)
            TPRINTF(("w"));
    }
} // lPrintMaskedDstReg

static void lPrintVertexProgram(ParsedProgram *parsed, int numInstructions, char *LiveMask)
{
    Instruction *inst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    int pc, lop, lmask, DeadInstruction;

    inst = parsed->firstInstruction;
    for (pc = 0; pc < numInstructions; inst++, pc++) {
        lop = inst->end_op.opcode;
        DeadInstruction = 0;
        TPRINTF(("%03d:  ", pc));
        if (LiveMask) {
            lmask = LiveMask[pc];
            if (lmask & 0x10) {
                TPRINTF(("      "));
            } else if (lmask & 0x20) {
                TPRINTF(("....  "));
                DeadInstruction = 1;
            } else {
                TPRINTF(("%c%c%c%c  ", "-*"[lmask & 1], "-*"[(lmask >> 1) & 1],
                                       "-*"[(lmask >> 2) & 1], "-*"[(lmask >> 3) & 1]));
                if (!(lmask & 0xf))
                    DeadInstruction = 1;
            }
        }
        TPRINTF(("%s  ", opcodes[lop]));
        switch (lop) {

        // ARL op:

        case OP_ARL:
            ainst = (Arl_Instruction *) inst;
            TPRINTF(("A0.x"));
            lPrintScalarSrcReg(&ainst->src);
            break;

        // SCALAR ops:

        case OP_EXP:
        case OP_LOG:
#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
#endif // NV_INTERNAL_OPCODES
        case OP_RCP:
        case OP_RSQ:
            sinst = (Scalar_Instruction *) inst;
            lPrintMaskedDstReg(&sinst->dst);
            lPrintScalarSrcReg(&sinst->src);
            break;

        // VECTOR ops:

        case OP_LIT:
#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
#endif // NV_INTERNAL_OPCODES
        case OP_MOV:
            vinst = (Vector_Instruction *) inst;
            lPrintMaskedDstReg(&vinst->dst);
            lPrintSwizzleSrcReg(&vinst->src);
            break;

        // BIN ops:

        case OP_ADD:
        case OP_DP3:
        case OP_DP4:
#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
#endif // NV_INTERNAL_OPCODES
        case OP_DST:
        case OP_MAX:
        case OP_MIN:
        case OP_MUL:
        case OP_SGE:
        case OP_SLT:
            binst = (Bin_Instruction *) inst;
            lPrintMaskedDstReg(&binst->dst);
            lPrintSwizzleSrcReg(&binst->srcA);
            lPrintSwizzleSrcReg(&binst->srcB);
            break;

        // TRIops:

        case OP_MAD:
            tinst = (Tri_Instruction *) inst;
            lPrintMaskedDstReg(&tinst->dst);
            lPrintSwizzleSrcReg(&tinst->srcA);
            lPrintSwizzleSrcReg(&tinst->srcB);
            lPrintSwizzleSrcReg(&tinst->srcC);
            break;

        // NOPops:

        case OP_NOP:
            break;

        // ENDops:

        case OP_END:
            break;

        default:
            TPRINTF((" ???"));
            break;
        }
        if (DeadInstruction) {
            TPRINTF(("  <<---<< Dead Instruction"));
        }
        TPRINTF(("\n"));
    }
} // lPrintVertexProgram
#endif // defined(_DEBUG)

#define LIVE 1
#define DEAD 0

/*
** lSetMaskedDstReg() - Mark registers set as "dead" prior to this point.
*/

static void lSetMaskedDstReg(vpOptimize *opData, int pc, MaskedDstReg *reg)
{
    unsigned char *LiveDead, *LiveMask;
    int mask, lreg;

    LiveMask = &opData->LiveMask[pc];
    lreg = reg->reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        LiveDead = opData->LiveDead[lreg - TR_0];
        mask = reg->mask;

        // Save current live bits for this register:

        LiveMask[0] = 0; // Mark as a temp register
        if (LiveDead[0] && (mask & DST_X_BIT))
            LiveMask[0] |= DST_X_BIT;
        if (LiveDead[1] && (mask & DST_Y_BIT))
            LiveMask[0] |= DST_Y_BIT;
        if (LiveDead[2] && (mask & DST_Z_BIT))
            LiveMask[0] |= DST_Z_BIT;
        if (LiveDead[3] && (mask & DST_W_BIT))
            LiveMask[0] |= DST_W_BIT;

        // Are we computing any values that won't be used?

        if (mask & ~LiveMask[0]) {
            NV_TRACE(TR_PROGRAM, 30, ("** Dead values: %03d  R%d sets=%d, but live=%d",
                                      pc, lreg - TR_0, mask, LiveMask[0]));
            mask = mask & LiveMask[0];
            if (opData->optimizeMask & (OPT_LIVE_DEAD | OPT_HPOS_ONLY)) {
                reg->mask = (unsigned char) mask;
                NV_TRACE(TR_PROGRAM, 30, ("\n"))
            } else {
                NV_TRACE(TR_PROGRAM, 30, (" ** Optimization Disabled\n"))
            }
        }

        // Mark any registers set as dead:

        if (mask & DST_X_BIT)
            LiveDead[0] = DEAD;
        if (mask & DST_Y_BIT)
            LiveDead[1] = DEAD;
        if (mask & DST_Z_BIT)
            LiveDead[2] = DEAD;
        if (mask & DST_W_BIT)
            LiveDead[3] = DEAD;
    } else {
        if (lreg >= VR_0 && lreg <= VR_15) {
            if ((opData->optimizeMask & OPT_HPOS_ONLY) && lreg != VR_0) {
                reg->mask = 0;
                LiveMask[0] = 0x20; // Dead write to non HPOS output register
            }
            opData->resultRegsWritten[lreg - VR_0] |= reg->mask;
        }
    }
} // lSetMaskedDstReg

/*
** lUseScalarSrcReg() - Mark referenced registers as "live" prior to this point.
*/

static void lUseScalarSrcReg(vpOptimize *opData, char mask, ScalarSrcReg *reg)
{
    unsigned char *LiveDead;
    int lreg;

    lreg = reg->reg.reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        LiveDead = opData->LiveDead[lreg - TR_0];
        if (mask) // Any output means we need the input
            LiveDead[reg->com & 3] = LIVE;
    }
} // lUseScalarSrcReg

/*
** lUseSwizzleSrcReg() - Mark referenced registers as "live" prior to this point.
*/

static void lUseSwizzleSrcReg(vpOptimize *opData, char mask, SwizzleSrcReg *reg)
{
    unsigned char *LiveDead;
    int lreg;

    lreg = reg->reg.reg;
    if (lreg >= TR_0 && lreg <= TR_11) {
        LiveDead = opData->LiveDead[lreg - TR_0];
        if (mask & DST_X_BIT)
            LiveDead[reg->com4 & 3] = LIVE;
        if (mask & DST_Y_BIT)
            LiveDead[(reg->com4 >> 2) & 3] = LIVE;
        if (mask & DST_Z_BIT)
            LiveDead[(reg->com4 >> 4) & 3] = LIVE;
        if (mask & DST_W_BIT)
            LiveDead[(reg->com4 >> 6) & 3] = LIVE;
    }
} // lUseSwizzleSrcReg

/*
** vp_Optimize() - Optimize a vertex program.
*/

void vp_Optimize(ParsedProgram *parsed, int numInstructions, int optimizeMask)
{
    vpOptimize opData;
    Instruction *inst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    int lop, pc, bit;
    char dstMask;

    NV_TRACE_COND(TR_PROGRAM, 30, {
        TPRINTF(("************ Entering optimizer.  Initial program is: ***************\n"));
        lPrintVertexProgram(parsed, numInstructions, NULL);
    });
    NV_TRACE_COND(TR_PROGRAM, 30, {
        if (optimizeMask & OPT_HPOS_ONLY) {
            TPRINTF(("************************************\n"));
            TPRINTF(("*** Generating HPOS-only Program ***\n"));
            TPRINTF(("************************************\n"));
        }
    });

    for (pc = numInstructions - 1; pc >= 0; pc--)
        opData.LiveMask[pc] = 0;
    for (pc = __GL_NUMBER_OF_TEMPORARY_REGISTERS - 1; pc >= 0; pc--)
        opData.LiveDead[pc][0] = opData.LiveDead[pc][1] =
                opData.LiveDead[pc][2] = opData.LiveDead[pc][3] = 0;
    for (pc = 0; pc < __GL_NUMBER_OF_RESULT_REGISTERS; pc++)
        opData.resultRegsWritten[pc] = 0;
    opData.optimizeMask = optimizeMask;

    for (pc = numInstructions - 1; pc >= 0; pc--) {
        opData.LiveMask[pc] = 0x10; // Not a temp register
        inst = &parsed->firstInstruction[pc];
        lop = inst->end_op.opcode;
        switch (lop) {

        // ARL op:

        case OP_ARL:
            ainst = (Arl_Instruction *) inst;
            lUseScalarSrcReg(&opData, DST_X_BIT, &ainst->src);
            break;

        // SCALAR ops:

        case OP_EXP:
        case OP_LOG:
#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
#endif // NV_INTERNAL_OPCODES
        case OP_RCP:
        case OP_RSQ:
            sinst = (Scalar_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &sinst->dst);
            lUseScalarSrcReg(&opData, sinst->dst.mask, &sinst->src);
            break;

        // VECTOR ops:

        case OP_LIT:
            vinst = (Vector_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &vinst->dst);
            dstMask = (vinst->dst.mask != DST_NONE_BITS) ? DST_XYW_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &vinst->src);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
#endif // NV_INTERNAL_OPCODES
        case OP_MOV:
            vinst = (Vector_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &vinst->dst);
            lUseSwizzleSrcReg(&opData, vinst->dst.mask, &vinst->src);
            break;

        // BIN ops:

        case OP_ADD:
        case OP_MAX:
        case OP_MIN:
        case OP_MUL:
        case OP_SGE:
        case OP_SLT:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            lUseSwizzleSrcReg(&opData, binst->dst.mask, &binst->srcA);
            lUseSwizzleSrcReg(&opData, binst->dst.mask, &binst->srcB);
            break;

        case OP_DP3:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? DST_XYZ_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcA);
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcB);
            break;

        case OP_DP4:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? DST_XYZW_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcA);
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcB);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? DST_XYZ_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcA);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? DST_XYZW_BITS : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcB);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_DST:
            binst = (Bin_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &binst->dst);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? (DST_Y_BIT | DST_Z_BIT) : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcA);
            dstMask = (binst->dst.mask != DST_NONE_BITS) ? (DST_Y_BIT | DST_W_BIT) : DST_NONE_BITS;
            lUseSwizzleSrcReg(&opData, dstMask, &binst->srcB);
            break;

       // TRIops:

        case OP_MAD:
            tinst = (Tri_Instruction *) inst;
            lSetMaskedDstReg(&opData, pc, &tinst->dst);
            lUseSwizzleSrcReg(&opData, tinst->dst.mask, &tinst->srcA);
            lUseSwizzleSrcReg(&opData, tinst->dst.mask, &tinst->srcB);
            lUseSwizzleSrcReg(&opData, tinst->dst.mask, &tinst->srcC);
            break;

        // NOPops:

        case OP_NOP:
            break;

        // ENDops:

        case OP_END:
            break;

        default:
            break;
        }
    }

    // Remember which result registers are written:

    for (pc = 0; pc < __GL_NUMBER_OF_RESULT_REGISTERS; pc++)
        parsed->resultRegsWritten[pc] = opData.resultRegsWritten[pc];

    NV_TRACE_COND(TR_PROGRAM, 30, {
        TPRINTF(("** Output 0: "));
        for (pc = 0; pc < __GL_NUMBER_OF_RESULT_REGISTERS; pc++) {
            if (pc == 8)
                TPRINTF(("\n**        8: "));
            lop = opData.resultRegsWritten[pc];
            TPRINTF((" %c%c%c%c", "-*"[lop & 1], "-*"[(lop >> 1) & 1],
                      "-*"[(lop >> 2) & 1], "-*"[(lop >> 3) & 1]));
        }
        TPRINTF(("\n"));
    });

    // Mark any Live on Entry temp registers:

    parsed->liveOnEntry = 0;
    for (bit = 1, pc = 0; pc < __GL_NUMBER_OF_TEMPORARY_REGISTERS; bit <<= 1, pc++) {
        if (opData.LiveDead[pc][0] | opData.LiveDead[pc][1] |
            opData.LiveDead[pc][2] | opData.LiveDead[pc][3])
            parsed->liveOnEntry |= bit;
    };
    NV_TRACE_COND(TR_PROGRAM, 30, {
        if (parsed->liveOnEntry) {
            TPRINTF(("** Live On Entry Temps: "));
            for (pc = 0; pc < __GL_NUMBER_OF_TEMPORARY_REGISTERS; pc++) {
                TPRINTF((" %c%c%c%c", "-*"[opData.LiveDead[pc][0]], "-*"[opData.LiveDead[pc][1]],
                          "-*"[opData.LiveDead[pc][2]], "-*"[opData.LiveDead[pc][3]]));
            }
            TPRINTF(("\n"));
        } else {
            TPRINTF(("** No Live On Entry Temps.\n"));
        }
    });

    // Remove any dead instructions:

    for (pc = numInstructions - 1; pc >= 0; pc--) {
        if (opData.LiveMask[pc] == 0 || opData.LiveMask[pc] == 0x20) {
            inst = &parsed->firstInstruction[pc];
            inst->end_op.opcode = OP_NOP;
            NV_TRACE(TR_PROGRAM, 30, ("** Dead instruction at %03d **\n", pc));
        }
    }

    NV_TRACE_COND(TR_PROGRAM, 30, {
        TPRINTF(("************ Final program is: ***************\n"));
        lPrintVertexProgram(parsed, numInstructions, opData.LiveMask);
        TPRINTF(("************ Leaving optimizer ***************\n"));
    });
} // vp_Optimize
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\vesa\vesadata.h ===
#ifndef _VESADATA_H_
#define _VESADATA_H_
 /***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/


//*****************************************************************************
//
// Definition of display timing terms:
//
//
//  <------------------><--------><-------><------><-------><--------><--------
//
//     Active Display     Border    Porch    Sync    Porch    Border    Active
//
//
//  <---------------------------------------------------------------->
//  Total
//
//  <------------------>
//  Visible
//
//  <---------------------------->
//  Blank Start
//
//  <------------------------------------->
//  Sync Start
//
//  <--------------------------------------------->
//  Sync End
//
//  <------------------------------------------------------>
//  Blank End
//
//*****************************************************************************

#ifndef BUFFER_HSYNC_NEGATIVE
// nvrm.h also defines these. So check if it is already defined.
#define BUFFER_HSYNC_NEGATIVE           1
#define BUFFER_HSYNC_POSITIVE           0
#define BUFFER_VSYNC_NEGATIVE           1
#define BUFFER_VSYNC_POSITIVE           0

#endif

typedef struct _mode_timing_values
{  
    unsigned int HorizontalVisible; 
    unsigned int VerticalVisible;
    unsigned int Refresh;
    unsigned int HorizontalTotal; 
    unsigned int HorizontalBlankStart; 
    unsigned int HorizontalRetraceStart; 
    unsigned int HorizontalRetraceEnd; 
    unsigned int HorizontalBlankEnd;
    unsigned int VerticalTotal; 
    unsigned int VerticalBlankStart; 
    unsigned int VerticalRetraceStart; 
    unsigned int VerticalRetraceEnd; 
    unsigned int VerticalBlankEnd;
    unsigned int PixelClock;
    unsigned int HSyncpolarity; 
    unsigned int VSyncpolarity; 
} MODE_TIMING_VALUES;

unsigned int vesaGetGTFTimings (unsigned int hRes, 
                                unsigned int vRes, 
                                unsigned int refreshRate, 
                                MODE_TIMING_VALUES * timingInfo);
unsigned int vesaGetDMTTimings (unsigned int hRes, 
                                unsigned int vRes, 
                                unsigned int refreshRate, 
                                MODE_TIMING_VALUES * timingInfo);

unsigned int vesaGetNumGTFEntries(void);


#endif // _VESADATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\surfaces.h ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
*                                                                           *
* Module: surfaces.h                                                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           3/26/98                                          *
*                                                                           *
\***************************************************************************/


#ifndef surfaces_h
#define surfaces_h

//#define MAXDATASTORE (0x640)
#define MAXDATASTORE (0x640*4)

/*  FIXES TO GET THIS TO COMPILE UNDER MY NV3 DIRECTORY */

#include "VidTex.h"
#include "VPCallbk.h"
#include "transfer.h"
#include "timing.h"

#ifndef RESMANSIDE

#include "nvddobj.h"

#ifdef NV3

#define info32  otherInfo32
#define info16  otherInfo16
#define nvContextDmaToMemory contextDmaToMemory
#define nv03ExternalVideoDecoder    externalVideoDecoder
#define NV04D_NOTIFICATION_STATUS_IN_PROGRESS   NV_STATUS_IN_PROGRESS
#define NV04D_NOTIFICATION_STATUS_DONE_SUCCESS  NV_STATUS_DONE_OK

#endif // NV3

#endif // !RESMANSIDE

// this file will include the definitions of the common
// data structures between the Ring3 VPE code
// and the ring0 VXD code which will actually program
// things

//---------------------------------------------------------------------------

// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)

// these next three are measured in Pixels ie 2 byte chunks
#define NV4_MAX_FIELDWIDTH (0x1000)
#define NV4_MAX_FIELDHEIGHT (0x5dc)	//1500. current max.height=1080p for HD
#define NV4_MAX_VBIWIDTH (0x1000)
#define NV4_MAX_BUFFERLENGTH (0x80000)

#define NV4_MAX_PIXELRATE ( 27000000)

// these next three are measured in Pixels ie 2 byte chunks
#define NV10_MAX_FIELDWIDTH (0x1000)
#define NV10_MAX_FIELDHEIGHT (0x5dc)	//1500. current max.height=1080p for HD
#define NV10_MAX_VBIWIDTH (0x1000)
#define NV10_MAX_BUFFERLENGTH (0x800000)

#define NV10_MAX_PIXELRATE ( 100000000)     // a little arbitrary, need to confirm (jsun)

// Here we'll put chip specific info which may change from part to part...
#ifdef NV3
// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)
// these next three are measured in Pixels ie 2 byte chunks
#define NV_MAX_FIELDWIDTH (0x1000)
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)
#endif // NV3

//---------------------------------------------------------------------------

#ifdef NV4
// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)
// these next three are measured in Pixels ie 2 byte chunks
#define NV_MAX_FIELDWIDTH 2000	//since max now is 1920
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)
#define NV_MAX_FIELDHEIGHT	1200	//since max now is 1080i
#endif //NV4

//---------------------------------------------------------------------------

#ifdef NV5
// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)
// these next three are measured in Pixels ie 2 byte chunks
#define NV_MAX_FIELDWIDTH (0x1000)
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)

const DWORD MY_CONNECTION_CAPS= //DDVPCONNECT_DOUBLECLOCK           |
                                            //DDVPCONNECT_VACT                  |
                                            //DDVPCONNECT_INVERTPOLARITY        |
                                            DDVPCONNECT_DISCARDSVREFDATA    |
                                            //DDVPCONNECT_HALFLINE              |
                                            DDVPCONNECT_INTERLACED          |
                                            //DDVPCONNECT_SHAREEVEN         |
                                            //DDVPCONNECT_SHAREODD              |
                                            0;
#endif //NV5

//---------------------------------------------------------------------------

#ifdef NV10
// defines the number of video ports that this system will handle
#define NV_MAX_VIDEOPORTS   (1)
// these next three are measured in Pixels ie 2 byte chunks
#define NV_MAX_FIELDWIDTH 2000	//since max now is 1920
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)
#define NV_MAX_FIELDHEIGHT	1200	//since max now is 1080i
#endif //NV10

//---------------------------------------------------------------------------

// since many compiler have poor enum implementations
// I'll reserve the right to do this manually
//#define DECENTENUMS

#ifdef DECENTENUMS

enum    {
    VP_NOT_RUNNING = 0,
    VP_VBI_CAPTURING =1,
    VP_IMAGE_CAPTURING =2,
    VP_BOTH_CAPTURING = 3
} VPSTATE;

enum {

    MY_EXTERNAL_DECODER_OBJECT      = 0x80024000,
    MY_EXTERNAL_DECODER_NOTIFIER,
    MY_IMAGE0_BUFFER_CONTEXT,
    MY_IMAGE1_BUFFER_CONTEXT,
    MY_VBI0_BUFFER_CONTEXT,
    MY_VBI1_BUFFER_CONTEXT

} MYINSTANCES;

enum {
    VBISURF = (0xFEEDC0DE),
    IMAGESURF
} SURFKIND;

enum {
    NOVPERROR               = 0,
    TOOMANYSURFACESERROR = 20,
    CANTCREATESURFACE,
    SURFACENOTFOUND = 9999,
    NOSURFACEPROGRAMED = 999
} VPERRORS;


enum {
    EVENODD =1,
    EVENEVEN,
    ODDODD
} CAPTUREMODE;

enum {
    SEPERATEBUF = 10,
    INTERLEAVBUF  = 20
} SCANMODE;

// These constants are designed to correspond with the NV3 hardware.
enum {
    ODD = 0,
    EVEN,
    UNKNOWN
} FIELDTYPE;


#else
#define SURFKIND   U032
#define VBISURF (0xFEEDC0DE)
#define IMAGESURF   (0xBAD0BEEF)

#define VPSTATE         U032
#define VP_NOT_RUNNING          (0)
#define VP_VBI_CAPTURING        (1)
#define VP_IMAGE_CAPTURING  (2)
#define VP_BOTH_CAPTURING   (3)

// standard decoder object handle values
#define MY_EXTERNAL_DECODER_OBJECT      (0x80024000)
#define MY_EXTERNAL_DECODER_NOTIFIER    (0x80024001)
#define MY_IMAGE0_BUFFER_CONTEXT        (0x80024002)
#define MY_IMAGE1_BUFFER_CONTEXT        (0x80024003)
#define MY_VBI0_BUFFER_CONTEXT          (0x80024004)
#define MY_VBI1_BUFFER_CONTEXT          (0x80024005)
#define MY_IMAGE1_BUFFER_EVENT          (0x80024006)
#define MY_IMAGE0_BUFFER_EVENT          (0x80024007)
#define MY_VBI1_BUFFER_EVENT                (0x80024008)
#define MY_VBI0_BUFFER_EVENT                (0x80024009)
#define MY_VPE_CHANNEL                      (0x8002400A)
#define  MY_TIMER_NOTIFIER                  (0x8002400B)
#define  MY_TIMER_OBJECT                    (0x8002400C)
#define  MY_TIMER_EVENT                     (0x8002400D)
// handle values for MTM
#define MY_MTM_OBJECT                       (0x80024010)
#define MY_MTM_NOTIFIER                 (0x80024011)
#define MY_MTM_FROM_CONTEXT             (0x80024012)
#define MY_MTM_TO_CONTEXT                   (0x80024013)
#define MY_MTM_EVENT                        (0x80024014)
//#define   MY_MTM_EVENT2                       (0x80024015)
// values for the texture surface
#define MY_SWIZ_OBJECT                      (0x80024020)
#define MY_SWIZ_NOTIFIER                    (0x80024021)
#define  MY_2DSWIZD_OBJECT                  (0x80024022)
#define  MY_2DSWIZD_NOTIFIER                (0x80024023)

#define MY_OVERLAY0_BUFFER_EVENT                (0x80024025)
#define MY_OVERLAY1_BUFFER_EVENT                (0x80024026)

#define MY_DVD_SUBPICTURE_OBJECT                (0x80024027)

#define MYINSTANCES (U032)

#define SURFKIND   U032
#define VBISURF (0xFEEDC0DE)
#define IMAGESURF   (0xBAD0BEEF)

#define STARTINGBUF (99)
#define UNKNOWNBUF  (123)


#define NOVPERROR               (0)
#define TOOMANYSURFACESERROR (20)
#define CANTCREATESURFACE       (21)
#define SURFACENOTFOUND     (0x9999)
#define NOSURFACEPROGRAMED  (0x999)
#define VPERRORS                U032

// Note that PROGRESSIVE is the currently defined to be ODD ODD
#define CAPTUREMODE             U032
#define EVENODD                 (1)
#define EVENEVEN                (2)
#define PROGRESSIVE             (3)
#define ODDODD                  (3)

#define SCANMODE                    U032
#define SEPERATEBUF             (10)
#define INTERLEAVBUF            (20)

// These constants are designed to correspond with the NV3 hardware.
#define FIELDTYPE               U032
#define ODD                     0
#define EVEN                        1
#define UNKNOWN                 3

#endif //DECENTENUMS

// the maximum frame period should be 20% more than 1/24 of a second measured in nanosecs
//    this is  1/24  * 1.2  * 1,000,000,000 = 50000000  = 0x2faf080
#define MAXFRAMEPERIOD          (0x2faf080)

//  There are 9 notifiers for the externalvideodecoder class
//    there are an additional  2 notifiers for the timer class
//    2 notifiers for the MTM class
//    1 notifier for the nvo3 sclaed image
//    1 notifier for the stretch swizzle class
#define  NUM04DNOTIFIER     (9)
#define  NUM004NOTIFIER    (2)
#define NUM039NOTIFIER      (2)
#define  NUM077NOTIFIER    (1)
#define  NUM052NOTIFIER    (1)
#define  NUM04DOFFSET       (0)
#define  NUM004OFFSET       (NUM04DOFFSET+NUM04DNOTIFIER)
#define  NUM039OFFSET       (NUM004OFFSET+NUM004NOTIFIER)

// for swizzler class
#define  NUM077OFFSET       (NUM039OFFSET+NUM039NOTIFIER)

// for swizzled surface
#define  NUM052OFFSET       (NUM077OFFSET+NUM077NOTIFIER)
#define NUMVPNOTIFIERS      (NUM052OFFSET+NUM052NOTIFIER)


// This little goodies is going to be used so that we can distinguish between
// two states which the architecture has traditionally considered to be ONE.
// these states are to distinguish between a notification where Status indicates
// that the HW is done, but the SW has not dealt with that even
// this is DONE_SUCESS
// the second state is HW done and SW dealt with the event, but no new
// task has been delivered back to the HW.    Theoretically this should
// be the power-on state.

#define NV04D_NOTIFICATION_STATUS_NOT_LAUNCHED                     (0x42)


/* Debug stuff */
#ifndef RESMANSIDE
#ifdef DEBUG
    #define ASSERT(ParamAssert)     (ParamAssert)? \
            (void)0:DPF("Assertion failed in %s at line %i\n", __FILE__, __LINE__)

    #define strASSERT( Condition, string )  (Condition)?\
            (void)0:DPF("Assertion failed in %s at line %i, %s", __FILE__, __LINE__, strAssert)

#else
    #define ASSERT( ParamAssert )               (void)0
    #define strASSERT( Condition, string )      (void)0
#endif
#else
    #define ASSERT(x)  (void)0
    #define strASSERT(Condition,string)   (void)0
#endif

// this is the maximum for both VBI and IMAGE combined
#define MAXVPSURFACES   (10)

// used to timeout while's which are depedant on HW so which may never terminate
#define WHILETIMEOUT                        (0x800000)


// this next one can't conflict with MS defined things...
//#define VDD_IOCTL_SET_NOTIFY    0x10000001  // set mode change notify
//#define VDD_IOCTL_GET_DDHAL     0x10000002  // get DDHAL functions from miniVDD

#define VDD_IOCTL_NV_FILLTABLE   0x20000667

typedef struct _NVVDDPROCTABLE
{

    U032        dwPDDDriver;
    MINIPROC    getStoragePointer;
    MINIPROC handleBufferInterrupts;

} NVVDDPROCTABLE;

typedef struct _vpSurfaceInfo
{
    HANDLE              surfHandle;             // directDraw surface handle
    FLATPTR             pVidMem;                    // flat pointer to the surface
    U032                    dwOffset;               // offset from the base of the frame buffer
    U032                    dwPitch;
    U032                    dwLength;
    U032                    dwHeight;
    U032                    dwWidth;                    // ignored for VBI
    U032                    dwStartLine;            // programs Y-crop for image, and startline for vbi
    U032                    dwPreScaleSize;     // ignored for VBI.. represented in 16..16 format
    DWORD                   ddsCaps;                    // capabilites of this DD surface
    NvNotification*     pNvNotify;              // pointer to typical notification structure that was most recently used
    U032                    bAutoFlip;              // do we turn around and auto program this surface?
    U032                    nextSurfaceNum;     // which is the next surface to fire off?
    FIELDTYPE           field;                  // what field was this surface setup to capture?
    U032                    dwRes1;         // for storing the pointer to the "second" surface for the DVD subpicture stuff
} vpSurfaceInfo;

typedef struct _DropSys {
   U032 dwTargetSurface;
   U032 dwbIsBobFromInterleave;
   U032 dwFieldType;
   U032 dwFullBool;
   U032 dwDropFields;
} DropSys;


typedef struct _vpSurfaces {
    U032                    numberOfSurfaces;               // total number of surfaces that we're keeping track of
    vpSurfaceInfo*      Surfaces[MAXVPSURFACES];    // this will be a pointer to an array of surfaces
    U032                    CurrentBufferSurface[4];    // to associate the HW buffer with an arrary index
    CAPTUREMODE         CurrentCaptureMode;         // indicates which fields will be capture Even
    SCANMODE                CurrentScanMode;                // seperate or interleaved buffersx
    FIELDTYPE           lastField;                      // the last buffer programmed was to capture a field of this type
    FIELDTYPE           lastVBIField;                           //same but for VBI
    U032                    bInputInterLaced;               // TRUE if we're running with an interlaced input
    U032                    VBIstart;                       // which surface is the first one which has VBI data?
    // general information
    U032                    bSkipNextField;             // set to true to indicate that the next field should be skipped.  reset by upon skip
    U032                    dwInHeight;                    // input height (into the surface)
    U032                    dwInWidth;                      // input width (into the surface)
    U032                    dwImageStartLine;               // first line of image data to capture
    U032                    dwVBIStartLine;             // the first VBI line to capture
    U032                    dwVBIHeight;                    // total number of lines of VBI to capture
    U032                    dwPreHeight;                    // height and width before prescaling
    U032                    dwPreWidth;                     // width before prescaling
    U032                    dwOriginX;                      // orgins to move data within the surface
    U032                    dwOriginY;
    U032                    bThreadDead;                    // TRUE indicates that the thread has decided to exit
    U032                    bThreadRunning;             // if true, indicates that the thread should continue to run
//  LPVOID              hVPInterruptEvent;          // handle to the event used to notify the thread to wake up
//  DWORD                   VpInterruptId;                  // the thread ID of the thread
//  HANDLE              hThreadHandle;                  // Handle to the thread
    U032                    bStopVP;                            // indicates to the thread that it should NOT reprogram..
    HANDLE              myVXDhandle;                    // used to store the handle to access the mini-vdd

    U032                    CallbackSelector;
    U032                    pNotifyCallbackProcI0;
    U032                    pNotifyCallbackProcI1;
    U032                    pNotifyCallbackProcV0;
    U032                    pNotifyCallbackProcV1;
    U032                    pTimerNotifyProc;
    U032                    pMTMNotifyCallback;
    U032                    pNotifyOverlay0NotifyProc;
    U032                    pNotifyOverlay1NotifyProc;

    DDMINIVDDTABLE      myKMVTTable;                    // for storing the locations of the KVMT functions
    U032*                   pNvDevBase;
    U032                    bInvertedFields;
    // these are temporarly while I do information about the speed of things

    timeStore           Timings;
#if 0
    U032                    marker;
    U032                    storCount;
    U032                    mpFlipTime0[MAXDATASTORE];  // these next are for collection timing statistics
    U032                    mpFlipTime1[MAXDATASTORE];
    U032                    mpFlip[MAXDATASTORE];

    U032                    ovReqTime0[MAXDATASTORE];
    U032                    ovReqTime1[MAXDATASTORE];
    U032                    ovReq[MAXDATASTORE];

    U032                    ovFlipTime0[MAXDATASTORE];  // this should be in MicroSeconds
    U032                    ovFlipTime1[MAXDATASTORE];      // this should be in MicroSeconds
    U032                    ovFlip[MAXDATASTORE];

    U032                    surfPlace[MAXDATASTORE];    // a "packed" version of current surfaces
    U032                    mpLoopCount;
    U032                    ovLoopCount;
    U032                    ovFlLoopCount;
    U032                    loopCount;
#endif
    U032                    curImageSurf;
    U032                    curVBISurf;
    U032                    curSurf;
    U032                    intermediateCycle;

    FLATPTR             pBuffer0Mem;                    // to keep track of which surface is programmed in the VDD
    FLATPTR             pBuffer1Mem;
    U032                    curOverlay;
    NVVDDPROCTABLE      myTable;
    NvChannel*          pVPChanPtr;
    NvChannel*          pOverlayChanPtr;                // used to store the Pointer to the NV channel
                                                                // because of potential multithreading issues we try to keep the overlay in
                                                                // it's own channel.  However, we do a SetObject on it just incase before use
    U032                    dwOverlaySubChan;               // used to store the subchannel in which we'll talk to the Overlay
    U032                    dwOverlayObjectID;          // used to store the OverlayObject ID...
    U032                    dwScalerObjectID;
    U032                    dwDVDObjectID;
    NvNotification* pTheNotifiers;

    CALLBPROC           ImageCallbackRoutine;
    CALLBPROC           VBICallbackRoutine;
    sCallBack           myIMGCallbackInfo;
    sCallBack           myVBICallbackInfo;
    GLOBALDATA*         pDriverData;
    U032                    myFreeCount;
    // THESE are the big ugly so we dont' have to worry about which context the ring0 stuff was called from and there
    // where these guys were allocated from
    U032                    lastsrcDeltaY;
    U032                    surfMemAllocCount;
    vpSurfaceInfo       surfMemory[MAXVPSURFACES];  // this will be a pointer to an array of surfaces
    U032                    DXIRQCallbackSources;       // flags for the callback determination
    U032                    pDXIRQCallback;             // address of the callback proc for the DX stuff
    U032                    dwIrqContext;
    U032                    dwVPFlags;              // same flags as passed in to UpdateVideoPort
    VPSTATE             dwVideoPortStatus;  // yet another global silly
    U032                    bFlipRequested;         // used during non-auto-flip to determine if a flip occurred
    U032                    lastSurfaceFlippedTo;
    volatile U032*                  pNvTimer;

    aTransfer           MyTransfers[MAXTRANSFERS];  // array of transfers from which to allocate
    U032                    dwNextEmpty;    //Points to the location in the array of the next empty we should fill
    U032                    dwLastEmpty;    //Points to the location in the arry which was just emptied...
    //pTransfer         pLastTransfer;                  // the last one which was added
    pTransfer           pCurrentTransfer;               // the current one which just just put into the HW
    U032                    bContextCreated;                // has the context object been created or not
    U032                    savedStart;
    U032                    savedLimit;
    U032                    dwMostRecentFinishTransferId;  // used to store the ID of the most recently finished transfer
    U032                    SetupComplete;
    U032                    dwOvSurfaceOffset;
    U032                    lastSurface;            // bob-interleave field delay
    U032                    lastBuffer;             // bob-interleave field delay
    U032                    bDoingDropFrame;        // used to indicate that we just dropped a field and the leap frogging should stop for one frame
    VidTexSurf*         pVidTexSurf;
    U032                    bRing0Flip;
    DropSys                 DropSystem;
    U032                    lastOvLowTime;          // used to store the last overlay callback time to eliminate duplicates
    U032                    bFirstTime;           // used to indicate first time through on seperate buffer starts to eliminate an NV10 bug!
} vpSurfaces;




vpSurfaces* getStoragePointer(void );
DWORD SetupVP (LPDDHAL_CREATEVPORTDATA lpInput);
BOOL    GetField(void);
DWORD getCurLine(void);
void    tearDownVP(void);
void    StopVP(void);
U032    findSurface(LPDDRAWI_DDRAWSURFACE_LCL pNewSurface );
U032    ProgramBufferWithSurface(U032   dwBufferIndex,U032  newSurfaceIndex, U032 bZeroLength);
VPERRORS replaceSurfaceList(DWORD dwNumAutoflip,DWORD dwNumVBIAutoflip,
                                        LPDDRAWI_DDRAWSURFACE_INT   *lplpDDSurface,
                                        LPDDRAWI_DDRAWSURFACE_INT   *lplpDDVBISurface,
                                        U032 bAutoflip );

// used by surfaces.h internally
DWORD WINAPI VPInterruptThread(PVOID daParameter);

VPERRORS    addSurface(vpSurfaceInfo*   pNewSurface);
VPERRORS replaceSurfaceWithSurface(U032 surfaceToReplace,
                                        LPDDRAWI_DDRAWSURFACE_LCL pNewSurface,
                                        U032  bVBI);

vpSurfaceInfo* createSurface(LPDDRAWI_DDRAWSURFACE_INT pNewSurface, U032 bAutoflip,
                                        U032 bVBI, NvNotification* pToNotify,U032 nextSurface);
VPERRORS clearAllSurfaces();

U032    getNextSurface(U032 currentSurface, U032 bSingleAdvance);
U032    getPrevSurface(U032 currentSurface);
U032    getPrevOverlaySurface(U032 targetSurface);
void    getCurrentNanoTimer(U032*   Most, U032* Least);

U032    HookUpVxdStorage(void);


#define INIT_FREE_COUNT(a) unsigned long freeCount = a;

#ifdef NV3
#define CHECK_FREE_COUNT(a,b)                       \
    ASSERT(b < NV_GUARANTEED_FIFO_SIZE );           \
    while (freeCount < b)                               \
        freeCount = NvGetFreeCount(a, 0);           \
    freeCount -= b;
#else
#define CHECK_FREE_COUNT(a,b)                       \
    ASSERT(b < NV06A_FIFO_GUARANTEED_SIZE );            \
    while (freeCount < b)                               \
        freeCount = NvGetFreeCount(a, 0);           \
    freeCount -= b;

#endif


#ifndef VPE_NT      // this is for win9x

#ifndef INVDDCODE
#define  GLOBDATAPTR         ((GLOBALDATA*)(pMySurfaces->pDriverData))
#else
#define  GLOBDATAPTR         ((GLOBALDATA*)(MySurfaces.pDriverData))
#endif  // INVDDCODE

#define  PBASEADDRESS    BaseAddress
#define  DWFBUFFERLEN    (GLOBDATAPTR->VideoHeapEnd - GLOBDATAPTR->BaseAddress)
#define  DEVHANDLE       dwDeviceHandle
#define  ROOTHANDLE      dwRootHandle
#define  CLIENTHANDLE    hClient

#else           // this is for NT
#define  GLOBDATAPTR        ((PDEV*)(pMySurfaces->pDriverData))
#define  PBASEADDRESS    pjFrameBufbase
#define  DWFBUFFERLEN    cbFrameBuf - 1

#define  DEVHANDLE       hDevice
#define  ROOTHANDLE      hDriver
#define  CLIENTHANDLE    hClient
#define

#endif


#endif //surfaces_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\nvVPP.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-2001 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*==========================================================================;
 *
 *
 *  File:       nvVPP.cpp
 *  Content:    Shared Video Post Processing Code
 *
 *
 *  VPP pipe for NV4/5:
 *
 *                                           /-----\   /-------\
 *  YUV12           YUV422                   |Scale|   |Colour |
 *    |  /---------\  |                  +-->|Down |-->|Control|--+
 *    +->|Convert  |  |   /----------\   |   \-----/   \-------/  |   /--------\   /----\   /-------\
 *    +->|to YUV422|--+-->|Subpicture|-->+                        +-->|Temporal|-->|Flip|-->|Overlay|
 *    |  \---------/      \----------/   |   /-------\   /-----\  |   |Filter  |   \----/   |Scale  |
 *  YUV9                                 +-->|Colour |-->|Scale|--+   \--------/            \-------/
 *                                           |Control|   |Up   |
 *                                           \-------/   \-----/
 *
 *
 *  VPP pipe for NV10/NV20:
 *
 *  YUV12            YUV422
 *    |  /---------\   |                                                                                     /-------\
 *    +->|Convert  |   |    /----------\   /-----------\   /--------\      /--------\   /----\   /-------\   |Overlay|
 *    +->|to YUV422|---+--->|Subpicture|-->|DeInterlace|-->|Temporal|--+-->|Prescale|-->|Flip|-->|Overlay|-->|Colour |
 *    |  \---------/        \----------/   |Filter     |   |Filter  |  |   \--------/   \----/   |Scale  |   |Control|
 *  YUV9                                   \-----------/   \--------/  |                         \-------/   \-------/
 *                                                                     |
 *                                                                     v
 *                                                                /---------\   /-------\
 *                                                                |FS Mirror|-->|FS Flip|
 *                                                                \---------/   \-------/
 *
 * Initialization/Use Sequence:
 *
 *     VppConstructor()          - Done @ DriverInit.  A few driver escapes to the VPP are safe (but no 4cc blts etc)
 *                                 Allocates DMA contexts.
 *        VppEnable()            - Done @ DirectDraw Enable.  4CC blts are okay using the driver escapes.
 *                                 Allocates object, sets up pointers for access to pusher etc.
 *           VppCreateOverlay()  - Done @ Overlay creation time.  Actually creates the overlay object
 * 
 *           VppDestroyOverlay() - Done when overlay surface is destroyed
 *
 *           [VppCreateFSMirror VPPDestroyFSMirror] - These are at this level as well
 *
 *        VppDisable()           - Done when DirectDraw is disabled (objects are freed, channel ptrs are cleared)
 *
 *     VppDestructor()           - Done @ Driver Exit.  DMA contexts are freed.
 *
 *  Extra surfaces:
 *      In addition to the overlay surfaces that the application creates, 4 extra
 *      (or 3 optimized) work surfaces are created for VPP usage.  The original
 *      data in the overlay surface is never modified.  Each run through the pipe
 *      uses 2 of the extra surfaces (the other two hold video data which is
 *      being displayed or pre-swizzled) and each stage alternates working on
 *      one surface to the other, i.e. the output of one stage is the input for
 *      the next.  On each flip, the 2 working surfaces are swapped with the 2
 *      holding surfaces.
 *
 *  Event protocol
 *      Each stage must generate a unique event (vppSubPicture and vppPrescale are
 *      excepted).  VppDoFlip waits for last event to complete before flipping.
 *      Note that because we can only have one DVD_SUBPICTURE per channel, we must
 *      wait until the previous instance completes before using it again.
 *
 *  Decision making:
 *      Gross level stage enable decisions are made in VppDoFlip.  More complex
 *      decision making which may require computation is made within the stage.  Each
 *      stage returns TRUE if it succeeds, FALSE if not.  If the stage returns FALSE,
 *      it must do nothing so that video can still proceed though the pipe.
 *
 *  State changes:
 *      Each stage is responsible for changing the surface parameters if a stage
 *      modifies them.  This can either be done within the stage, or in VppDoFlip
 *      upon successful completion of the stage.  E.g. the convert stage changes
 *      the fourcc code and the prescaler changes the width and height.
 *
 *  Stage enables and disables:
 *      There can be up to 3 levels of stage enables:
 *      1) Most (but not all) stages have registry enables
 *      2) Each stage is selectively enabled by the caller of VppDoFlip
 *      3) The enable flags passed by the caller are masked by an inverse mask set in the registry
 *      The final enable is determined by ((2 & ~3) && 1)
 *
 ***************************************************************************/

// For 9x and NT5, nvprecomp.h comes from the ddraw common area,
// for NT4, it comes from drivers/display/winnt4/ddraw/nv4/nvprecomp.h
#include "nvprecomp.h"
#include "wincommon.h"

#include "nvVPP.h"

// We define this as a null label to use instead of 'static' to indicate to the reader that a function
// is intended for use only within this file.  If we define the functions as static, we get reports off
// faults from the last exported function instead of the function we should be looking at.
#define LOCAL

#if (IS_WINNT4 || IS_WINNT5)
#undef GET_MODE_BPP
#define GET_MODE_BPP()       (vpp.m_ppdev->cBitsPerPel)
#define LOGICAL_HEAD_ID()    (vpp.m_ppdev->ulDeviceDisplay[0])
#define DRIVER_HANDLE()      (vpp.m_ppdev->hDriver)
#else
#define LOGICAL_HEAD_ID()    (pDXShare->dwHeadNumber)
#define DRIVER_HANDLE()      (0)
#endif

#if (IS_WINNT5)
extern "C" BOOL __cdecl NvSetDac(PDEV *ppdev, ULONG ulHead, RESOLUTION_INFO * pResolution);
extern "C" void __cdecl DisableHeadCursor(PDEV *ppdev, ULONG ulHead, ULONG ulDiable);
extern "C" void __cdecl NVMoveDisplayWindow(PDEV* ppdev, ULONG ulHead, RECTL * prclCurrentDisplay);
extern "C" void __cdecl NvSetDacImageOffset(PDEV* ppdev, ULONG ulDac, ULONG ulOffset);
#endif

// *********************************************************************
// Local Prototypes
// *********************************************************************
LOCAL void vppFreeOverlay(Vpp_t *pVpp);
LOCAL NvU8 vppAllocOverlay(Vpp_t *pVpp);
LOCAL void vppChooseOverlayHead(Vpp_t *pVpp);
LOCAL BOOL vppAllocateObjects(Vpp_t *pVpp);
LOCAL void vppFreeObjects(Vpp_t *pVpp);
LOCAL void vppInitObjects(Vpp_t *pVpp);
LOCAL BOOL vppAllocateContextDMAs(Vpp_t *pVpp);
LOCAL void vppFreeContextDMAs(Vpp_t *pVpp);
LOCAL BOOL vppInitCelsius(Vpp_t *pVpp);
LOCAL BOOL vppInitKelvin(Vpp_t *pVpp);
LOCAL BOOL vppValidateMode(Vpp_t *pVpp, DWORD dwWidth, DWORD dwHeight, DWORD dwBytesPerPel,
                            DWORD dwNumSurfaces, DWORD dwHead, DWORD dwRefreshRate, DWORD dwDCHead, DWORD dwDeviceType);
LOCAL BOOL vppPreCopy(Vpp_t *pVpp, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                       DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight);
LOCAL BOOL vppConvert(Vpp_t *pVpp, LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                       DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFourCC);
LOCAL BOOL vppSubPicture(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                          DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFourCC);
LOCAL BOOL vppPreScale(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset, DWORD dwDstPitch,
                        LPDWORD pWidth, LPDWORD pHeight, DWORD dwFourCC, LPDWORD dwField);
LOCAL BOOL vppFSMirror(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwWidth, DWORD dwHeight,
                        DWORD dwFourCC, DWORD dwFlags, DWORD dwPrescaleFactorX, DWORD dwPrescaleFactorY);
LOCAL BOOL vppColourControl(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset, DWORD dwDstPitch,
                             DWORD dwWidth, DWORD dwHeight, DWORD dwFourCC, DWORD dwField);
LOCAL BOOL vppNv20Deinterlace(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                               DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags);
LOCAL BOOL vppNv20Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                            DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags, LPDWORD pPrevFrameOffset);
LOCAL BOOL vppNv10Deinterlace(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                               DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags);
LOCAL BOOL vppNv10Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                            DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, DWORD dwFlags, LPDWORD pPrevFrameOffset);
LOCAL BOOL vppNv5Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwSrcOffset, DWORD dwSrcPitch, DWORD dwDstOffset,
                           DWORD dwDstPitch, DWORD dwWidth, DWORD dwHeight, LPDWORD pPrevFrameOffset);
LOCAL BOOL vppFSFlipSync(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex, BOOL bWait);
LOCAL BOOL vppFSFlip(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex);
LOCAL BOOL vppFlipSync(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex, BOOL bWait);
LOCAL BOOL vppFlip(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                    DWORD dwOffset, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight,
                    DWORD dwIndex, DWORD dwFourCC, DWORD dwFlags,
                    DWORD dwPrescaleFactorX, DWORD dwPrescaleFactorY);
LOCAL void vppBltFillBlock(Vpp_t *pVpp, NvU32 dwColor, NvU32 dwOffset, NvU32 dwPitch, NvU32 dwWidth, NvU32 dwHeight, NvU32 dwBytesPerPel);
LOCAL void vppBltWriteDword(Vpp_t *pVpp, NvU32 dwOffset, NvU32 dwIndex, NvU32 dwData);
LOCAL void vppBltUpdateClip(Vpp_t *pVpp);

extern NvU8 VppIsConstructed(Vpp_t *pVpp)
{
    nvAssert(pVpp);
    return ((pVpp->dwFlags & VPP_FLAG_CONSTRUCTED) != 0 );
}
extern NvU8 VppIsOverlayActive(Vpp_t *pVpp)
{
    nvAssert(pVpp);
    return ((pVpp->dwFlags & VPP_FLAG_OVERLAY_READY) != 0 );
}

// These substitute for the real constructor/destructor that we'd have in C++
static VppObjectRecord_t VppDefaultObjects[VPP_OBJECT_COUNT] =
{
    {VPP_OBJ_FREED, NV10_VIDEO_OVERLAY,            NV_VPP_OVERLAY_IID,         NV_VPP_OVERLAY_CONTEXT_IID,       3, NULL}, // May be NV4_OVERLAY
    {VPP_OBJ_NA,    NV04_SCALED_IMAGE_FROM_MEMORY, NV_VPP_SWIZZLE_BLIT_IID,    NV_VPP_SWIZZLE_BLIT_CONTEXT_IID,  1, NULL}, // Used on NV4/NV5 only
    {VPP_OBJ_NA,    NV01_TIMER,                    NV_VPP_TIMER_IID,           NV_VPP_TIMER_CONTEXT_IID,         2, NULL},
    {VPP_OBJ_FREED, NV04_IMAGE_BLIT,               NV_VPP_ALPHA_BLIT_IID,      NV_VPP_ALPHA_BLIT_CONTEXT_IID,    1, NULL},
    {VPP_OBJ_FREED, NV03_MEMORY_TO_MEMORY_FORMAT,  NV_VPP_V2V_FORMAT_Y_IID,    NV_VPP_V2V_FORMAT_Y_CONTEXT_IID,  2, NULL},
    {VPP_OBJ_FREED, NV03_MEMORY_TO_MEMORY_FORMAT,  NV_VPP_V2OSH_FORMAT_IID,    NV_VPP_V2OSH_FORMAT_CONTEXT_IID,  2, NULL},
    {VPP_OBJ_FREED, NV03_MEMORY_TO_MEMORY_FORMAT,  NV_VPP_OSH2V_FORMAT_IID,    NV_VPP_OSH2V_FORMAT_CONTEXT_IID,  2, NULL},
    {VPP_OBJ_FREED, NV10_SCALED_IMAGE_FROM_MEMORY, NV_VPP_SCALED_IMAGE1_IID,   NV_VPP_SCALED_IMAGE1_CONTEXT_IID, 1, NULL}, // will be NV4, NV5 or NV10
    {VPP_OBJ_FREED, NV10_SCALED_IMAGE_FROM_MEMORY, NV_VPP_SCALED_IMAGE2_IID,   NV_VPP_SCALED_IMAGE2_CONTEXT_IID, 1, NULL}, // will be NV4, NV5 or NV10
    {VPP_OBJ_FREED, NV03_MEMORY_TO_MEMORY_FORMAT,  NV_VPP_DMABLT_TO_VID_IID,   NV_VPP_DMABLT_TO_VID_CONTEXT_IID, 2, NULL},
    {VPP_OBJ_FREED, NV04_DVD_SUBPICTURE,           NV_VPP_DVD_SUBPICTURE_IID,  NV_VPP_DVD_SUBPICTURE_CONTEXT_IID,1, NULL}, // may upgrade to NV10

};

#ifdef ENABLE_VPP_DISPATCH_CODE
// This code is no longer used but may someday be useful.

//---------------------------------------------------------------------------
// vppDispatcher
//      Remote dispatcher for VppDoFlip
#define PDRIVERDATA     ((GLOBALDATA *)pData)
#define TIME_INFINITY   0x7FFFFFFF
LOCAL DWORD WINAPI vppDispatcher(Vpp_t *pVpp,LPVOID pData)
{
    // create signal
#if IS_WINNT5
    EngCreateEvent(&(vppDispatch.hSignalGo0));
    vppDispatch.hSignalGo3 = vppDispatch.hSignalGo0;
    EngCreateEvent(&(vppDispatch.hSignalDone0));
    vppDispatch.hSignalDone3 = vppDispatch.hSignalDone0;
#elif IS_WINNT4
    // Do something for NT4
#elif IS_WIN9X
    vppDispatch.hSignalGo3 = CreateEvent(NULL, TRUE, FALSE, EVENTNAME_DISPATCH_GO);
    vppDispatch.hSignalGo0 = ConvertRing3EventToRing0(vppDispatch.hSignalGo3);
    vppDispatch.hSignalDone3 = CreateEvent(NULL, FALSE, FALSE, EVENTNAME_DISPATCH_DONE);
    vppDispatch.hSignalDone0 = ConvertRing3EventToRing0(vppDispatch.hSignalDone3);
#endif
    if (vppDispatch.hSignalGo3 == NULL ||
        vppDispatch.hSignalGo0 == NULL ||
        vppDispatch.hSignalDone3 == NULL ||
        vppDispatch.hSignalDone0 == NULL) {

        vppDispatch.dwState |= VPPDSTATE_INITERROR | VPPDSTATE_TERMINATED;
        CLOSE_HANDLE(vppDispatch.hSignalGo3);
        CLOSE_HANDLE(vppDispatch.hSignalDone3);
        vppDispatch.hSignalGo3 = NULL;
        vppDispatch.hSignalGo0 = NULL;
        vppDispatch.hSignalDone3 = NULL;
        vppDispatch.hSignalDone0 = NULL;
        return -1;
    }

    vppDispatch.procInfo.hProcess = GetCurrentProcess();
    vppDispatch.procInfo.dwProcessId = nvGetCurrentProcessId();
    vppDispatch.dwOriginalThreadPriority = GetThreadPriority(GetCurrentThread());
    vppDispatch.dwOriginalProcessPriority = GetPriorityClass(GetCurrentProcess());

    vppDispatch.dwState &= ~VPPDSTATE_CMDERROR;
    vppDispatch.dwState &= ~VPPDSTATE_INITERROR;
    vppDispatch.dwState &= ~VPPDSTATE_TERMINATED;

    // explicitly reset these events, windows does not seem to set initial state properly
    VppResetNotification(NULL,vppDispatch.hSignalGo3);
    VppResetNotification(NULL,vppDispatch.hSignalDone3);

    while (vppDispatch.dwCommand != VPPDISPATCH_EXIT) {
        vppDispatch.dwState &= ~VPPDSTATE_BUSY;
        vppDispatch.dwState |= VPPDSTATE_WAITING;

        nvWaitEvent(vppDispatch.hSignalGo3, TIME_INFINITY);

        vppDispatch.dwState &= ~VPPDSTATE_WAITING;
        vppDispatch.dwState |= VPPDSTATE_BUSY;

        switch (vppDispatch.dwCommand) {
        case VPPDISPATCH_NOOP:
        case VPPDISPATCH_EXIT:
            break;

        case VPPDISPATCH_DISPATCH:
            vppDispatch.dwReturnCode = VppDoFlip(vppDispatch.dwOffset,
                                                                  vppDispatch.dwPitch,
                                                                  vppDispatch.dwWidth,
                                                                  vppDispatch.dwHeight,
                                                                  vppDispatch.dwFourCC,
                                                                  vppDispatch.dwFlags);
            vppDispatch.dwCommand = VPPDISPATCH_NOOP;
            break;

        case VPPDISPATCH_SETPRIORITY:
            SetThreadPriority(GetCurrentThread(), vppDispatch.dwThreadPriority);
            SetPriorityClass(GetCurrentProcess(), vppDispatch.dwProcessPriority);
            vppDispatch.dwCommand = VPPDISPATCH_NOOP;
            break;

        case VPPDISPATCH_RESTOREPRIORITY:
            SetThreadPriority(GetCurrentThread(), vppDispatch.dwOriginalThreadPriority);
            SetPriorityClass(GetCurrentProcess(), vppDispatch.dwOriginalProcessPriority);
            vppDispatch.dwCommand = VPPDISPATCH_NOOP;
            break;

        default:
            vppDispatch.dwState |= VPPDSTATE_CMDERROR;
            vppDispatch.dwCommand = VPPDISPATCH_NOOP;
            break;
        }

        VppResetNotification(NULL,vppDispatch.hSignalGo3);
        setEvent(NULL,vppDispatch.hSignalDone3);
    }

    SetThreadPriority(GetCurrentThread(), vppDispatch.dwOriginalThreadPriority);
    SetPriorityClass(GetCurrentProcess(), vppDispatch.dwOriginalProcessPriority);

    vppDispatch.dwState |= VPPDSTATE_TERMINATED;

    // destroy signal
    CLOSE_HANDLE((HANDLE)vppDispatch.hSignalGo3);
    vppDispatch.hSignalGo3 = NULL;
    vppDispatch.hSignalGo0 = NULL;
    CLOSE_HANDLE((HANDLE)vppDispatch.hSignalDone3);
    vppDispatch.hSignalDone3 = NULL;
    vppDispatch.hSignalDone0 = NULL;
    return 0;
}

//---------------------------------------------------------------------------
// vppInitDispatcher
//      Initializes vpp dispatcher, should be called from DriverInit
LOCAL BOOL vppInitDispatcher(Vpp_t *pVpp)
{
    vppDestroyDispatcher();

    vppDispatch.dwState = 0;
    vppDispatch.dwCommand = VPPDISPATCH_NOOP;

    vppDispatch.procInfo.hThread = CreateThread(NULL, 4096, vppDispatcher, pDriverData, 0, &vppDispatch.procInfo.dwThreadId);
    if (vppDispatch.procInfo.hThread == NULL) {
        vppDestroyDispatcher();
        return FALSE;
    }

    // may as well init some subpicture vars while we are here
    vpp.subPicture.originX = 0xFFFFFFFF;
    vpp.subPicture.originY = 0xFFFFFFFF;
    vpp.subPicture.width = 0xFFFFFFFF;
    vpp.subPicture.height = 0xFFFFFFFF;
    return TRUE;
}


//---------------------------------------------------------------------------
// vppDestroyDispatcher
//      Destroys vpp dispatcher, should be called from DestroyDriver
LOCAL void vppDestroyDispatcher(Vpp_t *pVpp)
{
    if (vppDispatch.procInfo.hThread) {
        HDRVEVENT vppSignalGo, vppSignalDone;

#if IS_WINNT5
        vppSignalGo   = vppDispatch.hSignalGo0;
        vppSignalDone = vppDispatch.hSignalDone0;
#elif IS_WINNT4
        // Do something here
#elif IS_WIN9X
        vppSignalGo   = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_DISPATCH_GO);
        vppSignalDone = OpenEvent(EVENT_ALL_ACCESS, TRUE, EVENTNAME_DISPATCH_DONE);
#endif
        vppDispatch.dwCommand = VPPDISPATCH_EXIT;
        NvSetEvent(vppSignalGo);
        VppWaitForNotification(NULL, vppSignalDone, 1000);
    }

    vppDispatch.dwState = VPPDSTATE_TERMINATED;
    vppDispatch.dwCommand = VPPDISPATCH_EXIT;
    vppDispatch.dwThreadPriority = THREAD_PRIORITY_IDLE;
    vppDispatch.dwProcessPriority = IDLE_PRIORITY_CLASS;
    vppDispatch.dwOriginalThreadPriority = 0;
    vppDispatch.dwOriginalProcessPriority = 0;
    vppDispatch.procInfo.hProcess = 0;
    vppDispatch.procInfo.hThread = 0;
    vppDispatch.procInfo.dwProcessId = 0;
    vppDispatch.procInfo.dwThreadId = 0;
    vppDispatch.hSignalGo0 = NULL;
    vppDispatch.hSignalGo3 = NULL;
    vppDispatch.hSignalDone0 = NULL;
    vppDispatch.hSignalDone3 = NULL;
    vppDispatch.dwOffset = 0;
    vppDispatch.dwPitch = 0;
    vppDispatch.dwWidth = 0;
    vppDispatch.dwHeight = 0;
    vppDispatch.dwFourCC = 0;
    vppDispatch.dwFlags = 0;
}

#endif

//
// VppGetVideoScalerBandwidthStatus
// TBD: this probably needs a better interface @mjl@.
//
extern NvU8 VppGetVideoScalerBandwidthStatus(Vpp_t *pVpp, NvU16 wWidth)
{
    Vpp_t &vpp = *pVpp;
    NvU32 dwGetDownScaleRatioX;
    NvU32 dwAllowed;

    nvAssert(vpp.dwFlags & VPP_FLAG_CONSTRUCTED);

    if (wWidth <= 768) {
        dwGetDownScaleRatioX = NV_CFG_VIDEO_DOWNSCALE_RATIO_768;
    } else if (wWidth <= 1280) {
        dwGetDownScaleRatioX = NV_CFG_VIDEO_DOWNSCALE_RATIO_1280;
    } else {
        dwGetDownScaleRatioX = NV_CFG_VIDEO_DOWNSCALE_RATIO_1920;
    }

    // Get max overlay downscale
    NvRmConfigGet(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle, 
        dwGetDownScaleRatioX, &(vpp.dwOverlayMaxDownScale));

    if (vpp.dwOverlayMaxDownScale == 0)
    {
        vpp.dwOverlayMaxDownScale = 1;  // this can be reported as zero on NV4
    }
    vpp.dwOverlayMaxDownScaleX = vpp.dwOverlayMaxDownScale;
    vpp.dwOverlayMaxDownScaleY = vpp.dwOverlayMaxDownScale;

    // Ask the resource manager if a video scaler is allowed within the current
    // resolution, given the current clocks and bandwidth limitations
    NvRmConfigGet(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                   NV_CFG_VIDEO_OVERLAY_ALLOWED, &(dwAllowed));

    return (dwAllowed ? TRUE : FALSE);
}

#ifdef WINNT
extern NvU8 VppConstructor(PDEV *ppdev, Vpp_t *pVpp, NV_SystemInfo_t *pSysInfo)
#else
extern NvU8 VppConstructor(GLOBALDATA *pDriverData, Vpp_t *pVpp, NV_SystemInfo_t *pSysInfo)
#endif
{
    Vpp_t &vpp = *pVpp;
    DWORD dwArch;
#ifdef WINNT
    GLOBALDATA *pDriverData = ppdev->pDriverData;
#endif

    nvAssert(pVpp);
    nvAssert(pSysInfo);

    if (VppIsConstructed(pVpp))
    {
        dbgError("VPP: VppConstructor being called again -- before destructor\n");
        return TRUE;
    }

    // Much up everything so that we can easily see uninitialized data
    memset(pVpp, 0,sizeof(*pVpp));

    vpp.pDriverData = pDriverData;  // Hopefully this will someday go away

#ifdef WINNT
    vpp.m_ppdev = ppdev;            // Hopefully this will someday go away
#else
    vpp.m_ppdev = NULL;             // Hopefully this will someday go away
#endif

    vpp.pSysInfo = pSysInfo;    // This is used early in nvpriv routines (by control panel) so it MUST
                                // be set early in VppConstructor (@ Driver Init time)
    vpp.dwDecoderIdentity = 0;
    vpp.dwDecoderCaps = 0;
    
    vpp.dwFlags = 0;
    vpp.m_pContextDMABase = 0;
    vpp.dwOverlayEventsAllocated = FALSE;
    vpp.pPusher = NULL;
    vpp.pThreeDClassLastUser = NULL;

    vpp.hImageBlackRect = NULL;
    vpp.hContextPattern = NULL;
    vpp.hContextRop = NULL;
    vpp.hContextColorKey = NULL;
    vpp.hFloatingContextDmaInOverlayShadow = NULL;
    vpp.hVideoMemUtoVideoMemFormat = NULL;
    vpp.hVideoMemVtoVideoMemFormat = NULL;
    vpp.hVideoMemUVtoVideoMemFormat = NULL;
    vpp.hLutCursorDacBase = NULL;
    vpp.hMiscEventNotifier = NULL;
    vpp.hContextSurfaceSwizzled = NULL;
    vpp.hContextBeta4 = NULL;
    vpp.hSurfaces2D = NULL;
    vpp.hChannel = NULL;
    vpp.hThreeDClass = NULL;
    vpp.hInVideoMemContextDma = NULL;
    vpp.hFromVideoMemContextDma = NULL;
    vpp.hToVideoMemContextDma = NULL;
    vpp.hThreeDClass = NULL;
    vpp.hContextSurfacesARGB_ZS = NULL;
    vpp.hDX6MultiTextureTriangle = NULL;

    vpp.pFlipPrimaryNotifier = NULL;
    vpp.pPusherSyncNotifier = NULL;

    vpp.ropRectTextSubCh = 0xffffffff;
    vpp.ropSubCh = 0xffffffff;
    vpp.spareSubCh = 0xffffffff;
    vpp.surfaces2DSubCh = 0xffffffff;
    vpp.threeDClassSubCh = 0xffffffff;

    vpp.dwOverlayFSNumSurfaces = 0;
    vpp.dwOverlayFSOvlLost = FALSE;

    vpp.dwOverlayFSWidth     = 0;
    vpp.dwOverlayFSHeight    = 0;
    vpp.dwOverlayFSPitch     = 0;
    vpp.dwOverlayFSFormat    = 0;
    vpp.dwOverlayFSIndex     = 0;
    vpp.dwOverlayFSDeltaX    = 0;
    vpp.dwOverlayFSDeltaY    = 0;

    memset(&(vpp.dwOverlayFSOffset),0,sizeof(vpp.dwOverlayFSOffset));  // Init arrays to zero
    memset(&(vpp.extraOverlayOffset),0,sizeof(vpp.extraOverlayOffset));
    memset(&(vpp.dwOverlaySurfaceLCL),0,sizeof(vpp.dwOverlaySurfaceLCL));

    vpp.extraPitch       = 0;
    vpp.extraNumSurfaces = 0;
    vpp.extraIndex       = 0;

    vpp.dwOverlaySrcWidth  = 0;
    vpp.dwOverlaySrcHeight = 0;
    vpp.dwOverlayDstWidth  = 0;
    vpp.dwOverlayDstHeight = 0;
    vpp.dwOverlayDeltaX    = 0;
    vpp.dwOverlayDeltaY    = 0;

    vpp.dwOverlaySrcX      = 0;
    vpp.dwOverlaySrcY      = 0;
    vpp.dwOverlayDstX      = 0;
    vpp.dwOverlayDstY      = 0;
    vpp.dwOverlaySrcOffset = 0;
    vpp.dwOverlayFormat    = 0;
    vpp.dwOverlaySrcPitch  = 0;

    vpp.dwOverlayLastVisibleFpVidMem    = 0xffffffff;
    vpp.dwOverlayLastVisiblePitch       = 0xffffffff;
    vpp.dwOverlayLastVisiblePixelFormat = 0xffffffff;
    vpp.dwOverlayFlipCount              = 0;
    vpp.overlayBufferIndex              = 0;
    vpp.overlayRelaxOwnerCheck          = FALSE;
    vpp.dwOverlaySrcSize                = 0;
    vpp.dwOverlayColorKey               = 0;
    vpp.dwOverlaySrcPitch               = 0;
    vpp.dwOverlayCachedFlags            = 0;
    vpp.dwOverlayFSSrcWidth             = 0;
    vpp.dwOverlayFSSrcHeight            = 0;
    vpp.dwOverlayFSSrcMinX              = 0;
    vpp.dwOverlayFSSrcMinY              = 0;
    vpp.dwOverlayMaxDownScale           = 0;
    vpp.dwOverlayMaxDownScaleX          = 0;
    vpp.dwOverlayMaxDownScaleY          = 0;
    vpp.regRing0ColourCtlInterlockFlags = 0;

    memset(&(vpp.dwOverlayFSTwinData), 0,sizeof(vpp.dwOverlayFSTwinData));

    vpp.dwOverlayMode     = 0;
    vpp.dwPrevFrameOffset = 0;
    vpp.llDeliveryPeriod  = 0;
    vpp.llDeliveryTime    = 0;
    vpp.llDeliveryStart   = 0;

    memset(&(vpp.subPicture),0x0,sizeof(vpp.subPicture));
    memset(&(vpp.pipeState),0x0,sizeof(vpp.pipeState));
    memset(&(vpp.snoop),0x0,sizeof(vpp.snoop));

    // Initialize overlay alignment.

    if (NvRmConfigGet(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle, NV_CFG_ARCHITECTURE, &dwArch) != NVOS_CGE_STATUS_SUCCESS)
    {
        dbgError("Failed to query arch from RM in VPP constructor!");
        return FALSE;
	}

    if (dwArch >= 5) { // NV10
        vpp.dwOverlayByteAlignmentPad = NV_OVERLAY_BYTE_ALIGNMENT_PAD;
    }
    else {
        vpp.dwOverlayByteAlignmentPad = vpp.pDriverData->dwSurfaceAlignPad;
    }

    vpp.dwOverlaySurfaces              = 0;
    vpp.dwOverlayLastVisibleSurfaceLCL = 0;
    vpp.dwOverlayFSOvlHead             = 0xFFFFFFFF;
    vpp.dwOverlayFSOvlHeadSaved        = 0xFFFFFFFF;

    vpp.colorCtrl.dwSize = sizeof(vpp.colorCtrl);
    vpp.colorCtrl.dwFlags = NV_VPP_COLOR_BRIGHTNESS |
                            NV_VPP_COLOR_CONTRAST   |
                            NV_VPP_COLOR_SATURATION |
                            NV_VPP_COLOR_HUE;
    vpp.colorCtrl.lSharpness  = 0;
    vpp.colorCtrl.lHue        = 0;
    vpp.colorCtrl.dwReserved1 = 0;

    // Initialize overlay color control data to default Microsoft values
    if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10)
    {
        vpp.colorCtrl.lBrightness  =    0;
        vpp.colorCtrl.lContrast    =  255;
        vpp.colorCtrl.lHue         =    0;
        vpp.colorCtrl.lSaturation  =  256;
        vpp.colorCtrl.lGamma       =  255;
        vpp.colorCtrl.lColorEnable =    1;
        vpp.subPicture.format      = NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT;
    }
    else
    {
        vpp.colorCtrl.lBrightness  =   750;
        vpp.colorCtrl.lContrast    = 10000;
        vpp.colorCtrl.lSaturation  = 10000;
        vpp.colorCtrl.lGamma       =     0;
        vpp.colorCtrl.lColorEnable =     0;
        vpp.subPicture.format      = NV088_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT;
    }

    vpp.fpOverlayShadow = 0;
    vpp.dwOverlayFSHead = 0xFFFFFFFF;

    // Overlay colour control stuff
    vpp.regOverlayColourControlEnable = 0;
    vpp.regOverlayMode    = 0;
    vpp.regOverlayMode2   = NV4_REG_OVL_MODE2_FSASPECT | NV4_REG_OVL_MODE2_FSTRACKOVLASPECT | NV4_REG_OVL_MODE2_FSSETMODE;
    vpp.regOverlayMode3   = 0;
    vpp.regVPPInvMask     = 0;
    vpp.regVPPMaxSurfaces = NV_VPP_MAX_EXTRA_SURFACES;

    memcpy(vpp.m_obj_a,&VppDefaultObjects,sizeof(VppDefaultObjects));

    if (vpp.pSysInfo->dwNVClasses & NVCLASS_0088_DVDPICT)
    {
        vpp.m_obj_a[DVDPICT_NDX].classNdx = NV10_DVD_SUBPICTURE;
    }
    else
    {
        nvAssert(vpp.pSysInfo->dwNVClasses & NVCLASS_0038_DVDPICT);
    }

    // Select the SCALED_IMAGE class based on what we have (in order of preference)
    if      (vpp.pSysInfo->dwNVClasses & NVCLASS_0089_SCALEDIMG) vpp.m_obj_a[SCALED_IMAGE1_NDX].classNdx = NV10_SCALED_IMAGE_FROM_MEMORY;
    else if (vpp.pSysInfo->dwNVClasses & NVCLASS_0063_SCALEDIMG) vpp.m_obj_a[SCALED_IMAGE1_NDX].classNdx = NV05_SCALED_IMAGE_FROM_MEMORY;
    else if (vpp.pSysInfo->dwNVClasses & NVCLASS_0077_SCALEDIMG) vpp.m_obj_a[SCALED_IMAGE1_NDX].classNdx = NV04_SCALED_IMAGE_FROM_MEMORY;
    vpp.m_obj_a[SCALED_IMAGE2_NDX].classNdx = vpp.m_obj_a[SCALED_IMAGE1_NDX].classNdx;

    // For NV4 & NV5:
    //
    // Can't have more than one surfaces type for each channel, so share NV_DD_SURFACES_2D,
    //  D3D_CONTEXT_SURFACE_SWIZZLED, and vpp.hContextSurfacesARGB_ZS instead of using
    //      objects comment out below
    //   For NV_DD_SURFACES_2D_A8R8G8B8, we only change the pixel depth so be sure to restore that
    //   For NV_DD_SURFACES_3D, call nvSetD3DSurfaceState(pContext) to restore
    //   For NV_DD_SURFACES_SWIZZLED, D3D restores its state on each usage, ok to dirty it
    //
    // @mjl@ the above are probably out of date... TBD

    if (vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_KELVIN)
    {
        vpp.dwFlags |= VPP_FLAG_KELVIN_3D;
    }
    else if (vpp.pSysInfo->dwNVClasses & NVCLASS_FAMILY_CELSIUS)
    {
        vpp.dwFlags |= VPP_FLAG_CELSIUS_3D;
    }
    else
    {
        vpp.m_obj_a[OVERLAY_NDX].classNdx = NV04_VIDEO_OVERLAY; // Used NV04 overlay instead of NV10
        vpp.m_obj_a[SWIZZLE_NDX].status   = VPP_OBJ_FREED;      // 'Enables' this object
    }

    // If we have the timer class, turn it on
    if (vpp.pSysInfo->dwNVClasses & NVCLASS_0004_TIMER)
    {
        vpp.m_obj_a[TIMER_NDX].status = VPP_OBJ_FREED;      // 'Enables' this object
    }
    
    if (!vppAllocateContextDMAs(pVpp))
    {
        dbgError("Failed to allocate a context DMA in VPP constructor!");
        return FALSE;
    }

    vpp.dwFlags |= VPP_FLAG_CONSTRUCTED; // Construction is done

	return TRUE;
}

void VppDestructor(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;

    if (!VppIsConstructed(pVpp)) return;    // This can occur under special circumstance

    vppFreeContextDMAs(pVpp);

    if (vpp.fpOverlayShadow) {
        FreeIPM((void*)vpp.fpOverlayShadow);
    }

    // Wreck the data in VPP to make sure we don't make use of it somehow
    //  NB: This implicitly clears VPP_FLAG_CONSTRUCTED
    memset(pVpp, 0,sizeof(*pVpp));
}

//------------------------------------------------------------------------------
// some utility functions to manage switching between using notifiers and events
//
// These are not meant to be called by the general driver, but only the nvPriv
//

extern int VppWaitForNotification(NvNotification* pNotify, HDRVEVENT hEvent, unsigned long timeOut)
{
#ifdef VPP_USE_EVENT_NOTIFIERS
    nvAssert(hEvent);

    if (IS_EVENT_ERROR(NvWaitEvent(hEvent, timeOut)))
    {
        return -1;
    }
#else
    unsigned long count = timeOut;
    nvAssert(pNotify);

#ifdef IKOS
    while(pNotify->status == NV_IN_PROGRESS) // on IKOS we'll ignore timeOut; could be a very long time
#else
    while( (count>0) && (pNotify->status == NV_IN_PROGRESS) )
#endif
    {
        // TBD: find out how VPP_TIMEOUT_TIME was derived.  Use pSysInfo->dwSpinLoopCount instead perhaps @mjl@
        nvSpin(timeOut);
        count--;
    }
#endif
    return 0;
}

extern void VppResetNotification(NvNotification* pNotify, HDRVEVENT hEvent)
{
#ifdef VPP_USE_EVENT_NOTIFIERS
    nvAssert(hEvent);
    NvResetEvent(hEvent);
#else
    nvAssert(pNotify);
    pNotify->status = NV_IN_PROGRESS;
#endif
}

#if (NVARCH >= 0x10)
//---------------------------------------------------------------------------
// vppInitCelsius
//      Inits celsius object for temporal filter usage.  Celsius is a shared,
//      cached object, so these methods only get set when we are a new consumer
LOCAL BOOL vppInitCelsius(Vpp_t *pVpp)
{
    DWORD tmpVal;
    float fBuffer[16];
    unsigned long *ftol = (unsigned long *)&fBuffer[0];
    float xTrans, yTrans, zTrans;
    Vpp_t &vpp = *pVpp;

#if (NVARCH >= 0x20)
    nvAssert (!(vpp.dwFlags & VPP_FLAG_KELVIN_3D));
#endif
    nvAssert(vpp.dwFlags & VPP_FLAG_CELSIUS_3D);

    nvAssert(vpp.pThreeDClassLastUser);
    *vpp.pThreeDClassLastUser = MODULE_ID_DDRAW_VPP;

    // Let D3D code know that we have touched NV
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    // Set object
    vpp.pPusher->setObject(vpp.threeDClassSubCh,vpp.hThreeDClass);

    if (vpp.dwFlags & VPP_FLAG_CELSIUS_3D)
    {
        NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

        // Reset the celsius context Dmas to use the default video context Dma
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_CONTEXT_DMA_A | 0x40000);
        vpp.pPusher->push(1, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_CONTEXT_DMA_B | 0x40000);
        vpp.pPusher->push(3, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_CONTEXT_DMA_VERTEX | 0x40000);
        vpp.pPusher->push(5, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_CONTEXT_DMA_STATE | 0x40000);
        vpp.pPusher->push(7, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(8, subchannel +
                      NV056_SET_CONTEXT_DMA_COLOR | 0x40000);
        vpp.pPusher->push(9, vpp.hInVideoMemContextDma);

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_CONTEXT_DMA_ZETA | 0x40000);
        vpp.pPusher->push(11, vpp.hInVideoMemContextDma);

        vpp.pPusher->adjust(12);

        // Set up one window clip rectangle to be the rendered area
        // All the other rectangles are deactivated
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_WINDOW_CLIP_HORIZONTAL(0) | 0x200000);
        vpp.pPusher->push(1, ((2047 << 16) | (-2048 & 0xfff)));
        vpp.pPusher->push(2, 0);
        vpp.pPusher->push(3, 0);
        vpp.pPusher->push(4, 0);
        vpp.pPusher->push(5, 0);
        vpp.pPusher->push(6, 0);
        vpp.pPusher->push(7, 0);
        vpp.pPusher->push(8, 0);

        vpp.pPusher->push(9, subchannel +
                      NV056_SET_WINDOW_CLIP_VERTICAL(0) | 0x200000);
        vpp.pPusher->push(10, ((2047 << 16) | (-2048 & 0xfff)));
        vpp.pPusher->push(11, 0);
        vpp.pPusher->push(12, 0);
        vpp.pPusher->push(13, 0);
        vpp.pPusher->push(14, 0);
        vpp.pPusher->push(15, 0);
        vpp.pPusher->push(16, 0);
        vpp.pPusher->push(17, 0);

        vpp.pPusher->push(18, subchannel +
                       NV056_SET_WINDOW_CLIP_TYPE | 0x40000);
        vpp.pPusher->push(19, NV056_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);
        vpp.pPusher->adjust(20);

        // Enable transforms
        tmpVal = (NV056_SET_TLMODE_W_DIVIDE_1_DISABLE << 2) |
                 (NV056_SET_TLMODE_W_DIVIDE_0_DISABLE << 1) |
                  NV056_SET_TLMODE_PASSTHROUGH_FALSE;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TLMODE | 0x40000);
        vpp.pPusher->push(1, tmpVal);
        vpp.pPusher->adjust(2);

        // Set Control0 defaults
        tmpVal = (NV056_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE << 24) |
                 (NV056_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE << 20) |
                 (NV056_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 16) |
                 (NV056_SET_CONTROL0_Z_FORMAT_FIXED << 12) |
                 (NV056_SET_CONTROL0_WBUFFER_SELECT_0 << 8) |
                 (NV056_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE);

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_CONTROL0 | 0x40000);
        vpp.pPusher->push(1, tmpVal);

        vpp.pPusher->adjust(2);

        // Load ModelView matrix and inverse ModelView matrix with identity
        fBuffer[0]  = 1.0; fBuffer[1]  = 0.0; fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0; fBuffer[5]  = 1.0; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0; fBuffer[9]  = 0.0; fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0; fBuffer[13] = 0.0; fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_MODEL_VIEW_MATRIX0(0) | 0x400000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[4]);
        vpp.pPusher->push(3, ftol[8]);
        vpp.pPusher->push(4, ftol[12]);
        vpp.pPusher->push(5, ftol[1]);
        vpp.pPusher->push(6, ftol[5]);
        vpp.pPusher->push(7, ftol[9]);
        vpp.pPusher->push(8, ftol[13]);
        vpp.pPusher->push(9, ftol[2]);
        vpp.pPusher->push(10, ftol[6]);
        vpp.pPusher->push(11, ftol[10]);
        vpp.pPusher->push(12, ftol[14]);
        vpp.pPusher->push(13, ftol[3]);
        vpp.pPusher->push(14, ftol[7]);
        vpp.pPusher->push(15, ftol[11]);
        vpp.pPusher->push(16, ftol[15]);

        vpp.pPusher->push(17, subchannel +
                       NV056_SET_INVERSE_MODEL_VIEW_MATRIX0(0) | 0x400000);
        vpp.pPusher->push(18, ftol[0]);
        vpp.pPusher->push(19, ftol[4]);
        vpp.pPusher->push(20, ftol[8]);
        vpp.pPusher->push(21, ftol[12]);
        vpp.pPusher->push(22, ftol[1]);
        vpp.pPusher->push(23, ftol[5]);
        vpp.pPusher->push(24, ftol[9]);
        vpp.pPusher->push(25, ftol[13]);
        vpp.pPusher->push(26, ftol[2]);
        vpp.pPusher->push(27, ftol[6]);
        vpp.pPusher->push(28, ftol[10]);
        vpp.pPusher->push(29, ftol[14]);
        vpp.pPusher->push(30, ftol[3]);
        vpp.pPusher->push(31, ftol[7]);
        vpp.pPusher->push(32, ftol[11]);
        vpp.pPusher->push(33, ftol[15]);

        vpp.pPusher->adjust(34);

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_SURFACE_FORMAT | 0x40000);
        vpp.pPusher->push(1, (NV056_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
                       NV056_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8);
        vpp.pPusher->adjust(2);

        // Set up viewport
        xTrans = (float)(-2048.0 - (1.0 / 32.0)); // hardware epsilon
        yTrans = (float)(-2048.0 - (1.0 / 32.0));
        zTrans = 0.0;

        // Load composite matrix assuming full pel scaling of surface coordinates
        fBuffer[0]  = 0.25; // quarter pel xScale
        fBuffer[1]  = 0.0;
        fBuffer[2]  = 0.0;
        fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;
        fBuffer[5]  = 0.25; // quarter pel pel yScale
        fBuffer[6]  = 0.0;
        fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;
        fBuffer[9]  = 0.0;
        fBuffer[10] = 1.0;
        fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;
        fBuffer[13] = 0.0;
        fBuffer[14] = 0.0;
        fBuffer[15] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_COMPOSITE_MATRIX(0) | 0x400000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[4]);
        vpp.pPusher->push(3, ftol[8]);
        vpp.pPusher->push(4, ftol[12]);
        vpp.pPusher->push(5, ftol[1]);
        vpp.pPusher->push(6, ftol[5]);
        vpp.pPusher->push(7, ftol[9]);
        vpp.pPusher->push(8, ftol[13]);
        vpp.pPusher->push(9, ftol[2]);
        vpp.pPusher->push(10, ftol[6]);
        vpp.pPusher->push(11, ftol[10]);
        vpp.pPusher->push(12, ftol[14]);
        vpp.pPusher->push(13, ftol[3]);
        vpp.pPusher->push(14, ftol[7]);
        vpp.pPusher->push(15, ftol[11]);
        vpp.pPusher->push(16, ftol[15]);

        vpp.pPusher->adjust(17);

        // Set viewport offset separately
        fBuffer[0] = xTrans;
        fBuffer[1] = yTrans;
        fBuffer[2] = zTrans;
        fBuffer[3] = 0.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_VIEWPORT_OFFSET(0) | 0x100000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[1]);
        vpp.pPusher->push(3, ftol[2]);
        vpp.pPusher->push(4, ftol[3]);

        vpp.pPusher->adjust(5);

        // Set front and back clipping
        fBuffer[0] = 0.0;
        fBuffer[1] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_CLIP_MIN | 0x80000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[1]);

        vpp.pPusher->adjust(3);

        // Disable almost everything

        // Disable alpha test
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_ALPHA_TEST_ENABLE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_ALPHA_TEST_ENABLE_V_FALSE);

        // Disable blending
        vpp.pPusher->push(2, subchannel +
                      NV056_SET_BLEND_ENABLE | 0x40000);
        vpp.pPusher->push(3, NV056_SET_BLEND_ENABLE_V_FALSE);

        // Disable culling
        vpp.pPusher->push(4, subchannel +
                      NV056_SET_CULL_FACE_ENABLE | 0x40000);
        vpp.pPusher->push(5, NV056_SET_CULL_FACE_ENABLE_V_FALSE);

        // Disable depth test
        vpp.pPusher->push(6, subchannel +
                      NV056_SET_DEPTH_TEST_ENABLE | 0x40000);
        vpp.pPusher->push(7, NV056_SET_DEPTH_TEST_ENABLE_V_FALSE);

        // Disable dither
        vpp.pPusher->push(8, subchannel +
                      NV056_SET_DITHER_ENABLE | 0x40000);
        vpp.pPusher->push(9, NV056_SET_DITHER_ENABLE_V_FALSE);

        // Disable lighting
        vpp.pPusher->push(10, subchannel +
                       NV056_SET_LIGHTING_ENABLE | 0x40000);
        vpp.pPusher->push(11, NV056_SET_LIGHTING_ENABLE_V_FALSE);

        // Disable point parameters computation
        vpp.pPusher->push(12, subchannel +
                       NV056_SET_POINT_PARAMS_ENABLE | 0x40000);
        vpp.pPusher->push(13, NV056_SET_POINT_PARAMS_ENABLE_V_FALSE);

        // Disable point smoothing
        vpp.pPusher->push(14, subchannel +
                       NV056_SET_POINT_SMOOTH_ENABLE | 0x40000);
        vpp.pPusher->push(15, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);

        // Disable line smoothing
        vpp.pPusher->push(16, subchannel +
                       NV056_SET_LINE_SMOOTH_ENABLE | 0x40000);
        vpp.pPusher->push(17, NV056_SET_LINE_SMOOTH_ENABLE_V_FALSE);

        // Disable polygon smoothing
        vpp.pPusher->push(18, subchannel +
                       NV056_SET_POLY_SMOOTH_ENABLE | 0x40000);
        vpp.pPusher->push(19, NV056_SET_POLY_SMOOTH_ENABLE_V_FALSE);

        // Disable skinning
        vpp.pPusher->push(20, subchannel +
                       NV056_SET_SKIN_ENABLE | 0x40000);
        vpp.pPusher->push(21, NV056_SET_SKIN_ENABLE_V_FALSE);

        // Disable stencil test
        vpp.pPusher->push(22, subchannel +
                       NV056_SET_STENCIL_TEST_ENABLE | 0x40000);
        vpp.pPusher->push(23, NV056_SET_STENCIL_TEST_ENABLE_V_FALSE);

        // Disable polygon offset point
        vpp.pPusher->push(24, subchannel +
                       NV056_SET_POLY_OFFSET_POINT_ENABLE | 0x40000);
        vpp.pPusher->push(25, NV056_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);

        // Disable polygon offset line
        vpp.pPusher->push(26, subchannel +
                       NV056_SET_POLY_OFFSET_LINE_ENABLE | 0x40000);
        vpp.pPusher->push(27, NV056_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);

        // Disable polygon offset fill
        vpp.pPusher->push(28, subchannel +
                       NV056_SET_POLY_OFFSET_FILL_ENABLE | 0x40000);
        vpp.pPusher->push(29, NV056_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);

        vpp.pPusher->adjust(30);

        // Set light control
        tmpVal = (NV056_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE << 1) |
                  NV056_SET_LIGHT_CONTROL_SECONDARY_COLOR_EN_FALSE;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_LIGHT_CONTROL | 0x40000);
        vpp.pPusher->push(1, tmpVal);

        // Disable color material
        vpp.pPusher->push(2, subchannel +
                      NV056_SET_COLOR_MATERIAL | 0x40000);
        vpp.pPusher->push(3, NV056_SET_COLOR_MATERIAL_V_DISABLED);

        // Set material emission
        fBuffer[0] = 0.0;

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_MATERIAL_EMISSION(0) | 0xC0000);
        vpp.pPusher->push(5, ftol[0]);
        vpp.pPusher->push(6, ftol[0]);
        vpp.pPusher->push(7, ftol[0]);

        // Disable specular
        vpp.pPusher->push(8, subchannel +
                      NV056_SET_SPECULAR_ENABLE | 0x40000);
        vpp.pPusher->push(9, NV056_SET_SPECULAR_ENABLE_V_FALSE);

        // Disable all lights
        vpp.pPusher->push(10, subchannel +
                       NV056_SET_LIGHT_ENABLE_MASK | 0x40000);
        vpp.pPusher->push(11, 0);

        vpp.pPusher->adjust(12);

        // Disable texgen modes for now (OpenGL default is EYE_LINEAR)

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXGEN_S(0) | 0x40000);
        vpp.pPusher->push(1, NV056_SET_TEXGEN_S_V_DISABLE);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_TEXGEN_T(0) | 0x40000);
        vpp.pPusher->push(3, NV056_SET_TEXGEN_T_V_DISABLE);

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_TEXGEN_R(0) | 0x40000);
        vpp.pPusher->push(5, NV056_SET_TEXGEN_R_V_DISABLE);

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_TEXGEN_Q(0) | 0x40000);
        vpp.pPusher->push(7, NV056_SET_TEXGEN_Q_V_DISABLE);

        vpp.pPusher->push(8, subchannel +
                      NV056_SET_TEXGEN_S(1) | 0x40000);
        vpp.pPusher->push(9, NV056_SET_TEXGEN_S_V_DISABLE);

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_TEXGEN_T(1) | 0x40000);
        vpp.pPusher->push(11, NV056_SET_TEXGEN_T_V_DISABLE);

        vpp.pPusher->push(12, subchannel +
                       NV056_SET_TEXGEN_R(1) | 0x40000);
        vpp.pPusher->push(13, NV056_SET_TEXGEN_R_V_DISABLE);

        vpp.pPusher->push(14, subchannel +
                       NV056_SET_TEXGEN_Q(1) | 0x40000);
        vpp.pPusher->push(15, NV056_SET_TEXGEN_Q_V_DISABLE);

        vpp.pPusher->adjust(16);

        // Set default texgen planes
        fBuffer[0] = 0.0;
        fBuffer[1] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXGEN_SPLANE0(0) | 0x100000);
        vpp.pPusher->push(1, ftol[1]);
        vpp.pPusher->push(2, ftol[0]);
        vpp.pPusher->push(3, ftol[0]);
        vpp.pPusher->push(4, ftol[0]);

        vpp.pPusher->push(5, subchannel +
                      NV056_SET_TEXGEN_TPLANE0(0) | 0x100000);
        vpp.pPusher->push(6, ftol[0]);
        vpp.pPusher->push(7, ftol[1]);
        vpp.pPusher->push(8, ftol[0]);
        vpp.pPusher->push(9, ftol[0]);

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_TEXGEN_RPLANE0(0) | 0x100000);
        vpp.pPusher->push(11, ftol[0]);
        vpp.pPusher->push(12, ftol[0]);
        vpp.pPusher->push(13, ftol[0]);
        vpp.pPusher->push(14, ftol[0]);

        vpp.pPusher->push(15, subchannel +
                       NV056_SET_TEXGEN_QPLANE0(0) | 0x100000);
        vpp.pPusher->push(16, ftol[0]);
        vpp.pPusher->push(17, ftol[0]);
        vpp.pPusher->push(18, ftol[0]);
        vpp.pPusher->push(19, ftol[0]);

        vpp.pPusher->push(20, subchannel +
                       NV056_SET_TEXGEN_SPLANE1(0) | 0x100000);
        vpp.pPusher->push(21, ftol[1]);
        vpp.pPusher->push(22, ftol[0]);
        vpp.pPusher->push(23, ftol[0]);
        vpp.pPusher->push(24, ftol[0]);

        vpp.pPusher->push(25, subchannel +
                       NV056_SET_TEXGEN_TPLANE1(0) | 0x100000);
        vpp.pPusher->push(26, ftol[0]);
        vpp.pPusher->push(27, ftol[1]);
        vpp.pPusher->push(28, ftol[0]);
        vpp.pPusher->push(29, ftol[0]);

        vpp.pPusher->push(30, subchannel +
                       NV056_SET_TEXGEN_RPLANE1(0) | 0x100000);
        vpp.pPusher->push(31, ftol[0]);
        vpp.pPusher->push(32, ftol[0]);
        vpp.pPusher->push(33, ftol[0]);
        vpp.pPusher->push(34, ftol[0]);

        vpp.pPusher->push(35, subchannel +
                       NV056_SET_TEXGEN_QPLANE1(0) | 0x100000);
        vpp.pPusher->push(36, ftol[0]);
        vpp.pPusher->push(37, ftol[0]);
        vpp.pPusher->push(38, ftol[0]);
        vpp.pPusher->push(39, ftol[0]);

        vpp.pPusher->adjust(40);

        // Set default fog mode
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_FOG_MODE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_FOG_MODE_FOG_MODE_LINEAR);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_FOG_GEN_MODE | 0x40000);
        vpp.pPusher->push(3, NV056_SET_FOG_GEN_MODE_FOG_GEN_MODE_USE_INPUT);

        // Disable fog
        vpp.pPusher->push(4, subchannel +
                      NV056_SET_FOG_ENABLE | 0x40000);
        vpp.pPusher->push(5, NV056_SET_FOG_ENABLE_V_FALSE);

        // Set default fog parameters
        fBuffer[0] = 1.0;                           // K0
        fBuffer[1] = 1.0;                           // K1
        fBuffer[2] = 0.0;                           // K2

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_FOG_PARAMS(0) | 0xC0000);
        vpp.pPusher->push(7, ftol[0]);
        vpp.pPusher->push(8, ftol[1]);
        vpp.pPusher->push(9, ftol[2]);

        // Set default fog color
        vpp.pPusher->push(10, subchannel +
                       NV056_SET_FOG_COLOR | 0x40000);
        vpp.pPusher->push(11, 0xFFFFFFFF);

        vpp.pPusher->adjust(12);

        // Set default alpha function
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_ALPHA_FUNC | 0x40000);
        vpp.pPusher->push(1, NV056_SET_ALPHA_FUNC_V_ALWAYS);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_ALPHA_REF | 0x40000);
        vpp.pPusher->push(3, 0);

        // Set default blend equation
        vpp.pPusher->push(4, subchannel +
                      NV056_SET_BLEND_EQUATION | 0x40000);
        vpp.pPusher->push(5, NV056_SET_BLEND_EQUATION_V_FUNC_ADD);

        // Set default blend color
        vpp.pPusher->push(6, subchannel +
                      NV056_SET_BLEND_COLOR | 0x40000);
        vpp.pPusher->push(7, 0);

        // Set default blend func source factor
        vpp.pPusher->push(8, subchannel +
                      NV056_SET_BLEND_FUNC_SFACTOR | 0x40000);
        vpp.pPusher->push(9, NV056_SET_BLEND_FUNC_SFACTOR_V_ONE);

        // Set default blend func destination factor
        vpp.pPusher->push(10, subchannel +
                       NV056_SET_BLEND_FUNC_DFACTOR | 0x40000);
        vpp.pPusher->push(11, NV056_SET_BLEND_FUNC_DFACTOR_V_ZERO);

        vpp.pPusher->adjust(12);

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_FRONT_FACE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_FRONT_FACE_V_CCW);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_CULL_FACE | 0x40000);
        vpp.pPusher->push(3, NV056_SET_CULL_FACE_V_BACK);

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_SHADE_MODE | 0x40000);
        vpp.pPusher->push(5, NV056_SET_SHADE_MODE_V_SMOOTH);

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_FRONT_POLYGON_MODE | 0x40000);
        vpp.pPusher->push(7, NV056_SET_FRONT_POLYGON_MODE_V_FILL);

        vpp.pPusher->push(8, subchannel +
                      NV056_SET_BACK_POLYGON_MODE | 0x40000);
        vpp.pPusher->push(9, NV056_SET_BACK_POLYGON_MODE_V_FILL);

        fBuffer[0] = 0.0;

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_POLYGON_OFFSET_SCALE_FACTOR | 0x40000);
        vpp.pPusher->push(11, ftol[0]);

        vpp.pPusher->push(12, subchannel +
                       NV056_SET_POLYGON_OFFSET_BIAS | 0x40000);
        vpp.pPusher->push(13, ftol[0]);

        vpp.pPusher->push(14, subchannel +
                       NV056_SET_EDGE_FLAG | 0x40000);
        vpp.pPusher->push(15, 1);

        vpp.pPusher->adjust(16);

        // Initialize some vertex attributes
        fBuffer[0] = 0.0;
        fBuffer[1] = 1.0;

        // Set color for MODULATE blend mode
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_DIFFUSE_COLOR4F(0) | 0x100000);
        vpp.pPusher->push(1, ftol[1]);
        vpp.pPusher->push(2, ftol[1]);
        vpp.pPusher->push(3, ftol[1]);
        vpp.pPusher->push(4, ftol[1]);

        vpp.pPusher->push(5, subchannel +
                      NV056_SET_SPECULAR_COLOR3F(0) | 0xC0000);
        vpp.pPusher->push(6, ftol[0]);
        vpp.pPusher->push(7, ftol[0]);
        vpp.pPusher->push(8, ftol[0]);

        vpp.pPusher->push(9, subchannel +
                      NV056_SET_TEXCOORD0_4F(0) | 0x100000);
        vpp.pPusher->push(10, ftol[0]);
        vpp.pPusher->push(11, ftol[0]);
        vpp.pPusher->push(12, ftol[0]);
        vpp.pPusher->push(13, ftol[1]);

        vpp.pPusher->push(14, subchannel +
                       NV056_SET_TEXCOORD1_4F(0) | 0x100000);
        vpp.pPusher->push(15, ftol[0]);
        vpp.pPusher->push(16, ftol[0]);
        vpp.pPusher->push(17, ftol[0]);
        vpp.pPusher->push(18, ftol[1]);

        vpp.pPusher->push(19, subchannel +
                       NV056_SET_NORMAL3F(0) | 0xC0000);
        vpp.pPusher->push(20, ftol[0]);
        vpp.pPusher->push(21, ftol[0]);
        vpp.pPusher->push(22, ftol[1]);

        vpp.pPusher->push(23, subchannel +
                       NV056_SET_FOG1F | 0x40000);
        vpp.pPusher->push(24, ftol[0]);

        vpp.pPusher->push(25, subchannel +
                       NV056_SET_WEIGHT1F | 0x40000);
        vpp.pPusher->push(26, ftol[1]);

        vpp.pPusher->adjust(27);

        // Set depth function
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_DEPTH_FUNC | 0x40000);
        vpp.pPusher->push(1, NV056_SET_DEPTH_FUNC_V_ALWAYS);

        // Set color mask
        tmpVal = (NV056_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE << 24) |
                 (NV056_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE << 16) |
                 (NV056_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE << 8) |
                  NV056_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE;

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_COLOR_MASK | 0x40000);
        vpp.pPusher->push(3, tmpVal);

        // Set depth mask
        vpp.pPusher->push(4, subchannel +
                      NV056_SET_DEPTH_MASK | 0x40000);
        vpp.pPusher->push(5, NV056_SET_DEPTH_MASK_V_FALSE);

        vpp.pPusher->adjust(6);

        // Initialize stencil state (test already disabled above)
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_STENCIL_FUNC | 0x40000);
        vpp.pPusher->push(1, NV056_SET_STENCIL_FUNC_V_ALWAYS);

        vpp.pPusher->push(2, subchannel +
                      NV056_SET_STENCIL_FUNC_REF | 0x40000);
        vpp.pPusher->push(3, 0);

        vpp.pPusher->push(4, subchannel +
                      NV056_SET_STENCIL_FUNC_MASK | 0x40000);
        vpp.pPusher->push(5, 0x000000FF);

        vpp.pPusher->push(6, subchannel +
                      NV056_SET_STENCIL_OP_FAIL | 0x40000);
        vpp.pPusher->push(7, NV056_SET_STENCIL_OP_FAIL_V_KEEP);

        vpp.pPusher->push(8, subchannel +
                      NV056_SET_STENCIL_OP_ZFAIL | 0x40000);
        vpp.pPusher->push(9, NV056_SET_STENCIL_OP_ZFAIL_V_KEEP);

        vpp.pPusher->push(10, subchannel +
                       NV056_SET_STENCIL_OP_ZPASS | 0x40000);
        vpp.pPusher->push(11, NV056_SET_STENCIL_OP_ZPASS_V_KEEP);

        vpp.pPusher->push(12, subchannel +
                       NV056_SET_STENCIL_MASK | 0x40000);
        vpp.pPusher->push(13, 0x000000FF);

        vpp.pPusher->adjust(14);

        // This is set once and forgotten. It puts the class in OGL flat shade mode.
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_FLAT_SHADE_OP | 0x40000);
        vpp.pPusher->push(1, NV056_SET_FLAT_SHADE_OP_V_LAST_VTX);

        vpp.pPusher->adjust(2);

        // Load texture matrices assuming quarter pel scaling of texture coordinates
        fBuffer[0]  = 0.25; fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
        fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
        fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
        fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXTURE_MATRIX0(0) | 0x400000);
        vpp.pPusher->push(1, ftol[0]);
        vpp.pPusher->push(2, ftol[4]);
        vpp.pPusher->push(3, ftol[8]);
        vpp.pPusher->push(4, ftol[12]);
        vpp.pPusher->push(5, ftol[1]);
        vpp.pPusher->push(6, ftol[5]);
        vpp.pPusher->push(7, ftol[9]);
        vpp.pPusher->push(8, ftol[13]);
        vpp.pPusher->push(9, ftol[2]);
        vpp.pPusher->push(10, ftol[6]);
        vpp.pPusher->push(11, ftol[10]);
        vpp.pPusher->push(12, ftol[14]);
        vpp.pPusher->push(13, ftol[3]);
        vpp.pPusher->push(14, ftol[7]);
        vpp.pPusher->push(15, ftol[11]);
        vpp.pPusher->push(16, ftol[15]);

        vpp.pPusher->push(17, subchannel +
            NV056_SET_TEXTURE_MATRIX1(0) | 0x400000);
        vpp.pPusher->push(18, ftol[0]);
        vpp.pPusher->push(19, ftol[4]);
        vpp.pPusher->push(20, ftol[8]);
        vpp.pPusher->push(21, ftol[12]);
        vpp.pPusher->push(22, ftol[1]);
        vpp.pPusher->push(23, ftol[5]);
        vpp.pPusher->push(24, ftol[9]);
        vpp.pPusher->push(25, ftol[13]);
        vpp.pPusher->push(26, ftol[2]);
        vpp.pPusher->push(27, ftol[6]);
        vpp.pPusher->push(28, ftol[10]);
        vpp.pPusher->push(29, ftol[14]);
        vpp.pPusher->push(30, ftol[3]);
        vpp.pPusher->push(31, ftol[7]);
        vpp.pPusher->push(32, ftol[11]);
        vpp.pPusher->push(33, ftol[15]);

        vpp.pPusher->adjust(34);

        vpp.pPusher->start(TRUE);

        // Enable both texture matrices since these texture coordinates are in quarter pel
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXTURE_MATRIX0_ENABLE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_TEXTURE_MATRIX0_ENABLE_V_TRUE);
        vpp.pPusher->push(2, subchannel +
                      NV056_SET_TEXTURE_MATRIX1_ENABLE | 0x40000);
        vpp.pPusher->push(3, NV056_SET_TEXTURE_MATRIX1_ENABLE_V_TRUE);
        vpp.pPusher->adjust(4);

        tmpVal = (NV056_SET_TEXTURE_FORMAT_WRAPV_FALSE << 31) |
                 (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                 (NV056_SET_TEXTURE_FORMAT_WRAPU_FALSE << 27) |
                 (NV056_SET_TEXTURE_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                 (1 << 12) | // 1 MIPMAP level
                 (NV096_SET_TEXTURE_FORMAT_COLOR_LE_IMAGE_A8R8G8B8 << 7) |
                 (NV056_SET_TEXTURE_FORMAT_ORIGIN_FOH_CORNER << 5) |
                 (NV056_SET_TEXTURE_FORMAT_ORIGIN_ZOH_CORNER << 3) |
                 (NV056_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
                  NV056_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

        vpp.pPusher->push(0, subchannel +
                      NV056_SET_TEXTURE_FORMAT(0) | 0x80000);
        vpp.pPusher->push(1, tmpVal);
        vpp.pPusher->push(2, tmpVal);
        vpp.pPusher->push(3, subchannel +
                      NV056_SET_TEXTURE_CONTROL0(0) | 0x80000);
        vpp.pPusher->push(4, (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                      (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                      (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1 << 4) |
                      (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                      (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                       NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE);
        vpp.pPusher->push(5, (NV056_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
                      (15 << 8) | // huh ?  default MAX_LOD_CLAMP from OGL (no clamping)
                      (NV056_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
                      (NV056_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
                      (NV056_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
                       NV056_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE);
        vpp.pPusher->push(6, subchannel +
                      NV056_SET_TEXTURE_CONTROL2(0) | 0x80000);
        vpp.pPusher->push(7, 0);
        vpp.pPusher->push(8, 0);

        tmpVal = (NV056_SET_TEXTURE_FILTER_TEXTUREMAG_LINEAR << 28) |
                 (NV056_SET_TEXTURE_FILTER_TEXTUREMIN_LINEAR << 24);

        vpp.pPusher->push(9, subchannel +
                       NV056_SET_TEXTURE_FILTER(0) | 0x80000);
        vpp.pPusher->push(10, tmpVal);
        vpp.pPusher->push(11, tmpVal);

        vpp.pPusher->adjust(12);

        // Disable fog
        vpp.pPusher->push(0, subchannel +
                      NV056_SET_FOG_ENABLE | 0x40000);
        vpp.pPusher->push(1, NV056_SET_FOG_ENABLE_V_FALSE);

        vpp.pPusher->adjust(2);

        // Now setup combiners
        // Default register combiner settings are:
        // A = primary color
        // B = one
        // C = zero
        // D = zero

        // Our temporal filter moComp values
        // combiner0, RGB portion:   A = constantColor0
        // combiner0, RGB portion:   B = texture0
        // combiner0, RGB portion:   C = constantColor1
        // combiner0, RGB portion:   D = texture1

        // Initialize combiner ICW methods
        vpp.pPusher->push(0, subchannel | NV056_SET_COMBINER_ALPHA_ICW(0) | 0x80000);
        vpp.pPusher->push(1, (NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                      (NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                      (NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1 << 24) |

                      (NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                      (NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                      (NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8 << 16) |

                      (NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                      (NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                      (NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1 << 8) |

                      (NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                      (NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                       NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9);

        vpp.pPusher->push(2, (NV056_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                      (NV056_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                      (NV056_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_0 << 24) |

                      (NV056_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_INVERT << 21) |
                      (NV056_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                      (NV056_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_0 << 16) |

                      (NV056_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                      (NV056_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                      (NV056_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_0 << 8) |

                      (NV056_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                      (NV056_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                       NV056_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_0);

        vpp.pPusher->push(3, subchannel | NV056_SET_COMBINER_COLOR_ICW(0) | 0x80000);
        vpp.pPusher->push(4, (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                      (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                      (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                      (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                      (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                      (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                      (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                      (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                      (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                      (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                      (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                       NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9);

        vpp.pPusher->push(5, (NV056_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                      (NV056_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                      (NV056_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_0 << 24) |

                      (NV056_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_INVERT << 21) |
                      (NV056_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                      (NV056_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_0 << 16) |

                      (NV056_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_IDENTITY << 13) |
                      (NV056_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                      (NV056_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_0 << 8) |

                      (NV056_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                      (NV056_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                       NV056_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_0);

        // Load combination factors
        vpp.pPusher->push(6, subchannel | NV056_SET_COMBINE_FACTOR(0) | 0x80000);
        vpp.pPusher->push(7, 0x80808080); // % of top field
        vpp.pPusher->push(8, 0x80808080); // % of bottom field

        vpp.pPusher->adjust(9);

        // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1
        // Initialize combiner OCW methods
        vpp.pPusher->push(0, subchannel | NV056_SET_COMBINER_ALPHA_OCW(0) | 0x80000);
        vpp.pPusher->push(1, (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                      (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                      (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                      (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                       NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0);

        vpp.pPusher->push(2, (NV056_SET_COMBINER_ALPHA_OCW_OPERATION_NOSHIFT << 15) |
                      (NV056_SET_COMBINER_ALPHA_OCW_MUX_ENABLE_FALSE << 14) |
                      (NV056_SET_COMBINER_ALPHA_OCW_SUM_DST_REG_C << 8) |
                      (NV056_SET_COMBINER_ALPHA_OCW_AB_DST_REG_0 << 4) |
                       NV056_SET_COMBINER_ALPHA_OCW_CD_DST_REG_0);

        vpp.pPusher->push(3, subchannel | NV056_SET_COMBINER0_COLOR_OCW | 0x40000);
        vpp.pPusher->push(4, (NV056_SET_COMBINER0_COLOR_OCW_OPERATION_NOSHIFT << 15) |
                      (NV056_SET_COMBINER0_COLOR_OCW_MUX_ENABLE_FALSE << 14) |
                      (NV056_SET_COMBINER0_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |
                      (NV056_SET_COMBINER0_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |
                      (NV056_SET_COMBINER0_COLOR_OCW_SUM_DST_REG_C << 8) |
                      (NV056_SET_COMBINER0_COLOR_OCW_AB_DST_REG_0 << 4) |
                       NV056_SET_COMBINER0_COLOR_OCW_CD_DST_REG_0);

        vpp.pPusher->push(5, subchannel | NV056_SET_COMBINER1_COLOR_OCW | 0x40000);
        vpp.pPusher->push(6, (NV056_SET_COMBINER1_COLOR_OCW_ITERATION_COUNT_ONE << 28) |    \
                      (NV056_SET_COMBINER1_COLOR_OCW_MUX_SELECT_MSB << 27) |         \
                      (NV056_SET_COMBINER1_COLOR_OCW_OPERATION_NOSHIFT << 15) |      \
                      (NV056_SET_COMBINER1_COLOR_OCW_MUX_ENABLE_FALSE << 14) |       \
                      (NV056_SET_COMBINER1_COLOR_OCW_AB_DOT_ENABLE_FALSE << 13) |    \
                      (NV056_SET_COMBINER1_COLOR_OCW_CD_DOT_ENABLE_FALSE << 12) |    \
                      (NV056_SET_COMBINER1_COLOR_OCW_SUM_DST_REG_C << 8) |           \
                      (NV056_SET_COMBINER1_COLOR_OCW_AB_DST_REG_0 << 4) |            \
                       NV056_SET_COMBINER1_COLOR_OCW_CD_DST_REG_0);

        vpp.pPusher->adjust(7);

        // Load final stages with default values
        // Initialize combiner final CW methods
        vpp.pPusher->push(0, subchannel | NV056_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
        vpp.pPusher->push(1, DEFAULT_FINAL_CW0);
        vpp.pPusher->push(2, subchannel | NV056_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
        vpp.pPusher->push(3, DEFAULT_FINAL_CW1);
        vpp.pPusher->adjust(4);

        vpp.pPusher->start(TRUE);
    }
    return TRUE;
}
#endif // #if (NVARCH >= 0x10)


//---------------------------------------------------------------------------
// vppInitKelvin
//      Inits Kelvin object for temporal filter usage.  Kelvin is a shared,
//      cached object, so these methods only get set when we are a new consumer
LOCAL BOOL vppInitKelvin(Vpp_t *pVpp)
{
    DWORD tmpVal;
    float fBuffer[16];
    unsigned long *ftol = (unsigned long *)&fBuffer[0];
    float xTrans, yTrans, zTrans;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert(vpp.dwFlags & VPP_FLAG_KELVIN_3D);

    nvAssert(vpp.pThreeDClassLastUser);
    *vpp.pThreeDClassLastUser = MODULE_ID_DDRAW_VPP;

    // Let D3D code know that we have touched NV
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    // Reset the celsius context Dmas to use the default video context Dma
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    vpp.pPusher->push(1, vpp.hToVideoMemContextDma);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_CONTEXT_DMA_A | 0x40000);
    vpp.pPusher->push(3, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_CONTEXT_DMA_B | 0x40000);
    vpp.pPusher->push(5, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_CONTEXT_DMA_STATE | 0x40000);
    vpp.pPusher->push(7, vpp.hToVideoMemContextDma);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_CONTEXT_DMA_COLOR | 0x40000);
    vpp.pPusher->push(9, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(10, subchannel +
                          NV097_SET_CONTEXT_DMA_ZETA | 0x40000);
    vpp.pPusher->push(11, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(12, subchannel +
                          NV097_SET_CONTEXT_DMA_VERTEX_A | 0x40000);
    vpp.pPusher->push(13, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(14, subchannel +
                          NV097_SET_CONTEXT_DMA_VERTEX_B | 0x40000);
    vpp.pPusher->push(15, vpp.hInVideoMemContextDma);

    vpp.pPusher->push(16, subchannel +
                          NV097_SET_CONTEXT_DMA_SEMAPHORE | 0x40000);
    vpp.pPusher->push(17, NV01_NULL_OBJECT);

    vpp.pPusher->push(18, subchannel +
                          NV097_SET_CONTEXT_DMA_REPORT | 0x40000);
    vpp.pPusher->push(19, NV01_NULL_OBJECT);

    vpp.pPusher->adjust(20);

    // Set up one window clip rectangle to be the rendered area
    // All the other rectangles are deactivated
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_WINDOW_CLIP_HORIZONTAL(0) | 0x200000);
    vpp.pPusher->push(1, ((2047 << 16) | 0));  // PG: used to be (-2048 & 0xfff)
    vpp.pPusher->push(2, 0);
    vpp.pPusher->push(3, 0);
    vpp.pPusher->push(4, 0);
    vpp.pPusher->push(5, 0);
    vpp.pPusher->push(6, 0);
    vpp.pPusher->push(7, 0);
    vpp.pPusher->push(8, 0);

    vpp.pPusher->push(9, subchannel +
                         NV097_SET_WINDOW_CLIP_VERTICAL(0) | 0x200000);
    vpp.pPusher->push(10, ((2047 << 16) | 0));  // PG: used to be (-2048 & 0xfff)
    vpp.pPusher->push(11, 0);
    vpp.pPusher->push(12, 0);
    vpp.pPusher->push(13, 0);
    vpp.pPusher->push(14, 0);
    vpp.pPusher->push(15, 0);
    vpp.pPusher->push(16, 0);
    vpp.pPusher->push(17, 0);

    vpp.pPusher->push(18, subchannel +
                          NV097_SET_WINDOW_CLIP_TYPE | 0x40000);
    vpp.pPusher->push(19, NV097_SET_WINDOW_CLIP_TYPE_V_INCLUSIVE);
    vpp.pPusher->adjust(20);

    // Set Control0 defaults
    tmpVal = (NV097_SET_CONTROL0_COLOR_SPACE_CONVERT_PASS << 28) |
             (NV097_SET_CONTROL0_PREMULTIPLIEDALPHA_FALSE << 24) |
             (NV097_SET_CONTROL0_TEXTUREPERSPECTIVE_FALSE << 20) |
             (NV097_SET_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 16) |
             (NV097_SET_CONTROL0_Z_FORMAT_FIXED << 12) |
             (NV097_SET_CONTROL0_STENCIL_WRITE_ENABLE_TRUE);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_CONTROL0 | 0x40000);
    vpp.pPusher->push(1, tmpVal);
    vpp.pPusher->adjust(2);

    // Make sure to disable any transform program which may be running in D3D
    vpp.pPusher->push(0, subchannel + NV097_SET_TRANSFORM_EXECUTION_MODE | 0x40000);
    vpp.pPusher->push(1, ((NV097_SET_TRANSFORM_EXECUTION_MODE_RANGE_MODE_PRIV << 2) |
                           NV097_SET_TRANSFORM_EXECUTION_MODE_MODE_FIXED));
    vpp.pPusher->adjust(2);

    // Load ModelView matrix and inverse ModelView matrix with identity
    fBuffer[0]  = 1.0; fBuffer[1]  = 0.0; fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0; fBuffer[5]  = 1.0; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0; fBuffer[9]  = 0.0; fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0; fBuffer[13] = 0.0; fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_PROJECTION_MATRIX(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);
    vpp.pPusher->adjust(17);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_MODEL_VIEW_MATRIX0(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);
    vpp.pPusher->adjust(17);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_INVERSE_MODEL_VIEW_MATRIX0(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);

    vpp.pPusher->adjust(17);

    vpp.pPusher->push(0, subchannel +
                           NV097_NO_OPERATION | 0x40000);
    vpp.pPusher->push(1, 0);

    // PG - Modified 10/31/2000
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_SURFACE_FORMAT | 0x40000);
    vpp.pPusher->push(3, ((NV097_SET_SURFACE_FORMAT_ANTI_ALIASING_CENTER_1 << 12) |
                          (NV097_SET_SURFACE_FORMAT_TYPE_PITCH << 8) |
                          (NV097_SET_SURFACE_FORMAT_ZETA_Z16 << 4) |
                           NV097_SET_SURFACE_FORMAT_COLOR_LE_A8R8G8B8));

    vpp.pPusher->adjust(4);

    // Set up viewport
    xTrans = (float)(1.0 / 32.0); // hardware epsilon
    yTrans = (float)(1.0 / 32.0);
    zTrans = 0.0;

    // Load composite matrix assuming full pel scaling of surface coordinates
    fBuffer[0]  = 0.25; // quarter pel xScale
    fBuffer[1]  = 0.0;
    fBuffer[2]  = 0.0;
    fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;
    fBuffer[5]  = 0.25; // quarter pel pel yScale
    fBuffer[6]  = 0.0;
    fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;
    fBuffer[9]  = 0.0;
    fBuffer[10] = 1.0;
    fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;
    fBuffer[13] = 0.0;
    fBuffer[14] = 0.0;
    fBuffer[15] = 1.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMPOSITE_MATRIX(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);

    vpp.pPusher->adjust(17);

    // Set viewport offset separately
    fBuffer[0] = xTrans;
    fBuffer[1] = yTrans;
    fBuffer[2] = zTrans;
    fBuffer[3] = 0.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_VIEWPORT_OFFSET(0) | 0x100000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[1]);
    vpp.pPusher->push(3, ftol[2]);
    vpp.pPusher->push(4, ftol[3]);
    vpp.pPusher->adjust(5);

    // PG - Modified 10/31/2000
    // Set front and back clipping
    fBuffer[0] = 0.0;
    fBuffer[1] = KELVIN_Z_SCALE24;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_CLIP_MIN | 0x80000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[1]);
    vpp.pPusher->adjust(3);

    // Set light control
    tmpVal = (NV097_SET_LIGHT_CONTROL_SOUT_ZERO_OUT << 17) |
             (NV097_SET_LIGHT_CONTROL_LOCALEYE_FALSE << 16) |
              NV097_SET_LIGHT_CONTROL_SEPARATE_SPECULAR_EN_FALSE;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_LIGHT_CONTROL | 0x40000);
    vpp.pPusher->push(1, tmpVal);

    // Disable color material
    tmpVal = (NV097_SET_COLOR_MATERIAL_BACK_SPECULAR_MATERIAL_DISABLE << 14) |
             (NV097_SET_COLOR_MATERIAL_BACK_DIFF_MATERIAL_DISABLE << 12) |
             (NV097_SET_COLOR_MATERIAL_BACK_AMBIENT_MATERIAL_DISABLE << 10) |
             (NV097_SET_COLOR_MATERIAL_BACK_EMISSIVE_MATERIAL_DISABLE << 8) |
             (NV097_SET_COLOR_MATERIAL_SPECULAR_MATERIAL_DISABLE << 6) |
             (NV097_SET_COLOR_MATERIAL_DIFF_MATERIAL_DISABLE << 4) |
             (NV097_SET_COLOR_MATERIAL_AMBIENT_MATERIAL_DISABLE << 2) |
              NV097_SET_COLOR_MATERIAL_EMISSIVE_MATERIAL_DISABLE;

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_COLOR_MATERIAL | 0x40000);
    vpp.pPusher->push(3, tmpVal);
    vpp.pPusher->adjust(4);

    // Set default fog mode
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_FOG_MODE | 0x40000);
    vpp.pPusher->push(1, NV097_SET_FOG_MODE_V_LINEAR);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_FOG_GEN_MODE | 0x40000);
    vpp.pPusher->push(3, NV097_SET_FOG_GEN_MODE_V_FOG_X);

    // Disable fog
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_FOG_ENABLE | 0x40000);
    vpp.pPusher->push(5, NV097_SET_FOG_ENABLE_V_FALSE);

    // Set default fog color
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_FOG_COLOR | 0x40000);
    vpp.pPusher->push(7, 0xFFFFFFFF);
    vpp.pPusher->adjust(8);

    // Disable almost everything

    // Disable alpha test
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_ALPHA_TEST_ENABLE | 0x40000);
    vpp.pPusher->push(1, NV097_SET_ALPHA_TEST_ENABLE_V_FALSE);

    // Disable blending
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_BLEND_ENABLE | 0x40000);
    vpp.pPusher->push(3, NV097_SET_BLEND_ENABLE_V_FALSE);

    // Disable culling
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_CULL_FACE_ENABLE | 0x40000);
    vpp.pPusher->push(5, NV097_SET_CULL_FACE_ENABLE_V_FALSE);

    // Disable depth test
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_DEPTH_TEST_ENABLE | 0x40000);
    vpp.pPusher->push(7, NV097_SET_DEPTH_TEST_ENABLE_V_FALSE);

    // Disable dither
    vpp.pPusher->push(8, subchannel +
                         NV097_SET_DITHER_ENABLE | 0x40000);
    vpp.pPusher->push(9, NV097_SET_DITHER_ENABLE_V_FALSE);

    // Disable lighting
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_LIGHTING_ENABLE | 0x40000);
    vpp.pPusher->push(11, NV097_SET_LIGHTING_ENABLE_V_FALSE);

    // Disable point parameters computation
    vpp.pPusher->push(12, subchannel +
                          NV097_SET_POINT_PARAMS_ENABLE | 0x40000);
    vpp.pPusher->push(13, NV097_SET_POINT_PARAMS_ENABLE_V_FALSE);

    // Disable point smoothing
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_POINT_SMOOTH_ENABLE | 0x40000);
    vpp.pPusher->push(15, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable line smoothing
    vpp.pPusher->push(16, subchannel +
                          NV097_SET_LINE_SMOOTH_ENABLE | 0x40000);
    vpp.pPusher->push(17, NV097_SET_LINE_SMOOTH_ENABLE_V_FALSE);

    // Disable polygon smoothing
    vpp.pPusher->push(18, subchannel +
                          NV097_SET_POLY_SMOOTH_ENABLE | 0x40000);
    vpp.pPusher->push(19, NV097_SET_POLY_SMOOTH_ENABLE_V_FALSE);

    // Disable stippling
    vpp.pPusher->push(20, subchannel +
                          NV097_SET_STIPPLE_CONTROL | 0x40000);
    vpp.pPusher->push(21, NV097_SET_STIPPLE_CONTROL_V_OFF);

    // Disable skinning
    vpp.pPusher->push(22, subchannel +
                          NV097_SET_SKIN_MODE | 0x40000);
    vpp.pPusher->push(23, NV097_SET_SKIN_MODE_V_OFF);

    // Disable stencil test
    vpp.pPusher->push(24, subchannel +
                          NV097_SET_STENCIL_TEST_ENABLE | 0x40000);
    vpp.pPusher->push(25, NV097_SET_STENCIL_TEST_ENABLE_V_FALSE);

    // Disable polygon offset point
    vpp.pPusher->push(26, subchannel +
                          NV097_SET_POLY_OFFSET_POINT_ENABLE | 0x40000);
    vpp.pPusher->push(27, NV097_SET_POLY_OFFSET_POINT_ENABLE_V_FALSE);

    // Disable polygon offset line
    vpp.pPusher->push(28, subchannel +
                          NV097_SET_POLY_OFFSET_LINE_ENABLE | 0x40000);
    vpp.pPusher->push(29, NV097_SET_POLY_OFFSET_LINE_ENABLE_V_FALSE);

    // Disable polygon offset fill
    vpp.pPusher->push(30, subchannel +
                          NV097_SET_POLY_OFFSET_FILL_ENABLE | 0x40000);
    vpp.pPusher->push(31, NV097_SET_POLY_OFFSET_FILL_ENABLE_V_FALSE);
    vpp.pPusher->adjust(32);

    // PG: This part unitl the material emission comment is new
    // Set default alpha function
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_ALPHA_FUNC | 0x40000);
    vpp.pPusher->push(1, NV097_SET_ALPHA_FUNC_V_ALWAYS);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_ALPHA_REF | 0x40000);
    vpp.pPusher->push(3, 0);

    // Initialize blend factors
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_BLEND_FUNC_SFACTOR | 0x40000);
    vpp.pPusher->push(5, NV097_SET_BLEND_FUNC_SFACTOR_V_ONE);

    // PG - Changed 11/01/2000
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_BLEND_FUNC_DFACTOR | 0x40000);
    vpp.pPusher->push(7, NV097_SET_BLEND_FUNC_DFACTOR_V_ZERO);

    // Set default blend color
    vpp.pPusher->push(8, subchannel +
                         NV097_SET_BLEND_COLOR | 0x40000);
    vpp.pPusher->push(9, 0);

    // PG - Modified 10/31/2000 - SIGNED
    // Set default blend equation
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_BLEND_EQUATION | 0x40000);
    vpp.pPusher->push(11, NV097_SET_BLEND_EQUATION_V_FUNC_ADD_SIGNED);
    vpp.pPusher->adjust(12);

    // Set depth function
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_DEPTH_FUNC | 0x40000);
    vpp.pPusher->push(1, NV097_SET_DEPTH_FUNC_V_ALWAYS);

    // Set color mask
    tmpVal = (NV097_SET_COLOR_MASK_ALPHA_WRITE_ENABLE_TRUE << 24) |
             (NV097_SET_COLOR_MASK_RED_WRITE_ENABLE_TRUE << 16) |
             (NV097_SET_COLOR_MASK_GREEN_WRITE_ENABLE_TRUE << 8) |
              NV097_SET_COLOR_MASK_BLUE_WRITE_ENABLE_TRUE;

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_COLOR_MASK | 0x40000);
    vpp.pPusher->push(3, tmpVal);

    // Set depth mask
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_DEPTH_MASK | 0x40000);
    vpp.pPusher->push(5, NV097_SET_DEPTH_MASK_V_FALSE);
    vpp.pPusher->adjust(6);

    // Initialize stencil state (test already disabled above)
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_STENCIL_MASK | 0x40000);
    vpp.pPusher->push(1, 0x000000FF);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_STENCIL_FUNC | 0x40000);
    vpp.pPusher->push(3, NV097_SET_STENCIL_FUNC_V_ALWAYS);

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_STENCIL_FUNC_REF | 0x40000);
    vpp.pPusher->push(5, 0);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_STENCIL_FUNC_MASK | 0x40000);
    vpp.pPusher->push(7, 0x000000FF);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_STENCIL_OP_FAIL | 0x40000);
    vpp.pPusher->push(9, NV097_SET_STENCIL_OP_FAIL_V_KEEP);

    vpp.pPusher->push(10, subchannel +
                          NV097_SET_STENCIL_OP_ZFAIL | 0x40000);
    vpp.pPusher->push(11, NV097_SET_STENCIL_OP_ZFAIL_V_KEEP);

    vpp.pPusher->push(12, subchannel +
                          NV097_SET_STENCIL_OP_ZPASS | 0x40000);
    vpp.pPusher->push(13, NV097_SET_STENCIL_OP_ZPASS_V_KEEP);
    vpp.pPusher->adjust(14);

    // PG - Modified 10/31/2000 - V_SMOOTH
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_SHADE_MODE | 0x40000);
    vpp.pPusher->push(1, NV097_SET_SHADE_MODE_V_FLAT);

    fBuffer[0] = 0.0;

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_POLYGON_OFFSET_SCALE_FACTOR | 0x40000);
    vpp.pPusher->push(3, ftol[0]);

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_POLYGON_OFFSET_BIAS | 0x40000);
    vpp.pPusher->push(5, ftol[0]);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_FRONT_POLYGON_MODE | 0x40000);
    vpp.pPusher->push(7, NV097_SET_FRONT_POLYGON_MODE_V_FILL);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_BACK_POLYGON_MODE | 0x40000);
    vpp.pPusher->push(9, NV097_SET_BACK_POLYGON_MODE_V_FILL);

    vpp.pPusher->push(10, subchannel +
                          NV097_SET_CULL_FACE | 0x40000);
    vpp.pPusher->push(11, NV097_SET_CULL_FACE_V_BACK);

    vpp.pPusher->push(12, subchannel +
                          NV097_SET_FRONT_FACE | 0x40000);
    vpp.pPusher->push(13, NV097_SET_FRONT_FACE_V_CCW);

    vpp.pPusher->push(14, subchannel +
                          NV097_SET_NORMALIZATION_ENABLE | 0x40000);
    vpp.pPusher->push(15, NV097_SET_NORMALIZATION_ENABLE_V_FALSE);

    vpp.pPusher->push(16, subchannel +
                          NV097_SET_EDGE_FLAG | 0x40000);
    vpp.pPusher->push(17, NV097_SET_EDGE_FLAG_V_TRUE);
    vpp.pPusher->adjust(18);

    // Set material emission
    fBuffer[0] = 0.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_MATERIAL_EMISSION(0) | 0xC0000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[0]);
    vpp.pPusher->push(3, ftol[0]);

    // Disable specular
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_SPECULAR_ENABLE | 0x40000);
    vpp.pPusher->push(5, NV097_SET_SPECULAR_ENABLE_V_FALSE);

    // Disable all lights
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_LIGHT_ENABLE_MASK | 0x40000);
    vpp.pPusher->push(7, 0);
    vpp.pPusher->adjust(8);

    // Disable texgen modes for now (OpenGL default is EYE_LINEAR)
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXGEN_S(0) | 0x40000);
    vpp.pPusher->push(1, NV097_SET_TEXGEN_S_V_DISABLE);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_TEXGEN_T(0) | 0x40000);
    vpp.pPusher->push(3, NV097_SET_TEXGEN_T_V_DISABLE);

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_TEXGEN_R(0) | 0x40000);
    vpp.pPusher->push(5, NV097_SET_TEXGEN_R_V_DISABLE);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_TEXGEN_Q(0) | 0x40000);
    vpp.pPusher->push(7, NV097_SET_TEXGEN_Q_V_DISABLE);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_TEXGEN_S(1) | 0x40000);
    vpp.pPusher->push(9, NV097_SET_TEXGEN_S_V_DISABLE);

    vpp.pPusher->push(10, subchannel +
                          NV097_SET_TEXGEN_T(1) | 0x40000);
    vpp.pPusher->push(11, NV097_SET_TEXGEN_T_V_DISABLE);

    vpp.pPusher->push(12, subchannel +
                          NV097_SET_TEXGEN_R(1) | 0x40000);
    vpp.pPusher->push(13, NV097_SET_TEXGEN_R_V_DISABLE);

    vpp.pPusher->push(14, subchannel +
                          NV097_SET_TEXGEN_Q(1) | 0x40000);
    vpp.pPusher->push(15, NV097_SET_TEXGEN_Q_V_DISABLE);
    vpp.pPusher->adjust(16);

    // PG: This part until the fog parameters is new
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_SWATH_WIDTH | 0x40000);
    vpp.pPusher->push(1, NV097_SET_SWATH_WIDTH_V_OFF);

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_SHADER_STAGE_PROGRAM | 0x40000);
    vpp.pPusher->push(3, ((NV097_SET_SHADER_STAGE_PROGRAM_STAGE3_PROGRAM_NONE << 15) |
                          (NV097_SET_SHADER_STAGE_PROGRAM_STAGE2_PROGRAM_NONE << 10) |
                          (NV097_SET_SHADER_STAGE_PROGRAM_STAGE1_2D_PROJECTIVE << 5) |
                           NV097_SET_SHADER_STAGE_PROGRAM_STAGE0_2D_PROJECTIVE));

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_SHADER_CLIP_PLANE_MODE | 0x40000);
    vpp.pPusher->push(5, 0);

    vpp.pPusher->push(6, subchannel +
                         NV097_SET_SHADER_OTHER_STAGE_INPUT | 0x40000);
    vpp.pPusher->push(7, 0);

    // This is set once and forgotten. It puts the class in OGL flat shade mode.
    vpp.pPusher->push(8, subchannel +
                         NV097_SET_FLAT_SHADE_OP | 0x40000);
    vpp.pPusher->push(9, NV097_SET_FLAT_SHADE_OP_V_LAST_VTX);
    vpp.pPusher->adjust(10);

    // Set default fog parameters
    // PG - Modified - 11/03/2000
    fBuffer[0] = 0.0;   // K0
    fBuffer[1] = 1.0;   // K1
    //fBuffer[2] = 0.0;   // K2

    // PG - Modified 10/31/2000 - [0][1][2]
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_FOG_PARAMS(0) | 0xC0000);
    vpp.pPusher->push(1, ftol[1]); // K0
    vpp.pPusher->push(2, ftol[1]); // K1
    vpp.pPusher->push(3, ftol[0]); // K2

    // Set fog plane
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_FOG_PLANE(0) | 0x100000);
    vpp.pPusher->push(5, ftol[0]);
    vpp.pPusher->push(6, ftol[0]);
    vpp.pPusher->push(7, ftol[1]);
    vpp.pPusher->push(8, ftol[0]);

    // Set default fog color
    vpp.pPusher->push(9, subchannel +
                         NV097_SET_FOG_COLOR | 0x40000);
    vpp.pPusher->push(10, 0xFFFFFFFF);
    vpp.pPusher->adjust(11);

    // Set color for MODULATE blend mode
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_DIFFUSE_COLOR4F(0) | 0x100000);
    vpp.pPusher->push(1, ftol[1]);
    vpp.pPusher->push(2, ftol[1]);
    vpp.pPusher->push(3, ftol[1]);
    vpp.pPusher->push(4, ftol[1]);

    vpp.pPusher->push(5, subchannel +
                         NV097_SET_SPECULAR_COLOR3F(0) | 0xC0000);
    vpp.pPusher->push(6, ftol[0]);
    vpp.pPusher->push(7, ftol[0]);
    vpp.pPusher->push(8, ftol[0]);

    vpp.pPusher->push(9, subchannel +
                         NV097_SET_TEXCOORD0_4F(0) | 0x100000);
    vpp.pPusher->push(10, ftol[0]);
    vpp.pPusher->push(11, ftol[0]);
    vpp.pPusher->push(12, ftol[0]);
    vpp.pPusher->push(13, ftol[1]);

    vpp.pPusher->push(14, subchannel +
                          NV097_SET_TEXCOORD1_4F(0) | 0x100000);
    vpp.pPusher->push(15, ftol[0]);
    vpp.pPusher->push(16, ftol[0]);
    vpp.pPusher->push(17, ftol[0]);
    vpp.pPusher->push(18, ftol[1]);

    vpp.pPusher->push(19, subchannel +
                          NV097_SET_NORMAL3F(0) | 0xC0000);
    vpp.pPusher->push(20, ftol[0]);
    vpp.pPusher->push(21, ftol[0]);
    vpp.pPusher->push(22, ftol[1]);

    vpp.pPusher->push(23, subchannel +
                          NV097_SET_FOG1F | 0x40000);
    vpp.pPusher->push(24, ftol[0]);

    vpp.pPusher->push(25, subchannel +
                          NV097_SET_WEIGHT1F | 0x40000);
    vpp.pPusher->push(26, ftol[1]);
    vpp.pPusher->adjust(27);

    // Load texture matrices assuming quarter pel scaling of texture coordinates
    fBuffer[0]  = 0.25; fBuffer[1]  = 0.0;  fBuffer[2]  = 0.0; fBuffer[3]  = 0.0;
    fBuffer[4]  = 0.0;  fBuffer[5]  = 0.25; fBuffer[6]  = 0.0; fBuffer[7]  = 0.0;
    fBuffer[8]  = 0.0;  fBuffer[9]  = 0.0;  fBuffer[10] = 1.0; fBuffer[11] = 0.0;
    fBuffer[12] = 0.0;  fBuffer[13] = 0.0;  fBuffer[14] = 0.0; fBuffer[15] = 1.0;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXTURE_MATRIX0(0) | 0x400000);
    vpp.pPusher->push(1, ftol[0]);
    vpp.pPusher->push(2, ftol[4]);
    vpp.pPusher->push(3, ftol[8]);
    vpp.pPusher->push(4, ftol[12]);
    vpp.pPusher->push(5, ftol[1]);
    vpp.pPusher->push(6, ftol[5]);
    vpp.pPusher->push(7, ftol[9]);
    vpp.pPusher->push(8, ftol[13]);
    vpp.pPusher->push(9, ftol[2]);
    vpp.pPusher->push(10, ftol[6]);
    vpp.pPusher->push(11, ftol[10]);
    vpp.pPusher->push(12, ftol[14]);
    vpp.pPusher->push(13, ftol[3]);
    vpp.pPusher->push(14, ftol[7]);
    vpp.pPusher->push(15, ftol[11]);
    vpp.pPusher->push(16, ftol[15]);

    vpp.pPusher->push(17, subchannel +
                          NV097_SET_TEXTURE_MATRIX1(0) | 0x400000);
    vpp.pPusher->push(18, ftol[0]);
    vpp.pPusher->push(19, ftol[4]);
    vpp.pPusher->push(20, ftol[8]);
    vpp.pPusher->push(21, ftol[12]);
    vpp.pPusher->push(22, ftol[1]);
    vpp.pPusher->push(23, ftol[5]);
    vpp.pPusher->push(24, ftol[9]);
    vpp.pPusher->push(25, ftol[13]);
    vpp.pPusher->push(26, ftol[2]);
    vpp.pPusher->push(27, ftol[6]);
    vpp.pPusher->push(28, ftol[10]);
    vpp.pPusher->push(29, ftol[14]);
    vpp.pPusher->push(30, ftol[3]);
    vpp.pPusher->push(31, ftol[7]);
    vpp.pPusher->push(32, ftol[11]);
    vpp.pPusher->push(33, ftol[15]);
    vpp.pPusher->adjust(34);

    vpp.pPusher->start(TRUE);

    // Disable logic ops
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_LOGIC_OP_ENABLE | 0x40000);
    vpp.pPusher->push(1, NV097_SET_LOGIC_OP_ENABLE_V_FALSE);

    // Disable Z min/max culling
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_ZMIN_MAX_CONTROL | 0x40000);
    vpp.pPusher->push(3, ((NV097_SET_ZMIN_MAX_CONTROL_CULL_IGNORE_W_TRUE << 8) |
                          (NV097_SET_ZMIN_MAX_CONTROL_ZCLAMP_EN_CLAMP << 4) |
                           NV097_SET_ZMIN_MAX_CONTROL_CULL_NEAR_FAR_EN_FALSE));

    // PG - New 10/31/2000
    // MUST set antialiasing control sample mask even though antialiasing is disabled
    // Disable antialiasing
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_ANTI_ALIASING_CONTROL | 0x40000);
    vpp.pPusher->push(5, ((0xFFFF0000) |
                         NV097_SET_ANTI_ALIASING_CONTROL_ENABLE_FALSE));

    // Disable z buffer compression
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_COMPRESS_ZBUFFER_EN | 0x40000);
    vpp.pPusher->push(7, NV097_SET_COMPRESS_ZBUFFER_EN_V_DISABLE);

    // Disable z stencil occlusion
    vpp.pPusher->push(8, subchannel +
                         NV097_SET_OCCLUDE_ZSTENCIL_EN | 0x40000);
    vpp.pPusher->push(9, NV097_SET_OCCLUDE_ZSTENCIL_EN_OCCLUDE_ZEN_DISABLE);

    // Disable two sided lighting
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_TWO_SIDE_LIGHT_EN | 0x40000);
    vpp.pPusher->push(11, NV097_SET_TWO_SIDE_LIGHT_EN_V_FALSE);

    // Disable z pass pixel counting
    vpp.pPusher->push(12, subchannel +
                          NV097_SET_ZPASS_PIXEL_COUNT_ENABLE | 0x40000);
    vpp.pPusher->push(13, NV097_SET_ZPASS_PIXEL_COUNT_ENABLE_V_FALSE);
    vpp.pPusher->adjust(14);

    vpp.pPusher->start(TRUE);

    // Initialize some vertex attributes
    fBuffer[0] = 0.0;
    fBuffer[1] = 1.0;

    // Enable both texture matrices since these texture coordinates are in quarter pel
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXTURE_MATRIX_ENABLE(0) | 0x100000);
    vpp.pPusher->push(1, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    vpp.pPusher->push(2, NV097_SET_TEXTURE_MATRIX_ENABLE_V_TRUE);
    vpp.pPusher->push(3, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    vpp.pPusher->push(4, NV097_SET_TEXTURE_MATRIX_ENABLE_V_FALSE);
    vpp.pPusher->adjust(5);

    tmpVal = (1 << 16) | // 1 MIPMAP level
             (NV097_SET_TEXTURE_FORMAT_COLOR_LU_IMAGE_A8R8G8B8 << 8) |
             (NV097_SET_TEXTURE_FORMAT_DIMENSIONALITY_TWO << 4) |
             (NV097_SET_TEXTURE_FORMAT_BORDER_SOURCE_COLOR << 3) |
             (NV097_SET_TEXTURE_FORMAT_CUBEMAP_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_FORMAT_CONTEXT_DMA_A;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXTURE_FORMAT(0) | 0x40000);
    vpp.pPusher->push(1, tmpVal);
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_TEXTURE_FORMAT(1) | 0x40000);
    vpp.pPusher->push(3, tmpVal);
    vpp.pPusher->push(4, subchannel +
                         NV097_SET_TEXTURE_FORMAT(2) | 0x40000);
    vpp.pPusher->push(5, tmpVal);
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_TEXTURE_FORMAT(3) | 0x40000);
    vpp.pPusher->push(7, tmpVal);

    // PG - Added 10/31/2000
    tmpVal = (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_Q_FALSE << 24) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_P_FALSE << 20) |
             (NV097_SET_TEXTURE_ADDRESS_P_CLAMP_TO_EDGE << 16) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_V_FALSE << 12) |
             (NV097_SET_TEXTURE_ADDRESS_V_CLAMP_TO_EDGE << 8) |
             (NV097_SET_TEXTURE_ADDRESS_CYLWRAP_U_FALSE << 4) |
              NV097_SET_TEXTURE_ADDRESS_U_CLAMP_TO_EDGE;

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_TEXTURE_ADDRESS(0) | 0x40000);
    vpp.pPusher->push(9, tmpVal);
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_TEXTURE_ADDRESS(1) | 0x40000);
    vpp.pPusher->push(11, tmpVal);
    vpp.pPusher->push(12, subchannel +
                          NV097_SET_TEXTURE_ADDRESS(2) | 0x40000);
    vpp.pPusher->push(13, tmpVal);
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_TEXTURE_ADDRESS(3) | 0x40000);
    vpp.pPusher->push(15, tmpVal);
    vpp.pPusher->adjust(16);

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_TEXTURE_CONTROL0(0) | 0x40000);
    vpp.pPusher->push(1, tmpVal);

    // PG - Modified 11/02/2000 - ANISO_1
    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_TRUE << 30) |
        (15 << 18) | // MIN_LOD_CLAMP == 0.9
        (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
        (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_1 << 4) |
        (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
        (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
        NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    vpp.pPusher->push(2, subchannel +
                         NV097_SET_TEXTURE_CONTROL0(1) | 0x40000);
    vpp.pPusher->push(3, tmpVal);

    tmpVal = (NV097_SET_TEXTURE_CONTROL0_ENABLE_FALSE << 30) |
             (15 << 18) | // MIN_LOD_CLAMP == 0.9
             (15 << 6) | // default MAX_LOD_CLAMP from OGL == 0.9 (no clamping)
             (NV097_SET_TEXTURE_CONTROL0_LOG_MAX_ANISO_0 << 4) |
             (NV097_SET_TEXTURE_CONTROL0_IMAGE_FIELD_ENABLE_FALSE << 3) |
             (NV097_SET_TEXTURE_CONTROL0_ALPHA_KILL_ENABLE_FALSE << 2) |
              NV097_SET_TEXTURE_CONTROL0_COLOR_KEY_OPERATION_FALSE;

    vpp.pPusher->push(4, subchannel +
                         NV097_SET_TEXTURE_CONTROL0(2) | 0x40000);
    vpp.pPusher->push(5, tmpVal);
    vpp.pPusher->push(6, subchannel +
                         NV097_SET_TEXTURE_CONTROL0(3) | 0x40000);
    vpp.pPusher->push(7, tmpVal);


    tmpVal = (NV097_SET_TEXTURE_FILTER_BSIGNED_BIT_DISABLED << 31) |
             (NV097_SET_TEXTURE_FILTER_GSIGNED_BIT_DISABLED << 30) |
             (NV097_SET_TEXTURE_FILTER_RSIGNED_BIT_DISABLED << 29) |
             (NV097_SET_TEXTURE_FILTER_ASIGNED_BIT_DISABLED << 28) |
             (NV097_SET_TEXTURE_FILTER_MAG_TENT_LOD0 << 24) |
             (NV097_SET_TEXTURE_FILTER_MIN_TENT_LOD0 << 16) |
             (NV097_SET_TEXTURE_FILTER_CONVOLUTION_KERNEL_QUINCUNX << 13);

    vpp.pPusher->push(8, subchannel +
                         NV097_SET_TEXTURE_FILTER(0) | 0x40000);
    vpp.pPusher->push(9, tmpVal);
    vpp.pPusher->push(10, subchannel +
                          NV097_SET_TEXTURE_FILTER(1) | 0x40000);
    vpp.pPusher->push(11, tmpVal);
    vpp.pPusher->push(12, subchannel +
                          NV097_SET_TEXTURE_FILTER(2) | 0x40000);
    vpp.pPusher->push(13, tmpVal);
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_TEXTURE_FILTER(3) | 0x40000);
    vpp.pPusher->push(15, tmpVal);

    tmpVal = (2044 << 16) | 2046; // Must be even and <= 4094

    vpp.pPusher->push(16, subchannel +
                          NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    vpp.pPusher->push(17, tmpVal);
    vpp.pPusher->push(18, subchannel +
                          NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    vpp.pPusher->push(19, tmpVal);
    vpp.pPusher->push(20, subchannel +
                          NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    vpp.pPusher->push(21, tmpVal);
    vpp.pPusher->push(22, subchannel +
                          NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    vpp.pPusher->push(23, tmpVal);

    vpp.pPusher->adjust(24);

    // Now setup combiners

    // Default register combiner settings are:
    // A = primary color
    // B = one
    // C = zero
    // D = zero

    // Our temporal filter moComp values
    // combiner0, RGB portion:   A = constantColor0
    // combiner0, RGB portion:   B = texture0
    // combiner0, RGB portion:   C = constantColor1
    // combiner0, RGB portion:   D = texture1

    // Initialize combiner ICW methods
    vpp.pPusher->push(0, subchannel | NV097_SET_COMBINER_ALPHA_ICW(0) | 0x100000);
    vpp.pPusher->push(1, (NV097_SET_COMBINER_ALPHA_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                         (NV097_SET_COMBINER_ALPHA_ICW_A_ALPHA_TRUE << 28) |
                         (NV097_SET_COMBINER_ALPHA_ICW_A_SOURCE_REG_1 << 24) |

                         (NV097_SET_COMBINER_ALPHA_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                         (NV097_SET_COMBINER_ALPHA_ICW_B_ALPHA_TRUE << 20) |
                         (NV097_SET_COMBINER_ALPHA_ICW_B_SOURCE_REG_8 << 16) |

                         (NV097_SET_COMBINER_ALPHA_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                         (NV097_SET_COMBINER_ALPHA_ICW_C_ALPHA_TRUE << 12) |
                         (NV097_SET_COMBINER_ALPHA_ICW_C_SOURCE_REG_1 << 8) |

                         (NV097_SET_COMBINER_ALPHA_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                         (NV097_SET_COMBINER_ALPHA_ICW_D_ALPHA_TRUE << 4) |
                          NV097_SET_COMBINER_ALPHA_ICW_D_SOURCE_REG_9);
    vpp.pPusher->push(2, DEFAULT_KELVIN_ALPHA_ICW);
    vpp.pPusher->push(3, DEFAULT_KELVIN_ALPHA_ICW);
    vpp.pPusher->push(4, DEFAULT_KELVIN_ALPHA_ICW);

    vpp.pPusher->push(5, subchannel | NV097_SET_COMBINER_COLOR_ICW(0) | 0x100000);
    vpp.pPusher->push(6, (NV097_SET_COMBINER_COLOR_ICW_A_MAP_UNSIGNED_IDENTITY << 29) |
                         (NV097_SET_COMBINER_COLOR_ICW_A_ALPHA_FALSE << 28) |
                         (NV097_SET_COMBINER_COLOR_ICW_A_SOURCE_REG_1 << 24) |

                         (NV097_SET_COMBINER_COLOR_ICW_B_MAP_UNSIGNED_IDENTITY << 21) |
                         (NV097_SET_COMBINER_COLOR_ICW_B_ALPHA_FALSE << 20) |
                         (NV097_SET_COMBINER_COLOR_ICW_B_SOURCE_REG_8 << 16) |

                         (NV097_SET_COMBINER_COLOR_ICW_C_MAP_UNSIGNED_INVERT << 13) |
                         (NV097_SET_COMBINER_COLOR_ICW_C_ALPHA_FALSE << 12) |
                         (NV097_SET_COMBINER_COLOR_ICW_C_SOURCE_REG_1 << 8) |

                         (NV097_SET_COMBINER_COLOR_ICW_D_MAP_UNSIGNED_IDENTITY << 5) |
                         (NV097_SET_COMBINER_COLOR_ICW_D_ALPHA_FALSE << 4) |
                          NV097_SET_COMBINER_COLOR_ICW_D_SOURCE_REG_9);
    vpp.pPusher->push(7, DEFAULT_KELVIN_COLOR_ICW);
    vpp.pPusher->push(8, DEFAULT_KELVIN_COLOR_ICW);
    vpp.pPusher->push(9, DEFAULT_KELVIN_COLOR_ICW);
    vpp.pPusher->adjust(10);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    vpp.pPusher->push(1, 0x80808080); // % of top field

    vpp.pPusher->push(2, subchannel | NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    vpp.pPusher->push(3, 0x80808080); // % of bottom field
    vpp.pPusher->adjust(4);

    // combiner0, RGB portion:   texture0 + texture1
    // spare0 = A * B + C * D
    // Initialize combiner OCW methods
    // combiner0, RGB portion:      spare0 = A * B + C * D = texture0 + texture1

    // Initialize combiner OCW methods
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMBINER_ALPHA_OCW(0) | 0x100000);
    vpp.pPusher->push(1, DEFAULT_KELVIN_ALPHA_OCW);
    vpp.pPusher->push(2, DEFAULT_KELVIN_ALPHA_OCW);
    vpp.pPusher->push(3, DEFAULT_KELVIN_ALPHA_OCW);
    vpp.pPusher->push(4, DEFAULT_KELVIN_ALPHA_OCW);
    vpp.pPusher->adjust(5);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMBINER_COLOR_OCW(0) | 0x100000);
    vpp.pPusher->push(1, DEFAULT_KELVIN_COLOR_OCW);
    vpp.pPusher->push(2, DEFAULT_KELVIN_COLOR_OCW);
    vpp.pPusher->push(3, DEFAULT_KELVIN_COLOR_OCW);
    vpp.pPusher->push(4, DEFAULT_KELVIN_COLOR_OCW);
    vpp.pPusher->adjust(5);

    tmpVal = (NV097_SET_COMBINER_CONTROL_FACTOR1_SAME_FACTOR_ALL << 16) |
             (NV097_SET_COMBINER_CONTROL_FACTOR0_SAME_FACTOR_ALL << 12) |
             (NV097_SET_COMBINER_CONTROL_MUX_SELECT_MSB << 8) |
              NV097_SET_COMBINER_CONTROL_ITERATION_COUNT_ONE;

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMBINER_CONTROL | 0x40000);
    vpp.pPusher->push(1, tmpVal);
    vpp.pPusher->adjust(2);

    // Load final stages with default values
    // Initialize combiner final CW methods
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_COMBINER_SPECULAR_FOG_CW0 | 0x40000);
    vpp.pPusher->push(1, DEFAULT_KELVIN_FINAL_CW0);
    vpp.pPusher->push(2, subchannel +
                         NV097_SET_COMBINER_SPECULAR_FOG_CW1 | 0x40000);
    vpp.pPusher->push(3, DEFAULT_KELVIN_FINAL_CW1);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);

    return TRUE;
}


//---------------------------------------------------------------------------
// vppValidateMode
//      Determine whether there is enough memory for this mode
LOCAL BOOL vppValidateMode(Vpp_t *pVpp, DWORD dwWidth, DWORD dwHeight, DWORD dwBytesPerPel,
                            DWORD dwNumSurfaces, DWORD dwHead, DWORD dwRefreshRate, DWORD dwDCHead, DWORD dwDeviceType)
{
    NV_CFGEX_GET_SURFACE_PITCH_PARAMS params = {dwWidth, dwBytesPerPel * 8, 0};
    DWORD dwPitch, dwSize;
    Vpp_t &vpp = *pVpp;

    // get the pitch

    if (NvRmConfigGetEx(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                        NV_CFGEX_GET_SURFACE_PITCH,
                        &params, sizeof(params)) == NVOS_CGE_STATUS_SUCCESS) {
        dwPitch = params.Pitch;
    } else {
        // RM call failed, try to figure it out ourselves
        dwPitch  = ((dwWidth * dwBytesPerPel) + vpp.pDriverData->dwSurfaceAlignPad) & ~vpp.pDriverData->dwSurfaceAlignPad;
    }

    // calculate total size
    dwSize = dwPitch * dwHeight * dwNumSurfaces;

    // enough memory?
    if (dwSize > NV_GET_VIDEO_HEAP_FREE()) {
        return FALSE;
    }

#if (IS_WINNT4 || IS_WINNT5)
    MODE_ENTRY *lpMode = vpp.m_ppdev->PhysModeList[dwHead];
    DWORD dwNumModes = vpp.m_ppdev->ulNumPhysModes[dwHead];
    for (DWORD i = 0; i < dwNumModes; i++) {
        if (lpMode->ValidMode && lpMode->Width == dwWidth && lpMode->Height == dwHeight &&
            lpMode->Depth == (dwBytesPerPel * 8) && lpMode->RefreshRate == dwRefreshRate) {
            return TRUE;
        }
        lpMode++;
    }
    return FALSE;
#else
    // validate whether that display mode exists or not
    NVTWINVIEWDATA twinData;
    twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinData.dwAction = NVTWINVIEW_ACTION_VALIDATE_PHYSICAL_MODE;
    twinData.dwCrtc   = dwHead;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType = dwDeviceType;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes = dwWidth;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes = dwHeight;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp  = dwBytesPerPel * 8;
    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = dwRefreshRate;
    MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                 (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

    if (!twinData.dwSuccess) {
        return FALSE;
    }
#endif

    return TRUE;
}


//---------------------------------------------------------------------------
// vppCreateFSMirror
//      Initialize for fullscreen mirror mode
extern BOOL VppCreateFSMirror(Vpp_t *pVpp,  DWORD dwSrcWidth, DWORD dwSrcHeight)
{
    nvAssert(pVpp);
    nvAssert(dwSrcWidth>0);
    nvAssert(dwSrcHeight>0);

    // During modeset on win9x, this is called before enable (in nvEnable)
    //   Is that really necessary? @mjl@
    if (!(pVpp->dwFlags & VPP_FLAG_ENABLED))
    {
        return FALSE;
    }

    nvAssert(!(pVpp->dwFlags & VPP_FLAG_MIRROR_READY));

#ifdef IS_WINNT4    // No FullScreen mirror on NT4
    return FALSE;
#else
    DWORD i, dwStatus, dwBlockSize;
    NVTWINVIEWDATA twinData = {0};
    DWORD dwCrtcNumber = 0;
    DWORD dwDeviceType = 0;
    DWORD dwDCHead;
    DWORD dwPhysicalHead = 0;
    Vpp_t &vpp = *pVpp;
    LPPROCESSINFO lpProcInfo;

#if IS_WINNT5
    if (vpp.m_ppdev->TwinView_State != NVTWINVIEW_STATE_CLONE) {
        return FALSE;
    }
#elif IS_WIN9X
    if (vpp.pDriverData->dwDesktopState != NVTWINVIEW_STATE_DUALVIEW &&
        vpp.pDriverData->dwDesktopState != NVTWINVIEW_STATE_CLONE) {
        return FALSE;
    }
#endif

    // overlay creation has succeeded, now attempt to create fullscreen mirrors
    if ((vpp.pDriverData->dwHeads > 1) &&       
        (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) &&
        (vpp.dwOverlayFSNumSurfaces == 0)) {
        DWORD dwAdapterIndex = 0xFFFFFFFF;

        vpp.dwOverlayFSHead = (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) - 1;

        if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW) {
            vpp.dwOverlayFSHead = 14;
            vpp.regOverlayMode2 |= NV4_REG_OVL_MODE2_FSDEVICEMASK;  // set to autoselect
        }

        if (vpp.dwOverlayFSHead >= 14) {
            // auto head selection
            switch (vpp.pDriverData->dwDesktopState) {
            case NVTWINVIEW_STATE_DUALVIEW:
                // multimon mode uses the head which the overlay was not created on
                if (vpp.dwOverlayFSOvlHead == 0) {
                    vpp.dwOverlayFSHead = 1;
                } else if (vpp.dwOverlayFSOvlHead == 1) {
                    vpp.dwOverlayFSHead = 0;
                } else {
                    // no overlay, pick head 1
                    vpp.dwOverlayFSHead = 1;
                }
                break;
            case NVTWINVIEW_STATE_CLONE:
                // clone mode preferentially uses head 1
                vpp.dwOverlayFSHead = 1;
                break;
            default:
                // invalid condition, fail
                vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSMASK;
                return FALSE;
            }
        }

#if IS_WIN9X

        switch (vpp.pDriverData->dwDesktopState) {
        case NVTWINVIEW_STATE_DUALVIEW:
            dwCrtcNumber   = 0;       // need to use logical head numbers in multimon mode
            dwDCHead       = vpp.dwOverlayFSHead;
            dwPhysicalHead = vpp.dwOverlayFSHead;
            break;
        case NVTWINVIEW_STATE_CLONE:
            dwCrtcNumber = vpp.dwOverlayFSHead;
            dwDCHead     = pDXShare->dwHeadNumber;
            // get physical head number
            twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
            twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
            twinData.dwCrtc   = dwCrtcNumber;
            MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
            dwPhysicalHead = twinData.dwCrtc;
            break;
        default:
            // invalid condition, fail
            vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSMASK;
            return FALSE;
        }

        // get the current device type
        vpp.dwOverlayFSTwinData.dwFlag   = NVTWINVIEW_FLAG_GET;
        vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_SETGET_DEVICE_TYPE;
        vpp.dwOverlayFSTwinData.dwCrtc   = dwCrtcNumber;
        MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &vpp.dwOverlayFSTwinData,
                     sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);
        twinData = vpp.dwOverlayFSTwinData;
        dwDeviceType = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwDeviceType;

#elif IS_WINNT5
        vpp.dwOverlayFSHead = vpp.m_ppdev->ulDeviceDisplay[vpp.dwOverlayFSHead];
        dwDeviceType = vpp.m_ppdev->ulDeviceType[vpp.dwOverlayFSHead];
        dwDCHead = 0;
#endif

        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSSETMODE) {
            // driver will choose the display mode
            DWORD dwEncoderType;
            BOOL isDVDSized, isTV;
            NvRmConfigGet(
                vpp.pDriverData->dwRootHandle,
                vpp.pDriverData->dwDeviceHandle,
                     NV_CFG_VIDEO_ENCODER_TYPE, &dwEncoderType);

    // determine optimal mode
            // TODO: can do some interesting optimizations for anamorphic mode

            isTV = (dwDeviceType == MONITOR_TYPE_NTSC || dwDeviceType == MONITOR_TYPE_PAL);
            isDVDSized = (dwSrcWidth == 720 || dwSrcWidth == 704);

            if (isTV) {
                // if monitor is a TV, then attempt to set the native resolution
                if (dwEncoderType == NV_ENCODER_BROOKTREE_869 ||
                    dwEncoderType == NV_ENCODER_BROOKTREE_868) {
                    // Bt868/9 needs some weird modes because of locked and incorrect aspect ratios on those chips
                    if (dwDeviceType == MONITOR_TYPE_NTSC) {
                        vpp.dwOverlayFSWidth  = 720;
                        vpp.dwOverlayFSHeight = 512;
                        vpp.dwOverlayFSFormat = 4;
                        if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                            goto vppFSMirrorModeFound;
                        }

                        vpp.dwOverlayFSWidth  = 640;
                        vpp.dwOverlayFSHeight = 480;
                        vpp.dwOverlayFSFormat = 4;
                        if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                            goto vppFSMirrorModeFound;
                        }
                    }

                    if (dwDeviceType == MONITOR_TYPE_PAL) {
                        vpp.dwOverlayFSWidth  = 720;
                        vpp.dwOverlayFSHeight = 544;
                        vpp.dwOverlayFSFormat = 4;
                        if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                            goto vppFSMirrorModeFound;
                        }
                        vpp.dwOverlayFSWidth  = 800;
                        vpp.dwOverlayFSHeight = 600;
                        vpp.dwOverlayFSFormat = 4;
                        if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                            goto vppFSMirrorModeFound;
                        }
                    }
                } else if (dwEncoderType == NV_ENCODER_CHRONTEL_7007 ||
                           dwEncoderType == NV_ENCODER_CHRONTEL_7008) {
                    // optimal mode for Chrontel is 720x576
                    vpp.dwOverlayFSWidth  = 720;
                    vpp.dwOverlayFSHeight = 576;
                    vpp.dwOverlayFSFormat = 4;
                    if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                        goto vppFSMirrorModeFound;
                    }
                }
                // Note: if TV encoder is Brooktree/Conexant 871, we fall throught into the following
                // code, which handles more normal video mirror resolutions.
            }

            // Under some circumstances we use the source size, but not for TV.
            // Note 320x240 mode doesn't look right on TV.
            if (!isTV && !((dwDeviceType == MONITOR_TYPE_FLAT_PANEL) && isDVDSized)) {
                // first try a mode exactly equal to source size
                vpp.dwOverlayFSWidth  = dwSrcWidth;
                vpp.dwOverlayFSHeight = dwSrcHeight;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            }

            // select mode based on source size
            // Note 320x240 mode doesn't look right on TV.
            if (dwSrcWidth <= 320 && dwSrcHeight <= 240 && !isTV) {
                vpp.dwOverlayFSWidth  = 320;
                vpp.dwOverlayFSHeight = 240;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            // Note 512x384 mode doesn't look right on TV.
            } else if (dwSrcWidth <= 512 && dwSrcHeight <= 384 && !isTV) {
                vpp.dwOverlayFSWidth  = 512;
                vpp.dwOverlayFSHeight = 384;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 640 && dwSrcHeight <= 480) {
                vpp.dwOverlayFSWidth  = 640;
                vpp.dwOverlayFSHeight = 480;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 800 && dwSrcHeight <= 600) {
                vpp.dwOverlayFSWidth  = 800;
                vpp.dwOverlayFSHeight = 600;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 1024 && dwSrcHeight <= 768) {
                vpp.dwOverlayFSWidth  = 1024;
                vpp.dwOverlayFSHeight = 768;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 1280 && dwSrcHeight <= 960) {
                vpp.dwOverlayFSWidth  = 1280;
                vpp.dwOverlayFSHeight = 960;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            } else if (dwSrcWidth <= 1600 && dwSrcHeight <= 1200) {
                vpp.dwOverlayFSWidth  = 1600;
                vpp.dwOverlayFSHeight = 1200;
                vpp.dwOverlayFSFormat = 4;
                if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                    goto vppFSMirrorModeFound;
                }
            }
            // ok, we must be running into memory problems by now, try modes smaller that overlay source and downscale
            vpp.dwOverlayFSWidth  = 800;
            vpp.dwOverlayFSHeight = 600;
            vpp.dwOverlayFSFormat = 4;
            if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                goto vppFSMirrorModeFound;
            }

            // Try 8x6x32 with 2 buffers.
            if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 2, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                goto vppFSMirrorModeFound;
            }

            vpp.dwOverlayFSWidth  = 640;
            vpp.dwOverlayFSHeight = 480;
            vpp.dwOverlayFSFormat = 4;
            if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                goto vppFSMirrorModeFound;
            }

            // Try 6x4x32 with 2 buffers.
            if (vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 2, dwCrtcNumber, 60, dwDCHead, dwDeviceType)) {
                goto vppFSMirrorModeFound;
            }

            // last resort mode
            vpp.dwOverlayFSWidth  = 640;
            vpp.dwOverlayFSHeight = 480;
            vpp.dwOverlayFSFormat = 2;

            vppFSMirrorModeFound:
#if IS_WINNT5
            RESOLUTION_INFO res;
            BOOL success;

            // WIN2k works a little differently that win9x escape, it won't back down to a lower refresh
            // automatically so we have to do the explicit refresh rate validation
            if (dwDeviceType == MONITOR_TYPE_NTSC) {
                res.ulDisplayRefresh = 60;
            } else if (dwDeviceType == MONITOR_TYPE_PAL) {
                res.ulDisplayRefresh = 50;
            } else {
                res.ulDisplayRefresh = 85;
                if (!vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 85, dwDCHead, dwDeviceType)) {
                    res.ulDisplayRefresh = 75;
                    if (!vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 75, dwDCHead, dwDeviceType)) {
                        res.ulDisplayRefresh = 60;
                    }
                }
            }

            res.ulDisplayWidth      = vpp.dwOverlayFSWidth;
            res.ulDisplayHeight     = vpp.dwOverlayFSHeight;
            switch (vpp.dwOverlayFSFormat) {
            case 1:  res.ulDisplayPixelDepth = BMF_8BPP;  break;
            case 4:  res.ulDisplayPixelDepth = BMF_32BPP; break;
            default: res.ulDisplayPixelDepth = BMF_16BPP; break;
            }
            success = NvSetDac(vpp.m_ppdev, vpp.dwOverlayFSHead, &res);
#elif IS_WIN9X
            // lock the head CRTC
            // do not touch pDriverData->dwOverlayFSTwinData anymore until the CRTC unlock, display driver needs this context for unlocking
            vpp.dwOverlayFSTwinData.dwFlag   = NVTWINVIEW_FLAG_SET;
            vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_LOCK_HWCRTC;
            vpp.dwOverlayFSTwinData.dwCrtc   = dwPhysicalHead;   // leave this as the physical head number for lock
            MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &vpp.dwOverlayFSTwinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);

            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX;
            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pGNLogdevCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX;
            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.dwLogicalCrtcIndex = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex;
            twinData = vpp.dwOverlayFSTwinData;

            if (!twinData.dwSuccess) {
                // lock failed, abort
                vpp.dwOverlayFSNumSurfaces = 0;
                return FALSE;
            }

            // set the mode
            twinData.dwFlag   = NVTWINVIEW_FLAG_SET;
            twinData.dwAction = NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE;
            if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
                twinData.dwCrtc   = dwPhysicalHead;
            } else {
                twinData.dwCrtc   = dwCrtcNumber;
            }
            twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes = vpp.dwOverlayFSWidth;
            twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes = vpp.dwOverlayFSHeight;
            twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp  = vpp.dwOverlayFSFormat * 8;
            if (dwDeviceType == MONITOR_TYPE_NTSC) {
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 60;
            } else if (dwDeviceType == MONITOR_TYPE_PAL) {
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 50;
            } else {
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 85;
            }
            MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

            vpp.dwOverlayFSWidth  = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes;
            vpp.dwOverlayFSHeight = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes;
            vpp.dwOverlayFSFormat = (twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp + 1) / 8;
#endif
        } else {
            // use whatever mode is currently set

#if IS_WINNT5
            vpp.dwOverlayFSWidth  = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].right -
                                             vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].left;
            vpp.dwOverlayFSHeight = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].bottom -
                                             vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].top;
            vpp.dwOverlayFSFormat = vpp.m_ppdev->cjPelSize;
            vpp.dwOverlayFSPitch  = vpp.m_ppdev->lDelta;

            if (vpp.dwOverlayFSFormat == 1) {
                RESOLUTION_INFO res;
                BOOL success;

                // if other head was set to 8 bpp, then actually use a 16 bpp FS surface
                vpp.dwOverlayFSFormat = 2;
                // WIN2k works a little differently that win9x escape, it won't back down to a lower refresh
                // automatically so we have to do the explicite refresh rate validation
                if (dwDeviceType == MONITOR_TYPE_NTSC) {
                    res.ulDisplayRefresh = 60;
                } else if (dwDeviceType == MONITOR_TYPE_PAL) {
                    res.ulDisplayRefresh = 50;
                } else {
                    res.ulDisplayRefresh = 85;
                    if (!vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 85, dwDCHead, dwDeviceType)) {
                        res.ulDisplayRefresh = 75;
                        if (!vppValidateMode(&vpp, vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, vpp.dwOverlayFSFormat, 3, dwCrtcNumber, 75, dwDCHead, dwDeviceType)) {
                            res.ulDisplayRefresh = 60;
                        }
                    }
                }

                // promote the mode
                res.ulDisplayWidth      = vpp.dwOverlayFSWidth;
                res.ulDisplayHeight     = vpp.dwOverlayFSHeight;
                res.ulDisplayPixelDepth = BMF_16BPP;
                success = NvSetDac(vpp.m_ppdev, vpp.dwOverlayFSHead, &res);
            }
#elif IS_WIN9X
            // get the physical mode
            twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
            twinData.dwAction = NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE;
            twinData.dwCrtc   = dwCrtcNumber;
            MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

            vpp.dwOverlayFSWidth  = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes;
            vpp.dwOverlayFSHeight = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes;
            vpp.dwOverlayFSFormat = (twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp + 1) / 8;

            // lock the head CRTC
            // do not touch pDriverData->dwOverlayFSTwinData anymore until the CRTC unlock, display driver needs this context for unlocking
            vpp.dwOverlayFSTwinData.dwFlag   = NVTWINVIEW_FLAG_SET;
            vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_LOCK_HWCRTC;
            vpp.dwOverlayFSTwinData.dwCrtc   = dwPhysicalHead;   // leave this as the physical head number for lock
            MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &vpp.dwOverlayFSTwinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);

            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX;
            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pGNLogdevCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX;
            vpp.dwOverlayFSTwinData.nvtwPhysicalModeImmediate.dwLogicalCrtcIndex = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pHWCrtcCX;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.pGNLogdevCX;
            vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex = vpp.dwOverlayFSTwinData.nvtwLockUnlockHwcrtc.dwLogicalCrtcIndex;
            twinData = vpp.dwOverlayFSTwinData;

            if (!twinData.dwSuccess) {
                // lock failed, abort
                vpp.dwOverlayFSNumSurfaces = 0;
                return FALSE;
            }

            if (vpp.dwOverlayFSFormat == 1) {
                // if other head was set to 8 bpp, then actually use a 16 bpp FS surface
                vpp.dwOverlayFSFormat = 2;

                twinData.dwFlag   = NVTWINVIEW_FLAG_SET;
                twinData.dwAction = NVTWINVIEW_ACTION_SETGET_PHYSICAL_MODE_IMMEDIATE;
                if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
                    twinData.dwCrtc   = dwPhysicalHead;
                } else {
                    twinData.dwCrtc   = dwCrtcNumber;
                }
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes = vpp.dwOverlayFSWidth;
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes = vpp.dwOverlayFSHeight;
                twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp  = 16;
                if (dwDeviceType == MONITOR_TYPE_NTSC) {
                    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 60;
                } else if (dwDeviceType == MONITOR_TYPE_PAL) {
                    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 50;
                } else {
                    twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwRefresh = 85;
                }
                MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                             (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);

                vpp.dwOverlayFSWidth  = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwXRes;
                vpp.dwOverlayFSHeight = twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwYRes;
                vpp.dwOverlayFSFormat = (twinData.NVTWINVIEWUNION.nvtwdevdata[0].dwBpp + 1) / 8;
            }
#endif
        }

        // Get the pitch from the RM for a given width/bpp
        NV_CFGEX_GET_SURFACE_PITCH_PARAMS params = {vpp.dwOverlayFSWidth, vpp.dwOverlayFSFormat * 8, 0};
        if (
            NvRmConfigGetEx(
                vpp.pDriverData->dwRootHandle,
                vpp.pDriverData->dwDeviceHandle,
                NV_CFGEX_GET_SURFACE_PITCH,
                &params, sizeof(params)) == NVOS_CGE_STATUS_SUCCESS) {
            vpp.dwOverlayFSPitch = params.Pitch;
        } else {
            // RM call failed, try to figure it out ourselves
            vpp.dwOverlayFSPitch  = ((vpp.dwOverlayFSWidth * vpp.dwOverlayFSFormat) + vpp.pDriverData->dwSurfaceAlignPad) & ~vpp.pDriverData->dwSurfaceAlignPad;
        }

        // create offscreen FS mirror surfaces
        dwBlockSize = vpp.dwOverlayFSPitch * vpp.dwOverlayFSHeight;
        for (i=0; i<NV_MAX_EXTRA_FS_SURFACES; i++) {
            NVHEAP_ALLOC (dwStatus, vpp.dwOverlayFSOffset[i], dwBlockSize, TYPE_IMAGE);
            if (dwStatus==0)
            {
                vpp.dwOverlayFSNumSurfaces++;
                vpp.dwOverlayFSOffset[i] = VIDMEM_OFFSET(vpp.dwOverlayFSOffset[i]);

                // strange bug: running vppBltFillBlock to zero out the FS mirror surfaces
                // makes the VPE overlay (in nvpecore.c) nonfunctional. Workaround:
                // don't do the blit if VPE is initialized. -FCF
                if (!vpp.pDriverData->nvpeState.bVPEInitialized) {
                if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSASPECT) {
                    // will be preserving aspect, need to zero these surfaces
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[i], vpp.dwOverlayFSPitch,
                        vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, max(vpp.dwOverlayFSFormat, 2));
                }
                }
            }
            else
            {
                dbgError("Failed to allocate offscreen FS-mirror surfaces");
            }
        }

        if (vpp.dwOverlayFSNumSurfaces == 0) {
#if IS_WINNT5
            // we failed restore the display mode
            RESOLUTION_INFO res;
            res.ulDisplayWidth      = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].right -
                                      vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].left;
            res.ulDisplayHeight     = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].bottom -
                                      vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].top;
            switch (vpp.m_ppdev->cjPelSize) {
            case 1:  res.ulDisplayPixelDepth = BMF_8BPP;  break;
            case 4:  res.ulDisplayPixelDepth = BMF_32BPP; break;
            default: res.ulDisplayPixelDepth = BMF_16BPP; break;
            }
            res.ulDisplayRefresh    = vpp.m_ppdev->ulRefreshRate[vpp.dwOverlayFSHead];
            NvSetDac(vpp.m_ppdev, vpp.dwOverlayFSHead, &res);
#elif IS_WIN9X
            // we failed, unlock
            vpp.dwOverlayFSTwinData.dwFlag = NVTWINVIEW_FLAG_SET;
            vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_UNLOCK_HWCRTC;
            vpp.dwOverlayFSTwinData.dwCrtc = dwPhysicalHead;     // leave as physical head
            MyExtEscape (dwDCHead, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                         (LPCSTR) &vpp.dwOverlayFSTwinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);
#endif
            return FALSE;
        } else {
/*
            if ((dwDeviceType == MONITOR_TYPE_NTSC || dwDeviceType == MONITOR_TYPE_PAL) ) {
                NV_CFGEX_SET_MACROVISION_MODE_PARAMS    mvParams;
                // To be safe, always turn on Macrovision even though we don't know that it's DVD playing.
                // Unfortunately, this is overkill but we have to be diligent legally. (Until we figure out
                // a better way to make our macrovision more secure.)
                mvParams.head = dwPhysicalHead;
                mvParams.resx = vpp.dwOverlayFSWidth;
                mvParams.resy = vpp.dwOverlayFSHeight;
                mvParams.mode = 3;  // modes are 1-3, arbitrarly use 3 (DVD players will reset it)
                // TODO:  We could define a macro (NvRmConfigSetEX) for this call in WinNT.  Every other RM config call has one.
#ifdef WINNT
                NvConfigSetEx(vpp.m_ppdev->hDriver, vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                                NV_CFGEX_SET_MACROVISION_MODE, &mvParams, sizeof(mvParams));
#else
                NvRmConfigSetEx(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                                NV_CFGEX_SET_MACROVISION_MODE, &mvParams, sizeof(mvParams));
#endif
            }
*/
            // fill in other info
            vpp.dwOverlayFSDeltaX = 0;
            vpp.dwOverlayFSDeltaY = 0;
            vpp.dwOverlayFSIndex = 0;
            switch (vpp.dwOverlayFSFormat) {
            case 1:  vpp.dwOverlayFSFormat = NV062_SET_COLOR_FORMAT_LE_Y8;                break;
            case 4:  vpp.dwOverlayFSFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8; break;
            default: vpp.dwOverlayFSFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;            break;
            }
        }
    } else {
        return FALSE;
    }

#if IS_WINNT5
   DisableHeadCursor(vpp.m_ppdev, vpp.dwOverlayFSHead, TRUE);
#endif

    // Perform a quick flip to clear out the full screen memory.
    lpProcInfo = pmGetProcess(vpp.pDriverData, nvGetCurrentProcessId());
    vppFSFlipSync(pVpp,lpProcInfo, 0, 0);
    vppFSFlip(pVpp,lpProcInfo, 0);

    vpp.dwFlags |= VPP_FLAG_MIRROR_READY;
    return TRUE;
#endif // End if IS_WINNT4
}


//---------------------------------------------------------------------------
// vppDestroyFSMirror
//      Frees all the objects created in vppCreateFSMirror
extern void VppDestroyFSMirror(Vpp_t *pVpp)
{
    nvAssert(pVpp);

    if (!(pVpp->dwFlags & VPP_FLAG_MIRROR_READY))   // It hasn't been created
    {
        return;
    }

#if (IS_WINNT5 || IS_WIN9X)
    DWORD i;
    Vpp_t &vpp = *pVpp;
    LPPROCESSINFO lpProcInfo = pmGetProcess(vpp.pDriverData, nvGetCurrentProcessId());

    // destroy FS mirror surfaces
    if (vpp.dwOverlayFSNumSurfaces > 0) {
#if IS_WINNT5
        RESOLUTION_INFO res;

        vppFSFlipSync(pVpp,lpProcInfo, 0, TRUE);
        vppFSFlipSync(pVpp,lpProcInfo, 1, TRUE);

        // restore the display mode
        res.ulDisplayWidth      = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].right -
                                  vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].left;
        res.ulDisplayHeight     = vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].bottom -
                                  vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].top;

        switch (vpp.m_ppdev->cjPelSize) {
        case 1:  res.ulDisplayPixelDepth = BMF_8BPP;  break;
        case 4:  res.ulDisplayPixelDepth = BMF_32BPP; break;
        default: res.ulDisplayPixelDepth = BMF_16BPP; break;
        }
        res.ulDisplayRefresh    = vpp.m_ppdev->ulRefreshRate[vpp.dwOverlayFSHead];

        // Get DAC back into the correct resolution
        NvSetDac(vpp.m_ppdev, vpp.dwOverlayFSHead, &res);

        // Re-enable the cursor
        DisableHeadCursor(vpp.m_ppdev, vpp.dwOverlayFSHead, FALSE);

        // Reset the current display rectangle to zero (resets panning values)
        vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].right   = res.ulDisplayWidth;
        vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].bottom  = res.ulDisplayHeight;
        vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].left    = 0;
        vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead].top     = 0;

        // Get DAC pointing back to the proper memory area
        NvSetDacImageOffset(vpp.m_ppdev, vpp.dwOverlayFSHead, 0);

        // Reset panning
        NVMoveDisplayWindow(vpp.m_ppdev, vpp.dwOverlayFSHead,&vpp.m_ppdev->rclCurrentDisplay[vpp.dwOverlayFSHead]);
#elif IS_WIN9X
        // get physical head number
        DWORD dwPhysicalHead;
        if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
            NVTWINVIEWDATA twinData;
            twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
            twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
            twinData.dwCrtc   = vpp.dwOverlayFSHead;
            MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
            dwPhysicalHead = twinData.dwCrtc;
        } else {
            dwPhysicalHead = vpp.dwOverlayFSHead;
        }

        // unlock the head CRTC
        vpp.dwOverlayFSTwinData.dwFlag = NVTWINVIEW_FLAG_SET;
        vpp.dwOverlayFSTwinData.dwAction = NVTWINVIEW_ACTION_UNLOCK_HWCRTC;
        vpp.dwOverlayFSTwinData.dwCrtc = dwPhysicalHead;
        MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPCSTR) &vpp.dwOverlayFSTwinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &vpp.dwOverlayFSTwinData);
#endif

        for (i=0; i<NV_MAX_EXTRA_FS_SURFACES; i++) {
            if (vpp.dwOverlayFSOffset[i]) {
                NVHEAP_FREE(vpp.dwOverlayFSOffset[i] + vpp.pDriverData->BaseAddress);
            }
            vpp.dwOverlayFSOffset[i] = 0;
        }
    }

    vpp.dwOverlayFSWidth = 0;
    vpp.dwOverlayFSHeight = 0;
    vpp.dwOverlayFSFormat = 0;
    vpp.dwOverlayFSPitch = 0;
    vpp.dwOverlayFSIndex = 0;
    vpp.dwOverlayFSNumSurfaces = 0;
    vpp.dwOverlayFSDeltaX = 0;
    vpp.dwOverlayFSDeltaY = 0;
    vpp.dwOverlayFSHead = 0xFFFFFFFF;

    vpp.dwFlags &= ~VPP_FLAG_MIRROR_READY;

#endif // End if (IS_WINNT5 || IS_WIN9X)
}



//---------------------------------------------------------------------------
// VppReadRegistry()
//
//---------------------------------------------------------------------------
extern NvU8 VppReadRegistry(Vpp_t *pVpp, HANDLE hDriver, NvU32 logicalHeadID)
{
    Vpp_t &vpp = *pVpp;

    nvAssert(pVpp);

    if (vpp.pDriverData==NULL || vpp.pSysInfo==NULL)
    {
        nvAssert(FALSE);  // On DBG builds, stop here... need to know if/when this occurs
        return TRUE;      // We were called before VppConstructor -- skip registry read benignly
    }

    if (vpp.regTool.Open(hDriver, logicalHeadID, NV4_REG_DIRECT_DRAW_SUBKEY))
    {
        vpp.regTool.Read(NV4_REG_OVL_MODE,  vpp.regOverlayMode);
        vpp.regTool.Read(NV4_REG_OVL_MODE2, vpp.regOverlayMode2);
        vpp.regTool.Read(NV4_REG_OVL_MODE3, vpp.regOverlayMode3);
        vpp.regTool.Read(NV4_REG_VPP_INV_MASK, vpp.regVPPInvMask);
        vpp.regTool.Read(NV4_REG_VPP_MAX_SURFACES, vpp.regVPPMaxSurfaces);
        vpp.regTool.Read(NV4_REG_OVLCC_ENABLE, vpp.regOverlayColourControlEnable);
#if IS_WIN9X
        vpp.regTool.Read(NV4_REG_VIDEO_BUS_MASTER_MODE, vpp.pDriverData->regTVTunerHack);
        vpp.regTool.Read(NV4_REG_ENUM_REFRESH, vpp.pDriverData->regEnumDDRefresh);
#endif

#if (IS_WIN9X || IS_WINNT5) && !defined(NVPE)
        vpp.regTool.Read(NV4_REG_VPE_ENABLE, vpp.pDriverData->bEnableVPE);  //check for VPE enable bit
#endif

        if (vpp.regTool.Read(NV4_REG_OVLCC_BRIGHTNESS, vpp.colorCtrl.lBrightness))
        {
            if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                // range should be from -10000 to +10000
                vpp.colorCtrl.lBrightness = min(max(vpp.colorCtrl.lBrightness * 10000 / 255, -10000), 10000);
            } else {
                // range should be from -100 to +100, but -256 to +255 is still legal
                vpp.colorCtrl.lBrightness = min(max(vpp.colorCtrl.lBrightness, -256), 255);
            }
        }

        if (vpp.regTool.Read(NV4_REG_OVLCC_CONTRAST, vpp.colorCtrl.lContrast))
        {
            if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                // convert range of 0 to 200% to 0 to 20000
                vpp.colorCtrl.lContrast = min(max(vpp.colorCtrl.lContrast * 20000 / 200, 0), 20000);
            } else {
                // convert range of 0 to 200% to 0 to 511
                vpp.colorCtrl.lContrast = min(max(vpp.colorCtrl.lContrast * 511 / 200, 0), 511);
            }
        }

        if (vpp.regTool.Read(NV4_REG_OVLCC_HUE, vpp.colorCtrl.lHue))
        {
            // range is 0 to 359 degrees
            while (vpp.colorCtrl.lHue < 0)    vpp.colorCtrl.lHue += 360;
            while (vpp.colorCtrl.lHue >= 360) vpp.colorCtrl.lHue -= 360;
        }

        if (vpp.regTool.Read(NV4_REG_OVLCC_SATURATION, vpp.colorCtrl.lSaturation))
        {
            if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
                // convert range of 0 to 200% to 0 to 20000
                vpp.colorCtrl.lSaturation = min(max(vpp.colorCtrl.lSaturation * 20000 / 200, 0), 20000);
            } else {
                // convert range of 0 to 200% to 0 to 511
                vpp.colorCtrl.lSaturation = min(max(vpp.colorCtrl.lSaturation * 512 / 200, 0), 512);
            }
        }

        vpp.regTool.Close();
    }

    // can't do this unless more than 4M and MMX instructions available
    if (!(vpp.pSysInfo->dwCPUFeatureSet & CPU_FS_MMX) || (vpp.pDriverData->TotalVRAM <= 0x400000)) {
        vpp.regOverlayColourControlEnable = FALSE;
    }

    // Disable HQVUp on less than 16M
    if (vpp.pDriverData->TotalVRAM < 0x1000000) {
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
    }

    if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        // Disable HQVUp and sw colour controls on NV10/NV20
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_VUPSCALE;
        vpp.regOverlayColourControlEnable = FALSE;
        if (vpp.pDriverData->TotalVRAM < 0x800000) {
            // Disable temporal and deinterlace filters on NV10/NV20 if less than 8M
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
        }
    } else {
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_DFILTER;
        if (vpp.pDriverData->TotalVRAM < 0x1000000) {
            // Disable temporal filter on NV4/5 if less than 16M
            vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_TFILTER;
        }
    }

    // Disable fullscreen mirror on non-dual head devices
    if (vpp.pDriverData->dwHeads < 2) {
        vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSDEVICEMASK;
    }

    return TRUE;
}

LOCAL BOOL vppAllocateObjects(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    int i;
    BOOL bSuccess = TRUE;

    nvAssert(vpp.hChannel != NULL);

    // Allocate each object in the array; skip OVERLAY (done @ vppEnable)
    //
    for(i=1; bSuccess && i<VPP_OBJECT_COUNT; i++)
    {
        if (vpp.m_obj_a[i].status == VPP_OBJ_FREED)
        {
            vpp.m_obj_a[i].status =
                NvRmAllocObject(vpp.pDriverData->dwRootHandle, vpp.hChannel,vpp.m_obj_a[i].classIID,vpp.m_obj_a[i].classNdx)
                ? VPP_OBJ_ERROR:VPP_OBJ_ALLOCATED;
            bSuccess = (vpp.m_obj_a[i].status == VPP_OBJ_ALLOCATED);
            if (!bSuccess)
            {
                dbgError("Failed object allocation in VPP.");
            }
        }
    }

    // Set the DMA context NOTIFIER on all objects (excluding overlay)
    //   Note: We use the NV07A_SET_CONTEXT_DMA_NOTIFIES member for ALL objects in our array.
    //         This loop assumes all objects have their notifier set method @ that offset (and they must!)
    //
    for(i=1; bSuccess && i<VPP_OBJECT_COUNT; i++)
    {
        if (vpp.m_obj_a[i].status == VPP_OBJ_ALLOCATED)
        {
            vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[i].classIID);
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
            vpp.pPusher->push(1, vpp.m_obj_a[i].contextIID);         // SetContextDmaNotifies
            vpp.pPusher->adjust(2);
        }
    }
    vpp.pPusher->start(TRUE);

    return bSuccess;
}

LOCAL void vppFreeObjects(Vpp_t *pVpp)
{
    int i;
    Vpp_t &vpp = *pVpp;

    nvAssert(vpp.hChannel != NULL);

    for(i=0; i<VPP_OBJECT_COUNT; i++)
    {
        if (vpp.m_obj_a[i].status == VPP_OBJ_ALLOCATED)
        {
            NvRmFree(vpp.pDriverData->dwRootHandle, vpp.hChannel,vpp.m_obj_a[i].classIID);
            vpp.m_obj_a[i].status = VPP_OBJ_FREED;
        }
    }
}

// Since different objects have different initialization requirements,
// this function is readily 'automated'.
LOCAL void vppInitObjects(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    int i;

    // Swizzle
    if (vpp.m_obj_a[SWIZZLE_NDX].status == VPP_OBJ_ALLOCATED)
    {
        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[SWIZZLE_NDX].classIID);
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV077_SET_CONTEXT_DMA_IMAGE | 0x40000);
        vpp.pPusher->push(1, vpp.hInVideoMemContextDma);       // SetContextDmaImage
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV077_SET_CONTEXT_SURFACE | 0x40000);
        vpp.pPusher->push(3, vpp.hContextSurfaceSwizzled);                // SetContextSurface
        vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | NV077_SET_COLOR_FORMAT | 0x80000);
        vpp.pPusher->push(5, NV077_SET_COLOR_FORMAT_LE_A8R8G8B8);          // SetColorFormat
        vpp.pPusher->push(6, NV077_SET_OPERATION_SRCCOPY);                 // SetOperation
        vpp.pPusher->adjust(7);
    }

    // Alpha Blt
    nvAssert(vpp.m_obj_a[ALPHA_BLT_NDX].status == VPP_OBJ_ALLOCATED);
    vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV05F_SET_CONTEXT_BETA4 | 0x40000);
    vpp.pPusher->push(1, vpp.hContextBeta4);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV05F_SET_OPERATION | 0x40000);
    vpp.pPusher->push(3, NV05F_SET_OPERATION_SRCCOPY_PREMULT);
    vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | NV05F_SET_CONTEXT_SURFACES | 0x40000);
    vpp.pPusher->push(5, vpp.hSurfaces2D);
    vpp.pPusher->adjust(6);

    // V2V Format
    nvAssert(vpp.m_obj_a[V2V_FORMAT_NDX].status == VPP_OBJ_ALLOCATED);
    vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[V2V_FORMAT_NDX].classIID);
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
    vpp.pPusher->push(1, vpp.hFromVideoMemContextDma);     // SetContextDmaBufferIn
    vpp.pPusher->push(2, vpp.hToVideoMemContextDma);       // SetContextDmaBufferOut
    vpp.pPusher->adjust(3);

    // Scaled Image (2 of them in sequence)
    nvAssert(SCALED_IMAGE2_NDX == SCALED_IMAGE1_NDX+1);
    for(i=0; i<2 ;i++)
    {
        int objNdx = SCALED_IMAGE1_NDX+i;
        if (vpp.m_obj_a[objNdx].status == VPP_OBJ_ALLOCATED)
        {
            vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[objNdx].classIID);

            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV063_SET_CONTEXT_PATTERN | 0x80000 );
            vpp.pPusher->push(1, vpp.hContextPattern);         // SetContextPattern
            vpp.pPusher->push(2, vpp.hContextRop);             // SetContextRop

            vpp.pPusher->push(3, SUB_CHANNEL(vpp.spareSubCh) | NV063_SET_OPERATION | 0x40000);
            vpp.pPusher->push(4, NV063_SET_OPERATION_ROP_AND);  // SetOperation

            vpp.pPusher->adjust(5);

            if (vpp.m_obj_a[objNdx].classNdx == NV05_SCALED_IMAGE_FROM_MEMORY)
            {
                vpp.pPusher->push(0,SUB_CHANNEL(vpp.spareSubCh) | NV063_SET_COLOR_CONVERSION | 0x40000);
                vpp.pPusher->push(1,NV063_SET_COLOR_CONVERSION_TRUNCATE);
                vpp.pPusher->adjust(2);
            }
        }
    }

    nvAssert(vpp.m_obj_a[DVDPICT_NDX].status == VPP_OBJ_ALLOCATED);
    vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[DVDPICT_NDX].classIID);
    vpp.pPusher->push(0,SUB_CHANNEL(vpp.spareSubCh) + NV038_SET_CONTEXT_DMA_OVERLAY | 0xC0000);
    vpp.pPusher->push(1,vpp.hFromVideoMemContextDma);
    vpp.pPusher->push(2,vpp.hFromVideoMemContextDma);
    vpp.pPusher->push(3,vpp.hToVideoMemContextDma);
    vpp.pPusher->adjust(4);

    vpp.pDriverData->dDrawSpareSubchannelObject = 0;
    vpp.pPusher->start(TRUE);
}


// NB: We don't yet know (since this is called at constructor time) whether or not
//     any given object is going to be valid.  Therefore we allocate a context DMA
//     for ALL of them.
LOCAL BOOL vppAllocateContextDMAs(Vpp_t *pVpp)
{
    NvU32 status;
    Vpp_t &vpp = *pVpp;
    int i;
    NvU32 contextSize;
    NvU8 *pContextBase;
    int notifierCount;
    NvU32 notifierMemSize;

// This is horrible!  This is so some of the code below which looks like function calls but
//  are actually macros, will get the right value! @mjl@ TBD
#ifdef WINNT
    PDEV *ppdev = pVpp->m_ppdev;
#endif
  
    // Determine how many notifiers total we have
    notifierCount = 0;
    for(i=0; i<VPP_OBJECT_COUNT; i++)
    {
        notifierCount += vpp.m_obj_a[i].notifierCount;
    }

    notifierMemSize = sizeof(NvNotification) * notifierCount;

    // Allocate memory for a bunch of notifiers and the scanline buffer.
    // We must allocate the memory for this structure out of SHARED or
    // SYSTEM space -- not out of App space so don't use GlobalAlloc.

    // TBD: Why doesn't this use AllocIPM? @mjl@
#if (IS_WINNT4 || IS_WINNT5)

    // Under Win2K and WinNT4 this routine is called once when the state is
    // created, and once again after every mode change. Only alloc
    // the notifier buffer and the notfier context DMAs once.
    if (!vpp.m_pContextDMABase)
    {
        vpp.m_pContextDMABase = (DWORD) EngAllocMem(FL_ZERO_MEMORY, (notifierMemSize), 'x_VN');
    }

#else // !WINNT
    {
        NvU32 dwMem[2];
        NvU32 notifierMemoryLimit;

        // Round up to nearest 4k or resman will fail the call
        //   The -1 changes this into a 'limit' which is what the call below requires
        //
        notifierMemoryLimit = ((notifierMemSize + 0xfff) & ~0xfff) - 1;

        if (NvRmAllocMemory (vpp.pDriverData->dwRootHandle,
                             vpp.pDriverData->dwDeviceHandle, NV_VPP_CONTEXT_DMA_MEMORY_IID,
                             NV01_MEMORY_SYSTEM,
                             (NVOS02_FLAGS_PHYSICALITY_NONCONTIGUOUS << 4) |
                             (NVOS02_FLAGS_LOCATION_PCI << 8) |
                             (NVOS02_FLAGS_COHERENCY_CACHED << 12),
                             (PVOID *) dwMem, &notifierMemoryLimit))
        {
            vpp.m_pContextDMABase = NULL;
        }
        else
        {
            vpp.m_pContextDMABase = dwMem[0];
        }
    }

#endif // !WINNT

    if (vpp.m_pContextDMABase == NULL)
    {
        dbgError("Failed to allocate context DMA memory block");
        dbgTracePop();
        return(FALSE);
    }

    for(pContextBase=(NvU8 *)vpp.m_pContextDMABase,i=0; i<VPP_OBJECT_COUNT; i++)
    {
        contextSize = vpp.m_obj_a[i].notifierCount*sizeof(NvNotification);
        
        status = NvRmAllocContextDma(
            vpp.pDriverData->dwRootHandle,
            vpp.m_obj_a[i].contextIID,
            NV01_CONTEXT_DMA,
            DRF_DEF(OS03, _FLAGS, _ACCESS,    _READ_WRITE) |
            DRF_DEF(OS03, _FLAGS, _LOCKED,    _ALWAYS) |
            DRF_DEF(OS03, _FLAGS, _COHERENCY, _CACHED),
            pContextBase,contextSize-1);
        
        vpp.m_obj_a[i].notifier_a = (volatile NvNotification *)pContextBase;   // Each of these context DMAs is used as a notifier
        
        pContextBase += contextSize;
        
        if (status!=0)
        {
            dbgError("VPP: Failed allocateContextDMAs()");
            return(FALSE);
        }
    }
    
    return (TRUE);
}

LOCAL void vppFreeContextDMAs(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    int i;
    
    nvAssert(pVpp != NULL);
    nvAssert(vpp.pDriverData != NULL);
    nvAssert(vpp.pDriverData->dwRootHandle != 0);
    nvAssert(vpp.pDriverData->dwDeviceHandle != 0);
    nvAssert(vpp.m_pContextDMABase != NULL);

// This is horrible!  This is so some of the code below which looks like function calls but
//  are actually macros, will get the right value! @mjl@ TBD
#ifdef WINNT
    PDEV *ppdev = pVpp->m_ppdev;
#endif

    for(i=0; i<VPP_OBJECT_COUNT; i++)
    {
        NvRmFree(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,vpp.m_obj_a[i].contextIID);
        vpp.m_obj_a[i].notifier_a = NULL;
    }
    
#if (IS_WINNT4 || IS_WINNT5)
    if (vpp.m_pContextDMABase)
    {
        EngFreeMem((PVOID) vpp.m_pContextDMABase);
        vpp.m_pContextDMABase = NULL;
    }
#else
    NvRmFree(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,NV_VPP_CONTEXT_DMA_MEMORY_IID);
#endif

}

//
// Determine which head the overlay will go on.  Result is stored
// in vpp.dwOverlayFSOvlHead.
//
LOCAL void vppChooseOverlayHead(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    DWORD dwOverlayDeviceType;
    NV_CFGEX_GET_DISPLAY_TYPE_MULTI_PARAMS displayParams;

#if (!IS_WINNT4)
    ResetTwinViewState(vpp.pDriverData);
#endif

                                    // Logical index of the requested full screen device
    DWORD dwRequestedFSDevice = (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) - 1;
    DWORD dwAssignedOvlDevice = 0;  // Logical index of the overlay device, default to first head

    if (vpp.pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE &&
        dwRequestedFSDevice != 0xFFFFFFFF)
    {
        // We are in clone mode AND Video Mirror is enabled
        if (dwRequestedFSDevice < 14) {
            // Not in Auto-Select mode, deduce overlay head from FS head
            dwAssignedOvlDevice = dwRequestedFSDevice ^ 1;
        }
#ifndef WINNT
    }
    else
    {
        // We are NOT in clone mode OR we are in clone mode with Video
        // Mirror disabled
        dwAssignedOvlDevice = pDXShare->dwHeadNumber;
#endif
    }
    
#if (IS_WIN9X)
    // RM needs physical head, map logical to physical
    NVTWINVIEWDATA twinData;
    twinData.dwFlag   = NVTWINVIEW_FLAG_GET;
    twinData.dwAction = NVTWINVIEW_ACTION_MAP_LOG_TO_PHYS_HEAD;
    twinData.dwCrtc   = dwAssignedOvlDevice;
    MyExtEscape (pDXShare->dwHeadNumber, NV_ESC_SETGET_TWINVIEW_DATA, sizeof(NV_ESC_SETGET_TWINVIEW_DATA),
                 (LPCSTR) &twinData, sizeof(NV_ESC_SETGET_TWINVIEW_DATA), (LPSTR) &twinData);
    
    // Display device type retrieval will use the physical index of the overlay head
    displayParams.Head = twinData.dwCrtc;

    // Win9x will remember the overlay head with its -logical- index
    vpp.dwOverlayFSOvlHead = twinData.dwCrtc;
#else
    // Device type retrieval will use the physical index of the overlay head
    displayParams.Head = vpp.m_ppdev->ulDeviceDisplay[dwAssignedOvlDevice];
    
    // WinNT/2K/XP will remember the ovelay head with its -physical- index
    vpp.dwOverlayFSOvlHead = displayParams.Head;
#endif

    NvRmConfigGetEx(vpp.pDriverData->dwRootHandle, vpp.pDriverData->dwDeviceHandle,
                    NV_CFGEX_GET_DISPLAY_TYPE_MULTI,
                    &displayParams, sizeof(displayParams));
    dwOverlayDeviceType = displayParams.Type;

    // Set flag to say whether the overlay is on a flat panel.
    // This is used later by UpdateOverlay32.
    if (dwOverlayDeviceType == DISPLAY_TYPE_FLAT_PANEL)
    {
        vpp.dwNVOverlayFlags |= OVERLAY_FLAG_ON_PANEL;
    }
    else
    {
        vpp.dwNVOverlayFlags &= ~OVERLAY_FLAG_ON_PANEL;
    }
}

// The overlay object is SPECIAL since it requires a parameter to specify the
// head on which to create it.
LOCAL NvU8 vppAllocOverlay(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    NV07A_ALLOCATION_PARAMETERS nv07aAllocParms;
    nvAssert(vpp.m_obj_a[OVERLAY_NDX].status == VPP_OBJ_FREED);
    nvAssert(vpp.hChannel != NULL);

    nv07aAllocParms.logicalHeadId = vpp.dwOverlayFSOvlHead;
    vpp.m_obj_a[OVERLAY_NDX].status =
        NvRmAlloc(vpp.pDriverData->dwRootHandle,vpp.hChannel,
              vpp.m_obj_a[OVERLAY_NDX].classIID,
              vpp.m_obj_a[OVERLAY_NDX].classNdx,
              &nv07aAllocParms)
        ? VPP_OBJ_ERROR:VPP_OBJ_ALLOCATED;

    if (vpp.m_obj_a[OVERLAY_NDX].status == VPP_OBJ_ERROR)
    {
        dbgError("VPP overlay allocation failed!");
        return FALSE;
    }

    // Special Case -- we've created the overlay and it's notifiers as part of the VPP,
    // but much of the driver [currently] needs direct access to these notifiers.
    // For now, we re-initialize the driver value to the "correct one".  Eventually, all
    // driver components that need to wait for the overlay notifiers to clear should call
    // a vpp function to do it for them.

    // Tell the rest of the driver where the real overlay notifier is located
    vpp.pDriverData->pPioFlipOverlayNotifierFlat = vpp.m_obj_a[OVERLAY_NDX].notifier_a;

    // Don't know if this is necessary here... @mjl@
    // Deal with possible mode change during pending flip

//    if (vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status == NV_IN_PROGRESS) {
//        long countDown = 0x200000;
//        while ((vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status == NV_IN_PROGRESS) && (--countDown > 0));
//    }
//    if (vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status == NV_IN_PROGRESS) {
//        long countDown = 0x200000;
//        while ((vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status == NV_IN_PROGRESS) && (--countDown > 0));
//    }

    // clear all status flags before first use
    vpp.m_obj_a[OVERLAY_NDX].notifier_a[0].status = 0;
    vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status = 0;
    vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status = 0;

    // Initialize the overlay
    vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[OVERLAY_NDX].classIID);
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_CONTEXT_DMA_NOTIFIES | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[OVERLAY_NDX].contextIID);         // SetContextDmaNotifies
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_CONTEXT_DMA_OVERLAY(0) | 0x80000);
    vpp.pPusher->push(3, vpp.hFromVideoMemContextDma);                 // SetContextDmaOverlay(0)
    vpp.pPusher->push(4, vpp.hFromVideoMemContextDma);                 // SetContextDmaOverlay(1)
    vpp.pPusher->adjust(5);
    return TRUE;
}

LOCAL void vppFreeOverlay(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    nvAssert(vpp.hChannel != NULL);

    NvRmFree(vpp.pDriverData->dwRootHandle, vpp.hChannel,vpp.m_obj_a[OVERLAY_NDX].classIID);
    vpp.m_obj_a[OVERLAY_NDX].status = VPP_OBJ_FREED;
}


//---------------------------------------------------------------------------
// VppCreateOverlay
//      Initializes some objects used by the VPP (TBD update this comment block @mjl@)
//
// Objects we don't need to create because they already exist:
//      D3D_CELSIUS_PRIMITIVE or D3D_KELVIN_PRIMITIVE (we initialize here)
//      NV_DD_CONTEXT_BETA4
//      NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT
//      NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT
//
// Events (created in nvProcMan):
//      NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC -> NV_VPP_V2OSH_FORMAT
//      NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC -> NV_VPP_OSH2V_FORMAT
//      NV_DD_EVENT_COMBINER_SYNC        -> vpp.hDX6MultiTextureTriangle
//
// Notifiers (created in ddDrv):
//      NV_DD_DMA_VPP_NOTIFIER

extern BOOL VppCreateOverlay(Vpp_t *pVpp)
{
    BOOL retCode = TRUE;
    Vpp_t &vpp = *pVpp;

    nvAssert(pVpp);

    // During modeset on win9x, this is called before enable (in nvEnable)
    //   Is that really necessary? @mjl@
    if (!(vpp.dwFlags & VPP_FLAG_ENABLED))
    {
        return FALSE;
    }

    nvAssert(!(vpp.dwFlags & VPP_FLAG_OVERLAY_READY));

    // This is only going to happen if one of the asserts fire... but this gives us
    // a chance to get further in the debug session...
#ifdef DEBUG
    if (vpp.pDriverData == NULL) return TRUE;
#endif

    vppChooseOverlayHead(pVpp);

    if (!vppAllocOverlay(pVpp)) 
    {
        return FALSE;
    }
    vpp.dwFlags |= VPP_FLAG_OVERLAY_READY;  // Set now so VppSetOverlayColourControl will know that overlay obj exists

    //
    // 3d object must already be created outside of the VPP, just fill in some default values
    //
    if (vpp.dwFlags & VPP_FLAG_CELSIUS_3D)
    {
        vppInitCelsius(pVpp);
    }
    else if (vpp.dwFlags & VPP_FLAG_KELVIN_3D)
    {
        vppInitKelvin(pVpp);
    }

    pmAddProcess(vpp.pDriverData, nvGetCurrentProcessId());

    VppSetOverlayColourControl(pVpp);

    vpp.dwOverlayFSOvlLost = FALSE;

    vpp.llDeliveryPeriod = 0;
    vpp.llDeliveryTime = 0;

    return retCode;
}

//---------------------------------------------------------------------------
// VppDestroyOverlay
//
extern void VppDestroyOverlay(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;

    if (!(pVpp->dwFlags & VPP_FLAG_OVERLAY_READY))   // It hasn't been created
    {
        return;
    }

#ifdef IKOS
    // To avoid a race (shows up in IKOS), make sure our push buffer is flushed before calling NvRmFree
    // NOTE:  enable this in non-IKOS builds once it's been tested more
    vpp.pPusher->flush(TRUE);
#endif

    // Delete events tied to objects before freeing the parent objects
    pmDeleteAllProcesses(vpp.pDriverData); // On NT4/2k this only removes all events

    vppFreeOverlay(pVpp);

    vpp.dwOverlayFSOvlHead = 0xFFFFFFFF;
    vpp.dwFlags &= ~VPP_FLAG_OVERLAY_READY;
}

//---------------------------------------------------------------------------
// VppDisable

extern void VppDisable(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;

    // In some shutdown scenarios, disable may be called regardless of current state
    if (!(vpp.dwFlags & VPP_FLAG_ENABLED)) return;

#ifdef IKOS
    // To avoid a race (shows up in IKOS), make sure our push buffer is flushed before calling NvRmFree
    // NOTE:  enable this in non-IKOS builds once it's been tested more
    vpp.pPusher->flush(TRUE);
#endif

    vppFreeObjects(pVpp);

    vpp.dwFlags &= ~VPP_FLAG_ENABLED;
}


//---------------------------------------------------------------------------
//  VppEnable
//
//    Defines and creates various resources needed to operate the VPP.
//
//---------------------------------------------------------------------------
extern NvU8 VppEnable(
    Vpp_t           *pVpp,
    PDEV            *ppdev,
    CPushBuffer     *pPusher,
    NvU32            hChannel,
    NvU32            hThreeDClass,
    NvU32            threeDClassSubCh,
    NvU32            *pThreeDClassLastUser,
    NvU32            hInVideoMemContextDma,
    NvU32            hFromVideoMemContextDma,
    NvU32            hToVideoMemContextDma,
    NvU32            hLutCursorDacBase,
    NvU32            hMiscEventNotifier,
    NvU32            hContextSurfaceSwizzled,
    NvU32            hContextBeta4,
    NvU32            hSurfaces2D,
    NvU32            surfaces2DSubCh,
    NvU32            hVideoMemUtoVideoMemFormat,     // U-conversion object
    NvU32            hVideoMemVtoVideoMemFormat,     // V-conversion object
    NvU32            hVideoMemUVtoVideoMemFormat,    // V-conversion object

    NvU32            unused1,
    NvU32            hContextPattern,
    NvU32            hContextRop,
    NvU32            hContextColorKey,
    NvU32            hFloatingContextDmaInOverlayShadow,

    NvNotification  *pFlipPrimaryNotifier,
    NvNotification  *pPusherSyncNotifier,
    NvNotification  *pUnused,

    NvU32            hContextSurfacesARGB_ZS,
    NvU32            hDX6MultiTextureTriangle,
    NvU32            hImageBlackRect,

    NvU32            ropRectTextSubCh,
    NvU32            ropSubCh,
    NvU32            spareSubCh)
{
    Vpp_t &vpp = *pVpp;

    nvAssert(vpp.dwFlags & VPP_FLAG_CONSTRUCTED);
    nvAssert(!(vpp.dwFlags & VPP_FLAG_ENABLED));

    vpp.m_ppdev                            = ppdev;
    vpp.pPusher                            = pPusher;
    vpp.hThreeDClass                       = hThreeDClass;
    vpp.hChannel                           = hChannel;
    vpp.threeDClassSubCh                   = threeDClassSubCh;
    vpp.pThreeDClassLastUser               = pThreeDClassLastUser;
    vpp.hInVideoMemContextDma              = hInVideoMemContextDma;
    vpp.hFromVideoMemContextDma            = hFromVideoMemContextDma;
    vpp.hToVideoMemContextDma              = hToVideoMemContextDma;
    vpp.hLutCursorDacBase                  = hLutCursorDacBase;
    vpp.hMiscEventNotifier                 = hMiscEventNotifier;
    vpp.hContextSurfaceSwizzled            = hContextSurfaceSwizzled;
    vpp.hContextBeta4                      = hContextBeta4;
    vpp.hSurfaces2D                        = hSurfaces2D;
    vpp.surfaces2DSubCh                    = surfaces2DSubCh;
    vpp.hVideoMemUtoVideoMemFormat         = hVideoMemUtoVideoMemFormat;
    vpp.hVideoMemVtoVideoMemFormat         = hVideoMemVtoVideoMemFormat;
    vpp.hVideoMemUVtoVideoMemFormat        = hVideoMemUVtoVideoMemFormat;

    vpp.hContextPattern                    = hContextPattern;
    vpp.hContextRop                        = hContextRop;
    vpp.hContextColorKey                   = hContextColorKey;
    vpp.hFloatingContextDmaInOverlayShadow = hFloatingContextDmaInOverlayShadow;

    vpp.pFlipPrimaryNotifier               = pFlipPrimaryNotifier;
    vpp.pPusherSyncNotifier                = pPusherSyncNotifier;

    vpp.hContextSurfacesARGB_ZS            = hContextSurfacesARGB_ZS;
    vpp.hDX6MultiTextureTriangle           = hDX6MultiTextureTriangle;
    vpp.hImageBlackRect                    = hImageBlackRect;

    vpp.ropRectTextSubCh                   = ropRectTextSubCh;
    vpp.ropSubCh                           = ropSubCh;
    vpp.spareSubCh                         = spareSubCh;

    if (!vppAllocateObjects(pVpp))
    {
        dbgError("VPP object allocation failed!");
        VppDisable(pVpp);
        return FALSE;
    }

    vppInitObjects(pVpp);

    vpp.dwFlags |= VPP_FLAG_ENABLED;

    return TRUE;
}



//---------------------------------------------------------------------------
// vppPreCopy
//      Copies surface from source to destination.  Does not need to follow
//      the notifier protocol because it is not a stage by itself.
LOCAL BOOL vppPreCopy(Vpp_t *pVpp, DWORD dwSrcOffset, DWORD dwSrcPitch,
                DWORD dwDstOffset, DWORD dwDstPitch,
                DWORD dwWidth, DWORD dwHeight)
{
    Vpp_t &vpp = *pVpp;
    DWORD dwMergeSize;

    dwMergeSize = (dwHeight << 16) | (dwWidth >> 1);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hContextBeta4);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | BETA4_SET_BETA_FACTOR_OFFSET | 0x40000);
    vpp.pPusher->push(3, 0xFFFFFFFF);

    // This is sometimes used in it's own channel -- but here DD_SURFACES_2D is assigned to spare? -mjl
    vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(5, vpp.hSurfaces2D);
    vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | SURFACES_2D_PITCH_OFFSET | 0xC0000);
    vpp.pPusher->push(7, (dwDstPitch << 16) | dwSrcPitch);     // SetPitch
    vpp.pPusher->push(8, dwSrcOffset);                         // SetOffsetSource
    vpp.pPusher->push(9, dwDstOffset);                         // SetOffsetDestin
    vpp.pDriverData->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
    vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    vpp.pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    vpp.pPusher->push(10, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(11, vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
    vpp.pPusher->push(12, SUB_CHANNEL(vpp.spareSubCh) | BLIT_POINT_IN_OFFSET | 0xC0000);
    vpp.pPusher->push(13, 0);                                  // control point in
    vpp.pPusher->push(14, 0);                                  // control point out
    vpp.pPusher->push(15, dwMergeSize);                        // size

    vpp.pPusher->adjust(16);
    vpp.pPusher->start(TRUE);
    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[ALPHA_BLT_NDX].classIID;
    return TRUE;
}


//---------------------------------------------------------------------------
// vppConvert
//      Converts YUV9 or YUV12 surface to YUV422.  Assume that we always
//      convert to YUY2 and not UYVY. Assume width, pitch, and height are
//      all divisible by the subsampling rate.
LOCAL BOOL vppConvert(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                DWORD dwSrcOffset, DWORD dwSrcPitch,
                DWORD dwDstOffset, DWORD dwDstPitch,
                DWORD dwWidth, DWORD dwHeight,
                DWORD dwFourCC)
{
    DWORD i;
    DWORD dwSrcUOffset, dwSrcVOffset, dwCOffset;
    Vpp_t &vpp = *pVpp;

    dwSrcVOffset = dwSrcOffset + dwSrcPitch * dwHeight;

    // move the chroma data
    switch (dwFourCC) {
    case FOURCC_IF09:
    case FOURCC_YVU9:
    case FOURCC_IV32:
    case FOURCC_IV31:
        dwSrcUOffset = dwSrcVOffset + (dwSrcPitch >> 2) * (dwHeight >> 2);
        dwCOffset    = dwSrcUOffset + (dwSrcPitch >> 2) * (dwHeight >> 2);

        // first weave U and V together in the horizontal direction and double up
        // move U even
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hVideoMemUtoVideoMemFormat);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(3, dwSrcUOffset);                    // OffsetIn
        vpp.pPusher->push(4, dwCOffset);                       // OffsetOut
        vpp.pPusher->push(5, dwSrcPitch >> 2);                 // PitchIn
        vpp.pPusher->push(6, dwSrcPitch);                      // PitchOut
        vpp.pPusher->push(7, dwWidth >> 2);                    // LineLengthIn
        vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
        vpp.pPusher->push(9, 0x401);                           // Format
        vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
        vpp.pPusher->adjust(11);

        // move V even
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hVideoMemVtoVideoMemFormat);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(3, dwSrcVOffset);                    // OffsetIn
        vpp.pPusher->push(4, dwCOffset + 1);                   // OffsetOut
        vpp.pPusher->push(5, dwSrcPitch >> 2);                 // PitchIn
        vpp.pPusher->push(6, dwSrcPitch);                      // PitchOut
        vpp.pPusher->push(7, dwWidth >> 2);                    // LineLengthIn
        vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
        vpp.pPusher->push(9, 0x401);                           // Format
        vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
        vpp.pPusher->adjust(11);
        vpp.pPusher->start(TRUE);

        // move U odd
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hVideoMemUtoVideoMemFormat);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(3, dwSrcUOffset);                    // OffsetIn
        vpp.pPusher->push(4, dwCOffset + 2);                   // OffsetOut
        vpp.pPusher->push(5, dwSrcPitch >> 2);                 // PitchIn
        vpp.pPusher->push(6, dwSrcPitch);                      // PitchOut
        vpp.pPusher->push(7, dwWidth >> 2);                    // LineLengthIn
        vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
        vpp.pPusher->push(9, 0x401);                           // Format
        vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
        vpp.pPusher->adjust(11);

        // move V odd
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hVideoMemVtoVideoMemFormat);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(3, dwSrcVOffset);                    // OffsetIn
        vpp.pPusher->push(4, dwCOffset + 3);                   // OffsetOut
        vpp.pPusher->push(5, dwSrcPitch >> 2);                 // PitchIn
        vpp.pPusher->push(6, dwSrcPitch);                      // PitchOut
        vpp.pPusher->push(7, dwWidth >> 2);                    // LineLengthIn
        vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
        vpp.pPusher->push(9, 0x401);                           // Format
        vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
        vpp.pPusher->adjust(11);
        vpp.pPusher->start(TRUE);

        // final move, 4x vertical resample
        for (i=0; i<4; i++) {
            DWORD dwDstAdd = i * dwDstPitch;

            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemUVtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwCOffset);                       // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + dwDstAdd + 1);      // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch);                      // PitchIn
            vpp.pPusher->push(6, dwDstPitch << 2);                 // PitchOut
            vpp.pPusher->push(7, dwWidth);                         // LineLengthIn
            vpp.pPusher->push(8, dwHeight >> 2);                   // LineCount
            vpp.pPusher->push(9, 0x201);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);
        }
        vpp.pPusher->start(TRUE);
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hVideoMemUVtoVideoMemFormat;
        break;

    case FOURCC_YV12:
    case FOURCC_420i:
        dwSrcUOffset = dwSrcVOffset + (dwSrcPitch >> 1) * (dwHeight >> 1);

        for (i=0; i<4; i++) {
            DWORD dwDstAdd = (i >> 1) * dwDstPitch + (i & 0x1) * 4;

            // move U
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemUtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwSrcUOffset);                    // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + dwDstAdd + 1);      // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch >> 1);                 // PitchIn
            vpp.pPusher->push(6, dwDstPitch << 1);                 // PitchOut
            vpp.pPusher->push(7, dwWidth >> 1);                    // LineLengthIn
            vpp.pPusher->push(8, dwHeight >> 1);                   // LineCount
            vpp.pPusher->push(9, 0x401);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);

            // move V
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemVtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwSrcVOffset);                    // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + dwDstAdd + 3);      // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch >> 1);                 // PitchIn
            vpp.pPusher->push(6, dwDstPitch << 1);                 // PitchOut
            vpp.pPusher->push(7, dwWidth >> 1);                    // LineLengthIn
            vpp.pPusher->push(8, dwHeight >> 1);                   // LineCount
            vpp.pPusher->push(9, 0x401);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);
            vpp.pPusher->start(TRUE);
        }
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hVideoMemVtoVideoMemFormat;
        break;

    default:
        return FALSE;
        break;
    }

//    resetNotification(vpp.pPusherSyncNotifier, lpProcInfo->hConvert3);
    VppResetNotification(vpp.m_obj_a[V2V_FORMAT_NDX].notifier_a, lpProcInfo->hConvert3);

    // move the luma data
    vpp.pPusher->push( 0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push( 1, vpp.m_obj_a[V2V_FORMAT_NDX].classIID);
    vpp.pPusher->push( 2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
    vpp.pPusher->push( 3, dwSrcOffset);                             // OffsetIn
    vpp.pPusher->push( 4, dwDstOffset);                             // OffsetOut
    vpp.pPusher->push( 5, dwSrcPitch);                              // PitchIn
    vpp.pPusher->push( 6, dwDstPitch);                              // PitchOut
    vpp.pPusher->push( 7, dwWidth);                                 // LineLengthIn
    vpp.pPusher->push( 8, dwHeight);                                // LineCount
    vpp.pPusher->push( 9, 0x201);                                   // Format
    vpp.pPusher->push(10, VPP_NOTIFY_TYPE);                         // BufferNotify
    vpp.pPusher->adjust(11);
    vpp.pPusher->start(TRUE);

    return TRUE;
}


//---------------------------------------------------------------------------
// vppSubPicture
//      Composites DVD subpicture to YUV422 image
LOCAL BOOL vppSubPicture(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                   DWORD dwSrcOffset, DWORD dwSrcPitch,
                   DWORD dwDstOffset, DWORD dwDstPitch,
                   DWORD dwWidth, DWORD dwHeight, DWORD dwFourCC)
{
    DWORD dwMergeSize, dwClipSize;
    DWORD dwOutFormat;
    DWORD dwInPoint, dwOutPoint;
    DWORD dwOverlayPoint;
    DWORD dwSubPictureOffset;
    Vpp_t &vpp = *pVpp;

    if (vpp.subPicture.pitch & NVS2VF_SP_SUBRECT) {
        DWORD dwBytesPerPixel = (vpp.subPicture.format == NV038_OVERLAY_FORMAT_COLOR_LE_A8V8U8Y8 ||
                                 vpp.subPicture.format == NV088_OVERLAY_FORMAT_COLOR_LE_A8CR8CB8Y8) ? 4:2;
        // codec requests in place subrectangle
        dwSubPictureOffset = vpp.subPicture.offset +
                             vpp.subPicture.originY * (vpp.subPicture.pitch & 0xFFFFFFF0) +
                             (vpp.subPicture.originX & ~0x1F) * dwBytesPerPixel;
        dwSrcOffset += vpp.subPicture.originY * dwSrcPitch + (vpp.subPicture.originX & ~0x1F) * 2;
        dwMergeSize = asmMergeCoords(vpp.subPicture.width, vpp.subPicture.height);
        dwOutPoint = asmMergeCoords(vpp.subPicture.originX & 0x1E, 0);
        dwInPoint = dwOutPoint << 4;
        dwOverlayPoint = dwInPoint;
        dwDstOffset = dwSrcOffset;
    } else {
        // otherwise blit the whole thing to next work surface
        dwSubPictureOffset = vpp.subPicture.offset;
        dwMergeSize = asmMergeCoords(dwWidth, dwHeight);
        dwInPoint = 0;
        dwOutPoint = 0;
        dwOverlayPoint = 0;
    }
    dwClipSize = asmMergeCoords(dwWidth, dwHeight);

    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
    } else {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
    }

    VppResetNotification(vpp.m_obj_a[DVDPICT_NDX].notifier_a, lpProcInfo->hSubPicture3);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[DVDPICT_NDX].classIID);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV038_IMAGE_OUT_POINT | 0x400000);
    vpp.pPusher->push(3, dwOutPoint);                              // ImageOutPoint
    vpp.pPusher->push(4, dwMergeSize);                             // ImageOutSize
    vpp.pPusher->push(5, (dwOutFormat << 16) | dwDstPitch);        // ImageOutFormat
    vpp.pPusher->push(6, dwDstOffset);                             // ImageOutOffset
    vpp.pPusher->push(7, 1 << 20);                                 // ImageInDeltaDuDx
    vpp.pPusher->push(8, 1 << 20);                                 // ImageInDeltaDvDy
    vpp.pPusher->push(9, dwClipSize);                              // ImageInSize
    vpp.pPusher->push(10, (dwOutFormat << 16) | dwSrcPitch);       // ImageInFormat
    vpp.pPusher->push(11, dwSrcOffset);                            // ImageInOffset
    vpp.pPusher->push(12, dwInPoint);                              // ImageInPoint
    vpp.pPusher->push(13, 1 << 20);                                // OverlayDeltaDuDx
    vpp.pPusher->push(14, 1 << 20);                                // OverlayDeltaDvDy
    vpp.pPusher->push(15, dwClipSize);                             // OverlaySize
    vpp.pPusher->push(16, (vpp.subPicture.format << 16) |  // OverlayFormat
                   (vpp.subPicture.pitch & 0xFFFFFFF0));
    vpp.pPusher->push(17, dwSubPictureOffset);                     // OverlayOffset
    vpp.pPusher->push(18, dwOverlayPoint);                         // OverlayPoint
    vpp.pPusher->push(19, SUB_CHANNEL(vpp.spareSubCh) | NV038_NOTIFY | 0x40000);
    vpp.pPusher->push(20, VPP_NOTIFY_TYPE);                        // Notify
    vpp.pPusher->push(21, SUB_CHANNEL(vpp.spareSubCh) | NV038_NO_OPERATION | 0x40000);
    vpp.pPusher->push(22, 0);
    vpp.pPusher->adjust(23);
    vpp.pPusher->start(TRUE);

    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DVDPICT_NDX].classIID;
    return TRUE;
}


//---------------------------------------------------------------------------
// vppPreScale
//      Prescales YUV422 surface.  The new width and height are returned.  If
//      this routine does the field prescaling, it flips off the field flags
//      to indicate that the flip should not bob.
LOCAL BOOL vppPreScale(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                 DWORD dwSrcOffset, DWORD dwSrcPitch,
                 DWORD dwDstOffset, DWORD dwDstPitch,
                 LPDWORD pWidth, LPDWORD pHeight,
                 DWORD dwFourCC, LPDWORD pField)
{
    DWORD preScaleDeltaX;
    DWORD preScaleDeltaY;
    DWORD preScaleOverlay;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwXFactor, dwYFactor;
    DWORD dwSrcWidth, dwDstWidth, dwSrcHeight, dwDstHeight;
    DWORD dwOutSizeX, dwOutSizeY, dwOutFormat;
    DWORD dwInPitch, dwInOffset, dwInPoint, dwInSize;
    BOOL isField;
    Vpp_t &vpp = *pVpp;;

    dwSrcWidth = *pWidth;
    dwSrcHeight = *pHeight;
    dwDstWidth = vpp.dwOverlayDstWidth;
    dwDstHeight = vpp.dwOverlayDstHeight;

    if (dwDstWidth == 0 ||dwDstHeight == 0) {
        return FALSE;
    }

    isField = IS_FIELD(*pField);

    if (dwDstWidth <= 1) {
        dwDeltaX = 0x100000;
        dwXFactor = 1;
    } else {
        dwDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
        dwXFactor = dwSrcWidth / dwDstWidth;
    }

    if (dwDstHeight <= 1) {
        dwDeltaY = 0x100000;
        dwYFactor = 1;
    } else {
        dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
        dwYFactor = dwSrcHeight / dwDstHeight;
    }

    preScaleOverlay = 0;

    if (dwXFactor >= max(vpp.dwOverlayMaxDownScaleX,2) && vpp.extraNumSurfaces >= 4) {
        // use multipass X downscale, one pass reduces by a factor of 2
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = (dwSrcWidth >> 1);
        preScaleDeltaX = ((dwSrcWidth - 1) << 20) / (dwSrcWidth / 2 - 1);
        vpp.dwOverlayDeltaX = ((dwSrcWidth / 2 - 1) << 20) / (dwDstWidth - 1);
    } else if (dwSrcWidth > (dwDstWidth * vpp.dwOverlayMaxDownScale)) {
        // use X prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = dwDstWidth;
        preScaleDeltaX = dwDeltaX;
        vpp.dwOverlayDeltaX = 0x100000;
    } else {
        // use X overlay scaler
        dwOutSizeX = *pWidth;
        preScaleDeltaX = 0x100000;
        vpp.dwOverlayDeltaX = dwDeltaX;
    }

    if (dwYFactor >= max(vpp.dwOverlayMaxDownScaleY,2) && vpp.extraNumSurfaces >= 4) {
        // use multipass Y downscale, one pass reduces by a factor of 2
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = (dwSrcHeight >> 1) & ~1;
        preScaleDeltaY = ((dwSrcHeight - 1) << 20) / (dwSrcHeight / 2 - 1);
        vpp.dwOverlayDeltaY = ((dwSrcHeight / 2 - 1) << 20) / (dwDstHeight - 1);
    } else if (dwSrcHeight > (dwDstHeight * vpp.dwOverlayMaxDownScale) ||
              (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)) {
        // use Y prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = dwDstHeight;
        preScaleDeltaY = dwDeltaY;
        vpp.dwOverlayDeltaY = 0x100000;
    } else {
        // use Y overlay scaler
        dwOutSizeY = *pHeight;
        preScaleDeltaY = 0x100000;
        vpp.dwOverlayDeltaY = dwDeltaY;
    }

    if ((vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) || (preScaleOverlay & NV_PRESCALE_OVERLAY_Y)) {
        if (isField) {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            if (*pField & VPP_INTERLEAVED) {
                if (dwYFactor >= max(vpp.dwOverlayMaxDownScaleY,2) && vpp.extraNumSurfaces >= 4) {
                    // multipass
                    preScaleDeltaY = ((dwSrcHeight / 2 - 1) << 20) / (dwSrcHeight / 2 - 1);
                } else if (dwSrcHeight > (dwDstHeight * vpp.dwOverlayMaxDownScale) ||
                          (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)) {
                    // use Y prescaler
                    preScaleDeltaY = ((dwSrcHeight / 2 - 1) << 20) / (dwDstHeight - 1);
                } else {
                    // use Y overlay scaler
                    preScaleDeltaY = ((dwSrcHeight / 2 - 1) << 20) / (dwSrcHeight - 1);
                }
            }
        }
    }

    if (preScaleOverlay == 0) {
        return FALSE;
    }

    dwInSize = asmMergeCoords( ((*pWidth+1) & 0xFFFE), *pHeight);
    dwInPoint = 0xFFF8FFF8;
    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField && (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        if (*pField & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            *pHeight >>= 1;
            if (*pField & VPP_ODD) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (*pField & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            if (*pField & VPP_ODD) {
                dwInPoint += 0x00040000;
            } else {
                dwInPoint += 0x000C0000;
            }
        }
    }
// I believe this code fixes a limit violation error (which should not be occuring so far as I can tell)
// however Sandy reports that visual quality is greatly reduced if we start on aligned boundary instead
// of -1/2 line. That results in a drop of our score on the Video2000 benchmark.  I could not get that
// to run.  Anyway, if no violation errors occur, we can remove this. @mjl@  
#if 0 
    else
    {
        dwInPoint = 0;
    }
#endif

    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
    } else {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
    }

    // HWBUG: Must serialize all usage of DVD subpicture
    // if (IS_EVENT_ERROR(WaitForSingleObject(lpProcInfo->hSubPicture3, VPP_TIMEOUT_TIME))) {
    if (VppWaitForNotification(vpp.m_obj_a[DVDPICT_NDX].notifier_a, lpProcInfo->hSubPicture3, VPP_TIMEOUT_TIME)) {
        dbgError(" *** SUBPICTURE event failure ***");
        EVENT_ERROR;
    }

    VppResetNotification(vpp.m_obj_a[DVDPICT_NDX].notifier_a, lpProcInfo->hSubPicture3);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[DVDPICT_NDX].classIID);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV038_IMAGE_OUT_POINT | 0x400000);
    vpp.pPusher->push(3, 0);                                       // ImageOutPoint
    vpp.pPusher->push(4, asmMergeCoords((dwOutSizeX + 1) & ~1, dwOutSizeY));  // ImageOutSize
    vpp.pPusher->push(5, (dwOutFormat << 16) | dwDstPitch);        // ImageOutFormat
    vpp.pPusher->push(6, dwDstOffset);                             // ImageOutOffset
    vpp.pPusher->push(7, preScaleDeltaX);                          // ImageInDeltaDuDx
    vpp.pPusher->push(8, preScaleDeltaY);                          // ImageInDeltaDvDy
    vpp.pPusher->push(9, dwInSize);                                // ImageInSize
    vpp.pPusher->push(10, (dwOutFormat << 16) | dwInPitch);        // ImageInFormat
    vpp.pPusher->push(11, dwInOffset);                             // ImageInOffset
    vpp.pPusher->push(12, dwInPoint);                              // ImageInPoint
    vpp.pPusher->push(13, preScaleDeltaX);                         // OverlayDeltaDuDx
    vpp.pPusher->push(14, preScaleDeltaY);                         // OverlayDeltaDvDy
    vpp.pPusher->push(15, dwInSize);                               // OverlaySize
    vpp.pPusher->push(16, (NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwInPitch);  // OverlayFormat
    vpp.pPusher->push(17, dwInOffset);                             // OverlayOffset
    vpp.pPusher->push(18, 0);                                      // OverlayPoint
    vpp.pPusher->push(19, SUB_CHANNEL(vpp.spareSubCh) | NV038_NOTIFY | 0x40000);
    vpp.pPusher->push(20, VPP_NOTIFY_TYPE);                        // Notify
    vpp.pPusher->push(21, SUB_CHANNEL(vpp.spareSubCh) | NV038_NO_OPERATION | 0x40000);
    vpp.pPusher->push(22, 0);
    vpp.pPusher->adjust(23);
    vpp.pPusher->start(TRUE);

    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[DVDPICT_NDX].classIID;

    // return changes in state
    if ((vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
        (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        // with HQVUp, we no longer use the overlay to bob
        *pField &= ~(VPP_ODD | VPP_EVEN | VPP_BOB | VPP_INTERLEAVED);
    }
    *pHeight = dwOutSizeY;
    *pWidth  = dwOutSizeX;
    return TRUE;
}


//---------------------------------------------------------------------------
// vppFSMirror
//      Scale and colour convert YUV to RGB surface
LOCAL BOOL vppFSMirror(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                 DWORD dwSrcOffset, DWORD dwSrcPitch,
                 DWORD dwWidth, DWORD dwHeight,
                 DWORD dwFourCC, DWORD dwFlags,
                 DWORD dwPrescaleFactorX, DWORD dwPrescaleFactorY)
{
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwDstPitch, dwDstOffset, dwDstSize, dwSrcSize, dwDstPoint;
    DWORD dwSrcWidth, dwDstWidth, dwSrcHeight, dwDstHeight;
    DWORD dwCombinedPitch, dwColourFormat;
    DWORD dwInFormat, dwSrcX, dwSrcY;
    DWORD dwInPitch, dwInOffset, dwInPoint;
    BOOL isField, doZoom;
    DWORD dwBytesPerPel;
    DWORD dwColourFormat2;
    Vpp_t &vpp = *pVpp;

    dwSrcX      = (vpp.dwOverlayFSSrcMinX * dwPrescaleFactorX) >> 20;
    dwSrcY      = (vpp.dwOverlayFSSrcMinY * dwPrescaleFactorY) >> 20;
    dwSrcWidth  = (vpp.dwOverlayFSSrcWidth * dwPrescaleFactorX) >> 20;
    dwSrcHeight = (vpp.dwOverlayFSSrcHeight * dwPrescaleFactorY) >> 20;
    dwDstWidth  = vpp.dwOverlayFSWidth;
    dwDstHeight = vpp.dwOverlayFSHeight;
    dwDstPitch  = vpp.dwOverlayFSPitch;
    dwDstOffset = vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex];
    dwDstPoint  = 0;
    dwInPoint   = (((dwSrcX << 4) - 8) & 0x0000FFFF) | ((dwSrcY << 20) - 0x80000);

    // scaled image and gdi_rect will silently fail unless we set the pattern (?)
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hContextPattern);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
    vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
    switch (vpp.dwOverlayFSFormat) {
    case NV062_SET_COLOR_FORMAT_LE_Y8:
        dwBytesPerPel = 2;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        vpp.pPusher->push(4,NV_ALPHA_1_008);
        vpp.pPusher->push(5,NV_ALPHA_1_008);
        break;
    case NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8:
        dwBytesPerPel = 4;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        vpp.pPusher->push(4,NV_ALPHA_1_032);
        vpp.pPusher->push(5,NV_ALPHA_1_032);
        break;
    default:
        dwBytesPerPel = 2;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
        vpp.pPusher->push(4,NV_ALPHA_1_016);
        vpp.pPusher->push(5,NV_ALPHA_1_016);
        break;
    }
    vpp.pPusher->adjust(6);

    isField = IS_FIELD(dwFlags);

    if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSTRACKOVLZOOM) {
        doZoom = vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK;
    } else {
        doZoom = vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSZOOMQUADMASK;
    }
    if (doZoom) {
        // zoom
        DWORD dwZoomFactor, dwZoomQuad;
        DWORD dwNewSrcWidth, dwNewSrcHeight;

        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSTRACKOVLZOOM) {
            dwZoomFactor   = 384 - ((vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMFACTORMASK) >> 12);
            dwZoomQuad     = (vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK) >> 8;
        } else {
            dwZoomFactor   = 384 - ((vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSZOOMFACTORMASK) >> 12);
            dwZoomQuad     = (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSZOOMQUADMASK) >> 8;
        }
        dwNewSrcWidth  = dwSrcWidth  * dwZoomFactor / 384;
        dwNewSrcHeight = dwSrcHeight * dwZoomFactor / 384;

        // get start point
        switch (dwZoomQuad) {
        case 1:  break;
        case 2:  dwSrcX += dwSrcWidth - dwNewSrcWidth;          break;
        case 3:  dwSrcY += dwSrcHeight - dwNewSrcHeight;        break;
        case 4:  dwSrcX += dwSrcWidth - dwNewSrcWidth;
                 dwSrcY += dwSrcHeight - dwNewSrcHeight;        break;
        case 5:  dwSrcX += (dwSrcWidth - dwNewSrcWidth) >> 1;
                 dwSrcY += (dwSrcHeight - dwNewSrcHeight) >> 1; break;
        default: break;
        }
        dwSrcWidth = dwNewSrcWidth;
        dwSrcHeight = dwNewSrcHeight;
    }
    // align source
    dwSrcOffset += (dwSrcY * dwSrcPitch) + ((dwSrcX * 2) & ~NV_BYTE_ALIGNMENT_PAD);
    dwSrcX &= ((NV_BYTE_ALIGNMENT / 2) - 1);
    dwSrcY = 0;
    dwInPoint = (dwInPoint & 0xFFFF0000) | ((dwInPoint & 0x0000FFFF) + (dwSrcX << 4));

    dwDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
    dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
    dwSrcSize  = (dwSrcHeight << 16) | ((dwSrcWidth + dwSrcX + 1) & ~1);

    if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSASPECT) {
        // preserve aspect
        if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSTRACKOVLASPECT) {
            // track overlay aspect
            DWORD dwOverlayAspect = (vpp.dwOverlayDeltaX << 8) / vpp.dwOverlayDeltaY;
            DWORD dwNewDeltaY, dwNewDstHeight;

            dwNewDeltaY = (dwDeltaX << 8) / dwOverlayAspect;
            dwNewDstHeight = ((dwSrcHeight - 1) << 20) / dwNewDeltaY + 1;
            if (dwNewDstHeight <= dwDstHeight) {
                DWORD dwHeightPad;
                // X is wider
                dwDeltaY = dwNewDeltaY;
                dwDstHeight = dwNewDstHeight;
                dwHeightPad = ((vpp.dwOverlayFSHeight - dwDstHeight) >> 1);
                dwDstOffset += vpp.dwOverlayFSPitch * dwHeightPad;
//                if (vpp.dwOverlayFSNumSurfaces == 1) {
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex], vpp.dwOverlayFSPitch,
                                 vpp.dwOverlayFSWidth, dwHeightPad, dwBytesPerPel);
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex] + (dwHeightPad + dwDstHeight) * vpp.dwOverlayFSPitch,
                                 vpp.dwOverlayFSPitch, dwDstWidth, dwHeightPad, dwBytesPerPel);
                    vpp.dwOverlayFSDeltaX = dwDeltaX;
                    vpp.dwOverlayFSDeltaY = dwDeltaY;
//                }
            } else {
                // Y is higher
                DWORD dwXOffsetPels;

                dwOverlayAspect = (vpp.dwOverlayDeltaY << 8) / vpp.dwOverlayDeltaX;
                dwDeltaX = (dwDeltaY << 8) / dwOverlayAspect;
                dwDstWidth = ((dwSrcWidth - 1) << 20) / dwDeltaX + 1;
                dwXOffsetPels = (vpp.dwOverlayFSWidth - dwDstWidth) >> 1;
                dwDstOffset += (dwXOffsetPels * dwBytesPerPel) & ~NV_BYTE_ALIGNMENT_PAD;
                dwDstPoint = dwXOffsetPels & ((NV_BYTE_ALIGNMENT / dwBytesPerPel) - 1);
                dwSrcSize  = (dwSrcHeight << 16) | ((dwSrcWidth + dwDstPoint + dwSrcX + 1) & ~1);
//                if (vpp.dwOverlayFSNumSurfaces == 1) {
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex],
                                 vpp.dwOverlayFSPitch, dwXOffsetPels, dwDstHeight, dwBytesPerPel);
                    vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex] + ((dwXOffsetPels + dwDstWidth) * dwBytesPerPel),
                                 vpp.dwOverlayFSPitch, dwXOffsetPels, dwDstHeight, dwBytesPerPel);
                    vpp.dwOverlayFSDeltaX = dwDeltaX;
                    vpp.dwOverlayFSDeltaY = dwDeltaY;
//                }
            }
        } else if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSFIXEDANIMORPHIC) {
            // fixed 16:9 aspect
            dwDstHeight = dwDstWidth * 9 / 16;
            dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
            dwDstOffset += vpp.dwOverlayFSPitch * ((vpp.dwOverlayFSHeight - dwDstHeight) >> 1);
        } else if (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSFIXEDTV) {
            // fixed 4:3 aspect
            if ((dwDstHeight * 4 / 3) >= dwDstWidth) {
                // use X as a reference
                dwDstHeight = dwDstWidth * 3 / 4;
                dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight - 1);
                dwDstOffset += vpp.dwOverlayFSPitch * ((vpp.dwOverlayFSHeight - dwDstHeight) >> 1);
            } else {
                DWORD dwXOffsetPels;

                // use Y as a reference
                dwDstWidth = dwDstHeight * 4 / 3;
                dwDeltaX = ((dwSrcWidth - 1) << 20) / (dwDstWidth - 1);
                dwXOffsetPels = (vpp.dwOverlayFSWidth - dwDstWidth) >> 1;
                dwDstOffset += (dwXOffsetPels * dwBytesPerPel) & ~NV_BYTE_ALIGNMENT_PAD;
                dwDstPoint = dwXOffsetPels & ((NV_BYTE_ALIGNMENT / dwBytesPerPel) - 1);
                dwSrcSize  = (dwSrcHeight << 16) | ((dwSrcWidth + dwDstPoint + dwSrcX + 1) & ~1);
            }
        } else {
            // preserve aspect
            DWORD dwNewDstHeight = ((dwSrcHeight - 1) << 20) / dwDeltaX + 1;

            if (dwNewDstHeight <= dwDstHeight) {
                // X is wider
                dwDeltaY = dwDeltaX;
                dwDstHeight = dwNewDstHeight;
                dwDstOffset += vpp.dwOverlayFSPitch * ((vpp.dwOverlayFSHeight - dwDstHeight) >> 1);
            } else {
                //Y is wider
                DWORD dwXOffsetPels;

                dwDeltaX = dwDeltaY;
                dwDstWidth = ((dwSrcWidth - 1) << 20) / dwDeltaX + 1;
                dwXOffsetPels = (vpp.dwOverlayFSWidth - dwDstWidth) >> 1;
                dwDstOffset += (dwXOffsetPels * dwBytesPerPel) & ~NV_BYTE_ALIGNMENT_PAD;
                dwDstPoint = dwXOffsetPels & ((NV_BYTE_ALIGNMENT / dwBytesPerPel) - 1);
                dwSrcSize  = (dwSrcHeight << 16) | ((dwSrcWidth + dwDstPoint + dwSrcX + 1) & ~1);
            }
        }
        if (vpp.dwOverlayFSDeltaX != dwDeltaX || vpp.dwOverlayFSDeltaY != dwDeltaY) {
            static DWORD dwCount = 0;
            // aspect has changed, clear surface first
            vppBltFillBlock(pVpp, 0, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex], vpp.dwOverlayFSPitch,
                         vpp.dwOverlayFSWidth, vpp.dwOverlayFSHeight, dwBytesPerPel);
            if (dwCount++ >= (4 * vpp.dwOverlayFSNumSurfaces)) {
                vpp.dwOverlayFSDeltaX = dwDeltaX;
                vpp.dwOverlayFSDeltaY = dwDeltaY;
                dwCount = 0;
            }
        }
    }

    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField) {
        // Set flag to say overlay has been in Bob mode.
        vpp.pDriverData->dwDXVAFlags |= DXVA_OVERLAY_WAS_BOBBED;

        if (dwFlags & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            dwSrcHeight >>= 1;
            dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight);
            if (dwFlags & VPP_ODD) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (dwFlags & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            if (dwFlags & VPP_ODD) {
                dwInPoint += 0x00040000;
            } else {
                dwInPoint += 0x000C0000;
            }
        }
    }
    else if (vpp.pDriverData->dwDXVAFlags & DXVA_OVERLAY_WAS_BOBBED) {
        // For Weave mode: if the overlay has ever been in Bob mode, we adjust the vertical
        // scale factor to match the Bob mode scaling, to improve Bob/Weave switches.
        dwDeltaY = ((dwSrcHeight - 1) << 20) / (dwDstHeight);
    }

    // set ROP
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropSubCh) | SET_ROP_OFFSET | 0x40000);
    vpp.pPusher->push(1, SRCCOPYINDEX);
    vpp.pPusher->adjust(2);
    vpp.pDriverData->bltData.dwLastRop = SRCCOPYINDEX;

    // set colour key
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hContextColorKey);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SET_TRANSCOLOR_OFFSET | 0x40000);
    vpp.pPusher->push(3, 0);
    vpp.pPusher->adjust(4);
    vpp.pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;

    if (dwFourCC == FOURCC_UYVY) {
        dwInFormat = NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8;
    } else {
        dwInFormat = NV089_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8;
    }

    dwCombinedPitch = (dwDstPitch << 16) | dwInPitch;
    dwColourFormat = max(vpp.dwOverlayFSFormat, NV062_SET_COLOR_FORMAT_LE_R5G6B5);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    vpp.pPusher->push(1, dwColourFormat);                  // SetColorFormat
    vpp.pPusher->push(2, dwCombinedPitch);                 // SetPitch
    vpp.pPusher->push(3, dwInOffset);                      // SetSrcOffset
    vpp.pPusher->push(4, dwDstOffset);                     // SetDstOffset
    vpp.pPusher->adjust(5);
    vpp.pDriverData->bltData.dwLastColourFormat = dwColourFormat;
    vpp.pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
    vpp.pDriverData->bltData.dwLastSrcOffset = dwInOffset;
    vpp.pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    dwDstSize  = (dwDstHeight << 16) | dwDstWidth;

// TBD ask ###
    // wait for any backdoor FOURCC blits to complete
    if (VppWaitForNotification(vpp.pPusherSyncNotifier, lpProcInfo->hFSMirror3, VPP_TIMEOUT_TIME)) {
        dbgError(" *** FSMIRROR event failure ***");
        EVENT_ERROR;
    }

    VppResetNotification(vpp.pPusherSyncNotifier, lpProcInfo->hFSMirror3);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[SCALED_IMAGE1_NDX].classIID);
//    vpp.pPusher->push(1, NV_DD_SCALED_IMAGE_IID);

    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    vpp.pPusher->push(3, vpp.hInVideoMemContextDma);   // SetContextDmaImage
    vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_CONTEXT_SURFACE_OFFSET | 0x40000);
    vpp.pPusher->push(5, vpp.hSurfaces2D);                       // SetContextSurface
    vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    vpp.pPusher->push(7, dwInFormat);              // SetColorFormat
    vpp.pPusher->push(8, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    vpp.pPusher->push(9, dwDstPoint);              // ClipPoint
    vpp.pPusher->push(10, dwDstSize);              // ClipSize
    vpp.pPusher->push(11, dwDstPoint);             // ImageOutPoint
    vpp.pPusher->push(12, dwDstSize);              // ImageOutSize
    vpp.pPusher->push(13, dwDeltaX);               // DsDx
    vpp.pPusher->push(14, dwDeltaY);               // DtDy
    vpp.pPusher->push(15, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    vpp.pPusher->push(16, dwSrcSize);              // ImageInSize
    vpp.pPusher->push(17, (NV089_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24) |     // ImageInFormat
                   (NV089_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16) |
                   dwInPitch);
    vpp.pPusher->push(18, dwInOffset);             // ImageInOffset
    vpp.pPusher->push(19, dwInPoint);              // ImageInPoint
    vpp.pPusher->push(20, SUB_CHANNEL(vpp.spareSubCh) | SCALED_IMAGE_NOTIFY_OFFSET | 0x40000);
    vpp.pPusher->push(21, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(22, SUB_CHANNEL(vpp.spareSubCh) | NV089_NO_OPERATION | 0x40000);
    vpp.pPusher->push(23, 0);
    vpp.pPusher->adjust(24);
    vpp.pPusher->start(TRUE);
    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[SCALED_IMAGE1_NDX].classIID;
//    vpp.pDriverData->dDrawSpareSubchannelObject = NV_DD_SCALED_IMAGE_IID;

    // restore surfaces2d, pattern, and rect formats
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hContextPattern);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
    vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
    switch ((GET_MODE_BPP() + 1) / 8) {
    case 1:
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        vpp.pPusher->push(4,NV_ALPHA_1_008);
        vpp.pPusher->push(5,NV_ALPHA_1_008);
        break;
    case 4:
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        vpp.pPusher->push(4,NV_ALPHA_1_032);
        vpp.pPusher->push(5,NV_ALPHA_1_032);
        break;
    default:
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
        vpp.pPusher->push(4,NV_ALPHA_1_016);
        vpp.pPusher->push(5,NV_ALPHA_1_016);
        break;
    }
    vpp.pPusher->push(6, SUB_CHANNEL(vpp.ropRectTextSubCh) | NV04A_SET_COLOR_FORMAT | 0x40000);
    vpp.pPusher->push(7, dwColourFormat2);
    vpp.pPusher->push(8, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000);
    vpp.pPusher->push(9, NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8);
    vpp.pPusher->adjust(10);

    vpp.pDriverData->bltData.dwLastColourFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;

    return TRUE;
}


//---------------------------------------------------------------------------
// vppColourControl
//      Software colour controls for NV4/5.  There is evidence that the
//      Windows kernel uses the floating point stack, which is why there
//      are extra EMMS instructions scattered through the code.
LOCAL BOOL vppColourControl(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                      DWORD dwSrcOffset, DWORD dwSrcPitch,
                      DWORD dwDstOffset, DWORD dwDstPitch,
                      DWORD dwWidth, DWORD dwHeight,
                      DWORD dwFourCC, DWORD dwFlags)
{
    BOOL bOverContrast;
    DWORD dwContrast, dwBrightness, cnt, brt;
    short hue, sat;
    DWORD dwYPhase, dwSysPitch;
    BOOL doContrastBlt, doLuma, doChroma;
    DWORD dwMergeSize;
    BOOL isField;
    Vpp_t &vpp = *pVpp;

    isField = IS_FIELD(dwFlags);

    if (isField) {
        if (dwFlags & VPP_INTERLEAVED) {
            if (dwFlags & VPP_ODD) {
                dwSrcOffset += dwSrcPitch;
                dwDstOffset += dwDstPitch;
            }
            dwSrcPitch <<= 1;
            dwDstPitch <<= 1;
            dwHeight >>= 1;
        }
    }

    if (vpp.colorCtrl.lContrast > 0xFF) {
        cnt = vpp.colorCtrl.lContrast >> 1;
        bOverContrast = TRUE;
    } else {
        cnt = vpp.colorCtrl.lContrast;
        bOverContrast = FALSE;
    }
    if(vpp.colorCtrl.lBrightness  < 0 ) {
      brt = -vpp.colorCtrl.lBrightness;
    } else {
      brt = vpp.colorCtrl.lBrightness;
    }
    hue = (short) vpp.colorCtrl.lHue;
    sat = (short) vpp.colorCtrl.lSaturation;

    dwSysPitch = dwSrcPitch >> 1;
    if (dwFourCC == FOURCC_UYVY || dwFourCC == FOURCC_UYNV) {
        dwContrast   = (cnt << 8) | (cnt << 24) | 0x00FF00FF;
        dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
        dwYPhase = 1;
    } else if (dwFourCC == FOURCC_YUY2 || dwFourCC == FOURCC_YUNV) {
        dwContrast   = cnt | (cnt << 16) | 0xFF00FF00;
        dwBrightness = brt | (brt << 8) | (brt << 16) | (brt << 24);
        dwYPhase = 0;
    } else {
        dwContrast   = 0xFFFFFFFF;
        dwBrightness = 0;
        bOverContrast = FALSE;
        dwYPhase = 0;
    }
    if (dwFourCC == FOURCC_YV12 ||
        dwFourCC == FOURCC_YVU9 ||
        dwFourCC == FOURCC_IF09 ||
        dwFourCC == FOURCC_IV31 ||
        dwFourCC == FOURCC_IV32) {
        dwSrcPitch <<= 1;
        dwSysPitch <<= 1;
    }

    dwWidth = (dwWidth + 1) & ~1;      // width must be even
    //if (dwWidth > dwSysPitch)
    //   dwWidth -= 2;
    dwMergeSize = (dwHeight << 16) | (dwWidth >> 1);

    doContrastBlt = (dwContrast != 0xFFFFFFFF);
    doLuma        = (dwBrightness != 0 || bOverContrast);
    doChroma      = (hue != 0 || sat != 0x100);

    if (doChroma) {
        // Apply a chroma vector scale and rotation
        // [U'] = [ sat*cos(hue)  sat*sin(hue)] [U]
        // [V']   [-sat*sin(hue)  sat*cos(hue)] [V]
        short sinhue, coshue;
        __int64 c1, c2;
        static const __int64 bOneTwentyEight = 0x8080808080808080;
        static const __int64 evenMask        = 0x00FF00FF00FF00FF;
        static const __int64 oddMask         = 0xFF00FF00FF00FF00;
        static const __int64 zero            = 0;
        DWORD dwChromaOffset, dwAdjWidth, j;
        LPBYTE qPtr;
        // sin table normalized to 256
        static const short sintable[91] = {  0,  4,  9, 13, 18, 22, 27, 31,
                                            36, 40, 44, 49, 53, 58, 62, 66,
                                            71, 75, 79, 83, 88, 92, 96,100,
                                           104,108,112,116,120,124,128,132,
                                           136,139,143,147,150,154,158,161,
                                           165,168,171,175,178,181,184,187,
                                           190,193,196,199,202,204,207,210,
                                           212,215,217,219,222,224,226,228,
                                           230,232,234,236,237,239,241,242,
                                           243,245,246,247,248,249,250,251,
                                           252,253,254,254,255,255,255,256,
                                           256,256,256 };

        dwChromaOffset = dwSysPitch * dwHeight;

        // move chroma data to system memory
        _asm {emms};

        VppResetNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[V2OSH_FORMAT_NDX].classIID);
        vpp.pPusher->push( 0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
        vpp.pPusher->push( 1, vpp.hFromVideoMemContextDma);              // SetContextDmaBufferIn
        vpp.pPusher->push( 2, vpp.hFloatingContextDmaInOverlayShadow);   // SetContextDmaBufferOut
        vpp.pPusher->push( 3, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push( 4, dwSrcOffset + (dwYPhase ^ 1));             // OffsetIn
        vpp.pPusher->push( 5, dwChromaOffset);                           // OffsetOut
        vpp.pPusher->push( 6, dwSrcPitch);                               // PitchIn
        vpp.pPusher->push( 7, dwSysPitch);                               // PitchOut
        vpp.pPusher->push( 8, dwWidth);                                  // LineLengthIn
        vpp.pPusher->push( 9, dwHeight);                                 // LineCount
        vpp.pPusher->push(10, 0x102);                                    // Format
        vpp.pPusher->push(11, VPP_NOTIFY_TYPE);                          // BufferNotify
        vpp.pPusher->adjust(12);
        vpp.pPusher->start(TRUE);

        // coefficient calculations
        // possible MMX multiply overflow later, so halve the coefficients now
        // and double the result later with saturation
        if (vpp.colorCtrl.lHue <= 90) {
            sinhue = (short)(((long)sat * sintable[hue]) >> 9);
            coshue = (short)(((long)sat * sintable[90 - hue]) >> 9);
        } else if (vpp.colorCtrl.lHue <= 180) {
            sinhue = (short)(((long)sat * sintable[180 - hue]) >> 9);
            coshue = (short)(((long)sat * -sintable[hue - 90]) >> 9);
        } else if (vpp.colorCtrl.lHue <= 270) {
            sinhue = (short)(((long)sat * -sintable[hue - 180]) >> 9);
            coshue = (short)(((long)sat * -sintable[270 - hue]) >> 9);
        } else {
            sinhue = (short)(((long)sat * -sintable[360 - hue]) >> 9);
            coshue = (short)(((long)sat * sintable[hue - 270]) >> 9);
        }

        // c1 = sat*cos(hue), sat*cos(hue), sat*cos(hue), sat*cos(hue)
        c1 = (__int64)coshue & 0xFFFF;
        c1 |= c1 << 16;
        c1 |= c1 << 32;
        // c2 = -sat*sin(hue), sat*sin(hue), -sat*sin(hue), sat*sin(hue)
        c2 = (__int64)sinhue & 0xFFFF;
        c2 |= ((__int64)-sinhue & 0xFFFF) << 16;
        c2 |= c2 << 32;

        // init MMX const data
        qPtr       = (LPBYTE) (vpp.fpOverlayShadow + dwChromaOffset);
        dwAdjWidth = (dwWidth + 7) / 8;
        _asm {
            movq        mm0, zero
            movq        mm1, bOneTwentyEight
        }

        // while we are doing some host MMX things, overlap with some luma operations
        // since we are main memory throughput bound, DO NOT overlap with operations that touch main memory
        if (doContrastBlt) {
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hContextBeta4);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | BETA4_SET_BETA_FACTOR_OFFSET | 0x40000);
            vpp.pPusher->push(3, dwContrast);

            vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(5, vpp.hSurfaces2D);
            vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | SURFACES_2D_PITCH_OFFSET | 0xC0000);
            if (doLuma) {
                // more stuff to do later, do this in place
                vpp.pPusher->push(7, (dwSrcPitch << 16) | dwSrcPitch); // set pitch
                vpp.pPusher->push(8, dwSrcOffset);                     // set offset source
                vpp.pPusher->push(9, dwSrcOffset);                     // set offset destin
                vpp.pDriverData->bltData.dwLastCombinedPitch = (dwSrcPitch << 16) | dwSrcPitch;
                vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
                vpp.pDriverData->bltData.dwLastDstOffset = dwSrcOffset;
            } else {
                vpp.pPusher->push(7, (dwDstPitch << 16) | dwSrcPitch); // set pitch
                vpp.pPusher->push(8, dwSrcOffset);                     // set offset source
                vpp.pPusher->push(9, dwDstOffset);                     // set offset destin
                vpp.pDriverData->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
                vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
                vpp.pDriverData->bltData.dwLastDstOffset = dwDstOffset;
            }

            vpp.pPusher->push(10, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(11, vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
            vpp.pPusher->push(12, SUB_CHANNEL(vpp.spareSubCh) | BLIT_POINT_IN_OFFSET | 0xC0000);
            vpp.pPusher->push(13, 0);                                  // control point in
            vpp.pPusher->push(14, 0);                                  // control point out
            vpp.pPusher->push(15, dwMergeSize);                        // size

            vpp.pPusher->adjust(16);
            vpp.pPusher->start(TRUE);
        }

        if (!doContrastBlt && !doLuma) {
            // luma has not and will not move, do that now
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemUVtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwSrcOffset + dwYPhase);          // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + dwYPhase);          // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch);                      // PitchIn
            vpp.pPusher->push(6, dwDstPitch);                      // PitchOut
            vpp.pPusher->push(7, dwWidth);                         // LineLengthIn
            vpp.pPusher->push(8, dwHeight);                        // LineCount
            vpp.pPusher->push(9, 0x202);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);
            vpp.pPusher->start(TRUE);
        }

        // wait for chroma to arrive in system memory
        _asm {emms};
        // if (IS_EVENT_ERROR(WaitForSingleObject(lpProcInfo->hColourControl3, VPP_TIMEOUT_TIME))) {
        if (VppWaitForNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3, VPP_TIMEOUT_TIME)) {
            dbgError(" *** COLOUR CONTROL event failure ***");
            EVENT_ERROR;
        }

/*      // commented out because this appears to cause a cache coherency problem (bug in BX?)
        // preload the first 8 scan lines into the cache
        for (j=0; j<8; j++) {
            _asm {
                        mov     esi, qPtr
                        mov     ecx, dwAdjWidth
                        shr     ecx, 2
                preld1: mov     eax, [esi]
                        mov     eax, 0
                        add     esi, 32
                        dec     ecx
                        jnz     preld1
            }
            qPtr += dwSysPitch;
        }
*/
        // do the chroma vector scale and rotation, 2.25 cycles/pixel
        // mm0 = 0
        // mm1 = 128
        // mm2 = sign mask
        // mm3 = data quad / expanded data / result high
        // mm4 = expanded data / result low
        // mm5 = expanded data, UV swapped
        // mm6 = UV swapped quad / expanded swapped data
        // mm7 = work space
        if (vpp.regOverlayColourControlEnable == 2) {
            // full chroma resolution
            for (j=0; j<dwHeight; j++) {
                _asm {
                            mov         ecx, dwAdjWidth
                            mov         esi, qPtr
                            mov         edi, qPtr
                            mov         ebx, dwSysPitch
                    ;        shl         ebx, 3
                            movq        mm3, [esi]
                            psubb       mm3, mm1
                            movq        mm2, mm0
                            pcmpgtb     mm2, mm3
                            movq        mm4, mm3
                            movq        mm7, mm3
                            punpcklbw   mm4, mm2
                    nextc:  mov         eax, [esi+ebx]  ; U  ; preload cache for next scan line
                            mov         eax, 0          ; V  ; ensure OOE works
                            pmullw      mm4, c1         ; U  ; mm4 = c1 * low(UV)
                            movq        mm6, mm3        ; V  ; mm6 = copy of quad data-128
                            add         esi, 8          ; U  ; next source address
                            psrlq       mm6, 8          ; V  ; mm6 >>= 8
                            pand        mm6, evenMask   ; U  ; mm6 &= 0x00FF00FF00FF00FF
                            psllq       mm7, 8          ; V  ; mm7 <<= 8
                            pand        mm7, oddMask    ; U  ; mm7 &= 0xFF00FF00FF00FF00
                            punpckhbw   mm3, mm2        ; V  ; mm3 = unpacked signed high data
                            pmullw      mm3, c1         ; U  ; mm3 = c1 * high(UV)
                            por         mm6, mm7        ; V  ; mm6 |= mm7, UV are now swapped
                            movq        mm5, mm6        ; U  ; mm5 = quad data with UV swapped
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            add         edi, 8          ; U  ; next destination address
                            pcmpgtb     mm2, mm6        ; V  ; mm2 = sign bits of swapped UV
                            punpcklbw   mm5, mm2        ; U  ; mm5 = unpacked signed low VU data
                            movq        mm7, mm3        ; V  ; move result to mm7 so we can reuse mm3 early
                            movq        mm3, [esi]      ; U  ; mm3 = new data quad
                            punpckhbw   mm6, mm2        ; V  ; mm6 = unpacked signed high VU data
                            pmullw      mm5, c2         ; U  ; mm5 = c2 * low(VU)
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            pmullw      mm6, c2         ; U  ; mm6 = c2 * high(VU)
                            psubb       mm3, mm1        ; V  ; mm3 -= 128
                            paddsw      mm5, mm4        ; U  ; mm5 += mm4
                            paddsw      mm6, mm7        ; V  ; mm6 += mm7
                            dec         ecx             ; U  ; decrement loop count
                            psraw       mm5, 7          ; V  ; downshift result and multiply by 2
                            psraw       mm6, 7          ; U  ; downshift result and multiply by 2
                            pcmpgtb     mm2, mm3        ; V  ; mm2 = sign bits
                            packsswb    mm5, mm6        ; U  ; mm5 = packed(mm5,mm6)
                            paddb       mm5, mm1        ; V  ; mm5 += 128
                            movq        mm7, mm3        ; U  ; mm7 = copy of quad data-128
                            movq        mm4, mm3        ; V  ; mm4 = copy of quad data-128
                            movq        [edi-8], mm5    ; U  ; store data from mm5
                            punpcklbw   mm4, mm2        ; V  ; mm4 = unpacked signed low UV data
                            jnz         nextc
                }
                qPtr += dwSysPitch;
            }
        } else {
            // vertical chroma subsample
            // in this case, ESI is used for source and in-place destination, and EDI is used for next line in destination
            for (j=0; j<dwHeight; j+=2) {
                _asm {
                            mov         ecx, dwAdjWidth
                            mov         esi, qPtr
                            mov         edi, qPtr
                            add         edi, dwSysPitch
                            mov         ebx, dwSysPitch
                            shl         ebx, 1
                    ;        shl         ebx, 3
                            movq        mm3, [esi]
                            psubb       mm3, mm1
                            movq        mm2, mm0
                            pcmpgtb     mm2, mm3
                            movq        mm4, mm3
                            movq        mm7, mm3
                            punpcklbw   mm4, mm2
                    nextc2: mov         eax, [esi+ebx]  ; U  ; preload cache for next scan line
                            mov         eax, 0          ; V  ; ensure OOE works
                            pmullw      mm4, c1         ; U  ; mm4 = c1 * low(UV)
                            movq        mm6, mm3        ; V  ; mm6 = copy of quad data-128
                            add         esi, 8          ; U  ; next source address
                            psrlq       mm6, 8          ; V  ; mm6 >>= 8
                            pand        mm6, evenMask   ; U  ; mm6 &= 0x00FF00FF00FF00FF
                            psllq       mm7, 8          ; V  ; mm7 <<= 8
                            pand        mm7, oddMask    ; U  ; mm7 &= 0xFF00FF00FF00FF00
                            punpckhbw   mm3, mm2        ; V  ; mm3 = unpacked signed high data
                            pmullw      mm3, c1         ; U  ; mm3 = c1 * high(UV)
                            por         mm6, mm7        ; V  ; mm6 |= mm7, UV are now swapped
                            movq        mm5, mm6        ; U  ; mm5 = quad data with UV swapped
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            add         edi, 8          ; U  ; next destination address
                            pcmpgtb     mm2, mm6        ; V  ; mm2 = sign bits of swapped UV
                            movq        mm7, mm3        ; U  ; move result to mm7 so we can reuse mm3 early
                            punpcklbw   mm5, mm2        ; V  ; mm5 = unpacked signed low VU data
                            movq        mm3, [esi]      ; U  ; mm3 = new data quad
                            punpckhbw   mm6, mm2        ; V  ; mm6 = unpacked signed high VU data
                            pmullw      mm5, c2         ; U  ; mm5 = c2 * low(VU)
                            movq        mm2, mm0        ; V  ; mm2 = 0
                            pmullw      mm6, c2         ; U  ; mm6 = c2 * high(VU)
                            psubb       mm3, mm1        ; V  ; mm3 -= 128
                            paddsw      mm5, mm4        ; U  ; mm5 += mm4
                            paddsw      mm6, mm7        ; V  ; mm6 += mm7
                            dec         ecx             ; U  ; decrement loop count
                            psraw       mm5, 7          ; V  ; downshift result and multiply by 2
                            psraw       mm6, 7          ; U  ; downshift result and multiply by 2
                            pcmpgtb     mm2, mm3        ; V  ; mm2 = sign bits
                            packsswb    mm5, mm6        ; U  ; mm5 = packed(mm5,mm6)
                            paddb       mm5, mm1        ; V  ; mm5 += 128
                            movq        mm7, mm3        ; U  ; mm7 = copy of quad data-128
                            movq        mm4, mm3        ; V  ; mm4 = copy of quad data-128
                            movq        [edi-8], mm5    ; U  ; store data from mm5
                            punpcklbw   mm4, mm2        ; V  ; mm4 = unpacked signed low UV data
                            movq        [esi-8], mm5    ; U  ; store same data on next line
                            jnz         nextc2          ; V
                }
                qPtr += dwSysPitch << 1;
            }
        }

        _asm {emms};

        VppResetNotification(vpp.m_obj_a[OSH2V_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

        // move chroma data to back to video memory

        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[OSH2V_FORMAT_NDX].classIID);
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
        vpp.pPusher->push(1, vpp.hFloatingContextDmaInOverlayShadow);          // SetContextDmaBufferIn
        vpp.pPusher->push(2, vpp.hToVideoMemContextDma);                       // SetContextDmaBufferOut
        vpp.pPusher->push(3, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push(4, dwChromaOffset);                                  // OffsetIn
        vpp.pPusher->push(5, dwDstOffset + (dwYPhase ^ 1));                    // OffsetOut
        vpp.pPusher->push(6, dwSysPitch);                                      // PitchIn
        vpp.pPusher->push(7, dwDstPitch);                                      // PitchOut
        vpp.pPusher->push(8, dwWidth);                                         // LineLengthIn
        vpp.pPusher->push(9, dwHeight);                                        // LineCount
        vpp.pPusher->push(10, 0x201);                                          // Format
        if (!doLuma) {
            vpp.pPusher->push(11, VPP_NOTIFY_TYPE);                            // BufferNotify
        } else {
            vpp.pPusher->push(11, NV039_BUFFER_NOTIFY_WRITE_ONLY);             // BufferNotify
        }
        vpp.pPusher->adjust(12);
        vpp.pPusher->start(TRUE);

        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[OSH2V_FORMAT_NDX].classIID;

    } else if (doContrastBlt) {
        // Contrast Blit, since the hardware can only do multiplies up to one (0xFF),
        // and if the contrast is from 100% to 200%, then divide contrast by 2 and worry
        // about left shift and saturation in the MMX routines below
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextBeta4);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | BETA4_SET_BETA_FACTOR_OFFSET | 0x40000);
        vpp.pPusher->push(3, dwContrast);

        vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(5, vpp.hSurfaces2D);
        vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | SURFACES_2D_PITCH_OFFSET | 0xC0000);
        if (doLuma) {
            // more stuff to do later, do this in place
            vpp.pPusher->push(7, (dwSrcPitch << 16) | dwSrcPitch); // set pitch
            vpp.pPusher->push(8, dwSrcOffset);                     // set offset source
            vpp.pPusher->push(9, dwSrcOffset);                     // set offset destin
            vpp.pDriverData->bltData.dwLastCombinedPitch = (dwSrcPitch << 16) | dwSrcPitch;
            vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
            vpp.pDriverData->bltData.dwLastDstOffset = dwSrcOffset;
        } else {
            vpp.pPusher->push(7, (dwDstPitch << 16) | dwSrcPitch); // set pitch
            vpp.pPusher->push(8, dwSrcOffset);                     // set offset source
            vpp.pPusher->push(9, dwDstOffset);                     // set offset destin
            vpp.pDriverData->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
            vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
            vpp.pDriverData->bltData.dwLastDstOffset = dwDstOffset;
        }

        vpp.pPusher->push(10, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(11, vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
        vpp.pPusher->push(12, SUB_CHANNEL(vpp.spareSubCh) | BLIT_POINT_IN_OFFSET | 0xC0000);
        vpp.pPusher->push(13, 0);                                  // control point in
        vpp.pPusher->push(14, 0);                                  // control point out
        vpp.pPusher->push(15, dwMergeSize);                        // size
        vpp.pPusher->adjust(16);

        if (!doLuma) {
            // this is the only operation, be sure to trigger an event
            _asm {emms};

            VppResetNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | NV05F_NOTIFY | 0x40000);
            vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV05F_NO_OPERATION | 0x40000);
            vpp.pPusher->push(3, 0);
            vpp.pPusher->adjust(4);
        }
        vpp.pPusher->start(TRUE);
    }

    // OverContrast and Brightness calculations
    if (doLuma) {
        static const __int64 shiftMask   = 0xFEFEFEFEFEFEFEFE;
        static const __int64 cmpOverflow = 0xFFFFFFFFFFFFFFFF;
        DWORD j, dwAdjWidth;
        LPBYTE qPtr;

        // move Y data to system memory
        _asm {emms};

        VppResetNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[V2OSH_FORMAT_NDX].classIID);
        vpp.pPusher->push( 0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
        vpp.pPusher->push( 1, vpp.hFromVideoMemContextDma);           // SetContextDmaBufferIn
        vpp.pPusher->push( 2, vpp.hFloatingContextDmaInOverlayShadow);// SetContextDmaBufferOut
        vpp.pPusher->push( 3, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push( 4, dwSrcOffset + dwYPhase);                // OffsetIn
        vpp.pPusher->push( 5, 0);                                     // OffsetOut
        vpp.pPusher->push( 6, dwSrcPitch);                            // PitchIn
        vpp.pPusher->push( 7, dwSysPitch);                            // PitchOut
        vpp.pPusher->push( 8, dwWidth);                               // LineLengthIn
        vpp.pPusher->push( 9, dwHeight);                              // LineCount
        vpp.pPusher->push(10, 0x102);                                 // Format
        vpp.pPusher->push(11, VPP_NOTIFY_TYPE);                       // BufferNotify
        vpp.pPusher->adjust(12);
        vpp.pPusher->start(TRUE);

        if (!doChroma) {
            // chroma has not and will not move, do that now
            vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
            vpp.pPusher->push(1, vpp.hVideoMemUVtoVideoMemFormat);
            vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
            vpp.pPusher->push(3, dwSrcOffset + (dwYPhase ^ 1));    // OffsetIn
            vpp.pPusher->push(4, dwDstOffset + (dwYPhase ^ 1));    // OffsetOut
            vpp.pPusher->push(5, dwSrcPitch);                      // PitchIn
            vpp.pPusher->push(6, dwDstPitch);                      // PitchOut
            vpp.pPusher->push(7, dwWidth);                         // LineLengthIn
            vpp.pPusher->push(8, dwHeight);                        // LineCount
            vpp.pPusher->push(9, 0x202);                           // Format
            vpp.pPusher->push(10, NV039_BUFFER_NOTIFY_WRITE_ONLY); // BufferNotify
            vpp.pPusher->adjust(11);
            vpp.pPusher->start(TRUE);
        }

        // init MMX const data
        qPtr       = (LPBYTE) vpp.fpOverlayShadow;
        dwAdjWidth = (dwWidth + 15) / 16;
        _asm {
            movd        mm0, dwBrightness
            punpckldq   mm0, dwBrightness
            movq        mm2, shiftMask
            movq        mm3, cmpOverflow
        }

        // wait for luma data to arrive in system memory
        _asm {emms};
        // if (IS_EVENT_ERROR(WaitForSingleObject(lpProcInfo->hColourControl3, VPP_TIMEOUT_TIME))) {
        if (VppWaitForNotification(vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3, VPP_TIMEOUT_TIME)) {
            dbgError(" *** COLOUR CONTROL event failure ***");
            EVENT_ERROR;
        }
/*
        // preload the first 8 scan lines into the cache
        for (j=0; j<8; j++) {
            _asm {
                        mov     esi, qPtr
                        mov     ecx, dwAdjWidth
                        shr     ecx, 1
                preld2: mov     eax, [esi]
                        mov     eax, 0
                        add     esi, 32
                        dec     ecx
                        jnz     preld2
            }
            qPtr += dwSysPitch;
        }
*/
        // do brightness and/or overcontrast
        // mm0 = brightness
        // mm1 = quad data chunk
        // mm2 = shift mask
        // mm3 = overflow compare value
        // mm4 = compare register
        // mm5 = next quad data chunk
        // mm6 = next compare register
        if (vpp.colorCtrl.lBrightness >= 0) {
            if (bOverContrast) {
                // overcontrast and positive brightness, 0.6875 cycles/pixel
                // AND is commented out for performance -> noise in the lowest bit of precision
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwSysPitch
                       ;         shl     ebx, 3
                                movq    mm1, [esi]
                                movq    mm4, mm3
                        nextq1: mov     eax, [esi+ebx]  ; U     ; preload cache for next scan line
                                mov     eax, 0          ; V     ; ensure OOE works
                                movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                pcmpgtb mm4, mm1        ; Vi    ; mm4 = sign bit of data[i]
                                add     esi, 16         ; U     ; next source address
                                movq    mm6, mm3        ; Vi+   ; mm6 = overflow compare value
                                add     edi, 16         ; U     ; next destination address
                                psll    mm1, 1          ; Vi    ; mm1 <<= 1
                                pcmpgtb mm6, mm5        ; Ui+   ; mm6 = sign bit of data[i+1]
                       ;         pand    mm1, mm2        ; i    ; mm1 &= 0xFE (since there is no PSLLB)
                                por     mm4, mm1        ; Vi    ; mm4 |= mm1 (saturated result[i])

                                psll    mm5, 1          ; Ui+   ; mm5 <<= 1
                                paddusb mm4, mm0        ; Vi    ; mm4 += brightness
                       ;         pand    mm5, mm2        ; i+   ; mm5 &= 0xFE
                                movq    [edi-16], mm4   ; Ui    ; store result[i]
                                por     mm6, mm5        ; Vi+   ; mm6 |= mm5 (saturated result[i+1])
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                paddusb mm6, mm0        ; Vi+   ; mm6 += brightness
                                dec     ecx             ; U     ; decrement loop count
                                movq    mm4, mm3        ; Vi    ; mm4 = overflow compare value
                                movq    [edi-8], mm6    ; Ui+   ; store result[i+1]
                                jnz     nextq1          ; V
                    }
                    qPtr += dwSysPitch;
                }
            } else {
                // positive brightness only
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwSysPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                        nextq2: mov     eax, [esi+ebx]  ; U     ; preload cache for next scan line
                                mov     eax, 0          ; V     ; ensure OOE works
                                movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                paddusb mm1, mm0        ; Vi    ; mm1 += brightness
                                add     esi, 16         ; U     ; next source address
                                add     edi, 16         ; V     ; next destination address
                                dec     ecx             ; U     ; decrement loop count
                                movq    [edi-16], mm1   ; Ui    ; store result[i]
                                paddusb mm5, mm0        ; Vi+   ; mm5 += brightness
                                movq    [edi-8], mm5    ; Ui+   ; store result[i+1]
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                jnz     nextq2          ; V
                    }
                    qPtr += dwSysPitch;
                }
            }
        } else {
            if (bOverContrast) {
                // overcontrast and negative brightness
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwSysPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                                movq    mm4, mm3
                        nextq3: mov     eax, [esi+ebx]  ; U     ; preload cache for next scan line
                                mov     eax, 0          ; V     ; ensure OOE works
                                movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                pcmpgtb mm4, mm1        ; Vi    ; mm4 = sign bit of data[i]
                                add     esi, 16         ; U     ; next source address
                                movq    mm6, mm3        ; Vi+   ; mm6 = overflow compare value
                                add     edi, 16         ; U     ; next destination address
                                psll    mm1, 1          ; Vi    ; mm1 <<= 1
                                pcmpgtb mm6, mm5        ; Ui+   ; mm6 = sign bit of data[i+1]
                       ;         pand    mm1, mm2        ; i    ; mm1 &= 0xFE (since there is no PSLLB)
                                por     mm4, mm1        ; Vi    ; mm4 |= mm1 (saturated result[i])

                                psll    mm5, 1          ; Ui+   ; mm5 <<= 1
                                psubusb mm4, mm0        ; Vi    ; mm4 -= brightness
                       ;         pand    mm5, mm2        ; i+   ; mm5 &= 0xFE
                                movq    [edi-16], mm4   ; Ui    ; store result[i]
                                por     mm6, mm5        ; Vi+   ; mm6 |= mm5 (saturated result[i+1])
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                psubusb mm6, mm0        ; Vi+   ; mm6 -= brightness
                                dec     ecx             ; U     ; decrement loop count
                                movq    mm4, mm3        ; Vi    ; mm4 = overflow compare value
                                movq    [edi-8], mm6    ; Ui+   ; store result[i+1]
                                jnz     nextq3          ; V
                    }
                    qPtr += dwSysPitch;
                }
            } else {
                // negative brightness only
                for (j=0; j<dwHeight; j++) {
                    _asm {
                                mov     ecx, dwAdjWidth
                                mov     esi, qPtr
                                mov     edi, qPtr
                                mov     ebx, dwSysPitch
                        ;        shl     ebx, 3
                                movq    mm1, [esi]
                        nextq4: mov     eax, [esi+ebx]  ; U     ; preload cache for next scan line
                                mov     eax, 0          ; V     ; ensure OOE works
                                movq    mm5, [esi+8]    ; Ui+   ; mm5 = data[i+1]
                                psubusb mm1, mm0        ; Vi    ; mm1 -= brightness
                                add     esi, 16         ; U     ; next source address
                                add     edi, 16         ; V     ; next destination address
                                dec     ecx             ; U     ; decrement loop count
                                movq    [edi-16], mm1   ; Ui    ; store result[i]
                                psubusb mm5, mm0        ; Vi+   ; mm5 -= brightness
                                movq    [edi-8], mm5    ; Ui+   ; store result[i+1]
                                movq    mm1, [esi]      ; Ui    ; mm1 = data[i]
                                jnz     nextq4          ; V
                    }
                    qPtr += dwSysPitch;
                }
            }
        }

        // move Y data to back to video memory
        _asm {emms};

        VppResetNotification(vpp.m_obj_a[OSH2V_FORMAT_NDX].notifier_a, lpProcInfo->hColourControl3);

        vpp.pPusher->setObject(vpp.spareSubCh,vpp.m_obj_a[OSH2V_FORMAT_NDX].classIID);
        vpp.pPusher->push( 0, SUB_CHANNEL(vpp.spareSubCh) | NV039_SET_CONTEXT_DMA_BUFFER_IN | 0x80000);
        vpp.pPusher->push( 1, vpp.hFloatingContextDmaInOverlayShadow);// SetContextDmaBufferIn
        vpp.pPusher->push( 2, vpp.hToVideoMemContextDma);             // SetContextDmaBufferOut
        vpp.pPusher->push( 3, SUB_CHANNEL(vpp.spareSubCh) | MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET | 0x200000);
        vpp.pPusher->push( 4, 0);                                     // OffsetIn
        vpp.pPusher->push( 5, dwDstOffset + dwYPhase);                // OffsetOut
        vpp.pPusher->push( 6, dwSysPitch);                            // PitchIn
        vpp.pPusher->push( 7, dwDstPitch);                            // PitchOut
        vpp.pPusher->push( 8, dwWidth);                               // LineLengthIn
        vpp.pPusher->push( 9, dwHeight);                              // LineCount
        vpp.pPusher->push(10, 0x201);                                 // Format
        vpp.pPusher->push(11, VPP_NOTIFY_TYPE);                       // BufferNotify
        vpp.pPusher->adjust(12);
        vpp.pPusher->start(TRUE);

        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[OSH2V_FORMAT_NDX].classIID;
    }

    _asm {emms};
    return doContrastBlt || doLuma || doChroma;
}


//---------------------------------------------------------------------------
// vppNv20Deinterlace
//      Deinterlace filter for NV20.  Surface dimensions do not have to be a
//      power of 2.  Texture does not have to be swizzled.
LOCAL  BOOL vppNv20Deinterlace(Vpp_t *pVpp, LPPROCESSINFO lpProcInfo,
                        DWORD dwSrcOffset, DWORD dwSrcPitch,
                        DWORD dwDstOffset, DWORD dwDstPitch,
                        DWORD dwWidth, DWORD dwHeight, DWORD dwFlags)
{
    DWORD dwMergeSize;
    BOOL isField, isOddField;
    DWORD dwCombineFactor;
    int dwOppositeYOffset, dwCurrYOffset, dwDestYOffset;
    DWORD dwOppositeFieldOffset;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert(vpp.dwFlags & VPP_FLAG_KELVIN_3D);

    // Let D3D code know that we have touched NV
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    isField = IS_FIELD(dwFlags);
    isOddField = isField && (dwFlags & VPP_ODD);

    if (!isField || !(dwFlags & VPP_INTERLEAVED)) {
        return FALSE;
    }

    dwCombineFactor = (vpp.regOverlayMode >> 16) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    dwOppositeFieldOffset = dwSrcOffset;

    if (dwFlags & VPP_ODD) {
        dwSrcOffset += dwSrcPitch;
        dwDstOffset += dwDstPitch;
    } else {
        dwOppositeFieldOffset += dwSrcPitch;
    }

    dwSrcPitch <<= 1;
    dwDstPitch <<= 1;
    dwHeight >>= 1;

    // convert RGB16 to RGB32 width
    dwWidth >>= 1;

    dwMergeSize = (dwWidth << 16) | dwHeight;

    nvAssert(vpp.pThreeDClassLastUser);
    if (*vpp.pThreeDClassLastUser != MODULE_ID_DDRAW_VPP)
    {
        if (!vppInitKelvin(&vpp)) {
            return FALSE;
        }
    }

    vpp.pPusher->push(0, subchannel | NV097_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    vpp.pPusher->push(1, ((dwWidth << 16) | 0));
    vpp.pPusher->push(2, subchannel | NV097_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    vpp.pPusher->push(3, ((dwHeight << 16) | 0));
    vpp.pPusher->adjust(4);

    vpp.pPusher->push(0, subchannel | NV097_SET_SURFACE_PITCH | 0x40000);
    vpp.pPusher->push(1, (dwDstPitch << 16) | dwDstPitch);
    vpp.pPusher->adjust(2);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    vpp.pPusher->push(1, dwCombineFactor);     // % of current field
    vpp.pPusher->push(2, subchannel | NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    vpp.pPusher->push(3, dwCombineFactor);
    vpp.pPusher->adjust(4);

    // Make sure offset is 128-byte aligned (in debug builds)
    nvAssert(!((dwSrcOffset % 128) || (dwOppositeFieldOffset & ~0x1) % 128));

    vpp.pPusher->push(0, subchannel | NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    vpp.pPusher->push(1, dwSrcOffset);
    vpp.pPusher->push(2, subchannel | NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    vpp.pPusher->push(3, dwSrcOffset);//dwOppositeFieldOffset & ~0x1);
    vpp.pPusher->push(4, subchannel | NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    vpp.pPusher->push(5, dwDstOffset);
    vpp.pPusher->adjust(6);

    // IMPORTANT: Even if we are not using texture units 2 and 3, we need to give
    // them some kind of value other than zero in the following commands.
    // Without these, the hardware will behave incorrectly, probably exhibiting
    // a problem that looks like an invalid surface pitch.
    vpp.pPusher->push(0, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    vpp.pPusher->push(1, dwMergeSize);
    vpp.pPusher->push(2, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    vpp.pPusher->push(3, dwMergeSize);
    vpp.pPusher->push(4, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    vpp.pPusher->push(5, 8 << 16 | 8);
    vpp.pPusher->push(6, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    vpp.pPusher->push(7, 8 << 16 | 8);
    vpp.pPusher->push(8, subchannel | NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    vpp.pPusher->push(9, dwSrcPitch << 16);
    vpp.pPusher->push(10, subchannel | NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    vpp.pPusher->push(11, dwSrcPitch << 16);
    vpp.pPusher->push(12, subchannel | NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    vpp.pPusher->push(13, 8 << 16 | 8);
    vpp.pPusher->push(14, subchannel | NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    vpp.pPusher->push(15, 8 << 16 | 8);
    vpp.pPusher->adjust(16);

    vpp.pPusher->push(0, subchannel +
                         NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000);
    vpp.pPusher->push(1, 0);
    vpp.pPusher->push(2, 0);
    vpp.pPusher->push(3, 0);
    vpp.pPusher->push(4, 0);
    vpp.pPusher->push(5, 0);
    vpp.pPusher->push(6, 0);
    vpp.pPusher->push(7, 0);
    vpp.pPusher->push(8, 0);
    vpp.pPusher->push(9, 0);
    vpp.pPusher->push(10, 4);
    vpp.pPusher->push(11, 8);
    vpp.pPusher->push(12, 0);
    vpp.pPusher->push(13, 0);
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000);
    vpp.pPusher->push(15, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(16, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(17, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(18, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(19, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(20, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(21, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(22, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(23, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(24, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(25, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(26, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(27, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->adjust(28);

    // specify height and width in 1/4 pixel units
    dwHeight <<= 2;
    dwWidth <<= 2;

    if (dwFlags & VPP_ODD) {
        dwOppositeYOffset = +1;
        dwCurrYOffset     = -1;
        dwDestYOffset     = -1;
    } else {
        dwOppositeYOffset = -1;
        dwCurrYOffset     = +1;
        dwDestYOffset     = +1;
    }

    vpp.pPusher->push(0, subchannel | NV097_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(1, NV097_SET_BEGIN_END_OP_QUADS);
    vpp.pPusher->push(2, subchannel | NV097_INLINE_ARRAY | 0x40300000);

    vpp.pPusher->push(3, (dwDestYOffset << 16) | 0);   // destination
    vpp.pPusher->push(4, (dwCurrYOffset << 16) | 0);   // current field
    vpp.pPusher->push(5, (dwOppositeYOffset << 16) | 0);   // opposite field
    
    vpp.pPusher->push(6, ((dwHeight+dwDestYOffset) << 16) | 0);
    vpp.pPusher->push(7, ((dwHeight+dwCurrYOffset) << 16) | 0);
    vpp.pPusher->push(8, ((dwHeight+dwOppositeYOffset) << 16) | 0);
    
    vpp.pPusher->push(9, ((dwHeight+dwDestYOffset) << 16) | dwWidth);
    vpp.pPusher->push(10, ((dwHeight+dwCurrYOffset) << 16) | dwWidth);
    vpp.pPusher->push(11,  ((dwHeight+dwOppositeYOffset) << 16) | dwWidth);
    
    vpp.pPusher->push(12, (+dwDestYOffset << 16) | dwWidth);
    vpp.pPusher->push(13, (+dwCurrYOffset << 16) | dwWidth);
    vpp.pPusher->push(14, (+dwOppositeYOffset << 16) | dwWidth);
    vpp.pPusher->adjust(15);

    VppResetNotification(NULL, lpProcInfo->hDFilter3);

    vpp.pPusher->push(0, subchannel | NV097_NOTIFY | 0x40000);
    vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(2, subchannel | NV097_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(3, NV097_SET_BEGIN_END_OP_END);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);

    return TRUE;
}


//---------------------------------------------------------------------------
// vppNv10Deinterlace
//      Deinterlace filter for NV10.  Surface dimensions do not have to be a
//      power of 2.  Texture does not have to be swizzled.
LOCAL BOOL vppNv10Deinterlace(Vpp_t *pVpp, LPPROCESSINFO lpProcInfo,
                        DWORD dwSrcOffset, DWORD dwSrcPitch,
                        DWORD dwDstOffset, DWORD dwDstPitch,
                        DWORD dwWidth, DWORD dwHeight, DWORD dwFlags)
{
    DWORD dwMergeSize;
    BOOL isField, isOddField;
    DWORD dwCombineFactor;
    unsigned long vertexSizeContext;
    int dwOppositeYOffset, dwCurrYOffset, dwDestYOffset;
    DWORD dwOppositeFieldOffset;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert (NVARCH >= 0x10);

    isField = IS_FIELD(dwFlags);
    isOddField = isField && (dwFlags & VPP_ODD);

    if (!isField || !(dwFlags & VPP_INTERLEAVED)) {
        return FALSE;
    }

    dwCombineFactor = (vpp.regOverlayMode >> 16) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    if (dwFlags & VPP_ODD) {
        dwOppositeFieldOffset = dwSrcOffset;
        dwSrcOffset += dwSrcPitch;
        dwDstOffset += dwDstPitch;
    } else {
        dwOppositeFieldOffset = dwSrcOffset + dwSrcPitch;
    }
    dwSrcPitch <<= 1;
    dwDstPitch <<= 1;
    dwHeight >>= 1;

    // convert RGB16 to RGB32 width
    dwWidth >>= 1;

    dwMergeSize = (dwWidth << 16) | dwHeight;

    nvAssert(vpp.pThreeDClassLastUser);
    if (*vpp.pThreeDClassLastUser != MODULE_ID_DDRAW_VPP)
    {
        if (!vppInitCelsius(&vpp)) {
            return FALSE;
        }
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    vpp.pPusher->push(1, ((dwWidth << 16) | 0));

    vpp.pPusher->push(2, subchannel +
                   NV056_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    vpp.pPusher->push(3, ((dwHeight << 16) | 0));
    vpp.pPusher->adjust(4);

    vpp.pPusher->push(0, subchannel | NV056_SET_SURFACE_PITCH | 0x40000);
    vpp.pPusher->push(1, (dwDstPitch << 16) | dwDstPitch);
    vpp.pPusher->adjust(2);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    vpp.pPusher->push(1, dwCombineFactor);     // % of current field
    vpp.pPusher->push(2, dwCombineFactor);
    vpp.pPusher->adjust(3);

    vpp.pPusher->push(0, subchannel | NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
    vpp.pPusher->push(1, dwSrcOffset);
    vpp.pPusher->push(2, dwOppositeFieldOffset & ~0x1);
    vpp.pPusher->push(3, subchannel | NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
    vpp.pPusher->push(4, dwDstOffset);
    vpp.pPusher->adjust(5);

    vpp.pPusher->push(0, subchannel | NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    vpp.pPusher->push(1, dwMergeSize);
    vpp.pPusher->push(2, dwMergeSize);
    vpp.pPusher->push(3, subchannel | NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    vpp.pPusher->push(4, dwSrcPitch << 16);
    vpp.pPusher->push(5, dwSrcPitch << 16);
    vpp.pPusher->adjust(6);

    vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                        (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                        (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                        (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 12) | \
                        (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 16) | \
                        (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                        (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                        (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
    vpp.pPusher->push(0, subchannel | NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
    vpp.pPusher->push(1, vertexSizeContext); \
    vpp.pPusher->push(2, subchannel | NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
    vpp.pPusher->push(3, 0); \
    vpp.pPusher->push(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                  (12 << 8) | \
                  (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                   NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(5, 0); \
    vpp.pPusher->push(6, (12 << 8) | \
                  (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                   NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
    vpp.pPusher->push(7, 0); \
    vpp.pPusher->push(8, (12 << 8) | \
                  (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                   NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
    vpp.pPusher->push(9, 4); \
    vpp.pPusher->push(10, (12 << 8) | \
                  (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 4) | \
                   NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(11, 8); \
    vpp.pPusher->push(12, (12 << 8) | \
                   (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 4) | \
                    NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(13, 0); \
    vpp.pPusher->push(14, (12 << 8) | \
                   (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(15, 0); \
    vpp.pPusher->push(16, (12 << 8) | \
                   (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(17, 0); \
    vpp.pPusher->push(18, (12 << 8) | \
                   (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->adjust(19); \

    // specify height and width in 1/4 pixel units
    dwHeight <<= 2;
    dwWidth <<= 2;

    if (dwFlags & VPP_ODD) {
        dwOppositeYOffset = +1;
        dwCurrYOffset     = -1;
        dwDestYOffset     = -1;
    } else {
        dwOppositeYOffset = -1;
        dwCurrYOffset     = +1;
        dwDestYOffset     = +1;
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(1, NV056_SET_BEGIN_END_OP_QUADS);
    vpp.pPusher->push(2, subchannel | NV056_INLINE_ARRAY(0) | 0x300000);

    vpp.pPusher->push(3, (dwOppositeYOffset << 16) | 0);   // opposite field
    vpp.pPusher->push(4, (dwCurrYOffset << 16) | 0);   // current field
    vpp.pPusher->push(5, (dwDestYOffset << 16) | 0);   // destination

    vpp.pPusher->push(6, ((dwHeight+dwOppositeYOffset) << 16) | 0);
    vpp.pPusher->push(7, ((dwHeight+dwCurrYOffset) << 16) | 0);
    vpp.pPusher->push(8, ((dwHeight+dwDestYOffset) << 16) | 0);

    vpp.pPusher->push(9,  ((dwHeight+dwOppositeYOffset) << 16) | dwWidth);
    vpp.pPusher->push(10, ((dwHeight+dwCurrYOffset) << 16) | dwWidth);
    vpp.pPusher->push(11, ((dwHeight+dwDestYOffset) << 16) | dwWidth);

    vpp.pPusher->push(12, (+dwOppositeYOffset << 16) | dwWidth);
    vpp.pPusher->push(13, (+dwCurrYOffset << 16) | dwWidth);
    vpp.pPusher->push(14, (+dwDestYOffset << 16) | dwWidth);
    vpp.pPusher->adjust(15);

    VppResetNotification(NULL, lpProcInfo->hDFilter3); // TBD: need de-interlace notifier ptr

    vpp.pPusher->push(0, subchannel | NV056_NOTIFY | 0x40000);
    vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(2, subchannel | NV056_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(3, NV056_SET_BEGIN_END_OP_END);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);
    return TRUE;
}


//---------------------------------------------------------------------------
// vppNv20Temporal
//      Temporal filter for NV20.  Surface dimensions do not have to be a
//      power of 2.  Texture does not have to be swizzled.
LOCAL BOOL vppNv20Temporal(Vpp_t *pVpp, LPPROCESSINFO lpProcInfo,
                     DWORD dwSrcOffset, DWORD dwSrcPitch,
                     DWORD dwDstOffset, DWORD dwDstPitch,
                     DWORD dwWidth, DWORD dwHeight, DWORD dwFlags,
                     LPDWORD pPrevFrameOffset)
{
    DWORD dwMergeSize;
    BOOL isField, isOddField;
    DWORD dwCombineFactor;
    BOOL isPrevFieldOdd;
    int dwPrevYOffset, dwCurrYOffset, dwDestYOffset;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert(vpp.dwFlags & VPP_FLAG_KELVIN_3D);

    isField = IS_FIELD(dwFlags);
    isOddField = isField && (dwFlags & VPP_ODD);
    isPrevFieldOdd = (*pPrevFrameOffset & 0x1);

    dwCombineFactor = (vpp.regOverlayMode >> 8) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    if (isField) {
        if (dwFlags & VPP_INTERLEAVED) {
            if (dwFlags & VPP_ODD) {
                dwSrcOffset += dwSrcPitch;
                dwDstOffset += dwDstPitch;
            }
            dwSrcPitch <<= 1;
            dwDstPitch <<= 1;
            dwHeight >>= 1;
        }
    }

    if (!(vpp.regOverlayMode & NV4_REG_OVL_MODE_NOTFIRST)) {
        // if first frame
        vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        if (isOddField) {
            // remember field polarity of previous frame
            *pPrevFrameOffset = dwSrcOffset | 0x1;
        } else {
            *pPrevFrameOffset = dwSrcOffset;
        }
        return FALSE;
    }

    // convert RGB16 to RGB32 width
    dwWidth >>= 1;

    dwMergeSize = (dwWidth << 16) | dwHeight;

    nvAssert(vpp.pThreeDClassLastUser);
    if (*vpp.pThreeDClassLastUser != MODULE_ID_DDRAW_VPP)
    {
        if (!vppInitKelvin(&vpp)) {
            return FALSE;
        }
    }

    vpp.pPusher->push(0, subchannel | NV097_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    vpp.pPusher->push(1, ((dwWidth << 16) | 0));
    vpp.pPusher->push(2, subchannel | NV097_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    vpp.pPusher->push(3, ((dwHeight << 16) | 0));
    vpp.pPusher->adjust(4);

    vpp.pPusher->push(0, subchannel | NV097_SET_SURFACE_PITCH | 0x40000);
    vpp.pPusher->push(1, (dwDstPitch << 16) | dwDstPitch);
    vpp.pPusher->adjust(2);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV097_SET_COMBINER_FACTOR0(0) | 0x40000);
    vpp.pPusher->push(1, dwCombineFactor);     // % of current field
    vpp.pPusher->push(2, subchannel | NV097_SET_COMBINER_FACTOR1(0) | 0x40000);
    vpp.pPusher->push(3, dwCombineFactor);
    vpp.pPusher->adjust(4);

    // Make sure offset is 128-byte aligned (in debug builds)
    nvAssert(!((dwSrcOffset % 128) || (*pPrevFrameOffset & ~0x1) % 128));

    vpp.pPusher->push(0, subchannel | NV097_SET_TEXTURE_OFFSET(0) | 0x40000);
    vpp.pPusher->push(1, dwSrcOffset);
    vpp.pPusher->push(2, subchannel | NV097_SET_TEXTURE_OFFSET(1) | 0x40000);
    vpp.pPusher->push(3, *pPrevFrameOffset & ~0x1);
    vpp.pPusher->push(4, subchannel | NV097_SET_SURFACE_COLOR_OFFSET | 0x40000);
    vpp.pPusher->push(5, dwDstOffset);
    vpp.pPusher->adjust(6);

    if (isOddField) {
        // remember field polarity of previous frame
        *pPrevFrameOffset = dwSrcOffset | 0x1;
    } else {
        *pPrevFrameOffset = dwSrcOffset;
    }

    // IMPORTANT: Even if we are not using texture units 2 and 3, we need to give
    // them some kind of value other than zero in the following commands.
    // Without these, the hardware will behave incorrectly, probably exhibiting
    // a problem that looks like an invalid surface pitch.
    vpp.pPusher->push(0, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(0) | 0x40000);
    vpp.pPusher->push(1, dwMergeSize);
    vpp.pPusher->push(2, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(1) | 0x40000);
    vpp.pPusher->push(3, dwMergeSize);
    vpp.pPusher->push(4, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(2) | 0x40000);
    vpp.pPusher->push(5, 8 << 16 | 8);
    vpp.pPusher->push(6, subchannel | NV097_SET_TEXTURE_IMAGE_RECT(3) | 0x40000);
    vpp.pPusher->push(7, 8 << 16 | 8);
    vpp.pPusher->push(8, subchannel | NV097_SET_TEXTURE_CONTROL1(0) | 0x40000);
    vpp.pPusher->push(9, dwSrcPitch << 16);
    vpp.pPusher->push(10, subchannel | NV097_SET_TEXTURE_CONTROL1(1) | 0x40000);
    vpp.pPusher->push(11, dwSrcPitch << 16);
    vpp.pPusher->push(12, subchannel | NV097_SET_TEXTURE_CONTROL1(2) | 0x40000);
    vpp.pPusher->push(13, 8 << 16 | 8);
    vpp.pPusher->push(14, subchannel | NV097_SET_TEXTURE_CONTROL1(3) | 0x40000);
    vpp.pPusher->push(15, 8 << 16 | 8);
    vpp.pPusher->adjust(16);

    // Inspired by BMAC's SET_KELVIN_BIDIRECTIONAL_VERTEX_ARRAY_MODE macro.
    vpp.pPusher->push(0, subchannel +
                         NV097_SET_VERTEX_DATA_ARRAY_OFFSET(0) | 0x340000);
    vpp.pPusher->push(1, 0);
    vpp.pPusher->push(2, 0);
    vpp.pPusher->push(3, 0);
    vpp.pPusher->push(4, 0);
    vpp.pPusher->push(5, 0);
    vpp.pPusher->push(6, 0);
    vpp.pPusher->push(7, 0);
    vpp.pPusher->push(8, 0);
    vpp.pPusher->push(9, 0);
    vpp.pPusher->push(10, 4);
    vpp.pPusher->push(11, 8);
    vpp.pPusher->push(12, 0);
    vpp.pPusher->push(13, 0);
    vpp.pPusher->push(14, subchannel +
                          NV097_SET_VERTEX_DATA_ARRAY_FORMAT(0) | 0x340000);
    vpp.pPusher->push(15, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(16, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(17, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(18, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(19, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(20, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(21, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(22, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(23, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(24, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(25, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_2 << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(26, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->push(27, (12 << 8) |
                          (NV097_SET_VERTEX_DATA_ARRAY_FORMAT_SIZE_DISABLED << 4) |
                           NV097_SET_VERTEX_DATA_ARRAY_FORMAT_TYPE_S32K);
    vpp.pPusher->adjust(28);

    // specify height and width in 1/4 pixel units
    dwHeight <<= 2;
    dwWidth <<= 2;

    // PG - Modified 11/07/2000
    // I temporarily disabled the offsets to counter
    // the misalignment of the fields in the next few lines
    if (isField) {
        if (isOddField != isPrevFieldOdd) {
            // current field as opposite polarity as previous field
            if (dwFlags & VPP_ODD) {
                dwPrevYOffset = +1;
                dwCurrYOffset = -1;
                dwDestYOffset = -1;
            } else {
                dwPrevYOffset = -1;
                dwCurrYOffset = +1;
                dwDestYOffset = +1;
            }
        } else {
            // current field as identical polarity as previous field
            if (dwFlags & VPP_ODD) {
                // odd-odd
                dwPrevYOffset = -1;
                dwCurrYOffset = -1;
                dwDestYOffset = -1;
            } else {
                // even-even
                dwPrevYOffset = +1;
                dwCurrYOffset = +1;
                dwDestYOffset = +1;
            }
        }

    } else {    // weave
        dwPrevYOffset = 0;
        dwCurrYOffset = 0;
        dwDestYOffset = 0;
    }

    vpp.pPusher->push(0, subchannel | NV097_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(1, NV097_SET_BEGIN_END_OP_QUADS);
    vpp.pPusher->push(2, subchannel | NV097_INLINE_ARRAY | 0x40300000);

    vpp.pPusher->push(3, (dwDestYOffset << 16) | 0);   // destination
    vpp.pPusher->push(4, (dwCurrYOffset << 16) | 0);   // current frame
    vpp.pPusher->push(5, (dwPrevYOffset << 16) | 0);   // previous frame
    
    vpp.pPusher->push(6, ((dwHeight+dwDestYOffset) << 16) | 0);
    vpp.pPusher->push(7, ((dwHeight+dwCurrYOffset) << 16) | 0);
    vpp.pPusher->push(8, ((dwHeight+dwPrevYOffset) << 16) | 0);
    
    vpp.pPusher->push(9, ((dwHeight+dwDestYOffset) << 16) | dwWidth);
    vpp.pPusher->push(10, ((dwHeight+dwCurrYOffset) << 16) | dwWidth);
    vpp.pPusher->push(11,  ((dwHeight+dwPrevYOffset) << 16) | dwWidth);
    
    vpp.pPusher->push(12, (+dwDestYOffset << 16) | dwWidth);
    vpp.pPusher->push(13, (+dwCurrYOffset << 16) | dwWidth);
    vpp.pPusher->push(14, (+dwPrevYOffset << 16) | dwWidth);
    vpp.pPusher->adjust(15);

    VppResetNotification(NULL, lpProcInfo->hTFilter3);  // TBD: need temporal filter notifier ptr

    vpp.pPusher->push(0, subchannel | NV097_NOTIFY | 0x40000);
    vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(2, subchannel | NV097_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(3, NV097_SET_BEGIN_END_OP_END);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);

    return TRUE;
}


//---------------------------------------------------------------------------
// vppNv10Temporal
//      Temporal filter for NV10.  Surface dimensions do not have to be a
//      power of 2.  Texture does not have to be swizzled.
LOCAL BOOL vppNv10Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                     DWORD dwSrcOffset, DWORD dwSrcPitch,
                     DWORD dwDstOffset, DWORD dwDstPitch,
                     DWORD dwWidth, DWORD dwHeight, DWORD dwFlags,
                     LPDWORD pPrevFrameOffset)
{
    DWORD dwMergeSize;
    BOOL isField, isOddField;
    DWORD dwCombineFactor;
    unsigned long vertexSizeContext;
    BOOL isPrevFieldOdd;
    int dwPrevYOffset, dwCurrYOffset, dwDestYOffset;
    Vpp_t &vpp = *pVpp;
    NvU32 subchannel = SUB_CHANNEL(vpp.threeDClassSubCh);

    nvAssert (NVARCH >= 0x10);

    isField = IS_FIELD(dwFlags);
    isOddField = isField && (dwFlags & VPP_ODD);
    isPrevFieldOdd = (*pPrevFrameOffset & 0x1);

    dwCombineFactor = (vpp.regOverlayMode >> 8) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    if (isField) {
        if (dwFlags & VPP_INTERLEAVED) {
            if (dwFlags & VPP_ODD) {
                dwSrcOffset += dwSrcPitch;
                dwDstOffset += dwDstPitch;
            }
            dwSrcPitch <<= 1;
            dwDstPitch <<= 1;
            dwHeight >>= 1;
        }
    }

    if (!(vpp.regOverlayMode & NV4_REG_OVL_MODE_NOTFIRST)) {
        // if first frame
        vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        if (isOddField) {
            // remember field polarity of previous frame
            *pPrevFrameOffset = dwSrcOffset | 0x1;
        } else {
            *pPrevFrameOffset = dwSrcOffset;
        }
        return FALSE;
    }


    // convert RGB16 to RGB32 width
    dwWidth >>= 1;

    dwMergeSize = (dwWidth << 16) | dwHeight;

    nvAssert(vpp.pThreeDClassLastUser);
    if (*vpp.pThreeDClassLastUser != MODULE_ID_DDRAW_VPP)
    {
        if (!vppInitCelsius(&vpp)) {
            return FALSE;
        }
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_SURFACE_CLIP_HORIZONTAL | 0x40000);
    vpp.pPusher->push(1, ((dwWidth << 16) | 0));

    vpp.pPusher->push(2, subchannel +
                   NV056_SET_SURFACE_CLIP_VERTICAL | 0x40000);
    vpp.pPusher->push(3, ((dwHeight << 16) | 0));
    vpp.pPusher->adjust(4);

    vpp.pPusher->push(0, subchannel | NV056_SET_SURFACE_PITCH | 0x40000);
    vpp.pPusher->push(1, (dwDstPitch << 16) | dwDstPitch);
    vpp.pPusher->adjust(2);

    // Load combination factors
    vpp.pPusher->push(0, subchannel | NV056_SET_COMBINE_FACTOR(0) | 0x80000);
    vpp.pPusher->push(1, dwCombineFactor);     // % of current field
    vpp.pPusher->push(2, dwCombineFactor);
    vpp.pPusher->adjust(3);

    vpp.pPusher->push(0, subchannel | NV056_SET_TEXTURE_OFFSET(0) | 0x80000);
    vpp.pPusher->push(1, dwSrcOffset);
    vpp.pPusher->push(2, *pPrevFrameOffset & ~0x1);
    vpp.pPusher->push(3, subchannel | NV056_SET_SURFACE_COLOR_OFFSET | 0x40000);
    vpp.pPusher->push(4, dwDstOffset);
    vpp.pPusher->adjust(5);
    if (isOddField) {
        // remember field polarity of previous frame
        *pPrevFrameOffset = dwSrcOffset | 0x1;
    } else {
        *pPrevFrameOffset = dwSrcOffset;
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_TEXTURE_IMAGE_RECT(0) | 0x80000);
    vpp.pPusher->push(1, dwMergeSize);
    vpp.pPusher->push(2, dwMergeSize);

    vpp.pPusher->push(3, subchannel | NV056_SET_TEXTURE_CONTROL1(0) | 0x80000);
    vpp.pPusher->push(4, dwSrcPitch << 16);
    vpp.pPusher->push(5, dwSrcPitch << 16);
    vpp.pPusher->adjust(6);

    vertexSizeContext = NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 | \
                        (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                        (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 8) | \
                        (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 12) | \
                        (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 16) | \
                        (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 20) | \
                        (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 24) | \
                        (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 28); \
    vpp.pPusher->push(0, subchannel | NV056_SET_INVERSE_MODEL_VIEW_MATRIX1(15) | 0x40000); \
    vpp.pPusher->push(1, vertexSizeContext); \
    vpp.pPusher->push(2, subchannel | NV056_SET_VERTEX_ARRAY_OFFSET | 0x400000); \
    vpp.pPusher->push(3, 0); \
    vpp.pPusher->push(4, (NV056_SET_VERTEX_ARRAY_FORMAT_W_NONE << 24) | \
                  (12 << 8) | \
                  (NV056_SET_VERTEX_ARRAY_FORMAT_SIZE_2 << 4) | \
                   NV056_SET_VERTEX_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(5, 0); \
    vpp.pPusher->push(6, (12 << 8) | \
                  (NV056_SET_DIFFUSE_ARRAY_FORMAT_SIZE_0 << 4) | \
                   NV056_SET_DIFFUSE_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
    vpp.pPusher->push(7, 0); \
    vpp.pPusher->push(8, (12 << 8) | \
                  (NV056_SET_SPECULAR_ARRAY_FORMAT_SIZE_0 << 4) | \
                   NV056_SET_SPECULAR_ARRAY_FORMAT_TYPE_UNSIGNED_BYTE_BGRA); \
    vpp.pPusher->push(9, 4); \
    vpp.pPusher->push(10, (12 << 8) | \
                  (NV056_SET_TEX_COORD0_ARRAY_FORMAT_SIZE_2 << 4) | \
                   NV056_SET_TEX_COORD0_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(11, 8); \
    vpp.pPusher->push(12, (12 << 8) | \
                   (NV056_SET_TEX_COORD1_ARRAY_FORMAT_SIZE_2 << 4) | \
                    NV056_SET_TEX_COORD1_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(13, 0); \
    vpp.pPusher->push(14, (12 << 8) | \
                   (NV056_SET_NORMAL_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_NORMAL_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(15, 0); \
    vpp.pPusher->push(16, (12 << 8) | \
                   (NV056_SET_WEIGHT_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_WEIGHT_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->push(17, 0); \
    vpp.pPusher->push(18, (12 << 8) | \
                   (NV056_SET_FOG_ARRAY_FORMAT_SIZE_0 << 4) | \
                    NV056_SET_FOG_ARRAY_FORMAT_TYPE_SHORT); \
    vpp.pPusher->adjust(19); \

    // specify height and width in 1/4 pixel units
    dwHeight <<= 2;
    dwWidth <<= 2;

    if (isField) {
        if (isOddField != isPrevFieldOdd) {
            // current field as opposite polarity as previous field
            if (dwFlags & VPP_ODD) {
                dwPrevYOffset = +1;
                dwCurrYOffset = -1;
                dwDestYOffset = -1;
            } else {
                dwPrevYOffset = -1;
                dwCurrYOffset = +1;
                dwDestYOffset = +1;
            }
        } else {
            // current field as identical polarity as previous field
            if (dwFlags & VPP_ODD) {
                // odd-odd
                dwPrevYOffset = -1;
                dwCurrYOffset = -1;
                dwDestYOffset = -1;
            } else {
                // even-even
                dwPrevYOffset = +1;
                dwCurrYOffset = +1;
                dwDestYOffset = +1;
            }
        }

    } else {    // weave
        dwPrevYOffset = 0;
        dwCurrYOffset = 0;
        dwDestYOffset = 0;
    }

    vpp.pPusher->push(0, subchannel | NV056_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(1, NV056_SET_BEGIN_END_OP_QUADS);
    vpp.pPusher->push(2, subchannel | NV056_INLINE_ARRAY(0) | 0x300000);

    vpp.pPusher->push(3, (dwPrevYOffset << 16) | 0);   // previous frame
    vpp.pPusher->push(4, (dwCurrYOffset << 16) | 0);   // current frame
    vpp.pPusher->push(5, (dwDestYOffset << 16) | 0);   // destination

    vpp.pPusher->push(6, ((dwHeight+dwPrevYOffset) << 16) | 0);
    vpp.pPusher->push(7, ((dwHeight+dwCurrYOffset) << 16) | 0);
    vpp.pPusher->push(8, ((dwHeight+dwDestYOffset) << 16) | 0);

    vpp.pPusher->push(9,  ((dwHeight+dwPrevYOffset) << 16) | dwWidth);
    vpp.pPusher->push(10, ((dwHeight+dwCurrYOffset) << 16) | dwWidth);
    vpp.pPusher->push(11, ((dwHeight+dwDestYOffset) << 16) | dwWidth);

    vpp.pPusher->push(12, (+dwPrevYOffset << 16) | dwWidth);
    vpp.pPusher->push(13, (+dwCurrYOffset << 16) | dwWidth);
    vpp.pPusher->push(14, (+dwDestYOffset << 16) | dwWidth);
    vpp.pPusher->adjust(15);

    VppResetNotification(NULL, lpProcInfo->hTFilter3);  // TBD: need temporal filter notifier ptr

    vpp.pPusher->push(0, subchannel | NV056_NOTIFY | 0x40000);
    vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
    vpp.pPusher->push(2, subchannel | NV056_SET_BEGIN_END | 0x40000);
    vpp.pPusher->push(3, NV056_SET_BEGIN_END_OP_END);
    vpp.pPusher->adjust(4);

    vpp.pPusher->start(TRUE);
    return TRUE;
}

//---------------------------------------------------------------------------
// vppNv5Temporal
//      Temporal filter for NV5.  Surface dimensions must be a power of 2.
//      Previous frame must be swizzled.
LOCAL BOOL vppNv5Temporal(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
                    DWORD dwSrcOffset, DWORD dwSrcPitch,
                    DWORD dwDstOffset, DWORD dwDstPitch,
                    DWORD dwWidth, DWORD dwHeight,
                    LPDWORD pPrevFrameOffset)
{
    DWORD dwLogWidth, dwLogHeight, dwPixWidth, dwLineHeight;
    DWORD dwOffsetA, dwOffsetB;
    NvF32 fWidth, fHeight, fU, fV;
    DWORD dwMergeSize;
    DWORD dwCombineFactor;
    Vpp_t &vpp = *pVpp;
    const NvU32 subchannel = SUB_CHANNEL(vpp.spareSubCh);

    // we shouldn't have a celsius or kelvin class if we're here
    nvAssert(!(vpp.dwFlags & (VPP_FLAG_KELVIN_3D | VPP_FLAG_CELSIUS_3D)));

    dwPixWidth = dwSrcPitch >> 2;
    if (dwPixWidth > 4096)      dwLogWidth = 13;
    else if (dwPixWidth > 2048) dwLogWidth = 12;
    else if (dwPixWidth > 1024) dwLogWidth = 11;
    else if (dwPixWidth > 512)  dwLogWidth = 10;
    else if (dwPixWidth > 256)  dwLogWidth = 9;
    else if (dwPixWidth > 128)  dwLogWidth = 8;
    else if (dwPixWidth > 64)   dwLogWidth = 7;
    else if (dwPixWidth > 32)   dwLogWidth = 6;
    else                        dwLogWidth = 5;

    if (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) {
        dwLineHeight = max(dwHeight, vpp.dwOverlayDstHeight);
    } else {
        dwLineHeight = dwHeight;
    }
    if (dwLineHeight > 4096)      dwLogHeight = 13;
    else if (dwLineHeight > 2048) dwLogHeight = 12;
    else if (dwLineHeight > 1024) dwLogHeight = 11;
    else if (dwLineHeight > 512)  dwLogHeight = 10;
    else if (dwLineHeight > 256)  dwLogHeight = 9;
    else if (dwLineHeight > 128)  dwLogHeight = 8;
    else if (dwLineHeight > 64)   dwLogHeight = 7;
    else if (dwLineHeight > 32)   dwLogHeight = 6;
    else if (dwLineHeight > 16)   dwLogHeight = 5;
    else if (dwLineHeight > 8)    dwLogHeight = 4;
    else if (dwLineHeight > 4)    dwLogHeight = 3;
    else if (dwLineHeight > 2)    dwLogHeight = 2;
    else                          dwLogHeight = 1;

//    _asm {emms};
    fWidth  = (NvF32) (dwWidth >> 1);
    fHeight = (NvF32) dwLineHeight;
    fU = fWidth  / (1 << dwLogWidth);
    fV = fHeight / (1 << dwLogHeight);

    dwCombineFactor = (vpp.regOverlayMode >> 8) & 0xFF;
    dwCombineFactor |= (dwCombineFactor << 8);
    dwCombineFactor |= (dwCombineFactor << 16);

    dwMergeSize = (dwLineHeight << 16) | (dwWidth >> 1);

    // swizzle (used in next pass)
    vpp.pPusher->push(0, subchannel | 0x40000);
    vpp.pPusher->push(1, vpp.hContextSurfaceSwizzled);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV052_SET_FORMAT | 0x80000);
    vpp.pPusher->push(3, NV052_SET_FORMAT_COLOR_LE_A8R8G8B8 |  // SetFormat
                  (dwLogWidth << 16) |
                  (dwLogHeight << 24));
    vpp.pPusher->push(4, dwDstOffset);                         // SetOffset
    vpp.pPusher->adjust(5);

    vpp.pPusher->push(0, subchannel | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[SWIZZLE_NDX].classIID);
    vpp.pPusher->push(2, subchannel | NV077_CLIP_POINT | 0x180000);
    vpp.pPusher->push(3, 0);                               // ClipPoint
    vpp.pPusher->push(4, dwMergeSize);                     // ClipSize
    vpp.pPusher->push(5, 0);                               // ImageOutPoint
    vpp.pPusher->push(6, dwMergeSize);                     // ImageOutSize
    vpp.pPusher->push(7, 1 << 20);                         // DeltaDuDx
    vpp.pPusher->push(8, 1 << 20);                         // DeltaDvDy
    vpp.pPusher->push(9, subchannel | NV077_IMAGE_IN_SIZE | 0x100000);
    vpp.pPusher->push(10, (dwMergeSize + 1) & ~1);         // ImageInSize
    vpp.pPusher->push(11, (dwSrcPitch) |                   // ImageInFormat
                   (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16) |
                   (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24));
    vpp.pPusher->push(12, dwSrcOffset);                    // ImageInOffset
    vpp.pPusher->push(13, 0);                              // ImageInPoint
    vpp.pPusher->adjust(14);
    vpp.pPusher->start(TRUE);

    // offset A is current frame multiplied by factor
    // offset B is previous frame swizzled
    dwOffsetA = dwSrcOffset;
    dwOffsetB = *pPrevFrameOffset;
    *pPrevFrameOffset = dwDstOffset;

    // only do this part if this is not the first frame
    if (vpp.regOverlayMode & NV4_REG_OVL_MODE_NOTFIRST) {
        DWORD i;
        Tlmtvertex vertex[4] = {
            { 0.0f,   0.0f,    0.0f, 1.0f, 0xFFFFFFFF, 0xFFFFFFFF, 0.0f, 0.0f, 0.0f, 0.0f},
            { 0.0f,   fHeight, 0.0f, 1.0f, 0xFFFFFFFF, 0xFFFFFFFF, 0.0f, fV,   0.0f, fV},
            { fWidth, 0.0f,    0.0f, 1.0f, 0xFFFFFFFF, 0xFFFFFFFF, fU,   0.0f, fU,   0.0f},
            { fWidth, fHeight, 0.0f, 1.0f, 0xFFFFFFFF, 0xFFFFFFFF, fU,   fV,   fU,   fV}
        };

        // multiply current frame with factor, in place
        vpp.pPusher->push(0, subchannel | 0x40000);
        vpp.pPusher->push(1, vpp.hContextBeta4);
        vpp.pPusher->push(2, subchannel | BETA4_SET_BETA_FACTOR_OFFSET | 0x40000);
        vpp.pPusher->push(3, dwCombineFactor);

        vpp.pPusher->push(4, subchannel | 0x40000);
        vpp.pPusher->push(5, vpp.hSurfaces2D);
        vpp.pPusher->push(6, subchannel | SURFACES_2D_PITCH_OFFSET | 0xC0000);
        vpp.pPusher->push(7, (dwSrcPitch << 16) | dwSrcPitch);     // set pitch
        vpp.pPusher->push(8, dwSrcOffset);                         // set offset source
        vpp.pPusher->push(9, dwSrcOffset);                         // set offset destin
        vpp.pDriverData->bltData.dwLastCombinedPitch = (dwSrcPitch << 16) | dwSrcPitch;
        vpp.pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
        vpp.pDriverData->bltData.dwLastDstOffset = dwSrcOffset;

        vpp.pPusher->push(10, subchannel | 0x40000);
        vpp.pPusher->push(11, vpp.m_obj_a[ALPHA_BLT_NDX].classIID);
        vpp.pPusher->push(12, subchannel | BLIT_POINT_IN_OFFSET | 0xC0000);
        vpp.pPusher->push(13, 0);                                  // control point in
        vpp.pPusher->push(14, 0);                                  // control point out
        vpp.pPusher->push(15, dwMergeSize);                        // size
        vpp.pPusher->adjust(16);
        vpp.pPusher->start(TRUE);

        vpp.pPusher->push(0, subchannel | 0x40000);
        vpp.pPusher->push(1, vpp.hContextSurfacesARGB_ZS);
        vpp.pPusher->push(2, subchannel | NV053_SET_FORMAT | 0x80000);
        vpp.pPusher->push(3, NV053_SET_FORMAT_COLOR_LE_A8R8G8B8 |          // SetFormat
                     (NV053_SET_FORMAT_TYPE_PITCH << 8) |
                     (dwLogWidth << 16) |
                     (dwLogHeight << 24));
        vpp.pPusher->push(4, dwMergeSize);                                 // SetClipSize
        vpp.pPusher->push(5, subchannel | NV053_SET_PITCH | 0x80000);
        vpp.pPusher->push(6, ((dwSrcPitch) << 16) | (dwSrcPitch));         // SetPitch
        vpp.pPusher->push(7, dwSrcOffset);                                 // SetOffsetColor
        vpp.pPusher->adjust(8);

        vpp.pPusher->push(0, subchannel | 0x40000);
        vpp.pPusher->push(1, vpp.hDX6MultiTextureTriangle);
        vpp.pPusher->push(2, subchannel | NV055_SET_CONTEXT_DMA_NOTIFIES | 0x100000);
        vpp.pPusher->push(3, vpp.hMiscEventNotifier);     // SetContextDmaNotifies
        vpp.pPusher->push(4, vpp.hInVideoMemContextDma);       // SetContextDmaA
        vpp.pPusher->push(5, vpp.hInVideoMemContextDma);       // SetContextDmaB
        vpp.pPusher->push(6, vpp.hContextSurfacesARGB_ZS);                // SetContextSurfaces
        vpp.pPusher->adjust(7);

        // add current frame with previous frame (multiplied by [1-factor]) in place
        // not using texture unit 0, but need to set everything anyways otherwise RM generates error and doesn't do it
        vpp.pPusher->push(0, subchannel | 0x40000);
        vpp.pPusher->push(1, vpp.hDX6MultiTextureTriangle);
        vpp.pPusher->push(2, subchannel | NV055_OFFSET(0) | 0x200000);
        vpp.pPusher->push(3, dwOffsetA);                                   // Offset(0)
        vpp.pPusher->push(4, dwOffsetB);                                   // Offset(1)
        vpp.pPusher->push(5, NV055_FORMAT_CONTEXT_DMA_A |                  // Format(0)
                      (NV055_FORMAT_ORIGIN_ZOH_CENTER << 4) |
                      (NV055_FORMAT_ORIGIN_FOH_CENTER << 6) |
                      (NV055_FORMAT_COLOR_LE_A8R8G8B8 << 8) |
                      (1 << 12) |
                      (dwLogWidth << 16) |
                      (dwLogHeight << 20) |
                      (NV055_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                      (NV055_FORMAT_WRAPU_FALSE << 27) |
                      (NV055_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                      (NV055_FORMAT_WRAPV_FALSE << 31));
        vpp.pPusher->push(6, NV055_FORMAT_CONTEXT_DMA_B |                  // Format(1)
                      (NV055_FORMAT_ORIGIN_ZOH_CENTER << 4) |
                      (NV055_FORMAT_ORIGIN_FOH_CENTER << 6) |
                      (NV055_FORMAT_COLOR_LE_A8R8G8B8 << 8) |
                      (1 << 12) |
                      (dwLogWidth << 16) |
                      (dwLogHeight << 20) |
                      (NV055_FORMAT_TEXTUREADDRESSU_CLAMP << 24) |
                      (NV055_FORMAT_WRAPU_FALSE << 27) |
                      (NV055_FORMAT_TEXTUREADDRESSV_CLAMP << 28) |
                      (NV055_FORMAT_WRAPV_FALSE << 31));
        vpp.pPusher->push(7, (1 << 4) |                                    // Filter(0)
                      (NV055_FILTER_MIPMAP_DITHER_ENABLE_FALSE << 15) |
                      (NV055_FILTER_TEXTUREMIN_NEAREST << 24) |
                      (NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE << 27) |
                      (NV055_FILTER_TEXTUREMAG_NEAREST << 28) |
                      (NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE << 31));
        vpp.pPusher->push(8, (1 << 4) |                                    // Filter(1)
                      (NV055_FILTER_MIPMAP_DITHER_ENABLE_FALSE << 15) |
                      (NV055_FILTER_TEXTUREMIN_NEAREST << 24) |
                      (NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE << 27) |
                      (NV055_FILTER_TEXTUREMAG_NEAREST << 28) |
                      (NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE << 31));
        vpp.pPusher->push(9, NV055_COMBINE_0_ALPHA_INVERSE_0_NORMAL |      // Combine0Alpha
                      (NV055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO << 2) |
                      (NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL << 8) |
                      (NV055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO << 10) |
                      (NV055_COMBINE_0_ALPHA_INVERSE_2_NORMAL << 16) |
                      (NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1 << 18) |
                      (NV055_COMBINE_0_ALPHA_INVERSE_3_INVERSE << 24) |
                      (NV055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO << 26) |
                      (NV055_COMBINE_0_ALPHA_OPERATION_ADD << 29));
        vpp.pPusher->push(10, NV055_COMBINE_0_COLOR_INVERSE_0_NORMAL |     // Combine0Color
                       (NV055_COMBINE_0_COLOR_ALPHA_0_COLOR << 1) |
                       (NV055_COMBINE_0_COLOR_ARGUMENT_0_ZERO << 2) |
                       (NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL << 8) |
                       (NV055_COMBINE_0_COLOR_ALPHA_1_COLOR << 9) |
                       (NV055_COMBINE_0_COLOR_ARGUMENT_1_ZERO << 10) |
                       (NV055_COMBINE_0_COLOR_INVERSE_2_NORMAL << 16) |
                       (NV055_COMBINE_0_COLOR_ALPHA_2_COLOR << 17) |
                       (NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1 << 18) |
                       (NV055_COMBINE_0_COLOR_INVERSE_3_INVERSE << 24) |
                       (NV055_COMBINE_0_COLOR_ALPHA_3_COLOR << 25) |
                       (NV055_COMBINE_0_COLOR_ARGUMENT_3_ZERO << 26) |
                       (NV055_COMBINE_0_COLOR_OPERATION_ADD << 29));

        vpp.pPusher->push(11, subchannel | NV055_COMBINE_1_ALPHA | 0x200000);
        vpp.pPusher->push(12, NV055_COMBINE_1_ALPHA_INVERSE_0_NORMAL |     // Combine1Alpha
                       (NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1 << 2) |
                       (NV055_COMBINE_1_ALPHA_INVERSE_1_INVERSE << 8) |
                       (NV055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR << 10) |
                       (NV055_COMBINE_1_ALPHA_INVERSE_2_NORMAL << 16) |
                       (NV055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO << 18) |
                       (NV055_COMBINE_1_ALPHA_INVERSE_3_NORMAL << 24) |
                       (NV055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO << 26) |
                       (NV055_COMBINE_1_ALPHA_OPERATION_ADD << 29));
        vpp.pPusher->push(13, NV055_COMBINE_1_COLOR_INVERSE_0_NORMAL |     // Combine1Color
                       (NV055_COMBINE_1_COLOR_ALPHA_0_COLOR << 1) |
                       (NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1 << 2) |
                       (NV055_COMBINE_1_COLOR_INVERSE_1_INVERSE << 8) |
                       (NV055_COMBINE_1_COLOR_ALPHA_1_COLOR << 9) |
                       (NV055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR << 10) |
                       (NV055_COMBINE_1_COLOR_INVERSE_2_NORMAL << 16) |
                       (NV055_COMBINE_1_COLOR_ALPHA_2_COLOR << 17) |
                       (NV055_COMBINE_1_COLOR_ARGUMENT_2_ZERO << 18) |
                       (NV055_COMBINE_1_COLOR_INVERSE_3_NORMAL << 24) |
                       (NV055_COMBINE_1_COLOR_ALPHA_3_COLOR << 25) |
                       (NV055_COMBINE_1_COLOR_ARGUMENT_3_ZERO << 26) |
                       (NV055_COMBINE_1_COLOR_OPERATION_ADD << 29));
        vpp.pPusher->push(14, dwCombineFactor);                            // CombineFactor
        vpp.pPusher->push(15, NV055_BLEND_MASK_BIT_LSB |                   // Blend
                       (NV055_BLEND_SHADEMODE_FLAT << 6) |
                       (NV055_BLEND_TEXTUREPERSPECTIVE_FALSE << 8) |
                       (NV055_BLEND_SPECULARENABLE_FALSE << 12) |
                       (NV055_BLEND_FOGENABLE_FALSE << 16) |
                       (NV055_BLEND_ALPHABLENDENABLE_TRUE << 20) |
                       (NV055_BLEND_SRCBLEND_ONE << 24) |
                       (NV055_BLEND_DESTBLEND_ONE << 28));
        vpp.pPusher->push(16, (NV055_CONTROL0_ALPHAFUNC_ALWAYS << 8) |     // Control0
                       (NV055_CONTROL0_ALPHATESTENABLE_FALSE << 12) |
                       (NV055_CONTROL0_ORIGIN_CENTER << 13) |
                       (NV055_CONTROL0_ZENABLE_FALSE << 14) |
                       (NV055_CONTROL0_ZFUNC_ALWAYS << 16) |
                       (NV055_CONTROL0_CULLMODE_NONE << 20) |
                       (NV055_CONTROL0_DITHERENABLE_FALSE << 22) |
                       (NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE << 23) |
                       (NV055_CONTROL0_ZWRITEENABLE_FALSE << 24) |
                       (NV055_CONTROL0_STENCIL_WRITE_ENABLE_FALSE << 25) |
                       (NV055_CONTROL0_ALPHA_WRITE_ENABLE_TRUE << 26) |
                       (NV055_CONTROL0_RED_WRITE_ENABLE_TRUE << 27) |
                       (NV055_CONTROL0_GREEN_WRITE_ENABLE_TRUE << 28) |
                       (NV055_CONTROL0_BLUE_WRITE_ENABLE_TRUE << 29) |
                       (NV055_CONTROL0_Z_FORMAT_FLOAT << 30));
        vpp.pPusher->push(17, NV055_CONTROL1_STENCIL_TEST_ENABLE_FALSE |   // Control1
                       (NV055_CONTROL1_STENCIL_FUNC_NEVER << 4));
        vpp.pPusher->push(18, NV055_CONTROL2_STENCIL_OP_FAIL_KEEP |        // Control2
                       (NV055_CONTROL2_STENCIL_OP_ZFAIL_KEEP << 4) |
                       (NV055_CONTROL2_STENCIL_OP_ZPASS_KEEP << 8));
        vpp.pPusher->push(19, 0);                                          // FogColor

        vpp.pPusher->push(20, subchannel | NV055_TLMTVERTEX(0) | 0xa00000);
        for (i=0; i<40; i++) {
            vpp.pPusher->push(21+i, ((DWORD *)(&vertex[0]))[i]);
        }
        vpp.pPusher->adjust(61);
        vpp.pPusher->start(TRUE);

        VppResetNotification(NULL, lpProcInfo->hTFilter3);  // TBD: need temporal filter notifier ptr

        vpp.pPusher->push(0, subchannel | NV055_NOTIFY | 0x40000);
        vpp.pPusher->push(1, VPP_NOTIFY_TYPE);
        vpp.pPusher->push(2, subchannel | NV055_DRAW_PRIMITIVE(0) | 0x40000);
        vpp.pPusher->push(3, 0 | (1 << 4) | (2 << 8) | (1 << 12) | (2 << 16) | (3 << 20));
        vpp.pPusher->adjust(4);
        vpp.pPusher->start(TRUE);

        vpp.pDriverData->dDrawSpareSubchannelObject = 0;
        vpp.pDriverData->TwoDRenderingOccurred = 1;
    } else {
        // this was the first frame, next time it won't be
        vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        return FALSE;
    }

    return TRUE;
}

//---------------------------------------------------------------------------
// vppFlip
//      Flip to surface.  Use the PIO channel in case we do a raw flip with
//      a bunch of 3D going on.
//
LOCAL BOOL vppFlip(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo,
             DWORD dwOffset, DWORD dwPitch, DWORD dwWidth, DWORD dwHeight,
             DWORD dwIndex, DWORD dwFourCC, DWORD dwFlags,
             DWORD dwPrescaleFactorX, DWORD dwPrescaleFactorY)
{
    DWORD dwPointIn, dwSizeIn, dwOverlayFormat;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwDstX, dwDstY, dwDstWidth, dwDstHeight;
    BOOL doYBiasing;
    Vpp_t &vpp = *pVpp;

    // Remember this in case we get a SetOverlayPosition call
    vpp.dwOverlaySrcOffset = dwOffset;
    vpp.dwOverlaySrcPitch = dwPitch;

    dwDeltaX    = vpp.dwOverlayDeltaX;
    dwDeltaY    = vpp.dwOverlayDeltaY;
    dwDstX      = vpp.dwOverlayDstX;
    dwDstY      = vpp.dwOverlayDstY;
    dwDstWidth  = vpp.dwOverlayDstWidth;
    dwDstHeight = vpp.dwOverlayDstHeight;

    if (vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK) {
        // zoom
        DWORD dwSrcX         = (vpp.dwOverlayFSSrcMinX * dwPrescaleFactorX) >> 20;
        DWORD dwSrcY         = (vpp.dwOverlayFSSrcMinY * dwPrescaleFactorY) >> 20;
        DWORD dwSrcWidth     = (vpp.dwOverlayFSSrcWidth * dwPrescaleFactorX) >> 20;
        DWORD dwSrcHeight    = (vpp.dwOverlayFSSrcHeight * dwPrescaleFactorY) >> 20;
        DWORD dwZoomFactor   = 384 - ((vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMFACTORMASK) >> 12);
        DWORD dwZoomQuad     = (vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK) >> 8;
        DWORD dwNewSrcWidth  = dwSrcWidth  * dwZoomFactor / 384;
        DWORD dwNewSrcHeight = dwSrcHeight * dwZoomFactor / 384;

        // get start point
        switch (dwZoomQuad) {
        case 1:  break;
        case 2:  dwSrcX += dwWidth - dwNewSrcWidth;          break;
        case 3:  dwSrcY += dwHeight - dwNewSrcHeight;        break;
        case 4:  dwSrcX += dwWidth - dwNewSrcWidth;
                 dwSrcY += dwHeight - dwNewSrcHeight;        break;
        case 5:  dwSrcX += (dwWidth - dwNewSrcWidth) >> 1;
                 dwSrcY += (dwHeight - dwNewSrcHeight) >> 1; break;
        default: break;
        }
        dwWidth = dwNewSrcWidth;
        dwHeight = dwNewSrcHeight;

        // if DX clips the source, we need to adjust our new source rectangle to match
        if (vpp.dwOverlaySrcWidth < dwSrcWidth) {
            DWORD xScale = (vpp.dwOverlaySrcWidth << 20) / dwSrcWidth;
            DWORD xRelative = vpp.dwOverlaySrcX - ((vpp.dwOverlayFSSrcMinX * dwPrescaleFactorX) >> 20);
            DWORD xPos   = (xRelative << 20) / dwSrcWidth;
            dwSrcX += (dwWidth * xPos) >> 20;
            dwWidth = (dwWidth * xScale) >> 20;
        }
        if (vpp.dwOverlaySrcHeight < dwSrcHeight) {
            DWORD yScale = (vpp.dwOverlaySrcHeight << 20) / dwSrcHeight;
            DWORD yRelative = vpp.dwOverlaySrcY - ((vpp.dwOverlayFSSrcMinY * dwPrescaleFactorY) >> 20);
            DWORD yPos   = (yRelative << 20) / dwSrcHeight;
            dwSrcY += (dwHeight * yPos) >> 20;
            dwHeight = (dwHeight * yScale) >> 20;
        }

        // calculate new source offset
        dwOffset += (dwSrcY * dwPitch) + (dwSrcX * 2);

        // recompute new scale factors
        dwDeltaX = ((dwWidth - 1) << 20) / (vpp.dwOverlayDstWidth - 1);
        dwDeltaY = ((dwHeight - 1) << 20) / (vpp.dwOverlayDstHeight - 1);
    }

    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;
    dwSizeIn = asmMergeCoords((dwWidth & ~1), dwHeight);
    dwSizeIn += dwPointIn >> 4;
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    // if downscaling in Y, throw in a Y bias of -1/2 pixel
    // don't do this on NV5 class chips because it doesn't properly bias it
    doYBiasing = (dwDeltaY > 0x100000 && vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10);
    if (doYBiasing) {
        dwPointIn -= 0x00080000;
    }

    if (IS_FIELD(dwFlags)) {
        // Set flag to say overlay has been in Bob mode.
        vpp.pDriverData->dwDXVAFlags |= DXVA_OVERLAY_WAS_BOBBED;

        if (dwFlags & VPP_INTERLEAVED) {
            if (dwFlags & VPP_ODD) {
                dwOffset += dwPitch;
            }
            dwPitch <<= 1;
            dwHeight >>= 1;
            dwDeltaY = ((dwHeight) << 20) / (vpp.dwOverlayDstHeight);
            dwSizeIn = (dwSizeIn & 0x0000FFFF) | (dwHeight << 16);
        }
        if (dwFlags & VPP_BOB) {
            if (dwFlags & VPP_ODD) {
                if (doYBiasing) {
                    dwPointIn += 0x00040000;
                } else {
                    dwPointIn += 0xFFFC0000;
                }
            } else {
                if (doYBiasing) {
                    dwPointIn += 0x000C0000;
                } else {
                    dwPointIn += 0x00040000;
                }
            }
        }
    }

    // replace old surface pitch value with current pitch value
    dwOverlayFormat = vpp.dwOverlayFormat;
    dwOverlayFormat &= 0xFFFF0000;
    dwOverlayFormat |= dwPitch;
    dwOverlayFormat |= (VPP_NOTIFY_TYPE << 31);

    // reset notifiers
    //   Must clear notifier status even if we're using events.
    if (dwIndex & 0x1) {
        VppResetNotification(&vpp.m_obj_a[OVERLAY_NDX].notifier_a[2], lpProcInfo->hOvlFlipOddEvent3);
        vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status = NV_IN_PROGRESS;
    } else {
        VppResetNotification(&vpp.m_obj_a[OVERLAY_NDX].notifier_a[1], lpProcInfo->hOvlFlipEvenEvent3);
        vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status = NV_IN_PROGRESS;
    }

    // frame delivery control
    if (vpp.llDeliveryPeriod != 0)
    {
        VppResetNotification(vpp.m_obj_a[TIMER_NDX].notifier_a, lpProcInfo->hTimer3);
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.m_obj_a[TIMER_NDX].classIID);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_TIME | 0x80000);
        vpp.pPusher->push(3, (DWORD)(vpp.llDeliveryTime & 0x00000000FFFFFFFF));
        vpp.pPusher->push(4, (DWORD)(vpp.llDeliveryTime >> 32));
        vpp.pPusher->push(5, SUB_CHANNEL(vpp.spareSubCh) | NV004_SET_ALARM_NOTIFY | 0x40000);
        vpp.pPusher->push(6, VPP_NOTIFY_TYPE);
        vpp.pPusher->adjust(7);
        vpp.pPusher->start(TRUE);
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[TIMER_NDX].classIID;
        vpp.llDeliveryTime += vpp.llDeliveryPeriod;
        if (VppWaitForNotification(NULL, lpProcInfo->hTimer3, VPP_TIMEOUT_TIME * 4)) {
            DPF(" *** TIMER event failure ***");
            EVENT_ERROR;
        }
    }

    // HWFIX: NV20 overlay bug, if scale factor >= 0.5 && XPointIn >= 9.4375 then this must be FALSE:
    //        ((XSizeIn - 2) & 0x8) == 0x8
    // This code must not go through on NV < 20
    if ((vpp.pDriverData->NvDeviceVersion > NV_DEVICE_VERSION_10) &&
     ((((dwSizeIn & 0x0000FFFF) - 2) >> 3) & 0x1) &&
       ((dwPointIn & 0x0000FFFF) >= 0x97)) {
        // muck with source width so HWBUG does not happen
        dwSizeIn = (dwSizeIn & 0xFFFF0000) | ((dwSizeIn & 0x0000FFFF) + 8);
        // now muck with dwDeltaX so we don't see 1/2 pixel of crap on the right edge
        dwDeltaX -= (1 << 20) / ((dwSizeIn & 0xFFFF) * 3 / 2);  // should accumulate to 2/3 pixel over the span of the source
    }

    // do the overlay flip
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.m_obj_a[OVERLAY_NDX].classIID);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_OVERLAY_COLORKEY(dwIndex) | 0x240000);
    vpp.pPusher->push(3, vpp.dwOverlayColorKey);                    // SetOverlayColorKey
    vpp.pPusher->push(4, dwOffset);                                        // SetOverlayOffset
    vpp.pPusher->push(5, dwSizeIn);                                        // SetOverlaySizeIn
    vpp.pPusher->push(6, dwPointIn);                                       // SetOverlayPointIn
    vpp.pPusher->push(7, dwDeltaX);                                        // SetOverlayDuDx
    vpp.pPusher->push(8, dwDeltaY);                                        // SetOverlayDvDy
    vpp.pPusher->push(9, asmMergeCoords(dwDstX, dwDstY));                  // SetOverlayPointOut
    vpp.pPusher->push(10, asmMergeCoords(dwDstWidth, dwDstHeight));        // SetOverlaySizeOut
    vpp.pPusher->push(11, dwOverlayFormat);                                // SetOverlayFormat
    vpp.pPusher->adjust(12);
    vpp.pPusher->start(TRUE);
    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.m_obj_a[OVERLAY_NDX].classIID;

    return TRUE;
}

//---------------------------------------------------------------------------
// vppFSFlip
//      Flip full screen mirrored adapter
LOCAL BOOL vppFSFlip(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex)
{
    DWORD dwDAC, dwLUTFormat;
    Vpp_t &vpp = *pVpp;

#ifndef WINNT
    if (pVpp->dwOverlayFSTwinData.nvtwPhysicalModeImmediate.pHWCrtcCX == 0) {
        // ack! user has suddenly switched from clone mode to multimon
//        Sleep(VPP_TIMEOUT_TIME * 3);                // make sure all flips are flushed
        VppDestroyFSMirror(pVpp);
//        VppDestroyOverlay(pVpp);

        ResetTwinViewState (vpp.pDriverData);

        // special flag to indicate new display driver coming up
        pVpp->dwOverlayFSHead = 0xFFFFFFFE;

        // turn off mode setting bit to minimize impact of turning on FSmirror in the middle of a TwinView change
        vpp.regOverlayMode2 &= ~NV4_REG_OVL_MODE2_FSSETMODE;
        return TRUE;

//        VppCreateOverlay(pVpp);
//        VppCreateFSMirror(pVpp, pDriverData->dwOverlayFSSrcWidth, pDriverData->dwOverlayFSSrcHeight);
    }
#endif

    if (vpp.dwOverlayFSHead == 0) {
        dwDAC = vpp.hLutCursorDacBase;
        if (dwIndex & 0x1) {
            VppResetNotification(NULL, lpProcInfo->hPrimary0FlipOdd3);
            vpp.pFlipPrimaryNotifier[2].status = NV_IN_PROGRESS;
        } else {
            VppResetNotification(NULL, lpProcInfo->hPrimary0FlipEven3);
            vpp.pFlipPrimaryNotifier[1].status = NV_IN_PROGRESS;
        }
    } else {
        dwDAC = vpp.hLutCursorDacBase + 1;
        if (dwIndex & 0x1) {
            VppResetNotification(NULL, lpProcInfo->hPrimary1FlipOdd3);
            vpp.pFlipPrimaryNotifier[2].status = NV_IN_PROGRESS;
        } else {
            VppResetNotification(NULL, lpProcInfo->hPrimary1FlipEven3);
            vpp.pFlipPrimaryNotifier[1].status = NV_IN_PROGRESS;
        }
    }

    dwLUTFormat = vpp.dwOverlayFSPitch |
                 (VPP_NOTIFY_TYPE << 31) |
                 (NV067_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20);

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, dwDAC);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV067_SET_IMAGE_OFFSET(dwIndex) | 0x80000);
    vpp.pPusher->push(3, vpp.dwOverlayFSOffset[vpp.dwOverlayFSIndex]);   // SetImage[i].offset
    vpp.pPusher->push(4, dwLUTFormat);                                                     // SetImage[i].format
    vpp.pPusher->adjust(5);
    vpp.pPusher->start(TRUE);
    vpp.pDriverData->dDrawSpareSubchannelObject = dwDAC;

    return TRUE;
}


//---------------------------------------------------------------------------
// vppSetSurfacesState
//      Sets the pixel format on all the surfaces we will use for video
//      post processing

LOCAL void vppSetSurfacesState(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;
    vpp.pDriverData->dwSharedClipChangeCount++;

    // set surfaces state

    // SURFACES_3D
    if (!(vpp.dwFlags & (VPP_FLAG_CELSIUS_3D | VPP_FLAG_KELVIN_3D))) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextSurfacesARGB_ZS);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV053_SET_FORMAT | 0x80000);
        vpp.pPusher->push(3, NV053_SET_FORMAT_COLOR_LE_A8R8G8B8 |      // SetFormat
                     (NV053_SET_FORMAT_TYPE_PITCH << 8) |
                     (9 << 16) |
                     (10 << 24));
        vpp.pPusher->push(4, (2048 << 16) | 512);                      // SetClipSize
        vpp.pPusher->adjust(5);
    }

    // SURFACES_2D
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(1, vpp.hSurfaces2D);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000);
    vpp.pPusher->push(3, NV042_SET_COLOR_FORMAT_LE_A8R8G8B8);      // SetColorFormat

    // SURFACE_SWIZZLED
    vpp.pPusher->push(4, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
    vpp.pPusher->push(5, vpp.hContextSurfaceSwizzled);
    vpp.pPusher->push(6, SUB_CHANNEL(vpp.spareSubCh) | NV052_SET_FORMAT | 0x40000);
    vpp.pPusher->push(7, NV052_SET_FORMAT_COLOR_LE_A8R8G8B8 |     // SetFormat
                 (9 << 16) |
                 (10 << 24));

    vpp.pPusher->adjust(8);

    vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hContextSurfaceSwizzled;
    vpp.pDriverData->bltData.dwLastColourFormat = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
    vpp.pDriverData->TwoDRenderingOccurred = TRUE;
}

//---------------------------------------------------------------------------
// vppRestoreSurfacesState
//      Restores surfaces to default state.  Swizzled surface state is not
//      restored, D3D sets it before using it all the time

LOCAL void vppRestoreSurfacesState(Vpp_t *pVpp)
{
    DWORD dw2dFormat;
    Vpp_t &vpp = *pVpp;

    // restore surfaces2d
    switch (GET_MODE_BPP()) {
    case 8:
        dw2dFormat = NV062_SET_COLOR_FORMAT_LE_Y8;
        break;
    case 32:
        dw2dFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
        break;
    default:
        dw2dFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;
        break;
    }
    vpp.pPusher->push(0, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x40000);
    vpp.pPusher->push(1, dw2dFormat);
    vpp.pPusher->adjust(2);

    vpp.pDriverData->bltData.dwLastColourFormat = dw2dFormat;

    vpp.pPusher->start(TRUE);
}

//---------------------------------------------------------------------------
// vppFlipSync
//      Flushes out overlay flips.  Returns true if succeeded

LOCAL BOOL vppFlipSync(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex, BOOL bWait)
{
    HDRVEVENT hEvent;
    __int64 timeNow = 0x7FFFFFFFFFFFFFFF;
    static DWORD dwRetryCount = 0;
    Vpp_t &vpp = *pVpp;

    if (dwIndex) {
        hEvent = lpProcInfo->hOvlFlipOddEvent3;
    } else {
        hEvent = lpProcInfo->hOvlFlipEvenEvent3;
    }

    if (bWait) {
        // if (IS_EVENT_ERROR(WaitForSingleObject(hEvent, VPP_TIMEOUT_TIME))) {
        if (VppWaitForNotification(&(vpp.m_obj_a[OVERLAY_NDX].notifier_a[dwIndex+1]), hEvent, VPP_TIMEOUT_TIME)) {
            // NV11 mobile workaround, sometimes overlay flips are getting lost for unknown reasons
            // check to see if enough time has passed to guarantee this flip has flushed out
            static DWORD dwRetryCount = 0;
            if (dwRetryCount == 0) {
                nvQueryPerformanceCounter(&timeNow);
                if ((timeNow - vpp.pDriverData->flipOverlayRecord.llPreviousFlipTime) >= (vpp.pDriverData->flipPrimaryRecord.dwFlipDuration * 4)) {
                    dwRetryCount++;
                    return TRUE;
                }
            } else {
                dwRetryCount = 0;
            }
            // otherwise this is a real failure
            DPF(" *** OVERLAY FLIP event failure ***");
            EVENT_ERROR;
            vpp.m_obj_a[OVERLAY_NDX].notifier_a[1].status = 0;
            vpp.m_obj_a[OVERLAY_NDX].notifier_a[2].status = 0;
        }
    } else {
        if (vpp.m_obj_a[OVERLAY_NDX].notifier_a[dwIndex + 1].status == NV_IN_PROGRESS) {
            // NV11 mobile workaround, sometimes overlay flips are getting lost for unknown reasons
            // check to see if enough time has passed to guarantee this flip has flushed out
            nvQueryPerformanceCounter(&timeNow);
            if ((timeNow - vpp.pDriverData->flipOverlayRecord.llPreviousFlipTime) >= (vpp.pDriverData->flipPrimaryRecord.dwFlipDuration * 4)) {
                return TRUE;
            }
            // otherwise we really haven't flipped yet
            return FALSE;
        }
    }
    return TRUE;
}


//---------------------------------------------------------------------------
// vppFSFlipSync
//      Flushes out overlay flips.  Returns true if succeeded

LOCAL BOOL vppFSFlipSync(Vpp_t *pVpp,LPPROCESSINFO lpProcInfo, DWORD dwIndex, BOOL bWait)
{
    HDRVEVENT hEvent;
    Vpp_t &vpp = *pVpp;

    if (vpp.dwOverlayFSHead == 0) {
        if (dwIndex) {
            hEvent = lpProcInfo->hPrimary0FlipOdd3;
        } else {
            hEvent = lpProcInfo->hPrimary0FlipEven3;
        }
    } else {
        if (dwIndex) {
            hEvent = lpProcInfo->hPrimary1FlipOdd3;
        } else {
            hEvent = lpProcInfo->hPrimary1FlipEven3;
        }
    }

    if (bWait) {
        // if (IS_EVENT_ERROR(WaitForSingleObject(hEvent, VPP_TIMEOUT_TIME))) {
        if (VppWaitForNotification(&(vpp.pFlipPrimaryNotifier[dwIndex+1]), hEvent, VPP_TIMEOUT_TIME)) {
            DPF(" *** PRIMARY FLIP event failure ***");
            EVENT_ERROR;
            vpp.pFlipPrimaryNotifier[1].status = 0;
            vpp.pFlipPrimaryNotifier[2].status = 0;
        }
    } else {
        if (vpp.pFlipPrimaryNotifier[dwIndex + 1].status == NV_IN_PROGRESS) {
            return FALSE;
        }
    }
    return TRUE;
}


//---------------------------------------------------------------------------
// VppDoFlip
//     Does all the video post processing.  We never know whether the post
//      processing pipe has changed configuration since the last time, so
//      always flip.
//     Requires a source surface and 2 or (usually) 4 work surfaces.  Normal
//      usage leaves the source surface intact (mpeg-2 re-uses them) and
//      operates on each stage of the pipe by leaving the result in the
//      next working surface.  After each stage, the source is made to be
//      the destination of the previous stage.
//     Temporal filtering is special in that it snoops the 2 work surfaces
//      of the previous frame.
#define NEXT_SURFACE { \
            dwSrcOffset = dwDstOffset;  \
            dwSrcPitch = dwDstPitch;    \
            dwDstOffset = dwNextOffset; \
            dwDstPitch = dwNextPitch;   \
            dwNextOffset = dwSrcOffset; \
            dwNextPitch = dwSrcPitch;   \
            dwOpCount++;                \
        }

extern BOOL VppDoFlip(Vpp_t *pVpp,
                   DWORD dwOffset,
                   DWORD dwPitch,
                   DWORD dwWidth,
                   DWORD dwHeight,
                   DWORD dwFourCC,
                   DWORD dwFlags)
{
    DWORD dwSrcOffset, dwSrcPitch;
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwNextOffset, dwNextPitch;
    DWORD dwOpCount;
    DWORD dwWorkSurfaces;
    DWORD dwIndex;
    enum eClassUsed { NV5Class, CelsiusClass, KelvinClass } classUsed;
    BOOL  isYUV9, isYUV12, isYUV422;
    BOOL  doConvert, doSubPicture, doXPreScale, doYPreScale, doPreScale, doCC;
    BOOL  doTemporal, doFSMirror, doDeinterlace = FALSE;
    BOOL  doLateFlipSync, doOvlZoom;
    BOOL  isDownScale;
    LPPROCESSINFO lpProcInfo = NULL;
    DWORD dwRoundX, dwRoundY;
    DWORD vppExec;
    BOOL  isField;
    DWORD dwPrescaleFactorX, dwPrescaleFactorY;
    Vpp_t &vpp = *pVpp;
    HDRVEVENT hLastStage, hLastFSStage;
    NvNotification *pLastStageNotifier, *pLastFSStageNotifier;
    NvU32 processID;

    nvAssert(pVpp);
    nvAssert(vpp.dwFlags & VPP_FLAG_OVERLAY_READY);

    if ((vpp.regVPPInvMask & VPP_MASTER_DISABLE) ||
        (vpp.dwOverlayDstHeight == 0) ||
        (vpp.dwOverlayDstWidth == 0)) {
        return TRUE;
    }

#ifdef VPP_SNOOP
    __int64 qwTime1, qwDelta, qwJitter;
    __int64 qwTime2 = 0;

    vpp.snoop.dwMarker1 = 0x11111111;
    vpp.snoop.qwMarker2 = 0x2222222222222222;

    vpp.snoop.dwLastFlags = dwFlags | 0x80000000;
    nvQueryPerformanceCounter(&qwTime1);
    qwDelta = qwTime1 - vpp.snoop.qwInterFrameTime;
    qwJitter = (qwDelta > vpp.snoop.qwInterFrameDelta) ?
               (qwDelta - vpp.snoop.qwInterFrameDelta) :
               (vpp.snoop.qwInterFrameDelta - qwDelta);
    vpp.snoop.qwInterFrameJitterAcc += qwJitter;
    if (qwJitter > vpp.snoop.qwInterFrameJitterPeak) {
        vpp.snoop.qwInterFrameJitterPeak = qwJitter;
    }
    vpp.snoop.qwInterFrameAcc += qwDelta;
    if (qwDelta > vpp.snoop.qwInterFramePeak) {
        vpp.snoop.qwInterFramePeak = qwDelta;
    }
    vpp.snoop.qwInterFrameDelta = qwDelta;
    vpp.snoop.qwInterFrameTime = qwTime1;
#else   // !VPP_SNOOP
#ifdef DEBUG
    char debugstr[256];
    debugstr[0] = '\0';
    if (dwFlags & VPP_ODD)           nvStrCat (debugstr, "odd  ");
    if (dwFlags & VPP_EVEN)          nvStrCat (debugstr, "even ");
    if (dwFlags & VPP_BOB)           nvStrCat (debugstr, "bob ");
    if (dwFlags & VPP_INTERLEAVED)   nvStrCat (debugstr, "int ");
    if (dwFlags & VPP_VIDEOPORT)     nvStrCat (debugstr, "vp ");
    if (dwFlags & VPP_WAIT)          nvStrCat (debugstr, "wait ");
    if (dwFlags & VPP_OPTIMIZEFLIP)  nvStrCat (debugstr, "opt ");
    nvStrCat (debugstr, "REQ: ");
    if (dwFlags & VPP_CONVERT)       nvStrCat (debugstr, "cvt ");
    if (dwFlags & VPP_SUBPICTURE)    nvStrCat (debugstr, "sp ");
    if (dwFlags & VPP_PRESCALE)      nvStrCat (debugstr, "ps ");
    if (dwFlags & VPP_COLOURCONTROL) nvStrCat (debugstr, "cc ");
    if (dwFlags & VPP_TEMPORAL)      nvStrCat (debugstr, "tf ");
    if (dwFlags & VPP_DEINTERLACE)   nvStrCat (debugstr, "df ");
    if (dwFlags & VPP_FSMIRROR)      nvStrCat (debugstr, "fs ");
#endif  // DEBUG
#endif  // VPP_SNOOP

    dwFlags &= ~(vpp.regVPPInvMask);

    dwIndex = vpp.overlayBufferIndex;

    processID = nvGetCurrentProcessId();

    lpProcInfo = pmGetProcess(vpp.pDriverData, processID);

    // last resort event creation
    if (lpProcInfo == NULL || lpProcInfo->hOvlFlipEvenEvent3 == NULL || lpProcInfo->hOvlFlipOddEvent3 == NULL) {
        pmAddProcess(vpp.pDriverData, processID);
        lpProcInfo = pmGetProcess(vpp.pDriverData, processID);
    }

    // we de-reference the <lpProcInfo> var to get event handles... even when we're not using events
    // so it HAS to point to something!
    nvAssert(lpProcInfo != NULL);
    if (lpProcInfo == NULL)
    {
        return FALSE;
    }

#if (IS_WINNT5 || IS_WIN9X)
    if (dwFourCC == FOURCC_NV12) {
        LPNVMCSURFACEFLAGS lpSurfaceFlags;
        DWORD dwNewOffset;

        lpSurfaceFlags = (LPNVMCSURFACEFLAGS)&(vpp.pDriverData->nvMCSurfaceFlags[0]);

        while ((lpSurfaceFlags->dwMCSurfaceBase != 0) &&
               (lpSurfaceFlags->dwMCSurfaceBase != (dwOffset + vpp.pDriverData->BaseAddress)))
            lpSurfaceFlags++;

        // NV12 surfaces are preconverted to YUYV, just adjust some parameters
        dwNewOffset = lpSurfaceFlags->dwMCSurface422Offset;

        dwPitch = ((dwWidth + 3) & ~3);
        dwPitch = dwPitch << 1;
        dwPitch = (dwPitch + 127) & ~127;

        if (vpp.pDriverData->bMCOverlaySrcIsSingleField1080i) {
            dwFlags &= ~(VPP_ODD | VPP_EVEN | VPP_INTERLEAVED);
        }

        // Check if we should be displaying the default or the filtered portion of the surface
        if (lpSurfaceFlags->bMCFrameIsFiltered) {
            dwNewOffset += (dwPitch * dwHeight);
        }

        dwOffset = dwNewOffset;
        dwFourCC = FOURCC_YUY2;
    }
#endif

    hLastStage           = NULL;
    hLastFSStage         = NULL;
    pLastStageNotifier   = NULL;
    pLastFSStageNotifier = NULL;

    dwWorkSurfaces = vpp.extraNumSurfaces;
    vppExec = 0;
    dwOpCount = 0;
    dwPrescaleFactorX = 0x100000;
    dwPrescaleFactorY = 0x100000;
    dwSrcOffset = dwOffset;
    dwSrcPitch = dwPitch;
    dwDstOffset = vpp.extraOverlayOffset[vpp.extraIndex];
    dwDstPitch = vpp.extraPitch;
    dwNextOffset = vpp.extraOverlayOffset[vpp.extraIndex + 1];
    dwNextPitch = vpp.extraPitch;

    isYUV9 = (dwFourCC == FOURCC_IF09 ||
              dwFourCC == FOURCC_YVU9 ||
              dwFourCC == FOURCC_IV32 ||
              dwFourCC == FOURCC_IV31);

    isYUV12 = (dwFourCC == FOURCC_YV12 ||
               dwFourCC == FOURCC_420i);

    isYUV422 = (dwFourCC == FOURCC_YUY2 ||
                dwFourCC == FOURCC_UYVY ||
                dwFourCC == FOURCC_YUNV ||
                dwFourCC == FOURCC_UYNV);

    isField = IS_FIELD(dwFlags);

    if (!isYUV9 && !isYUV12 && !isYUV422) {
        return FALSE;
    }

    doConvert = (dwFlags & VPP_CONVERT) &&
                (isYUV9 || isYUV12);

    doSubPicture = (dwFlags & VPP_SUBPICTURE) &&
                   (vpp.subPicture.offset != 0) &&
                 (((vpp.subPicture.pitch & NVS2VF_SP_ODD) && (dwFlags & VPP_ODD)) ||
                  ((vpp.subPicture.pitch & NVS2VF_SP_EVEN) && (dwFlags & VPP_EVEN)) ||
                  ((dwFlags & (VPP_EVEN | VPP_ODD))==0));

    doXPreScale = (vpp.dwOverlaySrcWidth > (vpp.dwOverlayDstWidth * vpp.dwOverlayMaxDownScaleX));
    doYPreScale = (vpp.dwOverlaySrcHeight > (vpp.dwOverlayDstHeight * vpp.dwOverlayMaxDownScaleY));
    if (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) {
        // NV4/5 also prescales:
        //  - all BOBed fields
        //  - vertical upscales when HQVUp is enabled
        doYPreScale = doYPreScale || (vpp.regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) || isField;
    }

    doPreScale = (dwFlags & VPP_PRESCALE) &&
                 (doXPreScale || doYPreScale);

    isDownScale = FALSE;
    if (doPreScale) {
        DWORD dwSrcHeight, dwSrcArea, dwDstArea;

        dwSrcHeight = vpp.dwOverlaySrcHeight;
        if ((dwFlags & (VPP_ODD | VPP_EVEN)) && (dwFlags & VPP_INTERLEAVED)) {
            // bob mode
            dwSrcHeight >>= 1;
        }
        dwSrcArea = dwSrcHeight * vpp.dwOverlaySrcWidth;
        dwDstArea = vpp.dwOverlayDstHeight * vpp.dwOverlayDstWidth;
        if (dwSrcArea > dwDstArea) {
            isDownScale = TRUE;
        }
    }

    doCC = (dwFlags & VPP_COLOURCONTROL) &&
           (vpp.pDriverData->NvDeviceVersion < NV_DEVICE_VERSION_10) &&
           (vpp.fpOverlayShadow) &&
           (vpp.regOverlayColourControlEnable) &&
           (vpp.colorCtrl.lContrast != 0xFF ||
            vpp.colorCtrl.lBrightness != 0 ||
            vpp.colorCtrl.lHue != 0 ||
            vpp.colorCtrl.lSaturation != 0x100);

    doTemporal = (dwFlags & VPP_TEMPORAL) &&
                 (vpp.regOverlayMode & NV4_REG_OVL_MODE_TFILTER);

#if (NVARCH >= 10)
    doDeinterlace = (dwFlags & VPP_DEINTERLACE) && isField &&
                    (vpp.regOverlayMode & NV4_REG_OVL_MODE_DFILTER);
#endif

    if (vpp.dwFlags & VPP_FLAG_KELVIN_3D)
        classUsed = KelvinClass;
    else if (vpp.dwFlags & VPP_FLAG_CELSIUS_3D)
        classUsed = CelsiusClass;
    else
        classUsed = NV5Class;

    doFSMirror = (dwFlags & VPP_FSMIRROR) &&
                 (vpp.dwOverlayFSNumSurfaces > 0) &&
                 (vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK);

    if (dwWorkSurfaces < 2) {
        // no work surfaces, can't do anything
        doConvert = FALSE;
        doSubPicture = FALSE;
        doTemporal = FALSE;
        doDeinterlace = FALSE;
        doPreScale = FALSE;
        doCC = FALSE;
    } else if (dwWorkSurfaces < 4) {
        // there are only 2 or 3 work surfaces, we can only do one VPP stage, so prioritize
        if (doConvert) {
            doPreScale = FALSE;
            doSubPicture = FALSE;
            doTemporal = FALSE;
            doDeinterlace = FALSE;
        } else if (doPreScale) {
            doSubPicture = FALSE;
            doTemporal = FALSE;
            doDeinterlace = FALSE;
        } else if (doSubPicture) {
            doTemporal = FALSE;
            doDeinterlace = FALSE;
        }
        doCC = FALSE;   // needs more than 2 work surfaces
        if (classUsed == NV5Class) {
            // NV4/5 requires 4 work surfaces for temporal filtering
            doTemporal = FALSE;
        }
    }

    doOvlZoom = (vpp.regOverlayMode3 & NV4_REG_OVL_MODE3_OVLZOOMQUADMASK);

    doLateFlipSync = (vpp.regOverlayMode & NV4_REG_OVL_MODE_LATEFLIPSYNC);

    // never allow flips to queue up if we are post processing
    if (!doLateFlipSync) {
        // early sync handles all cases
        if (!vppFlipSync(&vpp,lpProcInfo, dwIndex, dwFlags & VPP_WAIT)) {
            return FALSE;
        }
    }

    if (doConvert || doSubPicture || doPreScale || doCC || doDeinterlace || doTemporal || doFSMirror) {
        vpp.pPusher->waitForOtherChannels();
        vppSetSurfacesState(&vpp);
    }

    if (doFSMirror) {
        // if FSMirror is enabled, then we want to process the entire video image, not just the subrectangle
        dwWidth = vpp.dwOverlayFSSrcWidth;
        dwHeight = vpp.dwOverlayFSSrcHeight;
    }

    // always convert the entire surface cuz it saves us alot of subrectangle calculation,
    //  who cares about non-YUV422 performance
    if (doConvert) {
        if (vppConvert(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset,
                       dwDstPitch, dwWidth, dwHeight, dwFourCC)) {
            hLastStage = lpProcInfo->hConvert3;
            pLastStageNotifier = vpp.m_obj_a[V2V_FORMAT_NDX].notifier_a;

            NEXT_SURFACE;
            dwFourCC = FOURCC_YUY2;
            vppExec |= VPP_CONVERT;
        }
    }

    // codec does the subrectangle optimization
    if (doSubPicture) {
        if (vppSubPicture(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset,
                          dwDstPitch, dwWidth, dwHeight, dwFourCC)) {
            hLastStage = lpProcInfo->hSubPicture3;
            pLastStageNotifier = vpp.m_obj_a[DVDPICT_NDX].notifier_a;

            if (vpp.subPicture.pitch & NVS2VF_SP_SUBRECT) {
                // codec has requested in place composition, don't do next_surface
            } else {
                NEXT_SURFACE;
            }
            vppExec |= VPP_SUBPICTURE;
        }
    }

    if (doFSMirror || doOvlZoom) {
        // adjust for the FS mirror subrectangle
        dwRoundX = vpp.dwOverlayFSSrcMinX & 0x1;
        dwRoundY = vpp.dwOverlayFSSrcMinY & 0x1;
        dwSrcOffset += (vpp.dwOverlayFSSrcMinY & ~0x1) * dwSrcPitch;
        dwSrcOffset += (vpp.dwOverlayFSSrcMinX & ~0x1) << 1;   // always YUV422
        // ????? There's a really weird interaction with DVD subpicture class with width set to 8 pixels or less,
        //       and some GDI operation.  Not sure if it's hw or sw, but setting minimum width of 16 pixels makes
        //       the problem go away.  Overlay surfaces should have a minimum pitch greater than this, so very
        //       small overlay surfaces will be unaffected.
        dwWidth = max(vpp.dwOverlayFSSrcWidth, 16);
        dwHeight = vpp.dwOverlayFSSrcHeight;
        if (dwRoundY) {
            dwHeight += 1;
        }
    } else {
        // adjust for the subrectangle
        dwRoundX = vpp.dwOverlaySrcX & 0x1;
        dwRoundY = vpp.dwOverlaySrcY & 0x1;
        dwSrcOffset += (vpp.dwOverlaySrcY & ~0x1) * dwSrcPitch;
        dwSrcOffset += (vpp.dwOverlaySrcX & ~0x1) << 1;   // always YUV422
        // ????? There's a really weird interaction with DVD subpicture class with width set to 8 pixels or less,
        //       and some GDI operation.  Not sure if it's hw or sw, but setting minimum width of 16 pixels makes
        //       the problem go away.  Overlay surfaces should have a minimum pitch greater than this, so very
        //       small overlay surfaces will be unaffected.
        dwWidth = max(vpp.dwOverlaySrcSize & 0xFFFF, 16);
        dwHeight = vpp.dwOverlaySrcSize >> 16;
        if (dwRoundY) {
            dwHeight += 1;
        }
    }

    if (doDeinterlace) {
        if (dwOpCount == 0 && (vpp.regOverlayMode & NV4_REG_OVL_MODE_DF_PRECOPY)) {
            // need to keep a copy of source data
            if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, dwWidth, dwHeight)) {
                NEXT_SURFACE;
            } else {
                nvAssert(FALSE);
            }
        }

        BOOL bDeinterlaceResult = FALSE;

        switch (classUsed)
        {
        case CelsiusClass:
            bDeinterlaceResult = vppNv10Deinterlace(&vpp, lpProcInfo, dwSrcOffset, dwSrcPitch,
                                                    dwDstOffset, dwDstPitch,
                                                    dwWidth, dwHeight, dwFlags);
            break;

        case KelvinClass:
            bDeinterlaceResult = vppNv20Deinterlace(&vpp, lpProcInfo, dwSrcOffset, dwSrcPitch,
                                                    dwDstOffset, dwDstPitch,
                                                    dwWidth, dwHeight, dwFlags);
            break;
        }

        if (bDeinterlaceResult)
        {
            hLastStage = lpProcInfo->hDFilter3;
            pLastStageNotifier = NULL; // ??? vpp.m_obj_a[???].notifier_a;
            NEXT_SURFACE;
            vppExec |= VPP_DEINTERLACE;
        }
    }

    if (doTemporal) {
        if (dwOpCount == 0 && (vpp.regOverlayMode & NV4_REG_OVL_MODE_TF_PRECOPY)) {
            // need to keep a copy of source data
            if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, dwWidth, dwHeight)) {
                NEXT_SURFACE;
            } else {
                nvAssert(FALSE);
            }
        }

        BOOL bTemporalResult = FALSE;

        switch(classUsed)
        {
        case CelsiusClass:
            bTemporalResult = vppNv10Temporal(&vpp, lpProcInfo, dwSrcOffset, dwSrcPitch,
                                                dwDstOffset, dwDstPitch,
                                                dwWidth, dwHeight, dwFlags,
                                                &vpp.dwPrevFrameOffset);
            break;

        case KelvinClass:
            bTemporalResult = vppNv20Temporal(&vpp, lpProcInfo, dwSrcOffset, dwSrcPitch,
                                                dwDstOffset, dwDstPitch,
                                                dwWidth, dwHeight, dwFlags,
                                                &vpp.dwPrevFrameOffset);
            break;
        }

        if (bTemporalResult)
        {
            hLastStage = lpProcInfo->hTFilter3;
            pLastStageNotifier = NULL; // ??? vpp.m_obj_a[???].notifier_a;
            NEXT_SURFACE;
            vppExec |= VPP_TEMPORAL;

            // not the first frame any more
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        }
    }

    if (doFSMirror) {
        if (vpp.dwOverlayFSNumSurfaces == 2) {
            // early flip sync for double buffered case
            vppFSFlipSync(pVpp,lpProcInfo, dwIndex, TRUE);
        } else if (vpp.dwOverlayFSNumSurfaces == 3) {
            // in 60 fps cases at 60 Hz, make sure only one flip is queued, may see tearing if 2 are queued
            vppFSFlipSync(pVpp,lpProcInfo, dwIndex ^ 1, TRUE);
        }
        if (vppFSMirror(pVpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwWidth, dwHeight, dwFourCC, dwFlags, dwPrescaleFactorX, dwPrescaleFactorY)) {
            hLastFSStage = lpProcInfo->hFSMirror3;
            pLastFSStageNotifier = NULL; // ??? vpp.m_obj_a[???].notifier_a;
            vppExec |= VPP_FSMIRROR;
        }
    }

    // Since OCC is much slower that prescale, arrange it so that OCC operates
    // on the smaller data set.
    if (isDownScale) {
        // do prescale first and then OCC
        if (doPreScale) {
            DWORD dwStartWidth, dwStartHeight;
            dwStartWidth = dwWidth;
            dwStartHeight = dwHeight;
            do {
                if (vppPreScale(pVpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                            &dwWidth, &dwHeight, dwFourCC, &dwFlags)) {
                    hLastStage = lpProcInfo->hSubPicture3;
                    pLastStageNotifier = vpp.m_obj_a[DVDPICT_NDX].notifier_a;
                    NEXT_SURFACE;
                    vppExec |= VPP_PRESCALE;
                }
            } while ((dwWidth  > (vpp.dwOverlayDstWidth * vpp.dwOverlayMaxDownScaleX) &&
                      vpp.dwOverlayDstWidth > 4) ||
                     (dwHeight > (vpp.dwOverlayDstHeight * vpp.dwOverlayMaxDownScaleY) &&
                      vpp.dwOverlayDstHeight > 4));
            dwPrescaleFactorX = (dwWidth << 20) / dwStartWidth;
            dwPrescaleFactorY = (dwHeight << 20) / dwStartHeight;
        }
        if (doCC) {
            if (dwOpCount == 0 && vpp.colorCtrl.lContrast != 0xFF) {
                // need to copy source data because contrast may be done in place
                if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                               dwWidth, dwHeight)) {
                    NEXT_SURFACE;
                } else {
                    nvAssert(FALSE);
                }
            }
            if (vppColourControl(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                                 dwWidth, dwHeight, dwFourCC, dwFlags)) {
                hLastStage = lpProcInfo->hColourControl3;
                pLastStageNotifier = vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a;
                NEXT_SURFACE;
                vppExec |= VPP_COLOURCONTROL;
            }
        }
    } else {
        // do OCC first and then prescale
        if (doCC) {
            if (dwOpCount == 0 && vpp.colorCtrl.lContrast != 0xFF) {
                // need to copy source data because contrast may be done in place
                if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                               dwWidth, dwHeight)) {
                    NEXT_SURFACE;
                } else {
                    nvAssert(FALSE);
                }
            }
            if (vppColourControl(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                                 dwWidth, dwHeight, dwFourCC, dwFlags)) {
                hLastStage = lpProcInfo->hColourControl3;
                pLastStageNotifier = vpp.m_obj_a[V2OSH_FORMAT_NDX].notifier_a;
                NEXT_SURFACE;
                vppExec |= VPP_COLOURCONTROL;
            }
        }
        if (doPreScale) {
            DWORD dwStartWidth, dwStartHeight;
            dwStartWidth = dwWidth;
            dwStartHeight = dwHeight;
            do {
                if (vppPreScale(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                                &dwWidth, &dwHeight, dwFourCC, &dwFlags)) {
                    hLastStage = lpProcInfo->hSubPicture3;
                    pLastStageNotifier = vpp.m_obj_a[DVDPICT_NDX].notifier_a;
                    NEXT_SURFACE;
                    vppExec |= VPP_PRESCALE;
                }
            } while ((dwWidth  > (vpp.dwOverlayDstWidth * vpp.dwOverlayMaxDownScaleX) &&
                      vpp.dwOverlayDstWidth > 4) ||
                     (dwHeight > (vpp.dwOverlayDstHeight * vpp.dwOverlayMaxDownScaleY) &&
                      vpp.dwOverlayDstHeight > 4));
            dwPrescaleFactorX = (dwWidth << 20) / dwStartWidth;
            dwPrescaleFactorY = (dwHeight << 20) / dwStartHeight;
        }
    }

    if (doTemporal && (classUsed == NV5Class)) {
        if (dwOpCount == 0) {
            // need to copy source data to a work area whose dimensions are a power of 2
            if (vppPreCopy(&vpp,dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, dwWidth, dwHeight)) {
                NEXT_SURFACE;
            } else {
                nvAssert(FALSE);
            }
        }

        if (vppNv5Temporal(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch,
                           dwWidth, dwHeight, &vpp.dwPrevFrameOffset)) {
            hLastStage = lpProcInfo->hTFilter3;
            pLastStageNotifier = NULL; // ??? vpp.m_obj_a[???].notifier_a;
            vppExec |= VPP_TEMPORAL;
            // don't do a NEXT_SURFACE, temporal filter operates in place and leaves
            // a swizzled version at dwDstOffset for use on the next frame (NV4/5)

            // not the first frame any more
            vpp.regOverlayMode |= NV4_REG_OVL_MODE_NOTFIRST;
        }
    }

    if (doConvert || doSubPicture || doPreScale || doCC || doDeinterlace || doTemporal || doFSMirror) {
        vppRestoreSurfacesState(&vpp);
    }

    if (!doTemporal) {
        // next time tfilter is enabled, it will be the first frame
        vpp.regOverlayMode &= ~NV4_REG_OVL_MODE_NOTFIRST;
    }

    if ((dwFlags & VPP_OPTIMIZEFLIP) && dwOpCount == 0) {
        // nothing happened, don't flip
        return FALSE;
    }

    if (doFSMirror && !doOvlZoom) {
        // now do the subrectangle adjustments for FS mirror so things flip properly
        dwSrcOffset += vpp.dwOverlaySrcY * dwSrcPitch;
        dwSrcOffset += (vpp.dwOverlaySrcX & ~0x1) << 1;   // always YUV422
        // ????? There's a really weird interaction with DVD subpicture class with width set to 8 pixels or less,
        //       and some GDI operation.  Not sure if it's hw or sw, but setting minimum width of 16 pixels makes
        //       the problem go away.  Overlay surfaces should have a minimum pitch greater than this, so very
        //       small overlay surfaces will be unaffected.
        dwWidth = max(vpp.dwOverlaySrcSize & 0xFFFF, 16);
        dwHeight = vpp.dwOverlaySrcSize >> 16;
    } else {
        if (dwRoundY) {
            dwSrcOffset += dwSrcPitch;
            dwHeight -= 1;
        }
    }

    //
    // NB: any local variables or parameters used before & after this point must be saved
    //    (excluding lProcinfo)
    //     This SAVE/RESTORE feature is only used by Ravisent decoders
    //
    if (dwFlags & VPP_SAVE_STATE) {
        vpp.pipeState.dwOpCount            = dwOpCount;
        vpp.pipeState.hLastStage           = hLastStage;
        vpp.pipeState.pLastStageNotifier   = pLastStageNotifier;
        vpp.pipeState.hLastFSStage         = hLastFSStage;
        vpp.pipeState.pLastFSStageNotifier = pLastFSStageNotifier;
        vpp.pipeState.doLateFlipSync       = (NvU8)doLateFlipSync;
        vpp.pipeState.dwIndex              = dwIndex;
        vpp.pipeState.dwSrcOffset          = dwSrcOffset;
        vpp.pipeState.dwSrcPitch           = dwSrcPitch;
        vpp.pipeState.dwWidth              = dwWidth;
        vpp.pipeState.dwHeight             = dwHeight;
        vpp.pipeState.dwFourCC             = dwFourCC;
        vpp.pipeState.dwFlags              = dwFlags & ~VPP_SAVE_STATE;
        vpp.pipeState.dwWorkSurfaces       = dwWorkSurfaces;
        vpp.pipeState.dwPrescaleFactorX    = dwPrescaleFactorX;
        vpp.pipeState.dwPrescaleFactorY    = dwPrescaleFactorY;
        vpp.pipeState.doFSMirror           = (NvU8)doFSMirror;
#ifdef VPP_SNOOP
        vpp.pipeState.qwTime1              = qwTime1;
        vpp.pipeState.qwTime2              = qwTime2;
        vpp.pipeState.qwDelta              = qwDelta;
        vpp.pipeState.qwJitter             = qwJitter;
#endif
        return TRUE;
    }

    if (dwFlags & VPP_RESTORE_STATE) {
        dwOpCount            = vpp.pipeState.dwOpCount;
        hLastStage           = vpp.pipeState.hLastStage;
        pLastStageNotifier   = vpp.pipeState.pLastStageNotifier;
        hLastFSStage         = vpp.pipeState.hLastFSStage;
        pLastFSStageNotifier = vpp.pipeState.pLastFSStageNotifier;
        doLateFlipSync       = vpp.pipeState.doLateFlipSync;
        dwIndex              = vpp.pipeState.dwIndex;
        dwSrcOffset          = vpp.pipeState.dwSrcOffset;
        dwSrcPitch           = vpp.pipeState.dwSrcPitch;
        dwWidth              = vpp.pipeState.dwWidth;
        dwHeight             = vpp.pipeState.dwHeight;
        dwFourCC             = vpp.pipeState.dwFourCC;
        dwFlags              = vpp.pipeState.dwFlags;
        dwWorkSurfaces       = vpp.pipeState.dwWorkSurfaces;
        vppExec              = vpp.pipeState.vppExec;
        dwPrescaleFactorX    = vpp.pipeState.dwPrescaleFactorX;
        dwPrescaleFactorY    = vpp.pipeState.dwPrescaleFactorY;
        doFSMirror           = vpp.pipeState.doFSMirror;
#ifdef VPP_SNOOP
        qwTime1              = vpp.pipeState.qwTime1;
        qwTime2              = vpp.pipeState.qwTime2;
        qwDelta              = vpp.pipeState.qwDelta;
        qwJitter             = vpp.pipeState.qwJitter;
#endif
    }

    // wait for all stages to complete
    if (dwOpCount > 0 && hLastStage) {
        if (VppWaitForNotification(pLastStageNotifier, hLastStage, VPP_TIMEOUT_TIME)) {
            DPF(" *** A VPP stage notification failed to return during timeout period ***");
            EVENT_ERROR;
        }

    } else {
        if (vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1].status == NV_IN_PROGRESS) {
            // wait for any DMA blits to flush out before processing
            // if (IS_EVENT_ERROR(WaitForSingleObject(lpProcInfo->hDMABlitToVid3, VPP_TIMEOUT_TIME))) {
            if (VppWaitForNotification(&(vpp.m_obj_a[DMABLT_TO_VID_NDX].notifier_a[1]), lpProcInfo->hDMABlitToVid3, VPP_TIMEOUT_TIME)) {
                DPF(" *** DMA BLIT event failure ***");
                EVENT_ERROR;
            }
        }
        // wait for any backdoor FOURCC blits to flush out
        if (VppWaitForNotification(vpp.pPusherSyncNotifier, lpProcInfo->hFSMirror3, VPP_TIMEOUT_TIME)) {
            DPF(" *** FOURCC BLIT event failure ***");
            EVENT_ERROR;
        }
    }

    if (doLateFlipSync) {
        // late sync only for decoders that use lots of stages, will not work for
        // fewer than 3 buffers, decoder must not go back and re-use a surface that
        // it just flipped away from
        if (!vppFlipSync(&vpp,lpProcInfo, dwIndex, TRUE)) {
            return FALSE;
        }
    }

    // always do the flip, even if we are not flipping
    if (vppFlip(&vpp,lpProcInfo, dwSrcOffset, dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFourCC, dwFlags, dwPrescaleFactorX, dwPrescaleFactorY)) {
        vpp.pDriverData->dwTVTunerFlipCount = 0;
        vpp.dwOverlayFlipCount++;
        vpp.overlayBufferIndex ^= 1;
        if (dwWorkSurfaces == 0) {
            vpp.extraIndex = 0;
        } else if (dwWorkSurfaces <= 3) {
            vpp.extraIndex = (vpp.extraIndex + 1) % dwWorkSurfaces;
        } else {
            vpp.extraIndex = (vpp.extraIndex + 2) % dwWorkSurfaces;
        }

        // successful overlay flip, now match it with the FS mirror image
        if (doFSMirror) {
            if (hLastFSStage) {
                if (VppWaitForNotification(pLastFSStageNotifier, hLastFSStage, VPP_TIMEOUT_TIME)) {
                    dbgError(" *** FS event failure ***");
                    EVENT_ERROR;
                }
            }
            if (vpp.dwOverlayFSNumSurfaces > 3) {
                // late flip sync for quad buffered case
                vppFSFlipSync(pVpp,lpProcInfo, dwIndex, TRUE);
            }
            vppFSFlip(pVpp,lpProcInfo, dwIndex);
            if (vpp.dwOverlayFSNumSurfaces != 0) {
                vpp.dwOverlayFSIndex = (vpp.dwOverlayFSIndex + 1) % vpp.dwOverlayFSNumSurfaces;
            }
        }
    } else {
        return FALSE;
    }

#ifdef VPP_SNOOP

    vpp.snoop.dwLastExec = vppExec;
    nvQueryPerformanceCounter(&qwTime2);
    qwDelta = qwTime2 - qwTime1;
    qwJitter = (qwDelta > vpp.snoop.qwIntraFrameDelta) ?
               (qwDelta - vpp.snoop.qwIntraFrameDelta) :
               (vpp.snoop.qwIntraFrameDelta - qwDelta);
    vpp.snoop.qwIntraFrameJitterAcc += qwJitter;
    if (qwJitter > vpp.snoop.qwIntraFrameJitterPeak) {
        vpp.snoop.qwIntraFrameJitterPeak = qwJitter;
    }
    vpp.snoop.qwIntraFrameAcc += qwDelta;
    if (qwDelta > vpp.snoop.qwIntraFramePeak) {
        vpp.snoop.qwIntraFramePeak = qwDelta;
    }
    vpp.snoop.qwIntraFrameDelta = qwDelta;
    vpp.snoop.qwCount += 1;
    vpp.snoop.dwLastFlags &= 0x7FFFFFFF;

#else   // !VPP_SNOOP
#ifdef DEBUG
    nvStrCat (debugstr, "ENA: ");
    if (doConvert)                       nvStrCat (debugstr, "cvt ");
    if (doSubPicture)                    nvStrCat (debugstr, "sp ");
    if (doPreScale)                      nvStrCat (debugstr, "ps ");
    if (doCC)                            nvStrCat (debugstr, "cc ");
    if (doTemporal)                      nvStrCat (debugstr, "tf ");
    if (doDeinterlace)                   nvStrCat (debugstr, "df ");
    if (doFSMirror)                      nvStrCat (debugstr, "fs ");
    nvStrCat (debugstr, "EXEC: ");
    if (vppExec & VPP_CONVERT)           nvStrCat (debugstr, "cvt ");
    if (vppExec & VPP_SUBPICTURE)        nvStrCat (debugstr, "sp ");
    if (vppExec & VPP_PRESCALE)          nvStrCat (debugstr, "ps ");
    if (vppExec & VPP_COLOURCONTROL)     nvStrCat (debugstr, "cc ");
    if (vppExec & VPP_TEMPORAL)          nvStrCat (debugstr, "tf ");
    if (vppExec & VPP_DEINTERLACE)       nvStrCat (debugstr, "df ");
    if (vppExec & VPP_FSMIRROR)          nvStrCat (debugstr, "fs ");
    DPF(debugstr);
#endif  // DEBUG
#endif  // VPP_SNOOP

    return TRUE;
}

// -----------------------------------------------------------------------------------------
// VppSetOverlayColourControl
//      Sets the overlay colour controls
//
// Globals:
//      OverlayColourControl

extern NvU8 VppSetOverlayColourControl(Vpp_t *pVpp)
{
    long            newHWContrast;
    long            newHWBrightness;
    long            newHWSaturation;
    long            newHWSine;
    long            newHWCosine;
    float           fRadians;
    Vpp_t &vpp = *pVpp;

    if (!(pVpp->dwFlags & VPP_FLAG_OVERLAY_READY))
    {
       return FALSE;
    }

    if (vpp.pDriverData->NvDeviceVersion >= NV_DEVICE_VERSION_10) {
        /* Convert to equivalent NV hardware values */
        newHWContrast = vpp.colorCtrl.lContrast;
        if (newHWContrast < 0)
            newHWContrast = 0;
        if (newHWContrast > 19999)
            newHWContrast = 19999;
        newHWContrast *= 8192;
        newHWContrast /= 20000;

        newHWBrightness = vpp.colorCtrl.lBrightness;
        newHWBrightness -= 750;
        newHWBrightness *= 256;
        newHWBrightness /= 10000;

        newHWSaturation = vpp.colorCtrl.lSaturation;
        if (newHWSaturation < 0)
            newHWSaturation = 0;
        if (newHWSaturation > 19999)
            newHWSaturation = 19999;
        newHWSaturation *= 8192;
        newHWSaturation /= 20000;

        fRadians = (float)((vpp.colorCtrl.lHue * 3.1415926) / 180);
        // TBD: using sin/cos in the driver may not be doable on all platforms.  Is the FPU ready in this
        //   cpu mode?  [it is for Windows systems in Ddraw] - @mjl
        newHWSine = (long)(sin(fRadians) * newHWSaturation);
        newHWCosine = (long)(cos(fRadians) * newHWSaturation);

        /* Merge luminance values */
        newHWBrightness <<= 16;
        newHWBrightness |= newHWContrast;

        /* Merge chrominance values */
        newHWCosine &= 0xFFFF;
        newHWSine <<= 16;
        newHWSine |= newHWCosine;

        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.m_obj_a[OVERLAY_NDX].classIID);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | NV07A_SET_OVERLAY_LUMINANCE_A | 0x80000);
        vpp.pPusher->push(3, newHWBrightness);     // SetOverlayLuminanceA
        vpp.pPusher->push(4, newHWSine);           // SetOverlayChrominanceA
        vpp.pPusher->adjust(5);
        vpp.pPusher->start(TRUE);
        vpp.pDriverData->dDrawSpareSubchannelObject = 0;
        return TRUE;
    }
    return FALSE;

}

// These blt support routines should be moved to a shared blt routine when that is made OS independant @mjl@

// -----------------------------------------------------------------------------
// vppBltUpdateClip
//      Updates the NV clipper state if necessary
// -----------------------------------------------------------------------------
LOCAL void vppBltUpdateClip(Vpp_t *pVpp)
{
    Vpp_t &vpp = *pVpp;

    if (vpp.pDriverData->ddClipUpdate ||
        vpp.pDriverData->dwSharedClipChangeCount != vpp.pDriverData->dwDDMostRecentClipChangeCount)
    {
        // Why not use spare here? @mjl@
        vpp.pPusher->push (0,SUB_CHANNEL(vpp.surfaces2DSubCh) | 0x40000);
        vpp.pPusher->push (1,vpp.hImageBlackRect);
        vpp.pPusher->push (2,SUB_CHANNEL(vpp.surfaces2DSubCh) +
                                IMAGE_BLACK_RECTANGLE_POINT_OFFSET | 0x80000);
        vpp.pPusher->push (3,0);
        vpp.pPusher->push (4,asmMergeCoords(NV_MAX_X_CLIP,NV_MAX_Y_CLIP));
        vpp.pPusher->push (5,SUB_CHANNEL(vpp.surfaces2DSubCh) | 0x40000);
        vpp.pPusher->push (6,vpp.hSurfaces2D);

        vpp.pPusher->adjust (7);
        vpp.pPusher->start  (TRUE);

        vpp.pDriverData->dwSharedClipChangeCount++;
        vpp.pDriverData->dwDDMostRecentClipChangeCount = vpp.pDriverData->dwSharedClipChangeCount;
        vpp.pDriverData->ddClipUpdate = FALSE;
    }
}

// -----------------------------------------------------------------------------
// vppBltFillBlock
//      Fill a block of memory.  Self contained, for internal use only
//
// -----------------------------------------------------------------------------
LOCAL void vppBltFillBlock(Vpp_t *pVpp, NvU32 dwColor, NvU32 dwOffset, NvU32 dwPitch, NvU32 dwWidth, NvU32 dwHeight, NvU32 dwBytesPerPel)
{
    NvU32 dwCombinedPitch, dwColourFormat, dwColourFormat2;
    NvU32 dwDstX;
    Vpp_t &vpp = *pVpp;

    vpp.pDriverData->blitCalled = TRUE;
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    // make sure we sync with other channels before writing put
    vpp.pPusher->setSyncChannelFlag();

    vppBltUpdateClip(pVpp);

    // alignment
    dwDstX = (dwOffset & NV_BYTE_ALIGNMENT_PAD) / dwBytesPerPel;
    dwOffset &= ~NV_BYTE_ALIGNMENT_PAD;

    // source key is disabled
    if (vpp.pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextColorKey);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SET_TRANSCOLOR_OFFSET | 0x40000);
        vpp.pPusher->push(3, 0);
        vpp.pPusher->adjust(4);
        vpp.pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hContextColorKey;
    }

    // ROP is always SRCCOPY
    if (vpp.pDriverData->bltData.dwLastRop != SRCCOPYINDEX) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropSubCh) | SET_ROP_OFFSET | 0x40000);
        vpp.pPusher->push(1, SRCCOPYINDEX);
        vpp.pPusher->adjust(2);
        vpp.pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
    }

    // set surfaces 2d
    switch (dwBytesPerPel) {
    case 1:
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_Y8;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        break;
    case 4:
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8;
        break;
    default:
        dwColourFormat = NV062_SET_COLOR_FORMAT_LE_R5G6B5;
        dwColourFormat2 = NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5;
        break;
    }
    dwCombinedPitch = (dwPitch << 16) | dwPitch;
    if (vpp.pDriverData->bltData.dwLastColourFormat != dwColourFormat ||
        vpp.pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
        vpp.pDriverData->bltData.dwLastSrcOffset != dwOffset ||
        vpp.pDriverData->bltData.dwLastDstOffset != dwOffset) {

        vpp.pPusher->push(0, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
        vpp.pPusher->push(1, dwColourFormat);          // SetColorFormat
        vpp.pPusher->push(2, dwCombinedPitch);         // SetPitch
        vpp.pPusher->push(3, dwOffset);                // SetSrcOffset
        vpp.pPusher->push(4, dwOffset);                // SetDstOffset
        vpp.pPusher->adjust(5);
        vpp.pDriverData->bltData.dwLastColourFormat = dwColourFormat;
        vpp.pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
        vpp.pDriverData->bltData.dwLastSrcOffset = dwOffset;
        vpp.pDriverData->bltData.dwLastDstOffset = dwOffset;

        // Also set mono pattern mask when pixel depth changes.
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextPattern);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) + NV044_SET_PATTERN_SELECT | 0xC0000);
        vpp.pPusher->push(3, NV044_SET_PATTERN_SELECT_MONOCHROME);
        switch (dwBytesPerPel) {
        case 1:
            vpp.pPusher->push(4,NV_ALPHA_1_008);
            vpp.pPusher->push(5,NV_ALPHA_1_008);
            break;
        case 4:
            vpp.pPusher->push(4,NV_ALPHA_1_032);
            vpp.pPusher->push(5,NV_ALPHA_1_032);
            break;
        default:
            vpp.pPusher->push(4,NV_ALPHA_1_016);
            vpp.pPusher->push(5,NV_ALPHA_1_016);
            break;
        }
        vpp.pPusher->adjust(6);
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hContextPattern;
    }

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropRectTextSubCh) | NV04A_SET_COLOR_FORMAT | 0x40000);
    vpp.pPusher->push(1, dwColourFormat2);
    vpp.pPusher->push(2, SUB_CHANNEL(vpp.ropRectTextSubCh) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
    vpp.pPusher->push(3, dwColor);
    vpp.pPusher->push(4, asmMergeCoords(0, dwDstX));
    vpp.pPusher->push(5, asmMergeCoords(dwHeight, dwWidth));
    vpp.pPusher->adjust(6);
    vpp.pPusher->start(TRUE);
}

// -----------------------------------------------------------------------------
// vppBltWriteDword
//      Fill a dword with data.  Self contained, for internal use only.  Useful
//      for writing data to video memory in win2k
void VppBltWriteDword(Vpp_t *pVpp, NvU32 dwOffset, NvU32 dwIndex, NvU32 dwData)
{
    Vpp_t &vpp = *pVpp;
    NvU32 dwCombinedPitch;

    vpp.pDriverData->blitCalled = TRUE;             // TBD: see that this is used or ignored properly in NT4 @mjl@
    vpp.pDriverData->TwoDRenderingOccurred = 1;

    // make sure we sync with other channels before writing put
    vpp.pPusher->setSyncChannelFlag();

    vppBltUpdateClip(pVpp);

    // source key is disabled
    if (vpp.pDriverData->bltData.dwLastColourKey != 0xFFFFFFFF) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.spareSubCh) | 0x40000);
        vpp.pPusher->push(1, vpp.hContextColorKey);
        vpp.pPusher->push(2, SUB_CHANNEL(vpp.spareSubCh) | SET_TRANSCOLOR_OFFSET | 0x40000);
        vpp.pPusher->push(3, 0);
        vpp.pPusher->adjust(4);
        vpp.pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
        vpp.pDriverData->dDrawSpareSubchannelObject = vpp.hContextColorKey;
    }

    // ROP is always SRCCOPY
    if (vpp.pDriverData->bltData.dwLastRop != SRCCOPYINDEX) {
        vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropSubCh) | SET_ROP_OFFSET | 0x40000);
        vpp.pPusher->push(1, SRCCOPYINDEX);
        vpp.pPusher->adjust(2);
        vpp.pDriverData->bltData.dwLastRop = SRCCOPYINDEX;
    }

    // set surfaces2D
    dwCombinedPitch = ((vpp.pDriverData->dwSurfaceAlignPad + 1) << 16) | (vpp.pDriverData->dwSurfaceAlignPad + 1);
    if (vpp.pDriverData->bltData.dwLastColourFormat != NV062_SET_COLOR_FORMAT_LE_Y32 ||
        vpp.pDriverData->bltData.dwLastCombinedPitch != dwCombinedPitch ||
        vpp.pDriverData->bltData.dwLastSrcOffset != dwOffset ||
        vpp.pDriverData->bltData.dwLastDstOffset != dwOffset) {

        vpp.pPusher->push(0, SUB_CHANNEL(vpp.surfaces2DSubCh) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
        vpp.pPusher->push(1, NV062_SET_COLOR_FORMAT_LE_Y32);   // SetColorFormat
        vpp.pPusher->push(2, dwCombinedPitch);                 // SetPitch
        vpp.pPusher->push(3, dwOffset);                        // SetSrcOffset
        vpp.pPusher->push(4, dwOffset);                        // SetDstOffset
        vpp.pPusher->adjust(5);
        vpp.pDriverData->bltData.dwLastColourFormat = NV062_SET_COLOR_FORMAT_LE_Y32;
        vpp.pDriverData->bltData.dwLastCombinedPitch = dwCombinedPitch;
        vpp.pDriverData->bltData.dwLastSrcOffset = dwOffset;
        vpp.pDriverData->bltData.dwLastDstOffset = dwOffset;
    }

    vpp.pPusher->push(0, SUB_CHANNEL(vpp.ropRectTextSubCh) | RECT_AND_TEXT_COLOR1A_OFFSET | 0xC0000);
    vpp.pPusher->push(1, dwData);
    vpp.pPusher->push(2, asmMergeCoords(0, dwIndex));
    vpp.pPusher->push(3, asmMergeCoords(1, 1));
    vpp.pPusher->adjust(4);

    vpp.pPusher->flush (TRUE, CPushBuffer::FLUSH_WITH_DELAY);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\src\vpcompilex86.c ===
/*
 * nv10vpexec.c
 *
 * Copyright 2000 NVIDIA, Corporation.  All rights reserved.
 * 
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */

/*
** This file is shared between OpenGL and D3D so don't mess with it!
*/

/*
** This file should only be compiled if it's needed.  The normal OpenGL ifdefs:
**
**      #if defined(GL_NV_vertex_program) && __NV_ACCEL>=10
**      #ifdef __GL_USE_OG_INTEL_ASM
**
** and any OpenGL includes like:
**
**      #include "context.h"
**
** can't be used since this is used by D3D as well.
**
*/

#include <stddef.h>
#include <float.h>

#if defined(IS_OPENGL)
#include "nvassert.h"
#else
//#define assert()
#endif

#include "vtxpgmconsts.h"
#include "vtxpgmcomp.h"
#include "x86.h"

#if !defined(FALSE)
#define FALSE 0
#endif

#if !defined(TRUE)
#define TRUE 1
#endif

#if !defined(VIEW_AS_INT)
#define VIEW_AS_INT(x) (*(int *) &(x))
#endif

#define INCLUDE_MULTIPLY_BY_ZERO_CODE 1

#define FIX_SLT_ZERO_COMPARE 1

typedef enum ExprKind_Enum {
    E_NONE, E_MEM, E_MEMIX, E_IREG, E_FREG, E_AREG,
} ExprKind;

// Scalar types:

typedef struct ExprMem_Rec {
    ExprKind kind;
    int offset;
    int Negate;
} ExprMem;

typedef struct ExprAReg_Rec {
    ExprKind kind;
} ExprAReg;

typedef struct ExprIReg_Rec {
    ExprKind kind;
    int regNo;
} ExprIReg;

typedef struct ExprFReg_Rec {
    ExprKind kind;
    int regNo;
} ExprFReg;

typedef union Expr_Rec {
    ExprKind kind;
    ExprMem eMem;
    ExprAReg aReg;
    ExprIReg iReg;
    ExprFReg fReg;
} Expr;

// Vector types:

typedef struct Vector_Rec {
    Expr x;
    Expr y;
    Expr z;
    Expr w;
} Vector;

typedef struct Code_Rec {
    unsigned int ilcCount, ilcMax;
    unsigned char *ilcData;
    VtxProgCompileX86 *environment;
} Code;

typedef struct Coord_Rec {
    float x, y, z, w;
} Coord;

#if defined(IS_OPENGL)
    #define FP_BITS_LOG0 0xFF800000 // use -inf
#else
    #define FP_BITS_LOG0 0xFF7FFFFF // use a large negative number
#endif

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#define OP_LIT_128_MINUS_EPSILON (128.0f - 1.0f/256.0f)
#define F_EXP_BIAS 127
#define LOCAL_VAR_SIZE 32

struct VtxProgImports_Rec VtxProgImports;

static char watermark[] = "wa\0\0t\2\ffer\0\0\0ma\0\ff\frk\0\0#0";

int __internal_setup(int i) { return watermark[i]; }

/*
** lLitOpFun()
*/

#if defined(IS_OPENGL)
static void lLitOpFun(Coord *a)
#else
static void _cdecl lLitOpFun(Coord *a)
#endif
{
    Coord *t = a + 1;
    float x, y, w;

    //if (vinst->dst.mask & DST_X_BIT)
        t->x = 1.0f;
    //if (vinst->dst.mask & (DST_Y_BIT | DST_Z_BIT)) {
    //    if (vinst->src.Signed) {
    //        x = -a->x;
    //        y = -a->y;
    //        w = -a->w;
    //    } else {
            x = a->x;
            y = a->y;
            w = a->w;
    //    }
        if (x < 0.0f)
            x = 0.0f;
        if (y < 0.0f)
            y = 0.0f;
    //    if (vinst->dst.mask & DST_Y_BIT)
            t->y = x;
    //    if (vinst->dst.mask & DST_Z_BIT) {
            if (x > 0.0f) {
                if (y == 0.0f) {
                    if (w == 0.0f) {
                        t->z = 1.0f;
                    } else {
                        t->z = 0.0f;
                    }
                } else {
                    if (w > OP_LIT_128_MINUS_EPSILON) {
                        w = OP_LIT_128_MINUS_EPSILON;
                    } else {
                        if (w < -OP_LIT_128_MINUS_EPSILON) {
                            w = -OP_LIT_128_MINUS_EPSILON;
                        }
                    }
                    t->z = VtxProgImports.expf(w*VtxProgImports.logf(y));
                    //////////////t->z = __GL_EXPF(w*__GL_LOGF(y));
                }
            } else {
                t->z = 0.0f;
            }
    //    }
    //}
    //if (vinst->dst.mask & DST_W_BIT)
        t->w = 1.0f;
} // lLitOpFun

///////////////////////////////////////////////////////////////////////////////

/*
** lIsNegated()
*/

static int lIsNegated(Vector *v)
{
    if (v->x.kind == E_MEM || v->x.kind == E_MEMIX) {
        return v->x.eMem.Negate;
    } else {
        return FALSE;
    }
} // lIsNegated
  
/*
** lGenSrcReg()
*/

static void lGenSrcReg(VtxProgCompileX86 *env, Expr *v, SrcReg *r)
{
    int lreg = r->reg;

    switch (lreg) {
    case VA_0:  case VA_1:  case VA_2:  case VA_3:
    case VA_4:  case VA_5:  case VA_6:  case VA_7:
    case VA_8:  case VA_9:  case VA_10: case VA_11:
    case VA_12: case VA_13: case VA_14: case VA_15:
        v->kind = E_MEM;
        v->eMem.offset = (lreg - VA_0)*sizeof(float)*4 + env->attrib_offset;
        v->eMem.Negate = FALSE;
        break;
    case VR_0:  case VR_1:  case VR_2:  case VR_3:
    case VR_4:  case VR_5:  case VR_6:  case VR_7:
    case VR_8:  case VR_9:  case VR_10: case VR_11:
    case VR_12: case VR_13: case VR_14: case VR_15:
        v->kind = E_MEM;
        v->eMem.offset = (lreg - VR_0)*sizeof(float)*4 + env->result_offset;
        v->eMem.Negate = FALSE;
        break;
    case ARL:
        v->kind = E_AREG;
        break;
    case PR_0:  case PR_1:  case PR_2:  case PR_3:
    case PR_4:  case PR_5:  case PR_6:  case PR_7:
    case PR_8:  case PR_9:  case PR_10: case PR_11:
    case PR_12: case PR_13: case PR_14: case PR_15:
    case PR_16: case PR_17: case PR_18: case PR_19:
    case PR_20: case PR_21: case PR_22: case PR_23:
    case PR_24: case PR_25: case PR_26: case PR_27:
    case PR_28: case PR_29: case PR_30: case PR_31:
    case PR_32: case PR_33: case PR_34: case PR_35:
    case PR_36: case PR_37: case PR_38: case PR_39:
    case PR_40: case PR_41: case PR_42: case PR_43:
    case PR_44: case PR_45: case PR_46: case PR_47:
    case PR_48: case PR_49: case PR_50: case PR_51:
    case PR_52: case PR_53: case PR_54: case PR_55:
    case PR_56: case PR_57: case PR_58: case PR_59:
    case PR_60: case PR_61: case PR_62: case PR_63:
    case PR_64: case PR_65: case PR_66: case PR_67:
    case PR_68: case PR_69: case PR_70: case PR_71:
    case PR_72: case PR_73: case PR_74: case PR_75:
    case PR_76: case PR_77: case PR_78: case PR_79:
    case PR_80: case PR_81: case PR_82: case PR_83:
    case PR_84: case PR_85: case PR_86: case PR_87:
    case PR_88: case PR_89: case PR_90: case PR_91:
    case PR_92: case PR_93: case PR_94: case PR_95:
        if (r->AddrReg) {
            v->kind = E_MEMIX;
            v->eMem.offset = r->addrRegOffset*sizeof(float)*4 + env->param_offset;
            v->eMem.Negate = FALSE;
        } else {
            v->kind = E_MEM;
            v->eMem.offset = (lreg - PR_0)*sizeof(float)*4 + env->param_offset;
            v->eMem.Negate = FALSE;
        }
        break;
    case TR_0:  case TR_1:  case TR_2:  case TR_3:
    case TR_4:  case TR_5:  case TR_6:  case TR_7:
    case TR_8:  case TR_9:  case TR_10: case TR_11:
    case TR_12: case TR_13: case TR_14: case TR_15:
        v->kind = E_MEM;
        v->eMem.offset = (lreg - TR_0)*sizeof(float)*4 + env->temp_offset;
        v->eMem.Negate = FALSE;
        break;
    default:
        assert(!"lGenSrcReg() - Bad register number");
        break;
    }
} // lGenSrcReg

/*
** lGenDstReg()
*/

static void lGenDstReg(VtxProgCompileX86 *env, Expr *v, Register_t freg)
{
    switch (freg) {
    case VA_0:  case VA_1:  case VA_2:  case VA_3:
    case VA_4:  case VA_5:  case VA_6:  case VA_7:
    case VA_8:  case VA_9:  case VA_10: case VA_11:
    case VA_12: case VA_13: case VA_14: case VA_15:
        v->kind = E_MEM;
        v->eMem.offset = (freg - VA_0)*sizeof(float)*4 + env->attrib_offset;
        v->eMem.Negate = FALSE;
        break;
    case VR_0:  case VR_1:  case VR_2:  case VR_3:
    case VR_4:  case VR_5:  case VR_6:  case VR_7:
    case VR_8:  case VR_9:  case VR_10: case VR_11:
    case VR_12: case VR_13: case VR_14: case VR_15:
        v->kind = E_MEM;
        v->eMem.offset = (freg - VR_0)*sizeof(float)*4 + env->result_offset;
        v->eMem.Negate = FALSE;
        break;
    case ARL:
        v->kind = E_AREG;
    case PR_0:  case PR_1:  case PR_2:  case PR_3:
    case PR_4:  case PR_5:  case PR_6:  case PR_7:
    case PR_8:  case PR_9:  case PR_10: case PR_11:
    case PR_12: case PR_13: case PR_14: case PR_15:
    case PR_16: case PR_17: case PR_18: case PR_19:
    case PR_20: case PR_21: case PR_22: case PR_23:
    case PR_24: case PR_25: case PR_26: case PR_27:
    case PR_28: case PR_29: case PR_30: case PR_31:
    case PR_32: case PR_33: case PR_34: case PR_35:
    case PR_36: case PR_37: case PR_38: case PR_39:
    case PR_40: case PR_41: case PR_42: case PR_43:
    case PR_44: case PR_45: case PR_46: case PR_47:
    case PR_48: case PR_49: case PR_50: case PR_51:
    case PR_52: case PR_53: case PR_54: case PR_55:
    case PR_56: case PR_57: case PR_58: case PR_59:
    case PR_60: case PR_61: case PR_62: case PR_63:
    case PR_64: case PR_65: case PR_66: case PR_67:
    case PR_68: case PR_69: case PR_70: case PR_71:
    case PR_72: case PR_73: case PR_74: case PR_75:
    case PR_76: case PR_77: case PR_78: case PR_79:
    case PR_80: case PR_81: case PR_82: case PR_83:
    case PR_84: case PR_85: case PR_86: case PR_87:
    case PR_88: case PR_89: case PR_90: case PR_91:
    case PR_92: case PR_93: case PR_94: case PR_95:
        v->kind = E_MEM;
        v->eMem.offset = (freg - PR_0)*sizeof(float)*4 + env->param_offset;
        v->eMem.Negate = FALSE;
        break;
    case TR_0:  case TR_1:  case TR_2:  case TR_3:
    case TR_4:  case TR_5:  case TR_6:  case TR_7:
    case TR_8:  case TR_9:  case TR_10: case TR_11:
    case TR_12: case TR_13: case TR_14: case TR_15:
        v->kind = E_MEM;
        v->eMem.offset = (freg - TR_0)*sizeof(float)*4 + env->temp_offset;
        v->eMem.Negate = FALSE;
        break;
    default:
        assert(!"lGenDstReg() - Bad register number");
        break;
    }
} // lGenDstReg

/*
** lGenAddOffset()
*/

static void lGenAddOffset(Expr *e, int fOffset)
{
    switch (e->kind) {
    case E_IREG:
    case E_FREG:
        assert(!"lGenAddOffset(I/FREG)");
        break;
    case E_MEM:
    case E_MEMIX:
        e->eMem.offset += fOffset;
        break;
    default:
        assert(!"lGenAddOffset()");
        break;
    }
} // lGenAddOffset

//////////////////////// X86 Code Generation Functions ////////////////////////

/*
** lGenLoadIReg()
*/

static void lGenLoadIReg(Code *fCode, Expr *e, int DoNegate)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_IREG:
        break;
    case E_FREG:
        assert(!"lGenLoadIReg(E_FREG)");
        break;
    case E_MEM:
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(e->eMem.offset);  // mov  eax, offset[gc]
            if (DoNegate && e->eMem.Negate) {
                xXOR_rm_imm(rmREG(rEAX), 0x80000000);               // xor  eax, 0x80000000
            }
            e->kind = E_IREG;
            e->iReg.regNo = rEAX;
        break;
    case E_MEMIX:
            xMOV_r_rm(rEAX, rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);  // mov  eax, offset[gc,esi]
            if (DoNegate && e->eMem.Negate) {
                xXOR_rm_imm(rmREG(rEAX), 0x80000000);               // xor  eax, 0x80000000
            }
            e->kind = E_IREG;
            e->iReg.regNo = rEAX;
        break;
    default:
        assert(!"lGenLoadIReg()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenLoadIReg

/*
** lGenLoad()
*/

static void lGenLoad(Code *fCode, Expr *e, int IRegOK, int DoNegate)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_IREG:
        if (!IRegOK)
            assert(!"lGenLoad(E_IREG, FLOAT)");
        break;
    case E_FREG:
        break;
    case E_MEM:
        if (IRegOK) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(e->eMem.offset);  // mov  eax, offset[gc]
            if (DoNegate && e->eMem.Negate) {
                xXOR_rm_imm(rmREG(rEAX), 0x80000000);               // xor  eax, 0x80000000
            }
            e->kind = E_IREG;
            e->iReg.regNo = rEAX;
        } else {
            xFLD_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);          // fld  offset[gc]
            if (DoNegate && e->eMem.Negate) {
                xFCHS;                                              // xchs
            }
            e->kind = E_FREG;
        }            
        break;
    case E_MEMIX:
            xFLD_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);    // fld  offset[gc,esi]
            if (DoNegate && e->eMem.Negate) {
                xFCHS;                                              // xchs
            }
            e->kind = E_FREG;
        break;
    default:
        assert(!"lGenLoad()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenLoad

/*
** lGenStore()
*/

static void lGenStore(Code *fCode, Expr *v, Expr *e, int DontFree)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (v->kind) {
    case E_MEM:
        switch (e->kind) {
        case E_IREG:
            xMOV_rm_r(rmIND32(rEBX), e->iReg.regNo) xOFS32(v->eMem.offset); // mov  offset[gc], eReg
            break;
        case E_FREG:
            if (DontFree) {
                xFST_rm(rmIND32(rEBX)) xOFS32(v->eMem.offset);              // fst  offset[gc]
            } else {
                xFSTP_rm(rmIND32(rEBX)) xOFS32(v->eMem.offset);             // fstp offset[gc]
            }
            break;
        default:
            assert(!"lGenStore(E_MEM, BAD)");
        }
        break;
    default:
        assert(!"lGenStore()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenStore

/*
** lGenNop() - Insert NOP instruction.
*/

static void lGenNop(Code *fCode)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xNOP;       // nop
    X86_CODE_RESTORE(fCode);
} // lGenNop

/*
** lGenChs() - Change Sign of TOS.
*/

static void lGenChs(Code *fCode)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xFCHS;      // xchs
    X86_CODE_RESTORE(fCode);
} // lGenChs

/*
** lGenFxch() - Swap TOS with TOS - 1.
*/

static void lGenFxch(Code *fCode)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xFXCH_st(1);        // fxch
    X86_CODE_RESTORE(fCode);
} // lGenFxch

/*
** lGenAdd() - Add E to TOS.
*/

static void lGenAdd(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        xFADDP_st(1);   // faddp st(1)
        break;
    case E_MEM:
        xFADD_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);         // fadd  offset[gc]
        break;
    case E_MEMIX:
        xFADD_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);   // fadd  offset[gc,esi]
        break;
    default:
        assert(!"lGenAdd()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenAdd

/*
** lGenSub() - Subtract E from TOS.
*/

static void lGenSub(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        xFSUBP_st(1);   // fsubp st(1)
        break;
    case E_MEM:
        xFSUB_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);         // fsub  offset[gc]
        break;
    case E_MEMIX:
        xFSUB_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);   // fsub  offset[gc,esi]
        break;
    default:
        assert(!"lGenSub()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenSub

/*
** lGenSubR() - Reverse Subtract E from TOS.
*/

static void lGenSubR(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        xFSUBRP_st(1);   // fsubrp st(1)
        break;
    case E_MEM:
        xFSUBR_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);        // fsubr  offset[gc]
        break;
    case E_MEMIX:
        xFSUBR_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);  // fsubr  offset[gc,esi]
        break;
    default:
        assert(!"lGenAdd()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenSubR

/*
** lGenAddVariant() - Add E to TOS, possibly negating either or both.
*/

static void lGenAddVariant(Code *fCode, Expr *e, int NegateA, int NegateB)
{
    if (NegateA) {
        if (NegateB) {
            lGenAdd(fCode, e);
            lGenChs(fCode);
        } else {
            lGenSubR(fCode, e);
        }
    } else {
        if (NegateB) {
            lGenSub(fCode, e);
        } else {
            lGenAdd(fCode, e);
        }
    }
} // lGenAddVariant

/*
** lGenFcomp() - Compare E to TOS.  Pop everything.
*/

static void lGenFcomp(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        xFCOMPP();                                          // fcompp
        break;
    case E_MEM:
        xFCOMP_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);        // fcomp  offset[gc]
        break;
    case E_MEMIX:
        xFCOMP_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);  // fcomp  offset[gc,esi]
        break;
    default:
        assert(!"lGenFcomp()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenFcomp

/*
** lGenPushFloatComp() - Push a 1.0 or 0.0 on the stack based on fpcc.
**         Uses 0[esp] to move data to fp stack.
*/

static void lGenPushFloatComp(Code *fCode, int fmask, int fSNZ)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xFNSTSW;                            // fnstsw ax
    xTEST_rm_imm8(rmREG(rAH), fmask);   // test   ah, mask
    if (fSNZ) {
        xSETNZ_rm8(rmREG(rEAX));        // setnz al
    } else {
        xSETZ_rm8(rmREG(rEAX));         // setz  al
    }
    xAND_rm_imm(rmREG(rEAX), 1);        // and   eax, 1
    xMOV_rm_r(rmSIB, rEAX) xSIB_esp;    // mov   [esp], eax
    xFILD_rm(rmSIB) xSIB_esp;           // fild  [esp]
    X86_CODE_RESTORE(fCode);
} // lGenPushFloatComp

#if defined(FIX_SLT_ZERO_COMPARE)

/*
** lGenSgeVariantSignedZero() - Compare EAX to +/-E treating +0.0 > -0.0 and return
**         a 1.0 or 0.0 on TOS.  Use SLT or SGE depending on IsSLT.
**
** Method: Xor sign bit with the lower 31 bits and use signed int compare.
**         Sign/Magnitude int shown.  Also works for fp. Sign/BiasedExp/Mantissa.
**
**  Value   S/M   Mask  xor(MSK,Val)  Value
**    1     001    000       001        1
**   +0     000    000       000        0
**   -0     100    011       111       -1
**   -1     101    011       110       -2
*/

static void lGenSgeVariantSignedZero(Code *fCode, Expr *e, int NegateE, int IsSLT)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);

    // Convert EAX arg into EDX:

    xMOV_rm_r(rmREG(rEDX), rEAX);       // mov edx, eax
    xSAR_rm_imm8(rmREG(rEDX), 30);      // sar edx, 30
    xSHR_rm_1(rmREG(rEDX));             // shr edx
    xXOR_rm_r(rmREG(rEDX), rEAX);       // xor edx, eax

    // Load second arg int EAX and convert using ECX as scratch:

    X86_CODE_RESTORE(fCode);
    lGenLoadIReg(fCode, e, NegateE);
    X86_CODE_LOAD(fCode);

    xMOV_rm_r(rmREG(rECX), rEAX);       // mov ecx, eax
    xSAR_rm_imm8(rmREG(rECX), 30);      // sar ecx, 30
    xSHR_rm_1(rmREG(rECX));             // shr ecx
    xXOR_rm_r(rmREG(rEAX), rECX);       // xor eax, ecx

    // Compare and use SLT or SGE to get result:

    xXOR_rm_r(rmREG(rECX), rECX);       // xor ecx, ecx ; For result
    xCMP_r_rm(rEDX, rmREG(rEAX));       // cmp eax, edx
    if (IsSLT) {
        xSETL_rm8(rmREG(rCL));          // setl cl
    } else {
        xSETGE_rm8(rmREG(rCL));         // setge cl
    }

    // Load the sucker onto the fp stack:

    xMOV_rm_r(rmSIB, rECX) xSIB_esp;    // mov   [esp], ecx
    xFILD_rm(rmSIB) xSIB_esp;           // fild  [esp]

    X86_CODE_RESTORE(fCode);
} // lGenSgeVariantSignedZero

#else // defined(FIX_SLT_ZERO_COMPARE)

/*
** lGenSgeVariant() - Compare E to TOS and return a 1 if GE, else a 0.
**
**        Possibly negating either or both arg.
*/

static void lGenSgeVariant(Code *fCode, Expr *e, int NegateA, int NegateB, int IsSLT)
{
    if (NegateA) {
        lGenChs(fCode);
        if (NegateB) {
            lGenLoad(fCode, e, FALSE, TRUE);
            lGenFxch(fCode);
            lGenFcomp(fCode, e);
        } else {
            lGenFcomp(fCode, e);
        }
    } else {
        if (NegateB) {
            lGenLoad(fCode, e, FALSE, TRUE);
            lGenFxch(fCode);
            lGenFcomp(fCode, e);
        } else {
            lGenFcomp(fCode, e);
        }
    }
    lGenPushFloatComp(fCode, 0x01, IsSLT);
} // lGenSgeVariant

#endif // defined(FIX_SLT_ZERO_COMPARE)

/*
** lGenMax() - Set TOS =  MAX(TOS, E).
*/

static void lGenMinMax(Code *fCode, Expr *e, int IsMax)
{
    X86_CODE_DECLARE;
    unsigned int loc;

    switch (e->kind) {
    case E_FREG:
        assert(!"lGenMinMax(E_FREG)");
        break;
    case E_MEM:
        lGenLoad(fCode, e, FALSE, TRUE);
        X86_CODE_LOAD(fCode);
        xFCOM_st(1);                            //      fcom   st(1)
        xFNSTSW;                                //      fnstsw ax
        if (IsMax) {
            xTEST_rm_imm8(rmREG(rAH), 0x41);    //      test   ah, 41  JLE (TOS <= st(1))
            xLABEL(loc);
            xJNZ(0);                            //      jne    lab
        } else {
            xTEST_rm_imm8(rmREG(rAH), 0x01);    //      test   ah, 01  JGE (TOS >= st(1))
            xLABEL(loc);
            xJZ(0);                             //      je     lab
        }
        xFXCH_st(1);                            //      fxch
        xTARGET_b8(loc);                        // lab:
        xFSTP_st(0);                            //      fstp   st(0)
        X86_CODE_RESTORE(fCode);
        break;
    default:
        assert(!"lGenMinMax()");
        break;
    }
} // lGenMinMax

/*
** lGenMul() - Multiply TOS by E.
*/

static void lGenMul(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        assert(!"lGenMul(E_FREG)");
        break;
    case E_MEM:
        xFMUL_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);         // fmul  offset[gc]
        break;
    case E_MEMIX:
        xFMUL_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);   // fmul  offset[gc,esi]
        break;
    default:
        assert(!"lGenMul()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenMul

#if defined(INCLUDE_MULTIPLY_BY_ZERO_CODE)

/*
** lGenTestForZeroMul() - Special case multiply:  If either value is +/- 0.0, result is 0.0
*/

static void lGenTestForZeroMul(Code *fCode, Expr *a, Expr *b, int FNegate)
{
    int zero1, zero2, done;
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (a->kind) {
    case E_IREG:
        assert(!"lGenTestForZeroMul(E_IREG)");
        break;
    case E_FREG:
        assert(!"lGenTestForZeroMul(E_FREG)");
        break;
    case E_MEM:
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(a->eMem.offset);       // mov eax, offset[gc]
        break;
    case E_MEMIX:
        xMOV_r_rm(rEAX, rmSIB32) xSIB32(rEBX, rESI, a->eMem.offset); // mov eax, offset[gc,esi]
        break;
    default:
        assert(!"lGenTestForZeroMul()");
        break;
    }
    // Mask off sign bit:
    xAND_rm_imm(rmREG(rEAX), 0x7fffffff);       //   and  eax, 0x7fffffff
    xLABEL(zero1);
    xJZ(0);                                     //   jz   zero

    switch (b->kind) {
    case E_IREG:
        assert(!"lGenTestForZeroMul(E_IREG)");
        break;
    case E_FREG:
        assert(!"lGenTestForZeroMul(E_FREG)");
        break;
    case E_MEM:
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(b->eMem.offset);       // mov eax, offset[gc]
        break;
    case E_MEMIX:
        xMOV_r_rm(rEAX, rmSIB32) xSIB32(rEBX, rESI, b->eMem.offset); // mov eax, offset[gc,esi]
        break;
    default:
        assert(!"lGenTestForZeroMul()");
        break;
    }
    // Mask off sign bit:
    xAND_rm_imm(rmREG(rEAX), 0x7fffffff);       //   and  eax, 0x7fffffff
    xLABEL(zero2);
    xJZ(0);                                     //   jz   zero
    X86_CODE_RESTORE(fCode);

    // Things are OK.  Do the multiply.

    lGenLoad(fCode, a, FALSE, FALSE);
    lGenMul(fCode, b);
    if (FNegate)
        lGenChs(fCode);

    X86_CODE_LOAD(fCode);
    xLABEL(done);
    xJMP8(0);
    xTARGET_b8(zero1);                         // zero:
    xTARGET_b8(zero2);                         // zero:
    xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_zero_offset); //   fld   gc->float_zero
    xTARGET_b8(done);                            // done:
    X86_CODE_RESTORE(fCode);
} // lGenTestForZeroMul

#endif // INCLUDE_MULTIPLY_BY_ZERO_CODE

/*
** lGenDivr() - Divide TOS into E.
*/

static void lGenDivr(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    switch (e->kind) {
    case E_FREG:
        assert(!"lGenDivr(E_FREG)");
        break;
    case E_MEM:
        xFDIVR_rm(rmIND32(rEBX)) xOFS32(e->eMem.offset);        // fdivr  offset[gc]
        break;
    case E_MEMIX:
        xFDIVR_rm(rmSIB32) xSIB32(rEBX, rESI, e->eMem.offset);  // fdivr  offset[gc,esi]
        break;
    default:
        assert(!"lGenDivr()");
        break;
    }
    X86_CODE_RESTORE(fCode);
} // lGenDivr

#if defined(NV_INTERNAL_OPCODES)

/*
** lGenRccr() - Divide TOS into E, clamped.
*/

static void lGenRccr(Code *fCode, Expr *e)
{
    X86_CODE_DECLARE;
    int test_neg, get_answer, done;

    // TOS = 1.0f/x;

    lGenDivr(fCode, e);

    X86_CODE_LOAD(fCode);

    // iexp = ((VIEW_AS_INT(f) & 0x7f800000) >> 23) - F_EXP_BIAS;
    // if (iexp >= 64) {
    //     VIEW_AS_INT(f) = ((64 + F_EXP_BIAS) << 23) |
    //                           (VIEW_AS_INT(f) & 0x80000000);
    // } else {
    //     if (iexp <= -64) {
    //         VIEW_AS_INT(f) = ((-64 + F_EXP_BIAS) << 23) |
    //                               (VIEW_AS_INT(f) & 0x80000000);
    //     }
    // }

    xFST_rm(rmSIB) xSIB_esp;                    //    fst  [esp]
    xMOV_r_rm(rEAX, rmSIB) xSIB_esp;            //    mov  eax, [esp]
    xAND_rm_imm(rmREG(rEAX), 0x7fffffff);       //    and  eax, 0x7fffffff

    // Clamp min magnitude to 0x1f800000;

    xCMP_rm_imm(rmREG(rEAX), 0x1f800000);       //    cmp  eax, 0x1f800000
    xLABEL(test_neg);
    xJG(0)                                      //    jl   test_neg
    xMOV_r_rm(rEAX, rmSIB) xSIB_esp;            //    mov  eax, [esp]
    xAND_rm_imm(rmREG(rEAX), 0x80000000);       //    and  eax, 0x80000000
    xOR_rm_imm(rmREG(rEAX), 0x1f800000);        //    or   eax, 0x1f800000
    xLABEL(get_answer);
    xJMP8(0);                                   //    jmp  get_answer

    // Clamp max magnitude to 0x5f800000;

    xTARGET_b8(test_neg);                       // test_neg:
    xCMP_rm_imm(rmREG(rEAX), 0x5f800000);       //    cmp  eax, 0x5f800000
    xLABEL(done);
    xJL(0)                                      //    jl   done
    xMOV_r_rm(rEAX, rmSIB) xSIB_esp;            //    mov  eax, [esp]
    xAND_rm_imm(rmREG(rEAX), 0x80000000);       //    and  eax, 0x80000000
    xOR_rm_imm(rmREG(rEAX), 0x5f800000);        //    or   eax, 0x5f800000

    xTARGET_b8(get_answer);                     // get_answer:
    xMOV_rm_r(rmSIB, rEAX) xSIB_esp;            //    mov  eax, [esp]
    xFSTP_st(0);                                //    fstp st(0)
    xFLD_rm(rmSIB) xSIB_esp;                    //    fld  [esp]

    // Answer in TOS:

    xTARGET_b8(done);                            // done:

    X86_CODE_RESTORE(fCode);
} // lGenRccr
#endif // NV_INTERNAL_OPCODES

/*
** lGenAbsSqrt() - Take the Square Root of ABS(TOS).
*/

static void lGenAbsSqrt(Code *fCode)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xFABS();
    xFSQRT();
    X86_CODE_RESTORE(fCode);
} // lGenSqrt

/*
** lGenIFloor() - ireg = ifloor(TOS).  Pops TOS and scratches esp(0-7).
**
** Arguments:
**     [tos]  = x
**
** Results:
**     [esp]  = floor(x)
**
** Scratches:
*/

static void lGenIFloor(Code *fCode, int iReg, int PopFP)
{
    X86_CODE_DECLARE;

    X86_CODE_LOAD(fCode);
    xMOV_rm_imm(rmREG(iReg), 0x047f);   // mov   iReg, 0x047f ; Round -INF, 24b
    xMOV_rm_r(rmSIB, iReg) xSIB_esp;    // mov   [esp], iReg
    xFSTCW_rm(rmSIB8) xSIB8_esp(4);     // fstcw 4[esp]     ; Save old FPCW
    xFLDCW_rm(rmSIB) xSIB_esp;          // fldcw [esp]      ; Load Round -INF, 24
    if (PopFP) {
        xFISTP_rm(rmSIB) xSIB_esp;      // fistp [esp]      ; floor(x)
    } else {
        xFIST_rm(rmSIB) xSIB_esp;       // fist  [esp]      ; floor(x)
    }
    xFLDCW_rm(rmSIB8) xSIB8_esp(4);     // fldcw 4[esp]     ; Restore FPCW
//  xMOV_r_rm(iReg, rmSIB) xSIB_esp;    // mov   iReg, [esp]
    X86_CODE_RESTORE(fCode);
} // lGenIFloor

////////////////////////// NV20 Level Code Generation /////////////////////////

/*
** lGenFloatOne()
*/

static void lGenFloatOne(VtxProgCompileX86 *env, Expr *r)
{
    r->kind = E_MEM;
    r->eMem.Negate = FALSE;
    r->eMem.offset = env->float_one_offset;
} // lGenFloatOne

/*
** lGenScalarSrcReg()
*/

static void lGenScalarSrcReg(VtxProgCompileX86 *env, Expr *r, ScalarSrcReg *reg)
{
    Expr v;
    int ii;

    lGenSrcReg(env, &v, &reg->reg);
    switch (v.kind) {
    case E_MEM:
        r->kind = E_MEM;
        r->eMem.Negate = reg->Signed;
        ii = reg->com;
        r->eMem.offset = v.eMem.offset + (ii & 3)*sizeof(float);
        break;
    default:
        assert(!"lGenScalarSrcReg()");
        break;
    }
} // lGenScalarSrcReg

/*
** lGenSwizzleSrcReg()
*/

static void lGenSwizzleSrcReg(VtxProgCompileX86 *env, Vector *a, SwizzleSrcReg *reg)
{
    Expr v;
    int ii;

    lGenSrcReg(env, &v, &reg->reg);
    switch (v.kind) {
    case E_MEM:
        a->x.kind = a->y.kind = a->z.kind = a->w.kind = E_MEM;
        a->x.eMem.Negate = a->y.eMem.Negate = a->z.eMem.Negate = a->w.eMem.Negate = reg->Signed;
        ii = reg->com4;
        a->x.eMem.offset = v.eMem.offset + (ii & 3)*sizeof(float);
        a->y.eMem.offset = v.eMem.offset + ((ii >> 2) & 3)*sizeof(float);
        a->z.eMem.offset = v.eMem.offset + ((ii >> 4) & 3)*sizeof(float);
        a->w.eMem.offset = v.eMem.offset + ((ii >> 6) & 3)*sizeof(float);
        break;
    case E_MEMIX:
        a->x.kind = a->y.kind = a->z.kind = a->w.kind = E_MEMIX;
        a->x.eMem.Negate = a->y.eMem.Negate = a->z.eMem.Negate = a->w.eMem.Negate = reg->Signed;
        ii = reg->com4;
        a->x.eMem.offset = v.eMem.offset + (ii & 3)*sizeof(float);
        a->y.eMem.offset = v.eMem.offset + ((ii >> 2) & 3)*sizeof(float);
        a->z.eMem.offset = v.eMem.offset + ((ii >> 4) & 3)*sizeof(float);
        a->w.eMem.offset = v.eMem.offset + ((ii >> 6) & 3)*sizeof(float);
        break;
    default:
        assert(!"lGenSwizzleSrcReg()");
        break;
    }
} // lGenSwizzleSrcReg

/*
** lGenStoreMaskedDstReg()
*/

static void lGenStoreMaskedDstReg(Code *fCode, MaskedDstReg *reg, Vector *a)
{
    int lmask = reg->mask;
    Expr v;

    lGenDstReg(fCode->environment, &v, reg->reg);
    lGenAddOffset(&v, 12);
    if (lmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, TRUE, TRUE);
        lGenStore(fCode, &v, &a->w, FALSE);
    }
    lGenAddOffset(&v, -4);
    if (lmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, TRUE, TRUE);
        lGenStore(fCode, &v, &a->z, FALSE);
    }
    lGenAddOffset(&v, -4);
    if (lmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, TRUE, TRUE);
        lGenStore(fCode, &v, &a->y, FALSE);
    }
    lGenAddOffset(&v, -4);
    if (lmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, TRUE, TRUE);
        lGenStore(fCode, &v, &a->x, FALSE);
    }
} // lGenStoreMaskedDstReg

/*
** lGenStoreMaskedDstRegScalar()
*/

static void lGenStoreMaskedDstRegScalar(Code *fCode, MaskedDstReg *reg, Expr *a)
{
    int lmask = reg->mask & DST_XYZW_BITS;
    Expr v;

    lGenDstReg(fCode->environment, &v, reg->reg);
    if (lmask & DST_X_BIT) {
        lmask &= ~DST_X_BIT;
        lGenLoad(fCode, a, TRUE, TRUE);
        lGenStore(fCode, &v, a, lmask);
    }
    lGenAddOffset(&v, 4);
    if (lmask & DST_Y_BIT) {
        lmask &= ~DST_Y_BIT;
        lGenLoad(fCode, a, TRUE, TRUE);
        lGenStore(fCode, &v, a, lmask);
    }
    lGenAddOffset(&v, 4);
    if (lmask & DST_Z_BIT) {
        lmask &= ~DST_Z_BIT;
        lGenLoad(fCode, a, TRUE, TRUE);
        lGenStore(fCode, &v, a, lmask);
    }
    lGenAddOffset(&v, 4);
    if (lmask & DST_W_BIT) {
        lGenLoad(fCode, a, TRUE, TRUE);
        lGenStore(fCode,&v, a, FALSE);
    }
} // lGenStoreMaskedDstRegScalar

/*
** lGenAddOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenAddOp(Code *fCode, Vector *r, Vector *a, Vector *b, int fmask)
{
    int NegateA = lIsNegated(a);
    int NegateB = lIsNegated(b);

    if (fmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, FALSE, FALSE);
        lGenAddVariant(fCode, &b->x, NegateA, NegateB);
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenAddVariant(fCode, &b->y, NegateA, NegateB);
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, FALSE);
        lGenAddVariant(fCode, &b->z, NegateA, NegateB);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenAddVariant(fCode, &b->w, NegateA, NegateB);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenAddOp

/*
** lGenAlrOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenAlrOp(Code *fCode, Expr *a)
{
    X86_CODE_DECLARE;
    int test_neg, done1, done2;

    assert(LOCAL_VAR_SIZE >= 8);

    // Min usable value: -63, since A0.x+63 -> 0
    // Max usable value: 159, since A0.x-64 -> 95  (159 = 95 + 64)
    // Out of range values changed to -64, so we can index full speed
    // into 128 registers of 0's that are padded on each end.

    lGenLoad(fCode, a, FALSE, TRUE);
    lGenIFloor(fCode, rESI, 1);
    X86_CODE_LOAD(fCode);
    xMOV_r_rm(rESI, rmSIB) xSIB_esp;//   mov   esi, [esp]

    xCMP_rm_imm(rmREG(rESI), 159);  //   cmp  esi, 159 ; Is value > 159?
    xLABEL(test_neg);
    xJLE(0);                        //   jle  test_neg
    xMOV_rm_imm(rmREG(rESI), -64);  //   mov  esi, -64
    xLABEL(done1);
    xJMP8(0);                       //   jmp  get_answer

    xTARGET_b8(test_neg);           // test_neg:
    xCMP_rm_imm(rmREG(rESI), -63);  //   cmp  esi, -63 ; Is value < -63?
    xLABEL(done2);
    xJGE(0);                        //   jge  test_neg
    xMOV_rm_imm(rmREG(rESI), -64);  //   mov  esi, -64

    xTARGET_b8(done1);              // done:
    xTARGET_b8(done2);
    xSHL_rm_imm8(rmREG(rESI), 4);   //   shl  esi, 4  ; 16 bytes/register
    X86_CODE_RESTORE(fCode);
} // lGenAlrOp

/*
** lGenDotProductOp() - Simple version:  Assumes all args in memory, leaves result on TOS
*/

static void lGenDotProductOp(Code *fCode, Expr *v, Vector *a, Vector *b, int size)
{
    int Negate = lIsNegated(a) ^ lIsNegated(b);

    lGenLoad(fCode, &a->x, FALSE, FALSE);
    lGenMul(fCode, &b->x);

    lGenLoad(fCode, &a->y, FALSE, FALSE);
    lGenMul(fCode, &b->y);

    lGenLoad(fCode, &a->z, FALSE, FALSE);
    lGenMul(fCode, &b->z);

    if (size == 4) {
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenMul(fCode, &b->w);
        lGenAdd(fCode, &a->z);
    } else {
        if (size == 0) {
            // DPH
            lGenAdd(fCode, &b->w);
        }
    }

    lGenAdd(fCode, &a->y);
    lGenAdd(fCode, &a->x);
    if (Negate)
        lGenChs(fCode);

    v->kind = E_FREG;
    v->fReg.regNo = 0;
} // lGenDotProductOp

/*
** lGenDstOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenDstOp(Code *fCode, Vector *r, Vector *a, Vector *b, int fmask)
{
    X86_CODE_DECLARE;

    int NegateA = lIsNegated(a);
    int NegateB = lIsNegated(b);

    if (fmask & DST_X_BIT) {
        X86_CODE_LOAD(fCode);
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        X86_CODE_RESTORE(fCode);
        r->x.kind = E_FREG; // Could do: xor eax, eax
    } else {
        r->x.kind = E_NONE;
    }

    if (fmask & DST_Y_BIT) {
#if defined(INCLUDE_MULTIPLY_BY_ZERO_CODE)
        //
        // Special case multiply:  If either value is +/- 0.0, result is 0.0
        //

        lGenTestForZeroMul(fCode, &a->y, &b->y, NegateA ^ NegateB);
        r->y.kind = E_FREG;
#else
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenMul(fCode, &b->y);
        if (NegateA ^ NegateB)
            lGenChs(fCode);
        r->y.kind = E_FREG;
#endif // INCLUDE_MULTIPLY_BY_ZERO_CODE
    } else {
        r->y.kind = E_NONE;
    }

    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, TRUE);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }

    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &b->w, FALSE, TRUE);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenDstOp

/*
** lGenLitOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenLitOp(Code *fCode, Vector *r, Vector *a, int fmask)
{
    X86_CODE_DECLARE;

    // Create a temp area on the stack and store all args there:

    lGenLoad(fCode, &a->x, FALSE, TRUE);
    lGenLoad(fCode, &a->y, FALSE, TRUE);
    lGenLoad(fCode, &a->z, FALSE, TRUE);
    lGenLoad(fCode, &a->w, FALSE, TRUE);

    assert(LOCAL_VAR_SIZE >= 32);

    X86_CODE_LOAD(fCode);
    xFSTP_rm(rmSIB8) xSIB8_esp(12);             // fstp 12[esp]  w
    xFSTP_rm(rmSIB8) xSIB8_esp(8);              // fstp 8[esp]   z
    xFSTP_rm(rmSIB8) xSIB8_esp(4);              // fstp 4[esp]   y
    xFSTP_rm(rmSIB) xSIB_esp;                   // fstp [esp]    x

    // Call a "C" function to compute this one:

    xPUSH_r(rESP);                              // push esp
    xMOV_rm_imm(rmREG(rEAX), (int) &lLitOpFun); // mov  eax, &lLitOpFun
    xCALL_rm(rmREG(rEAX));
    xADD_rm_imm8(rmREG(rESP), 4);

    // Load the needed results and pop the stack:

    if (fmask & DST_X_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(16);          // fld  16[esp]  x' == 1.0f
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(20);          // fld  20[esp]  y'
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(24);          // fld  24[esp]  z'
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(28);          // fld  28[esp]  w' == 1.0f
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
    X86_CODE_RESTORE(fCode);

} // lGenLitOp

/*
** lGenMinMaxOp() - Simple version:  Assumes all args in memory,
**         leaves result on TOS.
*/

static void lGenMinMaxOp(Code *fCode, Vector *r, Vector *a,
                         Vector *b, int fmask, int IsMax)
{
    if (fmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, FALSE, TRUE);
        lGenMinMax(fCode, &b->x, IsMax);
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, FALSE, TRUE);
        lGenMinMax(fCode, &b->y, IsMax);
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, TRUE);
        lGenMinMax(fCode, &b->z, IsMax);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, FALSE, TRUE);
        lGenMinMax(fCode, &b->w, IsMax);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenMinMaxOp

/*
** lGenMulOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenMulOp(Code *fCode, Vector *r, Vector *a, Vector *b, int fmask)
{
    int Negate = lIsNegated(a) ^ lIsNegated(b);

    if (fmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, FALSE, FALSE);
        lGenMul(fCode, &b->x);
        if (Negate)
            lGenChs(fCode);
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenMul(fCode, &b->y);
        if (Negate)
            lGenChs(fCode);
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, FALSE);
        lGenMul(fCode, &b->z);
        if (Negate)
            lGenChs(fCode);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenMul(fCode, &b->w);
        if (Negate)
            lGenChs(fCode);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenMulOp

/*
** lGenSgeOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenSgeOp(Code *fCode, Vector *r, Vector *a, Vector *b, int fmask, int IsSLT)
{
    int NegateA = lIsNegated(a);
    int NegateB = lIsNegated(b);

    assert(LOCAL_VAR_SIZE >= 4);

    if (fmask & DST_X_BIT) {
#if defined(FIX_SLT_ZERO_COMPARE)
        lGenLoadIReg(fCode, &a->x, NegateA);
        lGenSgeVariantSignedZero(fCode, &b->x, NegateB, IsSLT);
#else
        lGenLoad(fCode, &a->x, FALSE, FALSE);
        lGenSgeVariant(fCode, &b->x, NegateA, NegateB, IsSLT);
#endif
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
#if defined(FIX_SLT_ZERO_COMPARE)
        lGenLoadIReg(fCode, &a->y, NegateA);
        lGenSgeVariantSignedZero(fCode, &b->y, NegateB, IsSLT);
#else
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenSgeVariant(fCode, &b->y, NegateA, NegateB, IsSLT);
#endif
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
#if defined(FIX_SLT_ZERO_COMPARE)
        lGenLoadIReg(fCode, &a->z, NegateA);
        lGenSgeVariantSignedZero(fCode, &b->z, NegateB, IsSLT);
#else
        lGenLoad(fCode, &a->z, FALSE, FALSE);
        lGenSgeVariant(fCode, &b->z, NegateA, NegateB, IsSLT);
#endif
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
#if defined(FIX_SLT_ZERO_COMPARE)
        lGenLoadIReg(fCode, &a->w, NegateA);
        lGenSgeVariantSignedZero(fCode, &b->w, NegateB, IsSLT);
#else
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenSgeVariant(fCode, &b->w, NegateA, NegateB, IsSLT);
#endif
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenSgeOp

/*
** lGenMadOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenMadOp(Code *fCode, Vector *r, Vector *a, Vector *b, Vector *c, int fmask)
{
    int NegateAB = lIsNegated(a) ^ lIsNegated(b), NegateC = lIsNegated(c);

    if (fmask & DST_X_BIT) {
        lGenLoad(fCode, &a->x, FALSE, FALSE);
        lGenMul(fCode, &b->x);
        lGenAddVariant(fCode, &c->x, NegateAB, NegateC);
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        lGenLoad(fCode, &a->y, FALSE, FALSE);
        lGenMul(fCode, &b->y);
        lGenAddVariant(fCode, &c->y, NegateAB, NegateC);
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        lGenLoad(fCode, &a->z, FALSE, FALSE);
        lGenMul(fCode, &b->z);
        lGenAddVariant(fCode, &c->z, NegateAB, NegateC);
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        lGenLoad(fCode, &a->w, FALSE, FALSE);
        lGenMul(fCode, &b->w);
        lGenAddVariant(fCode, &c->w, NegateAB, NegateC);
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
} // lGenMadOp

#if defined(NV_INTERNAL_OPCODES)

/*
** lGenRccOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenRccOp(Code *fCode, Expr *r, Expr *a)
{
    Expr e;

    lGenLoad(fCode, a, FALSE, TRUE);
    lGenFloatOne(fCode->environment, &e);
    lGenRccr(fCode, &e);
    r->kind = E_FREG;
} // lGenRccOp

#endif // NV_INTERNAL_OPCODES

/*
** lGenRcpOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenRcpOp(Code *fCode, Expr *r, Expr *a)
{
    Expr e;

    lGenLoad(fCode, a, FALSE, TRUE);
    lGenFloatOne(fCode->environment, &e);
    lGenDivr(fCode, &e);
    r->kind = E_FREG;
} // lGenRcpOp

/*
** lGenRsqOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenRsqOp(Code *fCode, Expr *r, Expr *a)
{
    Expr e;

    lGenLoad(fCode, a, FALSE, TRUE);
    lGenAbsSqrt(fCode);
    lGenFloatOne(fCode->environment, &e);
    lGenDivr(fCode, &e);
    r->kind = E_FREG;
} // lGenRsqOp

/*
** lGenLogOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenLogOp(Code *fCode, Vector *r, Expr *a, int fmask)
{
    X86_CODE_DECLARE;
    int zero, done;

    // Load x into EAX:

    lGenLoadIReg(fCode, a, FALSE);
    X86_CODE_LOAD(fCode);

    assert(LOCAL_VAR_SIZE >= 4);

    // Mask off sign bit:

    xAND_rm_imm(rmREG(rEAX), 0x7fffffff);       //   and  eax, 0x7fffffff
    xLABEL(zero);
    xJZ(0);                                     //   jz   zero

    // tr.x = ((VIEW_AS_INT(x) & 0x7f800000) >> 23) - F_EXP_BIAS;

    if (fmask & DST_X_BIT) {
        xMOV_r_rm(rEDX, rmREG(rEAX));           //   mov  edx, eax
        xSHR_rm_imm8(rmREG(rEDX), 23);          //   shr  edx, 23
        xSUB_rm_imm8(rmREG(rEDX), F_EXP_BIAS);  //   sub  edx, F_EXP_BIAS
        xMOV_rm_r(rmSIB, rEDX) xSIB_esp;        //   mov  [esp], edx
        xFILD_rm(rmSIB) xSIB_esp;               //   fild [esp]
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }

    // VIEW_AS_INT(tr.y) = (VIEW_AS_INT(x) & 0x007fffff) | 0x3f800000;

    if (fmask & DST_Y_BIT) {
        xMOV_r_rm(rEDX, rmREG(rEAX));           //   mov  edx, eax
        xAND_rm_imm(rmREG(rEDX), 0x007fffff);   //   and  edx, 0x007fffff
        xOR_rm_imm(rmREG(rEDX), 0x3f800000);    //   or   edx, 0x3f800000
        xMOV_rm_r(rmSIB, rEDX) xSIB_esp;        //   mov  [esp], edx
        xFLD_rm(rmSIB) xSIB_esp;                //   fld  [esp]
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }

    // tr.z = __GL_LOGF(x)*LOG_E_BASE_2;

    if (fmask & DST_Z_BIT) {
        xMOV_rm_r(rmSIB, rEAX) xSIB_esp;        //   mov  [esp], eax
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        xFLD_rm(rmSIB) xSIB_esp;                //   fld  [esp]
        xFYL2X();                               //   fyl2x
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    xLABEL(done);
    xJMP8(0);                                   //   jmp  done
    xTARGET_b8(zero);                           // zero:

    // tr.x = F_NEG_INFINITY;
                
    if (fmask & (DST_X_BIT | DST_Z_BIT)) {
        xMOV_rm_imm(rmREG(rEAX), FP_BITS_LOG0); //   mov  eax, 0xff800000
        xMOV_rm_r(rmSIB, rEAX) xSIB_esp;        //   mov  [esp], eax
    }

    if (fmask & DST_X_BIT) {
        xFLD_rm(rmSIB) xSIB_esp;                //   fld  [esp]
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }

    // tr.y = 1.0f;
                
    if (fmask & DST_Y_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }

    // tr.z = F_NEG_INFINITY;

    if (fmask & DST_Z_BIT) {
        xFLD_rm(rmSIB) xSIB_esp;                //   fld  [esp]
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }

    xTARGET_b8(done);                           // done:

    // tr.w = 1.0f;

    if (fmask & DST_W_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }

    X86_CODE_RESTORE(fCode);
} // lGenLogOp

/*
** lGenExpOp() - Simple version:  Assumes all args in memory, leaves result on TOS.
*/

static void lGenExpOp(Code *fCode, Vector *r, Expr *a, int fmask)
{
    X86_CODE_DECLARE;
    int nottoobig, computeit, computeit2, done_a, done_b;
    float f;

    // Load x into EAX:

    lGenLoadIReg(fCode, a, FALSE);
    X86_CODE_LOAD(fCode);

    assert(LOCAL_VAR_SIZE >= 12);

    // if (floor(x) > FLT_MAX_EXP)

    f = FLT_MAX_EXP + 1;
    xCMP_rm_imm(rmREG(rEAX), VIEW_AS_INT(f));       // cmp  eax, 0xXXXXXXXX
    xLABEL(nottoobig);
    xJL(0);                                         //   jl   nottoobig

    // tr.x = F_POS_INFINITY;
    // tr.y = 0.0f;
    // tr.z = F_POS_INFINITY;
    // tr.w = 1.0f;

    if (fmask & (DST_X_BIT | DST_Z_BIT)) {
        xMOV_rm_imm(rmREG(rEAX), 0x7f800000);       //   mov  eax, 0x7f800000
        xMOV_rm_r(rmSIB, rEAX) xSIB_esp;            //   mov  [esp], eax
    }
    if (fmask & (DST_Y_BIT)) {
        xMOV_rm_imm(rmREG(rEAX), 0x00000000);       //   mov  eax, 0x00000000
        xMOV_rm_r(rmSIB8, rEAX) xSIB8_esp(4);       //   mov  4[esp], eax
    }
    if (fmask & DST_X_BIT) {
        xFLD_rm(rmSIB) xSIB_esp;                    //   fld  [esp]
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        xFLD_rm(rmSIB8) xSIB8_esp(4);               //   fld  4[esp]
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        xFLD_rm(rmSIB) xSIB_esp;                   //   fld  [esp]
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }

    xLABEL(done_a);
    xJMP(0);                                        //   jmp  done;  Can be bigger that 128 bytes
    xTARGET_b8(nottoobig);                          // nottoobig:

    // if (x >= 0) goto computeit

    xTEST_rm_imm(rmREG(rEAX), 0x80000000);          //   tst  eax, 0x80000000
    xLABEL(computeit);
    xJZ(0);                                         //   jz   computeit

    // if (floor(x) < FLT_MIN_EXP)

    xMOV_rm_r(rmREG(rEDX), rEAX);                   //   mov  edx, eax
    xAND_rm_imm(rmREG(rEDX), 0x7fffffff);           //   and  edx, 0x7fffffff
    f = FLT_MIN_EXP;
    VIEW_AS_INT(f) = VIEW_AS_INT(f) & 0x7fffffff;
    xCMP_rm_imm(rmREG(rEDX), VIEW_AS_INT(f));       // cmp  eax, 0xXXXXXXXX
    xLABEL(computeit2);
    xJL(0);                                         //   jl   computeit

    // X is too small:  X < FLT_MIN_EXP
    //
    // tr.x = tr.y = tr.z = tr.w = { 0.0f, floor(x), 0.0f, 1.0f };

    if (fmask & DST_X_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_zero_offset); //   fld   gc->float_zero
        r->x.kind = E_FREG;
    } else {
        r->x.kind = E_NONE;
    }
    if (fmask & DST_Y_BIT) {
        xMOV_rm_r(rmSIB8, rEAX) xSIB8_esp(8);           //   mov   8[esp], x
        xFLD_rm(rmSIB8) xSIB8_esp(8);                   //   fld   8[esp]      ; TOS = x
        X86_CODE_RESTORE(fCode);
        lGenIFloor(fCode, rEAX, 0);                     //   [esp] = floor(x), [tos] = x
        X86_CODE_LOAD(fCode);
        xFILD_rm(rmSIB) xSIB_esp;                       //   fld   [esp];  x, floor(x)
        xFSUBP_st(1);                                   //   fsubp [tos - 1];  x - floor(x)
        r->y.kind = E_FREG;
    } else {
        r->y.kind = E_NONE;
    }
    if (fmask & DST_Z_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_zero_offset); //   fld   gc->float_zero
        r->z.kind = E_FREG;
    } else {
        r->z.kind = E_NONE;
    }
    if (fmask & DST_W_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }

    xLABEL(done_b);
    xJMP8(0);                                       //   jmp  done
    xTARGET_b8(computeit);                          // computeit:
    xTARGET_b8(computeit2);                         // computeit2:

    // f = floor(x);
    // ii = f;
    // ii = (ii << 23) + 0x3f800000;
    // tr.x = __GL_VIEW_AS_FLOAT(ii);
    // tr.y = x - f;
    // tr.z = tr.x*__GL_EXPF(tr.y*LOG_2_BASE_E);
    // tr.w = 1.0f;

    xMOV_rm_r(rmSIB8, rEAX) xSIB8_esp(8);           //   mov  8[esp], x
    xFLD_rm(rmSIB8) xSIB8_esp(8);                   //   fld  8[esp]      ; TOS = x
    X86_CODE_RESTORE(fCode);

    lGenIFloor(fCode, rEAX, 1);                     //   [esp] = ifloor(TOS)

    X86_CODE_LOAD(fCode);
    xMOV_r_rm(rEAX, rmSIB) xSIB_esp;                //   mov  eax, [esp]
    xSHL_rm_imm8(rmREG(rEAX), 23);                  //   shl  eax, 23
    xADD_rm_imm(rmREG(rEAX), 0x3f800000);           //   or   eax, 0x3f800000
    xMOV_rm_r(rmSIB8, rEAX) xSIB8_esp(4);           //   mov  4[esp], eax; float 2**ii

    xFLD_rm(rmSIB8) xSIB8_esp(4);                   //   fld  4[esp];  X: 2.0**ii
    xFILD_rm(rmSIB) xSIB_esp;                       //   fild [esp];      floor(x)
    xFSUBR_rm(rmSIB8) xSIB8_esp(8);                 //   fsubr 8[esp]; Y: x - floor(x)
    xFLD_st(0);                                     //   fld  st(0);   Z: x - floor(x)
    xF2XM1();                                       //   fyl2x;           2**(x - floor(x)) - 1.0
    xFADD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); // fadd  1,0f;      2**(x - floor(x))
    xFMUL_st(2);                                    //   fmul  st(2);  Z: (2**ii)*(2**(x - floor(x)))

    if (fmask & DST_X_BIT) {
        r->x.kind = E_FREG;
    } else {
        xFXCH_st(2);                                //   fxch st(2)
        xFSTP_st(0);                                //   fstp st(0); Pop
        xFXCH_st(1);                                //   fxch st(1)
        r->x.kind = E_NONE;
    }

    if (fmask & DST_Y_BIT) {
        r->y.kind = E_FREG;
    } else {
        xFXCH_st(1);                                //   fxch st(1)
        xFSTP_st(0);                                //   fstp st(0); Pop
        r->y.kind = E_NONE;
    }
    
    if (fmask & DST_Z_BIT) {
        r->z.kind = E_FREG;
    } else {
        xFSTP_st(0);                                //   fstp st(0); Pop
        r->z.kind = E_NONE;
    }

    if (fmask & DST_W_BIT) {
        xFLD_rm(rmIND32(rEBX)) xOFS32(fCode->environment->float_one_offset); //   fld   gc->float_one
        r->w.kind = E_FREG;
    } else {
        r->w.kind = E_NONE;
    }
    
    xTARGET_jmp(done_a);                            // done_a:
    xTARGET_b8(done_b);                             // done_b:

    X86_CODE_RESTORE(fCode);
} // lGenExpOp

/*
** lInitLiveRegs() - Initialize:
**         1) temp registers that are read before written to 0,0,0,0
**         2) output registers that aren't written to 0,0,0,1
*/

static void lInitLiveRegs(Code *fCode, ParsedProgram *parsed)
{
    X86_CODE_DECLARE;
    unsigned int ii, bits, addr, mask, maskbar;
    int HaveZero = 0, HaveOne = 0;

    X86_CODE_LOAD(fCode);

    // Clear A0 register:

    xXOR_rm_r(rmREG(rESI), rESI);       // xor esi, esi

    // Clear temp registers that are read before they are written to 0:

    bits = parsed->liveOnEntry & ((1 << __GL_NUMBER_OF_TEMPORARY_REGISTERS) - 1);
    if (bits) {
        HaveZero = 1;
        xXOR_r_rm(rEAX, rmREG(rEAX));
        for (ii = 0; bits; ii++, bits >>= 1) {
            if (bits & 1) {
                addr = ii*sizeof(float)*4 + fCode->environment->temp_offset;
                xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr);                   // mov  offset[gc], eax
                xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float));   // mov  offset[gc], eax
                xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float)*2); // mov  offset[gc], eax
                xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float)*3); // mov  offset[gc], eax
            }
        }
    }

    // Set unset parts of result registers to 0/0/0/1:

    for (ii = 0; ii < __GL_NUMBER_OF_RESULT_REGISTERS; ii++) {
        if (parsed->resultRegsWritten[ii] != DST_XYZW_BITS) {

            // Only fill in partially written result regs:

            mask = (parsed->resultRegsWritten[ii] != DST_NONE_BITS);
            if (mask) {
                maskbar = DST_XYZW_BITS & ~mask;
                if ((maskbar & DST_XYZ_BITS) && !HaveZero) {
                    HaveZero = 1;
                    xXOR_r_rm(rEAX, rmREG(rEAX));
                }
                if ((maskbar & DST_W_BIT) && !HaveOne) {
                    HaveOne = 1;
                    xMOV_rm_imm(rmREG(rECX), 0x3f800000);
                }
                addr = ii*sizeof(float)*4 + fCode->environment->result_offset;
                if (maskbar & DST_X_BIT) {
                    xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr);                    // mov  offset[gc], eax
                }
                if (maskbar & DST_Y_BIT) {
                    xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float));    // mov  offset[gc], eax
                }
                if (maskbar & DST_Z_BIT) {
                    xMOV_rm_r(rmIND32(rEBX), rEAX) xOFS32(addr + sizeof(float)*2);  // mov  offset[gc], eax
                }
                if (maskbar & DST_W_BIT) {
                    xMOV_rm_r(rmIND32(rEBX), rECX) xOFS32(addr + sizeof(float)*3);  // mov  offset[gc], ecx
                }
            }
        }
    }

    X86_CODE_RESTORE(fCode);
} // lInitLiveRegs

/*
** lGrowCode() - Increase the generated code buffer.
*/

static int lGrowCode(Code *fCode, int fSize)
{
    unsigned char *newData;
    unsigned int ii;

    newData = (unsigned char *) fCode->environment->malloc(fCode->environment->mallocArg, fSize);
    if (!newData)
        return FALSE;
    for (ii = 0; ii < fCode->ilcCount; ii++)
        newData[ii] = fCode->ilcData[ii];
    fCode->environment->free(fCode->environment->mallocArg, fCode->ilcData);
    fCode->ilcData = newData;
    fCode->ilcMax = fSize;
    return TRUE;
} // lGrowCode

/*
** vp_CompileX86() - Compile a vertex program into X86 instructions.
*/

int vp_CompileX86(VtxProgCompileX86 *environment, ParsedProgram *parsed,
                int numInstructions, VertexProgramOutput *outArgs)
{
    unsigned char *theCode = NULL;
    unsigned int  ilcCount, ilcMax;
    unsigned char *ilcData;
    Code lCode;

    Instruction *inst;
    Arl_Instruction *ainst;
    Scalar_Instruction *sinst;
    Vector_Instruction *vinst;
    Bin_Instruction *binst;
    Tri_Instruction *tinst;
    Vector a, b, c, r;
    Expr e;
    int lop, lsize, pc;
    unsigned int ii;

    ilcCount = 0;
    ilcMax = 16385;
    ilcData = (unsigned char *) environment->malloc(environment->mallocArg, ilcMax);
    if (!ilcData)
        return FALSE;

    VtxProgImports.logf = environment->logf;
    VtxProgImports.expf = environment->expf;

    xPUSH_r(rEBP);
    xMOV_r_rm(rEBP, rmREG(rESP));
    //xPUSH_r(rEAX);
    xPUSH_r(rEBX);
    //xPUSH_r(rECX);
    //xPUSH_r(rEDX);
    xPUSH_r(rESI);          // Holds address register X 16
    xPUSH_r(rEDI);

    xMOV_r_rm(rEBX, rmIND8(rEBP)) xOFS8(8)          // mov  ebx, gc

    xADD_rm_imm8(rmREG(rESP), -LOCAL_VAR_SIZE);     // Alloc local stack space

    X86_CODE_RESTORE(&lCode);
    lCode.environment = environment;

    lInitLiveRegs(&lCode, parsed);

    inst = parsed->firstInstruction;
    for (pc = 0; pc < numInstructions; inst++, pc++) {

        // Make sure there's room for the next instruction:

        if (lCode.ilcCount + 200 >= lCode.ilcMax) {
            if (!lGrowCode(&lCode, ((lCode.ilcMax*3 >> 1) + 15) & ~15)) {
                environment->free(environment->mallocArg, lCode.ilcData);
                return FALSE;
            }
        }

        lGenNop(&lCode); // Mark instructions
        lop = inst->end_op.opcode;
        switch (lop) {

        // ARL op:

        case OP_ARL:
            ainst = (Arl_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &ainst->src);
            lGenAlrOp(&lCode, &a.x);
            break;

        // SCALAR ops:

        case OP_EXP:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenExpOp(&lCode, &r, &a.x, sinst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &sinst->dst, &r);
            break;

        case OP_LOG:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenLogOp(&lCode, &r, &a.x, sinst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &sinst->dst, &r);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_RCC:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenRccOp(&lCode, &e, &a.x);
            lGenStoreMaskedDstRegScalar(&lCode, &sinst->dst, &e);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_RCP:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenRcpOp(&lCode, &e, &a.x);
            lGenStoreMaskedDstRegScalar(&lCode, &sinst->dst, &e);
            break;

        case OP_RSQ:
            sinst = (Scalar_Instruction *) inst;
            lGenScalarSrcReg(environment, &a.x, &sinst->src);
            lGenRsqOp(&lCode, &e, &a.x);
            lGenStoreMaskedDstRegScalar(&lCode, &sinst->dst, &e);
            break;

        // VECTOR ops:

        case OP_LIT:
            vinst = (Vector_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &vinst->src);
            lGenLitOp(&lCode, &r, &a, vinst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &vinst->dst, &r);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_IMV:
#endif // NV_INTERNAL_OPCODES
        case OP_MOV:
            vinst = (Vector_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &vinst->src);
            lGenStoreMaskedDstReg(&lCode, &vinst->dst, &a);
            break;

        // BIN ops:

        case OP_ADD:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenAddOp(&lCode, &r, &a, &b, binst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_DP3:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenDotProductOp(&lCode, &e, &a, &b, 3);
            lGenStoreMaskedDstRegScalar(&lCode, &binst->dst, &e);
            break;

        case OP_DP4:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenDotProductOp(&lCode, &e, &a, &b, 4);
            lGenStoreMaskedDstRegScalar(&lCode, &binst->dst, &e);
            break;

#if defined(NV_INTERNAL_OPCODES)
        case OP_DPH:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenDotProductOp(&lCode, &e, &a, &b, 0);
            lGenStoreMaskedDstRegScalar(&lCode, &binst->dst, &e);
            break;
#endif // NV_INTERNAL_OPCODES

        case OP_DST:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenDstOp(&lCode, &r, &a, &b, binst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_MAX:
        case OP_MIN:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenMinMaxOp(&lCode, &r, &a, &b, binst->dst.mask, lop == OP_MAX);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_MUL:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenMulOp(&lCode, &r, &a, &b, binst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_SGE:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenSgeOp(&lCode, &r, &a, &b, binst->dst.mask, FALSE);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        case OP_SLT:
            binst = (Bin_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &binst->srcA);
            lGenSwizzleSrcReg(environment, &b, &binst->srcB);
            lGenSgeOp(&lCode, &r, &a, &b, binst->dst.mask, TRUE);
            lGenStoreMaskedDstReg(&lCode, &binst->dst, &r);
            break;

        // TRIops:

        case OP_MAD:
            tinst = (Tri_Instruction *) inst;
            lGenSwizzleSrcReg(environment, &a, &tinst->srcA);
            lGenSwizzleSrcReg(environment, &b, &tinst->srcB);
            lGenSwizzleSrcReg(environment, &c, &tinst->srcC);
            lGenMadOp(&lCode, &r, &a, &b, &c, tinst->dst.mask);
            lGenStoreMaskedDstReg(&lCode, &tinst->dst, &r);
            break;

        // ENDops:

        case OP_END:
            break;

        default:
            break;
        }
    }

    X86_CODE_LOAD(&lCode);

    xADD_rm_imm8(rmREG(rESP), LOCAL_VAR_SIZE);  // Free local stack space

    xPOP_r(rEDI)
    xPOP_r(rESI)
    //xPOP_r(rEDX)
    //xPOP_r(rECX)
    xPOP_r(rEBX)
    //xPOP_r(rEAX)

    xPOP_r(rEBP)
    xRET

    lsize = (ilcCount + 15) & ~15;
    theCode = (unsigned char *) environment->exec_malloc(environment->mallocArg, lsize);
    outArgs->residentSize = __internal_setup(lsize & 15); // so linker won't delete watermark
    if (theCode) {
        for (ii = 0; ii < ilcCount; ii++)
            theCode[ii] = ilcData[ii];
        outArgs->residentProgram = theCode;
        outArgs->residentSize = lsize;
    } else {
        outArgs->residentProgram = NULL;
        outArgs->residentSize = 0;
    }
    environment->free(environment->mallocArg, ilcData);

    return outArgs->residentProgram != NULL;
} // vp_CompileX86

/*
** vp_OutputCelsiusX86() - Compile a vertex program into X86 instructions.
*/

// Macros copied from nv32.h, nvhw.h, etc. so they don't have to be included by D3D:

#define __NV_COUNT_SHIFT                18
#define __NV_SUBCHANNEL_SHIFT           13
#define __NV_METHOD_SHIFT               0
#define __NV_METHOD(_SC,_M,_NUM)        (((_NUM) << __NV_COUNT_SHIFT) | ((_SC) << __NV_SUBCHANNEL_SHIFT) | (_M))

#define __NV056_SET_VERTEX4F(i)         (0x00000c18+(i)*4)
#define __NV056_SET_DIFFUSE_COLOR4F(i)  (0x00000c50+(i)*4)
#define __NV056_SET_DIFFUSE_COLOR3F(i)  (0x00000c60+(i)*4)
#define __NV056_SET_SPECULAR_COLOR4F(i) (0x00000c70+(i)*4)
#define __NV056_SET_SPECULAR_COLOR3F(i) (0x00000c80+(i)*4)
#define __NV056_SET_TEXCOORD0_2F(i)     (0x00000c90+(i)*4)
#define __NV056_SET_TEXCOORD0_4F(i)     (0x00000ca0+(i)*4)
#define __NV056_SET_TEXCOORD1_2F(i)     (0x00000cb8+(i)*4)
#define __NV056_SET_TEXCOORD1_4F(i)     (0x00000cc8+(i)*4)

#define C_METHOD(e, _M,_NUM)            __NV_METHOD((e)->channel_number, _M, _NUM)

#define OUT_OFFSET(n, k, e)             ((((n)*4) + (k))*sizeof(float) + (e)->result_offset)

int vp_OutputCelsiusX86(VtxProgCompileX86 *environment, ParsedProgram *parsed,
                        int numInstructions, VertexProgramOutput *outArgs)
{
    unsigned char *theCode = NULL;
    unsigned int  ilcCount, ilcMax;
    unsigned char *ilcData;
    Code lCode;

    unsigned int ii;
    int offset, lsize, mask, is_cube_map;

    ilcCount = 0;
    ilcMax = 1024;
    ilcData = (unsigned char *) environment->malloc(environment->mallocArg, ilcMax);
    if (!ilcData)
        return FALSE;
    offset = 0;
    lCode.environment = environment;

    xPUSH_r(rEBP);
    xMOV_r_rm(rEBP, rmREG(rESP));
    //xPUSH_r(rEAX);
    xPUSH_r(rEBX);
    //xPUSH_r(rECX);
    //xPUSH_r(rEDX);
    //xPUSH_r(rESI);          // Holds address register X 16
    xPUSH_r(rEDI);      // Points to output area

    xMOV_r_rm(rEBX, rmIND8(rEBP)) xOFS8(8)          // mov  ebx, gc
    xMOV_r_rm(rEDI, rmIND8(rEBP)) xOFS8(12)         // mov  edi, nvCurrent

    xADD_rm_imm8(rmREG(rESP), -LOCAL_VAR_SIZE);     // Alloc local stack space

    // Output Color:

    mask = parsed->resultRegsWritten[__GL_ATTRIB_OUTPUT_COL0];
    if (mask) {
        if (mask & 0x08) {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_DIFFUSE_COLOR4F(0),4)); // mov  eax, #SET_DIFFUSE_COLOR4F
        } else {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_DIFFUSE_COLOR3F(0),3)); // mov  eax, #SET_DIFFUSE_COLOR3F
        }
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                         // mov  nvCurrent[0], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(3,0,environment));      // mov  eax, o[COL0].x
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                       // mov  nvCurrent[1], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(3,1,environment));      // mov  eax, o[COL0].y
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                       // mov  nvCurrent[2], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(3,2,environment));      // mov  eax, o[COL0].z
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                      // mov  nvCurrent[3], eax
        if (mask & 0x08) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(3,3,environment));  // mov  eax, o[COL0].w
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
            offset += 5;
        } else {
            offset += 4;
        }
    }

    // Output Secondary Color:

    mask = parsed->resultRegsWritten[__GL_ATTRIB_OUTPUT_COL1];
    if (mask) {
        if (mask & 0x08) {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_SPECULAR_COLOR4F(0),4)); // mov  eax, #SET_SPECULAR_COLOR4F
        } else {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_SPECULAR_COLOR3F(0),3)); // mov  eax, #SET_SPECULAR_COLOR3F
        }
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                         // mov  nvCurrent[0], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(4,0,environment));      // mov  eax, o[COL1].x
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                       // mov  nvCurrent[1], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(4,1,environment));      // mov  eax, o[COL1].y
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                       // mov  nvCurrent[2], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(4,2,environment));      // mov  eax, o[COL1].z
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                      // mov  nvCurrent[3], eax
        if (mask & 0x08) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(4,3,environment));  // mov  eax, o[COL1].w
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
            offset += 5;
        } else {
            offset += 4;
        }
    }

    // Output Texture 0:

    mask = parsed->resultRegsWritten[__GL_ATTRIB_OUTPUT_TEX0];
    if (mask) {
        if (mask & 0x0c) {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_TEXCOORD0_4F(0),4));    // mov  eax, #SET_TEXCOORD0_4F
        } else {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_TEXCOORD0_2F(0),2));    // mov  eax, #SET_TEXCOORD0_2F
        }
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                         // mov  nvCurrent[0], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(9,0,environment));      // mov  eax, o[TEX0].x
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                       // mov  nvCurrent[1], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(9,1,environment));      // mov  eax, o[TEX0].y
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                       // mov  nvCurrent[2], eax
        if (mask & 0x0c) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(9,2,environment));  // mov  eax, o[TEX0].z
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                  // mov  nvCurrent[3], eax
            // See if cube maps are enabled on texture 0:
            xTEST_rm_imm(rmIND32(rEBX), environment->enables_offset);
                         xOFS32(__GL_PROGRAM_ENABLE_TEXTURE0); // Fields are BACKWARDS in macro!!!
            xLABEL(is_cube_map);
            xJNZ(0);                                                             // jnz  is_cube_map
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(9,3,environment));  // mov  eax, o[TEX0].w
            xTARGET_b8(is_cube_map);                                             // is_cube_map:
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
            offset += 5;
        } else {
            offset += 3;
        }
    }

    // Output Texture 1:

    mask = parsed->resultRegsWritten[__GL_ATTRIB_OUTPUT_TEX1];
    if (mask) {
        if (mask & 0x0c) {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_TEXCOORD1_4F(0),4));    // mov  eax, #SET_TEXCOORD1_4F
        } else {
            xMOV_rm_imm(rmREG(rEAX),
                        C_METHOD(environment,__NV056_SET_TEXCOORD1_2F(0),2));    // mov  eax, #SET_TEXCOORD1_2F
        }
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                         // mov  nvCurrent[0], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(10,0,environment));     // mov  eax, o[TEX1].x
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                       // mov  nvCurrent[1], eax
        xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(10,1,environment));     // mov  eax, o[TEX1].y
        xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                       // mov  nvCurrent[2], eax
        if (mask & 0x0c) {
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(10,2,environment)); // mov  eax, o[TEX1].z
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                  // mov  nvCurrent[3], eax
            // See if cube maps are enabled on texture 1:
            xTEST_rm_imm(rmIND32(rEBX), environment->enables_offset);
                         xOFS32(__GL_PROGRAM_ENABLE_TEXTURE1); // Fields are BACKWARDS in macro!!!
            xLABEL(is_cube_map);
            xJNZ(0);                                                             // jnz  is_cube_map
            xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(10,3,environment)); // mov  eax, o[TEX1].w
            xTARGET_b8(is_cube_map);                                             // is_cube_map:
            xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
            offset += 5;
        } else {
            offset += 3;
        }
    }

    // Output vertex data:

#if 000
    // invW = 1.0f/pRegs->result[0].w;
    // NV_CELSIUS_METHOD_4F(NV056_SET_VERTEX4F(0),
    //                      pRegs->result[__GL_ATTRIB_OUTPUT_HPOS].x*vp->xScale*invW + vp->xCenter - xAdjust,
    //                      pRegs->result[__GL_ATTRIB_OUTPUT_HPOS].y*vp->yScale*invW + vp->yCenter - yAdjust,
    //                      pRegs->result[__GL_ATTRIB_OUTPUT_HPOS].z*vp->zScale*invW + vp->zCenter,
    //                     invW);
    
    xFLD_rm(rmIND32(rEBX)) xOFS32(environment->float_one_offset);     // fld   1.0f
    xFDIV_rm(rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,3,environment));      // fdiv  o[HPOS].w
    xFLD_rm(rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,0,environment));       // fld   o[HPOS].x
    xFLD_rm(rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,1,environment));       // fld   o[HPOS].y
    xFLD_rm(rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,2,environment));       // fld   o[HPOS].z
    xFLD_rm(rmIND32(rEBX)) xOFS32(environment->vp_scale_offset);      // fld   vpScale.x
    xFLD_rm(rmIND32(rEBX)) xOFS32(environment->vp_scale_offset+4);    // fld   vpScale.y
    xFLD_rm(rmIND32(rEBX)) xOFS32(environment->vp_scale_offset+8);    // fld   vpScale.z  ; Sz  Sy  Sx  Oz  Oy  Ox  1/Ow
    xFMULP_st(3);                                                     // fmulp st(3)      ; Sy  Sx  Oz*Sz  Oy  Ox  1/Ow
    xFMULP_st(3);                                                     // fmulp st(3)      ; Sx  Oz*Sz  Oy*Sy  Ox  1/Ow
    xFMULP_st(3);                                                     // fmulp st(3)      ; Oz*Sz  Oy*Sy  Ox*Sx  1/Ow
    xFMULP_st(3);                                                     // fmul  st(3)      ; Oz*Sz/Ow  Oy*Sy  Ox*Sx  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_center_offset+8);  // fadd  vpCenter.z ; Oz*Sz/Ow+Cz  Oy*Sy  Ox*Sx  1/Ow
    xFXCH_st(2);                                                      // fxch  st(2)      ; Ox*Sx  Oy*Sy  Oz*Sz/Ow+Cz  1/Ow
    xFMULP_st(3);                                                     // fmul  st(3)      ; Ox*Sx/Ow  Oy*Sy  Oz*Sz/Ow+Cz  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_center_offset);    // fadd  vpCenter.x ; Ox*Sx/Ow+Cx  Oy*Sy  Zout  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_adjust_offset);    // fsub  vpAdjust.x ; Ox*Sx/Ow+Cx-Ax  Oy*Sy  Zout  1/Ow
    xFXCH_st(1);                                                      // fxch  st(1)      ; Oy*Sy  Ox*Sx/Ow+Cx-Ax  Zout  1/Ow
    xFMULP_st(3);                                                     // fmul  st(3)      ; Oy*Sy/Ow  Xout  Zout  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_center_offset+4);  // fadd  vpCenter.y ; Oy*Sy/Ow+Cy  Xout  Zout  1/Ow
    xFADD_rm(rmIND32(rEBX)) xOFS32(environment->vp_adjust_offset+4);  // fsub  vpAdjust.y ; Oy*Sy/Ow+Cy-Ay  Xout  Zout  1/Ow
    xFXCH_st(1);                                                      // fxch  st(1)      ; Xout  Yout  Zout  Wout
    xMOV_rm_imm(rmREG(rEAX), C_METHOD(__NV056_SET_VERTEX4F(0),4));    // mov   eax, #SET_VERTEX4F
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset);                    // mov   nvCurrent[0], eax
    xFSTP_rm(rmIND32(rEDI)) xOFS32(offset+4);                         // fstp  nvCurrent[1]
    xFSTP_rm(rmIND32(rEDI)) xOFS32(offset+8);                         // fstp  nvCurrent[2]
    xFSTP_rm(rmIND32(rEDI)) xOFS32(offset+12);                        // fstp  nvCurrent[3]
    xFSTP_rm(rmIND32(rEDI)) xOFS32(offset+16);                        // fstp  nvCurrent[4]
#endif
    xMOV_rm_imm(rmREG(rEAX),
                C_METHOD(environment,__NV056_SET_VERTEX4F(0),4));        // mov  eax, #SET_VERTEX4F
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4);                     // mov  nvCurrent[0], eax
    xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,0,environment));  // mov  eax, o[HPOS].x
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+4);                   // mov  nvCurrent[1], eax
    xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,1,environment));  // mov  eax, o[HPOS].y
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+8);                   // mov  nvCurrent[2], eax
    xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,2,environment));  // mov  eax, o[HPOS].z
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+12);                  // mov  nvCurrent[3], eax
    xMOV_r_rm(rEAX, rmIND32(rEBX)) xOFS32(OUT_OFFSET(0,3,environment));  // mov  eax, o[HPOS].w
    xMOV_rm_r(rmIND32(rEDI), rEAX) xOFS32(offset*4+16);                  // mov  nvCurrent[4], eax
    offset += 5;

    // Clean-up and go home:

    xADD_rm_imm8(rmREG(rESP), LOCAL_VAR_SIZE);  // Free local stack space

    xPOP_r(rEDI)
    //xPOP_r(rESI)
    //xPOP_r(rEDX)
    //xPOP_r(rECX)
    xPOP_r(rEBX)
    //xPOP_r(rEAX)

    xPOP_r(rEBP)
    xRET

    lsize = (ilcCount + 15) & ~15;
    theCode = (unsigned char *) environment->exec_malloc(environment->mallocArg, lsize);
    if (theCode) {
        for (ii = 0; ii < ilcCount; ii++)
            theCode[ii] = ilcData[ii];
        outArgs->residentProgram = theCode;
        outArgs->residentSize = lsize;
    } else {
        outArgs->residentProgram = NULL;
        outArgs->residentSize = 0;
        offset = 0;
    }
    environment->free(environment->mallocArg, ilcData);

    return offset;
} // vp_OutputCelsiusX86
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\vesa\vesadata.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

#include "vesadata.h"
#include "nvMultiMon.h"

//*****************************************************************************
//
// This file contains the display timing tables required for all supported
// VESA (DMT, GTF) modes.
//
// Definition of display timing terms:
//
//
//  <------------------><--------><-------><------><-------><--------><--------
//
//     Active Display     Border    Porch    Sync    Porch    Border    Active
//
//
//  <---------------------------------------------------------------->
//  Total
//
//  <------------------>
//  Visible
//
//  <---------------------------->
//  Blank Start
//
//  <------------------------------------->
//  Sync Start
//
//  <--------------------------------------------->
//  Sync End
//
//  <------------------------------------------------------>
//  Blank End
//
//*****************************************************************************

//*****************************************************************************
//
// GTF Timings 
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use pure floating point).
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Sync Start, Sync End
// Vertical Total, Sync Start, Sync End
// DotClock (MHz * 100)
// HSync polarity 
// VSync polarity 
//
// NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
// Blank End == Total.
//
unsigned int GTFTimingTable[][12] =
{
    // Settings for 2048x1536:
    {2048,1536,6000, 2800,2200,2424,1589,1537,1540,26695,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7000, 2816,2208,2432,1599,1537,1540,31519,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7200, 2816,2208,2432,1600,1537,1540,32440,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,7500, 2832,2216,2440,1603,1537,1540,34048,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {2048,1536,8500, 2832,2216,2440,1612,1537,1540,38804,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1920x1440:
    {1920,1440,6000, 2624,2064,2272,1490,1441,1444,23459,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7000, 2640,2072,2280,1499,1441,1444,27702,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7200, 2640,2072,2280,1500,1441,1444,28512,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,7500, 2640,2072,2280,1503,1441,1444,29759,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1440,8500, 2656,2072,2288,1512,1441,1444,34135,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 1920x1200:
    {1920,1200,6000, 2592,2048,2256,1242,1201,1204,19316,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7000, 2608,2056,2264,1249,1201,1204,22802,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7200, 2624,2064,2272,1251,1201,1204,23635,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7500, 2624,2064,2272,1253,1201,1204,24659,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,7600, 2624,2064,2272,1253,1201,1204,24988,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,8500, 2640,2072,2280,1260,1201,1204,28274,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,10000,2656,2072,2288,1271,1201,1204,33758,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1200,12000,2672,2080,2296,1286,1201,1204,41234,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1920x1080:
    {1920,1080,6000, 2576,2040,2248,1118,1081,1084,17280,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7000, 2608,2056,2264,1124,1081,1084,20520,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7200, 2608,2056,2264,1126,1081,1084,21144,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,7500, 2608,2056,2264,1128,1081,1084,22064,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,8500, 2624,2064,2272,1134,1081,1084,25293,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,10000,2640,2072,2280,1144,1081,1084,30202,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1920,1080,12000,2656,2072,2288,1157,1081,1084,36876,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1800x1440:
    {1800,1440,6000, 2456,1928,2128,1490,1441,1444,21957,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7000, 2472,1936,2136,1499,1441,1444,25939,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7200, 2472,1936,2136,1500,1441,1444,26698,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,7500, 2472,1936,2136,1503,1441,1444,27866,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,8500, 2488,1944,2144,1512,1441,1444,31976,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1800,1440,10000,2504,1952,2152,1525,1441,1444,38186,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1600x1200:
    {1600,1200,6000, 2160,1704,1880,1242,1201,1204,16096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7000, 2176,1712,1888,1249,1201,1204,19025,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7200, 2176,1712,1888,1251,1201,1204,19600,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,7500, 2192,1720,1896,1253,1201,1204,20599,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,8500, 2192,1720,1896,1260,1201,1204,23476,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,10000,2208,1728,1904,1272,1201,1204,28064,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,12000,2224,1736,1912,1286,1201,1204,34321,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1200,14000,2240,1744,1920,1301,1201,1204,40799,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x1024:
    {1600,1024,6000, 2144,1704,1872,1060,1025,1028,13636,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7000, 2160,1704,1880,1066,1025,1028,16118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7200, 2160,1704,1880,1067,1025,1028,16594,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7500, 2176,1712,1888,1069,1025,1028,17446,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,7600, 2176,1712,1888,1070,1025,1028,17695,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,8500, 2176,1712,1888,1075,1025,1028,19883,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,10000,2192,1720,1896,1085,1025,1028,23783,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,1024,12000,2208,1728,1904,1097,1025,1028,29066,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x900:
    {1600,900,6000, 2128,1696,1864,932,901,904,11900,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7000, 2144,1704,1872,937,901,904,14062,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7200, 2144,1704,1872,938,901,904,14480,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,7500, 2160,1704,1880,940,901,904,15228,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,8500, 2176,1712,1888,945,901,904,17479,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,10000,2192,1720,1896,953,901,904,20890,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,12000,2208,1728,1904,965,901,904,25569,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,14000,2224,1736,1912,976,901,904,30389,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,14400,2224,1736,1912,978,901,904,31321,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,15000,2224,1736,1912,982,901,904,32760,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,900,17000,2224,1736,1912,994,901,904,37581,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1600x880:
    {1600,880,6000, 2112,1688,1856,911,881,884,11544,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7000, 2144,1704,1872,916,881,884,13747,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7200, 2144,1704,1872,917,881,884,14156,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,7500, 2144,1704,1872,919,881,884,14778,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,8500, 2160,1704,1880,924,881,884,16965,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,10000,2192,1720,1896,932,881,884,20429,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,12000,2208,1728,1904,943,881,884,24986,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,14000,2208,1728,1904,954,881,884,29490,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,14400,2224,1736,1912,957,881,884,30648,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,15000,2224,1736,1912,960,881,884,32026,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1600,880,17000,2224,1736,1912,972,881,884,36749,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1400x1050:
    {1400,1050,6000, 1880,1488,1640,1087,1051,1054,12261,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7000, 1896,1496,1648,1093,1051,1054,14506,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7200, 1896,1496,1648,1094,1051,1054,14934,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,7500, 1896,1496,1648,1096,1051,1054,15585,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,8500, 1912,1504,1656,1103,1051,1054,17926,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,10000,1928,1512,1664,1112,1051,1054,21439,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,12000,1944,1520,1672,1125,1051,1054,26244,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,14000,1944,1520,1672,1139,1051,1054,30999,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,14400,1944,1520,1672,1141,1051,1054,31941,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1400,1050,15000,1944,1520,1572,1146,1051,1054,33417,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},

    
    // Settings for 1280x1024:
    {1280,1024,6000, 1712,1360,1496,1060,1025,1028,10888,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7000, 1728,1368,1504,1066,1025,1028,12894,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7200, 1728,1368,1504,1067,1025,1028,13275,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,7500, 0x6B0,0x550,0x5d8,0x424,0x401,0x404,0x2a88,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,8500, 1744,1376,1512,1075,1025,1028,15936,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,10000,1760,1376,1520,1085,1025,1028,19096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,12000,1776,1384,1528,1097,1025,1028,23379,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,14000,1776,1384,1528,1111,1025,1028,27624,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,14400,1776,1384,1528,1113,1025,1028,28464,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,15000,1776,1384,1528,1117,1025,1028,29757,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,17000,1792,1392,1536,1131,1025,1028,34455,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,1024,20000,1729,1392,1536,1152,1025,1028,41288,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1280x960:
    {1280,960,6000, 1712,1360,1496,994, 961,964,10210,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7000, 1728,1368,1504,999, 961,964,12084,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7200, 1728,1368,1504,1001,961,964,12454,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,7500, 1728,1368,1504,1002,961,964,12986,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,8500, 1744,1376,1512,1008,961,964,14943,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,10000,1760,1376,1520,1017,961,964,17899,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,12000,1760,1376,1520,1029,961,964,21732,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,14000,1776,1384,1528,1041,961,964,25883,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,14400,1776,1384,1528,1044,961,964,26700,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,15000,1776,1384,1528,1047,961,964,27892,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,17000,1792,1392,1536,1060,961,964,32292,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1280,960,20000,1792,1392,1536,1080,961,964,38707,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1152x864:
    {1152,864,6000, 1520,1216,1336,895,865,868,8162,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7000, 1536,1224,1344,900,865,868,9677,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7200, 1536,1224,1344,901,865,868,9964,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,7500, 1552,1224,1352,902,865,868,10499,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,8500, 1552,1224,1352,907,865,868,11965,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,10000,1568,1232,1360,915,865,868,14347,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,12000,1584,1240,1368,926,865,868,17601,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,14000,1600,1248,1376,937,865,868,20989,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,14400,1600,1248,1376,939,865,868,21635,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,15000,1600,1248,1376,943,865,868,22632,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,17000,1600,1248,1376,954,865,868,25949,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,20000,1616,1256,1384,972,865,868,31415,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1152,864,24000,1616,1256,1384,997,865,868,38668,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 1024x768:
    //Use DMT for 60Hz: 1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {1024,768,6000, 1344,1048,1184,806,771,777,6500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
    {1024,768,7000, 1360,1080,1192,800,769,772,7616,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,7200, 1360,1080,1192,801,769,772,7843,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,7500, 1360,1080,1192,802,769,772,8180,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,8500, 1376,1088,1200,807,769,772,9439,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    //Adjust 100Hz due to DAC feedback
    //1392,1096,1208,814,769,772,11331,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {1024,768,10000,1392,1096,1208,814,769,772,11370,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,12000,1408,1104,1216,823,769,772,13905,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,14000,1408,1104,1216,833,769,772,16420,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,14400,1408,1104,1216,835,769,772,16930,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,15000,1408,1104,1216,838,769,772,17699,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,17000,1424,1112,1224,848,769,772,20528,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,20000,1424,1112,1224,864,769,772,24607,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {1024,768,24000,1440,1120,1232,886,769,772,30620,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 960x720:
    {960,720,6000, 1248,1008,1104,746,721,724,5586,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7000, 1264,1008,1112,750,721,724,6636,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7200, 1264,1008,1112,751,721,724,6835,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,7500, 1280,1016,1120,752,721,724,7219,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,8500, 1280,1016,1120,756,721,724,8225,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,10000,1296,1024,1128,763,721,724,9888,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,12000,1312,1032,1136,772,721,724,12154,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,14000,1312,1032,1136,781,721,724,14345,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,14400,1328,1040,1144,783,721,724,14973,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,15000,1328,1040,1144,786,721,724,15657,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,17000,1328,1040,1144,795,721,724,17948,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,20000,1344,1048,1152,810,721,724,21773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {960,720,24000,1344,1048,1152,831,721,724,26805,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 864x480:
    {864,480,6000, 1072,880,968,497,481,484,3197,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7000, 1104,896,984,500,481,484,3864,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7200, 1104,896,984,501,481,484,3982,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,7500, 1104,896,984,502,481,484,4157,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,8500, 1120,904,992,505,481,484,4808,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,10000,1136,912,1000,509,481,484,5782,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,12000,1152,912,1008,515,481,484,7119,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,14000,1168,920,1016,521,481,484,8519,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,14400,1168,920,1016,522,481,484,8780,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,15000,1168,920,1016,524,481,484,9180,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,17000,1184,928,1024,531,481,484,10688,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,20000,1184,928,1024,540,481,484,12787,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {864,480,24000,1200,936,1032,554,481,484,15955,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 856x480:
    {856,480,6000, 1064,872,960,497,481,484,3173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7000, 1096,888,976,500,481,484,3836,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7200, 1096,888,976,501,481,484,3953,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,7500, 1096,888,976,502,481,484,4126,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,8500, 1112,896,984,505,481,484,4773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,10000,1128,904,992,509,481,484,5742,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,12000,1144,912,1000,515,481,484,7070,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,14000,1160,912,1008,521,481,484,8461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,14400,1160,912,1008,522,481,484,8719,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,15000,1160,912,1008,524,481,484,9118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,17000,1160,912,1008,531,481,484,10471,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,20000,1176,920,1016,540,481,484,12701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {856,480,24000,1192,928,1024,554,481,484,15849,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 852x480:
    {852,480,6000, 1046,872,960,497,481,484,3173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7000, 1096,888,976,500,481,484,3836,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7200, 1096,888,976,501,481,484,3953,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,7500, 1096,888,976,502,481,484,4126,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,8500, 1112,896,984,505,481,484,4773,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,10000,1128,904,992,509,481,484,5742,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,12000,1144,912,1000,515,481,484,7070,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,14000,1160,912,1008,521,481,484,8461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,14400,1160,912,1008,522,481,484,8719,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,15000,1160,912,1008,524,481,484,9118,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,17000,1160,912,1008,531,481,484,10471,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,20000,1176,920,1016,540,481,484,12701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {852,480,24000,1192,928,1024,554,481,484,15849,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 848x480:
    {848,480,6000, 1056,864,952,497,481,484,3149,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7000, 1072,872,960,500,481,484,3752,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7200, 1088,880,968,501,481,484,3925,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,7500, 1088,880,968,502,481,484,4096,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,8500, 1104,888,976,505,481,484,4739,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,10000,1120,896,984,509,481,484,5701,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,12000,1136,904,992,515,481,484,7020,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,14000,1152,904,1000,521,481,484,8403,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,14400,1152,904,1000,522,481,484,8659,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,15000,1152,904,1000,524,481,484,9055,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,17000,1152,904,1000,531,481,484,10399,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,20000,1168,912,1008,540,481,484,12614,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {848,480,24000,1168,912,1008,554,481,484,15530,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
        
    // Settings for 800x600:
    // Use DMT for 60: 1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {800,600,6000, 1056,840,968,628,601,605,4000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7000, 1040,840,920,625,601,604,4550,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7200, 1040,840,920,626,601,604,4687,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,7500, 1040,840,920,627,601,604,4891,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,8500, 1056,840,928,630,601,604,5655,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,10000,1072,848,936,636,601,604,6818,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,12000,1088,856,944,643,601,604,8395,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,14000,1088,856,944,651,601,604,9916,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,14400,1088,856,944,653,601,604,10231,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,15000,1088,856,944,655,601,604,10690,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,17000,1104,864,952,663,601,604,12443,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,20000,1104,864,952,675,601,604,14904,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {800,600,24000,1120,872,960,692,601,604,18601,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 720x480:
    {720,480,6000, 896,736,808,497,481,484,2672,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7000, 912,744,816,500,481,484,3192,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7200, 912,744,816,501,481,484,3290,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,7500, 928,752,824,502,481,484,3494,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,8500, 928,752,824,505,481,484,3983,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,10000,944,760,832,509,481,484,4805,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,12000,960,760,840,515,481,484,5933,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,14000,976,768,848,521,481,484,7119,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,14400,976,768,848,522,481,484,7336,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,15000,976,768,848,524,481,484,7671,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,17000,976,768,848,531,481,484,8810,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,20000,992,776,856,540,481,484,10714,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {720,480,24000,992,776,856,554,481,484,13190,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 640x480:
    // Use DMT for 60: 800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,480,6000, 800,656,752,525,490,492,2518,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
    {640,480,7000, 816,664,728,500,481,484,2856,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,7200, 816,664,728,501,481,484,2943,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,7500, 816,664,728,502,481,484,3072,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,8500, 832,672,736,505,481,484,3571,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,10000,848,680,744,509,481,484,4316,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,12000,848,680,744,515,481,484,5241,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,14000,864,680,752,521,481,484,6302,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,14400,864,680,752,522,481,484,6495,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,15000,864,680,752,524,481,484,6791,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,17000,880,688,760,531,481,484,7944,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,20000,880,688,760,540,481,484,9504,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,480,24000,880,688,760,554,481,484,11700,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 640x400:
    //
    // The GTF timings for 640x400 at 70Hz and 72Hz are drastically different than
    // the original VGA timings (which officially only list 85Hz as a support rate
    // at this resolution).  Therefore, when we attempt to set the GTF rates the
    // monitors just aren't happy.
    //
    // Remember that IBM VGA 640x400 starts at 70Hz, not 60Hz.  There is no 60Hz 
    // timings for 640x400 as defined by IBM VGA.
    //
    // Use GTF 75: 784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,6000, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    // Use GTF 75: 800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,7000, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    // Use GTF 75: 800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {640,400,7200, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,7500, 800,656,720,418,401,404,2508,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,8500, 816,664,728,421,401,404,2920,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,10000,832,672,736,424,401,404,3528,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,12000,848,680,744,429,401,404,4366,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,14000,848,680,744,434,401,404,5152,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,14400,848,680,744,435,401,404,5312,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,15000,864,680,752,437,401,404,5664,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,17000,864,680,752,442,401,404,6492,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,20000,880,688,760,451,401,404,7938,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {640,400,24000,880,688,760,462,401,404,9757,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    {512,384,6000, 672,536,592,795,769,772,3205,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {512,384,7000, 672,536,592,800,769,772,3763,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,7200, 688,544,600,801,769,772,3968,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,7500, 688,544,600,802,769,772,4138,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,8500, 688,544,600,807,769,772,4719,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,10000,688,544,600,814,769,772,5600,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,12000,704,552,608,823,769,772,6953,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,14000,704,552,608,833,769,772,8210,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,14400,704,552,608,835,769,772,8465,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,15000,704,552,608,838,769,772,8849,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,17000,704,552,608,848,769,772,10149,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,20000,720,560,616,864,769,772,12442,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    {512,384,24000,720,560,616,886,769,772,15310,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE},
    
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    {480,360,6000, 624,504,552,746,721,724,2793,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7000, 640,512,560,750,721,724,3360,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7200, 640,512,560,751,721,724,3461,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,7500, 640,512,560,752,721,724,3610,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,8500, 640,512,560,756,721,724,4113,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,10000,656,512,568,763,721,724,5005,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,12000,656,512,568,772,721,724,6077,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,14000,656,512,568,781,721,724,7173,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,14400,656,512,568,783,721,724,7397,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,15000,656,512,568,786,721,724,7734,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,17000,672,520,576,795,721,724,9082,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,20000,672,520,576,810,721,724,10886,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {480,360,24000,672,520,576,831,721,724,13402,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    {400,300,6000, 512,416,456,622,601,604,1911,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7000, 528,424,464,625,601,604,2310,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7200, 528,424,464,626,601,604,2380,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,7500, 528,424,464,627,601,604,2483,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,8500, 528,424,464,630,601,604,2827,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,10000,528,424,464,636,601,604,3358,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,12000,544,432,472,643,601,604,4198,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,14000,544,432,472,651,601,604,4958,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,14400,544,432,472,653,601,604,5115,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,15000,544,432,472,655,601,604,5345,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,17000,544,432,472,663,601,604,6131,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,20000,560,432,480,675,601,604,7560,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {400,300,24000,560,432,480,692,601,604,9300,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    {320,240,6000, 400,328,360,497,481,484,1193,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7000, 400,328,360,500,481,484,1400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7200, 416,336,368,501,481,484,1501,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,7500, 416,336,368,502,481,484,1566,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,8500, 416,336,368,505,481,484,1786,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,10000,416,336,368,509,481,484,2117,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,12000,432,344,376,515,481,484,2670,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,14000,432,344,376,521,481,484,3151,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,14400,432,344,376,522,481,484,3247,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,15000,432,344,376,524,481,484,3396,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,17000,432,344,376,531,481,484,3900,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,20000,432,344,376,540,481,484,4666,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,240,24000,448,352,384,554,481,484,5957,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    {320,200,6000, 400,328,360,417,401,404,1168,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7000, 400,328,360,417,401,404,1168,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7200, 400,328,360,418,401,404,1204,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,7500, 400,328,360,418,401,404,1254,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,8500, 416,336,368,421,401,404,1489,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,10000,416,336,368,424,401,404,1764,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,12000,416,336,368,429,401,404,2142,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,14000,432,344,376,434,401,404,2625,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,14400,432,344,376,435,401,404,2706,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,15000,432,344,376,437,401,404,2832,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,17000,432,344,376,442,401,404,3246,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,20000,432,344,376,451,401,404,3897,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE},
    {320,200,24000,448,352,384,462,401,404,4967,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE}
};

//*****************************************************************************
//
// VESA 1.0 rev 0.7 DMT timings
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7 
// Monitor Timing Specifications.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity 
// VSync polarity 
//
// NOTE: Unlike GTF timings, DMT does not dictate zero border widths.
// Therefore we must include blank start and end positions. 
//
unsigned int DMTTimingTableNT[][16] =
{

    // Settings for 320x200 (mode doubled 640x400):
    //  NOTE: There is no 60Hz 320x200, so use 70Hz if anyone wants 60Hz
    {320,200,6000,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {320,200,7000,800/2,640/2,656/2,752/2,288/2,449,400,412,414,449,2518/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {320,200,8500,832/2,640/2,672/2,736/2,832/2,445,400,401,404,445,3150/2,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 320x240 (mode doubled 640x480):
	{320,240,6000,800/2,648/2,656/2,752/2,792/2,525,488,490,492,517,2518/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,7200,832/2,648/2,664/2,704/2,824/2,520,488,489,492,512,3150/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,7500,840/2,640/2,656/2,720/2,840/2,500,480,481,484,500,3150/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{320,240,8500,832/2,640/2,696/2,752/2,832/2,509,480,481,484,509,3600/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 400x300 (mode doubled 800x600):
	{400,300,6000,1056/2,800/2,840/2,968/2,1056/2,628,600,601,605,628,4000/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,7200,1040/2,800/2,856/2,976/2,1040/2,666,600,637,643,666,5000/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,7500,1056/2,800/2,816/2,896/2,1056/2,625,600,601,604,625,4950/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{400,300,8500,1048/2,800/2,832/2,896/2,1048/2,631,600,601,604,631,5625/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 512x384 (mode doubled 1024x768):
	{512,384,6000,1344/2,1024/2,1048/2,1184/2,1344/2,806,768,771,777,806,6500/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{512,384,7000,1328/2,1024/2,1048/2,1184/2,1328/2,806,768,771,777,806,7500/2,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{512,384,7500,1312/2,1024/2,1040/2,1136/2,1312/2,800,768,769,772,800,7875/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{512,384,8500,1376/2,1024/2,1072/2,1168/2,1376/2,808,768,769,772,808,9450/2,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 640x400:
    //  NOTE: There is no 60Hz 640x400, so use 70Hz if anyone wants 60Hz
    {640,400,6000,800,640,656,752,288,449,400,412,414,449,2518,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {640,400,7000,800,640,656,752,288,449,400,412,414,449,2518,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},
    {640,400,8500,832,640,672,736,832,445,400,401,404,445,3150,
    	BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 640x480:
	{640,480,6000,800,648,656,752,792,525,488,490,492,517,2518,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,7200,832,648,664,704,824,520,488,489,492,512,3150,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,7500,840,640,656,720,840,500,480,481,484,500,3150,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{640,480,8500,832,640,696,752,832,509,480,481,484,509,3600,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 800x600:
	{800,600,6000,1056,800,840,968,1056,628,600,601,605,628,4000,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,7200,1040,800,856,976,1040,666,600,637,643,666,5000,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,7500,1056,800,816,896,1056,625,600,601,604,625,4950,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{800,600,8500,1048,800,832,896,1048,631,600,601,604,631,5625,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1024x768:
	{1024,768,6000,1344,1024,1048,1184,1344,806,768,771,777,806,6500,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{1024,768,7000,1328,1024,1048,1184,1328,806,768,771,777,806,7500,
		BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},
	{1024,768,7500,1312,1024,1040,1136,1312,800,768,769,772,800,7875,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1024,768,8500,1376,1024,1072,1168,1376,808,768,769,772,808,9450,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1152x864:
	{1152,864,7500,1600,1152,1216,1344,1600,900,864,865,868,900,10800,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

	// Settings for 1280x1024:
	{1280,1024,6000,1688,1280,1328,1440,1688,1066,1024,1025,1028,1066,10800,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1280,1024,7500,1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1280,1024,8500,1728,1280,1344,1504,1728,1072,1024,1025,1028,1072,15750,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1600x1024 (OEM requested version of 76Hz)
    {1600,1024,7600,2096,1600,1632,1792,2096,1070,1024,1027,1030,1070,17045,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE},

	// Settings for 1600x1200:
	{1600,1200,6000,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,16200,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,6500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,17550,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,7000,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,18900,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,7500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,20250,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},
	{1600,1200,8500,2160,1600,1664,1856,2160,1250,1200,1201,1204,1250,22950,
		BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE},

    // Settings for 1920x1200 (OEM requested version of 76Hz)
    {1920,1200,7600,2584,1920,1984,2240,2584,1250,1200,1203,1206,2584,24548,
        BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE}
};

// This function scans the GTF table for the requested resolution/refresh rate
// and returns the timing values for it.
unsigned int vesaGetGTFTimings
(
    unsigned int hRes,
    unsigned int vRes,
    unsigned int refreshRate,
    MODE_TIMING_VALUES * timingInfo
)
{
    unsigned int numEntries;
    unsigned int i;

    // Check for the multi-mon modes.
    if (MULTIMON_MODE(hRes, vRes)) 
       {
       if (HORIZONTAL_MODE(hRes, vRes))
          {
          hRes /= 2;
          }
       else
          {
          if (VERTICAL_MODE(hRes, vRes))
             {
             vRes /= 2;
             }
          }
       }


    // For each mode, there are 12 (unsigned int) timing values
    numEntries = sizeof(GTFTimingTable) / (sizeof(unsigned int) * 12);

    // refresh rate is in terms of Hz * 100 in the table.
    refreshRate *= 100;

    for (i = 0; i < numEntries; i++)
    {
        if (GTFTimingTable[i][0] == hRes &&
            GTFTimingTable[i][1] == vRes &&
            GTFTimingTable[i][2] == refreshRate)
        {
            // Found the mode we want.
            // Copy the timing values.
            // NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
            // Blank End == Total.
            timingInfo->HorizontalVisible       = GTFTimingTable[i][0]; 
            timingInfo->VerticalVisible         = GTFTimingTable[i][1];
            timingInfo->Refresh                 = GTFTimingTable[i][2];
            timingInfo->HorizontalTotal         = GTFTimingTable[i][3]; 
            timingInfo->HorizontalBlankStart    = timingInfo->HorizontalVisible; 
            timingInfo->HorizontalRetraceStart  = GTFTimingTable[i][4]; 
            timingInfo->HorizontalRetraceEnd    = GTFTimingTable[i][5]; 
            timingInfo->HorizontalBlankEnd      = timingInfo->HorizontalTotal;
            timingInfo->VerticalTotal           = GTFTimingTable[i][6]; 
            timingInfo->VerticalBlankStart      = timingInfo->VerticalVisible; 
            timingInfo->VerticalRetraceStart    = GTFTimingTable[i][7]; 
            timingInfo->VerticalRetraceEnd      = GTFTimingTable[i][8]; 
            timingInfo->VerticalBlankEnd        = timingInfo->VerticalTotal;
            timingInfo->PixelClock              = GTFTimingTable[i][9];
            timingInfo->HSyncpolarity           = GTFTimingTable[i][10]; 
            timingInfo->VSyncpolarity           = GTFTimingTable[i][11]; 

            // return success.
            return 0;
        } // found the matching mode
    } // loop over all the modes in the table

    // Did not find the specifed resolution/refresh rate conbination.
    return 1;
} // end of vesaGetGTFTimings

// This function scans the DMT table for the requested resolution/refresh rate
// and returns the timing values for it.
unsigned int vesaGetDMTTimings
(
    unsigned int hRes,
    unsigned int vRes,
    unsigned int refreshRate,
    MODE_TIMING_VALUES * timingInfo
)
{
    unsigned int numEntries;
    unsigned int i;

    // Check for the multi-mon modes.
    if (MULTIMON_MODE(hRes, vRes)) 
       {
       if (HORIZONTAL_MODE(hRes, vRes))
          {
          hRes /= 2;
          }
       else
          {
          if (VERTICAL_MODE(hRes, vRes))
             {
             vRes /= 2;
             }
          }
       }

    // For each mode, there are 16 (unsigned int) timing values
    numEntries = sizeof(DMTTimingTableNT) / (sizeof(unsigned int) * 16);

    // refresh rate is in terms of Hz * 100 in the table.
    refreshRate *= 100;

    for (i = 0; i < numEntries; i++)
    {
        if (DMTTimingTableNT[i][0] == hRes &&
            DMTTimingTableNT[i][1] == vRes &&
            DMTTimingTableNT[i][2] == refreshRate)
        {
            // Found the mode we want.
            // Copy the timing values.
            timingInfo->HorizontalVisible       = DMTTimingTableNT[i][0]; 
            timingInfo->VerticalVisible         = DMTTimingTableNT[i][1];
            timingInfo->Refresh                 = DMTTimingTableNT[i][2];
            timingInfo->HorizontalTotal         = DMTTimingTableNT[i][3]; 
            // timingInfo->HorizontalBlankStart    = DMTTimingTableNT[i][4]; 
            timingInfo->HorizontalBlankStart    = timingInfo->HorizontalVisible; 
            timingInfo->HorizontalRetraceStart  = DMTTimingTableNT[i][5]; 
            timingInfo->HorizontalRetraceEnd    = DMTTimingTableNT[i][6]; 
            // timingInfo->HorizontalBlankEnd      = DMTTimingTableNT[i][7];
            timingInfo->HorizontalBlankEnd      = timingInfo->HorizontalBlankStart
                            + (timingInfo->HorizontalTotal - DMTTimingTableNT[i][7]);
            timingInfo->VerticalTotal           = DMTTimingTableNT[i][8]; 
            // timingInfo->VerticalBlankStart      = DMTTimingTableNT[i][9]; 
            timingInfo->VerticalBlankStart      = timingInfo->VerticalVisible; 
            timingInfo->VerticalRetraceStart    = DMTTimingTableNT[i][10]; 
            timingInfo->VerticalRetraceEnd      = DMTTimingTableNT[i][11]; 
            // timingInfo->VerticalBlankEnd        = DMTTimingTableNT[i][12];
            timingInfo->VerticalBlankEnd        = timingInfo->VerticalBlankStart 
                            + (timingInfo->VerticalTotal - DMTTimingTableNT[i][12]);
            timingInfo->PixelClock              = DMTTimingTableNT[i][13];
            timingInfo->HSyncpolarity           = DMTTimingTableNT[i][14]; 
            timingInfo->VSyncpolarity           = DMTTimingTableNT[i][15]; 

            // success.
            return 0;
        } // found the matching mode
    } // loop over all the modes in the table

    // Did not find the specifed resolution/refresh rate conbination.
    return 1;
} // end of vesaGetDMTTimings


// This function simply returns the number of entries in the GTF table
// 

unsigned int vesaGetNumGTFEntries
(
void
)
{
    unsigned int numEntries;

    // For each mode, there are 12 (unsigned int) timing values
    numEntries = sizeof(GTFTimingTable) / (sizeof(unsigned int) * 12);

    return(numEntries);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\timing.h ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: timing.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           9/23/98                                          *
*                                                                           *
\***************************************************************************/

#ifndef timing_h
#define timing_h


#define	TIMINGTYPES			U032
#define  NOTIFYTRAN			(0x0 + 1 )

#define  NOTIFYIMG			(0x0 + 2 )
#define 	OVFLIPREQ			(0x0 + 3 )
#define 	OVFLIPNOT			(0x0 + 4 )
#define  TRANSFERRECRE		(0x0 + 5 )
#define  TRANSBUFTYPE      (0x0 + 6 ) 
#define  OVERLAYFAIL       (0x0 + 7 )
#define  PROGRAMVBI        (0x0 + 8 )
#define  PROGRAMIMG        (0x0 + 9 )
#define  NOTIFYVBI         (0x0 + 10 )
#define  CHECKCURBUF       (0x0 + 11 )
#define  CHECKLASTBUF      (0x0 + 12 )
#define  CHECKCURFLD       (0x0 + 13 )
// for the color control section
#define  ENTERCOLORCTL     (0x0 + 14 )
#define  LEAVECOLORCTL     (0x0 + 15 )
#define  WAITOCCCOLORCTL   (0x0 + 16 )
#define  WAITCHROMAARRIVE  (0x0 + 17 )
#define  WAITCHROMARETURN  (0x0 + 18 )
#define  WAITLUMAARIVE     (0x0 + 19 )
#define  WAITLUMARETURN    (0x0 + 20 )
#define  OVERLAYFLIPDEFERED (0x0 + 21 )
#define  DEFEREDOVERFLIP    (0x0 + 22 )

#define  TRANSFERLAUNCH		(0x0 + 23 )
#define  ALMEMRESTART      (0x0 + 24)

#define  NUMTIMTYPES 			 (ALMEMRESTART)


// this next one is used when the indice is hard to define in  that particular location
#define  INCNOTAP				(0xE)

#define  makeInd(vbibuf,vbisurf,imgbug,imgsurf) \
        (((((MySurfaces.DropSystem.dwDropFields & 0x3) | (MySurfaces.DropSystem.dwFullBool << 2))  & 0x0f) << 20)  |          \
			   ((INCNOTAP   & 0x0f) << 16)  |				\
			   ((vbibuf  & 0x0f) << 12)  |				\
			   ((vbisurf & 0x0f) << 8)  |				\
			   ((imgbug  & 0x0f) << 4 )  |				\
			   ((imgsurf & 0x0f)      )  )


#define  makeInd2(vbibuf,vbisurf,imgbug,imgsurf,field) \
         ( ((field   & 0x0f) << 16)  |          \
			  ((vbibuf  & 0x0f) << 12)  |				\
			  ((vbisurf & 0x0f) << 8)  |				\
			  ((imgbug  & 0x0f) << 4 )  |				\
			  ((imgsurf & 0x0f)      )  )


typedef struct _timeStore {

	U032					marker;
	U032					LoopCount;
	U032					Time0[MAXDATASTORE];
	U032					Time1[MAXDATASTORE];
	U032					SurfDat[MAXDATASTORE];
	U032					SurfIndex[MAXDATASTORE];
	U032					SurfPtr[MAXDATASTORE];
} timeStore;

void MarkTimingNot(TIMINGTYPES timingType,NvNotification*  pNot, U032 pSurf, U032 Indices);
void	MarkTiming(TIMINGTYPES timingType,U032 pSurf, U032 Indices);
void InitTiming(void);


#endif //timing_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\transfer.h ===
/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: transfer.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           8/17/98                                          *
*                                                                           *
\***************************************************************************/
// Implements a FIFO scheme to queue up transfer which the MTM engine will use

#ifndef TRANSFER_H
#define TRANSFER_H


#define MAXTRANSFERS	(10)
#define TRANSFERNOTINUSE (0xFEEDC0DE)

#ifdef DECENTENUMS
enum {
	QUEUED	= 30,
	PROGRAMMED,
	FINISHED,
	
} TRANSSTAT;
#else

#define TRANSSTAT U032
#define QUEUED      (30)
#define PROGRAMMED  (31)
#define FINISHED    (32)
#define ERRORED     (33)

#endif //DECENTENUMS

typedef struct _aTransfer
{
	U032			TransferID;		// if not equal to TRANSFERNOTINUSE then in use!
	TRANSSTAT	transferStatus;
	U032*			pNextTransfer;
	// "real" data from MS
	U032	SurfaceData;
	U032	StartLine;
	U032  EndLine;
	U032	TransferFlags;
	PMDL	DestMDL;
	
} aTransfer;

typedef aTransfer*	pTransfer;

// adds a transfer to the next position on the list
pTransfer AddTransfer(U032 TransferID);

pTransfer GetNextTransfer();

pTransfer FindTransfer(U032 TransferID);

U032 RemoveTransfer(U032 TransferID);

void CheckForLaunch(void);
U032 SetupMTM(void);
void TearDownMTM(void);

U032 checkNvAllocArchError(U032 error);

U032 UpdateStatus(void);

U032 CancelTransfer(DDTRANSFERININFO* pTransferInInfo);


#endif //TRANSFER_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\vpcallbk.h ===
#ifndef __VPCALLBK_H__
#define __VPCALLBK_H__

/***************************************************************************\
* (C) Copyright NVIDIA Corporation Inc.,                                    *
*  1996,1997, 1998. All rights reserved.                                    *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: VPcallbk.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           5/28/98                                          *
*                                                                           *
\***************************************************************************/



typedef struct _sCallBack {
    DWORD       dwSize;             // should be set to the size of this structure
    DWORD       dwVersion;          // set this to 0x100
    DWORD       dwFlags;                //
    DWORD       lastBufferAddr; // address of just finished buffer ( the one the client should unload )
    DWORD    curBufferAddr;    // address of current input buffer ( one that is now being written to by MP )
    DWORD       intCount;           // free running interrupt counter - incremented for each time the callback is made
} sCallBack;

/* callback procedure pointer definition */

typedef VOID (* CALLBPROC)(sCallBack*);

/*  These macros should will be ORed together to form the flags field  */

/* field type */                        // Bit 0
#define     ODDFIELD            0x1
#define     EVENFIELD       0x0
/* address type */                  // bits 1-2 
                                            // indicates that the buffer address really an offset from the base of the frame buffer memory
#define     BUFFADROFFSET   0x2 
                                            // indicates that the buffer address is a Physical address
#define     BUFFADRPHYS     0x4
                                            // indicates that the buffer address is a linear address ( see note below)
#define     BUFFADRLIN      0x6
                                            // indicates that the buffer address is an index into the list from DDRAW
#define     BUFFADRINDEX    0x0     
/* surface type */                  //bits 4
                                            // indicates that the surface contains VBI data
#define     VBISURFACE      0x10        
                                            // indicates that the surface contains IMAGE data
#define     IMAGESURFACE    0x00        
                                            
                                            // should always be ORed in to indicate that the flags are valid
#define     USINGFLAGS      0x80        

/*   NOTES

Notes for the client:

Allways hold the callback routine in locked memory.
When setting the callback, it can be called even before SetCallback returned. In this
case the callback routine cannot know about the context. So the callback routine needs
to ignore calls until it knows about the context.

Notes about Linear Address:

If a linear address is used, this address must be a ring 3 addressable Address in System range.
It should be the same address as ddSurface->Lock method returns.

Notes about Surface Index:

If this is to be used the index order should be the determined by the
attachment order when the surfaces are created (FrontBuffer = 0,BackBuffer = 1 ....)
This is nornally indetically to the flipping order. ???

*/



// USE THIS IOCTL CODE TO GET YOUR SETCALLBACK FUNCTION POINTER:
#define VDD_IOCTL_NV_GETSETCALLBACK  0x20000668     
//  This IOCTL allows you to get an address for a routine which can be called to set the callback.
//  The idea behind the indirection is that an application can use the IOCTL to get an address
//  which an associated VXD can use to set callbacks into itself.  The VXD is also capable of resetting
//  the callbacks in the situation where the application has crashed and the VXD is unloading itself.
//  input to IOCTL is U032 and is ignored
//  output to IOCTL is U032 and is a function pointer to a function ie  SETCALLBPROC



// USE the following structures to actually SET a callback
// input pointer points to a structure
typedef struct _inSCBStruct {
    DWORD       flags;
    CALLBPROC   pTheCallback;
} inSCBStruct;
// output pointer points to a structure
typedef struct _outSCBStruct {
    DWORD   returnValue;
} outSCBStruct;

// USE THIS FUNCTION POINTER TO SET YOUR CALLBACK:

//DWORD vddSetCallback(inSCBStruct* inbuffer, outSCBStruct* outbuffer);
typedef VOID (* SETCALLBPROC)(inSCBStruct*  inbuffer, outSCBStruct* outbuffer);


/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */


// Here is some real basic example code

#ifdef JUST_EXAMPLE_CODE
        HANDLE bVXDHandle;
        U032     inBuffer;
        U032     outputSize;
        SETCALLBPROC    pSetCallback;
        
        inBuffer = 0;       
        
#ifdef NV3      
        bVXDHandle = CreateFile("\\\\.\\NV3", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#else
        bVXDHandle = CreateFile("\\\\.\\NV4", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
#endif  // NV4      
        if((bVXDHandle != NULL ) && (bVXDHandle != INVALID_HANDLE_VALUE ) ){
            if(!DeviceIoControl(bVXDHandle,
                                        VDD_IOCTL_NV_GETSETCALLBACK,        // control code of operation to perform
                                        &inBuffer,                          // pointer to buffer to supply input data
                                        4,                                      // size of input buffer
                                        &pSetCallback,                      // pointer to buffer to receive output data
                                        4,                                      // size of output buffer
                                        &outputSize,                        // pointer to variable to receive output byte count
                                        NULL                                    // pointer to overlapped structure for asynchronous operation
                                    )
                 ){                 
                        // things worked, the
                        inSCBStruct     inBuf;
                        outSCBStruct    outBuf;
                        // NOTE USE OF FLAGS FROM VPCALLBk.h
                        inBuf.flags = IMAGESURFACE;
                        inBuf.pTheCallback = JoeCoolDudesCallbackRoutine;
                        
                        (pSetCallback)(&inBuf,&outBuf);
                        
            } else {
                        
                        // bummer, for some reason, we were unable to set your callback
            
            }
                    
            CloseHandle(bVXDHandle);
                                    
        }
        
        
#endif  //JUST_EXAMPLE_CODE 
    
    

#endif //__VPCALLBK_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\VidTex.h ===
/***************************************************************************\
* Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
* Module: VidTex.h                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       schaefer           11/16/98                                          *
*                                                                           *
\***************************************************************************/

#ifndef VidTex_h
#define VidTex_h

#ifndef U032
#define U032  unsigned long
#endif //U032

typedef struct _VidTexSurf {
	// this first record is probably not necessary
//	U032		frameBufferOffsetConv; // input	// bytes from base of FB to begin of color space converted image
	U032		frameBufferOffsetSwiz; // input	// bytes from base of FB to begin of swized image
	U032		width;				// input		//pixels			should be power of 2
	U032		height;				// input		//pixels			should be power of 2
	U032		pitch;				// input		// bytes			should be width * (bytes/pixel)
	U032		format;				// input		//Same as NV052_SET_FORMAT_COLOR_LE_XXXXXX  color
	U032		dwFrameCount;		// output	// is incremented each frame, and will simply wrap
	U032		bUpdateSystem;		// N/A/     this should be set to true each time you update the input records
										//          the VXD will set it back to false after updating context DMA etc
	U032		bContextsAllocated;	// N/A  used by VXD to keep track of contexts
} VidTexSurf;

void fillVidTexSurface(DWORD surface );
void initTextureSurf(void);
void DestroyTextureSurf(void);

#define VDD_IOCTL_NV_SETVIDTEXSURF 		0x20000669


/* =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-= */


// Here is some real basic example code

#ifdef JUST_EXAMPLE_CODE
	{
		HANDLE bVXDHandle;
		
		// These should _NOT NOT NOT_ be declared on the stack.. this is just _example_ code
		VidTexSurf MyVidTexureSurface;
		U032	 		outBuffer;
		U032			outputSize;
		
		VidTexSurf*	pVidTextureSurface = &MyVidTexureSurface;
		
		
		
		bVXDHandle = CreateFile("\\\\.\\NV4", 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);

		if((bVXDHandle != NULL ) && (bVXDHandle != INVALID_HANDLE_VALUE ) ){
			if(!DeviceIoControl(bVXDHandle,
										VDD_IOCTL_NV_SETVIDTEXSURF,		// control code of operation to perform
										&pVidTextureSurface,							// pointer to buffer to supply input data
										4,										// size of input buffer
										&outBuffer,						// pointer to buffer to receive output data
										4,										// size of output buffer
										&outputSize,						// pointer to variable to receive output byte count
										NULL 									// pointer to overlapped structure for asynchronous operation
									)
				 ){					
					// things worked, the 
					if(outBuffer != 0 ) {
						// error check outBuffer error code
					
					}						
			} else {
							// error check outBuffer error code
			}
					
			CloseHandle(bVXDHandle);
									
		}
		
		
#endif  //JUST_EXAMPLE_CODE	
	
	


#endif //VidTex_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\inc\nvpecore.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1996,1997,1998,1999. All rights reserved.

    nvpecore.h

    Local definitions used by vpe and kernel mode video transport

    Dec 17, 1999

==============================================================================
*/

#ifdef _WIN32_WINNT

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"
#include "nv32.h"
#include "nvos.h"
#include "nvpeos.h"

#include "nvpekmvt.h"

#else // _WIN32_WINNT

// MS includes
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>
#include <vwin32.h>

// NV includes 
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>
#include <nvrmr0api.h>

#include "ddkmmini.h"

#include "nvpeos.h"

#endif // _WIN32_WINNT

//// VPE/kernel interface 
#include "nvpesrvc.h"


#define BUFSIZE	720*(576+4)*2	//size of sys mem buffer for dma xfer

//some debug stuff

extern int DebugLevel;

#ifndef _WIN32_WINNT
#define KdPrint(DBG_STR)	{	_Debug_Printf_Service("NVPECORE: ");	\
								_Debug_Printf_Service(DBG_STR);			\
								_Debug_Printf_Service("\n");}

#define KdPrintValue(DBG_STR, DBG_VALUE)	{	_Debug_Printf_Service("NVPECORE: ");	\
								_Debug_Printf_Service("%s %d", DBG_STR, DBG_VALUE);				\
								_Debug_Printf_Service("\n");}
#else
#define KdPrint(DBG_STR)	{	DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVPECORE: ");	\
								DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, DBG_STR);			\
								DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "\n");}

#define KdPrintValue(DBG_STR, DBG_VALUE)	{	DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVPECORE: ");	\
								DBG_PRINT_STRING_VALUE(DEBUGLEVEL_WARNINGS, DBG_STR, DBG_VALUE);			\
								DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "\n");}
#endif

#define DBGERROR	0
#define DBGWARN		1
#define DBGINFO		2
#define DBGTRACE	3
#define DBGPRINT(DbgLevel, DbgStr)	{if(DebugLevel >= DbgLevel) {KdPrint(DbgStr);}}
#define DBGPRINTVALUE(DbgLevel, DbgStr, DbgValue)	{if(DebugLevel >= DbgLevel) {KdPrintValue(DbgStr, DbgValue);}}
								
#define NVP_CLASS04D_MAX_NOTIFIERS			9
#define NVP_CLASS039_MAX_NOTIFIERS			2
#define NVP_CLASS07A_MAX_NOTIFIERS          3

#ifdef VPEFSMIRROR
// [XW:09/29/2000]
#define NVP_CLASS089_MAX_NOTIFIERS          1
#define NVP_CLASS07C_MAX_NOTIFIERS          9

#define NVP_VIDEO_LUT_DAC_SUBCHANNEL 3
#define NVP_SCALED_IMAGE_SUBCHANNEL  4
#define NVP_FREE_SUBCHANNEL          7

// [XW:09/26/2000] FS Mirror Functions
VP_STATUS NVPIsFsMirrorEnabled(PHW_DEVICE_EXTENSION pHwDevExt,NVP_CMD_OBJECT *pInCmdObj);
VP_STATUS NVPFsRegSurface(PHW_DEVICE_EXTENSION pHwDevExt,NVP_CMD_OBJECT *pCmdObj);
VP_STATUS NVPFsMirrorEnable(PHW_DEVICE_EXTENSION pHwDevExt,NVP_CMD_OBJECT *pCmdObj);
VP_STATUS NVPFsMirrorDisable(PHW_DEVICE_EXTENSION pHwDevExt,NVP_CMD_OBJECT *pCmdObj);
VP_STATUS NVPFsFlip(PNVP_CONTEXT pVPEContext,int nFieldId);
VP_STATUS NVPFsMirror(PNVP_CONTEXT pVPEContext,PNVP_OVERLAY pOverlayInfo,DWORD dwOffset,DWORD dwPitch,DWORD dwWidth,DWORD dwHeight,DWORD dwIndex,DWORD dwFlags);

#ifdef _WIN32_WINNT

void NVPFsCRTCField0Notify(PVOID pHwDeviceExtension);
void NVPFsCRTCField1Notify(PVOID pHwDeviceExtension);
#else

void NVPFsCRTCField0Notify();
void NVPFsCRTCField1Notify();
extern nvpeDevExtension;
#endif


#endif

#ifndef NV01_CONTEXT_DMA
#define NV01_CONTEXT_DMA   NV01_CONTEXT_DMA_FROM_MEMORY
#endif 

#define NVP_VPP_TIME_OUT    10000

///////
/// BUGBUG: taken from dvp.h !!! 
#define DDVP_AUTOFLIP                   0x00000001l
#define DDVP_INTERLEAVE 				0x00000008l
#define DDVP_SKIPEVENFIELDS				0x00000080l
#define DDVP_SKIPODDFIELDS				0x00000100l
#define DDVPCONNECT_INVERTPOLARITY		0x00000004l
#define DDVPCONNECT_INTERLACED			0x00000020l

#define DDFLIP_EVEN                     0x00000002L
#define DDFLIP_ODD                      0x00000004L

#define NV_VFM_FORMAT_BOBFROMINTERLEAVE 0x08000000l

/// equivalent in nvReg.h
#define VPP_ODD            0x001
#define VPP_EVEN           0x002
#define VPP_BOB            0x004
#define VPP_INTERLEAVED    0x008
#define VPP_PRESCALE       0x400

#define NV_PRESCALE_OVERLAY_X           1
#define NV_PRESCALE_OVERLAY_Y           2
#define NV_PRESCALE_OVERLAY_FIELD       4

#define IS_FIELD(f) ((f & (VPP_INTERLEAVED | VPP_BOB)) && (f & (VPP_ODD | VPP_EVEN)))

#ifndef NV_IN_PROGRESS
#define NV_IN_PROGRESS (0x8000)
#endif

#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L


#ifdef	asmMergeCoords
#undef	asmMergeCoords
#endif
#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)

#ifndef mmioFOURCC
#define mmioFOURCC( ch0, ch1, ch2, ch3 )                                \
                ( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |    \
                ( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )
#endif // mmioFOURCC

///////////
// external services
//

#ifndef NvGetFreeCount
#if defined NV10 || defined NV4
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.Free
#else   /* !(NV10 || NV4) */
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.free
#endif  /* !(NV10 || NV4) */
#endif

//////////
// DMA channel macros
//
#define NVP_JUMP(ADDR)		(0x20000000 | (ADDR))
#define NVP_DECODER_SUBCHANNEL	0
#define NVP_M2M_SUBCHANNEL		1
#define NVP_DMAPUSH_WRITE1(SUBCH, METHOD_OFFSET, METHOD_VALUE)              			\
{\
	pVPEContext->nvDmaFifo[nvDmaCount++] = ((1 <<18) | ((SUBCH)<<13) | (METHOD_OFFSET)); \
    pVPEContext->nvDmaFifo[nvDmaCount++] = METHOD_VALUE;                        			\
}
// assuming the FIFO is at least twice (2x + 1) the size of NEEDED_DWORDS
#define NVP_DMAPUSH_CHECK_FREE_COUNT(NEEDED_DWORDS)		\
{	\
	if ((nvDmaCount + (NEEDED_DWORDS)) >= (pVPEContext->DmaPushBufTotalSize >> 2))	\
	{	\
		pVPEContext->nvDmaFifo[nvDmaCount] = 0x20000000;	\
		nvDmaCount = 0;	\
		DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "nvpecore: DMA wrap around...\n");\
	}	\
}

////////////
// local functions prototypes
//
void VideoField0Notify(PVOID pHwDeviceExtension);
void VideoField1Notify(PVOID pHwDeviceExtension);
void VBIField0Notify(PVOID pHwDeviceExtension);
void VBIField1Notify(PVOID pHwDeviceExtension);
void NVPProgVideoField(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int nFieldId, U032 dwSurfPitch, U032 dwInterleaveOffset, BOOL bGrab);
void NVPProgVBIField(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int nFieldId);
VP_STATUS NVPProcessState(PHW_DEVICE_EXTENSION pHwDevExt, int nFieldId,	BOOL bVBIField);
VP_STATUS NVPScheduleOverlayFlip(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int  nImageId, U032 dwSrcPitch, U032 dwMoveDownOffset);
VP_STATUS DoProgressive(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoWeave(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoBob(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoBobFromInterleaved(PNVP_CONTEXT pVPEContext, int nFieldId);
BOOL NVPGetSurface(	PNVP_CONTEXT pVPEContext,U032 dwSurfOffset, PNVP_SURFACE_INFO *pSurface);
void NVPTransferNotify(PVOID pHwDevExtension);
DWORD NVPCheckTransferStatus(PHW_DEVICE_EXTENSION pHwDevExt);
DWORD NVPCancelTransfer(PNVP_CONTEXT pVPEContext, DDTRANSFERININFO* pInInfo);
DWORD NVPRemoveTransfer(PNVP_CONTEXT pVPEContext, int nTransferIdx);
DWORD NVPAddTransfer(PNVP_CONTEXT pVPEContext, PNVP_DDTRANSFERININFO pInInfo, BOOL bIsOddField);
DWORD NVPGetTransferStatus(PVOID pContext, PVOID pNotUsed, PNVP_DDGETTRANSFEROUTINFO pOutInfo);
DWORD NVPCheckForLaunch(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface);
DWORD NVPRecreateContext(PNVP_CONTEXT pVPEContext, PMDL pDestMDL);
DWORD NVPTransfer(PVOID pContext, PNVP_DDTRANSFERININFO pInInfo, PNVP_DDTRANSFEROUTINFO pOutInfo);
PVOID GetHwInfo(PVOID HwDevExt);
BOOL NVPPrescaleAndFlip(PNVP_CONTEXT pVPEContext, PNVP_OVERLAY pOverlayInfo, DWORD dwOffset, DWORD dwPitch, DWORD dwIndex, DWORD dwFlags);
VP_STATUS NVPFlipVideoPort(PHW_DEVICE_EXTENSION pHwDevExt, NVP_CMD_OBJECT *pCmdObj);
DWORD kmvtNVPCallbackDxApi(PVOID *pContext, DWORD dwIRQSource);
VP_STATUS NVPInitialize(PHW_DEVICE_EXTENSION pHwDevExt,	NVP_CMD_OBJECT *pCmdObj);
VP_STATUS NVPIsVPEEnabled(PHW_DEVICE_EXTENSION pHwDevExt, NVP_CMD_OBJECT *pInCmdObj, NVP_CMD_OBJECT *pOutCmdObj);

#ifdef _WIN32_WINNT
VP_STATUS NVRegistryCallbackPnpId(PVOID HwDeviceExtension, PVOID Context, PWSTR ValueName, PVOID ValueData, ULONG ValueLength);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\inc\nvpe.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1996,1997,1998,1999. All rights reserved.

    nvpe.h

    NVIDIA's VPE driver header

    Jan 27, 1999

==============================================================================
*/

#ifndef _NVPE_H
#define _NVPE_H

// NVP defines
#define NVPAPI  __stdcall

//limit values for VP config
#define NV_MAX_FIELDWIDTH 2000	//since max now is 1920
#define NV_MAX_VBIWIDTH (0x1000)
#define NV_MAX_BUFFERLENGTH (0x80000)
#define NV_MAX_PIXELRATE ( 27000000)
#define NV_MAX_FIELDHEIGHT	1200	//since max now is 1080i

// provides access to the global data structures in ddmini.h
//extern GLOBALDATA *pDriverData;

// NVP function prototypes
DWORD NVPAPI CanCreateVideoPort32 (LPDDHAL_CANCREATEVPORTDATA lpInput);
DWORD NVPAPI CreateVideoPort32 (LPDDHAL_CREATEVPORTDATA lpInput);
DWORD NVPAPI FlipVideoPort32 (LPDDHAL_FLIPVPORTDATA lpInput);
DWORD NVPAPI GetVideoPortBandwidth32 (LPDDHAL_GETVPORTBANDWIDTHDATA lpInput);
DWORD NVPAPI GetVideoPortInputFormat32 (LPDDHAL_GETVPORTINPUTFORMATDATA lpInput);
DWORD NVPAPI GetVideoPortOutputFormat32 (LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput);
DWORD NVPAPI GetVideoPortField32 (LPDDHAL_GETVPORTFIELDDATA lpInput);
DWORD NVPAPI GetVideoPortLine32 (LPDDHAL_GETVPORTLINEDATA lpInput);
DWORD NVPAPI GetVideoPortConnectInfo (LPDDHAL_GETVPORTCONNECTDATA lpInput);
DWORD NVPAPI DestroyVideoPort32 (LPDDHAL_DESTROYVPORTDATA lpInput);
DWORD NVPAPI GetVideoPortFlipStatus32 (LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput);
DWORD NVPAPI UpdateVideoPort32 (LPDDHAL_UPDATEVPORTDATA lpInput);
DWORD NVPAPI WaitForVideoPortSync32 (LPDDHAL_WAITFORVPORTSYNCDATA lpInput);
DWORD NVPAPI GetVideoSignalStatus32 ( LPDDHAL_GETVPORTSIGNALDATA lpInput);	

//
// NVIDIA VP caps
// 
const DDVIDEOPORTCAPS g_ddNVideoPortCaps =
{
    sizeof(DDVIDEOPORTCAPS),    // size of the DDVIDEOPORTCAPS structure
    DDVPD_WIDTH             |
    DDVPD_HEIGHT            |
    DDVPD_ID                |
    DDVPD_CAPS              |
    DDVPD_FX                |
    DDVPD_AUTOFLIP          |
    DDVPD_ALIGN             |
    0,
    4096,                       // VP max width
    4096,                       // max VBI data width
    640,                        // VP max height
    0,                          // VP ID (0 - (dwMaxVideoPorts-1))
    DDVPCAPS_AUTOFLIP       |   // suport autoflip buffers
    DDVPCAPS_INTERLACED     |
    DDVPCAPS_NONINTERLACED  |
    DDVPCAPS_READBACKFIELD  |
//  DDVPCAPS_READBACKLINE   |   // not supported
//  DDVPCAPS_SHAREABLE      |   // not supported 
    DDVPCAPS_SKIPEVENFIELDS |   // can skip even fields
    DDVPCAPS_SKIPODDFIELDS  |   // can skip odd fields
//  DDVPCAPS_SYNCMASTER     |   // not supported
    DDVPCAPS_VBISURFACE     |   // VBI support
	DDVPCAPS_OVERSAMPLEDVBI |
	DDVPCAPS_VBIANDVIDEOINDEPENDENT |	
//  DDVPCAPS_COLORCONTROL   |   // not supported
    0,
    DDVPFX_CROPTOPDATA      |   // 
//  DDVPFX_CROPX            |
//  DDVPFX_CROPY            |
    DDVPFX_INTERLEAVE       |
//  DDVPFX_MIRRORLEFTRIGHT  |   // not supported
//  DDVPFX_MIRRORUPDOWN     |   // not supported
//  DDVPFX_PRESHRINKX       |   // not supported
    DDVPFX_PRESHRINKY       |   // not supported
//  DDVPFX_PRESHRINKXS      |   // not supported
//  DDVPFX_PRESHRINKYS      |   // not supported
    DDVPFX_PRESHRINKXB      |   // down to 1/2, 1/4, 1/8 or 1/16
//  DDVPFX_PRESHRINKYB      |   // 
//  DDVPFX_PRESTRETCHX      |   // LPB never stretches
//  DDVPFX_PRESTRETCHY      |   // LPB never stretches
//  DDVPFX_PRESTRETCHXN     |   // LPB never stretches
//  DDVPFX_PRESTRETCHYN     |   // LPB never stretches
    DDVPFX_VBICONVERT       |
    DDVPFX_VBINOSCALE       |
    DDVPFX_VBINOINTERLEAVE  |
    DDVPFX_IGNOREVBIXCROP   |
    0,
    5,                          // Number of autoflippable surfaces
    8,                          // Byte restriction of placement within surface    ////// BUGBUG must change to NV_BYTE_ALIGNMENT
    1,                          // Byte restriction of width after prescaling
    1,                          // Byte restriction of left cropping
    1,                          // Byte restriction of cropping width
    24,                         // shrink in steps of original width
    0x400,                      // shrink in steps of original height
    5,							// Max number of VBI autoflippable surfaces allowed
    3,							// Optimal number of autoflippable surfaces for hardware
    2,                          // Number of taps the prescaler uses in the X direction (0 - no prescale, 1 - replication, etc.)
    1                           // Number of taps the prescaler uses in the Y direction (0 - no prescale, 1 - replication, etc.)

};

//
// NVIDIA VP Callbacks
//
const DDHAL_DDVIDEOPORTCALLBACKS LPBVideoPortCallbacks =
{
    sizeof(DDHAL_DDVIDEOPORTCALLBACKS),
    DDHAL_VPORT32_CANCREATEVIDEOPORT |
    DDHAL_VPORT32_CREATEVIDEOPORT |
    DDHAL_VPORT32_FLIP |
    DDHAL_VPORT32_GETBANDWIDTH |
    DDHAL_VPORT32_GETINPUTFORMATS |
    DDHAL_VPORT32_GETOUTPUTFORMATS |
    DDHAL_VPORT32_GETFIELD |
    DDHAL_VPORT32_GETLINE |
    DDHAL_VPORT32_GETCONNECT |
    DDHAL_VPORT32_DESTROY |
    DDHAL_VPORT32_GETFLIPSTATUS |
    DDHAL_VPORT32_UPDATE |
    DDHAL_VPORT32_WAITFORSYNC |
    DDHAL_VPORT32_GETSIGNALSTATUS |
    //DDHAL_VPORT32_COLORCONTROL |
    0,
    &CanCreateVideoPort32,
    &CreateVideoPort32,
    &FlipVideoPort32,
    &GetVideoPortBandwidth32,
    &GetVideoPortInputFormat32,
    &GetVideoPortOutputFormat32,
    NULL,
    &GetVideoPortField32,
    &GetVideoPortLine32,
    &GetVideoPortConnectInfo,
    &DestroyVideoPort32,
    &GetVideoPortFlipStatus32,
    &UpdateVideoPort32,
    &WaitForVideoPortSync32,
    &GetVideoSignalStatus32,
    NULL
};

//
// Kernel callbacks table exported through the GetDriverInfo interface
//
const DDHAL_DDKERNELCALLBACKS KernelCallbacks =
{
    sizeof(DDHAL_DDKERNELCALLBACKS),
    // DDHAL_KERNEL_SYNCSURFACEDATA | 
    // DDHAL_KERNEL_SYNCVIDEOPORTDATA | 
    0,
    NULL,	// SafeSyncSurfaceData
    NULL	// SafeSyncVideoPortData
};

//
// NVIDIA VP connection caps
// 
const DWORD g_dwNVPConnectionCaps = { 
	//DDVPCONNECT_DOUBLECLOCK			|
	//DDVPCONNECT_VACT					|
	DDVPCONNECT_INVERTPOLARITY		|
	/* we discard at least until the V bit goes low, and potentially more depending
	  on the setting of YCROP  as well as the current VBI situation  */
	//DDVPCONNECT_DISCARDSVREFDATA	|
	DDVPCONNECT_HALFLINE			|
	/*  these next are "client" only 
	//DDVPCONNECT_INTERLACED			|
	//DDVPCONNECT_SHAREEVEN			|
	//DDVPCONNECT_SHAREODD				|
	*/
	0 
};

// video format
DDPIXELFORMAT g_aNVPVideoFormat[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC, mmioFOURCC('U','Y','V','Y'), 16, (DWORD)-1, (DWORD)-1, (DWORD)-1},
};

// VBI format
DDPIXELFORMAT g_aNVPVBIFormat[] = {
	{sizeof(DDPIXELFORMAT),DDPF_FOURCC, mmioFOURCC('R','A','W','8'), 8, (DWORD)-1, (DWORD)-1, (DWORD)-1},
};

// driver global data
//extern 		GLOBALDATA*			pDriverData;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\inc\nvpkrnl.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright
    1996,1997,1998,1999. All rights reserved.

    nvpkrnl.h

    DDrawVPE-Miniport interface header

    Feb 10, 1999

==============================================================================
*/

#ifndef _NVPKRNL_H
#define _NVPKRNL_H

#include "nvprecomp.h"

// event indices
#define NVP_EVENT_MEDIAPORT 0
#define NVP_EVENT_OVERLAY1  1
#define NVP_EVENT_OVERLAY2  2
#define NVP_EVENT_MAX       3

typedef enum _NVP_STATUS {
    NVP_STATUS_SUCCESS  = 0x0,
    NVP_STATUS_FAILURE,
    NVP_STATUS_NOT_IMPLEMENTED,
    MVP_STATUS_INVALID_ARGUMENT
} NVP_STATUS;

// interface to Miniport
NVP_STATUS NVPInitialize(	GLOBALDATA *pDriverData, DWORD dwVPConnectionFlags, 
							LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
NVP_STATUS NVPUninitialize(GLOBALDATA *pDriverData);
NVP_STATUS NVPStartVideo(LPDDHAL_UPDATEVPORTDATA lpInput);
NVP_STATUS NVPStopVideo(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
NVP_STATUS NVPUpdateVideo(LPDDHAL_UPDATEVPORTDATA lpInput);
NVP_STATUS NVPWaitForSync(GLOBALDATA *pDriverData, DWORD dwIndex, DWORD dwTimeOut);
NVP_STATUS NVPFlipVideoPort(LPDDHAL_FLIPVPORTDATA lpInput);

#ifdef VPEFSMIRROR

// [XW:09/27/2000] FS Mirror 
NVP_STATUS NVPFsMirrorEnable(GLOBALDATA *pDriverData);
NVP_STATUS NVPFsMirrorDisable(GLOBALDATA *pDriverData);

#endif

#ifdef __cplusplus
extern "C" {
#endif
DWORD __stdcall NVPUpdateOverlay(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
BOOL  __stdcall NVPIsVPEEnabled(GLOBALDATA *pDriverData, DWORD);
DWORD __stdcall NVPCleanUp(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl);
#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\inc\nvpecntx.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1993-1999. All rights reserved.

    nvpecntx.h

    VPE kernel context definition. This is a shared file with Win9x minivdd

    Dec 17, 1999

==============================================================================
*/
#ifndef _NVPECNTX_H
#define _NVPECNTX_H

#define NVP_MAX_VPORTS				1
#define NVP_MAX_SURFACES    		5
#define NVP_MAX_TRANSFER_BUFFERS	10
#define NVP_MAX_EXTRA422            10
#define NVP_MAX_SYNC_EVENTS         3   // defined also in nvpesrvc.h and nvpkrnl.c !!!

//
// Surface definition (Video or VBI) and related data
//
typedef struct _NVP_SURFACE_INFO
{
    //HANDLE              hSurface;           // DirectDraw surface handle
    ULONG               dwCaps;             // capabilites of this DD surface
    ULONG               pVidMem;            // Flat pointer to the surface
    ULONG               dwOffset;           // Offset from the base of the frame buffer
    ULONG               dwPitch;
    ULONG               dwLength;               
    ULONG               dwHeight;               
    ULONG               dwWidth;            // Ignored for VBI
    ULONG               dwStartLine;        // Programs Y-crop for image, and startline for vbi
    ULONG               dwPreScaleSizeX;    // Ignored for VBI.. prescale size width
    ULONG               dwPreScaleSizeY;    // Ignored for VBI.. prescale size height
    ULONG               dwFieldType;        // what field was this surface setup to capture?
    //ULONG               bAutoFlip;          // do we turn around and auto program this surface?
	ULONG				bIsFirstFieldCaptured;

    LONG                nNextSurfaceIdx;     // the next surface idx in the chain
    LONG                nPrevSurfaceIdx;     // the previous surface, used for FS Mirror

} NVP_SURFACE_INFO, *PNVP_SURFACE_INFO;

// Overlay info
typedef struct _NVP_OVERLAY {
	ULONG 	dwOverlayFormat;
	ULONG 	dwOverlaySrcX;
	ULONG 	dwOverlaySrcY;
	ULONG 	dwOverlaySrcPitch;
	ULONG 	dwOverlaySrcSize;
	ULONG 	dwOverlaySrcWidth;
	ULONG 	dwOverlaySrcHeight;
	ULONG 	dwOverlayDstWidth;
	ULONG 	dwOverlayDstHeight;
	ULONG   dwOverlayDstX;
    ULONG   dwOverlayDstY;
	ULONG   dwOverlayDeltaX;
	ULONG   dwOverlayDeltaY;
	ULONG   dwOverlayColorKey;
	ULONG   dwOverlayMode;
    ULONG   aExtra422OverlayOffset[NVP_MAX_EXTRA422];	// extra memory space used for prescaling
    ULONG   dwExtra422Index;			// index of current extra surface
    ULONG   dwExtra422NumSurfaces;      // number of extra allocated surfaces
	ULONG   dwExtra422Pitch;            // extra surface pitch
	ULONG   pNvPioFlipOverlayNotifierFlat;
	ULONG   dwOverlayMaxDownScale;
	ULONG   dwOverlayBufferIndex;
	ULONG 	dwReserved1;
	ULONG 	dwReserved2;
} NVP_OVERLAY, *PNVP_OVERLAY;

// Transfer
typedef struct _NVP_TRANSFER_BUFFER
{
	ULONG	dwTransferId;
	ULONG	dwTransferStatus;
	ULONG	pSurfaceData;
	//LONG	nSurfaceIdx;	// Idx of surface we're transfering from
	LONG	lStartLine;
	LONG 	lEndLine;
	ULONG	dwTransferFlags;
	ULONG	pDestMDL;
	LONG	nNextTransferIdx;
	LONG	nPrevTransferIdx;
} NVP_TRANSFER_BUFFER, *PNVP_TRANSFER_BUFFER;

// transfer status 
#define NVP_TRANSFER_QUEUED			0x01
#define NVP_TRANSFER_IN_PROGRESS	0x02
#define NVP_TRANSFER_DONE			0x03
#define NVP_TRANSFER_FAILURE		0x04
#define NVP_TRANSFER_FREE			0xFFFFFFFF

//
// NVidia Video Port context
//
typedef struct _NVP_CONTEXT
{
    NVP_SURFACE_INFO    aVideoSurfaceInfo[NVP_MAX_SURFACES];
    NVP_SURFACE_INFO    aVBISurfaceInfo[NVP_MAX_SURFACES];
 
    // Full screen mirror context information
    ULONG               dwOverlayFSOvlHead;    
    int                 MultiMon;               // True/False: whether there are multiple monitors
    NVP_SURFACE_INFO    aFSMirrorSurfaceInfo[NVP_MAX_SURFACES];  //Fullscreen mirror surface pointers 
    int                 nNumFSSurf;			    // number of allocated fullscreen mirror surfaces 
    int                 nFSFlipSurfIdx;         // current fullscreen mirror surface index 
    int                 nFSMirrorIdx;           // current completed
    int                 nFSFlipIdx;             // simple flip modifier for CRTC
    ULONG               regOverlayMode;         // pass these down from pDriver Data and through to kernel
    ULONG               regOverlayMode2;        // might even need zoom modes , and aspect ratios.
    ULONG               regOverlayMode3;
    ULONG               dwOverlayFSHead;        // which head is the overlay on? not sure if we need this
    ULONG               dwFsMirrorOn;           // signifies that Fsmirror is currently on.
    ULONG               dwDesktopState;
    UCHAR               adacNotifiers[16*9];    // (DAC notifiers) NvNotification 
    UCHAR               as2mNotifiers[16*1];    // s2m notifiers NvNotification
    UCHAR               asrfNotifiers[16*1];    // cont surface 2d notifiers , we need NVP_MAX_SURFACES
    
    int                 nNumVidSurf;			// number of allocated video surfaces
    int                 nNumVBISurf;			// number of allocated vbi surfaces
    int                 nVidSurfIdx;    		// current video surface index
    int                 nVBISurfIdx;    		// current vbi surface index

	int 				nNextVideoSurfId;
	int 				nNextVBISurfId;

	int 				nLastFieldId;			// Id of last field captured
	ULONG				bLastFieldType;			// type of last field captured (TRUE if VBI, FALSE if VIDEO)

	ULONG				dwVPState;				// NVP_STATE_STOPPED, NVP_STATE_STARTED
	ULONG				dwVPFlags;
	ULONG				dwVPConFlags;			// connection flags

	ULONG				dwChipId;				// chip version Id
	ULONG				hClient;
	ULONG				dwDeviceId;				// NV_WIN_DEVICE
    ULONG               pFrameBuffer;  // frame buffer base address
    ULONG               dwFBLen;       // frame buffer length

	ULONG				dwOverlayObjectID;		// overlay object Id (shared object!)
	ULONG				dwScalerObjectID;		// scaler object Id
	ULONG				dwDVDSubPicObjectID;	// used for prescaling on nv4 and nv5 
	ULONG               dwDVDObjectCtxDma;      // context dma used for synchronization.
	int					nFreeCount;		// fifo free count

    // BUGBUG: hacking declerations to avoid including hardware dependent header files 
    //         in "nv.h"
    ULONG               pNVPChannel;            // NvChannel *pNVPChannel; // VPE pio channel
    UCHAR               avpNotifiers[16*9];     // (Media port notifiers) NvNotification avpNotifiers[NVP_CLASS04D_MAX_NOTIFIERS];
    UCHAR               aovNotifiers[16*3];     // (Overlay notifiers) NvNotification aovNotifiers[NVP_CLASS07A_MAX_NOTIFIERS];

	// overlay
	NVP_OVERLAY			nvpOverlay;				// information retrieved from UpdateOverlay32() in Ring3
	ULONG				pOverlayChannel;		// NvChannel *pOverlayChannel; // Overlay channel
	ULONG				dwOvrSubChannel;
    ULONG                          pOvrRing0FlipFlag;

	// vidmem to sysmem transfer (vbi and video capture !)
	NVP_TRANSFER_BUFFER aTransferBuffers[NVP_MAX_TRANSFER_BUFFERS];
	UCHAR				axfNotifiers[16*6];	// 
	int					nCurTransferIdx;	// current transfer buffer index
	int					nLastTransferIdx;
	int					nRecentTransferIdx;	// index of most recently transfered buffer
	int					nNumTransfer;		// current number of transfer buffer in queue
	ULONG				bxfContextCreated;	// TRUE if context already created
	ULONG				bxfContextFlushed;	// TRUE if context flushed
	ULONG				dwTransferCtxStart;	// old transfer context start
	ULONG				dwTransferCtxSize;	// transfer size

	PVOID				hNVPSyncEvent[NVP_MAX_SYNC_EVENTS];		// media port and overlay sync event handle // PKEVENT hVSyncEvent;

	// DMA push buffer
	PVOID				pDmaChannel;
	ULONG				*nvDmaFifo;
	ULONG				nvDmaCount;
	ULONG				DmaPushBufTotalSize;	// 32k DWORDs
	UCHAR				DmaPushBufErrNotifier[16*1];

	// WDM prescale stuff
	ULONG				ulVPECaptureFlag;			//hack for WDM ME prescaling when capturing to disk
	ULONG				ulVPECapturePrescaleYFactor;	//hack for WDM ME prescale. Y-scale factor
	ULONG				ulVPECapturePrescaleXFactor;	//hack for WDM ME prescale. X-scale factor
	ULONG				ulVPNotUseOverSurf;			//flag for VP using over surf.

	//m2m xfer stuff
	PVOID				pSysBuf;				//dst surf for dma xfer
	ULONG				ulCap;					//capture flag

	ULONG				dwDecoderHeight;			//need this to determine single or dual field capture

} NVP_CONTEXT, *PNVP_CONTEXT;

#endif // _NVPECNTX_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\inc\nvpesrvc.h ===
#ifndef _NVPESRVC_H
#define _NVPESRVC_H

#define _USE_DMA

#define NVP_MAX_EXTRA_SURF_422    10
#define NVP_SYNC_EVENT_MAX        3


// data structure used to communicate with miniport
typedef struct _NVP_CMD_OBJECT {
	U032		dwSize;
	U032		dwChipId;	// chip version Id
	U032		dwPortId;	// usually 0 unless there are more than one VP on the chip
	U032		dwDeviceId;	// NV_WIN_DEVICE
	U032		dwSrvId;	// service ID	
	U032		hClient;
	U032        pChannel;		// VPE pio channel
	U032        pOvrChannel;  	// Overlay channel
	U032		dwOvrSubChannel;
	U032		pFrameBuffer;
	U032		dwFBLen;


	U032		dwOverlayObjectID;
	U032		dwScalerObjectID;
	U032		dwDVDObjectID;
    U032        dwDVDObjectCtxDma;
	// VP flags
	U032		dwVPTypeFlags;	// VP connection flag
	U032		dwVPInfoFlags;

	// image attributes
	U032		dwImageStartLine;
	U032		dwVBIStartLine;
	U032		dwInWidth;
	U032		dwInHeight;
	U032		dwPreWidth;
	U032		dwPreHeight;
	U032		dwOriginX;
	U032		dwOriginY;
	U032		dwVBIHeight;

	// surface
	U032		pSurfVidMem;	// address of surface
	U032		dwSurfaceId;	// 0 based surface index 
	U032		dwSurfPitch;	// in bytes
	U032		dwSurfOffset;	// offset from the beginning of the framebuffer
	U032		bSurfVBI;		// TRUE if VBI surface, FALSE for video
	U032		bSurfUpdate;	// TRUE if updating the surfaces attibutes only

	// overlay
	U032 		dwOverlayFormat;
	U032 		dwOverlaySrcX;
	U032 		dwOverlaySrcY;
	U032 		dwOverlaySrcPitch;
	U032 		dwOverlaySrcSize;
	U032 		dwOverlaySrcWidth;
	U032 		dwOverlaySrcHeight;
	U032 		dwOverlayDstWidth;
	U032 		dwOverlayDstHeight;
	U032        dwOverlayDstX;

    U032        dwOverlayDstY;
	U032        dwOverlayDeltaX;
    
	U032        dwOverlayDeltaY;


    U032        dwOverlayColorKey;    
	U032        dwOverlayMode;

    // For FS Mirror
    U032        dwOverlayFSOvlHead;
    U032        MultiMon;
    U032        regOverlayMode2;
    U032        regOverlayMode3;
    U032        regOverlayMode;
    U032        dwOverlayFSHead;
    U032        dwDesktopState;
    U032        dwSurfHeight;
    U032        dwSurfWidth;    
    
	U032        dwOverlayMaxDownScale;
	U032 		aExtra422OverlayOffset[NVP_MAX_EXTRA_SURF_422];
    U032        dwExtra422NumSurfaces;
	U032        dwExtra422Index;
	U032        dwExtra422Pitch;
    U032        pNvPioFlipOverlayNotifierFlat;

    // VPE vsync events
    U032        hNVPSyncEvent[NVP_SYNC_EVENT_MAX];

    // point to a shared flag between DDraw and VPE kernel (indicates who flips overlay!)
    U032        pOvrRing0FlipFlag;

} NVP_CMD_OBJECT, *PNVP_CMD_OBJECT;


// Service ID used by NVP_CMD_OBJECT
#define NVP_SRV_INITIALIZE		0x01
#define NVP_SRV_UNINITIALIZE	0x02
#define NVP_SRV_START_VIDEO		0x03
#define NVP_SRV_STOP_VIDEO		0x04
#define NVP_SRV_UPDATE_VIDEO	0x05
#define NVP_SRV_REG_SURFACE		0x06
#define NVP_SRV_UPDATE_OVERLAY	0x07
#define NVP_SRV_PROG_STATE		0x08
#define NVP_SRV_FLIP_VIDEOPORT  0x09
#define NVP_SRV_IS_VPE_ENABLED  0x0A

// For FS Mirror
// #define NVP_SRV_IS_FSMIRROR_ENABLED   0x0B
#define NVP_SRV_REG_FSMIRROR_SURFACE  0x0C
#define NVP_SRV_ENABLE_FSMIRROR       0x0D
#define NVP_SRV_DISABLE_FSMIRROR      0x0E

// NVP object, channels and events
#define NVP_VPE_CHANNEL						0xA0010001
#define NVP_EXTERNAL_DECODER_OBJECT			0xA0010002
#define NVP_EXTERNAL_DECODER_NOTIFIER		0xA0010003
#define NVP_VIDEO_FIELD0_BUFFER_CONTEXT		0xA0010004
#define NVP_VIDEO_FIELD1_BUFFER_CONTEXT		0xA0010005
#define NVP_VBI_FIELD0_BUFFER_CONTEXT		0xA0010006
#define NVP_VBI_FIELD1_BUFFER_CONTEXT		0xA0010007
#define NVP_VIDEO_FIELD0_BUFFER_EVENT		0xA0010008
#define NVP_VIDEO_FIELD1_BUFFER_EVENT		0xA0010009
#define NVP_VBI_FIELD0_BUFFER_EVENT			0xA001000A
#define NVP_VBI_FIELD1_BUFFER_EVENT			0xA001000B
#define NVP_M2M_OBJECT						0xA001000C
#define NVP_M2M_NOTIFIER					0xA001000D
#define NVP_M2M_CONTEXT						0xA001000E
#define NVP_M2M_FROM_CONTEXT				0xA001000F
#define NVP_M2M_EVENT						0xA0020001
#define NVP_DMA_PUSHBUF_ERROR_NOTIFIER		0xA0020002
#define NVP_DMA_FROM_MEMORY_PUSHBUF			0xA0020003

#define NVP_OVERLAY_OBJECT                  0xA0020004
#define NVP_DVD_SUBPICTURE_OBJECT           0xA0020005
#define NVP_OVERLAY_NOTIFIER                0xA0020006
#define NVP_DVD_SUBPICTURE_CONTEXT          0xA0020007
#define NVP_OVERLAY_BUFFER_CONTEXT          0xA0020008

#define NVP_VSYNC_EVENT0					0xA0020009
#define NVP_VSYNC_EVENT1					0xA002000A
#define NVP_OV_SYNC_EVENT0                  0xA002000B
#define NVP_OV_SYNC_EVENT1                  0xA002000C

// for FS Mirror
#define NVP_VIDEO_LUT_DAC_OBJ_ID                0xA0030001
#define NVP_VIDEO_LUT_DAC_NOTIFIERS_CONTEXT_ID  0xA0030002
#define NVP_VIDEO_LUT_DAC_EVENT0_ID             0xA0030003
#define NVP_VIDEO_LUT_DAC_EVENT1_ID             0xA0030004
#define NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT 0xA0030005
#define NVP_VIDEO_LUT_DAC_FIELD1_BUFFER_CONTEXT	0xA0030006

#define NVP_SCALED_IMAGE_OBJ_ID                 0xA0030007
#define NVP_SCALED_IMAGE_NOTIFIERS_CONTEXT_ID   0xA0030008
#define NVP_SCALED_IMAGE_BUFFER_CONTEXT         0xA0030009
#define NVP_SCALED_IMAGE_EVENT_ID               0xA003000A

// There can be multiple surface_2d objects
#define NVP_CONTEXT_SURFACE_2D_OBJECT               (0xA0030010)
#define NVP_CONTEXT_SURFACE_2D_NOTIFIERS_CONTEXT_ID (0xA0030011)
#define NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT       (0xA0030012)

///// methods are equivalent to NV10_VIDEO_OVERLAY
#ifndef NV04_VIDEO_OVERLAY
#define NV04_VIDEO_OVERLAY (0x00000047)
#endif

// field definition (corresponds to H/W def)
#define NVP_FIELD_EVEN			0x00
#define NVP_FIELD_ODD			0x01

// VP state
#define NVP_STATE_STOPPED		0x01L
#define NVP_STATE_STARTED		0x02L
#define NVP_STATE_STARTED_VIDEO	0x04L
#define NVP_STATE_STARTED_VBI	0x10L

#define NVP_STOP_VIDEO          0x01L
#define NVP_STOP_VBI            0x02L

// End of Queue
#define NVP_EOQ		(-1)
#define NVP_UNDEF	(0xFFFFFFFF)

#define NVPE_VSYNC_EVENT_NAME	L"NVPE_VSYNc_EVENT"

// NV chip versions
#define NVP_GET_CHIP_VER(ver)	((ver) & 0xFFFF)

#define NVP_CHIP_VER_03			0x03
#define NVP_CHIP_VER_04			0x04
#define NVP_CHIP_VER_05			0x05
#define NVP_CHIP_VER_10			0x10

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010

#endif // _NVPESRVC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\DDMINI.H ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995,1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       ddmini.h
 *  Content:    header for Windows95 Direct Draw driver
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

#ifndef NVARCH
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

#if !defined(_WIN32) && !defined(WINNT)
#define NOUSER
#define NOGDI
#define NOGDIOBJ
#define NOGDICAPMASKS
#include <windows.h>
#define NOPTRC
#define PTTYPE POINT
#include <nvgdi.inc>
#define NVFAR FAR
#include <nvdib.inc>
typedef struct tagPALETTEENTRY FAR* LPPALETTEENTRY;
typedef struct tagRGNDATA      FAR* LPRGNDATA;
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    };
} ULARGE_INTEGER;
#include <ddrawi.h>
#endif

#include "nvFourCC.h"
#include "nvVPP.h"
#include "nvcm.h"
#include "nvdd.h"

#include "nvUniversal.h"

/***************************************************************************
 *
 * DriverData
 *
 * this structure contains all the globals of the driver, it is shared
 * between the 16 and 32bit side of the driver.
 *
 ***************************************************************************/

#ifndef HDRVEVENT
#include "nvProcMan.h"
#endif

#ifndef NVTWINVIEWDATA
#include "nvMultiMon.h"
#endif

#define DDMINI_VERSION  0x0400

#if (NVARCH < 0x4)
#define NV_MAX_OVERLAY_SURFACES  10
#define NV_MAX_EXTRA_SURFACES    6
#define NV_MAX_EXTRA_FS_SURFACES 4
#endif

//---------------------------------------------------------------------------

typedef struct tagNVMCSURFACEFLAGS {
  DWORD dwMCSurfaceBase;
  DWORD dwMCSurface422Offset;
  DWORD dwMCMotionCompReferenceCount;
  DWORD dwMCFormatCnvReferenceCount;
  DWORD dwMCCompositeReferenceCount;
  DWORD dwMCTemporalFilterReferenceCount;
  BYTE  bMCPictureStructure;
  BYTE  bMCPictureCodingType;
  BYTE  bMCTopFieldFirst;
  BYTE  bMCSecondField;
  BYTE  bMCFrameType;
  BYTE  bMCFrameIsFiltered;
  BYTE  bMCFrameIsComposited;
  BYTE  bMCFrameAlreadyFormatConverted;
} NVMCSURFACEFLAGS, *LPNVMCSURFACEFLAGS;

//---------------------------------------------------------------------------
#ifdef ENABLE_VPP_DISPATCH_CODE

typedef struct {
    DWORD               dwState;    // dispatcher state
    DWORD               dwCommand;  // dispatcher command
    DWORD               dwThreadPriority;
    DWORD               dwProcessPriority;
    DWORD               dwOriginalThreadPriority;
    DWORD               dwOriginalProcessPriority;
    PROCESS_INFORMATION procInfo;
    HDRVEVENT           hSignalGo0;     // ring0 event to dispatch
    HDRVEVENT           hSignalGo3;     // ring3 event to dispatch
    HDRVEVENT           hSignalDone0;   // ring0 event signaling completion
    HDRVEVENT           hSignalDone3;   // ring3 event signaling completion

    // parameters for vppVPPandFlip
    DWORD               dwOffset;
    DWORD               dwPitch;
    DWORD               dwWidth;
    DWORD               dwHeight;
    DWORD               dwFourCC;
    DWORD               dwFlags;
    DWORD               dwReturnCode;
    DWORD               dwReserved1;
} VPPDISPATCH;
#else
// NB: The following # of DWORDS must exactly match the size of the dispatch code
// above.  Someday this can all go away...
typedef DWORD VPPDISPATCH[22];
#endif

//---------------------------------------------------------------------------
#if (NVARCH < 0x4)
typedef struct {
    DWORD               dwLastFlags;
    DWORD               dwLastExec;
    DWORD               dwMarker1;
    DWORD               dwReserved1;

    LONGLONG            qwCount;

    LONGLONG            qwInterFrameTime;
    LONGLONG            qwInterFrameAcc;
    LONGLONG            qwInterFramePeak;
    LONGLONG            qwInterFrameDelta;
    LONGLONG            qwInterFrameJitterAcc;
    LONGLONG            qwInterFrameJitterPeak;

    LONGLONG            qwIntraFrameAcc;
    LONGLONG            qwIntraFramePeak;
    LONGLONG            qwIntraFrameDelta;
    LONGLONG            qwIntraFrameJitterAcc;
    LONGLONG            qwIntraFrameJitterPeak;

    LONGLONG            qwMarker2;
    LONGLONG            qwReserved2;
} VPPSNOOP;

//---------------------------------------------------------------------------

typedef struct {
    DWORD               dwOpCount;
    HDRVEVENT           hLastStage;
    BOOL                doLateFlipSync;
    DWORD               dwIndex;
    DWORD               dwSrcOffset;
    DWORD               dwSrcPitch;
    DWORD               dwWidth;
    DWORD               dwHeight;
    DWORD               dwFourCC;
    DWORD               dwFlags;
    DWORD               dwWorkSurfaces;
    DWORD               vppExec;
    LONGLONG            qwTime1;
    LONGLONG            qwTime2;
    LONGLONG            qwDelta;
    LONGLONG            qwJitter;
} VPPSTATE;
#endif
#define NVPE_EVENT_MAX 3

//---------------------------------------------------------------------------
/// NVPESTATE

typedef struct {
    BOOL                bVPEInitialized;
    BOOL                bFsMirrorEnabled;
    DWORD               dwVPEState;
    HANDLE              hVPEKernel;
    HANDLE              hNVPSyncEvent[NVPE_EVENT_MAX];
    HANDLE              hNVPSyncEvent0[NVPE_EVENT_MAX];
} NVPESTATE;

//---------------------------------------------------------------------------
// blit data, including cached values and other control parameters

typedef struct {
    DWORD               dwStatusReferenceCount;
    DWORD               dwSystemSurfaceContextDMAIndex;
    DWORD               dwMTMFIndex;     // alternating odd or even, does not need to be initialized
    DWORD               dwLastRop;
    DWORD               dwLastColourKey;
    DWORD               dwLastColourFormat;
    DWORD               dwLastCombinedPitch;
    DWORD               dwLastSrcOffset;
    DWORD               dwLastDstOffset;
    DWORD               dwSystemBltFallback;
    DWORD               dwLetItThrash;
    DWORD               dwQueuedPrimaryBlitCount;
} BLTDATA;

//---------------------------------------------------------------------------
// blt work surface info

typedef struct {
    DWORD               dwLocale;
    DWORD               dwContextDma;
    DWORD               dwWSSize;
    FLATPTR             fpVidMem;
    DWORD               dwOffset;
    DWORD               dwReserved;
} BLTWSINFO;

//---------------------------------------------------------------------------
// sync record

typedef struct {
    DWORD               bSyncFlag;
    DWORD               dwReserved1;
} SYNCRECORD;

//---------------------------------------------------------------------------
// flip record
//---------------------------------------------------------------------------
typedef struct {
    DWORD               fpFlipFrom;
    DWORD               dwFlipDuration;
    DWORD               bFlipFlag;
    DWORD               bIsD3DSurface;
    DWORD               fpFlipTo;
    DWORD               fpPreviousFlipFrom;
    DWORD               dwReserved1;
    DWORD               dwReserved2;
    LONGLONG            llFlipTime;
    LONGLONG            llPreviousFlipTime;
    NV_CFGEX_CRTC_TIMING_PARAMS nvTimingInfo[2];
    LONGLONG            llFlipDurationNs[2];
} FLIPRECORD;

typedef DWORD  (FAR PASCAL *LPDDHALSURFCB_GETSURFACEINFO)(LPDDRAWI_DDRAWSURFACE_LCL);

#ifdef WINNT
typedef struct _PDEV PDEV;      // Defined in NT display driver's DRIVER.H file
#endif

//---------------------------------------------------------------------------

/*
 * nvdd32 driver context
 *
 * this is only used when nvdd32.dll source files include this file
 */
#if (NVARCH < 0x4)
#ifdef __cplusplus
class CDriverContext;
#define NVDD32_CONTEXT      DWORD  dwNVDD32Context;
#else
#define NVDD32_CONTEXT      DWORD  ContextSpaceFiller;
#endif
#endif
/*
 * forward definitions
 */
#ifdef __cplusplus
class CNvObject;
class CInterProcessHeap;
struct _NV_OBJECT_LIST;
#endif

#ifdef __cplusplus
class CReferenceCount;
#define REFCOUNT_t CReferenceCount
#else
struct CReferenceCount;
#define REFCOUNT_t struct CReferenceCount
#endif

// ---------------------------------------------------------
// GLOBALDATA struct
// ---------------------------------------------------------

#define FSDOSSTATUS_RECOVERYNEEDED_DDRAW  0x00000001
#define FSDOSSTATUS_RECOVERYNEEDED_D3D    0x00000002
#define FSDOSSTATUS_TWINVIEW_STATE_CHANGE 0x40000000
#define FSDOSSTATUS_COMPLETE              0x80000000

typedef struct _GLOBALDATA {
    // ---------------------------------------------------------
    // Stuff whose offset in this structure is critical.
    // ---------------------------------------------------------

#if (NVARCH >= 0x04)

    DWORD                       dwVersion;
    DWORD                       dwGlobalStructSize;          // current size of this structure
    DWORD                       DDrawVideoSurfaceCount;
    DWORD                       dwFullScreenDOSStatus;

#else  // NV3

    // on nv3, we still have dependencies with the display driver, so offsets are critical
#ifdef _WIN32
    DWORD                       lpPDevice;                   // *MUST* be first (DIBLINK.ASM) uses it.
#else
    DIBENGINE FAR *             lpPDevice;
#endif
    DWORD                       dwVersion;
    DWORD                       dwGlobalStructSize;          // current size of this structure
    DWORD                       DDrawVideoSurfaceCount;      // *MUST* start at 0x0C (cursor code and realizeObject checks it)
    WORD                        fDmaPusherActive;            // *MUST* start at 0x10 (both display driver and direct draw check it)
    BYTE                        fFullScreenDosOccurred;      // *MUST* start at 0x12 (both display driver and D3D check it)
    BYTE                        fDDrawFullScreenDosOccurred; // *MUST* start at 0x13 (both display driver and DDraw check it)
    DWORD                       dwModeSwitchCount;           // *MUST* start at 0x16 offset (display driver uses it)

#endif  // NV3

    // ---------------------------------------------------------
    // General Info -
    // stuff not specific to NV internals, D3D, DirectDraw,
    // or MultiMon alone. If specific, please file below.
    // (sooner or later, i _will_ organize the world.
    // ---------------------------------------------------------
#if (NVARCH >= 0x4)
    CPushBuffer                 nvPusher;
#endif
    DWORD                       dwDDDmaPusherChannelIndex;
    DWORD                       dwDDDmaPusherChannelMask;
    DWORD                       NvAGPDmaPusherBufferBase;
    DWORD                       dwSharedClipChangeCount;
    DWORD                       dwDDMostRecentClipChangeCount;
#ifdef  _WIN32
    volatile long               *NvDmaPusherBufferEnd;
#else   // _WIN32
#endif  // _WIN32
    long                        NvDmaPusherBufferSize;
    DWORD                       dwVidMemCtxDmaSize;
    #if (NVARCH < 0x4)
    DWORD                       dwDmaPusherCtxDmaSize;
    #endif
    DWORD                       dwMacrovisionNavigatorID;
    SYNCRECORD                  syncPioFifoRecord;
    SYNCRECORD                  syncDmaRecord;
    DWORD                       blitCalled;
    WORD                        fVidMemLocked;
    WORD                        fActiveExternalUser; // NVLIB, NVDDX, etc
    WORD                        fNvActiveFloatingContexts;
#ifdef WINNT
    // stored in pDXShare under win9x
    WORD                        primaryBufferIndex;
#else
    WORD                        unused_01;  // Keep everything dword aligned
#endif

    // info about the current mode
    DWORD                       TotalVRAM;          // total VRAM on card
#if (NVARCH < 0x4)
    DWORD                       ModeNumber;
    DWORD                       ScreenSel;          // selector to screen
    DWORD                       maxOffScreenY;      // maximum screen pitch width Y at current resolution
#endif
    DWORD                       BaseAddress;        // base addess of accessable video memory.
    long                        VideoHeapBase;      // start of video heap
    long                        VideoHeapEnd;       // end of video heap
    long                        VideoHeapTotal;     // total available heap
    long                        VideoHeapOverhead;  // GDI and RM overhead, not related to DX surfaces
    long                        VideoHeapFree;      // free heap
#ifdef WINNT
    DWORD_PTR                   GARTLinearBase;     // linear base address of AGP GART memory
    DWORD_PTR                   GARTPhysicalBase;   // physical base address of AGP GART memory
    DWORD_PTR                   GARTLinearHeapOffset; // WINNT - offset from GARTLinearBase to beginning of AGP heap
#else
    DWORD                       GARTLinearBase;     // linear base address of AGP GART memory
    DWORD                       GARTPhysicalBase;   // physical base address of AGP GART memory
    VOID                        *notUsedGARTLinearHeapOffset; // not used - placeholder for Win9x VxD builds
#endif // !WINNT

    DWORD                       regPersistAGPSize;  // # of bytes reserved for persistent AGP allocs
#if (NVARCH < 0x4)
    // bitmapinfo for current mode
    BITMAPINFOHEADER            bi;
    DWORD                       color_table[256];

    DWORD                       dwDXRuntimeVersion; // version of DirectX runtime installed (inferred from GUIDs)
    #endif
    DWORD                       dwDDGlobal;         // LPDDRAWI_DIRECTDRAW_GBL for this context
    DWORD                       __pad_xxx;

    DWORD                       dwGenInfoPad0;      // unused
    DWORD                       dwGenInfoPad1;      // unused

    // ---------------------------------------------------------
    // NV stuff
    // ---------------------------------------------------------
    DWORD                       lpNvDmaBuffer; // obsolete
    DWORD                       NvCommonDmaBufferFlat;
    DWORD                       NvScanlineBufferFlat;
#if (NVARCH < 0x04)
    DWORD                       NvDevFlatPio;
#endif
    DWORD                       NvDevVideoFlatPio;  // Video channel
    DWORD                       NvDevFlatVPE;       // Vpe channel
#if (NVARCH >= 0x04)
    NvNotification *            pDmaBufferNotifierFlat;
    NvNotification *            pDmaFlipPrimaryNotifierFlat;
    NvNotification *            pDmaDmaToMemNotifierFlat;
    NvNotification *            pDmaSyncNotifierFlat;
    NvNotification *            pGenericScaledImageNotifier;
    NvNotification *            pPioColourControlEventNotifierFlat;
    NvNotification *            pPioCombinerEventNotifierFlat;
#else
    DWORD                       NvPioFlipPrimaryNotifierFlat;
    DWORD                       NvPioSyncNotifierFlat;
    DWORD                       NvPioDmaFromMemNotifierFlat;
#endif
    DWORD                       NvPioDmaToMemNotifierFlat;
    DWORD                       NvPioBufferNotifierFlat;
    NvNotification *            pDmaPusherSyncNotifierFlat;
    NvNotification *            pPioFlipOverlayNotifierFlat;
    DWORD                       NvDmaFromMemBaseAddress;
    DWORD                       NvDmaFromMemSurfaceMem;
    DWORD                       NvFloating0UYVYSurfaceMem;                  // only used for WINNT now, delete when done
    DWORD                       NvFloating1UYVYSurfaceMem;                  // only used for WINNT now, delete when done
    DWORD                       NvFloating0YUYVSurfaceMem;                  // only used for WINNT now, delete when done
    DWORD                       NvFloating1YUYVSurfaceMem;                  // only used for WINNT now, delete when done
    DWORD                       NvFloatingMem2MemFormatMemoryHandle;        // only used for WINNT now, delete when done
    DWORD                       NvFloatingMem2MemFormatSurfaceAddress[4];   // only used for NV3 now, delete when done
    DWORD                       NvYUY2Surface0Mem;                          // only used for WINNT now, delete when done
    DWORD                       NvYUY2Surface1Mem;                          // only used for WINNT now, delete when done
    DWORD                       NvYUY2Surface2Mem;                          // only used for WINNT now, delete when done
    DWORD                       NvYUY2Surface3Mem;                          // only used for WINNT now, delete when done
    DWORD                       NvWinDmaPusherNotifierFlat;
    DWORD                       dwVideoPortsAvailable;
    DWORD                       NvFloatingTexture;
    DWORD                       CurrentVisibleSurfaceAddress;
    DWORD                       dDrawSpareSubchannelObject; // subchannel 7
    BOOL                        bDirtyRenderTarget;                         // nv4 only - RT/ZB has/have changed, need HW update
    DWORD                       NvBaseFlat;
    NvU32                       dwDesktopState;

    // --------------------------------------------------------
    // Overlay related stuff
    // --------------------------------------------------------
    Vpp_t                       vpp;

    NvU32                       regSuper7Compat;
#if (NVARCH < 0x4)
    DWORD                       dwOverlaySurfaces;
    DWORD                       dwOverlayOwner;
    DWORD                       dwOverlaySurfaceLCL[NV_MAX_OVERLAY_SURFACES];
    DWORD                       dwOverlaySrcWidth;
    DWORD                       dwOverlaySrcHeight;
    DWORD                       dwOverlayDstWidth;
    DWORD                       dwOverlayDstHeight;
    DWORD                       dwOverlayDeltaX;
    DWORD                       dwOverlayDeltaY;
    DWORD                       dwOverlayLastVisibleSurfaceLCL;
    DWORD                       dwOverlayLastVisibleFpVidMem;
    DWORD                       dwOverlayLastVisiblePitch;
    DWORD                       dwOverlayLastVisiblePixelFormat;
    DWORD                       dwOverlayFlipCount;
    WORD                        OverlaySrcX;        // overlay starting points
    WORD                        OverlaySrcY;
    WORD                        OverlayDstX;
    WORD                        OverlayDstY;
    WORD                        OverlayBufferIndex;
    WORD                        OverlayRelaxOwnerCheck;
    DWORD                       OverlaySrcOffset;
    DWORD                       OverlayFormat;      // current overlay format - used so VDD knows what's up!
    DWORD                       OverlaySrcPitch;    // current overlay pitch   - used so VDD knows what's up!
    DWORD                       OverlaySrcSize;
    DWORD                       OverlayColorKey;
    DDCOLORCONTROL              OverlayColourControl;
    DWORD                       OverlayCachedFlags;
    DWORD                       extra422OverlayOffset[NV_MAX_EXTRA_SURFACES];   // can be up to n "chunks" longer original surface
    DWORD                       extra422Pitch;
    DWORD                       extra422NumSurfaces;
    DWORD                       extra422Index;
    DWORD                       dwOverlayFSOffset[NV_MAX_EXTRA_FS_SURFACES];
    DWORD                       dwOverlayFSWidth;
    DWORD                       dwOverlayFSHeight;
    DWORD                       dwOverlayFSPitch;
    DWORD                       dwOverlayFSFormat;
    DWORD                       dwOverlayFSNumSurfaces;
    DWORD                       dwOverlayFSIndex;
    DWORD                       dwOverlayFSDeltaX;
    DWORD                       dwOverlayFSDeltaY;
    DWORD                       dwOverlayFSHead;
    DWORD                       dwOverlayFSOvlHead;
    DWORD                       dwOverlayFSSrcWidth;
    DWORD                       dwOverlayFSSrcHeight;
    DWORD                       dwOverlayFSSrcMinX;
    DWORD                       dwOverlayFSSrcMinY;
    NVTWINVIEWDATA              dwOverlayFSTwinData;
    DWORD                       dwOverlayFSOvlHeadSaved;
    DWORD                       dwOverlayFSOvlLost;
    DWORD                       fpOverlayShadow;
    DWORD                       dwOverlayByteAlignmentPad;
    DWORD                       dwOverlayMaxDownScale;
    DWORD                       dwOverlayMaxDownScaleX;
    DWORD                       dwOverlayMaxDownScaleY;
    DWORD                       regOverlayColourControlEnable;
    DWORD                       regRing0ColourCtlInterlockFlags;    // bit0 = 1 -> ring0 should run; bit2 = 1 ring0 in progress
    DWORD                       regOverlayMode;
    DWORD                       regOverlayMode2;
    DWORD                       regOverlayMode3;
    DWORD                       OverlayMode;            // used to tell if we're doing interleaved or what...
    DWORD                       regVPPInvMask;
    DWORD                       regVPPMaxSurfaces;
    VPPDISPATCH                 vppDispatch;
    VPPSNOOP                    vppSnoop;
    VPPSTATE                    vppState;
    DWORD                       dwVPPSubPictureOffset;
    DWORD                       dwVPPSubPicturePitch;
    DWORD                       dwVPPSubPictureFormat;
    DWORD                       dwVPPSubPictureX;
    DWORD                       dwVPPSubPictureY;
    DWORD                       dwVPPSubPictureWidth;
    DWORD                       dwVPPSubPictureHeight;
    #endif
    NvU32                       regPBLocale;
    LPPROCESSINFO               lpProcessInfoHead;
    PROCESSINFO                 procInfo;           // statically created for NT
    DWORD                       dwUseRefreshRate;
    WORD                        ddClipUpdate;
    WORD                        fDeviceHasDitheringControl;
    DWORD                       physicalColorMask;
    BYTE                        fDmaPushBufferHasBeenFlushed;
    BYTE                        fIsBltStyleFlip;
    WORD                        NvDeviceVersion;
    WORD                        bEnableVPE;     // used to allow registry disabling of VPE port
    WORD                        ddPad0point5;   // the other word which is unused
    DWORD                       CloseNvDevVideoFlatPio;
    DWORD                       CloseNvDevFlatVPE;
    DWORD                       northBridgeID;
    BLTDATA                     bltData;
    BLTWSINFO                   bltSysMemInfo;
    BLTWSINFO                   bltAGPMemInfo;
    BLTWSINFO                   bltVidMemInfo;
    DWORD                       dwTVTunerFlipCount;
    DWORD                       dwTVTunerTimer;
    NvU32                       regMaxAGPLimit;
    NvU32                       regTVTunerHack;         // unused under WINNT
    NvU32                       regEnumDDRefresh;

    // --------------------------------------------------------
    // VPE related stuff
    // --------------------------------------------------------

    NVPESTATE                   nvpeState;

    // --------------------------------------------------------
    // Motion Comp related stuff
    // --------------------------------------------------------
    DWORD                       dwMCTex0Control0;
    DWORD                       dwMCTex1Control0;
    BYTE                        bMCNewFrame;
    BYTE                        bMCPictureStructure;
    BYTE                        bMCPictureCodingType;
    BYTE                        bMCTopFieldFirst;
    BYTE                        bMCSecondField;
    BYTE                        bMCFrameType;
    BYTE                        bMCForwardPictureStructure;
    BYTE                        bMCBackwardPictureStructure;
    DWORD                       dwMCDestinationSurface;
    DWORD                       dwMCForwardSurface;
    DWORD                       dwMCBackwardSurface;
    DWORD                       dwMCDualPrimeSurface;
    DWORD                       dwMCIDCTSurface;
    DWORD                       dwMCMostRecentlyDecodedSurfaceBase;
    DWORD                       dwMCNVDSSurfaceBase;
    DWORD                       dwMCFirstAlignedIDCTIndex;
    DWORD                       dwMCIDCTAGPSurfaceBase[4];
    DWORD                       dwMCIDCTAGPCtxDmaSize[4];
    DWORD                       dwMCCurrentCelsiusIDCTCtxDma;
    DWORD                       dwMCDestinationSurfaceOffset;
    DWORD                       dwMCForwardSurfaceOffset;
    DWORD                       dwMCBackwardSurfaceOffset;
    DWORD                       dwMCNVMCSurface;
    DWORD                       dwMCNV12Surface[8];
    DWORD                       dwMCNVIDSurface[4];
    DWORD                       dwMCNVSPSurface;
    NVMCSURFACEFLAGS            nvMCSurfaceFlags[9];
    BYTE                        bMCTemporalFilterDisabled;
    BYTE                        bMCPercentCurrentField;
    BYTE                        bMCMostRecentlyDecodedPictureStructure;
    BYTE                        bMCOverlaySrcIsSingleField1080i;
    BYTE                        bMCCurrentExecuteFunction;
    BYTE                        bMCHorizontallyDownscale1080i;
    BYTE                        bMCPad0; // unused
    BYTE                        bMCPad1; // unused
    DWORD                       dwMCNVIDSurfaceReferenceCount[4];
    // --------------------------------------------------------
    DWORD                       dwMostRecentHWUser;   // most recent user of shared HW objects (celsius, kelvin, etc.)
    DWORD                       NvVideoNotifierBuffer;
    DWORD                       lockCount;
    DWORD                       thisDeviceID;
    DWORD                       dwRingZeroMutex; // when true prevents ring 0 from stepping on ring3 spare channel state
    WORD                        flatSelector;
    WORD                        NvFreeCount;
    DWORD                       dwBusType;
    DWORD                       pCurrentChannelID;
    DWORD                       NvVideoFreeCount;
    #if (NVARCH < 0x4)
    BYTE                        NvFirstCall;
    BYTE                        NvPrevDepth;
    #else
    WORD                        wNv4Pad;
    #endif
    BYTE                        TwoDRenderingOccurred;
    BYTE                        ThreeDRenderingOccurred;
    DWORD                       fourCC[32];

    // Used by VPP, MoComp & D3D
    FLIPRECORD               flipPrimaryRecord;
    FLIPRECORD               flipOverlayRecord;
    REFCOUNT_t              *pRefCount;

    // ---------------------------------------------------------
    // D3D stuff
    // ---------------------------------------------------------

    // for nv4 and beyond, most stuff has been moved into CDriverContext
#if (NVARCH >= 0x04)
    NV_SystemInfo_t             nvD3DPerfData;
    DWORD                       dwCurrentContextHandle;     // probably don't need
#else  // NV3
    DWORD                       dwCurrentContextHandle;
    DWORD                       dwD3DContextCount;
    DWORD                       dwZBufferContextAddr;
    DWORD                       dwTextureContextValid;
    DWORD                       dwD3DTextureCount;
    DWORD                       dwDMAPushContext;
    DWORD                       dwDmaPushBufferSize;
    DWORD                       hContexts_gbl;
    DWORD                       hTextures_gbl;
    DWORD                       hAGPList_gbl;
    DWORD                       hTextureHeap;
    DWORD                       dwContextListHead;
    DWORD                       dwDmaMaxPushCount;
    DWORD                       dwDmaFifoAddr;
    DWORD                       dwDmaFifoOffset;
    DWORD                       dwDmaFifoCurrentBuffer;
    DWORD                       dwDmaCount;
    DWORD                       dwDmaFifoPhysOffset;
    DWORD                       dwDmaFifoCurrent;
    DWORD                       dwDmaFifoOffsetCurrent;
    DWORD                       dwTextureListHead;
#ifdef __cplusplus
    CNvObject                  *pNvObjectHead;
#else
    void                       *dwD3DPad3;
#endif
    DWORD                       dwRMChID;
    DWORD                       dwRMPtBase;
    DWORD                       dwRMAddressSpace;
    DWORD                       dwProcessorSpeed;
    DWORD                       dwProcessorFlags;
    // Texture heap data.
    DWORD                       pRealHeapBase;
    DWORD                       pTextureHeapBase;
    DWORD                       pTextureHeapAllocHead;
    DWORD                       pTextureHeapAllocTail;
    DWORD                       pTextureHeapFreeHead;
    DWORD                       pTextureHeapFreeTail;
    DWORD                       dwTextureHeapSize;
    DWORD                       dwTextureHeapSizeMax;
    DWORD                       dwTextureHeapLimit;
    DWORD                       dwTextureHeapLimitMax;
    DWORD                       dwAllocSize;
    DWORD                       dwFreeSize;
    // D3D registry settings.
    DWORD                       regD3DEnableBits1;
    DWORD                       regDmaPushBufferSizeMax;
    DWORD                       regMipMapLevels;
    DWORD                       regZOHMode;
    DWORD                       regTexHeap;
    DWORD                       regMinVideoTextureSize;
    DWORD                       regFilterControl;
    DWORD                       regD3DContextMax;
    DWORD                       regD3DTextureMax;
    DWORD                       regNonSquareExpand;
    DWORD                       regFOHMode;
    DWORD                       regLODMethod;
    DWORD                       regAAReadCompatibilityFile;
    DWORD                       regAAMethod;
    DWORD                       regTurboMode;
    DWORD                       regD3DAlphaBlendMethod;
    DWORD                       regDmaMinPushCount;
    DWORD                       regNVPEventBits;   // locutus enable bits
    DWORD                       regNVPTimeBits;    // locutus enable bits
    DWORD                       regNVPCountBits;   // locutus enable bits
    DWORD                       regGapFill;
    DWORD                       regTexAddrAdjust;
    // Extra D3D data space
    DWORD                       dwD3DPad0;         // unused
    DWORD                       dwD3DPad1;         // unused
    DWORD                       fReset;
    DWORD                       fVidMemVarsReset;
#endif  // NV3

    // ---------------------------------------------------------
    // DirectDraw stuff
    // ---------------------------------------------------------

    DWORD                       dwFourCCSelector;
    DWORD                       dwPvmListSelector;
    DWORD                       dwDDCallbacksSelector;
    DWORD                       dwDDSurfaceCallbacksSelector;
    DWORD                       dwDDPaletteCallbacksSelector;
    DWORD                       dwDDExecuteBufferCallbackSelector;
    DWORD                       dwModeListSelector;
#ifndef WINNT
#define                         MAX_MODES   MAX_MODEENTRYS
#ifdef  _WIN32  // This is because we use this file with both 16 and 32 bit compilers
    DDHALMODEINFO NEAR          *ModeList;
#else
    DWORD                       ModeList;
#endif  // _WIN32
    DDHALDDRAWFNS               HALCallbacks;
#endif // !WINNT

#ifdef WINNT
    DDHALINFO                   HALInfo;                // allocated dynamically under Win9x
#endif // WINNT
    DDHAL_DDCALLBACKS           DDCallbacks;
    DDHAL_DDSURFACECALLBACKS    DDSurfaceCallbacks;
    DDHAL_DDPALETTECALLBACKS    DDPaletteCallbacks;

#ifndef WINNT   // WINNT BUG we will need to remove when DX7 port is complete
    DDHAL_DDEXEBUFCALLBACKS     DDExecuteBufferCallbacks;
#else
    DDHAL_D3DBUFCALLBACKS       DDExecuteBufferCallbacks;
#endif // WINNT0

#ifndef WINNT
    VIDMEM                      vidMem[2];
#endif // #ifdef WINNT

    DWORD                       dwMySurfacesPtr;        // unused
    DWORD                       bRing0FlippingFlag;        // TRUE when KMVT based overlay flipping is happening
    DWORD                       dwDDrawPad3;        // unused

    DWORD                       dwSurfaceAlignPad;
    DWORD                       dwSurfaceAlign;     // hw required surface alignment
    DWORD                       dwSurfaceBitAlign; // hw required surface alignment in term of bits

    // ---------------------------------------------------------
    // Multi-Monitor stuff - only use this data in a MM driver
    // ---------------------------------------------------------
    DWORD                       dwDrvRefCount;      // driver reference count, can get greater than 1 in multihead
    DWORD                       dwRootHandle;       // NV connection Root Handle
    DWORD                       dwDeviceHandle;     // ID associated with a particular driver for a display by VDD
    DWORD                       dwDeviceIDNum;      // ID for a display assigned by the RM
    DWORD                       dwDeviceClass;
    DWORD                       dwHeads;            // number of heads (DACs) on this device
#ifdef WINNT
    //*****************************************************************************
    // Semaphore related fields.
    //*****************************************************************************
    BOOL    NvSemRefCnt;        // Does this GLOBALDATA own the semaphore?
#else
    DWORD   NvSemPlaceHolder;   // Dummy placeholder for Win9x
#endif // !WINNT

    DWORD                       pStereoData;        // pointer to a structure containing stereo stuff.

    // ---------------------------------------------------------
    // DirectX-VA Stuff
    // ---------------------------------------------------------
    BYTE                        bDXVAIndexToNVIndex[8];
    DWORD                       dwDXVAConvertBuffer;
    WORD                        wDXVAReserved1;
    WORD                        wDXVAReserved2;
    DWORD                       dwDXVAFlags;
    DWORD                       dwDXVAIndexToVidMem[8];
    DWORD                       dwDXVAReserved3;

    DWORD                       dwNVOverlayFlags;

} GLOBALDATA;

/***************************************************************************
 ***************************************************************************/

#ifdef _WIN32

#ifdef __cplusplus
    class CDriverContext;
    extern CDriverContext *pDriverData;   // in ddDrv.cpp
#else
    extern GLOBALDATA     *pDriverData;   // in ddDrv.cpp
#endif

/* Ternary raster operation indexes */

#define BLACKNESSINDEX      0x00000000L
#define NOTSRCERASEINDEX    0x00000011L
#define NOTSRCCOPYINDEX     0x00000033L
#define SRCERASEINDEX       0x00000044L
#define PATINVERTINDEX      0x0000005AL
#define SRCINVERTINDEX      0x00000066L
#define SRCANDINDEX         0x00000088L
#define MERGEPAINTINDEX     0x000000BBL
#define SRCCOPYINDEX        0x000000CCL
#define SRCPAINTINDEX       0x000000EEL
#define PATCOPYINDEX        0x000000F0L
#define WHITENESSINDEX      0x000000FFL

/* Supported ROP table bits */

/* 0x00 */
#define BLACKNESSBIT        0x00000001L
/* 0x10 */
#define NOTSRCERASEBIT      0x00020000L

/* 0x20 */
/* 0x30 */
#define NOTSRCCOPYBIT       0x00080000L

/* 0x40 */
#define SRCERASEBIT         0x00000010L
/* 0x50 */
#define PATINVERTBIT        0x04000000L

/* 0x60 */
#define SRCINVERTBIT        0x00000040L
/* 0x70 */

/* 0x80 */
#define SRCANDBIT           0x00000100L
/* 0x90 */

/* 0xA0 */
/* 0xB0 */
#define MERGEPAINTBIT       0x08000000L

/* 0xC0 */
#define MERGECOPYBIT        0x00000001L
#define SRCCOPYBIT          0x00001000L
/* 0xD0 */

/* 0xE0 */
#define SRCPAINTBIT         0x00004000L
/* 0xF0 */
#define PATCOPYBIT          0x00010000L
#define WHITENESSBIT        0x80000000L


#else  // _WIN32

/* Ternary raster operations */
#define BLACKNESS           0x00000042L
#define SRCCOPY             0x00CC0020L
#define PATCOPY             0x00F00021L
#define WHITENESS           0x00FF0062L

/***************************************************************************
 *
 * global driver data
 *
 ***************************************************************************/

#if !defined(_WIN32) && !defined(WINNT)
extern GLOBALDATA           DriverData;     // in ddmini16.c
#endif /* !defined(_WIN32) && !defined(WINNT) */

/***************************************************************************
 *
 * functions in ddmini.c
 *
 ***************************************************************************/

void FAR PASCAL _loadds BeginAccess(DIBENGINE FAR *pde, int left, int top, int right, int bottom, UINT flags);
void FAR PASCAL _loadds EndAccess(DIBENGINE FAR *pde, UINT flags);

/***************************************************************************
 *
 * functions in setmode.c
 *
 ***************************************************************************/

BOOL HWSetMode();
BOOL HWTestMode(int ModeNumber);
void HWEndAccess(void);
BOOL HWSetPalette(int start, int count, DWORD FAR *colors);


/***************************************************************************
 *
 * functions in DIBENG
 *
 ***************************************************************************/

extern DWORD FAR PASCAL CreateDIBPDevice    (LPBITMAPINFOHEADER lpbi, DIBENGINE FAR *lpDevice, LPVOID lpBits, WORD dwFlags);
extern UINT  FAR PASCAL DIB_Enable          (LPVOID, UINT, LPSTR, LPSTR, LPVOID);
extern UINT  FAR PASCAL DIB_Disable         (DIBENGINE FAR *);
extern LONG  FAR PASCAL DIB_Control         (DIBENGINE FAR *, UINT, LPVOID, LPVOID);
extern UINT  FAR PASCAL DIB_BeginAccess     (DIBENGINE FAR *, int left, int top, int right, int bottom, WORD flags);
extern UINT  FAR PASCAL DIB_EndAccess       (DIBENGINE FAR *, WORD flags);
extern UINT  FAR PASCAL DIB_SetPaletteExt   (UINT start, UINT count, DWORD FAR *lpPalette, DIBENGINE FAR * pde);
extern UINT  FAR PASCAL DIB_BitBlt          (DIBENGINE FAR *, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *);
extern UINT  FAR PASCAL DIB_StretchBlt      (DIBENGINE FAR *, int, int, int, int, DIBENGINE FAR *, int, int, int, int, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_StretchDIBits   (DIBENGINE FAR *, int, int, int, int, int, int, int, int, LPVOID, BITMAPINFO FAR *, LPVOID, DWORD, DIB_Brush8 FAR *, DRAWMODE FAR *,RECT FAR *);
extern UINT  FAR PASCAL DIB_DibToDevice     (DIBENGINE FAR *, int, int, int, int, RECT FAR *, DRAWMODE FAR *, LPVOID, BITMAPINFO FAR *, LPVOID);
extern UINT  FAR PASCAL DIB_Output          (DIBENGINE FAR *, int, int, POINT FAR *, DIB_Pen FAR *, DIB_Brush8 FAR *, DRAWMODE FAR *, RECT FAR *);
extern UINT  FAR PASCAL DIB_ExtTextOutExt   (DIBENGINE FAR *pde, int x, int y, RECT FAR *Clip, LPSTR sz, UINT cb, LPVOID lpFont, DRAWMODE FAR *pdm, LPVOID xform, int FAR *pdx, RECT FAR *lpORect, UINT f, LPVOID DrawBitmap, LPVOID DrawRect);
// extern UINT  FAR PASCAL DIB_SetCursorExt    (CURSORSHAPE FAR *lpCursor, DIBENGINE FAR *pde);
extern UINT  FAR PASCAL DIB_MoveCursorExt   (int x, int y, DIBENGINE FAR * pde);

#endif // _WIN32

/* NV Device Version Numbers */
#define NV_DEVICE_VERSION_4     0x0004
#define NV_DEVICE_VERSION_5     0x0005
#define NV_DEVICE_VERSION_10    0x0010
#define NV_DEVICE_VERSION_20    0x0020

/* AGP stuff */
#define NV_MAX_AGP_MEMORY_LIMIT 0x1FFFFFF

/* Dma flags */
#define NV_WIN_DMA_PUSHER_IS_ACTIVE  1
#define NV_DD_DMA_PUSHER_IS_ACTIVE   2

/* Floating system memory context in use flags */
#define NV_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        1
#define NV_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY        2
#define NV_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        4
#define NV_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY        8
#define NV_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY       16

/* Other NV specific defines */
#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L

/* Surface Alignment */
#if (NVARCH >= 0x010)
#define NV_BYTE_ALIGNMENT_PAD           63L
#define NV_BYTE_ALIGNMENT               64L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#elif (NVARCH >= 0x04)
#define NV_BYTE_ALIGNMENT_PAD           31L
#define NV_BYTE_ALIGNMENT               32L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      256
#define NV_BIT_ALIGNMENT                256
#else /* NVARCH < 0x04 */
#define NV_BYTE_ALIGNMENT_PAD           15L
#define NV_BYTE_ALIGNMENT               16L
#define NV_SCAN_OUT_BYTE_ALIGNMENT      128
#define NV_BIT_ALIGNMENT                128
#endif  /* !(NV10 || NV4) */

/* Define driver defined surface bits for the driver reserved field in the local surface structure */
#define NV_D3D_HAS_FLIPPED              0x00000001

/* Detect the Via VP3 and MVP3 Northbridge IDs for workarounds */
#define VIA_VP3_NB_ID   0x5971106
#define VIA_MVP3_NB_ID  0x5981106
#define IS_VIA_MVP3_NB_ID(nb)   (((nb) == VIA_VP3_NB_ID) || ((nb) == VIA_MVP3_NB_ID))

// dwDXVAFlags in pDriverData
#define DXVA_MO_COMP_IN_PROGRESS     0x00000001
#define DXVA_PICTURE_IN_PROGRESS     0x00000002
#define DXVA_ENABLED_IN_REGISTRY     0x00000004
#define DXVA_INTRA_IDCT_UNSIGNED     0x00000008
#define DXVA_OVERLAY_WAS_BOBBED      0x00000010
#define DXVA_BACK_END_ALPHA_SELECTED 0x00000020
#define DXVA_BACK_END_ALPHA_ENABLED  0x00000040

// dwNVOverlayFlags in pDriverData
#define OVERLAY_FLAG_ON_PANEL        0x00000001


/***************************************************************************
 *
 * DEBUG stuff
 *
 ***************************************************************************/
#ifdef IS_32
    extern void __cdecl PF (LPSTR szFormat, ...);
    #ifdef DEBUG
        extern void __cdecl DPF(LPSTR szFormat, ...);
        #define BREAK()     DebugBreak();
    #else
        #define DPF         1 ? (void)0 : (void)
        #define BREAK()
    #endif
#else  // !IS_32
    #define PF          1 ? (void)0 : (void)
    #define DPF         1 ? (void)0 : (void)
    #define BREAK()
#endif  // !IS_32

#ifdef WINNT
//
// WINNT Only:
// Need to declare these with "C" linkage so we can call them from the display
// driver.
//
// Function prototypes. One time DX6 Init/Destroy code. This is the 32 bit ddraw init code.
// Found in $(BUILDDIR)\main\drivers\ddraw\common\src\ddDrv.cpp
//
BOOL  __stdcall buildDDHALInfo32(GLOBALDATA *pDriverData);
DWORD __stdcall DriverInit(DWORD dwDriverData);
HRESULT __stdcall DestroyDriver32(GLOBALDATA *pGlobalData);
void  __stdcall init_globals(void);
void  __stdcall NvWin2KInitIPM();
void  __stdcall NvWin2KInitDXGlobals();
void  __stdcall NvWin2KInitDXState(PDEV *ppdev);
BOOL  __stdcall NvWin2KD3DHALCreateDriver(DD_HALINFO *pHalInfo, PDEV *ppdev);
BOOL  __stdcall NvWin2KAllocDriverData(PDEV* ppdev);
void  __stdcall NvWin2KpvmConfig(PDEV *ppdev, VIDEOMEMORY *pvmList);
DWORD __stdcall NvWin2KMapAgpHeap(PDEV *ppdev);
DWORD __stdcall NvWin2KGetAgpLimit(PDEV *ppdev, DWORD dwRootHandle, DWORD dwDevID);
DWORD __stdcall NvWin2KUnmapAgpHeap(PDEV *ppdev);

extern GLOBALDATA  DefaultGlobalData;
extern ENGSAFESEMAPHORE NvSem;
#define NvAcquireSemaphore(pGblData)                \
{                                                   \
    if ((pGblData) && !((pGblData)->NvSemRefCnt))   \
    {                                               \
        EngAcquireSemaphore(NvSem.hsem);            \
    }                                               \
    (pGblData)->NvSemRefCnt++;                      \
}
#define NvReleaseSemaphore(pGblData)            \
{                                               \
    if ((pGblData) && (pGblData)->NvSemRefCnt)  \
    {                                           \
        (pGblData)->NvSemRefCnt--;              \
        if (!((pGblData)->NvSemRefCnt))         \
        {                                       \
            EngReleaseSemaphore(NvSem.hsem);    \
        }                                       \
    }                                           \
}
#else   // Win9x
#define NvAcquireSemaphore(pGblData)
#define NvReleaseSemaphore(pGblData)
#endif

/*
 * This is the error return value from the DX heap manager allocation functions.
 * It is defined differently under Win2K since the DX heap manager returns an
 * offset rather than an address, which makes 0 a valid offset rather than an
 * error code.
 */
#ifndef WINNT
#define ERR_DXALLOC_FAILED 0
#else
#define ERR_DXALLOC_FAILED 0xffffffff
#endif

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\src\nvpe.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*
==============================================================================

    NVIDIA Corporation, (C) Copyright
    1996,1997,1998,1999. All rights reserved.

    nvpe.cpp

    DDraw Video Port implementation

    Jan 27, 1999

==============================================================================
*/

#ifdef NVPE

#include "nvpkrnl.h"
#include "nvpe.h"

// VPE states
#define NVP_STATE_STOPPED   0x01
#define NVP_STATE_RUNNING   0x02

/*
==============================================================================

    CanCreateVideoPort32

    Description:    Determines whether a Videoport can be created. Sometimes
                    this function is called twice with the same VideoPort ID.
                    In such case, the video port can be created (VIDEO and
                    VBI)

==============================================================================
*/
DWORD NVPAPI CanCreateVideoPort32(LPDDHAL_CANCREATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***CanCreateVideoPort32");

    //ASSERT(lpInput!=NULL);
    //ASSERT(lpInput->lpDDVideoPortDesc !=NULL);    
    
    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);
    
    if (pDriverData == NULL)
    {
        DPF("NVPE: error - VideoPort not creatable  -->  pDriverData = NULL");
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }
    
    // Check structure size
    if (lpInput->lpDDVideoPortDesc->dwSize < sizeof(DDVIDEOPORTDESC))
    {
        DPF("NVPE: error - VideoPort not creatable  -->  stucture length is not large enough");
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }
    
    // check input connection GUID
    if (!IsEqualGUID_C((lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID), DDVPTYPE_CCIR656))
    {
        DPF("NVPE: error - VideoPort not creatable  --> GUID should be DDVPTYPE_CCIR656");
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // check to see if there are videoports available... by looking at local allocation
    if (pDriverData->dwVideoPortsAvailable <= 0)
    {
        // check to see if there are ports available... by looking at IDs
        if (lpInput->lpDDVideoPortDesc->dwVideoPortID != 0)
        {
            DPF("NVPE: error - VideoPort not creatable  --> not enough video ports");
            NvReleaseSemaphore(pDriverData);
            lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
            return DDHAL_DRIVER_HANDLED;
        }

        DPF("NVPE: second VP with the same ID allowed !");
    }


	
	// the restrictions we have FieldWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...
	if (lpInput->lpDDVideoPortDesc->dwFieldWidth > NV_MAX_FIELDWIDTH) {
		DPF("   ***VideoPort not creatable  --> field Width is too great");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have VBIWidth are dependant on maximum pitch specifiable
	//  pitch is 2^13 in size...  but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwVBIWidth > NV_MAX_VBIWIDTH) {
		DPF("   ***VideoPort not creatable  --> VBI field Width is too great");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}
	
	// the restrictions we have on Field Height are dependant on maximum length specifiable
	//  length is 2^19 in size... which is but there are 2 bytes in each pixel
	if (lpInput->lpDDVideoPortDesc->dwFieldHeight > NV_MAX_FIELDHEIGHT) {
		DPF("   ***VideoPort not creatable  --> Maximum buffer length exceed by field height too high");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

	if (lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond > NV_MAX_PIXELRATE) {
		DPF("   ***VideoPort not creatable  --> Sorry incoming data rate is too high");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}

    
	if ((lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  != 8) && (lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth  != 16)) 
	{
		DPF("NVPE: error - VideoPort not creatable  --> port width is not 8 or 16");
		NvReleaseSemaphore(pDriverData);
		lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
		return DDHAL_DRIVER_HANDLED;
	}


    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    CreateVideoPort32

    Description:    Create a Videoport. Initialize context.

    Notes:          This function allows the HAL to set internal flags and
                    become aware that a video port has been created. It
                    should always return DDHAL_DRIVER_HANDLED.
                    According to DDHAL documentation, this procedure can
                    return DDHAL_DRIVER_NOTHANDLED as well, signifying that
                    the createvideoport fn could not be completed.
                    DirectDraw MS layer will prevent creating more videoports
                    that is available.

==============================================================================
*/
DWORD NVPAPI CreateVideoPort32(LPDDHAL_CREATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***CreateVideoPort32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    if (NVPInitialize(	pDriverData, 
						lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags,
						lpInput->lpDD->lpGbl))
    {
        DPF("NVPE: error - VideoPort driver failed to initialize !");
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_CURRENTLYNOTAVAIL;
        return DDHAL_DRIVER_HANDLED;
    }

    // one down !
    (pDriverData->dwVideoPortsAvailable)--;

    pDriverData->nvpeState.dwVPEState = NVP_STATE_STOPPED;

    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
==============================================================================

    GetVideoPortBandwidth32

    Description:    Determine how much bandwidth is available for the
                    specified output format and fill in the information

==============================================================================
*/
DWORD NVPAPI GetVideoPortBandwidth32(LPDDHAL_GETVPORTBANDWIDTHDATA lpInput)
{
    DPF("***GetVideoPortBandwidth32");

    if (lpInput->dwFlags & DDVPB_TYPE)
    {
        lpInput->lpBandwidth->dwCaps = DDVPBCAPS_DESTINATION;  // we are limited by the "shrink" of the overlay
    }
    
    if (lpInput->dwFlags & DDVPB_VIDEOPORT)
    {
        // The following four should indicate the MINIMUM stretch values represented as percentages times 10
        //  so if we could not stretch below 75% of the orginal size, the we should put in 750
        lpInput->lpBandwidth->dwOverlay                 = 1000;
        lpInput->lpBandwidth->dwColorkey                = 1000;  // Overlay/video port/colorkey works at 1X
        lpInput->lpBandwidth->dwYInterpolate            = 1000;  // Overlay/video port works at 1X
        lpInput->lpBandwidth->dwYInterpAndColorkey      = 1000;  // Overlay/video port/interpolation works at 2X
    }
    
    if (lpInput->dwFlags & DDVPB_OVERLAY)
    {
        DPF("NVPE: We are NOT an overlay limited device but a destination ");
        DPF("      limited device we should not have been called");
    }

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortInputFormat32

    Description:    retrieves the VP input format (UYVY 422)

==============================================================================
*/
DWORD NVPAPI GetVideoPortInputFormat32(LPDDHAL_GETVPORTINPUTFORMATDATA lpInput)
{
    DPF("***GetVideoPortInputFormat32");

    // Only 1 input format supported UYVY 4:2:2
    // Data stored in 32bit word as U[7:0] Y1[15:8] V[23:16] Y2[31:24]
    if (lpInput->dwFlags & DDVPFORMAT_VIDEO)
    {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL)
        {
            memcpy (lpInput->lpddpfFormat, &g_aNVPVideoFormat[0], sizeof(DDPIXELFORMAT));
        }
    }

    // VBI raw 8 bit
    if (lpInput->dwFlags & DDVPFORMAT_VBI)
    {
        lpInput->dwNumFormats = 1;
        if (lpInput->lpddpfFormat != NULL)
        {
            memcpy (lpInput->lpddpfFormat, &g_aNVPVBIFormat[0], sizeof(DDPIXELFORMAT));
        }
    }

    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}


/*
==============================================================================

    GetVideoPortOutputFormat32

    Description:    retrieves the VP output format (UYVY 422)

==============================================================================
*/
DWORD NVPAPI GetVideoPortOutputFormat32(LPDDHAL_GETVPORTOUTPUTFORMATDATA lpInput)
{
    DPF("***GetVideoPortOutputFormat32");

    lpInput->dwNumFormats = 1;
    if (lpInput->lpddpfOutputFormats != NULL)
    {
        memcpy (lpInput->lpddpfOutputFormats, lpInput->lpddpfInputFormat, sizeof (DDPIXELFORMAT));
    }

    // UYVY 4:2:2
    if (lpInput->dwFlags & DDVPFORMAT_VIDEO)
    {
        // BES converts (overlay) and not the video port !
        if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('U','Y','V','Y'))
        {
            lpInput->dwNumFormats = 1;
            if (lpInput->lpddpfOutputFormats != NULL)
            {
                memcpy (lpInput->lpddpfOutputFormats, &g_aNVPVideoFormat[0], sizeof(DDPIXELFORMAT));
            }
        }
    }

    // VBI raw 8 bit
    if (lpInput->dwFlags & DDVPFORMAT_VBI)
    {
        if (lpInput->lpddpfInputFormat->dwFourCC == mmioFOURCC('R','A','W','8'))
        {
            lpInput->dwNumFormats = 1;
            if (lpInput->lpddpfOutputFormats != NULL)
            {
                memcpy (lpInput->lpddpfOutputFormats, &g_aNVPVBIFormat[0], sizeof(DDPIXELFORMAT));
            }
        }
    }

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortConnectInfo

    Description:    Returns the GUIDs describing the connections that can be
                    supported, port widths and CAPS

==============================================================================
*/
DWORD NVPAPI GetVideoPortConnectInfo(LPDDHAL_GETVPORTCONNECTDATA lpInput)
{
    DPF("***GetVideoPortConnectInfo");

#if (NVARCH < 0x10)
    lpInput->dwNumEntries = 1;
    if(lpInput->lpConnect == NULL)
    {
        // this means that Dx is looking for the number of ways you can connect so that it can
        // allocate a structure for the next time around
        lpInput->ddRVal = DD_OK;
    }
    else
    {
        // fill in the one structure that we asked for..    
        lpInput->lpConnect->dwSize = sizeof(DDVIDEOPORTCONNECT);
        memcpy(&(lpInput->lpConnect->guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect->dwPortWidth = 8;
        lpInput->lpConnect->dwFlags = g_dwNVPConnectionCaps;
    }
#else
    lpInput->dwNumEntries = 2;
    if(lpInput->lpConnect == NULL)
    {
        // this means that Dx is looking for the number of ways you can connect so that it can
        // allocate a structure for the next time around
        lpInput->ddRVal = DD_OK;
    }
    else
    {
        // fill in the one structure that we asked for..    
        lpInput->lpConnect[0].dwSize = sizeof(DDVIDEOPORTCONNECT);
        memcpy(&(lpInput->lpConnect[0].guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect[0].dwPortWidth = 8;
        lpInput->lpConnect[0].dwFlags = g_dwNVPConnectionCaps;

        lpInput->lpConnect[1].dwSize = sizeof(DDVIDEOPORTCONNECT);
        memcpy(&(lpInput->lpConnect[1].guidTypeID), &DDVPTYPE_CCIR656, sizeof (GUID));
        lpInput->lpConnect[1].dwPortWidth = 16; // NV10 and up we support 16 bit port width
        lpInput->lpConnect[1].dwFlags = g_dwNVPConnectionCaps;

    }
#endif

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
==============================================================================

    DestroyVideoPort32

    Description:    This optional function notifies the HAL when the video
                    port has been destroyed

==============================================================================
*/
DWORD NVPAPI DestroyVideoPort32(LPDDHAL_DESTROYVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***DestroyVideoPort32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

	//Dst width & height =0 will shutdown overlay
	//changing size values are not recommended but since these values
	//are updated when you call updateoverlay, I guess this is fine.
	//and we are destroying VP anyway...
    
    // Should create a better method for this @mjl@

	pDriverData->vpp.dwOverlayDstWidth = 0;
	pDriverData->vpp.dwOverlayDstHeight = 0;
	NVPUpdateOverlay(pDriverData, lpInput->lpDD->lpGbl);
    NVPStopVideo(pDriverData, lpInput->lpDD->lpGbl);
    NVPUninitialize(pDriverData);

    // available again !
    (pDriverData->dwVideoPortsAvailable)++;

    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortField32

    Description:    readback of the current field

==============================================================================
*/
DWORD NVPAPI GetVideoPortField32(LPDDHAL_GETVPORTFIELDDATA lpInput)
{
    DPF("***GetVideoPortField32");

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortLine32

    Description:    readback of the current video line number (0 relative)

==============================================================================
*/
DWORD NVPAPI GetVideoPortLine32(LPDDHAL_GETVPORTLINEDATA lpInput)
{
    DPF("***GetVideoPortLine32");

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoSignalStatus32

    Description:    any incoming video signal ?

==============================================================================
*/
DWORD NVPAPI GetVideoSignalStatus32(LPDDHAL_GETVPORTSIGNALDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***GetVideoSignalStatus32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    if (pDriverData->nvpeState.dwVPEState == NVP_STATE_STOPPED)
    {
        DPF("GetVideoSignalStatus32: could not get the signal status, the video port is not running... ");
        NvReleaseSemaphore(pDriverData);
        // we'll return no signal in this case....
        lpInput->dwStatus = DDVPSQ_NOSIGNAL;
        lpInput->ddRVal = DD_OK;
        return DDHAL_DRIVER_HANDLED;
    }

    // check vp sync event to see if things are running down there !
    if (NVPWaitForSync(pDriverData, NVP_EVENT_MEDIAPORT, 35) == NVP_STATUS_SUCCESS)    // 35 msec for a complete frame to pass through !
        lpInput->dwStatus = DDVPSQ_SIGNALOK;
    else
        lpInput->dwStatus = DDVPSQ_NOSIGNAL;

    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;

    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    GetVideoPortFlipStatus32

    Description:    This required function allows DDRAW to restrict access to
                    a surface until the physical flip has occurred, allowing
                    doubled buffered capture.
                    If the physical flip has not yet occurred, return
                    DDERR_WASSTILLDRAWING

==============================================================================
*/
DWORD NVPAPI GetVideoPortFlipStatus32(LPDDHAL_GETVPORTFLIPSTATUSDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***GetVideoPortFlipStatus32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    // check vp sync event and return immediatly
    if (NVPWaitForSync(pDriverData, NVP_EVENT_MEDIAPORT, 0) != NVP_STATUS_SUCCESS)
    {
        // we'll return still drawing in this case....
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_WASSTILLDRAWING;
        return DDHAL_DRIVER_HANDLED;
    }

    NvReleaseSemaphore(pDriverData);
    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    WaitForVideoPortSync32

    Description:    Waits for the LPB Video VSYNC (note: this is entirely
                    different from the screen refresh VGA VSYNC)

==============================================================================
*/
DWORD NVPAPI WaitForVideoPortSync32(LPDDHAL_WAITFORVPORTSYNCDATA lpInput)
{
    GLOBALDATA *pDriverData;
    DWORD dwTimeOut;

    DPF("***WaitForVideoPortSync32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    if (pDriverData->nvpeState.dwVPEState == NVP_STATE_STOPPED)
    {
        DPF("WaitForVideoPortSync32: could not wait for VP Sync, the video port is not running... ");
        NvReleaseSemaphore(pDriverData);
        // we'll return an error in this case....
        lpInput->ddRVal = DDERR_VIDEONOTACTIVE;
        return DDHAL_DRIVER_HANDLED;
    }

    dwTimeOut = (lpInput->dwTimeOut != 0) ? lpInput->dwTimeOut : 2000; // wait for 2 sec (2000 msec)

    if (NVPWaitForSync(pDriverData, NVP_EVENT_MEDIAPORT, dwTimeOut) != NVP_STATUS_SUCCESS)
    {
        DPF("WaitForVideoPortSync32: VP Sync timed-out !");
        NvReleaseSemaphore(pDriverData);
        // we'll return an error in this case....
        lpInput->ddRVal = DDERR_VIDEONOTACTIVE;
        return DDHAL_DRIVER_HANDLED;
    }

    NvReleaseSemaphore(pDriverData);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}

/*
==============================================================================

    FlipVideoPort32

    Description:    Program registers to do the actual flip

==============================================================================
*/
DWORD NVPAPI FlipVideoPort32(LPDDHAL_FLIPVPORTDATA lpInput)
{
    DPF("***FlipVideoPort32");

    NVPFlipVideoPort(lpInput);

    lpInput->ddRVal = DD_OK;
    return DDHAL_DRIVER_HANDLED;
}


/*
==============================================================================

    UpdateVideoPort32

    Description:    Sets up the video port. Might be called separately for
                    VBI and Video.

==============================================================================
*/
DWORD NVPAPI UpdateVideoPort32(LPDDHAL_UPDATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;

    DPF("***UpdateVideoPort32");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    lpInput->ddRVal = DD_OK;

    //if (pDriverData->NvDevFlatDma == 0)
	if(pDriverData->nvpeState.bVPEInitialized == FALSE){
        NvReleaseSemaphore(pDriverData);
        lpInput->ddRVal = DDERR_SURFACELOST;
        return DDHAL_DRIVER_HANDLED;
    }

    if (lpInput->dwFlags == DDRAWI_VPORTUPDATE)
    {
        DPF("UpdateVideoPort32: update videoport");
        NVPUpdateVideo(lpInput);
    }
    else if (lpInput->dwFlags == DDRAWI_VPORTSTART)
    {
        // if already running, consider this as an update !!!
        if (pDriverData->nvpeState.dwVPEState == NVP_STATE_RUNNING)
        {
            DPF("UpdateVideoPort32: update videoport");
            NVPUpdateVideo(lpInput);
        }
        else
        {
            DPF("UpdateVideoPort32: start videoport");
            NVPStartVideo(lpInput);
            pDriverData->nvpeState.dwVPEState = NVP_STATE_RUNNING;
        }
    }
    else
    {
        DPF("UpdateVideoPort32: stop videoport");
        // stop grabbing video !
        NVPStopVideo(pDriverData, lpInput->lpDD->lpGbl);
        pDriverData->nvpeState.dwVPEState = NVP_STATE_STOPPED;
    }

    NvReleaseSemaphore(pDriverData);

    return DDHAL_DRIVER_HANDLED;
}


#endif // NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\src\nvpkrnl.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*
==============================================================================

    NVIDIA Corporation, (C) Copyright
    1996,1997,1998,1999. All rights reserved.

    nvpkrnl.cpp

    Video Port kernel interface (Miniport/MiniVDD)

    Feb 10, 1999

==============================================================================
*/
#ifdef NVPE

#include "nvpkrnl.h"

// NVPE inludes
#include "nvpesrvc.h"  // shared structure and definitions (miniport/DDraw)

// Win9x and NT differences
#ifdef WINNT

#define     NVP_CLIENT              (ppdev->hClient)
#define     NVP_DRIVER_HANDLE       (pDriverData->nvpeState.hVPEKernel)      // (pDriverData->ppdev->hDriver)
#define     NVP_VPE_CHANNEL_PTR     (pDriverData->NvDevFlatVPE)
#define     NVP_OVERLAY_CHANNEL_PTR (pDriverData->NvDevVideoFlatPio)
#define     NVP_FB_BASE_ADDRESS     (ppdev->pjFrameBufbase)
#define     NVP_FB_LENGTH           (ppdev->cbFrameBuf)
#define     PNVP_DDRAW_SURFACE      PDD_SURFACE_INT     // LPDDRAWI_DDRAWSURFACE_INT for Win9x
#define     NVP_OVERLAY_SUBCHANNEL  7 //DD_SPARE            // NV_DD_SPARE for Win9x
#define     NVP_GET_SURFACE_OFFSET(x) ((U032)(x))
#define     NVP_GET_SURFACE_POINTER(x) ((U032)(x) + (U032)(ppdev->pjFrameBufbase)) // on win2k, pVidMem are offsets not linear pointers !!!

#else
// Win9x version

#define     IOCTL_VIDEO_VPE_COMMAND 0x300cafe0
#define     VPE_EVENT               "VPE_Event"
#define     NVP_CLIENT              pDriverData->dwRootHandle //(pDriverData->ppdev->hClient)
#define     NVP_DRIVER_HANDLE       (pDriverData->nvpeState.hVPEKernel)     //(pDriverData->ppdev->hDriver)
#define     NVP_VPE_CHANNEL_PTR     (pDriverData->NvDevFlatVPE)
#define     NVP_OVERLAY_CHANNEL_PTR (pDriverData->NvDevVideoFlatPio)
#define     NVP_FB_BASE_ADDRESS     pDriverData->VideoHeapBase   //(pDriverData->ppdev->pjScreen)
#define     NVP_FB_LENGTH           (pDriverData->VideoHeapEnd - pDriverData->VideoHeapBase) //(pDriverData->ppdev->cbFrameBuf)
#define     PNVP_DDRAW_SURFACE      LPDDRAWI_DDRAWSURFACE_INT//PDD_SURFACE_INT     // LPDDRAWI_DDRAWSURFACE_INT for Win9x
#define     NVP_OVERLAY_SUBCHANNEL  7 //DD_SPARE            // NV_DD_SPARE for Win9x
#define     NVP_GET_SURFACE_OFFSET(x)  ((U032)(x) - (U032)(pDriverData->BaseAddress))
#define     NVP_GET_SURFACE_POINTER(x) ((U032)(x))

#endif //WINNT

// local prototypes
NVP_STATUS NVPGetImageDim(
    LPDDVIDEOPORTDESC pVPDesc,
    LPDDVIDEOPORTINFO pVideoInfo,
    PNVP_CMD_OBJECT pnvCmdObj,
    BOOL bIsVideoSurf);
NVP_STATUS NVPRegSurface(
    GLOBALDATA *pDriverData,
    PNVP_DDRAW_SURFACE pDDSurface, //LPDDRAWI_DDRAWSURFACE_INT *pDDSurface, // lpInput->lplpDDSurface,
    PNVP_CMD_OBJECT pnvCmdObj,
    DWORD dwSurfaceId);





NVP_STATUS NVPCreateEvents(GLOBALDATA *pDriverData, PNVP_CMD_OBJECT pnvInitObj);
NVP_STATUS NVPDestroyEvents(GLOBALDATA *pDriverData);
NVP_STATUS NVPCallKernel(HANDLE hDevice, PNVP_CMD_OBJECT pnvInCmdObj, PNVP_CMD_OBJECT pnvOutCmdObj);
NVP_STATUS NVPEGetHandleToKernel(GLOBALDATA *pDriverData, HANDLE hDevice);
NVP_STATUS NVPDumpVPSurfInfo(LPDDHAL_UPDATEVPORTDATA lpInput, NVP_CMD_OBJECT *pnvCmdObj);
NVP_STATUS NVPDumpVPConnectInfo(DWORD dwVPConnectionFlags);

#ifdef VPEFSMIRROR
// [XW] added for FS Mirror
NVP_STATUS NVPFsRegSurface(
    GLOBALDATA *pDriverData,
    PNVP_CMD_OBJECT pnvCmdObj,
    DWORD dwSurfaceId,
    DWORD dwSurfPitch,
    DWORD dwSurfOffset,
    DWORD dwSurfHeight,
    DWORD dwSurfWidth
    );

/*
==============================================================================

    NVPFsRegSurface

    Description:  Interface to the miniport... register surfaces etc.


    Parameters:


    Note:       Xun Wang September 25, 2000

==============================================================================
*/

NVP_STATUS NVPFsRegSurface(
    GLOBALDATA *pDriverData,
    PNVP_CMD_OBJECT pnvCmdObj,
    DWORD dwSurfaceId,
    DWORD dwSurfPitch,
    DWORD dwSurfOffset,
    DWORD dwSurfHeight,
    DWORD dwSurfWidth
    )
{

    // register the fullscreen mirror surface in the kernel.
    dwSurfOffset = (U032)(pDriverData->BaseAddress+dwSurfOffset);

    pnvCmdObj->pSurfVidMem = NVP_GET_SURFACE_POINTER(dwSurfOffset);
    pnvCmdObj->dwSurfPitch = dwSurfPitch;
    pnvCmdObj->dwSurfWidth = dwSurfWidth;
    pnvCmdObj->dwSurfHeight = dwSurfHeight;

    pnvCmdObj->dwSurfOffset = NVP_GET_SURFACE_OFFSET(dwSurfOffset);

    pnvCmdObj->dwSurfaceId = dwSurfaceId;
    pnvCmdObj->dwSrvId = NVP_SRV_REG_FSMIRROR_SURFACE;

     // call vpe kernel to register surface
    NVPCallKernel(NVP_DRIVER_HANDLE, pnvCmdObj, NULL);

    return NVP_STATUS_SUCCESS;

}
/*
==============================================================================

    NVPFsMirrorEnable

    Description:  Interface to the miniport... register surfaces etc.


    Parameters:


    Note:       Xun Wang September 25, 2000

==============================================================================
*/
NVP_STATUS NVPFsMirrorEnable(GLOBALDATA *pDriverData)
{
    NVP_CMD_OBJECT nvInObj;
    int i;

    DPF("nvpkrnl.cpp: NVPFsMirrorEnable()\n");

    if (!pDriverData->nvpeState.bVPEInitialized) {
        return NVP_STATUS_SUCCESS;
    }

    if (pDriverData->nvpeState.bFsMirrorEnabled) {
        NVPFsMirrorDisable(pDriverData);
    }

//    if (NVPEGetHandleToKernel(pDriverData, NULL) != NVP_STATUS_SUCCESS) {
//        return NVP_STATUS_FAILURE;
//    }

    // NVP_SRV_ENABLE_FSMIRROR to send down the other information
    nvInObj.dwPortId      = 0;    // use 0 for now !
    nvInObj.dwSrvId = NVP_SRV_ENABLE_FSMIRROR;
    nvInObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvInObj.regOverlayMode2 = pDriverData->vpp.regOverlayMode2;
    nvInObj.dwOverlayFSHead = pDriverData->vpp.dwOverlayFSHead;
    nvInObj.dwDesktopState = pDriverData->dwDesktopState;

    // figure out which device to put the overlay on (copied from VPP)
    DWORD dwFSMirrorDevice = (pDriverData->vpp.regOverlayMode2 & NV4_REG_OVL_MODE2_FSDEVICEMASK) - 1;
    if (pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE && dwFSMirrorDevice != 0xFFFFFFFF) {
        if (dwFSMirrorDevice >= 14) {
            dwFSMirrorDevice = 1;
        }
        nvInObj.dwOverlayFSOvlHead = dwFSMirrorDevice ^ 1;
        } else {
#if (IS_WINNT4 || IS_WINNT5)
            nvInObj.dwOverlayFSOvlHead = (ppdev->ulDeviceDisplay[0]);
#else
            nvInObj.dwOverlayFSOvlHead = (pDXShare->dwHeadNumber);
#endif
        }

    // call vpe kernel to enable FS Mirror
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInObj, NULL);

    // NVP_SRV_REG_FSMIRROR_SURFACE  to register surfaces

    for (i = 0; i < (int)(pDriverData->vpp.dwOverlayFSNumSurfaces); i++)
    {
        NVPFsRegSurface(pDriverData,
                        &nvInObj,
                        i,
                        pDriverData->vpp.dwOverlayFSPitch,
                        pDriverData->vpp.dwOverlayFSOffset[i],
                        pDriverData->vpp.dwOverlayFSHeight,
                        pDriverData->vpp.dwOverlayFSWidth
                        );
    }

    //CloseHandle(NVP_DRIVER_HANDLE);
    //NVP_DRIVER_HANDLE = 0;

    pDriverData->nvpeState.bFsMirrorEnabled = TRUE;

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPFsMirrorDisable

    Description:  Interface function to the miniport.. cleanup


    Parameters:


    Note:       Xun Wang September 25, 2000

==============================================================================
*/
NVP_STATUS NVPFsMirrorDisable(GLOBALDATA *pDriverData)
{
    NVP_CMD_OBJECT nvInitObj;

    DPF("nvpkrnl.cpp: NVPFsMirrorDisable()\n");

    if (!pDriverData->nvpeState.bFsMirrorEnabled) {
        return NVP_STATUS_SUCCESS;
    }

    // fill up structure with data needed for uninitialization
    nvInitObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvInitObj.dwSrvId = NVP_SRV_DISABLE_FSMIRROR;
    nvInitObj.hClient = NVP_CLIENT;
    nvInitObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR;    // pDriverData->NvDevFlatVPE
    nvInitObj.dwPortId = 0; // use 0 for now !
    nvInitObj.dwDeviceId = NV_WIN_DEVICE;

    // call vpe kernel to disable FS Mirror
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInitObj, NULL);

    pDriverData->nvpeState.bFsMirrorEnabled = FALSE;

    return NVP_STATUS_SUCCESS;
}

#endif

/*
==============================================================================

    NVPIsVPEEnabled

    Description:    On Win2k: call vpe kernel which to check the regitry
                              to see if VPPEEnable=0 is set in regsitry !
                    On Win9x: read VPEEnable key registry here.

                    Both platforms: pass shared flag "pOvrRing0FlipFlag"
                                    to kernel

   Parameters:      DWORD hDevice:  - handle to the kernel device
                                    - if handle is NULL, then try to connect here

   Note:            this function is called at DDraw initialization time !

==============================================================================
*/
BOOL __stdcall NVPIsVPEEnabled(
    GLOBALDATA *pDriverData,
    DWORD hDevice)
{
    NVP_CMD_OBJECT nvInObj, nvOutObj;
    BOOL bEnableVPE;
#ifndef WINNT
    int i, j;
    char regStr[256];
    const char ddSubKey[] = NV4_REG_DIRECT_DRAW_SUBKEY;
    HKEY hKey;
#endif

    if (NVPEGetHandleToKernel(pDriverData, (HANDLE)hDevice) != NVP_STATUS_SUCCESS)
        return FALSE;

    // fill up structure with initialization data
    nvOutObj.dwSize         = sizeof(NVP_CMD_OBJECT);
    nvOutObj.dwPortId       = 0;

    nvInObj.dwSize          = sizeof(NVP_CMD_OBJECT);
    nvInObj.dwSrvId         = NVP_SRV_IS_VPE_ENABLED;
    nvInObj.dwPortId        = 0;

#ifndef WINNT
    nvInObj.pOvrRing0FlipFlag = (DWORD)&(pDriverData->bRing0FlippingFlag);

    // call vpe kernel
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInObj, NULL);

    CloseHandle(NVP_DRIVER_HANDLE);
    NVP_DRIVER_HANDLE = 0;

    // Grab the local registry path and append the DirectDraw subkey to the string
    // without using the C runtime library.
    MyExtEscape(pDXShare->dwHeadNumber, NV_ESC_GET_LOCAL_REGISTRY_PATH, 0, NULL, 256, regStr);

    for (i = 4; i < 255; i++)
    {
        if (regStr[i] == '\0')
            break;
    }
    regStr[i] = '\\';
    j = 0;
    while (ddSubKey[j] != '\0' && (i+j+1) < 256)
    {
        regStr[i+j+1] = ddSubKey[j++];
    }
    regStr[i+j+1] = '\0';

    // VPE enabled by default
    bEnableVPE = 1;

    if (RegOpenKeyEx((HKEY)(*((LPDWORD)&regStr[0])), &regStr[4], 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof(long);
        DWORD   dwType = REG_DWORD;
        long    lValue;

        //check for VPE enable bit
        if (RegQueryValueEx(hKey, NV4_REG_VPE_ENABLE, NULL, &dwType, (LPBYTE)&lValue, &dwSize) == ERROR_SUCCESS)
        {
            if (!lValue)
                bEnableVPE = FALSE;
        }
        RegCloseKey(hKey);
    }

#else
    nvInObj.pOvrRing0FlipFlag = 0;

    // win2k: call vpe kernel to read registry !
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInObj, &nvOutObj);

    bEnableVPE = ((nvOutObj.dwPortId == 1) ? TRUE : FALSE);
#endif // !WINNT

    return bEnableVPE;
}

/*
==============================================================================

    NVPEGetHandleToKernel

    Description:    get a handle to minivdd(Win9x) or miniport(Win2k)

==============================================================================
*/
NVP_STATUS NVPEGetHandleToKernel(
    GLOBALDATA *pDriverData,
    HANDLE hDevice)
{
#ifndef WINNT
    HANDLE hVxdHandle = INVALID_HANDLE_VALUE;
#endif // !WINNT

    // forced to use the device handle passed to us !
    if (hDevice)
        NVP_DRIVER_HANDLE = hDevice;
    else
    {
#ifndef WINNT
        if (!NVP_DRIVER_HANDLE)
        {
            // Check whether we are primary or secondary display
            DWORD dwSuccess, dwDeviceHandle;
            dwSuccess = NvRmConfigGet(pDriverData->dwRootHandle, pDriverData->dwDeviceHandle,
                                      NV_CFG_DEVICE_HANDLE, &dwDeviceHandle);

            if (dwSuccess != NVOS_CGE_STATUS_SUCCESS)
            {
                // Unable to know if we are primary or secondary
                // We must fail the VPE since loading the wrong VDD would cause a BSOD.
                DPF("ERROR: VPE is unable to know if we are primary or secondary display\n");
                return NVP_STATUS_FAILURE;
            }

            if (dwDeviceHandle == 1)
            {
                // We are primary display
                hVxdHandle = CreateFile(NVX_PRIMARY_MINIVDD, 0,0,0, CREATE_NEW, FILE_FLAG_DELETE_ON_CLOSE, 0);
            }
            else
            {
                // We are secondary display
                // NO VPE support yet
                DPF("ERROR: VPE not supported on second display\n");
                return NVP_STATUS_FAILURE;
            }

            if (hVxdHandle != INVALID_HANDLE_VALUE)
            {
                NVP_DRIVER_HANDLE = hVxdHandle;
            }
            else
            {
                DPF("ERROR: unable to connect to MiniVDD!\n");
                return NVP_STATUS_FAILURE;
            }
       }
#else
        NVP_DRIVER_HANDLE = ppdev->hDriver;
#endif // WINNT
    }

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPInitialize

    Description:    pass initialization and other VPE data to kernel

==============================================================================
*/
NVP_STATUS NVPInitialize
(
    GLOBALDATA *pDriverData,
    DWORD dwVPConnectionFlags,
    LPDDRAWI_DIRECTDRAW_GBL pDDGbl
)
{
    NVP_CMD_OBJECT nvInitObj;

    DPF("nvpkrnl.cpp: NVPInitialize()\n");

    NVPDumpVPConnectInfo(dwVPConnectionFlags);      //Dump connection info

    // First time call into HAL: Reset NV and and create some objects
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED) {
        DPF ("NVPInitialize: reset NV\n");
        if (!nvEnable32 (pDDGbl)) {
            return NVP_STATUS_FAILURE;
        }
    }

    //If VPE is already initialized, uninitialize it first before continuing
    //pDriverData->nvpeState.bVPEInitialized = FALSE;
    if(pDriverData->nvpeState.bVPEInitialized){
        NVPUninitialize(pDriverData);
    }

    if (NVPEGetHandleToKernel(pDriverData, NULL) != NVP_STATUS_SUCCESS) {
        return NVP_STATUS_FAILURE;
    }

#ifdef NV3
    NvChannel *pVPChannel;

    // Use Pio channel for NV3
    if (NVP_VPE_CHANNEL_PTR == NULL)
    {
        // allocate timer object
        if (NvRmAllocChannelPio(
                NVP_CLIENT,     //pDriverData->dwRootHandle,
                NV_WIN_DEVICE,
                NVP_VPE_CHANNEL,
                NV03_CHANNEL_PIO,
                0,
                (PVOID)&(NVP_VPE_CHANNEL_PTR),
                ALLOC_CHL_PIO_FLAGS_FIFO_IGNORE_RUNOUT) != 0)
        {
            DPF("ERROR: NVPInitialize() failed to allocate VPE PIO channel !\n");
            return NVP_STATUS_FAILURE;
        }
    }
    nvInitObj.dwChipId          = pDriverData->NvDeviceVersion; //NVP_CHIP_VER_03;
#else
    nvInitObj.dwChipId          = pDriverData->NvDeviceVersion; //NVP_CHIP_VER_04;
#endif

    // fill up structure with initialization data
    nvInitObj.dwSize            = sizeof(NVP_CMD_OBJECT);
    nvInitObj.dwSrvId           = NVP_SRV_INITIALIZE;
    nvInitObj.hClient           = NVP_CLIENT;
    nvInitObj.pChannel          = (U032) NVP_VPE_CHANNEL_PTR;   // pDriverData->NvDevFlatVPE
    nvInitObj.pOvrChannel       = (U032) NVP_OVERLAY_CHANNEL_PTR;
    nvInitObj.dwOvrSubChannel   = NVP_OVERLAY_SUBCHANNEL;       // DD_SPARE; // NV_DD_SPARE;
    //nvInitObj.dwOverlayObjectID = NV_DD_YUV422_VIDEO_FROM_MEMORY;
    //nvInitObj.dwScalerObjectID = NV_DD_VIDEO_SCALER;
    //nvInitObj.dwDVDObjectID = NV_DD_DVD_SUBPICTURE;

    nvInitObj.dwOverlayObjectID = NV_VIDEO_OVERLAY; //0xDD003F90;
    nvInitObj.dwScalerObjectID = NV_VIDEO_OVERLAY; //0xDD003FA0;
    nvInitObj.dwDVDObjectID = NV_VIDEO_DVD_SUBPICTURE;
    nvInitObj.dwDVDObjectCtxDma = NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY;
    nvInitObj.pNvPioFlipOverlayNotifierFlat = (U032)pDriverData->pPioFlipOverlayNotifierFlat;

    nvInitObj.dwPortId      = 0;    // use 0 for now !
    nvInitObj.dwDeviceId    = NV_WIN_DEVICE;
    nvInitObj.pFrameBuffer  = (U032) NVP_FB_BASE_ADDRESS;
    nvInitObj.dwFBLen       = NVP_FB_LENGTH;
    nvInitObj.dwVPTypeFlags = dwVPConnectionFlags;

    nvInitObj.MultiMon        = 0;
#if IS_WINNT5
    if (ppdev->TwinView_State == NVTWINVIEW_STATE_CLONE) {
        nvInitObj.MultiMon = 1;
    }
#elif IS_WIN9X
    if (pDriverData->dwDesktopState == NVTWINVIEW_STATE_DUALVIEW ||
        pDriverData->dwDesktopState == NVTWINVIEW_STATE_CLONE) {
        nvInitObj.MultiMon = 1;
    }
#endif
    nvInitObj.regOverlayMode  = pDriverData->vpp.regOverlayMode;
    nvInitObj.regOverlayMode2 = pDriverData->vpp.regOverlayMode2;
    nvInitObj.regOverlayMode3 = pDriverData->vpp.regOverlayMode3;

    NVPCreateEvents(pDriverData, &nvInitObj);

/*
    dwVal = (DWORD)('e' | ('p' << 8) | ('v' << 16) | ('n' << 24));
    pVppDispatch = (PNVP_VPP_DISPATCH) EngAllocMem(FL_ZERO_MEMORY, sizeof(NVP_VPP_DISPATCH), dwVal);
    nvInitObj.pVppDispatch = (ULONG)pVppDispatch;

    nvCreateThread(&hThreadHandle, ThreadProc);
*/
    // call vpe kernel to initialize media port
    if (NVPCallKernel(NVP_DRIVER_HANDLE, &nvInitObj, NULL) == NVP_STATUS_SUCCESS)
        pDriverData->nvpeState.bVPEInitialized = TRUE;

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPUninitialize

    Description:    clean up

==============================================================================
*/
NVP_STATUS NVPUninitialize(GLOBALDATA *pDriverData)
{
    NVP_CMD_OBJECT nvInitObj;

    DPF("nvpkrnl.cpp: NVPUninitialize()\n");

   // already un-initialized !
    if (pDriverData->nvpeState.bVPEInitialized == FALSE)
    {
        DPF("NVPUninitialize: already unintialized !\n");
        return NVP_STATUS_SUCCESS;
    }

#ifdef VPEFSMIRROR
    if (pDriverData->nvpeState.bFsMirrorEnabled) {
        NVPFsMirrorDisable(pDriverData);
    }
#endif

    // fill up structure with data needed for uninitialization
    nvInitObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvInitObj.dwSrvId = NVP_SRV_UNINITIALIZE;
    nvInitObj.hClient = NVP_CLIENT;
    nvInitObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR;    // pDriverData->NvDevFlatVPE
    nvInitObj.dwPortId = 0; // use 0 for now !
    nvInitObj.dwDeviceId = NV_WIN_DEVICE;

    // call vpe kernel to uninitialize media port
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvInitObj, NULL);

    // free VPE pio channel
    if (NVP_VPE_CHANNEL_PTR)
    {
        NvRmFree(NVP_CLIENT, NV_WIN_DEVICE, NVP_VPE_CHANNEL);
        NVP_VPE_CHANNEL_PTR = 0;
    }

    NVPDestroyEvents(pDriverData);

#ifndef WINNT
    CloseHandle(NVP_DRIVER_HANDLE);
    NVP_DRIVER_HANDLE = 0;
#endif


    // reset flag
    pDriverData->nvpeState.bVPEInitialized = FALSE;

/*
    if (pVppDispatch)
    {
        EngFreeMem(pVppDispatch);
        pVppDispatch = NULL;
    }

    if (hThreadHandle)
    {
        nvTerminateThread();
        hThreadHandle = NULL;
    }
*/
    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPStartVideo

    Description:    tells the VP to start grabbing

==============================================================================
*/
NVP_STATUS NVPStartVideo(
    LPDDHAL_UPDATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;
    NVP_CMD_OBJECT nvCmdObj;
    DWORD dwNumVideoSurfaces, dwNumVBISurfaces;
    DWORD i;

    DPF("nvpkrnl.cpp: NVPStartVideo()\n");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    // fill up structure with data needed for uninitialization
    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.hClient = NVP_CLIENT;
    nvCmdObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR; // pDriverData->NvDevFlatVPE
    nvCmdObj.dwPortId = 0;  // use 0 for now !
    nvCmdObj.dwDeviceId = NV_WIN_DEVICE;

    // keep a copy of the VP Info DDraw flags
    nvCmdObj.dwVPInfoFlags = lpInput->lpVideoInfo->dwVPFlags;

    // determine image dimensions
    NVPGetImageDim(&(lpInput->lpVideoPort->ddvpDesc), lpInput->lpVideoInfo, &nvCmdObj, (lpInput->lplpDDVBISurface == NULL));

    nvCmdObj.bSurfVBI = FALSE;
    nvCmdObj.bSurfUpdate = FALSE;

    dwNumVideoSurfaces = lpInput->dwNumAutoflip;
    dwNumVBISurfaces = lpInput->dwNumVBIAutoflip;

    // in case of manual flip, register one surface for now... the others will be passed to us in FlipVideoPort
    if (!(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP))
    {
        dwNumVideoSurfaces = (lpInput->lplpDDSurface) ? 1 : 0;
        dwNumVBISurfaces = (lpInput->lplpDDVBISurface) ? 1 : 0;
    }

    // register Video surfaces
    for (i = 0; i < dwNumVideoSurfaces; i++)
    {
        NVPRegSurface(pDriverData, lpInput->lplpDDSurface[i], &nvCmdObj, i);
    }

    // any VBI surfaces ?!
    nvCmdObj.bSurfVBI = (dwNumVBISurfaces != 0);
    for (i = 0; i < dwNumVBISurfaces; i++)
    {
        NVPRegSurface(pDriverData, lpInput->lplpDDVBISurface[i], &nvCmdObj, i);
    }

    // Need better explanation of this. @mjl@

    // channel pointer might have been updated or initialized later than expected
    nvCmdObj.pOvrChannel = (U032) NVP_OVERLAY_CHANNEL_PTR;
    // extra overlay offset (used for prescaling on NV4 and NV5 !)
    for (i = 0; i < pDriverData->vpp.extraNumSurfaces; i++)
    {
        nvCmdObj.aExtra422OverlayOffset[i] = pDriverData->vpp.extraOverlayOffset[i];
    }
    nvCmdObj.dwExtra422NumSurfaces = pDriverData->vpp.extraNumSurfaces;
    nvCmdObj.dwExtra422Index = pDriverData->vpp.extraIndex;
    nvCmdObj.dwExtra422Pitch = pDriverData->vpp.extraPitch;

    // call Miniport to start VP
    nvCmdObj.dwSrvId = NVP_SRV_START_VIDEO;

    // before starting media port, wait for overlay engine to complete operation 35msec x 2 fields ... this situation might occur during a mode switch
    NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY1, 35);
    NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY2, 35);

    // call vpe kernel to start media port
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    NvReleaseSemaphore(pDriverData);

    NVPDumpVPSurfInfo(lpInput, &nvCmdObj);

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPUpdateVideo

    Description:    updates VP settings

==============================================================================
*/
NVP_STATUS NVPUpdateVideo(
    LPDDHAL_UPDATEVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;
    NVP_CMD_OBJECT nvCmdObj;
    DWORD dwNumVideoSurfaces, dwNumVBISurfaces;
    DWORD i;

    DPF("nvpkrnl.cpp: NVPUpdateVideo()\n");

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    // stop video first !
//    NVPStopVideo(pDriverData);

    // fill up structure with data needed for uninitialization
    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.hClient = NVP_CLIENT;
    nvCmdObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR; // pDriverData->NvDevFlatVPE
    nvCmdObj.dwPortId = 0;  // use 0 for now !
    nvCmdObj.dwDeviceId = NV_WIN_DEVICE;

    // keep a copy of the VP Info DDraw flags
    nvCmdObj.dwVPInfoFlags = lpInput->lpVideoInfo->dwVPFlags;

    // determine image dimensions
    NVPGetImageDim(&(lpInput->lpVideoPort->ddvpDesc), lpInput->lpVideoInfo, &nvCmdObj, (lpInput->lplpDDVBISurface == NULL));

    nvCmdObj.bSurfVBI = FALSE;
    nvCmdObj.bSurfUpdate = TRUE;

    dwNumVideoSurfaces = lpInput->dwNumAutoflip;
    dwNumVBISurfaces = lpInput->dwNumVBIAutoflip;

    // in case of manual flip, register one surface for now... the others will be passed to us in FlipVideoPort
    if (!(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP))
    {
        dwNumVideoSurfaces = (lpInput->lplpDDSurface) ? 1 : 0;
        dwNumVBISurfaces = (lpInput->lplpDDVBISurface) ? 1 : 0;
    }

    // register Video surfaces
    for (i = 0; i < dwNumVideoSurfaces; i++)
    {
        NVPRegSurface(pDriverData, lpInput->lplpDDSurface[i], &nvCmdObj, i);
    }

    // any VBI surfaces ?!
    nvCmdObj.bSurfVBI = (dwNumVBISurfaces != 0);
    for (i = 0; i < dwNumVBISurfaces; i++)
    {
        NVPRegSurface(pDriverData, lpInput->lplpDDVBISurface[i], &nvCmdObj, i);
    }

    // Need better explanation of this. @mjl@

    // channel pointer might have been updated or initialized later than expected
    nvCmdObj.pOvrChannel = (U032) NVP_OVERLAY_CHANNEL_PTR;
    // extra overlay offset (used for prescaling on NV4 and NV5 !)
    for (i = 0; i < pDriverData->vpp.extraNumSurfaces; i++)
    {
        nvCmdObj.aExtra422OverlayOffset[i] = pDriverData->vpp.extraOverlayOffset[i];
    }
    nvCmdObj.dwExtra422NumSurfaces = pDriverData->vpp.extraNumSurfaces;
    nvCmdObj.dwExtra422Index = pDriverData->vpp.extraIndex;
    nvCmdObj.dwExtra422Pitch = pDriverData->vpp.extraPitch;

    // call Miniport to update VP
    nvCmdObj.dwSrvId = NVP_SRV_UPDATE_VIDEO;

    // call vpe kernel to update video port data/state
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    NvReleaseSemaphore(pDriverData);

    NVPDumpVPSurfInfo(lpInput, &nvCmdObj);

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPStopVideo

    Description:    tells the VP to stop grabbing video

==============================================================================
*/
NVP_STATUS NVPStopVideo (GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
    NVP_CMD_OBJECT nvCmdObj;

    DPF("nvpkrnl.cpp: NVPStopVideo()\n");

    if(!pDriverData->nvpeState.bVPEInitialized){
        return  NVP_STATUS_SUCCESS;
    }

    // case where stopping VPE right after a mode switch... Reset NV and and create some objects
    if (getDC()->dwEnableStatus != CDriverContext::DC_ENABLESTATUS_ENABLED)
    {
        DPF ("NVPStopVideo: reset NV !\n");
        if (!nvEnable32 (pDDGbl)) {
            return NVP_STATUS_FAILURE;   
        }
        //// this flag must be set here after a mode switch because a new pDriverData got created and the old
        // flag/state is lost ! (this flag might be reset in NVPUninitialize() later)
        pDriverData->nvpeState.bVPEInitialized = TRUE;
    }

    // fill up structure with data needed for uninitialization
    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.dwSrvId = NVP_SRV_STOP_VIDEO;
    nvCmdObj.hClient = NVP_CLIENT;
    nvCmdObj.pChannel = (U032) NVP_VPE_CHANNEL_PTR; // pDriverData->NvDevFlatVPE
    nvCmdObj.dwPortId = 0;  // use 0 for now !
    nvCmdObj.dwDeviceId = NV_WIN_DEVICE;

    // call vpe kernel to stop media port
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    // wait for overlay engine to complete operation 35msec x 2 fields
    NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY1, 35);
    NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY2, 35);

    DPF("NVPStopVideo: end function !\n");

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPGetImageDim

    Description:    determines the dimension of captured video field (crop,
                    vbi height...)

==============================================================================
*/
NVP_STATUS NVPGetImageDim(
    LPDDVIDEOPORTDESC pVPDesc,
    LPDDVIDEOPORTINFO pVideoInfo,
    PNVP_CMD_OBJECT pnvCmdObj,
    BOOL bIsVideoOnlySurface)
{
    if (bIsVideoOnlySurface)
    {
        // this indicates that there are NO VBI surfaces associated with this video port update.
        // therefore we should send all the line to the Image surface
        pnvCmdObj->dwImageStartLine = 0;    // send all the data after line 0

        if (pVideoInfo->dwVPFlags & DDVP_CROP)
        {
            if(pVideoInfo->rCrop.top > (signed long) pnvCmdObj->dwImageStartLine)
                pnvCmdObj->dwImageStartLine = pVideoInfo->rCrop.top;
        }

    }
    else
    {
#define NVP_VBIVALIDDATALINE    1
        // there are some VBI surfaces associated with this video port,
        // so update VBI height and start line accordingly
        pnvCmdObj->dwVBIStartLine = NVP_VBIVALIDDATALINE;

        pnvCmdObj->dwVBIHeight = pVideoInfo->dwVBIHeight;

        pnvCmdObj->dwImageStartLine = 1 + pnvCmdObj->dwVBIHeight + pnvCmdObj->dwVBIStartLine;

        // Image start line should be one line after the vbi end

        if (pVideoInfo->dwVPFlags & DDVP_CROP)
        {
            if (pVideoInfo->rCrop.top > (signed long) pnvCmdObj->dwImageStartLine)
                pnvCmdObj->dwImageStartLine = pVideoInfo->rCrop.top;
        }
    }

    // check for cropping
    if (pVideoInfo->dwVPFlags & DDVP_CROP)
    {
        pnvCmdObj->dwInHeight = (DWORD) (pVideoInfo->rCrop.bottom - pVideoInfo->rCrop.top);
        pnvCmdObj->dwInWidth  = (DWORD) (pVideoInfo->rCrop.right - pVideoInfo->rCrop.left);
    }
    else
    {
        pnvCmdObj->dwInHeight = pVPDesc->dwFieldHeight;
        pnvCmdObj->dwInWidth  = pVPDesc->dwFieldWidth;
    }

    // in the case where DDVP_IGNOREVBIXCROP flag is set we must substract the VBIHeight from InHeight
    if (pVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP)
	    pnvCmdObj->dwInHeight -= (pVideoInfo->dwVBIHeight+1);	// -1=empirical data shows this is needed
																// to normalize to vid size

    // check prescaling
    if (pVideoInfo->dwVPFlags & DDVP_PRESCALE)
    {
        pnvCmdObj->dwPreHeight = pVideoInfo->dwPrescaleHeight;
        pnvCmdObj->dwPreWidth  = pVideoInfo->dwPrescaleWidth;

    }
    else
    {
        pnvCmdObj->dwPreHeight = pnvCmdObj->dwInHeight;
        pnvCmdObj->dwPreWidth = pnvCmdObj->dwInWidth;
    }

    pnvCmdObj->dwOriginX = pVideoInfo->dwOriginX;
    pnvCmdObj->dwOriginY = pVideoInfo->dwOriginY;

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPRegSurface

    Description:    registers a new surface in miniport

==============================================================================
*/
NVP_STATUS NVPRegSurface(
    GLOBALDATA *pDriverData,
    PNVP_DDRAW_SURFACE pDDSurface,  // lpInput->lplpDDSurface,
    PNVP_CMD_OBJECT pnvCmdObj,
    DWORD dwSurfaceId)
{
    DWORD dwVal;

    // surface memory pointer and pitch
    pnvCmdObj->pSurfVidMem = NVP_GET_SURFACE_POINTER(pDDSurface->lpLcl->lpGbl->fpVidMem);
    pnvCmdObj->dwSurfPitch = pDDSurface->lpLcl->lpGbl->lPitch;

    // compute the actual offset
    dwVal = (pnvCmdObj->dwOriginX)*2 + (pnvCmdObj->dwOriginY)*(pnvCmdObj->dwSurfPitch);
    pnvCmdObj->dwSurfOffset = NVP_GET_SURFACE_OFFSET(pDDSurface->lpLcl->lpGbl->fpVidMem) + dwVal;

    pnvCmdObj->dwSrvId = NVP_SRV_REG_SURFACE;
    pnvCmdObj->dwSurfaceId = dwSurfaceId;

    // call vpe kernel to register surface
    NVPCallKernel(NVP_DRIVER_HANDLE, pnvCmdObj, NULL);

    return NVP_STATUS_SUCCESS;
}


/*
==============================================================================

    NVPUpdateOverlay

    Description:    update overlay data in miniport

==============================================================================
*/
DWORD __stdcall NVPUpdateOverlay(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
    NVP_CMD_OBJECT nvCmdObj;
    DWORD          i;

    // this is a case where a VPE object wasn't created (ex: STB TV app) but KMVT service OverlayFlip() is called !
    if ((pDriverData->bRing0FlippingFlag) && !(pDriverData->nvpeState.bVPEInitialized))
    {
        if (NVPInitialize(pDriverData, 0, pDDGbl) != NVP_STATUS_SUCCESS)
            return 0;
    }

    if(!(pDriverData->nvpeState.bVPEInitialized)){
        return 0;
    }

    // copy overlay data from DriverInfo
    nvCmdObj.dwOverlayFormat       = pDriverData->vpp.dwOverlayFormat;
    nvCmdObj.dwOverlaySrcX         = pDriverData->vpp.dwOverlaySrcX;
    nvCmdObj.dwOverlaySrcY         = pDriverData->vpp.dwOverlaySrcY;
    nvCmdObj.dwOverlaySrcPitch     = pDriverData->vpp.dwOverlaySrcPitch;
    nvCmdObj.dwOverlaySrcSize      = pDriverData->vpp.dwOverlaySrcSize;
    nvCmdObj.dwOverlaySrcWidth     = pDriverData->vpp.dwOverlaySrcWidth;
    nvCmdObj.dwOverlaySrcHeight    = pDriverData->vpp.dwOverlaySrcHeight;
    nvCmdObj.dwOverlayDstWidth     = pDriverData->vpp.dwOverlayDstWidth;
    nvCmdObj.dwOverlayDstHeight    = pDriverData->vpp.dwOverlayDstHeight;
    nvCmdObj.dwOverlayDstX         = pDriverData->vpp.dwOverlayDstX;
    nvCmdObj.dwOverlayDstY         = pDriverData->vpp.dwOverlayDstY;
    nvCmdObj.dwOverlayDeltaX       = pDriverData->vpp.dwOverlayDeltaX;
    nvCmdObj.dwOverlayDeltaY       = pDriverData->vpp.dwOverlayDeltaY;
    nvCmdObj.dwOverlayColorKey     = pDriverData->vpp.dwOverlayColorKey;
    nvCmdObj.dwOverlayMode         = pDriverData->vpp.dwOverlayMode;
    nvCmdObj.dwOverlayMaxDownScale = pDriverData->vpp.dwOverlayMaxDownScale;

    // Need better explanation of this. @mjl@

    // extra overlay offset (used for prescaling on NV4 and NV5 !)
    for (i = 0; i < pDriverData->vpp.extraNumSurfaces; i++)
    {
        nvCmdObj.aExtra422OverlayOffset[i] = pDriverData->vpp.extraOverlayOffset[i];
    }
    nvCmdObj.dwExtra422NumSurfaces = pDriverData->vpp.extraNumSurfaces;
    nvCmdObj.dwExtra422Index = pDriverData->vpp.extraIndex;
    nvCmdObj.dwExtra422Pitch = pDriverData->vpp.extraPitch;

    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.dwSrvId = NVP_SRV_UPDATE_OVERLAY;
    nvCmdObj.dwPortId = 0;  // use 0 for now !

    // call vpe kernel to register this surface
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    if ((pDriverData->vpp.dwOverlayDstWidth == 0) && (pDriverData->vpp.dwOverlayDstHeight == 0))
    {
        // wait for overlay engine to complete operation (35msec)
        NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY1, 35);
        NVPWaitForSync(pDriverData, NVP_EVENT_OVERLAY2, 35);
    }

    return 0;
}

/*
==============================================================================

    NVPWaitForSync

    Description:    waits on vpe events. They are set by video kernel when
                    notification is issued after an even or odd field is
                    displayed or when captured (or engine stopped)

==============================================================================
*/
NVP_STATUS NVPWaitForSync(
    GLOBALDATA *pDriverData,
    DWORD dwIndex, // event list index NVP_EVENT_MEDIAPORT, NVP_EVENT_OVERLAY1, NVP_EVENT_OVERLAY2
    DWORD dwTimeOut) // in msec
{
#ifdef WINNT
    LARGE_INTEGER llTimeOut;

    if (pDriverData->nvpeState.hNVPSyncEvent[dwIndex] == NULL)
        return NVP_STATUS_SUCCESS;

    if (dwTimeOut)
    {
        llTimeOut.LowPart = -((int)dwTimeOut) * 10000;   // measured in units of 100 ns in NT
        llTimeOut.HighPart = -1;                       // negative means relative to current time
    }
    else
    {
        llTimeOut.LowPart = 0;
        llTimeOut.HighPart = 0;
    }

    // note: DDK docs are wrong, it returns an error code of 0x102 if timed-out and 0 on success, not a TRUE/FALSE result
    return (NVP_STATUS)(EngWaitForSingleObject((PEVENT) (pDriverData->nvpeState.hNVPSyncEvent[dwIndex]), &llTimeOut));

#else   //WINNT
    NVP_STATUS dwStatus;

    if (pDriverData->nvpeState.hNVPSyncEvent[dwIndex] == NULL)
        return NVP_STATUS_SUCCESS;

    dwStatus = (NVP_STATUS)(WaitForSingleObject(pDriverData->nvpeState.hNVPSyncEvent[dwIndex], dwTimeOut));
    ResetEvent(pDriverData->nvpeState.hNVPSyncEvent[dwIndex]);

    return dwStatus;
#endif  //WINNT
}

/*
==============================================================================

    NVPCreateEvents

    Description:    creates VPE events. They are set by video kernel when
                    notification is issued after an even or odd field is
                    captured (at end of mediaport vsync !)

==============================================================================
*/
NVP_STATUS NVPCreateEvents(
    GLOBALDATA *pDriverData,
    PNVP_CMD_OBJECT pnvInitObj)
{
    int i;

    // media port and overlay synchronization event
    for (i = 0; i < NVP_EVENT_MAX; i++)
    {
#ifndef WINNT
        if (!(pDriverData->nvpeState.hNVPSyncEvent[i] = CreateEvent(NULL, TRUE, FALSE, NULL)))
#else
        if (!EngCreateEvent((PEVENT *)&(pDriverData->nvpeState.hNVPSyncEvent[i])))
#endif
        {

            DPF("ERROR: NVPCreateEvents() failed to create sync events !\n");
            return NVP_STATUS_FAILURE;
        }

#ifndef WINNT
        // under Win9x, convert win32 event to ring0 handle
        pDriverData->nvpeState.hNVPSyncEvent0[i] = ConvertRing3EventToRing0((HANDLE) (pDriverData->nvpeState.hNVPSyncEvent[i]));
        pnvInitObj->hNVPSyncEvent[i] = (U032)(pDriverData->nvpeState.hNVPSyncEvent0[i]);
#else
        // under Win2k, you must de-reference the event handle in order to be used by miniport KeSetEvent !
        pnvInitObj->hNVPSyncEvent[i] = (U032) (*((LPDWORD)(pDriverData->nvpeState.hNVPSyncEvent[i])));
#endif
    }

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPDestroyEvents

    Description:    destroys VPE events

==============================================================================
*/
NVP_STATUS NVPDestroyEvents(GLOBALDATA *pDriverData)
{
    int i;

    // close media port and overlay synchronization event
    for (i = 0; i < NVP_EVENT_MAX; i++)
    {
#ifndef WINNT
        CloseHandle(pDriverData->nvpeState.hNVPSyncEvent[i]);
        CloseRing0Handle(pDriverData->nvpeState.hNVPSyncEvent0[i]);
        pDriverData->nvpeState.hNVPSyncEvent0[i] = NULL;

#else
        HDRVEVENT pevent;
        if(pevent = (PEVENT)pDriverData->nvpeState.hNVPSyncEvent[i])
        {
            EngDeleteEvent(pevent);
        }

#endif
        pDriverData->nvpeState.hNVPSyncEvent[i] = NULL;
    }

    return NVP_STATUS_SUCCESS;
}


/*
==============================================================================

    NVPFlipVideoPort

    Description:    asks kernel to start capturing now to the specified
                    target surface

==============================================================================
*/
NVP_STATUS NVPFlipVideoPort(
    LPDDHAL_FLIPVPORTDATA lpInput)
{
    GLOBALDATA *pDriverData;
    NVP_CMD_OBJECT nvCmdObj;
    DWORD dwVal;

    nvSetDriverDataPtrFromDDGbl (lpInput->lpDD->lpGbl);

    // determine image dimensions
    NVPGetImageDim(&(lpInput->lpVideoPort->ddvpDesc), &(lpInput->lpVideoPort->ddvpInfo), &nvCmdObj, TRUE);

    // surface memory pointer and pitch
    nvCmdObj.pSurfVidMem = NVP_GET_SURFACE_POINTER(lpInput->lpSurfTarg->lpGbl->fpVidMem);
    nvCmdObj.dwSurfPitch = lpInput->lpSurfTarg->lpGbl->lPitch;

    // compute the actual offset
    dwVal = (nvCmdObj.dwOriginX)*2 + (nvCmdObj.dwOriginY)*(nvCmdObj.dwSurfPitch);
    nvCmdObj.dwSurfOffset = NVP_GET_SURFACE_OFFSET(lpInput->lpSurfTarg->lpGbl->fpVidMem) + dwVal;

    nvCmdObj.dwSize = sizeof(NVP_CMD_OBJECT);
    nvCmdObj.dwPortId = 0;  // use 0 for now !
    nvCmdObj.dwSrvId = NVP_SRV_FLIP_VIDEOPORT;
    nvCmdObj.dwSurfaceId = NVP_UNDEF; // this value tells the kernel to lookup the surface Id in its registered surfaces list

    // flip to the target surface
    NVPCallKernel(NVP_DRIVER_HANDLE, &nvCmdObj, NULL);

    NvReleaseSemaphore(pDriverData);

    return NVP_STATUS_SUCCESS;
}

/*
==============================================================================

    NVPCallKernel

    Description:    OS dependent functions used to call miniport (Win2k) or
                    minivdd (Win9x)

==============================================================================
*/
NVP_STATUS NVPCallKernel(
    HANDLE hDevice,
    PNVP_CMD_OBJECT pnvInCmdObj,
    PNVP_CMD_OBJECT pnvOutCmdObj)
{
    DWORD   dwCBRet, dwSizeOut = 0;

    if (pnvOutCmdObj != NULL)
       dwSizeOut = sizeof(NVP_CMD_OBJECT);

#ifndef WINNT

    if (DeviceIoControl(
            hDevice,
            IOCTL_VIDEO_VPE_COMMAND,
            pnvInCmdObj,
            sizeof(NVP_CMD_OBJECT),
            pnvOutCmdObj,
            dwSizeOut,
            &dwCBRet,
            NULL))
        return NVP_STATUS_SUCCESS;  //Win9x returns non-zero for success

#else

    if (!EngDeviceIoControl(
            hDevice,          //pDriverData->ppdev->hDriver
            IOCTL_VIDEO_VPE_COMMAND,
            pnvInCmdObj,
            sizeof(NVP_CMD_OBJECT),
            pnvOutCmdObj,
            dwSizeOut,
            &dwCBRet))
        return NVP_STATUS_SUCCESS;  //Win2k returns zero for success

#endif // !WINNT

    return NVP_STATUS_FAILURE;
}

/*
==============================================================================

    NVPCleanUp

    Description:    basically, calls NVPUninitialize() and clears the ring0
                    flip flag set by kernel services

    Note:           this function is called from DestroySurface32() which
                    is NOT the "normal" path for uninitialization.
                    DestroyVideoPort32/NVPUninitialize is !

==============================================================================
*/
DWORD __stdcall NVPCleanUp(GLOBALDATA *pDriverData, LPDDRAWI_DIRECTDRAW_GBL pDDGbl)
{
#ifdef VPEFSMIRROR
    if (pDriverData->nvpeState.bVPEInitialized && pDriverData->nvpeState.bFsMirrorEnabled) {
        NVPFsMirrorDisable(pDriverData);
    }
#endif

//need to understand why the ifdef's are here to diff OSes.
#ifndef WINNT
    if ((pDriverData->bRing0FlippingFlag) && (pDriverData->nvpeState.bVPEInitialized)){
        //Dst width & height =0 will shutdown overlay
        //changing size values are not recommended but since these values
        //are updated when you call updateoverlay, I guess this is fine.
        //and we are destroying VP anyway...
        pDriverData->vpp.dwOverlayDstWidth = 0;
        pDriverData->vpp.dwOverlayDstHeight = 0;
        NVPUpdateOverlay(pDriverData, pDDGbl);
        NVPStopVideo(pDriverData, pDDGbl);
        NVPUninitialize(pDriverData);
    }

    pDriverData->bRing0FlippingFlag = 0;
#else
    if (pDriverData->nvpeState.bVPEInitialized){
        //Dst width & height =0 will shutdown overlay
        //changing size values are not recommended but since these values
        //are updated when you call updateoverlay, I guess this is fine.
        //and we are destroying VP anyway...
        pDriverData->vpp.dwOverlayDstWidth = 0;
        pDriverData->vpp.dwOverlayDstHeight = 0;
        NVPUpdateOverlay(pDriverData, pDDGbl);

		//bRing0FlippingFlag is only set when r0 lock is called (busmaster cards)
		//don't need to destroy VP otherwise (VP using non-over surf)
		if(pDriverData->bRing0FlippingFlag){
			NVPStopVideo(pDriverData, pDDGbl);
			NVPUninitialize(pDriverData);
		}
    }
#endif

    return 0;
}


NVP_STATUS NVPDumpVPSurfInfo(LPDDHAL_UPDATEVPORTDATA lpInput, NVP_CMD_OBJECT *pnvCmdObj)
{

    int i;

    DPF("nvpkrnl.cpp: # Video surf          =0x%x", lpInput->dwNumAutoflip);
    if(lpInput->dwNumAutoflip > 0){
        for(i=0; i < (int)(lpInput->dwNumAutoflip); ++i){
            DPF("nvpkrnl.cpp:   pVidMem (%d)        =0x%x", i,
                NVP_GET_SURFACE_POINTER(((lpInput->lplpDDSurface)[i])->lpLcl->lpGbl->fpVidMem));
        }
        DPF("nvpkrnl.cpp:   Pitch               =0x%x (%d)",
                        (*(lpInput->lplpDDSurface))->lpLcl->lpGbl->lPitch,
                        (*(lpInput->lplpDDSurface))->lpLcl->lpGbl->lPitch);
        DPF("nvpkrnl.cpp:   Width               =0x%x (%d)", pnvCmdObj->dwInWidth, pnvCmdObj->dwInWidth);
        DPF("nvpkrnl.cpp:   Height              =0x%x (%d)", pnvCmdObj->dwInHeight, pnvCmdObj->dwInHeight);
        DPF("nvpkrnl.cpp:   PrescaleSizeX       =0x%x (%d)", pnvCmdObj->dwPreWidth, pnvCmdObj->dwPreWidth);
        DPF("nvpkrnl.cpp:   PrescaleSizeY       =0x%x (%d)", pnvCmdObj->dwPreHeight, pnvCmdObj->dwPreHeight);
        DPF("nvpkrnl.cpp:   Video Start Line    =0x%x (%d)", pnvCmdObj->dwImageStartLine, pnvCmdObj->dwImageStartLine);

        // print some stuff out about the flags we're lookin at:
        /*if( pMySurfaces->bInvertedFields ) {
            DPF("      field polarity               inverted");
        } else {
            DPF("      field polarity               normal");
        }*/
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_AUTOFLIP  ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_AUTOFLIP            on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_AUTOFLIP            off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CONVERT       ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_CONVERT            on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_CONVERT            off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_CROP                  ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_CROP               on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_CROP               off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_INTERLEAVE            ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_INTERLEAVE         on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_INTERLEAVE         off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORLEFTRIGHT       ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_MIRRORLEFTRIGHT    on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_MIRRORLEFTRIGHT    off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_MIRRORUPDOWN          ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_MIRRORUPDOWN       on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_MIRRORUPDOWN       off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_PRESCALE              ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_PRESCALE           on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_PRESCALE           off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPEVENFIELDS        ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SKIPEVENFIELDS     on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SKIPEVENFIELDS     off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SKIPODDFIELDS         ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SKIPODDFIELDS      on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SKIPODDFIELDS      off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_SYNCMASTER                ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SYNCMASTER         on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_SYNCMASTER         off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBICONVERT                ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_VBICONVERT         on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_VBICONVERT         off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_VBINOSCALE                ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_VBINOSCALE         on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_VBINOSCALE         off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_OVERRIDEBOBWEAVE      ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_OVERRIDEBOBWEAVE   on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_OVERRIDEBOBWEAVE   off");
        }
        if(lpInput->lpVideoInfo->dwVPFlags & DDVP_IGNOREVBIXCROP        ) {
            DPF("nvpkrnl.cpp:   FLAG DDVP_IGNOREVBIXCROP     on");
        } else {
            DPF("nvpkrnl.cpp:   FLAG DDVP_IGNOREVBIXCROP     off");
        }





    }

    DPF("nvpkrnl.cpp: # Vbi surf            =0x%x", lpInput->dwNumVBIAutoflip);
    if(lpInput->dwNumVBIAutoflip){
        for(i=0; i < (int)(lpInput->dwNumVBIAutoflip); ++i){
            DPF("nvpkrnl.cpp:   pVbiMem (%d)        =0x%x", i,
                NVP_GET_SURFACE_POINTER(((lpInput->lplpDDVBISurface)[i])->lpLcl->lpGbl->fpVidMem));
        }
        DPF("nvpkrnl.cpp:   Vbi Start Line      =0x%x (%d)", pnvCmdObj->dwVBIStartLine, pnvCmdObj->dwVBIStartLine);
        DPF("nvpkrnl.cpp:   Vbi Height          =0x%x (%d)", pnvCmdObj->dwVBIHeight, pnvCmdObj->dwVBIHeight);
        DPF("nvpkrnl.cpp:   Vbi Pitch           =0x%x (%d)",
                        (*(lpInput->lplpDDVBISurface))->lpLcl->lpGbl->lPitch,
                        (*(lpInput->lplpDDVBISurface))->lpLcl->lpGbl->lPitch);
    }

    return NVP_STATUS_SUCCESS;

}

NVP_STATUS NVPDumpVPConnectInfo(DWORD dwVPConnectionFlags)
{
    //we currently do not use these
    /*
    // this is the second create
    DPF("  Size of the DDVIDEOPORTDESC structure     %d",lpInput->lpDDVideoPortDesc->dwSize);
    DPF("  Width of the video port field.            %d",lpInput->lpDDVideoPortDesc->dwFieldWidth);
    DPF("  Width of the VBI data.                    %d",lpInput->lpDDVideoPortDesc->dwVBIWidth);
    DPF("  Height of the video port field.           %d",lpInput->lpDDVideoPortDesc->dwFieldHeight);
    DPF("  Microseconds per video field.             %d",lpInput->lpDDVideoPortDesc->dwMicrosecondsPerField);
    DPF("  Maximum pixel rate per second.            %d",lpInput->lpDDVideoPortDesc->dwMaxPixelsPerSecond);
    DPF("  Video port ID (0 - (dwMaxVideoPorts -1)). %d",lpInput->lpDDVideoPortDesc->dwVideoPortID);
    DPF("  Reserved for future use - set to zero.    %d",lpInput->lpDDVideoPortDesc->dwReserved1);
    DPF("  Size of the DDVIDEOPORTDESC.dwSize        %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwSize);
    DPF("              DDVIDEOPORTDESC.dwPortWidth   %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwPortWidth);
#ifndef __cplusplus
    DPF("              DDVIDEOPORTDESC.guidTypeID    %d",lpInput->lpDDVideoPortDesc->VideoPortType.guidTypeID);
#endif
    DPF("              DDVIDEOPORTDESC.dwFlags       %d",lpInput->lpDDVideoPortDesc->VideoPortType.dwFlags);
    */
    DPF("nvpkrnl.cpp:VP Connection Info");
    if(dwVPConnectionFlags & DDVPCONNECT_INTERLACED ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_INTERLACED          on");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_INTERLACED          off");
    }
    if(dwVPConnectionFlags & DDVPCONNECT_INVERTPOLARITY  ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_INVERTPOLARITY      on");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_INVERTPOLARITY      off");
    }
    if(dwVPConnectionFlags & DDVPCONNECT_HALFLINE  ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_HALFLINE            on");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_HALFLINE            off");
    }
    if(dwVPConnectionFlags & DDVPCONNECT_VACT ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_VACT                on  -ERROR!!!!");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_VACT                off");
    }
    if(dwVPConnectionFlags & DDVPCONNECT_DOUBLECLOCK ) {
        DPF("nvpkrnl.cpp:   DDVPCONNECT_DOUBLECLOCK         on  -ERROR!!!!");
    }else{
        DPF("nvpkrnl.cpp:   DDVPCONNECT_DOUBLECLOCK         off");
    }


    return NVP_STATUS_SUCCESS;

}
//

void __stdcall NVPInitialState(
    GLOBALDATA *pDriverData)
{
    int i;

    pDriverData->nvpeState.bVPEInitialized = FALSE;
    pDriverData->nvpeState.bFsMirrorEnabled = FALSE;
    pDriverData->nvpeState.dwVPEState = 0;
    pDriverData->nvpeState.hVPEKernel = 0;
    for (i=0; i<NVPE_EVENT_MAX; i++) {
        pDriverData->nvpeState.hNVPSyncEvent[i] = 0;
        pDriverData->nvpeState.hNVPSyncEvent0[i] = 0;
    }

}


#endif // NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\VPE\src\core\nvpecore.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//***************************************************************************
//  Module Name:
//
//      nvpecore.c
//
//  Abstract:
//
//      This module contains the core implementation of VideoPort Extension
//      and Kernel mode video transport on both Win2k and Win9x
//
//      The DirectDraw Video Port Extensions (VPE) are the services that
//      control hardware videoports, where video data is streamed into
//      off-screen memory from an external device such as a TV tuner or
//      MPEG decoder, and then displayed on the screen by a video overlay.
//
//      To support VPE, you'll need the following:
//
//          1. A 2-D driver with DirectDraw overlay support;
//          2. A video input device that interfaces with the videoport;
//          3. A bunch of VPE code in the display driver;
//          4. A bunch of VPE code here in the miniport/miniVDD.
//
//
//  Environment:
//
//      Kernel mode
//
//  Copyright (c) 1997 Microsoft Corporation
//
//***************************************************************************

#ifdef NVPE

#include "nvpecore.h" // local definitions

//#define _NVP_DTRACE
//#define _NVP_TEST_NEXT_FIELD
#define FORCE_INTERLEAVE_MEM	//NOTE: If this is defined, DoBobFromInterleaved 
								//		is always called.
								//		Surf is always interleaved even if ddraw
								//		requests for non-interleaved surf. Need to
								//		double dwOverlaySrcHeight. Can't rely on ddraw
								//		interleave caps and our NV_VFM_FORMAT_X caps
								//		that is shared with the overlay code.

#ifdef _NVP_DTRACE
#define DEFINE_GLOBALS
#include "dtrace.h"
#endif

////////// globals
BOOL g_bFlip = FALSE;
DWORD g_nIntCounter = 0;
int DebugLevel=0;               //Debug level for printfs
#ifdef _NVP_TEST_NEXT_FIELD
int g_nNextFieldId = 0;
#endif

//Local Functions
VP_STATUS NVPFlushChannel(PNVP_CONTEXT pVPEContext);

#ifdef VPEFSMIRROR
// extern function not found in one of the header files need to integrate later [XW]
extern U032 rmNVPAlloc(U032 hClient, U032 hChannel,U032 hObject,U032 hClass, PVOID pAllocParms);
#endif


/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD FlipVideoPort(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPVIDEOPORTINFO pFlipVideoPortInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DBGPRINT(DBGTRACE,"FlipVideoPort()");
#ifdef _NOT_IMPLEMENTED
    //
    // Get offset (from framebuffer) and add offset from surface:
    //
    ULONG offset;

    offset = pFlipVideoPortInfo->lpTargetSurface->dwSurfaceOffset
           + pFlipVideoPortInfo->lpVideoPortData->dwOriginOffset;

    // flip the actual hw surface here
#endif
    return DX_OK;
}

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD FlipOverlay(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
    DDSURFACEDATA* pCurSurf = (DDSURFACEDATA*) (pFlipOverlayInfo->lpCurrentSurface);
    DDSURFACEDATA* pTargSurf = (DDSURFACEDATA*) (pFlipOverlayInfo->lpTargetSurface);
    PNVP_CONTEXT pVPEContext;
    U032 dwFlags, dwOverlayOffset;
    PNVP_OVERLAY pOvInfo;

    DBGPRINT(DBGTRACE,"FlipOverlay()");

    // get a pointer to the appropriate VPE context (assume VPE 0)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    // if not initialized
    if (pVPEContext->nvDmaFifo == NULL)
    {
        return DXERR_GENERIC;
    }

    // NVPUpdateOverlay must be called first !
    if (!g_bFlip)
        return NO_ERROR;

    pOvInfo = &(pVPEContext->nvpOverlay);

    // VPP flags
    dwFlags = VPP_PRESCALE;

    if (pTargSurf->dwOverlayFlags & DDOVER_INTERLEAVED)
       dwFlags |= VPP_INTERLEAVED;
      else
       dwFlags |= VPP_BOB;   // non-interleaved

    if (pTargSurf->dwOverlayFlags & DDOVER_BOB)
       dwFlags |= VPP_BOB;

    if (pFlipOverlayInfo->dwFlags & DDFLIP_ODD)
        dwFlags |= VPP_ODD;
    else if (pFlipOverlayInfo->dwFlags & DDFLIP_EVEN)
        dwFlags |= VPP_EVEN;

    // initialize overlay buffer index if necessary
    if (pOvInfo->dwOverlayBufferIndex == NVP_UNDEF)
        pOvInfo->dwOverlayBufferIndex = 0;

    dwOverlayOffset = (U032)pTargSurf->fpLockPtr - pVPEContext->pFrameBuffer;

    // flip overlay here !
    if (NVPPrescaleAndFlip(pVPEContext, pOvInfo, dwOverlayOffset, pTargSurf->lPitch, 0, dwFlags))
        return DX_OK;

    return DXERR_GENERIC;
}

DWORD LockSurface(
    PVOID HwDeviceExtension,
    PNVP_DDLOCKININFO pLockInfoIn,
    PNVP_DDLOCKOUTINFO pLockInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
    PNVP_CONTEXT pVPEContext;
    U032 *pOvrFlag;

    DBGPRINT(DBGTRACE, "LockSurface()");

    // get a pointer to the appropriate VPE context (assume VPE 0)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    // this is a shared flag with DDraw...  set flag to indicate to DDraw that VPE kernel takes care of overlay flips !
    pOvrFlag = (U032 *) (pVPEContext->pOvrRing0FlipFlag);
    if (pOvrFlag)
        *pOvrFlag = 1;

    return DX_OK;
}

/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD BobNextField(
    PVOID HwDeviceExtension,
    PNVP_DDBOBNEXTFIELDINFO pBobNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DBGPRINT(DBGTRACE,"BobNextField()");

    return DX_OK;
}

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD SetState(
    PVOID HwDeviceExtension,
    PNVP_DDSETSTATEININFO  pSetStateInInfo,
    PNVP_DDSETSTATEOUTINFO pSetStateOutInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DBGPRINT(DBGERROR,"SetState() not implemented");

    return DX_OK;
}


/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD SkipNextField(
    PVOID HwDeviceExtension,
    PNVP_DDSKIPNEXTFIELDINFO pSkipNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DBGPRINT(DBGERROR,"SkipNextField() not implemented");

    return DX_OK;
}


/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD GetPolarity(
    PVOID HwDeviceExtension,
    PNVP_DDGETPOLARITYININFO  pGetPolarityInInfo,
    PNVP_DDGETPOLARITYOUTINFO pGetPolarityOutInfo)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) HwDeviceExtension;
    PNVP_CONTEXT pVPEContext;

    DBGPRINT(DBGTRACE,"GetPolarity()");

    // get a handle to current VPE context (BUGBUG: assume index 0 for now !)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    // check video first !
    if (pVPEContext->nNumVidSurf)
    {
        // TRUE for Even, FALSE for Odd
        if (pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType == NVP_FIELD_ODD)
            pGetPolarityOutInfo->bPolarity = FALSE;
        else
            pGetPolarityOutInfo->bPolarity = TRUE;
    }
    // vbi polarity
    else if (pVPEContext->nNumVBISurf)
    {
        if (pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType == NVP_FIELD_ODD)
            pGetPolarityOutInfo->bPolarity = FALSE;
        else
            pGetPolarityOutInfo->bPolarity = TRUE;
    }
    else
        return DXERR_GENERIC;

    return DX_OK;
}

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETCURRENTAUTOFLIPININFO  pGetCurrentAutoflipInInfo,
    PNVP_DDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    int nNotifyIdx;

    DBGPRINT(DBGTRACE,"GetCurrentAutoflip()");

    // get a handle to current VPE context (BUGBUG: assume index 0 for now !)
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
    // check out video
    if (pVPEContext->nNumVidSurf)
    {
        nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
        // check progress status of current surface
        if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
            pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
        else
            // assume it is the next surface then !
            pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].nNextSurfaceIdx);
    }

    pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
    // check out vbi
    if (pVPEContext->nNumVBISurf)
    {
        nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
        // check progress status of current surface
        if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
            pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
        else
            // assume it is the next surface then !
            pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].nNextSurfaceIdx);
    }

    return DX_OK;
}


/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETPREVIOUSAUTOFLIPININFO  pGetAutoflipInInfo,
    PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    int nNotifyIdx;

    DBGPRINT(DBGTRACE,"GetPreviousAutoflip()");

    // get a handle to current VPE context (BUGBUG: assume index 0 for now !)
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
    // check out video
    if (pVPEContext->nNumVidSurf)
    {
        nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
        // check progress status of current surface
        if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
            // if in progress, return index of previous surface
            pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)((pVPEContext->nVidSurfIdx == 0) ? (pVPEContext->nNumVidSurf - 1): (pVPEContext->nVidSurfIdx - 1));
        else
            // assume this is the "previous"ly autoflipped surface then !
            pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
    }

    pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
    // check out vbi
    if (pVPEContext->nNumVBISurf)
    {
        nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
        // check progress status of current surface
        if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
            // if in progress, return index of previous surface
            pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)((pVPEContext->nVBISurfIdx == 0) ? (pVPEContext->nNumVBISurf - 1): (pVPEContext->nVBISurfIdx - 1));
        else
            // assume this is the "previous"ly autoflipped surface then !
            pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
    }

    return DX_OK;
}

#ifdef VPEFSMIRROR

// ***************************************************************************
// [XW:10/02/2000] - start FS Mirror Functions
// ***************************************************************************
//
// CreateVideoPort -> R3: vppEnableFsMirror + R0: NVPFsMirrorEnable + NVPFsRegSurface
//        |
//        V 
//     VideoField0/1Notify -> R0: NVPProcessCommand -> NVPScheduleOverlayandFlip 
//
//                      -> NVPFsFlipSync -> NVPFsMirror -> NVPFsFlip
//        |
//        V
// DestoryVideoPort32 -> R3: vppDisableFsMirror + R0: NVPFsMirrorDisable

// {

/*
==============================================================================
    
    NVPFsRegSurface

    Description:    register a full screen mirror surface... with
                    attributes

    Date:           September 25,2000
    BUGBUG:         To Fix feature.. Update surfaces.. needs to calc dsdy?
    
    Author:         Xun Wang

==============================================================================
*/
VP_STATUS NVPFsRegSurface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    
    PNVP_CONTEXT        pVPEContext;
    PNVP_SURFACE_INFO   pSurface;
       
    DWORD               dwSurfId;
        
    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);    
    pSurface = &(pVPEContext->aFSMirrorSurfaceInfo[pCmdObj->dwSurfaceId]);

    dwSurfId = pCmdObj->dwSurfaceId;

    pSurface->pVidMem = pCmdObj->pSurfVidMem;
    pSurface->dwOffset = pCmdObj->dwSurfOffset;    
    pSurface->dwPitch = pCmdObj->dwSurfPitch;
    pSurface->dwHeight = pCmdObj->dwSurfHeight;
    pSurface->dwWidth = pCmdObj->dwSurfWidth;
    
    // point each to previous surface
    if (pCmdObj->dwSurfaceId) {
        pSurface->nPrevSurfaceIdx = dwSurfId - 1;
    }
       
    (pVPEContext->nNumFSSurf)++;

    // update the surface 0's information
    pVPEContext->aFSMirrorSurfaceInfo[0].nPrevSurfaceIdx = pVPEContext->nNumFSSurf - 1; 
        
    return NO_ERROR;
}

/*
==============================================================================
    
    NVPFsMirrorEnable

    Description:    Initialize everything we need for the fsmirror 

    Date:           September 25,2000
    
    Author:         Xun Wang

==============================================================================
*/
VP_STATUS NVPFsMirrorEnable(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    NV07C_ALLOCATION_PARAMETERS nv07cAllocParms;  // object creation params
    NV07A_ALLOCATION_PARAMETERS nv07aAllocParms;
    PNVP_CONTEXT pVPEContext;   // the actual vpe context
    Nv4ControlDma *pDmaChannel; // dma channel stuff
    U032 nvDmaCount;           
    //NVOS10_PARAMETERS evParam; // for event callbacks
    NvNotification *adacNotifiers;
    NvNotification *as2mNotifiers;

    NvNotification *asrfNotifiers;
    U032 bRecreateOverlay = FALSE;
    
    //U032 status;             // some local vars that I need

  
    // ******************************
    // Object Creation  
    // ******************************

    // Create LUT_DAC Object.. most important
    
    //#define NVP_VIDEO_LUT_DAC_SUBCHANNEL 3

    //#define NVP_SCALED_IMAGE_SUBCHANNEL  4

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    pVPEContext->regOverlayMode2 = pCmdObj->regOverlayMode2;
    pVPEContext->dwOverlayFSHead = pCmdObj->dwOverlayFSHead;
    pVPEContext->dwDesktopState = pCmdObj->dwDesktopState;
    if (pCmdObj->dwOverlayFSOvlHead != pVPEContext->dwOverlayFSOvlHead) {
        bRecreateOverlay = TRUE;
    }
    pVPEContext->dwOverlayFSOvlHead = pCmdObj->dwOverlayFSOvlHead;    
    
    if (bRecreateOverlay) {
    
        // stop overlay?
        // free old overlay
        rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_OVERLAY_OBJECT);
        
        // make new overlay        
        nv07aAllocParms.logicalHeadId = pVPEContext->dwOverlayFSOvlHead;
        if (rmNVPAlloc(pCmdObj->hClient,
                  NVP_VPE_CHANNEL,
                  NVP_OVERLAY_OBJECT,
                  NV10_VIDEO_OVERLAY,
                  &nv07aAllocParms) != 0)
        {
            DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Overlay Object ", NVP_OVERLAY_OBJECT);
            return ERROR_INVALID_PARAMETER;
        }        

        // initialize new overlay

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;


    NVP_DMAPUSH_CHECK_FREE_COUNT(8);

    // set overlay contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_NOTIFIES, NVP_OVERLAY_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(0), NVP_OVERLAY_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(1), NVP_OVERLAY_BUFFER_CONTEXT);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    }

    // head selection.  pVPEContext should be pointing to head2
    nv07cAllocParms.logicalHeadId = pVPEContext->dwOverlayFSHead;    

    // use lowest one possible for complete compatibility
    if (rmNVPAlloc(pVPEContext->hClient,
                   NVP_VPE_CHANNEL,
                   NVP_VIDEO_LUT_DAC_OBJ_ID,
                   NV15_VIDEO_LUT_CURSOR_DAC,
                   &nv07cAllocParms) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate video_lut_dac object ", NVP_VIDEO_LUT_DAC_OBJ_ID);
        return ERROR_INVALID_PARAMETER;
    }

    if (rmNVPAllocObject(pVPEContext->hClient,
                   NVP_VPE_CHANNEL,
                   NVP_SCALED_IMAGE_OBJ_ID, 
                   NV10_SCALED_IMAGE_FROM_MEMORY) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate scaled image object ", NVP_SCALED_IMAGE_OBJ_ID);
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate Scaled-image-buffer-context context dmas
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_SCALED_IMAGE_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->pFrameBuffer,
                        pVPEContext->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate video_lut_dac_video_buffer0_context context dmas
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->pFrameBuffer,
                        pVPEContext->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }
    
    // Allocate video_lut_dac_video_buffer1_context context dmas
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_VIDEO_LUT_DAC_FIELD1_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->pFrameBuffer,
                        pVPEContext->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // ******************************
    // Notifiers Set, Set Events to VPEContext..
    // ******************************

    //#define NVP_CLASS089_MAX_NOTIFIERS          1
    //#define NVP_CLASS07C_MAX_NOTIFIERS          9

    // Allocate s2m context notifer ID
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_SCALED_IMAGE_NOTIFIERS_CONTEXT_ID,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->as2mNotifiers,
                        (sizeof(NvNotification)*NVP_CLASS089_MAX_NOTIFIERS - 1) ) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate video_lut_cursor_dac context notifer ID
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_VIDEO_LUT_DAC_NOTIFIERS_CONTEXT_ID,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->adacNotifiers,
                        (sizeof(NvNotification)*NVP_CLASS07C_MAX_NOTIFIERS - 1) ) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for S2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

  
    
    // reset notifiers, scaled image from memory and video_lut_cursor_dac

    adacNotifiers = (NvNotification*)pVPEContext->adacNotifiers;
    as2mNotifiers = (NvNotification*)pVPEContext->as2mNotifiers;
    

    adacNotifiers[NV07C_NOTIFIERS_NOTIFY].status = 0;
    adacNotifiers[NV07C_NOTIFIERS_SET_IMAGE(0)].status = 0;
    adacNotifiers[NV07C_NOTIFIERS_SET_IMAGE(1)].status = 0;
    as2mNotifiers[NV089_NOTIFIERS_NOTIFY].status = 0;

    
    // Context Surface Creation and Setup

    asrfNotifiers = (NvNotification*)(&pVPEContext->asrfNotifiers[0]);
    asrfNotifiers[NV042_NOTIFIERS_NOTIFY].status = 0;

    if (rmNVPAllocObject(pVPEContext->hClient,
                   NVP_VPE_CHANNEL,
                   NVP_CONTEXT_SURFACE_2D_OBJECT, 
                   NV04_CONTEXT_SURFACES_2D) != 0)
    {
        DBGPRINT (DBGERROR, "cannot allocate context surface 2D object");
        return ERROR_INVALID_PARAMETER;
    }

    // context_surface_2d_notifiers_ID
    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_CONTEXT_SURFACE_2D_NOTIFIERS_CONTEXT_ID,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)asrfNotifiers,
                        (sizeof(NvNotification)*NVP_CLASS089_MAX_NOTIFIERS - 1) ) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for surf 2 d transfer Object");
        return ERROR_INVALID_PARAMETER;
    } 

    if (rmNVPAllocContextDma(
                        pVPEContext->hClient,
                        NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pVPEContext->pFrameBuffer,
                        pVPEContext->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot Allocate Context for Surface 2D object in memory");
        return ERROR_INVALID_PARAMETER;
    }


    // ******************************
    // Events stuff and Callbacks
    // ******************************
/*  
    // Create 2 callbacks for video_lut_cursor_dac
    evParam.hRoot = pVPEContext->hClient;
    evParam.hObjectParent = NVP_VIDEO_LUT_DAC_OBJ_ID;
    evParam.hObjectNew = NVP_VIDEO_LUT_DAC_EVENT0_ID;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV07C_NOTIFIERS_SET_IMAGE(0);
    NvU64_VALUE(evParam.hEvent) = (ULONG) NVPFsCRTCField0Notify;
    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for crtc 0");
        return ERROR_INVALID_PARAMETER;
    }

    evParam.hRoot = pVPEContext->hClient;
    evParam.hObjectParent = NVP_VIDEO_LUT_DAC_OBJ_ID;
    evParam.hObjectNew = NVP_VIDEO_LUT_DAC_EVENT1_ID;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV07C_NOTIFIERS_SET_IMAGE(1);
    NvU64_VALUE(evParam.hEvent) = (ULONG) NVPFsCRTCField1Notify;
    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for crtc 1");
        return ERROR_INVALID_PARAMETER;
    }
  */      
    // ******************************
    // DMA Channel - Object Setup
    // ******************************
    
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel); // get dma chan    
    nvDmaCount = pVPEContext->nvDmaCount;
    
    NVP_DMAPUSH_CHECK_FREE_COUNT(30); // Adjusted - check    

    // Setup NV04_VIDEO_LUT_CURSOR_DAC object
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_OBJECT, NVP_VIDEO_LUT_DAC_OBJ_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_CONTEXT_DMA_NOTIFIES, NVP_VIDEO_LUT_DAC_NOTIFIERS_CONTEXT_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_CONTEXT_DMA_IMAGE(0), NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_CONTEXT_DMA_IMAGE(1), NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT);

    // Setup NV04_CONTEXT_SURFACES_2D object
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_OBJECT, NVP_CONTEXT_SURFACE_2D_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_CONTEXT_DMA_NOTIFIES, NVP_CONTEXT_SURFACE_2D_NOTIFIERS_CONTEXT_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_CONTEXT_DMA_IMAGE_SOURCE, NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_CONTEXT_DMA_IMAGE_DESTIN, NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT);
    
    // Setup NV05_SCALED_IMAGE_FROM_MEMORY object 
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_OBJECT, NVP_SCALED_IMAGE_OBJ_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_CONTEXT_DMA_NOTIFIES, NVP_SCALED_IMAGE_NOTIFIERS_CONTEXT_ID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_CONTEXT_DMA_IMAGE, NVP_SCALED_IMAGE_BUFFER_CONTEXT);        
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_COLOR_FORMAT, NV089_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_CONTEXT_SURFACE, NVP_CONTEXT_SURFACE_2D_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_OPERATION,NV089_SET_OPERATION_SRCCOPY_AND);    
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_COLOR_CONVERSION,NV089_SET_COLOR_CONVERSION_DITHER);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    pVPEContext->nNumFSSurf     = 0;   // will be incremented later
    pVPEContext->nFSFlipSurfIdx = 1;   // should be 1
    pVPEContext->nFSMirrorIdx   = 0;   // should always be one behind
    pVPEContext->nFSFlipIdx     = 0;   // should be 0
    
    // Will only turn on if everything has passed..
    pVPEContext->dwFsMirrorOn = TRUE;  // turn this off at disable time

	// [XW] BUGBUG: 
	// Ideally we should return an Error, so we could deallocate everything Through Ring 3.
	// Right now, we'll just use the dwFsMirrorOn flag to make sure everything is *off* if fs mirror
	// is not turned on.
	
    return NO_ERROR;    
}

/*
==============================================================================
    
    NVPFsMirrorDisable

    Description:    UnInitialize everything we need for the fsmirror 

    Date:           October 2,2000
    
    Author:         Xun Wang

==============================================================================
*/
VP_STATUS NVPFsMirrorDisable(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    // free objects, events etc.
    PNVP_CONTEXT pVPEContext;
    
    DBGPRINT(DBGTRACE, "NVPFsMirrorDisable()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    pVPEContext->dwFsMirrorOn = FALSE;  // turn off at disable time
        
    // FCF: wait for notifiers to stop objects still running?
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_SCALED_IMAGE_BUFFER_CONTEXT);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_VIDEO_LUT_DAC_FIELD0_BUFFER_CONTEXT);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_VIDEO_LUT_DAC_FIELD1_BUFFER_CONTEXT);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_SCALED_IMAGE_NOTIFIERS_CONTEXT_ID);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_VIDEO_LUT_DAC_NOTIFIERS_CONTEXT_ID);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_CONTEXT_SURFACE_2D_NOTIFIERS_CONTEXT_ID);
    rmNVPFree(pVPEContext->hClient,  pCmdObj->dwDeviceId, NVP_CONTEXT_SURFACE_2D_BUFFER_CONTEXT);
    
    rmNVPFree(pVPEContext->hClient, NVP_VPE_CHANNEL, NVP_CONTEXT_SURFACE_2D_OBJECT);
    rmNVPFree(pVPEContext->hClient, NVP_VPE_CHANNEL, NVP_VIDEO_LUT_DAC_OBJ_ID);
    rmNVPFree(pVPEContext->hClient, NVP_VPE_CHANNEL, NVP_SCALED_IMAGE_OBJ_ID);
    
    return NO_ERROR;

}

/*
==============================================================================
    
    NVPFsFlip

    Description:    Flips to next FS Surface

    Date:           October 2,2000
    
    Author:         Xun Wang

==============================================================================
*/
VP_STATUS NVPFsFlip(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    int nFlipIdx;
    NVP_SURFACE_INFO* pSurface;
    DWORD dwOffset;
    DWORD dwFormat;
    Nv4ControlDma *pDmaChannel; // dma channel stuff
    U032 nvDmaCount;           
    NvNotification *adacNotifiers;
        
    nFlipIdx = pVPEContext->nFSFlipSurfIdx;
    nFlipIdx = pVPEContext->aFSMirrorSurfaceInfo[nFlipIdx].nPrevSurfaceIdx;       
    pSurface = &(pVPEContext->aFSMirrorSurfaceInfo[nFlipIdx]);
        
    
    dwOffset = pSurface->dwOffset;
    dwFormat = pSurface->dwPitch |(NV07C_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 31)| (NV07C_SET_IMAGE_FORMAT_WHEN_NOT_WITHIN_BUFFER << 20);

    // we are ready to start flipping
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel); // get dma chan    
    nvDmaCount = pVPEContext->nvDmaCount;

    // update the notifiers
    adacNotifiers = (NvNotification*)pVPEContext->adacNotifiers;
    if (adacNotifiers[NV07C_NOTIFIERS_SET_IMAGE(nFieldId)].status == NV07C_NOTIFICATION_STATUS_IN_PROGRESS) {
        return ERROR_INVALID_PARAMETER;
    }
    adacNotifiers[NV07C_NOTIFIERS_SET_IMAGE(nFieldId)].status = NV07C_NOTIFICATION_STATUS_IN_PROGRESS;

    NVP_DMAPUSH_CHECK_FREE_COUNT(6);

    // Setup NV04_VIDEO_LUT_CURSOR_DAC object
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_OBJECT, NVP_VIDEO_LUT_DAC_OBJ_ID);
    // context dmas should be set up .. so we just need a offset, and a format to start it going
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_IMAGE_OFFSET(nFieldId), dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07C_SET_IMAGE_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    return NO_ERROR;
}


/*
==============================================================================
    
    NVPFsMirror

    Description:    Full Screen Mirror Copy Function from buffer into next surface

    Date:           October 2,2000
    
    Author:         Xun Wang

==============================================================================
*/

VP_STATUS NVPFsMirror(
    PNVP_CONTEXT  pVPEContext,
    PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset
    DWORD         dwPitch,         // source pitch
    DWORD         dwWidth,         // source width
    DWORD         dwHeight,        // source height
    DWORD         dwIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags)
{
    // free objects, events etc.

    DWORD dwPointIn, dwSizeIn, dwPointOut, dwSizeOut;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwInFormat;
    DWORD dwClipPoint, dwClipSize;
    DWORD dwSurfId;
    DWORD dwPitch2d;
    DWORD dwSurfaceColorFormat;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;

    NVP_SURFACE_INFO* pSurface;
    NvNotification* as2mNotifiers;

	DBGPRINT(DBGTRACE, "NVPFsMirror");
   
    dwSurfId = pVPEContext->nFSFlipSurfIdx;
    pSurface = &(pVPEContext->aFSMirrorSurfaceInfo[dwSurfId]);
    
    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;  // << 3 insteed of << 4 because YUYV is 2 bytes wide
    
    if (IS_FIELD(dwFlags) && (dwFlags & VPP_BOB) && (dwFlags & VPP_INTERLEAVED) ) {
        // The problem is scaled_image does not accept -0.5 as a value
        // for Point In, therefore we must adjust dwPointIn to
        // 0 for EVEN fields 
        // 1 for ODD Fields
        // Therefore we must also adjust the SizeIn as well, and this
        // must be done before Delta Y is calculated
        if (dwFlags & VPP_EVEN) 
        {            
            dwPointIn += 0x00040000;
        } else 
        {
            dwPointIn += 0x00140000;
        }
        dwHeight = dwHeight - 1;    
    }
    
    dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));        
    
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    dwPointOut = asmMergeCoords(0,0); // outpoint on fulscreen mirror should be zero, for top of screen.    
    dwClipPoint = asmMergeCoords(0,0); // clippoint should be zerol;       

    
    // This stuff should be done elsewhere, and saved in the context,
    // In Efficient! [XW]
    // aspect ratio.. should be calculated somewhere... in init,
    // and attached to some kind of info struct
    // calculate the scaling ration in/out.
    

    if (dwFlags & VPP_INTERLEAVED) 
    {            
        if (dwFlags & VPP_EVEN) 
        { dwOffset += dwPitch; }
        dwPitch  <<= 1;
        dwHeight >>= 1;
        dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));        
     
    }

    dwInFormat = (ULONG)((ULONG) dwPitch | (ULONG)NV089_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16| (ULONG) NV089_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24);

    if (pSurface->dwWidth <= 1)
        dwDeltaX = 0x100000;
    else
    {
        dwDeltaX =  (dwWidth - 1) << 16;
        dwDeltaX /= (pSurface->dwWidth - 1);
        dwDeltaX <<=4 ;
    }
        
    if (pSurface->dwHeight <= 1)
        dwDeltaY = 0x100000;
    else
    {
        dwDeltaY =  (dwHeight - 1) << 16;
        dwDeltaY /= (pSurface->dwHeight - 1);
        dwDeltaY <<=4 ;
    }
        
    
    dwSizeOut = asmMergeCoords(pSurface->dwWidth, pSurface->dwHeight); // size of fullscreen grab out of surf info in struct
    dwClipSize = dwSizeOut;   
            
    dwSurfaceColorFormat = NV042_SET_COLOR_FORMAT_LE_A8R8G8B8;
    dwPitch2d = ( (pSurface->dwPitch << 16) | dwPitch );

    // program overlay to flip
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;

    // update the notifiers
    as2mNotifiers = (NvNotification*)pVPEContext->as2mNotifiers;
//    if (as2mNotifiers[NV089_NOTIFIERS_NOTIFY].status == NV089_NOTIFICATION_STATUS_IN_PROGRESS) {
//        return ERROR_INVALID_PARAMETER;
//    } // FCF: Why is the notifier never ready?

    as2mNotifiers[NV089_NOTIFIERS_NOTIFY].status = NV089_NOTIFICATION_STATUS_IN_PROGRESS;

    NVP_DMAPUSH_CHECK_FREE_COUNT(32); // Adjusted - check

    // Setup NV04_CONTEXT_SURFACES_2D object    
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_OBJECT, NVP_CONTEXT_SURFACE_2D_OBJECT);    
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_COLOR_FORMAT, dwSurfaceColorFormat);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_PITCH, dwPitch2d);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_OFFSET_SOURCE, dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV042_SET_OFFSET_DESTIN, pSurface->dwOffset);
    
    // Setup NV05_SCALED_IMAGE_FROM_MEMORY object
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_SET_OBJECT, NVP_SCALED_IMAGE_OBJ_ID);        
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_CLIP_POINT,dwClipPoint);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_CLIP_SIZE,dwClipSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_OUT_POINT,dwPointOut);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_OUT_SIZE,dwSizeOut);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_DS_DX,dwDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_DT_DY,dwDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_IN_SIZE,dwSizeIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_IN_FORMAT,dwInFormat);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_IN_OFFSET,dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV089_IMAGE_IN,dwPointIn);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    return NO_ERROR;
}

// }
// ***************************************************************************
// [XW:10/02/2000] - end FS Mirror Functions
// ***************************************************************************

// ***************************************************************************
// [XW:10/02/2000] - start FS Mirror callbacks section
// ***************************************************************************
// {

#ifdef _WIN32_WINNT



/*
==============================================================================
    
    NVPFsCRTCField0Notify

    Description:    callback function. for crtc buffer 0 

    Date:           October 2, 2000
    
    Author:         Xun Wang

==============================================================================
*/
void NVPFsCRTCField0Notify(PVOID pHwDeviceExtension)
{
    PNVP_CONTEXT pVPEContext;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;    
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    NVPFsFlip(pVPEContext,1);
}


/*
==============================================================================
    
    NVPFsCRTCField1Notify

    Description:    callback function. for crtc buffer 1 

    Date:           October 2, 2000
    
    Author:         Xun Wang

==============================================================================
*/
void NVPFsCRTCField1Notify(PVOID pHwDeviceExtension)
{
    PNVP_CONTEXT pVPEContext;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    
    NVPFsFlip(pVPEContext,0);
}

#else


/*
==============================================================================
    
    NVPFsCRTCField0Notify

    Description:    callback function. for crtc buffer 0 

    Date:           October 2, 2000
    
    Author:         Xun Wang

==============================================================================
*/
void NVPFsCRTCField0Notify()
{
    PNVP_CONTEXT pVPEContext;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)&nvpeDevExtension;    
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    NVPFsFlip(pVPEContext,1);
}


/*
==============================================================================
    
    NVPFsCRTCField1Notify

    Description:    callback function. for crtc buffer 1 

    Date:           October 2, 2000
    
    Author:         Xun Wang

==============================================================================
*/
void NVPFsCRTCField1Notify()
{
    PNVP_CONTEXT pVPEContext;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)&nvpeDevExtension;
    pVPEContext = &(pHwDevExt->avpContexts[0]);
    
    NVPFsFlip(pVPEContext,0);
}



#endif //_WIN32_WINNT

//#endif // VPE_FSMIRROR

// }
// ***************************************************************************
// [XW:10/02/2000] - end FS Mirror callbacks section
// ***************************************************************************

#endif


/*
==============================================================================
    
    NVP3Initialize

    Description:    Initializes the NV video port. Creates channels and DMA
                    contexts. Create Video and VBI objects.
                    NV3 version uses PIO channel

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVP3Initialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
#ifdef NVP_NV3
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    NVOS10_PARAMETERS evParam;
    int nFreeCount;
    U032 status;
    NVOS09_PARAMETERS ntfParam;
    Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);

//////////// HACK
    //cur_debuglevel = 1;
    g_bFlip = FALSE;
///////////

    DBGPRINT(DBGTRACE,"NVP3Initialize()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    // initialize context
    pVPEContext->pNVPChannel = (ULONG) pNVPChannel; // keep a copy of the pio channel pointer
    pVPEContext->nvDmaFifo = NULL;
    pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
    pVPEContext->hClient = pCmdObj->hClient;
      pVPEContext->pFrameBuffer = pCmdObj->pFrameBuffer;
      pVPEContext->dwFBLen = pCmdObj->dwFBLen;
    pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
    pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
    pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
    pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
    pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
    pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
    pVPEContext->nNumVidSurf = 0;
    pVPEContext->nNumVBISurf = 0;
    pVPEContext->dwVPState = NVP_STATE_STOPPED;
    pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
    pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
    pVPEContext->nCurTransferIdx = NVP_EOQ;
    pVPEContext->nLastTransferIdx = NVP_EOQ;
    pVPEContext->nRecentTransferIdx = NVP_EOQ;
    pVPEContext->nNumTransfer = 0;
    pVPEContext->bxfContextCreated = FALSE;
    pVPEContext->bxfContextFlushed = FALSE;
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    // alloc external decoder object
    if (RmAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_EXTERNAL_DECODER_OBJECT,
                NV03_EXTERNAL_VIDEO_DECODER) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "Cannot allocate External Decoder Object ", NVP_EXTERNAL_DECODER_OBJECT);
        return FALSE;
    }

    // allocate transfer object (used for vbi and video capture)
    if (RmAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_M2M_OBJECT,
                NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "Cannot allocate Mem to mem transfer Object ", NVP_M2M_OBJECT);
        return FALSE;
    }

    // allocate the transfer FROM context
    if (RmAllocContextDma(
                        pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate notifiers for M2M transfer Object");
        return FALSE;
    }

    // allocate a notify context for transfer object
    if (RmAllocContextDma(
                        pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0,  //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate notifiers for M2M transfer Object");
        return FALSE;
    }
    
    // allocate a notify context for external decoder
    if (RmAllocContextDma(
                    pCmdObj->hClient,
                    NVP_EXTERNAL_DECODER_NOTIFIER,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    (U032)(pVPEContext->avpNotifiers),
                    (sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate notifiers for external decoder object");
        return FALSE;
    }

    // context DMA for video field0
    if (RmAllocContextDma(
                pCmdObj->hClient,
                NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for video field0");
        return FALSE;
    }

    // context DMA for video field1 
    if (RmAllocContextDma(
                pCmdObj->hClient,
                NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for video field1");
        return FALSE;
    }
    
    // context DMA for video field0
    if (RmAllocContextDma(
                pCmdObj->hClient,
                NVP_VBI_FIELD0_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for VBI field0");
        return FALSE;
    }

    // context DMA for video field1
    if (RmAllocContextDma(
                pCmdObj->hClient,
                NVP_VBI_FIELD1_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for VBI field1");
        return FALSE;
    }

    //CHECK_FREE_COUNT(pNVPChannel,10*5);
    nFreeCount = NvGetFreeCount(pNVPChannel, 0);
    while (nFreeCount < 13*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pNVPChannel, 0);
    }           
    pVPEContext->nFreeCount = nFreeCount - (13*4);

    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // transfer object setup
    pNVPChannel->subchannel[5].SetObject  = NVP_M2M_OBJECT;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = NVP_M2M_NOTIFIER;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = NVP_M2M_FROM_CONTEXT;
    
    // make sure decoder object is in the channel....
    pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = NVP_EXTERNAL_DECODER_NOTIFIER;

    // plug in our buffer contexts
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] = NVP_VIDEO_FIELD0_BUFFER_CONTEXT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] = NVP_VIDEO_FIELD1_BUFFER_CONTEXT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]   = NVP_VBI_FIELD0_BUFFER_CONTEXT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]   = NVP_VBI_FIELD1_BUFFER_CONTEXT;
    
    // NB: we don't want to launch any captures at this point

    // setup the transfer callback
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_M2M_OBJECT;
    evParam.hObjectNew = NVP_M2M_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) NVPTransferNotify;
    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for m2m transfer 0");
        return FALSE;
    }

    // setup fields callbacks
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) VideoField0Notify;

    // video field0
    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for video field 0");
        return FALSE;
    }

    // video field1
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) VideoField1Notify;

    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for video field 1");
        return FALSE;
    }

    // vbi field0
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) VBIField0Notify;

    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for VBI field 0");
        return FALSE;
    }
            
    // vbi field1
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
    NvU64_VALUE(evParam.hEvent) = (NvU64_VALUE_T) VBIField1Notify;

    status = Nv01AllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "Cannot create callback for VBI field 1");
        return FALSE;
    }
#endif // NVP_NV3
    return NO_ERROR;
}


/*
==============================================================================
    
    NVPInitialize

    Description:    Initializes the NV video port. Creates channels and DMA
                    contexts. Create Video and VBI objects.
                    DMA push buffer version (NV ver >= 0x04)

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPInitialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    NvNotification *aovNotifiers;
    U032 dwOvObj;
    NVOS10_PARAMETERS evParam;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    U032 i, status;

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pCmdObj->dwChipId) <= NVP_CHIP_VER_03)
        return NVP3Initialize(pHwDevExt, pCmdObj);

//////////// HACK
    //cur_debuglevel = 1;
    g_bFlip = FALSE;
///////////

    DBGPRINT(DBGTRACE, "NVPInitialize()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // already initialized... should rather uninitialize and re-initialize with new data !!!
    //transfer check to ring3 NVPInitialize
#if 0
	if (pVPEContext->nvDmaFifo != NULL)	
    {
          DBGPRINT(DBGERROR, "already initialized !");
          return NO_ERROR;
    }
#endif

    // FS Mirror variable initialization
    pVPEContext->MultiMon = pCmdObj->MultiMon;
    pVPEContext->regOverlayMode = pCmdObj->regOverlayMode;
    pVPEContext->regOverlayMode2 = pCmdObj->regOverlayMode2;
    pVPEContext->regOverlayMode3 = pCmdObj->regOverlayMode3;
    pVPEContext->dwFsMirrorOn = 0;
    pVPEContext->nNumFSSurf = 0;
    pVPEContext->nFSFlipSurfIdx = 0;
    pVPEContext->nFSMirrorIdx = 0;
    pVPEContext->nFSFlipIdx = 0;
    pVPEContext->dwOverlayFSHead = 0;
    pVPEContext->dwOverlayFSOvlHead = 0;

    // initialize context
    //pVPEContext->pNVPChannel = (ULONG) 0;
    pVPEContext->dwChipId = pCmdObj->dwChipId;
    pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
    pVPEContext->hClient = pCmdObj->hClient;
    pVPEContext->pFrameBuffer = pCmdObj->pFrameBuffer;
    pVPEContext->dwFBLen = pCmdObj->dwFBLen;
    pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
    pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
    pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
    pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
    pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
    pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
    pVPEContext->nNumVidSurf = 0;
    pVPEContext->nNumVBISurf = 0;
    pVPEContext->dwVPState = NVP_STATE_STOPPED;
    pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
    pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
    pVPEContext->nCurTransferIdx = NVP_EOQ;
    pVPEContext->nLastTransferIdx = NVP_EOQ;
    pVPEContext->nRecentTransferIdx = NVP_EOQ;
    pVPEContext->nNumTransfer = 0;
    pVPEContext->bxfContextCreated = FALSE;
    pVPEContext->bxfContextFlushed = FALSE;
    for (i = 0; i < NVP_MAX_SYNC_EVENTS; i++)
    {
        pVPEContext->hNVPSyncEvent[i] = (PVOID)(pCmdObj->hNVPSyncEvent[i]);
    }

    pVPEContext->nvDmaFifo = NULL;
    pVPEContext->DmaPushBufTotalSize = 32*1024*4;   // 32k DWORDs

    if (osNVPAllocDmaBuffer((PVOID)pHwDevExt, pVPEContext->DmaPushBufTotalSize, (PVOID *)&(pVPEContext->nvDmaFifo)))
        return ERROR_INVALID_PARAMETER;

    if (rmNVPAllocContextDma(pCmdObj->hClient,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_ONLY,
                            0, // selector
                            (U032)(pVPEContext->nvDmaFifo),
                            pVPEContext->DmaPushBufTotalSize - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate Context Dma for PushBuffer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // Allocate the DMA push buffer ERROR notifier
    if (rmNVPAllocContextDma(  pCmdObj->hClient,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
                            0, // selector
                            (U032)(&(pVPEContext->DmaPushBufErrNotifier[0])),
                            sizeof(NvNotification) - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate PushBuffer notifier");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate DMA channel here !
    if (rmNVPAllocChannelDma(  pCmdObj->hClient,
                            pCmdObj->dwDeviceId,
                            NVP_VPE_CHANNEL,
                            NV4_CHANNEL_DMA,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            0,
                            (PVOID)&(pVPEContext->pDmaChannel)) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Dma Channel ", NVP_VPE_CHANNEL);
        return ERROR_INVALID_PARAMETER;
    }

    // alloc external decoder object
    if (rmNVPAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_EXTERNAL_DECODER_OBJECT,
                NV03_EXTERNAL_VIDEO_DECODER) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate External Decoder Object ", NVP_EXTERNAL_DECODER_OBJECT);
        return ERROR_INVALID_PARAMETER;
    }

    // allocate transfer object (used for vbi and video capture)
    if (rmNVPAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_M2M_OBJECT,
                NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Mem to mem transfer Object ", NVP_M2M_OBJECT);
        return ERROR_INVALID_PARAMETER;
    }

    dwOvObj = (pCmdObj->dwChipId < NV_DEVICE_VERSION_10) ? NV04_VIDEO_OVERLAY : NV10_VIDEO_OVERLAY;

    // If not MultiMon, use the old way to make an overlay
    // Otherwise, specify which head to use.
    if (!pVPEContext->MultiMon) {
    // alloc overlay object
    if (rmNVPAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_OVERLAY_OBJECT,
                dwOvObj) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Overlay Object ", NVP_OVERLAY_OBJECT);
        return ERROR_INVALID_PARAMETER;
    }
    } else {
        NV07A_ALLOCATION_PARAMETERS nv07aAllocParms;

        nv07aAllocParms.logicalHeadId = pVPEContext->dwOverlayFSOvlHead;
        if (rmNVPAlloc(pCmdObj->hClient,
                  NVP_VPE_CHANNEL,
                  NVP_OVERLAY_OBJECT,
                  NV10_VIDEO_OVERLAY,
                  &nv07aAllocParms) != 0)
        {
            DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate Overlay Object ", NVP_OVERLAY_OBJECT);
            return ERROR_INVALID_PARAMETER;
        }
    }


    // alloc DVD subpicture object
    if (rmNVPAllocObject(
                pCmdObj->hClient,
                NVP_VPE_CHANNEL,
                NVP_DVD_SUBPICTURE_OBJECT,
                NV4_DVD_SUBPICTURE) != 0)
    {
        DBG_PRINT_STRING_VALUE(DBGERROR, "cannot allocate DVD subpicture Object ", NVP_DVD_SUBPICTURE_OBJECT);
        return ERROR_INVALID_PARAMETER;
    }

    // allocate the transfer FROM context
    if (rmNVPAllocContextDma(
                        pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for M2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate a notify context for transfer object
    if (rmNVPAllocContextDma(
                        pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0,  //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for M2M transfer Object");
        return ERROR_INVALID_PARAMETER;
    }
    
    // allocate a notify context for external decoder
    if (rmNVPAllocContextDma(
                    pCmdObj->hClient,
                    NVP_EXTERNAL_DECODER_NOTIFIER,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    (U032)(pVPEContext->avpNotifiers),
                    (sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "cannot allocate notifiers for external decoder object");
        return ERROR_INVALID_PARAMETER;
    }

    // context DMA for video field0
    if (rmNVPAllocContextDma(
                pCmdObj->hClient,
                NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate context DMA for video field0");
        return ERROR_INVALID_PARAMETER;
    }

    // context DMA for video field1 
    if (rmNVPAllocContextDma(
                pCmdObj->hClient,
                NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "Cannot allocate context DMA for video field1");
        return ERROR_INVALID_PARAMETER;
    }
    
    // context DMA for video field0
    if (rmNVPAllocContextDma(
                pCmdObj->hClient,
                NVP_VBI_FIELD0_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate context DMA for VBI field0");
        return ERROR_INVALID_PARAMETER;
    }

    // context DMA for video field1
    if (rmNVPAllocContextDma(
                pCmdObj->hClient,
                NVP_VBI_FIELD1_BUFFER_CONTEXT,
                NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
                0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                0, // selector
                (U032) (pCmdObj->pFrameBuffer),
                pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "cannot allocate context DMA for VBI field1");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate a context for overlay object
    if (rmNVPAllocContextDma(
                        pCmdObj->hClient,
                        NVP_OVERLAY_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0,  //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate dma context for overlay buffer0");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate a context for DVD subpicture object
    if (rmNVPAllocContextDma(
                        pCmdObj->hClient,
                        NVP_DVD_SUBPICTURE_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0,  //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
    {
        DBGPRINT(DBGERROR, "cannot allocate dma context for DVD subpicture Object");
        return ERROR_INVALID_PARAMETER;
    }

    // allocate a notify context for overlay notifiers
    if (rmNVPAllocContextDma(
                    pCmdObj->hClient,
                    NVP_OVERLAY_NOTIFIER,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    (U032)(pVPEContext->aovNotifiers),
                    (sizeof(NvNotification)*NVP_CLASS07A_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate notifiers for external decoder object");
        return ERROR_INVALID_PARAMETER;
    }

    // reset media port notifiers
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // reset overlay notifiers
    aovNotifiers = (NvNotification *) (pVPEContext->aovNotifiers);
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(0)].status = 0;
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(1)].status = 0;

    pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = (U032) (pVPEContext->aovNotifiers);

    // init Dma channel pointers
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    pDmaChannel->Put = 0;
    nvDmaCount = 0;

    // set m2m object context
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_NOTIFIES, NVP_M2M_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_IN, NVP_M2M_FROM_CONTEXT);

    // make sure decoder object is in the channel....
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_NOTIFIES, NVP_EXTERNAL_DECODER_NOTIFIER);
    // plug in our buffer contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(0), NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(1), NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(0), NVP_VBI_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(1), NVP_VBI_FIELD1_BUFFER_CONTEXT);

    // set overlay contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_NOTIFIES, NVP_OVERLAY_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(0), NVP_OVERLAY_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(1), NVP_OVERLAY_BUFFER_CONTEXT);

    // same for DVD subpicture context
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT, NVP_DVD_SUBPICTURE_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_IN, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_OUT, NVP_DVD_SUBPICTURE_CONTEXT);

    pVPEContext->nvDmaCount = nvDmaCount;
    pDmaChannel->Put = nvDmaCount << 2;

    // NB: we don't want to launch any captures at this point

    // setup the transfer callback
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_M2M_OBJECT;
    evParam.hObjectNew = NVP_M2M_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
    NvU64_VALUE(evParam.hEvent) = (ULONG) NVPTransferNotify;
    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for m2m transfer 0");
        return ERROR_INVALID_PARAMETER;
    }

    // setup fields callbacks
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
    NvU64_VALUE(evParam.hEvent) = (ULONG) VideoField0Notify;

    // video field0
    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for video field 0");
        return ERROR_INVALID_PARAMETER;
    }

    // video field1
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
    NvU64_VALUE(evParam.hEvent) = (ULONG) VideoField1Notify;

    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for video field 1");
        return ERROR_INVALID_PARAMETER;
    }

    // vbi field0
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
    NvU64_VALUE(evParam.hEvent) = (ULONG) VBIField0Notify;

    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for VBI field 0");
        return ERROR_INVALID_PARAMETER;
    }
            
    // vbi field1
    evParam.hRoot = pCmdObj->hClient;
    evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
    evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
    evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
    evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
    NvU64_VALUE(evParam.hEvent) = (ULONG) VBIField1Notify;

    status = rmNVPAllocEvent(&evParam);
    if (status)
    {
        DBGPRINT(DBGERROR, "cannot create callback for VBI field 1");
        return ERROR_INVALID_PARAMETER;
    }

    // media port sync event
    if (pCmdObj->hNVPSyncEvent[0])
    {
        // field 0
        evParam.hRoot = pCmdObj->hClient;
        evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
        evParam.hObjectNew = NVP_VSYNC_EVENT0;
        evParam.hClass = NV01_EVENT_WIN32_EVENT;
        evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
        NvU64_VALUE(evParam.hEvent) = (ULONG) pCmdObj->hNVPSyncEvent[0];

        status = rmNVPAllocEvent(&evParam);
        if (status)
        {
            DBGPRINT(DBGERROR, "cannot set event for video field 0");
            return ERROR_INVALID_PARAMETER;
        }

        // field 1 (use same event for both fields)
        evParam.hRoot = pCmdObj->hClient;
        evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
        evParam.hObjectNew = NVP_VSYNC_EVENT1;
        evParam.hClass = NV01_EVENT_WIN32_EVENT;
        evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
        NvU64_VALUE(evParam.hEvent) = (ULONG) pCmdObj->hNVPSyncEvent[0];

        status = rmNVPAllocEvent(&evParam);
        if (status)
        {
            DBGPRINT(DBGERROR, "cannot set event for video field 0");
            return ERROR_INVALID_PARAMETER;
        }

    }

    // media port sync event
    if (pCmdObj->hNVPSyncEvent[1] && pCmdObj->hNVPSyncEvent[2])
    {
        // field 0
        evParam.hRoot = pCmdObj->hClient;
        evParam.hObjectParent = NVP_OVERLAY_OBJECT;
        evParam.hObjectNew = NVP_OV_SYNC_EVENT0;
        evParam.hClass = NV01_EVENT_WIN32_EVENT;
        evParam.index = NV07A_NOTIFIERS_SET_OVERLAY(0);
        NvU64_VALUE(evParam.hEvent) = (ULONG) pCmdObj->hNVPSyncEvent[1];

        status = rmNVPAllocEvent(&evParam);
        if (status)
        {
            DBGPRINT(DBGERROR, "cannot set event for video field 0");
            return ERROR_INVALID_PARAMETER;
        }

        // field 1
        evParam.hRoot = pCmdObj->hClient;
        evParam.hObjectParent = NVP_OVERLAY_OBJECT;
        evParam.hObjectNew = NVP_OV_SYNC_EVENT1;
        evParam.hClass = NV01_EVENT_WIN32_EVENT;
        evParam.index = NV07A_NOTIFIERS_SET_OVERLAY(1);
        NvU64_VALUE(evParam.hEvent) = (ULONG) pCmdObj->hNVPSyncEvent[2];

        status = rmNVPAllocEvent(&evParam);
        if (status)
        {
            DBGPRINT(DBGERROR, "cannot set event for video field 0");
            return ERROR_INVALID_PARAMETER;
        }

    }

	//alloc m2m dst heap for dma xfer -osNVPAllocDmaBuffer naming is ambiguous, should change to allocheap
	if (osNVPAllocDmaBuffer((PVOID)pHwDevExt, BUFSIZE, (PVOID *)&(pVPEContext->pSysBuf)))
        return ERROR_INVALID_PARAMETER;

	if(!(pVPEContext->pSysBuf)){
		DBGPRINT(DBGERROR, "Unable to alloc Sys Buf\n");
		return ERROR_INVALID_PARAMETER;
	}

	//alloc context dma for m2m dst heap
	if (rmNVPAllocContextDma(
                    pVPEContext->hClient,
                    NVP_M2M_CONTEXT,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    (U032)(pVPEContext->pSysBuf),
                    BUFSIZE-1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate mem 2 mem context");
        return DXERR_GENERIC;
    }

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPUninitialize

    Description:    Free channels, DMA contexts and objects created by a
                    previous call to NVPInitialize

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPUninitialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;

    DBGPRINT(DBGTRACE, "NVPUninitialize()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    //NVPFlushChannel(pVPEContext);

    // free allocated resources
    ////////// shouldn't we wait for completion (either grab of transfer ?!)
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_EVENT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_EVENT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_EVENT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_EVENT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_EXTERNAL_DECODER_NOTIFIER);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_BUFFER_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DVD_SUBPICTURE_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_NOTIFIER);
    // free transfer object resources
    //if (pVPEContext->bxfContextCreated)
        rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_CONTEXT);

	// free m2m dst heap
	if(pVPEContext->pSysBuf){
		osNVPReleaseDmaBuffer((PVOID)(pHwDevExt), (PVOID)(pVPEContext->pSysBuf));
	}

    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_NOTIFIER);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_FROM_CONTEXT);
    rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_EVENT);
    rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_M2M_OBJECT);

    if (pVPEContext->hNVPSyncEvent[0])
    {
        rmNVPFree(pCmdObj->hClient, NVP_EXTERNAL_DECODER_OBJECT, NVP_VSYNC_EVENT0);
        rmNVPFree(pCmdObj->hClient, NVP_EXTERNAL_DECODER_OBJECT, NVP_VSYNC_EVENT1);
        pVPEContext->hNVPSyncEvent[0] = NULL;
    }

    if (pVPEContext->hNVPSyncEvent[1] || pVPEContext->hNVPSyncEvent[2])
    {
        rmNVPFree(pCmdObj->hClient, NVP_OVERLAY_OBJECT, NVP_OV_SYNC_EVENT0);
        rmNVPFree(pCmdObj->hClient, NVP_OVERLAY_OBJECT, NVP_OV_SYNC_EVENT1);
        pVPEContext->hNVPSyncEvent[1] = NULL;
        pVPEContext->hNVPSyncEvent[2] = NULL;
    }

    rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_EXTERNAL_DECODER_OBJECT);
    rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_OVERLAY_OBJECT);
    rmNVPFree(pCmdObj->hClient, NVP_VPE_CHANNEL, NVP_DVD_SUBPICTURE_OBJECT);

    if (pVPEContext->nvDmaFifo != NULL)
    {
        rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VPE_CHANNEL);
        rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_FROM_MEMORY_PUSHBUF);
        rmNVPFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_PUSHBUF_ERROR_NOTIFIER);
        osNVPReleaseDmaBuffer((PVOID)(pHwDevExt), (PVOID)(pVPEContext->nvDmaFifo));
    }

    pVPEContext->pOverlayChannel = 0;
    pVPEContext->nvDmaFifo = NULL;
    pVPEContext->pDmaChannel = NULL;

    pVPEContext->nvpOverlay.dwOverlayBufferIndex = NVP_UNDEF;

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPUpdate

    Description:    Updates the NV video port data.

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPUpdate(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_OVERLAY pnvOverlay;
    DWORD i, dwFlipStatus;

    DBGPRINT(DBGTRACE, "NVPUpdate()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// get decoder height
	pVPEContext->dwDecoderHeight = pCmdObj->dwInHeight;

    pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;
    pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
    {
        DBGPRINT(DBGERROR, "NVPUpdate() exceeded number of extra 422 surfaces");
        return ERROR_INVALID_PARAMETER;
    }

    // get a pointer to the overlay object in VPE context
    pnvOverlay = &(pVPEContext->nvpOverlay);

    // update overlay info: extra 422 surfaces used for prescaling
    pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
    pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
    pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < pCmdObj->dwExtra422NumSurfaces; i++)
    {
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i]; // extra memory space used for prescaling
    }

    // just in case flipping was turned on before starting mediaport, turn it off only for the first 2 manual flips
    dwFlipStatus = g_bFlip;
    g_bFlip = FALSE;

    // start video grabbing here if not already done in NVPStart
    if ((pVPEContext->nNumVidSurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO))
    {
        // start VBI at the same time as video if vbi is not already enabled !
        if (pVPEContext->nNumVBISurf > 0)
        {
            // is it already started, then no need to do it again...
            if (!(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
            {
                (pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
                pVPEContext->nNextVBISurfId = 1;
            }
            pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO | NVP_STATE_STARTED_VBI);
        }
        else
            pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO);
        
        (pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
        // kick off VP
        pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
#ifdef _NVP_TEST_NEXT_FIELD
            g_nIntCounter = 0;
            g_nNextFieldId = 0;
#endif
        // we OR 0x80 to tell function this is not a notifier calling !
        NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
        NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
    }
    // start VBI grabbing here if not already done in NVPStart
    else if ((pVPEContext->nNumVBISurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
    {
        // if video already started, then only enable VBI state flag
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
        {
            pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
        }
        else
        {
            pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VBI);
            (pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
            pVPEContext->nNextVBISurfId = 1;
            // kick off VP
            NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
            NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
        }
    }

    // restore overlay flipping status
    g_bFlip = dwFlipStatus;

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPStart

    Description:    Tells the NV video port to start grabbing video

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPStart(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_OVERLAY pnvOverlay;
    DWORD i, dwFlipStatus;

    DBGPRINT(DBGTRACE, "NVPStart()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // aleady started ?! it must be an UpdateVideo then...
    if (pVPEContext->dwVPState & NVP_STATE_STARTED)
        return NVPUpdate(pHwDevExt, pCmdObj);

	// get decoder height
	pVPEContext->dwDecoderHeight = pCmdObj->dwInHeight;

    // current
    pVPEContext->nVidSurfIdx = 0;
    pVPEContext->nVBISurfIdx = 0;
    // next in the list
    pVPEContext->nNextVideoSurfId = 0;
    pVPEContext->nNextVBISurfId = 0;

    // update overlay channel pointer !
    /////// NVPUpdate() must be the place for this !?
    pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

    pVPEContext->dwVPState = NVP_STATE_STARTED;
    pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
    {
        DBGPRINT(DBGERROR, "NVPStart() exceeded number of extra 422 surfaces ");
        return ERROR_INVALID_PARAMETER;
    }

    // get a pointer to the overlay object in VPE context
    pnvOverlay = &(pVPEContext->nvpOverlay);

    // update overlay info: extra 422 surfaces used for prescaling
    pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
    pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
    pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < pCmdObj->dwExtra422NumSurfaces; i++)
    {
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i]; // extra memory space used for prescaling
    }

    // just in case flipping was turned on before starting mediaport, turn it off only for the first 2 manual flips
    dwFlipStatus = g_bFlip;
    g_bFlip = FALSE;

    // make a cyclic chain with surfaces
    if (pVPEContext->nNumVidSurf > 0)
    {
        pVPEContext->dwVPState |= NVP_STATE_STARTED_VIDEO;
        (pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
        // kick off VP
        pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
        // before kicking off the media port, check out VBI setting
        if (pVPEContext->nNumVBISurf > 0)
        {
            pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
            (pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
            pVPEContext->nNextVBISurfId = 1;
        }
#ifdef _NVP_TEST_NEXT_FIELD
            g_nIntCounter = 0;
            g_nNextFieldId = 0;
#endif

        // we OR 0x80 to tell function this is not a notifier calling !
        NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
        NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
    }
    else if (pVPEContext->nNumVBISurf > 0)
    {
        pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
        (pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
        pVPEContext->nNextVBISurfId = 1;
        // kick off VP
        NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
        NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
    }

    // restore overlay flipping status
    g_bFlip = dwFlipStatus;
    
    return NO_ERROR;
}

/*
==============================================================================
    
    NVP3Stop

    Description:    Tells the NV video port to stop grabbing. PIO channel
                    version

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVP3Stop(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);
    PNVP_CONTEXT pVPEContext;
    NvNotification *avpNotifiers;
    NVOS09_PARAMETERS ntfParam;
    U032 i = 0;

    DBGPRINT(DBGTRACE, "NVP3Stop()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    // aleady stopped ?!
    if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
        return NO_ERROR;
    else
        pVPEContext->dwVPState = NVP_STATE_STOPPED;

    g_bFlip = FALSE;

    pVPEContext->pNVPChannel = (ULONG) pNVPChannel; // get a copy of the pio channel pointer
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    // tell VP to stop grabbing !
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage = 0;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;

    ntfParam.hObjectParent = pCmdObj->dwDeviceId;
#define NVP_NOTIFY_TIMEOUT 100000
    // wait for the last few notifies to show up...
    while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
             (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
           (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           (i < NVP_NOTIFY_TIMEOUT)))
    {
        i++;
        //RmInterrupt(&ntfParam);
    }

#ifdef _STOP_OVERLAY
    // reset surfaces counters
    pVPEContext->nNumVBISurf = 0;
    pVPEContext->nNumVidSurf = 0;
#endif

#endif // NVP_NV3
    return NO_ERROR;
}

/*
==============================================================================
    
    NVPShutDownMediaPort

    Description:    shuts down media port engine

    Date:           May 24, 2000
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPShutDownMediaPort(PNVP_CONTEXT pVPEContext)
{
    NvNotification *avpNotifiers;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    U032 i;

    DBGPRINT(DBGTRACE, "NVPShutDownMediaPort()");

    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    // channel
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;

    // stop grabbing !
    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    //if (pCmdObj->dwStopStrm & NVP_STOP_VIDEO)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_IMAGE , 0);
    //if (pCmdObj->dwStopStrm & NVP_STOP_VBI)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_VBI , 0);
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

#define NVP_NOTIFY_TIMEOUT 100000
    i = 0;
    // wait for the last few notifies to show up...
    while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
             (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
           (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           (i < NVP_NOTIFY_TIMEOUT)))
    {
        i++;
    }

    // timed-out...
    if (i >= NVP_NOTIFY_TIMEOUT)
        DBGPRINT(DBGERROR, "waiting for MediaPort notifiers timed-out....");

    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // clear/reset sync event
    osNVPClearEvent((PVOID) pVPEContext->hNVPSyncEvent[0]);

    pVPEContext->dwVPState = NVP_STATE_STOPPED;

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPShutDownOverlay

    Description:    shuts down overlay engine

    Date:           May 24, 2000
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPShutDownOverlay(PNVP_CONTEXT pVPEContext)
{
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    NvNotification *pPioFlipOverlayNotifier;
    U032 i;

    DBGPRINT(DBGTRACE, "NVPShutDownOverlay()");

    // channel
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;

    // stop overlay engine
    if (pDmaChannel && g_bFlip)
    {
        g_bFlip = FALSE;

        if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
        {
            osNVPClearEvent(pVPEContext->hNVPSyncEvent[1]);
            osNVPClearEvent(pVPEContext->hNVPSyncEvent[2]);
        }

        // reset notifiers
        pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;

        // stop overlay
        NVP_DMAPUSH_CHECK_FREE_COUNT(6);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS); //NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS); //NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE
        pDmaChannel->Put = nvDmaCount << 2;
        pVPEContext->nvDmaCount = nvDmaCount;

        // wait here only if not waiting on events in ring3 !!!
        if ((pVPEContext->hNVPSyncEvent[1] == NULL) || (pVPEContext->hNVPSyncEvent[2] == NULL))
        {
            i = 0;
            while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                i++;

            // timed-out...
            if (i >= NVP_VPP_TIME_OUT)
                DBGPRINT(DBGERROR, "waiting for overlay flip notifiers timed-out....");
        }

        pPioFlipOverlayNotifier[1].status = 0;
        pPioFlipOverlayNotifier[2].status = 0;
    }
    // don't let ring3 wait for nothing !
    else if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
    {
        osNVPSetEvent(pVPEContext->hNVPSyncEvent[1]);
        osNVPSetEvent(pVPEContext->hNVPSyncEvent[2]);
    }

    return NO_ERROR;
}


/*
==============================================================================
    
    NVPStop

    Description:    Tells the NV video port to stop grabbing

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPStop(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    //Nv03ChannelPio *pOvChannel;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    NvNotification *pPioFlipOverlayNotifier;

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // overlay channel
    //pOvChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);   // get a pointer to the overlay channel

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
        return NVP3Stop(pHwDevExt, pCmdObj);

    DBGPRINT(DBGTRACE, "NVPStop()");

    // aleady stopped ?!
    if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
        return NO_ERROR;
    else
        pVPEContext->dwVPState = NVP_STATE_STOPPED;

    // channel
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;

#ifdef _STOP_OVERLAY
    // stop overlay engine
    if (pDmaChannel && g_bFlip)
    {
        g_bFlip = FALSE;

        if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
        {
            osNVPClearEvent(pVPEContext->hNVPSyncEvent[1]);
            osNVPClearEvent(pVPEContext->hNVPSyncEvent[2]);
        }

        // reset notifiers
        pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;

        // stop overlay
        NVP_DMAPUSH_CHECK_FREE_COUNT(6);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS); //NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS); //NV07A_STOP_OVERLAY_AS_SOON_AS_POSSIBLE
        pDmaChannel->Put = nvDmaCount << 2;
        pVPEContext->nvDmaCount = nvDmaCount;

        // wait here only if not waiting on events in ring3 !!!
        if ((pVPEContext->hNVPSyncEvent[1] == NULL) || (pVPEContext->hNVPSyncEvent[2] == NULL))
        {
            i = 0;
            while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                i++;

            // timed-out...
            if (i >= NVP_VPP_TIME_OUT)
                DBGPRINT(DBGERROR, "waiting for overlay flip notifiers timed-out....");
        }

        pPioFlipOverlayNotifier[1].status = 0;
        pPioFlipOverlayNotifier[2].status = 0;
    }
    // don't let ring3 wait for nothing !
    else if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
    {
        osNVPSetEvent(pVPEContext->hNVPSyncEvent[1]);
        osNVPSetEvent(pVPEContext->hNVPSyncEvent[2]);
    }

    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

    // tell VP to stop grabbing !
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    //if (pCmdObj->dwStopStrm & NVP_STOP_VIDEO)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_IMAGE , 0);
    //if (pCmdObj->dwStopStrm & NVP_STOP_VBI)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_VBI , 0);
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

#define NVP_NOTIFY_TIMEOUT 100000
    i = 0;
    // wait for the last few notifies to show up...
    while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
             (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
           (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
           (i < NVP_NOTIFY_TIMEOUT)))
    {
        i++;
        //RmInterrupt(&ntfParam);
    }

    // timed-out...
    if (i >= NVP_NOTIFY_TIMEOUT)
        DBGPRINT(DBGERROR, "waiting for MediaPort notifiers timed-out....");

    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

#else
//    NVPShutDownOverlay(pVPEContext);

    // reset notifiers
    pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

    pPioFlipOverlayNotifier[1].status = 0;
    pPioFlipOverlayNotifier[2].status = 0;

    NVPShutDownMediaPort(pVPEContext);
#endif


    // reset surfaces counters
    pVPEContext->nNumVBISurf = 0;
    pVPEContext->nNumVidSurf = 0;

#ifdef _STOP_OVERLAY
    // clear/reset sync event
    osNVPClearEvent((PVOID) pVPEContext->hNVPSyncEvent[0]);
#endif

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPRegSurface

    Description:    register a DDraw surface. Insert in list and update
                    attributes

    Date:           Feb 18, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPRegSurface(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_SURFACE_INFO pSurface;
    BOOL bVideoStarted, bVBIStarted;

    DBGPRINT(DBGTRACE, "NVPRegSurface()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    bVideoStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO);
    bVBIStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI);

    //resize VP if capturing
    if(pVPEContext->ulVPECaptureFlag){
        
        pCmdObj->dwPreWidth=(pVPEContext->ulVPECapturePrescaleXFactor *
                                    pCmdObj->dwInWidth)/1000;
        pCmdObj->dwPreHeight=(pVPEContext->ulVPECapturePrescaleYFactor *
                                    pCmdObj->dwInHeight)/1000;
    }               

    // update attributes of already existing surfaces ?!
    if (pCmdObj->bSurfUpdate)
    {
        // vbi surfaces ?!
        if (pCmdObj->bSurfVBI)
        {
            if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVBISurf)
            {
                pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
                // check for mem offset in framebuffer !
                if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
                {
                    pSurface->dwHeight = pCmdObj->dwVBIHeight;
                    pSurface->dwStartLine = pCmdObj->dwVBIStartLine;        // startline for vbi

                }
                else
                {
                    DBGPRINT(DBGERROR, "can't update VBI surface data !");
                    return ERROR_INVALID_PARAMETER;
                }

            }
            else
            {
                // new vbi surfaces
                pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
                (pVPEContext->nNumVBISurf)++;
                pSurface->pVidMem = pCmdObj->pSurfVidMem;               // Flat pointer to the surface
                pSurface->dwOffset = pCmdObj->dwSurfOffset;             // Offset from the base of the frame buffer
                pSurface->dwPitch = pCmdObj->dwSurfPitch;
                pSurface->dwHeight = pCmdObj->dwVBIHeight;
                pSurface->dwStartLine = pCmdObj->dwVBIStartLine;        // Programs Y-crop for image, and startline for vbi
                pSurface->dwPreScaleSizeX = pCmdObj->dwInWidth;         // prescale size width == pitch for vbi surfaces
                pSurface->dwPreScaleSizeY = pCmdObj->dwInHeight;        // prescale size height == vbi height 
                pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;   // the next surface idx in the chain
                pSurface->bIsFirstFieldCaptured = FALSE;                // reset value

            }
        }
        else    // video surface
        {
            if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVidSurf)
            {
                //////////
                ///// I assume something changing in the following values only !
                pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
                if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
                {
#ifndef _STOP_OVERLAY
                    ///// we need to stop the media port and restart it later because there is a change in the scaling factors
                    if ((pSurface->dwHeight != pCmdObj->dwInHeight) || 
                        (pSurface->dwWidth != pCmdObj->dwInWidth) ||
                        (pSurface->dwPreScaleSizeX != pCmdObj->dwPreWidth) ||
                        (pSurface->dwPreScaleSizeY != pCmdObj->dwPreHeight))
                    {
                        //pVPEContext->bVPScalingFactorChanged = TRUE;
                        // aleady stopped ?!
                        if (!(pVPEContext->dwVPState & NVP_STATE_STOPPED))
                        {
                            NVPShutDownOverlay(pVPEContext);
                            NVPShutDownMediaPort(pVPEContext);
                        }
                    }
#endif
                    pSurface->dwHeight = pCmdObj->dwInHeight;
                    pSurface->dwWidth = pCmdObj->dwInWidth;                 // Ignored for VBI
                    pSurface->dwStartLine = pCmdObj->dwImageStartLine;      // Programs Y-crop for image, and startline for vbi
                    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;        // prescale size width
                    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;       // prescale size height
                }
                else
                {
                    DBGPRINT(DBGTRACE, "can't update video surface data !");
                    return ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                // new video surfaces
                pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
                (pVPEContext->nNumVidSurf)++;
                pSurface->pVidMem = pCmdObj->pSurfVidMem;               // Flat pointer to the surface
                pSurface->dwOffset = pCmdObj->dwSurfOffset;             // Offset from the base of the frame buffer
                pSurface->dwPitch = pCmdObj->dwSurfPitch;
                pSurface->dwHeight = pCmdObj->dwInHeight;
                pSurface->dwWidth = pCmdObj->dwInWidth;                 // Ignored for VBI
                pSurface->dwStartLine = pCmdObj->dwImageStartLine;      // Programs Y-crop for image, and startline for vbi
                pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;        // prescale size width
                pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;       // prescale size height
                pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;   // the next surface idx in the chain
                pSurface->bIsFirstFieldCaptured = FALSE;                // reset value

            }
        }
    }
    else    // new surfaces !
    {
        if (pVPEContext->dwVPState & NVP_STATE_STARTED)
        {
            DBGPRINT(DBGERROR, "can't register new DD surfaces while Video Port is running !");
            return ERROR_INVALID_PARAMETER;
        }

        // vbi surfaces ?!
        if (pCmdObj->bSurfVBI)
        {
            pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
            (pVPEContext->nNumVBISurf)++;
            pSurface->dwStartLine = pCmdObj->dwVBIStartLine;       // startline for vbi
            pSurface->dwPreScaleSizeX = pCmdObj->dwInWidth;        // shouldn't be any prescaling performed on vbi surfaces
            pSurface->dwPreScaleSizeY = pCmdObj->dwInHeight;
        }
        else    // video surface
        {
            pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
            (pVPEContext->nNumVidSurf)++;
            pSurface->dwStartLine = pCmdObj->dwImageStartLine;      // startline for video
            pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;        // prescale size width
            pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;       // prescale size height
        }

        pSurface->pVidMem = pCmdObj->pSurfVidMem;               // Flat pointer to the surface
        pSurface->dwOffset = pCmdObj->dwSurfOffset;             // Offset from the base of the frame buffer
        pSurface->dwPitch = pCmdObj->dwSurfPitch;
        pSurface->dwHeight = pCmdObj->dwInHeight;
        pSurface->dwWidth = pCmdObj->dwInWidth;
        pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;   // the next surface idx in the chain
        pSurface->bIsFirstFieldCaptured = FALSE;                // reset value
    }

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPUpdateOverlay

    Description:    update the overlay info structure

    Date:           Mar 01, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPUpdateOverlay(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    Nv03ChannelPio *pChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);   // get a pointer to the overlay channel;
    PNVP_OVERLAY pnvOverlay =  &(pVPEContext->nvpOverlay);
    NvNotification *pPioFlipOverlayNotifier;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount, i = 0;
    U032 srcDeltaX, srcDeltaY;
    U032 bRing0FlippingFlag;

    DBGPRINT(DBGTRACE, "NVPUpdateOverlay()");
#define VBI_CAP_OFFSET	0//1	//Hack. When capturing vid +vbi, the last vid line is always corrupted. Use
							//this to offset line and apply for all cases for consistency. ch    

	//Adjust for WDM prescale hack (only when capturing!!)
	//need to zoom back up because of ME prescaling during capture ONLY IF
	//vp is using the overlay engine(bVPNotUseOverSurf)
    if (pVPEContext->ulVPECaptureFlag && !(pVPEContext->ulVPNotUseOverSurf))
    {
        DBGPRINT(DBGTRACE, "NVPUpdateOverlay():Adjusting for VP prescaling...");

        pCmdObj->dwOverlaySrcWidth = (pVPEContext->aVideoSurfaceInfo[0]).dwPreScaleSizeX;    //getting prescale size since it's the same for all surfs.
#ifdef FORCE_INTERLEAVE_MEM
		pCmdObj->dwOverlaySrcHeight = ((pVPEContext->aVideoSurfaceInfo[0]).dwPreScaleSizeY - VBI_CAP_OFFSET)*2;
#else
        if(pVPEContext->dwVPFlags & DDVP_INTERLEAVE){
			pCmdObj->dwOverlaySrcHeight = ((pVPEContext->aVideoSurfaceInfo[0]).dwPreScaleSizeY - VBI_CAP_OFFSET)*2;
		}else{
			pCmdObj->dwOverlaySrcHeight = (pVPEContext->aVideoSurfaceInfo[0]).dwPreScaleSizeY - VBI_CAP_OFFSET;
		}
#endif
    }else{	//not capturing

#ifdef FORCE_INTERLEAVE_MEM
		//since we are forcing interleave and if DDVP_INTERLEAVE is off, 
		//overlay src size is is incorrect. need to double src height
		if (!(pVPEContext->dwVPFlags & DDVP_INTERLEAVE)){
			pCmdObj->dwOverlaySrcHeight = (pCmdObj->dwOverlaySrcHeight - VBI_CAP_OFFSET)*2;
			//pCmdObj->dwOverlaySrcPitch *= 2;
		}
#endif
	}
    // ds/dx
    if (pCmdObj->dwOverlayDstWidth <= 1) {
        srcDeltaX = 0x100000;
    } else {
        srcDeltaX = (pCmdObj->dwOverlaySrcWidth - 1) << 16;
        srcDeltaX /= pCmdObj->dwOverlayDstWidth - 1;
        srcDeltaX <<= 4;
    }

    // dt/dy
    if (pCmdObj->dwOverlayDstHeight <= 1) {
        srcDeltaY = 0x100000;
    } else {
        srcDeltaY = (pCmdObj->dwOverlaySrcHeight - 1) << 16;
        if (pVPEContext->dwChipId <= NV_DEVICE_VERSION_4) {
            srcDeltaY /= pCmdObj->dwOverlayDstHeight + 2;
        } else {
            srcDeltaY /= pCmdObj->dwOverlayDstHeight + 1;
        }
        srcDeltaY <<= 4;
    }

    // sizein
    pCmdObj->dwOverlaySrcSize = (pCmdObj->dwOverlaySrcHeight)<<16;
    pCmdObj->dwOverlaySrcSize |= pCmdObj->dwOverlaySrcWidth;

    pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

    if ((pCmdObj->dwOverlayDstWidth != 0) && (pCmdObj->dwOverlayDstHeight != 0))
    {
        // I must rather have a structure memcpy !
        pnvOverlay->dwOverlayFormat = pCmdObj->dwOverlayFormat;
        pnvOverlay->dwOverlaySrcX = pCmdObj->dwOverlaySrcX;
        pnvOverlay->dwOverlaySrcY = pCmdObj->dwOverlaySrcY;
        pnvOverlay->dwOverlaySrcPitch = pCmdObj->dwOverlaySrcPitch;
        pnvOverlay->dwOverlaySrcSize = pCmdObj->dwOverlaySrcSize;
        pnvOverlay->dwOverlaySrcWidth = pCmdObj->dwOverlaySrcWidth;
        pnvOverlay->dwOverlaySrcHeight = pCmdObj->dwOverlaySrcHeight;
        pnvOverlay->dwOverlayDstWidth = pCmdObj->dwOverlayDstWidth;
        pnvOverlay->dwOverlayDstHeight = pCmdObj->dwOverlayDstHeight;
        pnvOverlay->dwOverlayDstX = pCmdObj->dwOverlayDstX;
        pnvOverlay->dwOverlayDstY = pCmdObj->dwOverlayDstY;
        pnvOverlay->dwOverlayDeltaX = srcDeltaX;//pCmdObj->dwOverlayDeltaX;
        pnvOverlay->dwOverlayDeltaY = srcDeltaY;//pCmdObj->dwOverlayDeltaY;
        pnvOverlay->dwOverlayColorKey = pCmdObj->dwOverlayColorKey;
        pnvOverlay->dwOverlayMode = pCmdObj->dwOverlayMode;
        pnvOverlay->dwOverlayMaxDownScale = pCmdObj->dwOverlayMaxDownScale;

		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcX=", (pCmdObj->dwOverlaySrcX));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcY=", (pCmdObj->dwOverlaySrcY));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcPitch=", (pCmdObj->dwOverlaySrcPitch));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcSize=", (pCmdObj->dwOverlaySrcSize));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcWidth=", (pCmdObj->dwOverlaySrcWidth));
		DBGPRINTVALUE(DBGINFO, "dwOverlaySrcHeight=", (pCmdObj->dwOverlaySrcHeight));
		DBGPRINTVALUE(DBGINFO, "dwOverlayDstWidth=", (pCmdObj->dwOverlayDstWidth));
		DBGPRINTVALUE(DBGINFO, "dwOverlayDstHeight=", (pCmdObj->dwOverlayDstHeight));
		DBGPRINTVALUE(DBGINFO, "dwOverlayDstX=", (pCmdObj->dwOverlayDstX));
		DBGPRINTVALUE(DBGINFO, "dwOverlayDstY=", (pCmdObj->dwOverlayDstY));
		DBGPRINTVALUE(DBGINFO, "srcDeltaX=", (srcDeltaX));
		DBGPRINTVALUE(DBGINFO, "srcDeltaY=", (srcDeltaY));
		DBGPRINTVALUE(DBGINFO, "dwOverlayMode=", (pCmdObj->dwOverlayMode));
		DBGPRINTVALUE(DBGINFO, "dwOverlayMaxDownScale=", (pCmdObj->dwOverlayMaxDownScale));

        // update overlay info: extra 422 surfaces used for prescaling
        pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
        pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
        pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

        for (i = 0; i < pCmdObj->dwExtra422NumSurfaces; i++)
        {
            pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i]; // extra memory space used for prescaling
        }

        DBGPRINT(DBGTRACE, "overlay flipping enabled....");
        g_bFlip = TRUE;

        // if we get a 'show overlay' command while MediaPort engine is stopped, this means that we are in a 
        // 'pause state'... unless we are using KMVT to flip (STB-TV-tuner-like app), program the overlay engine to show the last frame captured by Media Port !
        bRing0FlippingFlag = 0;
        if (pVPEContext->pOvrRing0FlipFlag)
            bRing0FlippingFlag = *((U032 *)(pVPEContext->pOvrRing0FlipFlag));
        if ((pVPEContext->dwVPState & NVP_STATE_STOPPED) && !bRing0FlippingFlag)
        {
            NVPScheduleOverlayFlip(pVPEContext, &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]), 0, 0, 0);
            // reset notifiers
            pPioFlipOverlayNotifier[1].status = 0;
            pPioFlipOverlayNotifier[2].status = 0;

        }
    }
    else
    {
        if (g_bFlip)
        {
            DBGPRINT(DBGTRACE, "overlay flipping disabled....");

            g_bFlip = FALSE;    // no autoflip !

            // channel
            pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
            nvDmaCount = pVPEContext->nvDmaCount;

            // stop overlay engine
            if (pDmaChannel)
            {
                if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
                {
                    osNVPClearEvent(pVPEContext->hNVPSyncEvent[1]);
                    osNVPClearEvent(pVPEContext->hNVPSyncEvent[2]);
                }

                // reset notifiers
//                pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

                pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
                pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;

                // stop overlay
                NVP_DMAPUSH_CHECK_FREE_COUNT(6);
                NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
                NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
                NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
                pDmaChannel->Put = nvDmaCount << 2;
                pVPEContext->nvDmaCount = nvDmaCount;

               // wait here only if not waiting on events in ring3 !!!
               if ((pVPEContext->hNVPSyncEvent[1] == NULL) || (pVPEContext->hNVPSyncEvent[2] == NULL))
               {
                    while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                        i++;
                    // timed-out...
                    if (i >= NVP_VPP_TIME_OUT)
                        DBGPRINT(DBGERROR, "waiting for overlay flip notifiers timed-out....");
                }
    
                pPioFlipOverlayNotifier[1].status = 0;
                pPioFlipOverlayNotifier[2].status = 0;
            }
        }
        // don't let ring3 wait for nothing !
        else if ((pVPEContext->hNVPSyncEvent[1]) && (pVPEContext->hNVPSyncEvent[2]))
        {
            osNVPSetEvent(pVPEContext->hNVPSyncEvent[1]);
            osNVPSetEvent(pVPEContext->hNVPSyncEvent[2]);
        }
    }

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPFlipVideoPort

    Description:    start capturing in specified surface

    Date:           Mar 01, 1999
    
    Author:         H. Azar

==============================================================================
*/
#pragma warning(disable: 4296)

VP_STATUS NVPFlipVideoPort(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_SURFACE_INFO pSurface;
    int i;

    DBGPRINT(DBGTRACE, "NVPFlipVideoPort()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // NVP_UNDEF tells us to lookup the surface in list
    if (pCmdObj->dwSurfaceId == NVP_UNDEF)
    {
        for (i = 0; i < pVPEContext->nNumVidSurf; i++)
        {
                //////////
                ///// I assume nothing changing in the surfaces values
                pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
                if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
                {
                    // clear/reset sync event
                    osNVPClearEvent((PVOID)pVPEContext->hNVPSyncEvent[0]);
                    // found target surface, so update index of video surface we're currently capturing into
                    pVPEContext->nVidSurfIdx = i;
                    return NO_ERROR;
                }
        }
    }
    else
    {
        // check for weird values !
        if ((pCmdObj->dwSurfaceId >= 0) &&
            (pCmdObj->dwSurfaceId < (DWORD)pVPEContext->nNumVidSurf) &&
            (pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId].pVidMem == pCmdObj->pSurfVidMem))
        {
                // clear/reset sync event
                osNVPClearEvent((PVOID)pVPEContext->hNVPSyncEvent[0]);
                // update index of video surface we're currently capturing into
                pVPEContext->nVidSurfIdx = (int)(pCmdObj->dwSurfaceId);
                return NO_ERROR;
        }
    }

    ////// if we got here, it means the target surface wasn't found in list...
    // so add it at the end of the list
    i = pVPEContext->nNumVidSurf;
    pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
    (pVPEContext->nNumVidSurf)++;
    pSurface->dwStartLine = pCmdObj->dwImageStartLine;      // startline for video
    pSurface->pVidMem = pCmdObj->pSurfVidMem;               // Flat pointer to the surface
    pSurface->dwOffset = pCmdObj->dwSurfOffset;             // Offset from the base of the frame buffer
    pSurface->dwPitch = pCmdObj->dwSurfPitch;
    pSurface->dwHeight = pCmdObj->dwInHeight;
    pSurface->dwWidth = pCmdObj->dwInWidth;                 // Ignored for VBI
    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;        // Ignored for VBI.. prescale size width
    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;       // Ignored for VBI.. prescale size height
    pSurface->nNextSurfaceIdx = 0;                          // the next surface idx in the chain
    pSurface->bIsFirstFieldCaptured = FALSE;                // reset value
    // clear/reset sync event
    osNVPClearEvent((PVOID)pVPEContext->hNVPSyncEvent[0]);
    // flip to surface !
    pVPEContext->nVidSurfIdx = i;                           

    return NO_ERROR;
}

#pragma warning(default: 4296)

/*
==============================================================================
    
    NVP3ProgVideoField

    Description:    programs the vp to capture the specified video field

    Date:           Feb 19, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVP3ProgVideoField(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int nFieldId,
    U032 dwSurfPitch,
    U032 dwInterleaveOffset,
    BOOL bGrab)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pNVPChannel;
    NvNotification *avpNotifiers;
    int nFreeCount;
    NVOS09_PARAMETERS ntfParam;

    pSurface->dwFieldType = (ULONG)nFieldId;

    // get a pointer to the appropriate VPE context
    pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;    // get a copy of the pio channel pointer

#ifdef _NV_DPC
    //CHECK_FREE_COUNT(pNVPChannel,6*4);
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 7*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pNVPChannel, 0);
    }           
    pVPEContext->nFreeCount = nFreeCount - (7*4);
#endif

    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    // program the VP to grab in the next surface
    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeIn  = (pSurface->dwWidth) | (pSurface->dwHeight << 16);
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeOut = (pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16);

    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = pSurface->dwStartLine;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].offset  = pSurface->dwOffset + dwInterleaveOffset;

    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].format =
            (dwSurfPitch & 0xFFFF)  |
            ((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
            ((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000);

#endif // NVP_NV3
}

/*
==============================================================================
    
    NVP3ProgVBIField

    Description:    programs the vp to capture the specified VBI field.
                    PIO channel version.

    Date:           Feb 19, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVP3ProgVBIField(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int nFieldId)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pNVPChannel;
    int nFreeCount;
    NVOS09_PARAMETERS ntfParam;
    NvNotification *avpNotifiers;

    pSurface->dwFieldType = (ULONG)nFieldId;

    // get a pointer to the appropriate VPE context
    pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;    // get a copy of the pio channel pointer

#ifdef _NV_DPC
    //CHECK_FREE_COUNT(pNVPChannel,5*4);
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 5*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pNVPChannel, 0);
    }
    pVPEContext->nFreeCount = nFreeCount - (5*4);
#endif
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].size  = (pSurface->dwStartLine) | (pSurface->dwHeight << 16);
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].offset  = pSurface->dwOffset;
    pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].format =
            (pSurface->dwPitch & 0xFFFF)  |
            ((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
            ((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);

#endif // NVP_NV3
}

/*
==============================================================================
    
    NVPProgVideoField

    Description:    programs the vp to capture the specified video field

    Date:           Apr 19, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVPProgVideoField(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int nFieldId,
    U032 dwSurfPitch,
    U032 dwInterleaveOffset,
    BOOL bGrab)
{
    Nv4ControlDma *pDmaChannel;
    NvNotification *avpNotifiers;
    U032 dwFormat;
    U032 nvDmaCount;

    DBGPRINT(DBGTRACE, "NVPProgVideoField");

    //NVPFlushChannel(pVPEContext);
    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
    {
        NVP3ProgVideoField(pVPEContext, pSurface, nFieldId, dwSurfPitch, dwInterleaveOffset, bGrab);
        return;
    }

#ifdef _NVP_DTRACE
    DTRACE(0xdead0000);
    DTRACE_CYCLE_DELTA();
    DTRACE(g_nIntCounter);
    DTRACE(nFieldId);
    g_nIntCounter++;
#endif

    // update type of field we're capturing
    pSurface->dwFieldType = (ULONG)nFieldId;

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(12);

    // reset notifier
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

#ifdef _NVP_TEST_NEXT_FIELD
    if (nFieldId != g_nNextFieldId)
        _asm int 3
    g_nNextFieldId = nFieldId ^ 1;
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    dwFormat = avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status;
    dwFormat = avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(g_nNextFieldId)].status;
#endif

    avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_IN(nFieldId), ((pSurface->dwWidth) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_OUT(nFieldId), ((pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_START_LINE, pSurface->dwStartLine);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_OFFSET(nFieldId), (pSurface->dwOffset + dwInterleaveOffset));
    dwFormat = ((dwSurfPitch & 0xFFFF) |
                ((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
                ((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000));

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;


}

/*
==============================================================================
    
    NVPProgVBIField

    Description:    programs the vp to capture the specified VBI field

    Date:           Apr 22, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVPProgVBIField(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int nFieldId)
{
    Nv4ControlDma *pDmaChannel;
    NvNotification *avpNotifiers;
    U032 dwFormat;
    U032 nvDmaCount;

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
    {
        NVP3ProgVBIField(pVPEContext, pSurface, nFieldId);
        return;
    }

    // update type of field we're capturing
    pSurface->dwFieldType = (ULONG)nFieldId;

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(8);

    // reset notifier
    avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
    avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

    // program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_SIZE(nFieldId), ((pSurface->dwStartLine) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_OFFSET(nFieldId), pSurface->dwOffset);
    dwFormat = (pSurface->dwPitch & 0xFFFF)  |
            ((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
            ((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;
}


/*
==============================================================================
    
    NVPProcessState

    Description:    programs the video port grab in a surface and determines
                    which surface is next.

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPProcessState(
    PHW_DEVICE_EXTENSION pHwDevExt,
    int nIndex,
    BOOL bVBIField)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_SURFACE_INFO pSurface;
    int nFieldId = nIndex & 1;
    BOOL bIRQCallback;

    DBGPRINT(DBGTRACE, "NVPProcessState()");

    // get a pointer to the appropriate VPE context
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    // setting nIndex to greater than 1 (nField | any_value) means that the caller is NVPStart or NVPUpdate
    // so first time initialize the dwOverlayIndex to match up with the nFieldId (notifier)
    if ((pVPEContext->nvpOverlay.dwOverlayBufferIndex == NVP_UNDEF) && (nIndex <= 1))
       pVPEContext->nvpOverlay.dwOverlayBufferIndex = nFieldId;

    // calling IRQCallback must be done only at the end of video field or at end of vbi when
    // capturing vbi only
    bIRQCallback = (!bVBIField) || (pVPEContext->nNumVidSurf == 0);
    // any transfer request of already captured vbi/video data ?!
//  if (bIRQCallback)
//      NVPCheckForLaunch(pVPEContext, NULL);


    if (pVPEContext->dwVPState != NVP_STATE_STOPPED)
    {
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
        {
            // program VBI here. This way VBI is synchronized with the video thus we eliminate the need
            // for a seperate VBI notifications routine unless we're streaming VBI only
            if (!bVBIField)
            {
                if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
                {
                    pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
                    // program the VP to grab in the next surface
                    NVPProgVBIField(pVPEContext, pSurface, nFieldId);

                    // next surface in the chain !
                    pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
                    pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
                }

                if (pVPEContext->dwVPConFlags & DDVPCONNECT_INTERLACED)
                {
                    if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
                    {
                        if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
                        {
                            // Bob from interleaved surfaces (skip even/odd included here too)
                            DoBobFromInterleaved(pVPEContext, nFieldId);
                        }
                        else
                        {
                            // Weave
                            DoWeave(pVPEContext, nFieldId);
                        }
                    }
                    else
                    {
#ifdef FORCE_INTERLEAVE_MEM
                        // Bob from interleaved surfaces (skip even/odd included here too)
                        DoBobFromInterleaved(pVPEContext, nFieldId);
#else
                        // Bob from non-interleaved (separate) surfaces (skip even/odd included here too)
                        DoBob(pVPEContext, nFieldId);
#endif
                    }
                }
                else
                {
                    // Progressive
                    DoProgressive(pVPEContext, nFieldId);
                }
            }
        }
        else if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
        {
            pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
            // program the VP to grab in the next surface
            NVPProgVBIField(pVPEContext, pSurface, nFieldId);

            // next surface in the chain !
            pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
            pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
        }
    }

    //
    // calling IRQCallback must be done only at the end of video field or at end of vbi when
    // capturing vbi only
    if (bIRQCallback && (pHwDevExt->dwIRQSources & DDIRQ_VPORT0_VSYNC))
    {
        kmvtNVPCallbackDxApi((PVOID)pHwDevExt, DDIRQ_VPORT0_VSYNC);
#if 0
        // can we pass on the interrupt !
        if ((pHwDevExt->IRQCallback) && (pHwDevExt->dwIRQSources & DDIRQ_VPORT0_VSYNC))
        {
            PDX_IRQDATA pIRQData;
            pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
            pIRQData->dwIrqFlags |= DDIRQ_VPORT0_VSYNC;
            ((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
        }
#endif
    }

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPEProcessCommand

    Description:    dispatches commands sent via IOCTL to the appropriate
                    NVP function

    Date:           Feb 03, 1999
    
    Author:         H. Azar

==============================================================================
*/
#pragma warning(disable: 4296)

VP_STATUS NVPEProcessCommand(
    PVOID pHwDeviceExtension,
    PVIDEO_REQUEST_PACKET pRequestPacket)
{
    U032 status = 0;
    NVP_CMD_OBJECT *pnvCmdObj, *pnvCmdObjOut;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    DBGPRINT(DBGTRACE, "NVPEProcessCommand()");

    pnvCmdObj = (NVP_CMD_OBJECT *)(pRequestPacket->InputBuffer);
    pnvCmdObjOut = (NVP_CMD_OBJECT *)(pRequestPacket->OutputBuffer);
    // some arguments validation
    if ((pnvCmdObj->dwPortId < 0) || (pnvCmdObj->dwPortId >= NVP_MAX_VPORTS))
        return ERROR_INVALID_PARAMETER;

    // dispatch call
    switch (pnvCmdObj->dwSrvId)
    {
        case NVP_SRV_INITIALIZE:
            status = NVPInitialize(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_UNINITIALIZE:
            status = NVPUninitialize(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_START_VIDEO:
            status = NVPStart(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_STOP_VIDEO:
            status = NVPStop(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_UPDATE_VIDEO:
            status = NVPUpdate(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_REG_SURFACE:
            status = NVPRegSurface(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_UPDATE_OVERLAY:
            status = NVPUpdateOverlay(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_FLIP_VIDEOPORT:
            status = NVPFlipVideoPort(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_IS_VPE_ENABLED:
            status = NVPIsVPEEnabled(pHwDevExt, pnvCmdObj, pnvCmdObjOut);
#ifdef _WIN32_WINNT
                  pRequestPacket->StatusBlock->Information = sizeof(NVP_CMD_OBJECT);
#endif
            break;
#ifdef VPEFSMIRROR    
        case NVP_SRV_ENABLE_FSMIRROR:
            status = NVPFsMirrorEnable(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_REG_FSMIRROR_SURFACE:
            status = NVPFsRegSurface(pHwDevExt, pnvCmdObj);
            break;
        case NVP_SRV_DISABLE_FSMIRROR:
            status = NVPFsMirrorDisable(pHwDevExt, pnvCmdObj);
            break;
#endif
        default:
            DBGPRINT(DBGERROR, "invalid VPE command !");
            return ERROR_INVALID_PARAMETER;
    }

    return status;
}

#pragma warning(default: 4296)

#ifdef _WIN32_WINNT // {

/*
==============================================================================
    
    VideoField0Notify

    Description:    callback function. Called after a video buffer gets filled

    Date:           Feb 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void VideoField0Notify(PVOID pHwDeviceExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    NVPProcessState(pHwDevExt, 0, FALSE);
}

/*
==============================================================================
    
    VideoField1Notify

    Description:    callback function. Called after a vbi buffer gets filled

    Date:           Feb 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void VideoField1Notify(PVOID pHwDeviceExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    NVPProcessState(pHwDevExt, 1, FALSE);
}


/*
==============================================================================
    
    VBIField0Notify

    Description:    callback function. Called after a vbi buffer gets filled

    Date:           Feb 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void VBIField0Notify(PVOID pHwDeviceExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    NVPProcessState(pHwDevExt, 0, TRUE);
}

/*
==============================================================================
    
    VBIField1Notify

    Description:    callback function. Called after a vbi buffer gets filled

    Date:           Feb 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void VBIField1Notify(PVOID pHwDeviceExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

    NVPProcessState(pHwDevExt, 1, TRUE);
}

#endif // _WIN32_WINNT }

/*
==============================================================================
    
    NVPScheduleOverlayFlip

    Description:    program overlay object to flip surface

    Date:           Feb 25, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPScheduleOverlayFlip(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface,
    int  nImageId,
    U032 dwSrcPitch,
    U032 dwMoveDownOffset)
{
    U032 dwFlags = 0;

    DBGPRINT(DBGTRACE, "NVPScheduleOverlayFlip");

#ifdef VPEFSMIRROR
    	// [XW:10/15/2000] Added so we don't skip the FSMirror for FourCC blits of VPE Port
	    
    if ( (!g_bFlip) && (!pVPEContext->dwFsMirrorOn) )
        return NO_ERROR;

#endif

    if (!g_bFlip)
        return NO_ERROR;

    DBGPRINT(DBGTRACE, "NVPScheduleOverlayFlip()");

    dwFlags = VPP_PRESCALE;

#ifndef FORCE_INTERLEAVE_MEM
    if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
       dwFlags |= VPP_INTERLEAVED;
    else
       dwFlags |= VPP_BOB;
#else
	dwFlags |= VPP_INTERLEAVED;
	if (!(pVPEContext->dwVPFlags & DDVP_INTERLEAVE)){
		dwFlags |= VPP_BOB;
	}
#endif
    if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
       dwFlags |= VPP_BOB;

    if (nImageId == NVP_FIELD_ODD)
       dwFlags |= VPP_ODD;
    else if (nImageId == NVP_FIELD_EVEN)
       dwFlags |= VPP_EVEN;

    NVPPrescaleAndFlip(
        pVPEContext,
        &(pVPEContext->nvpOverlay),
        pSurface->dwOffset,
        pSurface->dwPitch, // source pitch
        nImageId,
        dwFlags);          // VPP flags

    return NO_ERROR;
}


/*
==============================================================================
    
    DoProgressive

    Description:    displays progressive video

    Date:           Mar 08, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS DoProgressive(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    PNVP_SURFACE_INFO pSurface;
    int nTargetSurfId = pVPEContext->nVidSurfIdx;
    U032 dwSrcPitch;
    int nImage = nFieldId;

    pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
        // if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
    if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
        nTargetSurfId = pSurface->nNextSurfaceIdx;

    dwSrcPitch = pSurface->dwPitch;

    // Overlay Image n from CS
    NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage, dwSrcPitch, 0);

    pVPEContext->nVidSurfIdx = nTargetSurfId;

    // Grab Image n in TS
    pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
    NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

    return NO_ERROR;
}

/*
==============================================================================
    
    DoWeave

    Description:    use weave method to display video

    Date:           Mar 08, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS DoWeave(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    PNVP_SURFACE_INFO pSurface;
    int nTargetSurfId = pVPEContext->nVidSurfIdx;
    U032 dwSrcPitch, dwOffset = 0;
    int nImage = nFieldId;

    pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
    // if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
    if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
        nTargetSurfId = pSurface->nNextSurfaceIdx;
    // double pitch (interleaved data)
    dwSrcPitch = 2*(pSurface->dwPitch);

    if (nFieldId == NVP_FIELD_ODD)
    {
        // Invert Polarity ?!
        if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
        {
            // change vp grab offset one line down
            dwOffset = pSurface->dwPitch;
            // Shift Down Image destination by 1 line !
            /////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
            //dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
        }
    }
    else
    {
        // not Invert Polarity ?!
        if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
        {
            // offset vp grab one line down
            dwOffset = pSurface->dwPitch;

            // Shift Down Image destination by 1 line !
            /////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
            //dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
        }
    }

    // whole frame captured ?!
    if (pSurface->bIsFirstFieldCaptured)
    {
        // Overlay Image n from CS
        NVPScheduleOverlayFlip(pVPEContext, pSurface, NVP_UNDEF, pSurface->dwPitch, 0);
        // NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);

        pSurface->bIsFirstFieldCaptured = FALSE;    // reset flag (for the next time)

        // if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
        if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
            pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
    }
    else
        pSurface->bIsFirstFieldCaptured = TRUE; // set flag (for the next time)

    // Grab Image n in TS
    pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
    NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

    return NO_ERROR;
}

/*
==============================================================================
    
    DoBobFromInterleaved

    Description:    use bob from interleaved input to display video

    Date:           Mar 08, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS DoBobFromInterleaved(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    PNVP_SURFACE_INFO pSurface;
    int nTargetSurfId = pVPEContext->nVidSurfIdx;
    U032 dwSrcPitch, dwOffset = 0;
    int nImage = nFieldId;

    DBGPRINT(DBGTRACE, "DoBobFromInterleaved");

    // Current Surface (CS)
    pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
    // NewPitch = OldPitch
    dwSrcPitch = pSurface->dwPitch; // interleaved
    // if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
    if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
        nTargetSurfId = pSurface->nNextSurfaceIdx;

#if 0
    if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
    {
        if (nFieldId == NVP_FIELD_EVEN)
        {
            // VP minimum programming to issue an interrupt at end of field !
            NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
            return NO_ERROR;
        }
    }
    else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
    {
        if (nFieldId == NVP_FIELD_ODD)
        {
            // VP minimum programming to issue an interrupt at end of field !
            NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
            return NO_ERROR;
        }
    }
    else
#endif
    {
        // double pitch (interleaved data)
        dwSrcPitch = 2*dwSrcPitch;
        if (nFieldId == NVP_FIELD_ODD)
        {
            // Invert Polarity ?!
            if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
            {
                // change vp grab offset one line down
                dwOffset = pSurface->dwPitch;
            }
        }
        else
        {
            // Invert Polarity ?!
            // for the even field (bottom) shift down overlay destination if invert polarity flag is not set !
            if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
            {
                dwOffset = pSurface->dwPitch;

            }
        }

    }

    if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
        !((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
    {
        // Overlay Image n from CS
        NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset);
        // NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);
    }

    // whole frame captured ?!
    if (pSurface->bIsFirstFieldCaptured)
    {
        pSurface->bIsFirstFieldCaptured = FALSE;    // reset (for the next time)
        // if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
        if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
            pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
    }
    else
        pSurface->bIsFirstFieldCaptured = TRUE; // for the next time

    // Grab Image n in TS
    pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
    NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

    return NO_ERROR;
}

/*
==============================================================================
    
    DoBob

    Description:    use bob from non-interleaved input to display video

    Date:           Mar 08, 1999
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS DoBob(
    PNVP_CONTEXT pVPEContext,
    int nFieldId)
{
    PNVP_SURFACE_INFO pSurface;
    int nTargetSurfId = pVPEContext->nVidSurfIdx;
    U032 dwSrcPitch;
    int nImage = nFieldId;

    pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
    dwSrcPitch = pSurface->dwPitch;
#if 0
    if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
    {
        if (nFieldId == NVP_FIELD_EVEN)
        {
            // VP minimum programming to issue an interrupt at end of field !
            // TS = next2(CS)
            nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
            pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
            NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
            return NO_ERROR;
        }
        else
            // TS = next(CS)
            nTargetSurfId = pSurface->nNextSurfaceIdx;
    }
    else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
    {
        if (nFieldId == NVP_FIELD_ODD)
        {
            // VP minimum programming to issue an interrupt at end of field !
            nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
            pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
            NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
            return NO_ERROR;
        }
        else
            // TS = next(CS)
            nTargetSurfId = pSurface->nNextSurfaceIdx;
    }
    else
#endif
    {
        // if autoflip, TS = next2(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
        if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
            nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
    }

    if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
        !((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
    {
        // Overlay Image n from CS
        NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage, dwSrcPitch, 0);
    }

    // if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
    if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
        pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;

    // Grab Image n in TS
    pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
    NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

    return NO_ERROR;
}

/*
==============================================================================
    
    NVPTransfer

    Description:    transfers content of video or vbi field to specified
                    buffer (usually system memory buffer)

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPTransfer(
    PVOID pContext,
    PNVP_DDTRANSFERININFO  pInInfo,
    PNVP_DDTRANSFEROUTINFO pOutInfo)
{
    PNVP_CONTEXT pVPEContext;
    PNVP_SURFACE_INFO pSurface = NULL;
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;

    DBGPRINT(DBGTRACE, "NVPTransfer()");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    if (pInInfo->dwTransferFlags & DDTRANSFER_NONLOCALVIDMEM)
        return DXERR_UNSUPPORTED;
    
    // we DO handle cancels for transfer buffers not "in progress" !
    if (pInInfo->dwTransferFlags & DDTRANSFER_CANCEL){
		pVPEContext->ulCap=FALSE;
        return NVPCancelTransfer(pVPEContext, pInInfo);
	}

    // determine polarity, TRUE for Even, FALSE for Odd !
    NVPGetSurface(pVPEContext, (U032)(((DDSURFACEDATA*) (pInInfo->lpSurfaceData))->fpLockPtr), &pSurface);
      if (pSurface == NULL)
        return DXERR_GENERIC;
    if (pSurface->dwFieldType == NVP_FIELD_ODD)
        pOutInfo->dwBufferPolarity = FALSE;
    else
        pOutInfo->dwBufferPolarity = TRUE;
    
    // queue request
    if (NVPAddTransfer(pVPEContext, pInInfo, !(pOutInfo->dwBufferPolarity)))
        return DXERR_GENERIC;
#if 0
    if (pVPEContext->nCurTransferIdx != -1)
    {
        pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
        // Recreate context dma for MDL
        NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
    }
#endif

      // launch a transfer here
    NVPCheckForLaunch(pVPEContext, pSurface);

    return DX_OK;
}

/*
==============================================================================
    
    NVPGetSurface

    Description:    looks for surface that has the specified pointer. pSurface
                    is set to NULL if no surface is found.


    Date:           Mar 18, 1999
    
    Author:         H. Azar

==============================================================================
*/
BOOL NVPGetSurface(
    PNVP_CONTEXT pVPEContext,
    U032 dwSurfPtr,
    PNVP_SURFACE_INFO *pSurface)
{
    int i;

    DBGPRINT(DBGTRACE, "NVPGetSurface()");

    *pSurface = NULL;

    // why VBI first ! well, this is most probably what we're transfering... kinda optimization !
    for (i = 0; i < pVPEContext->nNumVBISurf; i++)
    {
        if (pVPEContext->aVBISurfaceInfo[i].pVidMem == dwSurfPtr)
        {
            *pSurface = &(pVPEContext->aVBISurfaceInfo[i]);
            return FALSE;   // FALSE means VBI
        }
    }

    for (i = 0; i < pVPEContext->nNumVidSurf; i++)
    {
        if (pVPEContext->aVideoSurfaceInfo[i].pVidMem == dwSurfPtr)
        {
            *pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
            return TRUE;    // TRUE means VIDEO
        }
    }

    return FALSE;   // return something ! (pSurface is NULL anyway)
}

/*
==============================================================================
    
    NVP3RecreateContext

    Description:    if necessary, create context DMA for mem to mem object
                    PIO channel version.

    Date:           Mar 18, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVP3RecreateContext(
    PNVP_CONTEXT pVPEContext,
    PMDL pDestMDL)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pChan;
    NVOS09_PARAMETERS ntfParam;
    U032 dwStart;
    U032 dwLimit;
    int nFreeCount;

    pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);

    // first check to see if we can reuse the OLD context... since context creation is expensive.
    dwStart = (U032)(pDestMDL->lpMappedSystemVa);
    dwLimit = (pDestMDL->ByteCount) - 1;
    
    if (pVPEContext->bxfContextCreated)
    {
        // do not recreate if same context
        if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
            return DX_OK;
    }

#ifdef _NV_DPC
    // FIFO free count check up
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 4*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pChan, 5);
    }
    pVPEContext->nFreeCount = nFreeCount - (4*4);
#endif

    // free the old context first
    if (pVPEContext->bxfContextCreated)
    {
        pChan->subchannel[5].SetObject = NVP_M2M_OBJECT;
        pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#ifdef _NV_DPC
        // Do a software method flush here
        ntfParam.hObjectParent = pVPEContext->dwDeviceId;
        nFreeCount = pVPEContext->nFreeCount;
        while (nFreeCount < NV06A_FIFO_GUARANTEED_SIZE)
        {
            //RmInterrupt(&ntfParam);
            nFreeCount = NvGetFreeCount(pChan, 5);
        }
        pVPEContext->nFreeCount = nFreeCount - NV06A_FIFO_GUARANTEED_SIZE;
#endif
        RmFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

        pVPEContext->bxfContextCreated = FALSE;
    }
    
    // setup Notify Context
    if (RmAllocContextDma(
                    pVPEContext->hClient,
                    NVP_M2M_CONTEXT,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    dwStart,
                    dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "cannot allocate mem 2 mem context");
        return DXERR_GENERIC;
    }

    // set context of M2M object
    pChan->subchannel[5].SetObject  = NVP_M2M_OBJECT;
    pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = NVP_M2M_CONTEXT;

    pVPEContext->dwTransferCtxStart = dwStart;
    pVPEContext->dwTransferCtxSize = dwLimit;
    pVPEContext->bxfContextCreated = TRUE;

#endif // NVP_NV3

    return DX_OK;
}

/*
==============================================================================
    
    NVP3CheckForLaunch

    Description:    try to launch another mem transfer if engine not busy
                    (PIO version)

    Date:           Mar 18, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVP3CheckForLaunch(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface)
{
#ifdef NVP_NV3
    Nv03ChannelPio *pChan;
    PNVP_TRANSFER_BUFFER pTransfer;
    LPDDSURFACEDATA pSurfaceData;
    NVOS09_PARAMETERS ntfParam;
    NvNotification *aM2MNotifiers;
    PMDL pDestMDL;
    U032 dwOffsetStartByte;
    LONG lLength, lPitch, lCount;
    int nFreeCount;
    PNVP_SURFACE_INFO pSurf = NULL;

    DBGPRINT(DBGTRACE, "NVP3CheckForLaunch()");

    aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

    // is transfer in progress ?
    if ((aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS) ||
        // or no transfer request !?
        (pVPEContext->nCurTransferIdx == -1))
        return DXERR_GENERIC;

    // get a pointer to the VP pio channel
    pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);
    // which surface are we transferring from ?
    pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
    pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
    if (pSurface == NULL)
    {
        NVPGetSurface(pVPEContext, pSurfaceData->fpLockPtr, &pSurf);
        if (pSurf == NULL)
        {
            DBGPRINT(DBGERROR, "NVPCheckForLaunch() can't get pointer to surface");
            return DXERR_GENERIC;
        }
    }
    else
        pSurf = pSurface;

    // Recreate context dma for MDL
    NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
    
    // reset notifier status
    aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

#ifdef _NV_DPC
    //CHECKFREECOUNT(pMyNvChan,9*4);
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 9*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pChan, 5);
    }
    pVPEContext->nFreeCount = nFreeCount - (9*4);
#endif

    // start at given line
    dwOffsetStartByte = pSurf->dwOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

    // lLength and lPitch might not be the same (case of interleaved fields !!!)
    lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
    lLength = (pSurface->dwPreScaleSizeX)*(pSurfaceData->dwFormatBitCount >> 3);
    lPitch = pSurfaceData->lPitch;
            
    // SMAC@microsoft.com  :  Yes, you should transfer the end line.
    // Therefore, if we only wanted you to transfer a single line, start line would equal end line. 
    lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);

    if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
    {
        // if we want to invert things, then we should
        // negate the pitch and put the start offset at the end.
        
        dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
        lPitch = -lPitch;
    }

    pDestMDL = (PMDL)(pTransfer->pDestMDL);
    if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
    {
        DBGPRINT(DBGERROR, "NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count");
    //  lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
        lCount = pDestMDL->ByteCount / lLength;
    }

#ifdef _NV_DPC
    ntfParam.hObjectParent = pVPEContext->dwDeviceId;
    nFreeCount = pVPEContext->nFreeCount;
    while (nFreeCount < 8*4)
    {
        //RmInterrupt(&ntfParam);
        nFreeCount = NvGetFreeCount(pChan, 5);
    }
    pVPEContext->nFreeCount = nFreeCount - (8*4);
#endif

    // set mem to mem transfer object !
    pChan->subchannel[NVP_M2M_SUBCHANNEL].SetObject = NVP_M2M_OBJECT;
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetIn = dwOffsetStartByte;
    //pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = 0;
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchIn  = lPitch;   // use the pitch in so that we can do interleaved
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchOut = lLength;  // use line length on pitch out so that it squishes together
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineLengthIn = lLength;
    
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineCount    = lCount;
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.Format       =  ( 1 | (1 << 8));
    pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.BufferNotify = NV039_NOTIFY_WRITE_THEN_AWAKEN_1;

    pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;

#endif // NVP_NV3

    return DX_OK;
}

/*
==============================================================================
    
    NVPRecreateContext

    Description:    if necessary, create context DMA for mem to mem object
                    (DMA version)

    Date:           Apr 22, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPRecreateContext(
    PNVP_CONTEXT pVPEContext,
    PMDL pDestMDL)
{
    U032 dwStart;
    U032 dwLimit;

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
        return NVP3RecreateContext(pVPEContext, pDestMDL);

    // first check to see if we can reuse the OLD context... since context creation is expensive.
    dwStart = (U032)(pDestMDL->lpMappedSystemVa);
    dwLimit = (pDestMDL->ByteCount) - 1;
    
    if (pVPEContext->bxfContextCreated)
    {
        // do not recreate if same context
        if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
            return DX_OK;
    }

    // free the old context first
    if (pVPEContext->bxfContextCreated)
    {
        // free m2m dma context
        rmNVPFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

        pVPEContext->bxfContextCreated = FALSE;
    }
    
    // setup Notify Context
    if (rmNVPAllocContextDma(
                    pVPEContext->hClient,
                    NVP_M2M_CONTEXT,
                    NV01_CONTEXT_DMA_FROM_MEMORY,
                    0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                    0, // selector
                    dwStart,
                    dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
    {
        DBGPRINT(DBGERROR, "Cannot allocate mem 2 mem context");
        return DXERR_GENERIC;
    }

    pVPEContext->dwTransferCtxStart = dwStart;
    pVPEContext->dwTransferCtxSize = dwLimit;
    pVPEContext->bxfContextFlushed = FALSE;
    pVPEContext->bxfContextCreated = TRUE;

    return DX_OK;
}

/*
==============================================================================
    
    NVPCheckForLaunch

    Description:    try to launch another mem transfer if engine not busy
                    (DMA version)

    Date:           Apr 22, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPCheckForLaunch(
    PNVP_CONTEXT pVPEContext,
    PNVP_SURFACE_INFO pSurface)
{
    PNVP_TRANSFER_BUFFER pTransfer;
    LPDDSURFACEDATA pSurfaceData;
    NvNotification *aM2MNotifiers;
    PMDL pDestMDL;
    U032 dwOffsetStartByte;
    LONG lLength, lPitch, lCount;
    PNVP_SURFACE_INFO pSurf = NULL;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount, bVBICapture;

    // NV3 specific code
    if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
        return NVP3CheckForLaunch(pVPEContext, pSurface);

    DBGPRINT(DBGTRACE, "NVPCheckForLaunch()");

    aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);
	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

    // is transfer in progress ?
    if (aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
        return DXERR_GENERIC;

    // or no transfer request !?
    if (pVPEContext->nCurTransferIdx == -1) //|| !(pVPEContext->bxfContextCreated))
    {
        return DXERR_GENERIC;
    }

	//make sure surf hasn't been DMAed
	if(pTransfer->dwTransferStatus == NVP_TRANSFER_QUEUED){
		//DBGPRINTVALUE(DBGINFO, "Checkforlaunch- xfering=", pTransfer->dwTransferId);
		DBGPRINT(DBGINFO, "Checkforlaunch- xfering=");
	}else{
		//DBGPRINTVALUE(DBGINFO, "Checkforlaunch- surf is already xferred=", pTransfer->dwTransferId);
		DBGPRINT(DBGINFO, "Checkforlaunch- surf is already xferred=");
		return DXERR_GENERIC;
	}

    // which surface are we transferring from ?
    //pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
    pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
    if (pSurface == NULL)
    {
        NVPGetSurface(pVPEContext, pSurfaceData->fpLockPtr, &pSurf);
        if (pSurf == NULL)
        {
            DBGPRINT(DBGERROR, "NVPCheckForLaunch() can't get pointer to surface");
            return DXERR_GENERIC;
        }
    }
    else
        pSurf = pSurface;

    // reset notifier status
    aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

    // is it a raw8 (vbi) capture ?
    bVBICapture = (pSurfaceData->dwFormatFourCC == mmioFOURCC('R','A','W','8'));

    // start at given line
    dwOffsetStartByte = pSurf->dwOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

    // lLength and lPitch might not be the same (case of interleaved fields !!!)
    //////// NOTE: this should really be pSurfaceData->dwWidth instead of pSurf->dwPreScaleSizeX but the client
    ///            doesn't know we are prescaling... because of a bug in DShow OverlayMixer, we are using the 
    ///            MediaEngine prescaler behind the back of DirectShow/DxApi... a correction to the surface
    ///            width is needed here !
    //lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
    lLength = (bVBICapture) ? pSurfaceData->dwWidth : pSurf->dwPreScaleSizeX;
    lLength *= (pSurfaceData->dwFormatBitCount >> 3); // convert to bytes !
    lPitch = pSurfaceData->lPitch;
            
    // SMAC@microsoft.com  :  Yes, you should transfer the end line.
    // Therefore, if we only wanted you to transfer a single line, start line would equal end line. 
    lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);

    /// H.AZAR: 05/02/2000    
    /// NOTE: the following if-statement is a hack since DirectShow is unable of specifying single field capture, 
    ///       so we try to double the pitch to skip the bottom field and always return the top field...
    ///       An alternative to this hack would be for the client app to always capture full frame size (two fields)
    ///       and extract the field it needs...
    ///       PROS of using this hack:
    ///           - transfer only one field so no extra memory/bandwidth required for transfering a full frame
    ///           - no feathering effect or prescaling effect since only transfering the top field
    ///       CONS:
    ///           - it is a hack !
    ///           - if DShow get fixed one day, we will have to put extra logic to deal with old code !
    ///           - always return top field
    ///
/*
    //currently any height < 288 is single field
    //if it's single field, double the pitch (skipping bottom field)
    if (!bVBICapture && (lCount <= 288))
    {
        lPitch *= 2;
    }
*/
    //when capturing, src height is (pVPEContext->nvpOverlay).dwDecoderHeight
	//if capture height <= src height, it is single field capture
	if (!bVBICapture && (lCount <= (LONG)(pVPEContext->dwDecoderHeight)))
    {
        lPitch *= 2;
    }

    ////
    ////


    if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
    {
        // if we want to invert things, then we should
        // negate the pitch and put the start offset at the end.
        
        dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
        lPitch = -lPitch;
    }

    pDestMDL = (PMDL)(pTransfer->pDestMDL);

	//recreating a context dma for every captured frame causes weird behavior with ddraw.
	//changed to xfering to a fix surf in sys mem and do a sys 2 sys xfer in nvpchecktransferstatus
/*
    // if necessary, recreate context for new transfer buffer
    if (NVPRecreateContext(pVPEContext, pDestMDL) != DX_OK)
    {
        DBGPRINT(DBGERROR, "NVPCheckForLaunch() - error, can't create context dma for new transfer buffer !");
        return DXERR_GENERIC;
    }
*/


    if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
    {
        DBGPRINT(DBGERROR, "NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count");
    //  lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
        lCount = pDestMDL->ByteCount / lLength;
    }

    // get a pointer to the VPE dma channel
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(20);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_OUT, NVP_M2M_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_IN, dwOffsetStartByte);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_OUT, 0);    //(unsigned long)pTransfer->DestMDL->ByteOffset
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_IN, lPitch);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_OUT, lLength);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_LENGTH_IN, lLength);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_COUNT, lCount);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_FORMAT, ( 1 | (1 << 8)));
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_BUFFER_NOTIFY, NV039_NOTIFY_WRITE_THEN_AWAKEN_1);

    pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;
    // go !
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    return DX_OK;
}


/*
==============================================================================
    
    NVPGetTransferStatus

    Description:    returns status of buffer transfer (from video mem to
                    system mem)

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPGetTransferStatus(
    PVOID pContext,
    PVOID pNotUsed,
    PNVP_DDGETTRANSFEROUTINFO pOutInfo)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;
    PNVP_TRANSFER_BUFFER pTransfer;
    PNVP_CONTEXT pVPEContext;

    DBGPRINT(DBGTRACE, "NVPGetTransferStatus()");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    if (pVPEContext->nRecentTransferIdx == NVP_EOQ)
        return DXERR_GENERIC;

    pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nRecentTransferIdx]);

    if (pTransfer->dwTransferStatus == NVP_TRANSFER_DONE)
    {
        // return MS transfer ID
        pOutInfo->dwTransferID = pTransfer->dwTransferId;
        NVPRemoveTransfer(pVPEContext, pVPEContext->nRecentTransferIdx);

    }
    else
        return DXERR_GENERIC;

    return DX_OK;
}

/*
==============================================================================
    
    NVPAddTransfer

    Description:    adds transfer buffer to queue

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPAddTransfer(
    PNVP_CONTEXT pVPEContext,
    PNVP_DDTRANSFERININFO pInInfo,
    BOOL bIsOddField)
{
    PNVP_TRANSFER_BUFFER pNewTransfer;
    int i = pVPEContext->nCurTransferIdx;

    DBGPRINT(DBGTRACE, "NVPAddTransfer()");

    if (pVPEContext->nNumTransfer >= NVP_MAX_TRANSFER_BUFFERS)
        return DXERR_GENERIC;
    
    while (i != NVP_EOQ)
    {
        if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
            // a transfer request with same ID is already queued !!!
            return DXERR_GENERIC;
        else
            i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
    }

        
    // queue new transfer request !
    i = pVPEContext->nLastTransferIdx;
    pVPEContext->nLastTransferIdx = ++(pVPEContext->nLastTransferIdx) % NVP_MAX_TRANSFER_BUFFERS;
    pNewTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nLastTransferIdx]);
    if (i != NVP_EOQ)
        pVPEContext->aTransferBuffers[i].nNextTransferIdx = pVPEContext->nLastTransferIdx;
    pNewTransfer->nNextTransferIdx = NVP_EOQ;
    pNewTransfer->nPrevTransferIdx = i;
    (pVPEContext->nNumTransfer)++;
	if(pVPEContext->nNumTransfer){
		pVPEContext->ulCap=TRUE;
	}
    if (pVPEContext->nCurTransferIdx == NVP_EOQ)
        pVPEContext->nCurTransferIdx = pVPEContext->nLastTransferIdx;

    // DDTRANSFER_HALFLINES indicates that, due to half line issues, the odd field contains an
    // extra line of useless data at the top that the driver must account for
    if ((pInInfo->dwTransferFlags & DDTRANSFER_HALFLINES) && (bIsOddField))
    {
        pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine) + 1;
        pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine) + 1;
    }
    else
    {
        pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine);
        pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine);
    }

    // copy input data...
    pNewTransfer->pSurfaceData = (ULONG) (pInInfo->lpSurfaceData);
    pNewTransfer->dwTransferId = pInInfo->dwTransferID;
    pNewTransfer->dwTransferFlags = pInInfo->dwTransferFlags;
    pNewTransfer->pDestMDL = (ULONG) (pInInfo->lpDestMDL);
    pNewTransfer->dwTransferStatus = NVP_TRANSFER_QUEUED;

    return DX_OK;
}


/*
==============================================================================
    
    NVPCancelTransfer

    Description:    cancels transfer request before it gets processed

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPCancelTransfer(
    PNVP_CONTEXT pVPEContext,
    PNVP_DDTRANSFERININFO pInInfo)
{
    PNVP_TRANSFER_BUFFER pTransfer = NULL;
    int i = pVPEContext->nCurTransferIdx;

    DBGPRINT(DBGTRACE, "NVPCancelTransfer()");

    // look for transfer in queue
    while (i != NVP_EOQ)
    {
        if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
        {
            pTransfer = &(pVPEContext->aTransferBuffers[i]);
            break;
        }
        i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
    }

    if ((pTransfer) && (pTransfer->dwTransferStatus == NVP_TRANSFER_QUEUED))
        return NVPRemoveTransfer(pVPEContext, i);
    else
        return DXERR_GENERIC;
}

/*
==============================================================================
    
    NVPRemoveTransfer

    Description:    removes transfer request from queue

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPRemoveTransfer(
    PNVP_CONTEXT pVPEContext,
    int nTransferIdx)
{
    PNVP_TRANSFER_BUFFER pTransfer = &(pVPEContext->aTransferBuffers[nTransferIdx]);

    DBGPRINT(DBGTRACE, "NVPRemoveTransfer()");

    // check limits
    if (nTransferIdx == pVPEContext->nCurTransferIdx)
        pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;
    else if (nTransferIdx == pVPEContext->nLastTransferIdx)
        pVPEContext->nLastTransferIdx = pTransfer->nPrevTransferIdx;
    // reset values
    pTransfer->dwTransferId = NVP_UNDEF;
    pTransfer->dwTransferStatus = NVP_TRANSFER_FREE;
    // re-map indices
    if (pTransfer->nPrevTransferIdx != NVP_EOQ)
    {
        pVPEContext->aTransferBuffers[pTransfer->nPrevTransferIdx].nNextTransferIdx = pTransfer->nNextTransferIdx;
        pTransfer->nPrevTransferIdx = NVP_EOQ;
    }
    if (pTransfer->nNextTransferIdx != NVP_EOQ)
    {
        pVPEContext->aTransferBuffers[pTransfer->nNextTransferIdx].nPrevTransferIdx = pTransfer->nPrevTransferIdx;
        pTransfer->nNextTransferIdx = NVP_EOQ;
    }

    // one down !
    (pVPEContext->nNumTransfer)--;

    return DX_OK;
}
    

/*
==============================================================================
    
    NVPCheckTransferStatus

    Description:    checks for transfer status. Calls MS callback.

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPCheckTransferStatus(
    PHW_DEVICE_EXTENSION pHwDevExt)
{
    NvNotification *aM2MNotifiers;
    PNVP_CONTEXT pVPEContext;
    PNVP_TRANSFER_BUFFER pTransfer;
    U032 status;

    DBGPRINT(DBGTRACE, "nvpecore: NVPCheckTransferStatus()");

    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[0]);

    aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

    status = aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status;
    pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
/*
    if (status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
        // still in progress
        return FALSE;
    else if (status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS)
    {
        pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

        // finished ok!
        if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
            pTransfer->dwTransferStatus = NVP_TRANSFER_DONE;

        pVPEContext->nRecentTransferIdx = pVPEContext->nCurTransferIdx;
    }
*/
	if (	status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS ||
		status == NV039_NOTIFICATION_STATUS_IN_PROGRESS){	//notifier may already been reset 
		
		//logging 
		if(status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS){
			//DBGPRINTVALUE(DBGINFO, "ChkXferStatus - m2m status success", pTransfer->dwTransferId);
			DBGPRINT(DBGINFO, "ChkXferStatus - m2m status success");

		}else{
			//DBGPRINTVALUE(DBGINFO, "ChkXferStatus - m2m status in prog", pTransfer->dwTransferId);
			DBGPRINT(DBGINFO, "ChkXferStatus - m2m status in prog");
		}
		//pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

		//do Sys 2 Sys copy now
		//intermittent page faults were generated when Dst surf is no longer valid.
		//use ulCap=false when DDTRANSFER_CANCEL is sent to cancel sys 2 sys xfer.
		if(pVPEContext->ulCap)		
		{
			DWORD *pSrc;
			DWORD *pDst;
			//DWORD *pdw;
			DWORD dwLimit=((((PMDL)(pTransfer->pDestMDL))->ByteCount) - 1);///3;
			DWORD i;

			if(dwLimit < BUFSIZE){
				pSrc=(DWORD *)pVPEContext->pSysBuf;
				pDst=(DWORD *)(((PMDL)(pTransfer->pDestMDL))->lpMappedSystemVa);
				for(i=0; i<dwLimit; i+=4){
					*pDst=*pSrc;
					++pDst;
					++pSrc;
				}
			}

		
		}else{
			DBGPRINT(DBGERROR, "NOT xfering\n");
		}
        // finished ok!
        if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
            pTransfer->dwTransferStatus = NVP_TRANSFER_DONE;

        pVPEContext->nRecentTransferIdx = pVPEContext->nCurTransferIdx;

	}else{
        
		DBG_PRINT_STRING_VALUE(DBGERROR, "NVPCheckTransferStatus() - memory transfer failed error ", status);

        //pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

        // finished with an error !
        if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
            pTransfer->dwTransferStatus = NVP_TRANSFER_FAILURE;

    }

    // move to next transfer in queue (*** not sure whether I should do this even when an error had occured ?!?!?!?)
    pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;
/*
    // we pass on the interrupt
#if 0
    if (pHwDevExt->IRQCallback) //&& (pHwDevExt->dwIRQSources & DDIRQ_BUSMASTER))
    {
          PDX_IRQDATA pIRQData;
        pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
        pIRQData->dwIrqFlags |= DDIRQ_BUSMASTER;
        ((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
    }
#else
      kmvtNVPCallbackDxApi((PVOID)pHwDevExt, DDIRQ_BUSMASTER);
#endif
*/
    return DX_OK;
}


/*
==============================================================================
    
    NVPCompleteTransfer

    Description:    checks for transfer status. Calls MS callback.

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
DWORD NVPCompleteTransfer(PVOID pHwDevExtension)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) pHwDevExtension;
    PNVP_CONTEXT pVPEContext;

    // call MS callback if done with transfer
    if (NVPCheckTransferStatus(pHwDevExt) == DX_OK)
    {
        // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
        pVPEContext = &(pHwDevExt->avpContexts[0]);
        //  transfer next in queue !
        NVPCheckForLaunch(pVPEContext, NULL);

		// we pass on the interrupt
#if 0
		if (pHwDevExt->IRQCallback) //&& (pHwDevExt->dwIRQSources & DDIRQ_BUSMASTER))
		{
			PDX_IRQDATA pIRQData;
			pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
			pIRQData->dwIrqFlags |= DDIRQ_BUSMASTER;
			((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
		}
#else
		kmvtNVPCallbackDxApi((PVOID)pHwDevExt, DDIRQ_BUSMASTER);
#endif

        return DX_OK;
    }

    return DXERR_GENERIC;
}

#ifdef _WIN32_WINNT
/*
==============================================================================
    
    NVPTransferNotify

    Description:    callback routine for vbi/video transfer code.

    Date:           Mar 16, 1999
    
    Author:         H. Azar

==============================================================================
*/
void NVPTransferNotify(
    PVOID pHwDevExtension)
{
    NVPCompleteTransfer(pHwDevExtension);
}
#endif


/*
==============================================================================
    
    NVPPreScale

    Description:    Prescales YUV422 surface.  The new width and height are
                    returned.  If this routine does the field prescaling, it
                    flips off the field flags to indicate that the flip
                    should not bob.

    Date:           Nov 04, 1999
    
    Author:         H. Azar (based on VPP code from Sandy Lum)

==============================================================================
*/
BOOL NVPPreScale(
    PNVP_CONTEXT  pVPEContext,
    PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwSrcOffset,
    DWORD         dwSrcPitch,
    DWORD         dwDstOffset,
    DWORD         dwDstPitch,
    DWORD         *pWidth,
    DWORD         *pHeight,
    DWORD         *pField)
{
    DWORD preScaleDeltaX;
    DWORD preScaleDeltaY;
    DWORD preScaleOverlay;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwOutSizeX, dwOutSizeY, dwOutFormat;
    DWORD dwInPitch, dwInOffset, dwInPoint, dwInSize;
    BOOL isField;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;

    if (pOverlayInfo->dwOverlayDstWidth == 0 ||
        pOverlayInfo->dwOverlayDstHeight == 0)
        return FALSE;

    isField = IS_FIELD(*pField);

    if (pOverlayInfo->dwOverlayDstWidth <= 1)
    {
        dwDeltaX = 0x100000;
    }
    else
    {
        dwDeltaX = (pOverlayInfo->dwOverlaySrcWidth - 1) << 16;
        dwDeltaX /= pOverlayInfo->dwOverlayDstWidth - 1;
        dwDeltaX <<= 4;
    }

    if (pOverlayInfo->dwOverlayDstHeight <= 1)
    {
        dwDeltaY = 0x100000;
    }
    else
    {
        dwDeltaY = (pOverlayInfo->dwOverlaySrcHeight - 1) << 16; //(*pHeight - 1) << 16; //
        // err on the side of caution, need to do this because of the 1/4 pixel offset
        // ????? why is NV4 different from NV5?  NV4 HW must be a little wonky
        if (pVPEContext->dwChipId <= NV_DEVICE_VERSION_4) {
            dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 2;
        } else {
            dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 1;
        }
        dwDeltaY <<= 4;
    }

    preScaleOverlay = 0;

    if (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale))
    {
        // use X prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = (pOverlayInfo->dwOverlayDstWidth + 2) & ~1;
        preScaleDeltaX = dwDeltaX;
        pOverlayInfo->dwOverlayDeltaX = 0x100000;
    } else {
        // use X overlay scaler
        dwOutSizeX = (*pWidth + 2) & ~1;
        preScaleDeltaX = 0x100000;
        pOverlayInfo->dwOverlayDeltaX = dwDeltaX;
    }

///// Until I get 'pOverlayInfo->regOverlayMode' logic implememted, always use Y prescaler... otherwise video will look aweful on NV4/5 in 'bob from non-interleaved' mode !
#ifndef NVP_CHECK_REGKEY
    // use Y prescaler
    preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
    dwOutSizeY = pOverlayInfo->dwOverlayDstHeight;
    preScaleDeltaY = dwDeltaY;
    pOverlayInfo->dwOverlayDeltaY = 0x100000;
#else
    if ((pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale)) ||
        (pOverlayInfo->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE))
    {
        // use Y prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = pOverlayInfo->dwOverlayDstHeight;
        preScaleDeltaY = dwDeltaY;
        pOverlayInfo->dwOverlayDeltaY = 0x100000;
    }
    else
    {
        // use Y overlay scaler
        dwOutSizeY = *pHeight;
        preScaleDeltaY = 0x100000;
        pOverlayInfo->dwOverlayDeltaY = dwDeltaY;
    }
#endif //#ifdef NVP_CHECK_REGKEY

    if ((pVPEContext->dwChipId < NV_DEVICE_VERSION_10) || (preScaleOverlay & NV_PRESCALE_OVERLAY_Y))
    {
        if (isField)
        {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            if (*pField & VPP_INTERLEAVED)
                preScaleDeltaY >>= 1;
        }
    }

    if (preScaleOverlay == 0)
        return FALSE;

    dwInSize = asmMergeCoords(*pWidth, *pHeight);
    dwInPoint = 0;
    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField && (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        if (*pField & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            *pHeight >>= 1;
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (*pField & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInPoint = 0xFFFC0000;
            } else {
                dwInPoint = 0x00040000;
            }
        }
    }

//    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
//    } else {
//        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
//    }

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(38);

    // program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT , NVP_DVD_SUBPICTURE_OBJECT); // pVPEContext->dwDVDSubPicObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_POINT, 0);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_SIZE, (asmMergeCoords(dwOutSizeX, dwOutSizeY)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_FORMAT, ((dwOutFormat << 16) | dwDstPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_OFFSET, dwDstOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_FORMAT, ((dwOutFormat << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_POINT, dwInPoint);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_FORMAT, ((NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_POINT, 0);

    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NOTIFY, NV038_NOTIFY_WRITE_THEN_AWAKEN);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NO_OPERATION, 0);

    // this forces the H/W to serialize
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    // return changes in state
    if (//(pDriverData->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
        (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        // with HQVUp, we no longer use the overlay to bob
        *pField &= ~(VPP_ODD | VPP_EVEN | VPP_BOB | VPP_INTERLEAVED);
    }

    *pHeight = dwOutSizeY;
    *pWidth  = dwOutSizeX;

    return TRUE;
}

/*
==============================================================================
    
    NVPFlip

    Description:    Flip YUV422 surface.

    Date:           Nov 04, 1999
    
    Author:         H. Azar (based on VPP code from Sandy Lum)

==============================================================================
*/
BOOL NVPFlip(
    PNVP_CONTEXT  pVPEContext,
    PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset
    DWORD         dwPitch,         // source pitch
    DWORD         dwWidth,         // source width
    DWORD         dwHeight,        // source height
    DWORD         dwIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;
    DWORD dwPointIn, dwOverlayFormat, dwSizeIn;
    DWORD dwDeltaX, dwDeltaY;
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;

    DBGPRINT(DBGTRACE, "NVPFlip");

    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;  // << 3 insteed of << 4 because YUYV is 2 bytes wide
    dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));
    dwSizeIn += dwPointIn;
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    // Remember this in case we get a SetOverlayPosition call
    //pOverlayInfo->dwOverlaySrcOffset = dwOffset;
    //pOverlayInfo->dwOverlaySrcPitch = dwPitch;

    dwDeltaX = pOverlayInfo->dwOverlayDeltaX;
    dwDeltaY = pOverlayInfo->dwOverlayDeltaY;

    if (IS_FIELD(dwFlags)) {
        if (dwFlags & VPP_INTERLEAVED) {
            // if (dwFlags & VPP_ODD) {
            if (dwFlags & VPP_EVEN) {
                dwOffset += dwPitch;
            }
            dwPitch <<= 1;
            dwHeight >>= 1;
            dwDeltaY >>= 1;
        }
        if (dwFlags & VPP_BOB) {
            // if (dwFlags & VPP_ODD) {
            if (dwFlags & VPP_EVEN) {
                dwPointIn += 0xFFFC0000;
            } else {
                dwPointIn += 0x00040000;
            }
        }
    }

    // replace old surface pitch value with current pitch value
    dwOverlayFormat = pOverlayInfo->dwOverlayFormat;
    dwOverlayFormat &= 0xFFFF0000;
    dwOverlayFormat |= dwPitch;
    dwOverlayFormat |= (1 << 31);

/*

    if (pVPEContext->dwVPConnectFlags & NVP_CONNECT_HDTV) // progressive (non-interlaced) and 16bit VIP
        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT709 << 24);
*/
    if (dwIndex & 0x1) {
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;
    } else {
        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
    }

    // program overlay to flip
    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
    NVP_DMAPUSH_CHECK_FREE_COUNT(20);

    // program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_IN(dwIndex), dwSizeIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstWidth, pOverlayInfo->dwOverlayDstHeight)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_IN(dwIndex), dwPointIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstX, pOverlayInfo->dwOverlayDstY)));

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_OFFSET(dwIndex), dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_COLORKEY(dwIndex), pOverlayInfo->dwOverlayColorKey);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DU_DX(dwIndex), dwDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DV_DY(dwIndex), dwDeltaY);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_FORMAT(dwIndex), dwOverlayFormat);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    return TRUE;
}

//---------------------------------------------------------------------------
// vddPrescaleAndFlip
//
//      VPE implementation of selected parts of DDRAW's VPP pipe.  Only
//      prescaling and flip are performed.
//

/*
==============================================================================
    
    NVPPrescaleAndFlip

    Description:    VPE implementation of selected parts of DDRAW's VPP pipe.
                    Only prescaling and flip are performed.

    Date:           Nov 04, 1999
    
    Author:         H. Azar (based on VPP code from Sandy Lum)

==============================================================================
*/

#define NEXT_SURFACE { \
            dwSrcOffset = dwDstOffset;  \
            dwSrcPitch = dwDstPitch;    \
            dwDstOffset = dwNextOffset; \
            dwDstPitch = dwNextPitch;   \
            dwNextOffset = dwSrcOffset; \
            dwNextPitch = dwSrcPitch;   \
            dwOpCount++;                \
        }

BOOL NVPPrescaleAndFlip(
    PNVP_CONTEXT  pVPEContext,
    PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset
    DWORD         dwPitch,         // source pitch
    DWORD         dwOvIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
    DWORD dwHeight, dwWidth, i = 0;
    DWORD dwSrcOffset, dwSrcPitch;
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwNextOffset, dwNextPitch;
    DWORD dwOpCount;
    DWORD dwWorkSurfaces;
    BOOL  doXPreScale, doYPreScale, doPreScale;
    BOOL  isDownScale;
    DWORD dwRoundX, dwRoundY;
    DWORD vppExec;
    BOOL  isField;
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;


    

#if 0 //#ifdef DEBUG
    char debugstr[256];

    debugstr[0] = '\0';
    if (dwFlags & VPP_ODD)          strcat(debugstr, "odd  ");
    if (dwFlags & VPP_EVEN)         strcat(debugstr, "even ");
    if (dwFlags & VPP_BOB)          strcat(debugstr, "bob ");
    if (dwFlags & VPP_INTERLEAVED)  strcat(debugstr, "int ");
    if (dwFlags & VPP_VIDEOPORT)    strcat(debugstr, "vp ");
    if (dwFlags & VPP_WAIT)         strcat(debugstr, "wait ");
    if (dwFlags & VPP_OPTIMIZEFLIP) strcat(debugstr, "opt ");
    strcat(debugstr, "REQ: ");
    if (dwFlags & VPP_CONVERT)      strcat(debugstr, "cvt ");
    if (dwFlags & VPP_SUBPICTURE)   strcat(debugstr, "sp ");
    if (dwFlags & VPP_PRESCALE)     strcat(debugstr, "ps ");
    if (dwFlags & VPP_COLOURCONTROL) strcat(debugstr, "cc ");
    if (dwFlags & VPP_TEMPORAL)     strcat(debugstr, "tf ");
    if (dwFlags & VPP_DEINTERLACE)  strcat(debugstr, "df ");
#endif

    //assert(pDriverData);

    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    // find out if overlay hardware is busy, if so return "overlay busy" error code.
    // Perhaps check a "number of overlay buffers programmed" count.  When this count is less
    // than 2, the overlay hardare is not busy and when it's equal to 2, the hardwar is busy.
    // If it's not busy, then program it up here and increment the count.  Then use a kernel
    // callback to decrement this count upon buffer complete.
    //

    DWORD dwIndex = pOverlayInfo->dwOverlayBufferIndex & 1;

    DBGPRINT(DBGTRACE, "NVPPrescaleAndFlip");

#if 0 //def _NVP_DTRACE
    DTRACE(0xdead0001);
    DTRACE_CYCLE_DELTA();
    DTRACE(dwOffset);
    DTRACE(dwIndex);

//    return TRUE;
#endif

/*
        while ((pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS) && (i < VDD_VPP_TIME_OUT))
            i++;
        // timed-out... stop the appropriate buffer and return error
        if (i >= VDD_VPP_TIME_OUT)
*/


    dwWorkSurfaces = pOverlayInfo->dwExtra422NumSurfaces;
    vppExec = 0;
    dwOpCount = 0;
    dwSrcOffset = dwOffset;
    dwSrcPitch = dwPitch;
    dwDstOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index];
    dwDstPitch = pOverlayInfo->dwExtra422Pitch;
    dwNextOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index + 1];
    dwNextPitch = pOverlayInfo->dwExtra422Pitch;

    isField = IS_FIELD(dwFlags);

    doXPreScale = (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale));
    doYPreScale = (pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale));

    if (pVPEContext->dwChipId < NV_DEVICE_VERSION_10) {
        // NV4/5 also prescales:
        //  - all BOBed fields
        //  - vertical upscales when HQVUp is enabled
        doYPreScale = TRUE; //doYPreScale || isField; //|| (pOverlayInfo->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)
    }

    doPreScale = (dwFlags & VPP_PRESCALE) &&
                 (doXPreScale || doYPreScale);

    isDownScale = FALSE;
    if (doPreScale)
    {
        DWORD dwSrcArea, dwDstArea;

        dwSrcArea = pOverlayInfo->dwOverlaySrcHeight * pOverlayInfo->dwOverlaySrcWidth;
        if ((dwFlags & (VPP_ODD | VPP_EVEN)) && (dwFlags & VPP_INTERLEAVED))
        {
            // bob mode
            dwSrcArea >>= 1;
        }
        dwDstArea = pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayDstWidth;
        if (dwSrcArea > dwDstArea)
        {
            isDownScale = TRUE;
        }
    }

    if (dwWorkSurfaces < 2) {
        // no work surfaces, can't do anything
        doPreScale = FALSE;
    }

    // adjust for the subrectangle
    dwRoundX = pOverlayInfo->dwOverlaySrcX & 0x1;
    dwRoundY = pOverlayInfo->dwOverlaySrcY & 0x1;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcY & ~0x1) * dwSrcPitch;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcX & ~0x1) << 1;   // always YUV422
    dwWidth = pOverlayInfo->dwOverlaySrcSize & 0xFFFF;
    dwHeight = pOverlayInfo->dwOverlaySrcSize >> 16;
    if (dwWidth & 1)
        dwWidth += 1;
    if (dwRoundY)
        dwHeight += 1;

    // do the prescaling now
    if (doPreScale)
    {
        if (NVPPreScale(pVPEContext, pOverlayInfo,
                        dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, &dwWidth, &dwHeight,
                        &dwFlags)) {
            NEXT_SURFACE;
            vppExec |= VPP_PRESCALE;
        }
    }

    if (dwRoundY)
    {
        dwSrcOffset += dwSrcPitch;
        dwHeight -= 1;
    }

//    if (dwRoundX)
//        dwWidth -= 1;

#ifdef VPEFSMIRROR
	// do FS Mirror
    if (pVPEContext->dwFsMirrorOn)
	{   
        if(NVPFsMirror(pVPEContext, pOverlayInfo, dwSrcOffset, dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFlags)
           == NO_ERROR)
        {
            if (NVPFsFlip(pVPEContext, pVPEContext->nFSFlipIdx) 
                == NO_ERROR)
            {
             pVPEContext->nFSFlipIdx ^= 1;  // success, switch to other buffer            
            }        
        // move to next surface here            
        pVPEContext->nFSFlipSurfIdx = (pVPEContext->nFSFlipSurfIdx + 1) % pVPEContext->nNumFSSurf;
        }
	}
   
#endif

    // drop field if previous one is still being drawn (same overlay buffer) !
    if (pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS){
        DBGPRINT(DBGWARN, "     Overlay still busy. Previous one is still being drawn");
    }
    else {
    // always do the flip, even if we are not flipping
    if (NVPFlip(pVPEContext, pOverlayInfo, dwSrcOffset,
                dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFlags))
    {
        pOverlayInfo->dwOverlayBufferIndex ^= 1;
        if (dwWorkSurfaces == 0)
        {
            pOverlayInfo->dwExtra422Index = 0;
        }
        else if (dwWorkSurfaces <= 3)
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 1) % dwWorkSurfaces;
        }
        else
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 2) % dwWorkSurfaces;
        }
    }
    else
    {
        return FALSE;
    }
    }



    return TRUE;
}

/*
==============================================================================
    
    NVPIsVPEEnabled

    Description:    checks registry key VPEENABLE if set to 0 (disable)
                    return pCmdObj->dwPortId = 1 if enabled (default)
                           pCmdObj->dwPortId = 0 if disabled

    Date:           Feb 04, 2000
    
    Author:         H. Azar

==============================================================================
*/
VP_STATUS NVPIsVPEEnabled(
    PHW_DEVICE_EXTENSION pHwDevExt,
    NVP_CMD_OBJECT *pInCmdObj,
    NVP_CMD_OBJECT *pOutCmdObj)
{
    PNVP_CONTEXT pVPEContext;
    
    // get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
    pVPEContext = &(pHwDevExt->avpContexts[pInCmdObj->dwPortId]);

    // copy pointer to shared flag
    pVPEContext->pOvrRing0FlipFlag = pInCmdObj->pOvrRing0FlipFlag;

#ifdef _WIN32_WINNT
    // check flag (previously read from registry in function FindAdapter())
    pOutCmdObj->dwPortId = (pHwDevExt->dwVPEEnabled) ? 1 : 0;
#endif

    return NO_ERROR;
}

VP_STATUS NVPFlushChannel(
    PNVP_CONTEXT pVPEContext)
{
    Nv4ControlDma *pDmaChannel;
    U032 nvDmaCount;
    NvNotification *pavpNotifiers;
    U032    count=10000;
    
    DBGPRINT(DBGTRACE, "NVPFlushChannel");

    pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;


#define USE_M2M_OBJECT 
#ifdef USE_M2M_OBJECT

    pavpNotifiers = (NvNotification *)pVPEContext->axfNotifiers;
    (pavpNotifiers[NV039_NOTIFIERS_NOTIFY]).status=NV039_NOTIFICATION_STATUS_IN_PROGRESS;
    // send NO-OP thru
    NVP_DMAPUSH_CHECK_FREE_COUNT(10);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT , NVP_M2M_OBJECT);
    pDmaChannel->Put = nvDmaCount << 2;

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_NOTIFY, NV039_NOTIFY_WRITE_ONLY); 
    pDmaChannel->Put = nvDmaCount << 2;

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_NO_OPERATION, 0x00000000); 
    pDmaChannel->Put = nvDmaCount << 2;
/*
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT , NVP_M2M_OBJECT);
    //NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_NOTIFIES, NVP_M2M_NOTIFIER);
    //NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_IN, NVP_M2M_FROM_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_NOTIFY, NV039_NOTIFY_WRITE_ONLY); 
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_NO_OPERATION, 0x00000000); 

    pDmaChannel->Put = nvDmaCount << 2;
*/
    pVPEContext->nvDmaCount = nvDmaCount;

    while ( pavpNotifiers[NV039_NOTIFIERS_NOTIFY].status == 
                            NV04D_NOTIFICATION_STATUS_IN_PROGRESS && (--count));

    if(!count){
        DBGPRINT(DBGWARN, "Timeout. Unable to flush channel!!!");
    }

#endif

//#define USE_VID_DEC_OBJECT

#ifdef USE_VID_DEC_OBJECT
    ////////////////////////////////////////////////
    // reset notifiers
    //pavpNotifiers = &(((NvNotification *)(pVPEContext->avpNotifiers))[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)]);

    //pavpNotifiers->status = NV04D_NOTIFICATION_INFO16_FIELD_NOT_STARTED;//NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    pavpNotifiers = (NvNotification *)pVPEContext->avpNotifiers;
    (pavpNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)]).status=NV04D_NOTIFICATION_STATUS_IN_PROGRESS;//NV04D_NOTIFICATION_INFO16_FIELD_NOT_STARTED;
    // send NO-OP thru
    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_NOTIFY, NV04D_NOTIFY_WRITE_ONLY); 
    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_NO_OPERATION, 0x00000000); //not implemented
    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_NOTIFIES, 
    //                                  NVP_EXTERNAL_DECODER_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_GET_IMAGE_OFFSET_NOTIFY(0), 
                                        NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY); 
    pDmaChannel->Put = nvDmaCount << 2;
    pVPEContext->nvDmaCount = nvDmaCount;

    while ( ((pavpNotifiers[NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(0)]).status) == 
                            NV04D_NOTIFICATION_STATUS_IN_PROGRESS  && (--count));

    if(!count){
        DBGPRINT(DBGWARN, "Timeout. Unable to flush channel!!!");
    }

#endif

    return NO_ERROR;
}

#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\ESCAPE.H ===
/*****************************************************************************
 *                                                                           *
 *                                 ESCAPE.H                                  *
 *                                                                           *
 *    A file to gather all the miscellaneous Escape() codes implemented in   *
 *    the GDI driver.                                                        *
 *                                                                           *
 *                 Copyright (C) 1999, Nvidia Coporation                     *
 *                                                                           *
 *                                                                           *
 * Any escape that begins NV_ESC_XXX or GN_ESC_XXX can be changed since      *
 * these are private escapes between different driver components. Any other  *
 * escapes are system defined values and shouldn't be changed.               *
 *****************************************************************************/

#ifndef _ESCAPE_H_
#define _ESCAPE_H_

//*****************************************************************************
// Pulled from hwspec/code/hwcntrl.asm

#define NV_ESC_DVD_MACROVISION_CMD              0x6979

#define     MACROVISION_OFF                     0
#define     MACROVISION_AGC_ONLY                1
#define     MACROVISION_TWO_STRIPES_PLUS_AGC    2
#define     MACROVISION_FOUR_STRIPES_PLUS_AGC   3

//*****************************************************************************
// Hide these for WINNT miniport builds to avoid conflict with nv4_ref.h

#ifndef WINNT
#define     NV_PRAMDAC_TEST_CONTROL             0x680608
#define     NV_PRAMDAC_CHECKSUM                 0x68060C
#endif

    typedef struct _tagMACROVISION_INFO {
        unsigned long   dwMacrovisionNavigatorID;
        unsigned long   dwMacrovisionData;
    }   MACROVISION_INFO;


//*****************************************************************************
// Pulled from hwspec/code/hwcntrl.asm
#define NV_ESC_INTEL_DIAG                       0x6E77      // 'nv' + 1

#define     IDIAG_OPEN_INTERFACE                0
#define     IDIAG_CLOSE_INTERFACE               1
#define     IDIAG_GET_ERROR_CODE                2
#define     IDIAG_GET_CRC                       3
#define     IDIAG_GET_DRIVER_INFO               4
#define     IDIAG_GET_MEMORY_INFO               5
#define     IDIAG_GET_CLOCK_RATES               6
#define     IDIAG_GET_PCI_CONFIG                7
#define     IDIAG_GET_BUS_CONFIG                8

#define     IDIAG_ERROR_NONE                    0
#define     IDIAG_ERROR_GENERIC                 1
#define     IDIAG_ERROR_INVALID_PARAM           2
#define     IDIAG_ERROR_NOT_SUPPORTED           3


//*****************************************************************************
// Pulled from tools/sdk/win32/include/winerror.h
#ifndef ERROR_SUCCESS
#define ERROR_SUCCESS                    0L
#endif
#define ERROR_INVALID_FUNCTION           1L
#define ERROR_INVALID_DATA               13L
#define ERROR_BAD_COMMAND                22L
#define ERROR_INVALID_PARAMETER          87L


//*****************************************************************************
// Added to enable alpha blended color cursors
#define NV_ESC_GET_CURSOR_ALPHA             0x6E78      // 'nv' + 2
#define NV_ESC_SET_CURSOR_ALPHA             0x6E79      // 'nv' + 3

//*****************************************************************************
// Added to test mode switching by OpenGL or anything else that uses the counter
#define NV_ESC_INC_MODE_SWITCH              0x6E7A      // 'nv' + 4

//*****************************************************************************
// Pulled from common/win9x/inc/GNPDEV.H
// The generic non-Windows defined escapes we support are:
// For GETPDEVICE, the first DWORD pointed to by lpOut will get a linear
// address of the PDEVICE and the second DWORD gets a 16:16 ptr to the
// PDEVICE.
#define GN_ESC_GET_PDEVICE                  0x6E7B
#define GETPDEVICE                          GN_ESC_GET_PDEVICE

// The lpIn argument should point to 2 DWORDS.  The first DWORD is the
// linear base address the newly allcated seelctor should get. The
// second DWORD specifies the limit of the selector. The return value
// is a 16bit WORD that is placed where lpOut points to. The 16bit value
// is the newly allocated slector. It is 0 if the routine failed.
#define GN_ESC_ALLOC_SELECTOR_AND_MAP       0x6E7C

// The first 16 bit WORD pointed to by lpIn has the selector to free.
#define GN_ESC_UNMAP_AND_FREE_SELECTOR      0x6E7D

// If lpIn is NULL, then this is a query type call and lpOut points to
// a dword that returns the number of modes in the registry list. If lpIn
// is not NULL, then it points to one of the following three values
// (defined in modeext.h) MODETYPE_MODEENTRYNORR, MODETYPE_MODEENTRY,
// or MODETYPE_MODEENTRYANDPITCH. lpOut points to an array of
// MAX_MODEENTRYS structures of the format specified by the lpIn
// parameter (i.e. either MODEENTRYNORR, MODEENTRY, or MODEENTRYANDPITCH.)
// The list of modes will be placed into this lpOut buffer. If the
// routine fails, the return code is 0; if it succeeeds, it returns 1.
#define NV_ESC_GET_REGISTRY_MODE_LIST       0x6E7E

// This escape gets the local base path in the registry to be used
// by driver components wishing to write board specific info into the
// registry. How to use the string returned by this escape is discussed
// in ....drivers\common\nv4\inc\nvreg.h. The lpOut parameter points
// to a buffer that is at least 128 characters in length.
// The first DWORD in lpOut is one one of the predefined registry keys
// like HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER, etc. Starting right
// after the first dword is a string which is the registry path.
// NOTE: You have to issue the escape to the correct display driver in
// a multi-mon scenario. How do you know which one? There is code in
// the DirectX driver which shows how to get the correct display HDC.
#define NV_ESC_GET_LOCAL_REGISTRY_PATH      0x6E7F

// This escape indicates that we are running on an NVidia board/driver
// combination. It returns this escape value as a dword pointed to by
// lpOut argument of the escape call. The second dword pointed to by
// the lpOut argument is the NVidia device number that the display
// driver is talking to -- this is a 1 based number. The third dword
// pointed to by lpOut is a physical CRTC index. Don't use this right
// now -- it is just for testing purposes.
#define NV_ESC_IS_NVIDIA_BOARD_AND_DRIVER   0x6E80

// This escape will fill in the following structure into the memory
// area pointed to by the lpOut argument to the escape call.
#define NV_ESC_GET_HARDWARE_POINTERS        0x6E81

typedef struct  tagHARDWAREPOINTERS
{
    unsigned long   lp16FrameBuffer;        // 16:16 ptr to frame buffer
    unsigned long   lp32FrameBuffer;        // flat  ptr to frame buffer
    unsigned long   lp16Chip;               // 16:16 ptr to chip space
    unsigned long   lp32Chip;               // flat  ptr to chip space
} HARDWAREPOINTERS;

// This escape will get a flat ptr to the shared DirectX data. It
// is returned as the first dword of the lpOut parameter.
#define NV_ESC_GET_FLAT_DIRECTX_SHARED_DATA 0x6E82

// This escape will validate a mode on a given display device.
// The lpIn ptr will point to the following structure.  The
// Escape will always return TRUE. lpOut points to a dword. If
// the requested mode can be set on the specified device then
// the dword pointed to by lpOut will be set to 1. If the mode
// cannot be set on the device, the dword will be 0. The
// dwDeviceType field in the structure can be one of the
// MONITOR_TYPE_XXXX constants in nvcm.h.
#define NV_ESC_VALIDATE_DEVICE_MODE         0x6E83

typedef struct  tagVALMODEEXT
{
    unsigned long   dwHRes;
    unsigned long   dwVRes;
    unsigned long   dwBpp;
    unsigned long   dwDeviceType;
} VALMODEXT;

// This escape is used to inform the display driver what the
// desired output device should be on the next modeset. The
// lpIn parameter should point to the following structure.
// The dwSuccessFlag is ignored for this escape (can be 0.) The
// lpOut parameter should point to a dword which will be set
// to a 1 if the display driver successfully handles the escape
// and 0 if the display driver could not handle the call.
// The escape call itself will always return non-0 if the
// display driver recieved the escape.
// The dwDeviceType holds one of the MONITOR_TYPE_XXXX constants
// defined in nvcm.h. If dwDeviceType is either the NTSC or PAL
// type, then dwTvFormat will be one of the specific NTSC or PAL
// formats specified in nvcm.h like NTSC_M, NTSC_J, PAL_A etc.
#define NV_ESC_SET_DISPLAY_DEVICE_TYPE      0x6E84

// This escape is used to get from the display driver what the
// current output device actually is. The lpOut parameter should
// point to the following structure. Upon returning, the dwSuccessFlag
// will be non-0 if the display driver successfully filled in the
// dwDeviceType and dwTvFormat fields with the current device type
// and tv format respectively. Otherwise, it will hold FALSE.
// The escape call itself will always return non-0 if the
// display driver recieved the escape.
// The dwDeviceType will hold one of the MONITOR_TYPE_XXXX constants
// defined in nvcm.h. If dwDeviceType is either the NTSC or PAL
// type, then dwTvFormat will be one of the specific NTSC or PAL
// formats specified in nvcm.h like NTSC_M, NTSC_J, PAL_A etc.
#define NV_ESC_GET_DISPLAY_DEVICE_TYPE      0x6E85

typedef struct  tagSETGETDEVTYPE
{
    unsigned long   dwSuccessFlag;
    unsigned long   dwDeviceType;
    unsigned long   dwTvFormat;
} SETGETDEVTYPE;


// Escape used to get the current refresh rate from the display driver

#define NV_ESC_GET_REFRESH_INFO             0x6E86

// lpIn = NULL
// lpOut points to DWORD to receive the current refresh rate as follows:
// (-1) = Optimal
//  0   = Adapter Default
// Any other value represents the actual refresh rate in use


// This escape will allow 32 bit code to call SetCursor() directly,
// bypassing GDI and the goofyness inherent in it.  16 bit code can
// find the SetCursor entry point (ordinal 102 in the display driver).
//
// lpIn = pointer to a genuine cursor structure
//
// Note: this allows 32x32, 64x64 (and 32x64 & 64x32) cursors if the
// hardware permits it.  Also, in debug builds, pixel depths of 33 and
// 34 will expose the ARGB and premultiplied ARGB (where available).

#define GN_ESC_SET_CURSOR                   0x6E87

#ifdef WINNT
// lpIn = pointer to input structure to nvMoComp
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_DMABLIT               0x6E88

// lpIn = pointer to input structure to nvOverlayControl
// lpOut = pointer to a DWORD return code
#define NV_ESC_DDPRIV_OVERLAYCONTROL        0x6E89
#endif // WINNT

// lpIn pointer to a 32bit value that has the amount of memory
//      to allocate
// lpOut pointer to a 32bit value that is the flat ptr to the
//      block of memory that is at least as large as requested.
// The escape itself always returns TRUE. If the allocation is
// successful, lpOut will return pointing to a non-NULL value.
// NULL value indicates that the alloc failed. The alloc escape
// always allocates CACHED memory above 2Gig (SHARED memory).

// This escape allocates memory through the RM.
// lpIn should point to the following structure.
// The objectID should be a uniqueID for the object that the
// RM will associate with the memory block. This objectID will
// need to get passed back in to free the memory block.
// dwAllocFlags are things like NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS
// specified in nvos.h
// lpOut should point to a dword which will get filled in with
// a ptr to a memory block of the size requested or NULL if the
// allocation was unsuccessful.
// The Escape itself will always return TRUE.
#define NV_ESC_ALLOC_MEMORY                 0x6E8A
typedef struct  _ESC_ALLOC_MEMORY
{
    unsigned long   dwObjectID;
    unsigned long   dwAllocFlags;
    unsigned long   dwNumBytes;
}   ESC_ALLOC_MEMORY;


// This escape always returns TRUE.
// This escape frees memory allocated by a previous call to
// NV_ESC_ALLOC_MEMORY.
// lpIn should point to the following structure.
// lpOut is not used.
#define NV_ESC_FREE_MEMORY                  0x6E8B
typedef struct  _ESC_FREE_MEMORY
{
    unsigned long   dwObjectID;
}   ESC_FREE_MEMORY;


// This is identical to the NV_ESC_GET_REGISTRY_MODE_LIST escape,
// EXCEPT that the list only contains desktop modes. No DDRAW only
// modes are included.
#define NV_ESC_GET_REGISTRY_DESKTOP_MODE_LIST   0x6E8C


// This escape allocates shared memory.
// lpIn should point to an ESC_ALLOC_SHARED_MEMORY_IN structure.
// dwNumBytes should be the size in bytes of the desired
// memory block. dwID can be used to request a ptr to the
// memory block at a later date.
// lpOut should point to an ESC_ALLOC_MEMORY_OUT structure.
// pMemBlock will be a flat pointer to the memory block.
// The Escape itself will always return TRUE.
#define NV_ESC_ALLOC_SHARED_MEMORY  0x6E8D
typedef struct  _ESC_ALLOC_SHARED_MEMORY_IN
{
    unsigned long   dwNumBytes;
    unsigned long   dwID;
}   ESC_ALLOC_SHARED_MEMORY_IN;

typedef struct  _ESC_ALLOC_SHARED_MEMORY_OUT
{
    unsigned long   pMemBlock;
}   ESC_ALLOC_SHARED_MEMORY_OUT;

// This escape frees memory allocated by a previous call to
// NV_ESC_ALLOC_SHARED_MEMORY.
// lpIn should point to an _ESC_FREE_SHARED_MEMORY_IN structure.
// dwID should be an ID that was passed in to some prior ALLOC.
// lpOut should point to an _ESC_FREE_SHARED_MEMORY_OUT structure.
// If TRUE, the dwSuccess field indicates the the memory block
// assoictaed with the dwID passied in was freed.
// This escape always returns TRUE.
#define NV_ESC_FREE_SHARED_MEMORY   0x6E8E
typedef struct  _ESC_FREE_SHARED_MEMORY_IN
{
    unsigned long   dwID;
}   ESC_FREE_SHARED_MEMORY_IN;

typedef struct  _ESC_FREE_SHARED_MEMORY_OUT
{
    unsigned long   dwSuccess;
}   ESC_FREE_SHARED_MEMORY_OUT;

// This escape gets a ptr to a previsouly allocated shared
// memory block.
// lpIn should point to an _ESC_GET_SHARED_MEMORY_IN structure.
// dwID should be an ID that was passed in to some prior ALLOC.
// lpIn should point to an _ESC_GET_SHARED_MEMORY_OUT structure.
// This escape always returns TRUE.
#define NV_ESC_GET_SHARED_MEMORY    0x6E8F
typedef struct  _ESC_GET_SHARED_MEMORY_IN
{
    unsigned long   dwID;
}   ESC_GET_SHARED_MEMORY_IN;

typedef struct  _ESC_GET_SHARED_MEMORY_OUT
{
    unsigned long   pMemBlock;
}   ESC_GET_SHARED_MEMORY_OUT;


//*****************************************************************************
// Pulled from hwspec/code/hwcntrl.asm
#define NV_ESC_DMAPUSHMODESWITCHCOUNT       0x6E90

// Also found in OpenGL/nv/nvInit.c
#define NV_ESC_GETAGPBASE                   0x6E91
#define NV_ESC_GETACTIVECHANNELPTR          0x6E92


//*****************************************************************************
// Added for PGC (aka SLI) communications between multimonitor instances of the
// GDI driver. Can be also used to pull information about PGC drivers. The
// actual action is specified by the command field in the lpIn parameter.
#define NV_ESC_PGC_COMMAND                  0x6E93

//*****************************************************************************
//
// NV11 TwiNView escape for controlling dual CRTC functionality
//

#define NV_ESC_SETGET_TWINVIEW_DATA         0x6E94
#include "nvMultiMon.h" // Contains all definitions and structures used in the NV_ESC_SETGET_TWINVIEW_DATA escape call.

#define NV_ESC_ENABLE_DISABLE_SOFTWARE_CURSOR 0x6E95

// For both of these escapes the lpOut ptr points to a DWORD.
// For SET, the driver will get this dword and save it.
// For GET, the driver will place the cpl dword where lpOut points.
// The lpIn argument is not used.
#define NV_ESC_SET_CPL_DWORD                0x6E96
#define NV_ESC_GET_CPL_DWORD                0x6E97

#ifndef NV_SIGNATURE
// This value also is defined in driver.h of display driver
#define NV_SIGNATURE 0x11223344
#endif

#ifndef NV_ESC_PRIMARY_INFO
#define NV_ESC_PRIMARY_INFO 0x7104
typedef struct _NV_PRIMARY_INFO
{
    unsigned long ulNVSignature;   // IN
    unsigned long ulNumDevices;    // IN
    unsigned long ulHeadNum;       // IN
    unsigned long ulReturnCode;    // OUT from display driver
    unsigned long ulWidth;         // OUT from display driver
    unsigned long ulHeight;        // OUT from display driver
    unsigned long ulDepth;         // OUT from display driver
    unsigned long ulPitch;         // OUT from display driver
    unsigned long ulPrimaryOffset; // OUT from display driver
    unsigned long ulNumDACs;       // OUT from display driver (NT only)
    unsigned long ulNumActiveDACs; // OUT from display driver
    unsigned long ulActiveDACs;    // OUT from display driver (NT only)
    unsigned long ulPanningPtr;    // OUT from display driver (9x only)
    unsigned long ulFullscreenPtr; // OUT from display driver (9x only)
} NV_PRIMARY_INFO;
#endif

#ifndef ESC_NV_QUERY_HEAD_REFRESH_RATE
#define ESC_NV_QUERY_HEAD_REFRESH_RATE 0x7106
#endif

//*****************************************************************************
//
// PGC subcommands and corresponding structures
//
#ifndef WINNT
typedef struct _MYPGCCMD
{
    unsigned long dwCommand;
    unsigned long dwParam1;
    unsigned long dwParam2;
} MYPGCCMD;

#define PGC_CONNECT_GDI 1

#endif  // WINNT

//*****************************************************************************
//
// Formerly common/win9x/inc/OPENGL.H
//
#ifndef WINNT       // These are redefined in the NT tree
// From common/win9x/inc/opengl.h
// These escape values are fixed by Windows
#define OPENGL_CMD                          4352
#define OPENGL_GETINFO                      4353

#define     OPENGL_GETINFO_DRVNAME              0

#define     OPENGL_ICD_VER                      2
#define     OPENGL_DRIVER_VER                   0x10000     // Version 1.0000

#define     OPENGL_KEY_NAME                     "RIVATNT"

    typedef struct {
        unsigned long   ulVersion;
        unsigned long   ulDriverVersion;
        unsigned char   awch[ 129 ];
    } OPENGL_INFO;

#endif  // WINNT

#endif  // _ESCAPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\duma.h ===
/***************************************************************************\
* Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.            *
* THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO       *
* NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY  *
* IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.                *
*                                                                           *
*  Portions: Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.*
*                                                                           *
* Module: Duma.h															*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*		Andrei Osnovich    01/17/99  Created								*
*                                                                           *
\***************************************************************************/

#ifndef DUMA_H
#define DUMA_H

#ifndef DUMA_VXD
#include <windows.h>
#endif

/*
 *Duma delegated services.
 */

#define DUMA_HOT_KEY_CREATE 		  1
#define DUMA_HOT_KEY_DESTROY		  2
#define DUMA_HOT_KEY_RESET			  3
#define DUMA_CACHE_CONTROL			  4
#define DUMA_SOFTICE_CONTROL          5
#define DUMA_ENFORCE_FILTER           6
// Errors
#define DUMA_OK 		   0

#define CACHE_INVALIDATE	 0x01
#define CACHE_ENABLE_WT 	 0x02
#define CACHE_ENABLE_WB 	 0x04
#define CACHE_DISABLE		 0x08
#define CACHE_ENABLE_AGP	 0x10
#define CACHE_DISABLE_AGP	 0x20

typedef struct _CacheControlData {
	DWORD dwFlags;
	DWORD dwStartAddr;
	DWORD dwLength;
} CACHECONTROLDATA, *LPCACHECONTROLDATA;

// Hot key options:
#define HK_BUSY_MASK	   0x80000000 // mask for MSB - controls busy of hotkey
#define HK_OCCURED_MASK    0x7FFFFFFF // mask for value (w/o MSB)

#ifndef DUMA_VXD

typedef DWORD* HKHANDLE;  // HotKey Handle

typedef struct _HOTKEY
{
	DWORD	  dwValue;
	HKHANDLE  hkHandle;
} HOTKEY, *LPHOTKEY;

#ifdef __cplusplus

// C++ interface class for Duma VxD services.
class CHotKeyInterface
{
  protected:
	  HANDLE DumaHandle;

  public:
	  HKHANDLE CreateHotKey(DWORD dwKey);
	  BOOL DestroyHotKey(HKHANDLE );
	  BOOL ResetHotKey(HKHANDLE );
      BOOL EnforceFilter(void);
	  inline BOOL isInitialized()
		{ return DumaHandle!=NULL; }

  public:
	  CHotKeyInterface();  // constructor
	  ~CHotKeyInterface(); // destructor
};

typedef CHotKeyInterface CHOTKEYINTERFACE, *LPCHOTKEYINTERFACE;

/*
 * Macros for easy Hot Key Interface access.
 */

#define CREATEHOTKEY(pInterface,HotKey)                                 \
	if ((HotKey).dwValue)                                               \
    {                                                                   \
	  if (pInterface)                                                   \
		(HotKey).hkHandle = pInterface->CreateHotKey((HotKey).dwValue); \
    }

#define DESTROYHOTKEY(pInterface,HotKey)                                \
	if (pInterface && (HotKey).hkHandle)                                \
    {                                                                   \
	   pInterface->DestroyHotKey((HotKey).hkHandle);                    \
	   (HotKey).hkHandle = 0;                                           \
    }

#define ENFORCEFILTER(pInterface)                                       \
    res_ = FALSE;                                                       \
	if (pInterface)                                                     \
    {                                                                   \
	   res_ = pInterface->EnforceFilter();                              \
    }

// Warning!!! The function that uses the POLLHOTKEY macros has to 
// define the following local variable:
//      BOOL res_; 
#define POLLHOTKEY(pInterface,HotKey)                                   \
    res_ = FALSE;                                                       \
	if ((HotKey).hkHandle && (*((HotKey).hkHandle) & HK_OCCURED_MASK))  \
    {                                                                   \
        res_ = TRUE;                                                    \
		if (pInterface) pInterface->ResetHotKey((HotKey).hkHandle);     \
    }                                                                   \
    if (res_ == TRUE)

#ifdef  DEFINE_HOTKEY_INTERFACES

// CHotKeyInterface class members implementation is to be included once 
// somewhere in a ring 3 application that wants to utilize the DUMA hot 
// key support. 

CHotKeyInterface::CHotKeyInterface()
{
    if ((DumaHandle = CreateFile("\\\\.\\DUMA.VXD", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL))==INVALID_HANDLE_VALUE)
        DumaHandle = NULL;
}

CHotKeyInterface::~CHotKeyInterface()
{
    if (DumaHandle)
    {     
        CloseHandle(DumaHandle);
        DumaHandle = NULL;
    }
}

HKHANDLE CHotKeyInterface::CreateHotKey(DWORD dwKey)
{
    HKHANDLE hkHandle = NULL;
    DWORD RetVal = 0;

    if (DumaHandle) {
        DeviceIoControl(DumaHandle, DUMA_HOT_KEY_CREATE, (LPVOID)&dwKey, sizeof(DWORD), &hkHandle, sizeof(HKHANDLE), &RetVal, NULL);
        if (RetVal != sizeof(HKHANDLE)) return NULL;
        return hkHandle;
    }
    return NULL;
}

BOOL CHotKeyInterface::DestroyHotKey(HKHANDLE hkHandle)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (DumaHandle) {
        DeviceIoControl(DumaHandle, DUMA_HOT_KEY_DESTROY, hkHandle, sizeof(HKHANDLE), &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

BOOL CHotKeyInterface::ResetHotKey(HKHANDLE hkHandle)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (DumaHandle) {
        DeviceIoControl(DumaHandle, DUMA_HOT_KEY_RESET, hkHandle, sizeof(HKHANDLE), &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

BOOL CHotKeyInterface::EnforceFilter(void)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (DumaHandle) {
        DeviceIoControl(DumaHandle, DUMA_ENFORCE_FILTER, NULL, 0, &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

#endif  //DEFINE_HOTKEY_INTERFACES

#else   //__cplusplus==0

// "C" interface structure for Duma VxD services.
typedef struct _HotKeyInterface
{
	  HANDLE DumaHandle;
	  HKHANDLE (*CreateHotKey)(struct _HotKeyInterface *, DWORD dwKey);
	  BOOL (*DestroyHotKey)(struct _HotKeyInterface *, HKHANDLE );
	  BOOL (*ResetHotKey)(struct _HotKeyInterface *, HKHANDLE );
      BOOL (*EnforceFilter)(struct _HotKeyInterface *);
} CHOTKEYINTERFACE, *LPCHOTKEYINTERFACE;

/*
 * Macros for easy Hot Key Interface access.
 */

#define CREATEHOTKEY(pInterface,HotKey)                                             \
	if ((HotKey).dwValue)                                                           \
    {                                                                               \
	  if (pInterface)                                                               \
		(HotKey).hkHandle = pInterface->CreateHotKey(pInterface,(HotKey).dwValue);  \
    }

#define DESTROYHOTKEY(pInterface,HotKey)                                            \
	if (pInterface && (HotKey).hkHandle)                                            \
    {                                                                               \
	   pInterface->DestroyHotKey(pInterface,(HotKey).hkHandle);                     \
	   (HotKey).hkHandle = 0;                                                       \
    }

#define ENFORCEFILTER(pInterface)                                                   \
    res_ = FALSE;                                                                   \
	if (pInterface)                                                                 \
    {                                                                               \
	   res_ = pInterface->EnforceFilter(pInterface);                                \
    }

// Warning!!! The function that uses the POLLHOTKEY macros has to 
// define the following local variable:
//      BOOL res_; 
#define POLLHOTKEY(pInterface,HotKey)                                               \
    res_ = FALSE;                                                                   \
	if ((HotKey).hkHandle && (*((HotKey).hkHandle) & HK_OCCURED_MASK))              \
    {                                                                               \
        res_ = TRUE;                                                                \
		if (pInterface) pInterface->ResetHotKey(pInterface,(HotKey).hkHandle);      \
    }                                                                               \
    if (res_ == TRUE)

#ifdef  DEFINE_HOTKEY_INTERFACES

// HotKeyInterface "C" interface's implementation is to be included once 
// somewhere in a ring 3 application that wants to utilize the DUMA hot 
// key support. 

HKHANDLE CreateHotKey(LPCHOTKEYINTERFACE pInterface, DWORD dwKey)
{
    HKHANDLE hkHandle = NULL;
    DWORD RetVal = 0;

    if (pInterface->DumaHandle) {
        DeviceIoControl(pInterface->DumaHandle, DUMA_HOT_KEY_CREATE, (LPVOID)&dwKey, sizeof(DWORD), &hkHandle, sizeof(HKHANDLE), &RetVal, NULL);
        if (RetVal != sizeof(HKHANDLE)) return NULL;
        return hkHandle;
    }
    return NULL;
}

BOOL DestroyHotKey(LPCHOTKEYINTERFACE pInterface, HKHANDLE hkHandle)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (pInterface->DumaHandle) {
        DeviceIoControl(pInterface->DumaHandle, DUMA_HOT_KEY_DESTROY, hkHandle, sizeof(HKHANDLE), &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return RetVal;
    }
    return ServiceOutput;  
}

BOOL ResetHotKey(LPCHOTKEYINTERFACE pInterface, HKHANDLE hkHandle)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (pInterface->DumaHandle) {
        DeviceIoControl(pInterface->DumaHandle, DUMA_HOT_KEY_RESET, hkHandle, sizeof(HKHANDLE), &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

BOOL EnforceFilter(LPCHOTKEYINTERFACE pInterface)
{
    BOOL ServiceOutput = FALSE;
    DWORD RetVal = 0;

    if (pInterface->DumaHandle) {
        DeviceIoControl(pInterface->DumaHandle, DUMA_ENFORCE_FILTER, NULL, 0, &ServiceOutput, sizeof(ServiceOutput), &RetVal, NULL);
        if (RetVal != sizeof(ServiceOutput)) return FALSE;
        return ServiceOutput;
    }
    return FALSE;  
}

BOOL CreateHotKeyInterface(LPCHOTKEYINTERFACE pInterface)
{
    if (!pInterface)
        return FALSE;
    if ((pInterface->DumaHandle = CreateFile("\\\\.\\DUMA.VXD", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL))==INVALID_HANDLE_VALUE)
        return FALSE;
    pInterface->CreateHotKey  = CreateHotKey;
    pInterface->DestroyHotKey = DestroyHotKey;
    pInterface->ResetHotKey   = ResetHotKey;
}

void DestroyHotKeyInterface(LPCHOTKEYINTERFACE pInterface)
{
    if (pInterface->DumaHandle)
    {     
        CloseHandle(pInterface->DumaHandle);
        pInterface->DumaHandle = NULL;
    }
}

#else   //DEFINE_HOTKEY_INTERFACES==0
extern  BOOL CreateHotKeyInterface(LPCHOTKEYINTERFACE pInterface);
extern  void DestroyHotKeyInterface(LPCHOTKEYINTERFACE pInterface);
#endif  //DEFINE_HOTKEY_INTERFACES

#endif  //__cplusplus==0

#endif //DUMA_VXD

#endif // #define DUMA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\dxshare.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       dxshare.h
 *
 *  Content:    This file has a data structure that is shared between
 *              the display driver and the DirectX driver.
 *
 *      NOTES:  Due to the need to h2inc this file and also compiler
 *              structure packing parameters, please only use
 *              unsigned longs as members of this structure and
 *              do NOT have any substructures. The real data
 *              DirectX needs will go in its own private data
 *              structure that it allocates itself when the DirectX
 *              driver is laoded. This shared data structure is ONLY
 *              needed for the display driver to send over a few
 *              instance specific things to the DirectX driver
 *              and the DirectX driver to send back a few instance
 *              specific things to the display driver.
 *
 ***************************************************************************/

#ifndef _DXSHARE_H_
#define _DXSHARE_H_

// I don't think we will have more than this for a while
#define MAX_HEADS       4

typedef struct  tagDISPDRVDIRECTXCOMMON
{
    // The display driver fills these in for the DirectX driver to use
    unsigned long   pFlatDibeng;        // Flat ptr to Driver PDEVICE
    unsigned long   dwNVDeviceID;       // 1 based board instance
    unsigned long   dwDeviceVersion;    // NVidia chip/software version
    unsigned long   dwRootHandle;       // Root allocated from RM by driver
    unsigned long   dwScreenLinearBase; // Linear base address of framebuffer
    unsigned long   dwDeviceLinearBase; // Linear base address of chip
    unsigned long   dwDeviceHandle;     // VDD handle for this device
    unsigned long   dwHeadNumber;       // 0 or 1
                                        // For single head boards and
                                        // multi-head boards in clone mode
                                        // this will be 0.

    // There are some wierd DirectX apps that assume the mode table
    // is created in 16bit land before even calling the 32bit
    // DirectX driver. Hence, DirectX needs amode table around and
    // hanging out so that it can just grab. It doesn't have the
    // opportunity to build one before it needs it. This is a ptr to
    // MODEENTRYANDPITCH structures defined in modeext.h
    unsigned long   lpMasterModeList;

    // This is a 32:32 (FAR32) ptr to a callback function that DirectX
    // can invoke only when it is within a pfnInterfaceFunc routine
    // shown below. Pass in the pDispDriverHWLogDevCX as the context
    // data for this function call.
    unsigned long   dwDrvCallbackOffset;
    unsigned long   dwDrvCallbackSelector;
    unsigned long   pDispDriverHWLogDevCX;

    ////////////////////////////////////////////////////////////////////
    // The DirectX driver fills these in for the display driver to use.
    unsigned long   dwFlatDataSel;
    unsigned long   dwFlatCodeSel;

    // 32 Bit flat ptr to the DDHALInfo structure
    unsigned long   pHalInfo;

    // size of DDthe HALINFO structure in bytes
    unsigned long   dwHALInfoSize;

    // The hInstance of the DirectX driver passed to its DllMain proc
    unsigned long   hDirectXInstance;

    // cached values of the previous display mode (used to detect true mode changes)
    // do not use these to get the current mode information
    unsigned long   deWidth;
    unsigned long   deHeight;
    unsigned long   deBitsPixel;

    // 32bit flat ptr to a procedure which accepts the following:
    // eax - ptr to this structure DISPDRVDIRECTXCOMMON
    // ebx - one of the GDIDX_XXX equates below
    // Basically this procedure can be called by the display driver
    // whenever the driver wants to inform DirectX about something.
    // The interface is agreed upon solely by the display driver
    // and the DirectX driver. This procedure will be called directly
    // (with no thunking) from the display driver. Hence, it cannot
    // call any system routines, since although we are running in
    // 32bit flat land at the time we are executing it, we will really
    // be running as a sub-routine of the display driver! To return,
    // this procedure MUST execute a FAR32 return -- you must do this
    // in assembly -- the 32bit C compiler cannot do this for you!
    unsigned long   pfnInterfaceFunc;

    // DirectX context data ptr. The display driver has no idea
    // what this points to -- it is solely for DirectDraw's use.
    unsigned long   pDirectXData;
    unsigned long   pNvPrimarySurf;
    unsigned long   dwModeNumber;
    unsigned long   primaryBufferIndex;

    unsigned long   dwPhysicalHeadNumber;

}   DISPDRVDIRECTXCOMMON;

// These flags indicate what type of Interface call this is
// When calling pfnInterfaceFunc from the display driver, if ebx =
// GDIDX_PRE_SETINFOINIT, then you should fill in the 16bit portion of
// the DDHALINFO structure. Basically the "16 bit portion" is the
// vmiData, FourCC, ModeList, and Callback List fields.
#define GDIDX_PRE_SETINFOINIT           0x01
#define GDIDX_ENTER_FULL_SCREEN_DOS     0x02
#define GDIDX_EXIT_FULL_SCREEN_DOS      0x03
#define GDIDX_PRE_MODESET_NOTIFY        0x04
#define GDIDX_POST_MODESET_NOTIFY       0x05
#define GDIDX_DIRECTX_OS_VERSION        0x06
#define GDIDX_DRIVER_UNLOADING          0x07
#define GDIDX_EARLY_DX_CONNECT          0x08

// This is a DCI escape call that I made up. It is not part of the
// standard DCI escape set. but it should be! It tells the display
// driver that the DirectX driver is going down.
#define DDNVCREATEDRIVEROBJECT      98
#define DDNVDESTROYDRIVEROBJECT     99

// DirectX needs to understand the standard part of the PDEVICE
// which is the DIBENGING structure. Unfortunately, including
// dibeng.inc won't build so I just have the structure here.
typedef struct  _tagDIBENGINEHDR1
{
    unsigned short      deType;
    unsigned short      deWidth;
    unsigned short      deHeight;
    unsigned short      deWidthBytes;
    unsigned char       dePlanes;
    unsigned char       deBitsPixel;
    unsigned long       deReserved1;
    unsigned long       deDeltaScan;
    unsigned long       delpPDevice;
    unsigned long       deBitsOffset;
    unsigned short      deBitsSelector;
    unsigned short      deFlags;
    unsigned short      deVersion;
    unsigned long       deBitmapInfo;
    unsigned long       deBeginAccess;
    unsigned long       deEndAccess;
    unsigned long       deDriverReserved;
}   DIBENGINEHDR1;

// When certain events happen in 16bit, there is a special call
// made into the DX driver via the pfnInterfaceFunc ptr in the
// DISPDRVDIRECTXCOMMON structure. This is not a thunked call
// so while executing the code in these calls, the DX driver is
// running as a sub-routine of the display driver and it cannot
// make system calls. To make calls into the OS to alloc memory,
// etc, DX must call back to the display driver and have it make
// the system calls on its behalf. To do this the DX driver
// calls the function pointed at by the dwDrvCallbackOffset and
// dwDrvCallbackSelector fields in the DISPDRVDIRECTXCOMMON
// structure. This DrvCallback routine has the following interface.
// int FAR32 PASCAL DrvCallbackFunc(DWORD pDispDriverHWLogDevCX,
// DWORD dwFunction, void *pIn, void *pOut) and can perform a
// variety of services based upon the dwFunction argument.
// These are listed below.

// For the alloc memory service, set dwFunction to this equate
// pIn should point to the following structure.
// The objectID should be a uniqueID for the object that the
// RM will associate with the memory block. This objectID will
// need to get passed back in to free the memory block.
// dwAllocFlags are things like NVOS02_FLAGS_PHYSICALITY_CONTIGUOUS
// specified in nvos.h
// pOut should point to a dword which will get filled in with
// a ptr to a memory block of the size requested or NULL if the
// allocation was unsuccessful.
#define NV_DRVSERVICE_ALLOC_MEMORY          0x01
typedef struct  _DRVSERVICE_ALLOC_MEMORY
{
    unsigned long   dwObjectID;
    unsigned long   dwAllocFlags;
    unsigned long   dwNumBytes;
}   DRVSERVICE_ALLOC_MEMORY;

// For the free memory service, set dwFunction to this equate
// Then pIn should point to the following struct. The service
// always returns TRUE. The pOut argument is not used.
#define NV_DRVSERVICE_FREE_MEMORY           0x02
typedef struct  _DRVSERVICE_FREE_MEMORY
{
    unsigned long   dwObjectID;
}   DRVSERVICE_FREE_MEMORY;

// These two services should be called with the lpIn argument equal
// to the lpDibeng. lpDibeng should be a field in the HALINFO table.
// It is a 16:16 ptr to the DIBENGINE structure.
// These two services may actually be called even if the DX driver
// is not running as a subroutine of the display driver because
// these services make no system calls, so it does not matter what
// "space" the owner is running in.
#define NV_DRVSERVICE_BEGINACCESS           0x03
#define NV_DRVSERVICE_ENDACCESS             0x04

#endif  // _DXSHARE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\ddrvmem.h ===
#ifndef DDRVMEM_H
#define DDRVMEM_H

#define EXTRA_LEAN_AND_MEAN
#include <windows.h>

// =========================================================
// Memory Management Macros
//
//      These macros are used for platform independent
//      memory operations.
//
//      NOTE:  If you have multiple threads
//             that compete for memory or run
//             into memory corruption problems.
//             uncomment the #define DDRV_SERIALIZE below
//
//      NOTE:  This does not support locking/unlocking mutual
//             exclusion.  If you have multiple threads or
//             code that can be interrupted and re-entered
//             then it is possible to get invalid pointers.
//             It shouldn't be too hard to add this support yourself
// =========================================================



extern HANDLE g_hD3DHAL_DriverHeap;

#define MEMALLOC(cbSize)    HeapAlloc (g_hD3DHAL_DriverHeap, HEAP_ZERO_MEMORY, (cbSize))
#define MEMFREE(lpPtr)      HeapFree (g_hD3DHAL_DriverHeap, 0, (lpPtr))

#define MEMCOPY(p1,p2,cbSize)   CopyMemory((void *)(p1), (void *)(p2), (DWORD)(cbSize))
#define MEMCLEAR(p1,cbSize)     ZeroMemory((void *)(p1), (DWORD)(cbSize))
#define MEMSET(p1,cbSize,val)   FillMemory((void *)(p1), (DWORD)(cbSize), (BYTE)val)



// =========================================================
// DDrvItemArray library.
//
//   This is used by the display drivers for dynamic memory
//   management of contexts, textures, and other objects
//   described by fixed-size structures.
//
// =========================================================

// Call this in DLL_PROCESS_ATTACH.
// If this function returns FALSE, you should fail the
// DLL load.
BOOL DDrvItemArrayInit ();

// Call this on DLL_PROCESS_DETACH.
BOOL DDrvItemArrayFini ();


// Handle to an itemarray
typedef DWORD HDDRVITEMARRAY, *LPHDDRVITEMARRAY;

// Handle to an item
typedef DWORD HDDRVITEM, * LPHDDRVITEM;


// Passes back a handle to the itemarray and returns TRUE if
// successful.
//
// nItems   - initial number of item slots in array
// dwSize   - size of each item in array (in Bytes)
// dwDelta  - growth factor (array grows by dwDelta slot
//            each time it is full and needs more space)
// lphArray - handle to newly created array
//
// Returns FALSE if the itemarray could not be created.
BOOL DDrvItemArrayCreate (DWORD nItems, DWORD dwSize,
                          DWORD dwDelta, LPHDDRVITEMARRAY lphArray);

// Destroys an itemarray.
// Returns FALSE if the itemarray handle is not valid.
BOOL DDrvItemArrayDestroy(HDDRVITEMARRAY hArray);

// Flushes an array, i.e. sets all item slots to empty (available)
// Returns FALSE if the itemarray handle is not valid.
BOOL DDrvItemArrayFlush (HDDRVITEMARRAY hArray);

// Allocate an item in array and return a small integer handle to it.
// The integer handle is guaranteed positive (0 is not a valid handle).
// Returns FALSE if it could not allocate enough room.
BOOL DDrvItemArrayAlloc (HDDRVITEMARRAY hArray, LPHDDRVITEM lphItem);

// Attempts to free an item.
BOOL DDrvItemArrayFree (HDDRVITEMARRAY hArray, HDDRVITEM hItem);

// Given an itemarray and an item handle, return a pointer to
// the item.
//
// Don't save these pointers. Allocating more items from the array
// may move the array's location in memory, invalidating any
// pointers into the array that may be lying around.
LPVOID DDrvItemArrayGetPtr (HDDRVITEMARRAY hArray, HDDRVITEM hItem);


// Callback Return type
enum DDRV_RETURN {
    DDRV_SUCCESS_STOP,
    DDRV_SUCCESS_CONTINUE,
    DDRV_ERROR_CONTINUE,
    DDRV_ERROR_STOP
};

// Generic Callback prototype
// should return one of the above values
typedef DWORD (*DDRVAPPLYFUNC)(void * lpData, HDDRVITEM hItem, DWORD dwData);


// Apply's a user defined callback function to
// each and every valid item in itemarray
BOOL DDrvItemArrayApplyValid (HDDRVITEMARRAY hArray, DDRVAPPLYFUNC lpCallback,
                              DWORD dwExtraData);

BOOL DDrvItemArrayApplyAll (HDDRVITEMARRAY hArray, DDRVAPPLYFUNC lpCallback,
                            DWORD dwExtraData);

BOOL DDrvItemArrayFindFirstValid (HDDRVITEMARRAY hArray, LPHDDRVITEM lpNextValid);

BOOL DDrvItemArrayFindNextValid (HDDRVITEMARRAY hArray, HDDRVITEM hStartFrom,
                                 LPHDDRVITEM lpNextValid);


#endif // DDRVMEM_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\nv332.h ===
/***** Notification Status Values *****/
/*
 * NV sets NvNotification.status to NV_STATUS_DONE_OK if the operation
 * succeeded.
 */
#define NV_STATUS_DONE_OK          0



/* class NV_CONTEXT_ERROR_TO_MEMORY */
#define  NV_CONTEXT_ERROR_TO_MEMORY                      (0xFF5)
/* NvNotification[] elements */
#define NVFF5_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFF5_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF5_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF5_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF5_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} Nvff5Typedef, NvContextErrorToMemory;
#define NVFF5_TYPEDEF                                    NvContextErrorToMemory
/* dma method offsets, fields, and values */
#define NVFF5_SET_OBJECT                                 (0x00000000)
#define NVFF5_NO_OPERATION                               (0x00000100)
#define NVFF5_NOTIFY                                     (0x00000104)
#define NVFF5_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF5_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF5_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF5_SET_DMA_SPECIFIER                          (0x00000300)


/* class NV_VIDEO_COLOR_KEY */
#define  NV_VIDEO_COLOR_KEY                              (0xFF6)
/* NvNotification[] elements */
#define NVFF6_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFF6_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF6_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF6_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF6_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput[3];        /* NV1_PATCHCORD_VIDEO               0204-020b*/
 V032 Reserved02[0x03c];
 V032 SetColorFormat;          /* NVFF6_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColorKey;             /* color to compare with             0304-0307*/
 V032 SetPoint;                /* y_x, S16_S16 in pixels, top-left  0308-030b*/
 V032 SetSize;                 /* height_width U16_U16 in pixels    030c-030f*/
 V032 Reserved03[0x73c];
} Nvff6Typedef, NvVideoColorKey;
#define NVFF6_TYPEDEF                                    NvVideoColorKey
/* dma method offsets, fields, and values */
#define NVFF6_SET_OBJECT                                 (0x00000000)
#define NVFF6_NO_OPERATION                               (0x00000100)
#define NVFF6_NOTIFY                                     (0x00000104)
#define NVFF6_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF6_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF6_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF6_SET_VIDEO_OUTPUT                           (0x00000200)
#define NVFF6_SET_VIDEO_INPUT                            (0x00000204)
#define NVFF6_SET_COLOR_FORMAT                           (0x00000300)
#define NVFF6_SET_COLOR_FORMAT_LE_X16A8Y8                (0x00000001)
#define NVFF6_SET_COLOR_FORMAT_LE_X24Y8                  (0x00000002)
#define NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5            (0x00000003)
#define NVFF6_SET_COLOR_FORMAT_LE_X17R5G5B5              (0x00000004)
#define NVFF6_SET_COLOR_FORMAT_LE_A16R5G6B5              (0x00000005)
#define NVFF6_SET_COLOR_FORMAT_LE_A8R8G8B8               (0x00000006)
#define NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8               (0x00000007)
#define NVFF6_SET_COLOR_FORMAT_LE_A16Y16                 (0x00000008)
#define NVFF6_SET_COLOR_FORMAT_LE_X16Y16                 (0x00000009)
#define NVFF6_SET_COLOR_KEY                              (0x00000304)
#define NVFF6_SET_POINT                                  (0x00000308)
#define NVFF6_SET_POINT_X                                15:0
#define NVFF6_SET_POINT_Y                                31:16
#define NVFF6_SET_SIZE                                   (0x0000030C)
#define NVFF6_SET_SIZE_WIDTH                             15:0
#define NVFF6_SET_SIZE_HEIGHT                            31:16


/* class NV_VIDEO_SCALER */
#define  NV_VIDEO_SCALER                                 (0xFF7)
/* NvNotification[] elements */
#define NVFF7_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFF7_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF7_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF7_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF7_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x03e];
 V032 SetDeltaDuDx;            /* S12d20 ratio du/dx                0300-0303*/
 V032 SetDeltaDvDy;            /* S12d20 ratio dv/dy                0304-0307*/
 V032 SetPoint;                /* y_x S16_S16 in pixels, top-left   0308-030b*/
 V032 Reserved03[0x73d];
} Nvff7Typedef, NvVideoScaler;
#define NVFF7_TYPEDEF                                    NvVideoScaler
/* dma method offsets, fields, and values */
#define NVFF7_SET_OBJECT                                 (0x00000000)
#define NVFF7_NO_OPERATION                               (0x00000100)
#define NVFF7_NOTIFY                                     (0x00000104)
#define NVFF7_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF7_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF7_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF7_SET_VIDEO_OUTPUT                           (0x00000200)
#define NVFF7_SET_VIDEO_INPUT                            (0x00000204)
#define NVFF7_SET_DELTA_DU_DX                            (0x00000300)
#define NVFF7_SET_DELTA_DV_DY                            (0x00000304)
#define NVFF7_SET_POINT                                  (0x00000308)
#define NVFF7_SET_POINT_X                                15:0
#define NVFF7_SET_POINT_Y                                31:16


/* class NV_VIDEO_FROM_MEMORY */
#define  NV_VIDEO_FROM_MEMORY                            (0xFF8)
/* NvNotification[] elements */
#define NVFF8_NOTIFIERS_NOTIFY                           (0)
#define NVFF8_NOTIFIERS_IMAGE_SCAN(b)                    (1+(b))
#define NVFF8_NOTIFIERS_GET_OFFSET_NOTIFY(b)             (3+(b))
/* NvNotification[] fields and values */
#define NVFF8_NOTIFICATION_INFO16_BUFFER_NOT_STARTED     (0x0001)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_OFFSET_VALID    (0x0002)
#define NVFF8_NOTIFICATION_INFO16_BUFFER_DONE            (0x0003)
#define NVFF8_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF8_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF8_NOTIFICATION_STATUS_ERROR_BAD_PATCH        (0x0400)
#define NVFF8_NOTIFICATION_STATUS_WARNING_INVALID_DATA   (0x0001)
#define NVFF8_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF8_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NVFF8_STOP_TRANSFER_VALUE         0108-010b*/
 V032 SetPatch;                /* NVFF8_SET_PATCH_*                 010c-010f*/
 V032 Reserved00[0x01c];
 V032 SetImageNotifyCtxDma;    /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetImageCtxDma[2];       /* NV1_CONTEXT_DMA_FROM_MEMORY       0184-018b*/
 V032 Reserved01[0x01d];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 Reserved02[0x03f];
 struct {                      /* start of methods in array         0300-    */
  U032 offset;                 /* byte offset of top-left pixel       00-  03*/
  U032 pitch;                  /* bytes, vertical pixel delta         04-  07*/
  V032 size;                   /* height_width U16_U16 in pixels      08-  0b*/
  V032 format;                 /* field_color V16_V16                 0c-  0f*/
  V032 notify;                 /* NVFF8_IMAGE_SCAN_NOTIFY_*           10-  13*/
 } ImageScan[2];               /* end of methods in array               -0327*/
 V032 GetOffsetNotify[2];      /* NVFF8_GET_OFFSET_NOTIFY_*         0328-032f*/
 V032 Reserved03[0x734];
} Nvff8Typedef, NvVideoFromMemory;
#define NVFF8_TYPEDEF                                    NvVideoFromMemory
/* dma method offsets, fields, and values */
#define NVFF8_SET_OBJECT                                 (0x00000000)
#define NVFF8_NO_OPERATION                               (0x00000100)
#define NVFF8_NOTIFY                                     (0x00000104)
#define NVFF8_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF8_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF8_STOP_TRANSFER                              (0x00000108)
#define NVFF8_STOP_TRANSFER_VALUE                        (0x00000000)
#define NVFF8_SET_PATCH                                  (0x0000010C)
#define NVFF8_SET_PATCH_INVALIDATE                       (0x00000000)
#define NVFF8_SET_PATCH_VALIDATE                         (0x00000001)
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF8_SET_CONTEXT_DMA_IMAGE                      (0x00000184)
#define NVFF8_SET_VIDEO_OUTPUT                           (0x00000200)
#define NVFF8_IMAGE_SCAN                                 (0x00000300)
#define NVFF8_IMAGE_SCAN_OFFSET                          (0x00000300)
#define NVFF8_IMAGE_SCAN_PITCH                           (0x00000304)
#define NVFF8_IMAGE_SCAN_SIZE                            (0x00000308)
#define NVFF8_IMAGE_SCAN_SIZE_WIDTH                      15:0
#define NVFF8_IMAGE_SCAN_SIZE_HEIGHT                     31:16
#define NVFF8_IMAGE_SCAN_FORMAT                          (0x0000030C)
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR                    15:0
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_Y8              (0x00000001)
#define NV_VFM_FORMAT_COLOR_LE_Y8_P4                      0x00000001
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_V8YB8U8YA8      (0x00000002)
#define NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8                   0x00000002
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_YB8V8YA8U8      (0x00000003)
#define NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8                   0x00000003
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1R5G5B5       (0x00000004)
#define NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2                0x00000004
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_R5G6B5          (0x00000005)
#define NV_VFM_FORMAT_COLOR_LE_R5G6B5_P2                  0x00000005
#define NVFF8_IMAGE_SCAN_FORMAT_COLOR_LE_GY1X7R8G8B8     (0x00000006)
#define NV_VFM_FORMAT_COLOR_LE_X8R8G8B8                   0x00000006
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD                    31:16
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_PROGRESSIVE        (0x00000001)
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_EVEN_FIELD         (0x00000002)
#define NV_VFM_FORMAT_NEXT_FIELD_EVEN                     0x00000002
#define NVFF8_IMAGE_SCAN_FORMAT_FIELD_ODD_FIELD          (0x00000003)
#define NV_VFM_FORMAT_NEXT_FIELD_ODD                      0x00000003
#define NVFF8_IMAGE_SCAN_SET_NOTIFY                      (0x00000310)
#define NVFF8_IMAGE_SCAN_NOTIFY                          31:0
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_IMAGE_SCAN_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
#define NVFF8_GET_OFFSET_NOTIFY                          (0x00000328)
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_ONLY               (0x00000000)
#define NVFF8_GET_OFFSET_NOTIFY_WRITE_THEN_AWAKEN        (0x00000001)
#define NVFF8_SET_VIDEO_OUTPUT_PARAM(s)                  (0x00040200+8192*(s))
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES_PARAM(s)          (0x00040180+8192*(s))
#define NVFF8_IMAGE_SCAN_PARAM(s,b)                      (0x00140300+8192*(s)+\
                                                                     20*(b))


/* class NV_VIDEO_COLORMAP */
#define  NV_VIDEO_COLORMAP                               (0xFF9)
/* NvNotification[] elements */
#define NVFF9_NOTIFIERS_NOTIFY                           (0)
#define NVFF9_NOTIFIERS_COLORMAP_DIRTY_NOTIFY            (1)
/* NvNotification[] fields and values */
#define NVFF9_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFF9_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFF9_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFF9_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 SetColormapCtxDma;       /* NV_CONTEXT_DMA_FROM_MEMORY        0184-0187*/
 V032 Reserved01[0x01e];
 V032 SetVideoOutput;          /* NV1_PATCHCORD_VIDEO               0200-0203*/
 V032 SetVideoInput;           /* NV1_PATCHCORD_VIDEO               0204-0207*/
 V032 Reserved02[0x040];
 U032 SetColormapStart;        /* offset in bytes                   0308-030b*/
 U032 SetColormapLength;       /* in bytes                          030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update         0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, starts transfer         0314-0317*/
 V032 Reserved03[0x73a];
} Nvff9Typedef, NvVideoColormap;
#define NVFF9_TYPEDEF                                    NvVideoColormap
/* dma method offsets, fields, and values */
#define NVFF9_SET_OBJECT                                 (0x00000000)
#define NVFF9_NO_OPERATION                               (0x00000100)
#define NVFF9_NOTIFY                                     (0x00000104)
#define NVFF9_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFF9_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFF9_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFF9_SET_CONTEXT_DMA_COLORMAP                   (0x00000184)
#define NVFF9_SET_VIDEO_OUTPUT                           (0x00000200)
#define NVFF9_SET_VIDEO_INPUT                            (0x00000204)
#define NVFF9_SET_COLORMAP_START                         (0x00000308)
#define NVFF9_SET_COLORMAP_LENGTH                        (0x0000030C)
#define NVFF9_COLORMAP_DIRTY_START                       (0x00000310)
#define NVFF9_COLORMAP_DIRTY_LENGTH                      (0x00000314)
#define NVFF9_SET_VIDEO_OUTPUT_PARAM(s)                 (0x00040200+8192*(s))
#define NVFF9_SET_CONTEXT_DMA_NOTIFIES_PARAM(s)         (0x00040180+8192*(s))
#define NVFF9_SET_COLORMAP_START_PARAM(s)               (0x00040308+8192*(s))


/* class NV_VIDEO_SINK */
#define  NV_VIDEO_SINK                                   (0xFFA)
/* NvNotification[] elements */
#define NVFFA_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFA_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFA_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFA_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFFA_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetVideoInput[64];       /* NV1_PATCHCORD_VIDEO               0200-02ff*/
 V032 Reserved02[0x740];
} NvffaTypedef, NvVideoSink;
#define NVFFA_TYPEDEF                                    NvVideoSink
/* dma method offsets, fields, and values */
#define NVFFA_SET_OBJECT                                 (0x00000000)
#define NVFFA_NO_OPERATION                               (0x00000100)
#define NVFFA_NOTIFY                                     (0x00000104)
#define NVFFA_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFA_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFA_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFA_SET_VIDEO_INPUT                            (0x00000200)


/* class NV_PATCHCORD_VIDEO */
#define  NV_PATCHCORD_VIDEO                              (0xFFB)
/* NvNotification[] entries, values, errors, warnings */
#define NVFFB_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} NvffbTypedef, NvPatchcordVideo;
#define NVFFB_TYPEDEF                                    NvPatchcordVideo


/* class NV_CONTEXT_DMA_IN_MEMORY */
#define  NV_CONTEXT_DMA_IN_MEMORY                        (0xFFC)
/* NvNotification[] elements */
#define NVFFC_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFC_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFC_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFC_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFFC_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* On X86 address[1] is the selector    0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffcTypedef, NvContextDmaInMemory;
#define NVFFC_TYPEDEF                                    NvContextDmaInMemory
/* dma method offsets, fields, and values */
#define NVFFC_SET_OBJECT                                 (0x00000000)
#define NVFFC_NO_OPERATION                               (0x00000100)
#define NVFFC_NOTIFY                                     (0x00000104)
#define NVFFC_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFC_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFC_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFC_SET_DMA_SPECIFIER                          (0x00000300)


/* class NV_CONTEXT_DMA_TO_MEMORY */
#define  NV_CONTEXT_DMA_TO_MEMORY                        (0xFFD)
/* NvNotification[] elements */
#define NVFFD_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFD_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFD_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFD_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFFD_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffdTypedef, NvContextDmaToMemory;
#define NVFFD_TYPEDEF                                    NvContextDmaToMemory
/* dma method offsets, fields, and values */
#define NVFFD_SET_OBJECT                                 (0x00000000)
#define NVFFD_NO_OPERATION                               (0x00000100)
#define NVFFD_NOTIFY                                     (0x00000104)
#define NVFFD_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFD_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFD_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFD_SET_DMA_SPECIFIER                          (0x00000300)


/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define  NV_CONTEXT_DMA_FROM_MEMORY                      (0xFFE)
/* NvNotification[] elements */
#define NVFFE_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFE_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFE_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFE_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 SetNotify;               /* NVFFE_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  V032 address[2];             /* address[1] is selector on X86        0-   7*/
  U032 limit;                  /* size of data region in bytes-1       8-   b*/
 } SetDmaSpecifier;            /* end of method                         -030b*/
 V032 Reserved02[0x73d];
} NvffeTypedef, NvContextDmaFromMemory;
#define NVFFE_TYPEDEF                                    NvContextDmaFromMemory
/* dma method offsets, fields, and values */
#define NVFFE_SET_OBJECT                                 (0x00000000)
#define NVFFE_NO_OPERATION                               (0x00000100)
#define NVFFE_NOTIFY                                     (0x00000104)
#define NVFFE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFE_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFE_SET_DMA_SPECIFIER                          (0x00000300)
#define NVFFE_SET_DMA_SPECIFIER_LIMIT                    (0x00000308)


/* class NV_CLASS */
#define  NV_CLASS                                        (0xFFF)
/* NvNotification[] elements */
#define NVFFF_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NVFFF_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NVFFF_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NVFFF_NOTIFICATION_STATUS_WARNING_UNAVAILABLE    (0x0002)
#define NVFFF_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NVFFF_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV_CONTEXT_DMA_TO_MEMORY          0180-0183*/
 V032 Reserved01[0x05f];
 V032 Create;                  /* 32-bit handle of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit handle of object           0304-0307*/
 V032 Reserved02[0x73e];
} NvfffTypedef, NvClass;
#define NVFFF_TYPEDEF                                    NvClass
/* dma method offsets, fields, and values */
#define NVFFF_SET_OBJECT                                 (0x00000000)
#define NVFFF_NO_OPERATION                               (0x00000100)
#define NVFFF_NOTIFY                                     (0x00000104)
#define NVFFF_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NVFFF_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#define NVFFF_CREATE_OFFSET                              (0x00000300)
#define NVFFF_DESTROY_OFFSET                             (0x00000304)
#define NVFFF_CREATE(s)                                  (0x00000300+8192*(s))
#define NVFFF_CREATE_PARAM(s)                            (0x00040300+8192*(s))
#define NVFFF_DESTROY(s)                                 (0x00000304+8192*(s))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\h2inc.h ===
/******************************************************************************
 *                                                                            *
 *  H2INC.H  - A file used to help H2INC deal with complex header files.      *
 *                                                                            *
 ******************************************************************************/

#ifndef _H2INC_H        // Try not to include this file twice
#define _H2INC_H

#ifdef  H2INC           // Only include this file if it is in H2INC (-DH2INC on command line)

typedef unsigned long   DWORD;
typedef unsigned short  WORD;
typedef unsigned char   BYTE;

#endif //  H2INC
#endif // _H2INC_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\Files.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       files.h
 *  Content:    Contains defines for the various binary filenames
 *
 ***************************************************************************/

/*NV3 binaries*/
#define NV3_DDRAW_BINARY		"NV3DD32.DLL"
#define NV3_DISPLAY_BINARY		"NV3DISP.DRV"
#define NV3_OPENGL_BINARY		"NV3OGL.DLL"
#define NV3_MINIVDD_BINARY		"NV3.VXD"
#define NV3_MINIVDD2_BINARY		"NV3MINI2.VXD"
#define NV3_RM_32_BINARY		"NV3API.DLL"
#define NV3_RM_16_BINARY		"NV3SYS.DLL"
#define NV3_RM_KERNEL_BINARY		"NV3RM.VXD"
#define NV3_QUICK_TWEAK_BINARY		"NV3QTWK.DLL"
#define NV3_TWEAK_BINARY		"NV3TWEAK.DLL"
#define NV3_TWEAK_HELP_BINARY		"NV3TWEAK.HLP"

/*NV4 binaries*/
#define NV4_DDRAW_BINARY		"NVDD32.DLL"
#define NV4_DISPLAY_BINARY		"NVDISP.DRV"
#define NV4_MODESET_BINARY		"NVMODE.DLL"
#define NV4_OPENGL_BINARY		"NVOPENGL.DLL"
#define NV4_MINIVDD_BINARY		"NVMINI.VXD"
#define NV4_MINIVDD2_BINARY		"NVMINI2.VXD"
#define NV4_RM_32_BINARY		"NVARCH32.DLL"
#define NV4_RM_16_BINARY		"NVARCH16.DLL"
#define NV4_RM_KERNEL_BINARY		"NVCORE.VXD"
#define NV4_QUICK_TWEAK_BINARY		"NVQTWK.DLL"
#define NV4_TWEAK_BINARY		    "NVCPL.DLL"
#define NV4_TWEAK_SVC_BINARY		"NVCPLSVC.DLL"
#define NV4_DESK_MGR_BINARY         "NVDESK32.DLL"
#define NV4_DESK_MGR_UI_BINARY      "NVDMCPL.DLL"
#define NV4_FSVM_BINARY		        "NVFSVM.EXE"
#define NV4_TWEAK_HELP_BINARY		"NVCPL.HLP"
#define NV4_INSTALL_LIB_BINARY      "NVINST32.DLL"
#define NV4_ARABIC_RESOURCE_BINARY	"NVRSAR.DLL"
#define NV4_ARABIC_HELP_BINARY		"NVCPAR.HLP"
#define NV4_CZECH_RESOURCE_BINARY	"NVRSCS.DLL"
#define NV4_CZECH_HELP_BINARY		"NVCPCS.HLP"
#define NV4_DANISH_RESOURCE_BINARY	"NVRSDA.DLL"
#define NV4_DANISH_HELP_BINARY		"NVCPDA.HLP"
#define NV4_GERMAN_RESOURCE_BINARY	"NVRSDE.DLL"
#define NV4_GERMAN_HELP_BINARY		"NVCPDE.HLP"
#define NV4_UKENGLISH_RESOURCE_BINARY	"NVRSENG.DLL"
#define NV4_UKENGLISH_HELP_BINARY	"NVCPENG.HLP"
#define NV4_SPANISH_RESOURCE_BINARY	"NVRSES.DLL"
#define NV4_SPANISH_HELP_BINARY		"NVCPES.HLP"
#define NV4_LASPANISH_RESOURCE_BINARY	"NVRSES.DLL"
#define NV4_LASPANISH_HELP_BINARY	"NVCPES.HLP"
#define NV4_FINNISH_RESOURCE_BINARY	"NVRSFI.DLL"
#define NV4_FINNISH_HELP_BINARY		"NVCPFI.HLP"
#define NV4_FRENCH_RESOURCE_BINARY	"NVRSFR.DLL"
#define NV4_FRENCH_HELP_BINARY		"NVCPFR.HLP"
#define NV4_CAFRENCH_RESOURCE_BINARY	"NVRSFR.DLL"
#define NV4_CAFRENCH_HELP_BINARY	"NVCPFR.HLP"
#define NV4_GREEK_RESOURCE_BINARY	"NVRSEL.DLL"
#define NV4_GREEK_HELP_BINARY	"NVCPEL.HLP"
#define NV4_HEBREW_RESOURCE_BINARY	"NVRSHE.DLL"
#define NV4_HEBREW_HELP_BINARY	"NVCPHE.HLP"
#define NV4_HUNGARIAN_RESOURCE_BINARY	"NVRSHU.DLL"
#define NV4_HUNGARIAN_HELP_BINARY	"NVCPHU.HLP"
#define NV4_ITALIAN_RESOURCE_BINARY	"NVRSIT.DLL"
#define NV4_ITALIAN_HELP_BINARY		"NVCPIT.HLP"
#define NV4_JAPANESE_RESOURCE_BINARY	"NVRSJA.DLL"
#define NV4_JAPANESE_HELP_BINARY	"NVCPJA.HLP"
#define NV4_KOREAN_RESOURCE_BINARY	"NVRSKO.DLL"
#define NV4_KOREAN_HELP_BINARY		"NVCPKO.HLP"
#define NV4_DUTCH_RESOURCE_BINARY	"NVRSNL.DLL"
#define NV4_DUTCH_HELP_BINARY		"NVCPNL.HLP"
#define NV4_NORWEGIAN_RESOURCE_BINARY	"NVRSNO.DLL"
#define NV4_NORWEGIAN_HELP_BINARY	"NVCPNO.HLP"
#define NV4_POLISH_RESOURCE_BINARY	"NVRSPL.DLL"
#define NV4_POLISH_HELP_BINARY	"NVCPPL.HLP"
#define NV4_PORTUGUESE_RESOURCE_BINARY	"NVRSPT.DLL"
#define NV4_PORTUGUESE_HELP_BINARY	"NVCPPT.HLP"
#define NV4_BPORTUGUESE_RESOURCE_BINARY	"NVRSPTB.DLL"
#define NV4_BPORTUGUESE_HELP_BINARY	"NVCPPTB.HLP"
#define NV4_RUSSIAN_RESOURCE_BINARY	"NVRSRU.DLL"
#define NV4_RUSSIAN_HELP_BINARY		"NVCPRU.HLP"
#define NV4_SLOVAK_RESOURCE_BINARY	"NVRSSK.DLL"
#define NV4_SLOVAK_HELP_BINARY		"NVCPSK.HLP"
#define NV4_SLOVENIAN_RESOURCE_BINARY	"NVRSSL.DLL"
#define NV4_SLOVENIAN_HELP_BINARY		"NVCPSL.HLP"
#define NV4_SWEDISH_RESOURCE_BINARY	"NVRSSV.DLL"
#define NV4_SWEDISH_HELP_BINARY		"NVCPSV.HLP"
#define NV4_THAI_RESOURCE_BINARY	"NVRSTH.DLL"
#define NV4_THAI_HELP_BINARY		"NVCPTH.HLP"
#define NV4_TURKISH_RESOURCE_BINARY	"NVRSTR.DLL"
#define NV4_TURKISH_HELP_BINARY		"NVCPTR.HLP"
#define NV4_SIMCHINESE_RESOURCE_BINARY	"NVRSZHC.DLL"
#define NV4_SIMCHINESE_HELP_BINARY	"NVCPZHC.HLP"
#define NV4_TRDCHINESE_RESOURCE_BINARY	"NVRSZHT.DLL"
#define NV4_TRDCHINESE_HELP_BINARY	"NVCPZHT.HLP"

/*NV4 NT4 binaries*/
#define NV4_DISPLAY_BINARY_NT4		"NV4_DISP.DLL"
#define NV4_OPENGL_BINARY_NT4		"NVOGLNT.DLL"
#define NV4_MINIVDD_BINARY_NT4		"NV4_MINI.SYS"
#define NV4_QUICK_TWEAK_BINARY_NT4   NV4_QUICK_TWEAK_BINARY
#define NV4_TWEAK_BINARY_NT4         NV4_TWEAK_BINARY
#define NV4_TWEAK_HELP_BINARY_NT4    NV4_TWEAK_HELP_BINARY
#define NV4_DESK_MGR_BINARY_NT4      NV4_DESK_MGR_BINARY

/* Workstation Application binaries */
#define NV4_POWERDRAFT_BINARY		"NVDS15.DLL"
#define NV4_MAXTREME_BINARY			"MAXtreme.drv"
#define NV4_QUADROVIEW_BINARY		"QUADROVIEW.EXE"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\NVDD.H ===
#ifndef _NVDD_
#define _NVDD_

#ifdef __cplusplus
extern "C" {
#endif  // __cplusplus

/*==========================================================================;
 *
 *  Copyright (C) 1995, 1999 NVidia Corporation. All Rights Reserved.
 *
 *  File:       nvdd.h
 *  Content:    header for NVidia Windows 95 Direct Draw driver
 *
 ***************************************************************************/

#ifndef NVARCH
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

#if(NVARCH < 0x4)
#define CDriverContext GLOBALDATA
#pragma warning(disable:4005) //macro redefinition warning/error
#endif

// force write combine and put
#ifdef NVSPEAK
// obsolete - use nvPusherStart
#else //!NVSPEAK
#define NVDD_FLUSH_AND_PUT(putAddress) \
    { pDriverData->NvDmaPusherBufferEnd[0] += putAddress[0]; \
      _outp (0x3d0,0); \
      npDev->Put = (dmaPusherPutAddress - dmaPusherBufferBase) << 2; }
#endif //!NV_SPEAK

#define NVFAR FAR

#define FAST register

#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)


typedef struct {
    unsigned long offset;
    unsigned short selector;
} NVFP;

#define NVLP2FP(NVFAR_POINTER, USHORT_POINTER) \
    {   \
        NVFP *fptemp = (NVFP *)&(NVFAR_POINTER); \
         fptemp->selector = (USHORT_POINTER)[1]; \
        fptemp->offset = (USHORT_POINTER)[0]; \
    }


#define CLOSE_HANDLE(h) CloseHandle(h)
//#define CLOSE_HANDLE(h) (1)

#ifdef NVD3D

typedef struct {
    short   x;
    short   y;
} NVXY;

typedef struct {
    unsigned short w;
    unsigned short h;
} NVWH;


typedef union {
    long xy;
    unsigned long wh;
    NVXY xy16;
    NVWH wh16;
} NVCOORD;

#endif

#ifdef WINNT
    extern PDEV *ppdev;
    #define nvSetDriverDataPtrFromDDGbl(pDDGbl) {                                                                   \
        NvAcquireSemaphore((CDriverContext *)(((PDEV *)(((PDD_DIRECTDRAW_GLOBAL)(pDDGbl))->dhpdev))->pDriverData))  \
        ppdev       = ((PDEV *)(((PDD_DIRECTDRAW_GLOBAL)(pDDGbl))->dhpdev));                                        \
        pDriverData = (CDriverContext *)(ppdev->pDriverData);                                                       \
        pDriverData->dwDDGlobal = (DWORD)(pDDGbl);                                                                  \
        NvSetStereoDataPtrFromDriverData;                                                                           \
    }
    #define nvSetDriverDataPtrFromContext(pContext) {                                                               \
        NvAcquireSemaphore((pContext)->pDriverData)                                                                 \
        ppdev       = (pContext)->ppdev;                                                                            \
        pDriverData = (pContext)->pDriverData;                                                                      \
        NvSetStereoDataPtrFromDriverData;                                                                           \
    }
#else // !WINNT
    #include "dxshare.h"
    extern DISPDRVDIRECTXCOMMON *pDXShare;
    #define nvSetDriverDataPtrFromDDGbl(pDDGbl) {                                                                   \
        pDXShare         = (DISPDRVDIRECTXCOMMON *)((pDDGbl)->dwReserved3);                                         \
        pDriverData      = (CDriverContext *)pDXShare->pDirectXData;                                                \
        pDriverData->dwDDGlobal = (DWORD)(pDDGbl);                                                                  \
        NvSetStereoDataPtrFromDriverData;                                                                           \
    }
    #define nvSetDriverDataPtrFromContext(pContext) {                                                               \
        pDXShare         = (DISPDRVDIRECTXCOMMON *)((pContext)->pDXShare);                                          \
        pDriverData      = (pContext)->pDriverData;                                                                 \
        NvSetStereoDataPtrFromDriverData;                                                                           \
    }
#endif // !WINNT

//
// DDHAL_EXIT(retcode) should always be invoked when returning from a HAL function
// or any function which loads the global variable pDriverData. This macro will
// return the parameter retVal to its caller.
//
#ifndef WINNT
    #define DDHAL_EXIT(retVal) return(retVal)
#else
    #define DDHAL_EXIT(retVal)              \
        NvReleaseSemaphore(pDriverData);    \
        return(retVal)
#endif

#if !defined(WINNT) || (DIRECT3D_VERSION >= 0x0800)
    #define NvTexSurfHandle(ptcd) ((LPDIRECTDRAWSURFACE) ((ptcd)->lpDDS))
#else   // WINNT
    #define NvTexSurfHandle(ptcd) ((LPDIRECTDRAWSURFACE) ((ptcd)->hDDS))
#endif  // WINNT

#if !defined(WINNT) || (DIRECT3D_VERSION >= 0x0800)
    #define NvLockTextureSurface(ptr)   ((LPDDRAWI_DDRAWSURFACE_INT)NvTexSurfHandle(ptr))->lpLcl
    #define NvUnlockTextureSurface(ptr)
#else   // WINNT
    #define NvLockTextureSurface(ptr)   EngLockDirectDrawSurface(NvTexSurfHandle(ptr))
    #define NvUnlockTextureSurface(ptr) EngUnlockDirectDrawSurface((ptr))
#endif  // WINNT

#if !defined(WINNT) || (DIRECT3D_VERSION >= 0x0800)
#define NvSaveTexSurfHandle(dst, src)   (dst)->lpDDS = (src)->lpDDS
#else   // WINNT
#define NvSaveTexSurfHandle(dst, src)   (dst)->hDDS = (src)->lpDDS
#endif  // WINNT

/*
 * Macros used to obtain video memory offset/addresses from fpVidMem field
 * in surface struct. Our Win9x driver requires an address in the fpVidMem
 * field while NT requires an offset. These macros are used to hide these
 * differences.
 */

#if defined(WINNT) && (DIRECT3D_VERSION < 0x0800)
    #define SETLIGHT_DATATYPE(lpDp2SetLight)          ((lpDp2SetLight)->lightData)
    #define SETPRIORITY_DSTSURF(lpDp2SetPriority)     ((lpDp2SetPriority)->dwDDDestSurface)
    #define SETRENDERTARG_DDSLCL(lpDp2SetRenderTarg)  ((lpDp2SetRenderTarg)->lpDDS)
    #define SETRENDERTARG_DDSLCLZ(lpDp2SetRenderTarg) ((lpDp2SetRenderTarg)->lpDDSZ)
#else // !WINNT
    #define SETLIGHT_DATATYPE(lpDp2SetLight)          ((lpDp2SetLight)->dwDataType)
    #define SETPRIORITY_DSTSURF(lpDp2SetPriority)     ((lpDp2SetPriority)->dwDDSurface)
    #define SETRENDERTARG_DDSLCL(lpDp2SetRenderTarg)  ((lpDp2SetRenderTarg)->lpDDSLcl)
    #define SETRENDERTARG_DDSLCLZ(lpDp2SetRenderTarg) ((lpDp2SetRenderTarg)->lpDDSLclZ)
#endif // !WINNT

#ifdef WINNT
#ifndef VIDMEM_ADDR
    #define VIDMEM_ADDR(fpVidMem)    ((fpVidMem) + (ULONG) ppdev->pjFrameBufbase)
#endif
    #define VIDMEM_OFFSET(fpVidMem)  (fpVidMem)
#ifndef AGPMEM_ADDR
    #define AGPMEM_ADDR(fpVidMem)    ((ULONG) fpVidMem + (ULONG) pDriverData->GARTLinearBase)
#endif
    #define VIDMEM_OFFSET(fpVidMem)  (fpVidMem)
    #define AGPMEM_OFFSET(fpVidMem)  ((ULONG) fpVidMem - (ULONG) pDriverData->GARTLinearBase)
    #define GET_PRIMARY_ADDR()       (ppdev->ulPrimarySurfaceOffset)
    #define GET_MODE_WIDTH()         (ppdev->cxScreen)
    #define GET_MODE_HEIGHT()        (ppdev->cyScreen)
    #define GET_MODE_PITCH()         (ppdev->lDelta)
    #define GET_MODE_PHYSICAL_HEIGHT(dwHead) (pDriverData->flipPrimaryRecord.nvTimingInfo[dwHead].VDisplayEnd)
    #define GET_MODE_BPP()           (ppdev->cBitsPerPel)
    #define GET_HALINFO()            (&(pDriverData->HALInfo))
    #define GET_CURRENT_HEAD()       (ppdev->ulDeviceDisplay[0])
    #define GET_SPAN_OFFSET(dwHead)  (ppdev->ulHeadDisplayOffset[dwHead])
    #define PRIMARY_BUFFER_INDEX     (ppdev->ulPrimaryBufferIndex)
#else // !WINNT
    #define VIDMEM_ADDR(fpVidMem)    (fpVidMem)
    #define VIDMEM_OFFSET(fpVidMem)  ((fpVidMem) - pDriverData->BaseAddress)
    #define AGPMEM_ADDR(fpVidMem)    (fpVidMem)
    #define AGPMEM_OFFSET(fpVidMem)  ((fpVidMem) - pDriverData->GARTLinearBase)
    #define GET_PRIMARY_ADDR()       (pDXShare->dwScreenLinearBase + (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deBitsOffset))
    #define GET_MODE_WIDTH()         (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deWidth)
    #define GET_MODE_HEIGHT()        (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deHeight)
    #define GET_MODE_PITCH()         (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deDeltaScan)
    #define GET_MODE_PHYSICAL_HEIGHT(dwHead) (pDriverData->flipPrimaryRecord.nvTimingInfo[dwHead].VDisplayEnd)
    #define GET_MODE_BPP()           (((DIBENGINEHDR1 *)pDXShare->pFlatDibeng)->deBitsPixel)
    #define GET_HALINFO()            ((LPDDHALINFO)pDXShare->pHalInfo)
    #define GET_CURRENT_HEAD()       (pDXShare->dwHeadNumber)
    #define GET_SPAN_OFFSET(dwHead)  (0)
    #define PRIMARY_BUFFER_INDEX     (pDXShare->primaryBufferIndex)
#endif // !WINNT
    #define CURRENT_FLIP             (pDriverData->dwCurrentFlip[GET_CURRENT_HEAD()])
    #define COMPLETED_FLIP           (pDriverData->dwCompletedFlip[GET_CURRENT_HEAD()])

#ifdef WINNT
    #define TEXTURE_LOCK_SWIZZLED(pTex)  ((pTex)->getSwizzled()->getOffset())
    #define TEXTURE_LOCK_LINEAR(pTex)    ((pTex)->getLinear()->getAddress())
#else // !WINNT
    #define TEXTURE_LOCK_SWIZZLED(pTex)  ((pTex)->getSwizzled()->getAddress())
    #define TEXTURE_LOCK_LINEAR(pTex)    ((pTex)->getLinear()->getAddress())
#endif // !WINNT


// this now exists for win2k, prototype it
void getDisplayDuration(void);


#if (NVARCH >= 0x04)
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.Free
#else   // !(NVARCH >= 0x04)
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.free
#endif  // !(NVARCH >= 0x04)

#define NV_ALPHA_1_032          ((U032)0xFF000000)
#if (NVARCH >= 0x04)
#define NV_ALPHA_1_016          ((U032)0xFFFF0000)
#else
#define NV_ALPHA_1_016          ((U032)0x00008000)
#endif
#define NV_ALPHA_1_008          ((U032)0x0000FF00)
#define NV_PATTERN_EVEN         ((U032)0x55555555)
#define NV_PATTERN_ODD          ((U032)0xAAAAAAAA)
#define NV_PRESCALE_OVERLAY_X           1
#define NV_PRESCALE_OVERLAY_Y           2
#define NV_PRESCALE_OVERLAY_FIELD       4
#define NV_PRESCALE_OVERLAY_QUADRANT    8

#ifndef WINNT
#define NV_DD_NOTIFIER_BLOCK_SIZE       (sizeof(NvNotification) << 5)
#else
// BUGBUG we need to change this for NT when we update to latest
// Win9x driver source base.
#define NV_DD_NOTIFIER_BLOCK_SIZE       (sizeof(NvNotification) << 4)
#endif

#if (NVARCH >= 0x010)

#define NV_MAX_X_CLIP                   0x00000FFF
#define NV_MAX_X_WIDTH                  0x00001000

#define NV_MAX_Y_CLIP                   0x00000FFF
#define NV_MAX_Y_HEIGHT                 0x00001000

#else   // !(NVARCH >= 0x010)

#define NV_MAX_X_CLIP                   0x000007FF
#define NV_MAX_X_WIDTH                  0x00000800

#define NV_MAX_Y_CLIP                   0x00003FFF
#define NV_MAX_Y_HEIGHT                 0x00004000

#endif  // !(NVARCH >= 0x010)


// DMA Pusher related stuff

#if (NVARCH >= 0x04)

#define NV_PFIFO_DMA                                     0x00002508
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204
#define NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT               0x00000100
#define NV_PFIFO_CACHE1_DMA_PUSH                         0x00003220
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY_BIT        0x00000100

#ifndef NVSPEAK
#define NV_DD_DMA_PUSHER_SYNC() {                                           \
    volatile DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;            \
    DWORD *pDW = (DWORD *) (pPDevice->HWPDevice.pCurrentChannelID);         \
                                                                            \
  if  (*pDW != pDriverData->dwDDDmaPusherChannelIndex)                      \
  {                                                                         \
    *pDW = pDriverData->dwDDDmaPusherChannelIndex;                          \
    while ((npNvBase[(NV_PFIFO_DMA >> 2)] &                                 \
            (~pDriverData->dwDDDmaPusherChannelMask)) != 0);                \
    if ((npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & NV_PFIFO_CACHE1_PUSH1_MODE_DMA_BIT) && \
        ((npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & 0x1F) !=                   \
            (WORD)pDriverData->dwDDDmaPusherChannelIndex)) {                \
        while ((npNvBase[NV_PFIFO_CACHE1_DMA_PUSH >> 2] &                   \
                 NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY_BIT) == 0);          \
    }                                                                       \
  }                                                                         \
}
#endif

#define NV_DD_GET_DMA_CHANNEL_INDEX(I) {                                    \
    volatile DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;            \
    (I) = (npNvBase[NV_PFIFO_CACHE1_PUSH1 >> 2] & 0x1F);                    \
}

#ifndef NVSPEAK
#define NvGetDmaBufferFreeCount(dmaChannel, freeCount, requiredCount, currentBufferAddress) { \
    long getOffset = (long)(volatile)(dmaChannel)->Get;                     \
    long putOffset = (long)((currentBufferAddress) - (DWORD *)pDriverData->NvDmaPusherBufferBase) << 2; \
    if (putOffset >= getOffset) {                                           \
        (freeCount) = (long)(pDriverData->NvDmaPusherBufferSize - 64 - putOffset) >> 2; \
        if ((long)(freeCount) < (long)(requiredCount)) {                    \
            (currentBufferAddress)[0] = NV_DMA_PUSHER_JUMP;                 \
            pDriverData->NvDmaPusherBufferEnd[0] += (DWORD)currentBufferAddress; \
            _outp (0x3d0,0);                                                \
            (dmaChannel)->Put = 0;                                          \
            (currentBufferAddress) =                                        \
                (DWORD *)pDriverData->NvDmaPusherBufferBase;                \
        }                                                                   \
    } else {                                                                \
        (freeCount) = ((getOffset - putOffset) >> 2) - 1;                   \
    }                                                                       \
    if ((freeCount) < requiredCount) {                                      \
        putOffset = 350 << 3;                                               \
        while (--putOffset > 0)                                             \
            (volatile)getOffset = putOffset;                                \
    }                                                                       \
}

#ifdef  CACHE_FREECOUNT
#ifdef  DEBUG
    extern void __stdcall NvCachedFreeCountError(long, long, DWORD *);

#define NvCheckCachedFreeCount(freeCount, currentBufferAddress) { \
    long putOffset = (long)(((DWORD *)currentBufferAddress) - (DWORD *)pDriverData->NvDmaPusherBufferBase) << 2; \
    long correctFreeCount = (long)(pDriverData->NvDmaPusherBufferSize - 64 - putOffset) >> 2; \
    if ((long)freeCount > (long)correctFreeCount)                                       \
        NvCachedFreeCountError((long)freeCount, correctFreeCount, (DWORD *)currentBufferAddress); \
}
#endif  /* DEBUG */
#endif  /* CACHE_FREECOUNT */

#endif //!NVSPEAK

#else   // (NVARCH >= 0x04)

#define NV3_3D_PIPE_STATE_RESET ((U032)0x00000008)

#ifdef  NV3T
#define NV_DD_DMA_PUSHER_SYNC() {                                           \
    if (pDriverData->fDmaPusherActive) {                                    \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        pDriverData->fDmaPusherActive = 0;                                  \
        npNvBase[(0x3200 >> 2)] = 1;                                        \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            while (freeCount < 4)                                           \
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);               \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#else   // ~NV3T
#define NV_DD_DMA_PUSHER_SYNC() {                                           \
    if (pDriverData->fDmaPusherActive) {                                    \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            while (freeCount < 4)                                           \
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);               \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#endif  // ~NV3T

#ifdef  NEW_DMAPUSH
#define NV_DD_DMA_PUSHER_FLUSH() {                                          \
    if (pDriverData->fDmaPusherActive) {                                    \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    else if ((pDriverData->dwDmaCurrentCount > sizeSetHeaderDmaPush) || (dwDmaPendingCount != 0)) \
    {                                                                       \
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            while (freeCount < 4)                                           \
                freeCount = NvGetFreeCount(npDev, NV_DD_ROP);               \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#else   // OLD_DMAPUSH
#ifdef  NV3T
#define NV_DD_DMA_PUSHER_FLUSH() {                                          \
    if (pDriverData->fDmaPusherActive) {                                    \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
        npNvBase[(0x3200 >> 2)] = 1;                                        \
    }                                                                       \
    else if (pDriverData->dwDmaCount > sizeSetHeaderDmaPush)                \
    {                                                                       \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
        npNvBase[(0x3200 >> 2)] = 1;                                        \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            npNvBase[(0x3200 >> 2)] = 1;                                    \
            while (freeCount < 4)                                           \
             freeCount = NvGetFreeCount(npDev, NV_DD_ROP);                  \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#else   // ~NV3T
#define NV_DD_DMA_PUSHER_FLUSH() {                                          \
    if (pDriverData->fDmaPusherActive) {                                    \
        NvNotification *pDDPusherSyncNotifier =                             \
            (NvNotification *)pDriverData->NvDmaPusherSyncNotifierFlat;     \
        NvNotification *pWinDmaToMemNotifier =                              \
            (NvNotification *)pDriverData->NvWinDmaPusherNotifierFlat;      \
        if ((pDriverData->fDmaPusherActive & NV_DD_DMA_PUSHER_IS_ACTIVE) && \
            (pDriverData->NvDevFlatPio != 0))                               \
            while ((volatile)pDDPusherSyncNotifier->status == NV_IN_PROGRESS);\
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    else if (pDriverData->dwDmaCount > sizeSetHeaderDmaPush)                \
    {                                                                       \
        nvFlushDmaBuffers();                                                \
        pDriverData->fDmaPusherActive = 0;                                  \
    }                                                                       \
    if (pDriverData->ThreeDRenderingOccurred) {                             \
        DWORD *npNvBase = (DWORD *)pDriverData->NvBaseFlat;                 \
        NvChannel *npDev = (NvChannel *)pDriverData->NvDevFlatPio;          \
        if (npDev != NULL) {                                                \
            long freeCount = NvGetFreeCount(npDev, NV_DD_ROP);              \
            while (freeCount < 4)                                           \
             freeCount = NvGetFreeCount(npDev, NV_DD_ROP);                  \
            npDev->dDrawRop.SetRop5 = SRCCOPYINDEX;                         \
            while ((freeCount = NvGetFreeCount(npDev, NV_DD_ROP)) < 124);   \
        }                                                                   \
        npNvBase[0x100020] = npNvBase[0x100020] | NV3_3D_PIPE_STATE_RESET;  \
        pDriverData->ThreeDRenderingOccurred = 0;                           \
    }                                                                       \
}
#endif  // NV3T
#endif  // OLD_DMAPUSH

#endif  // !(NVARCH >= 0x04)

#ifdef NVD3D
/*
 * D3D Hal Fcts
 */
#if (NVARCH <0x04)
extern BOOL __stdcall D3DHALCreateDriver(LPD3DHAL_GLOBALDRIVERDATA *lplpGlobal,
                                         LPD3DHAL_CALLBACKS* lplpHALCallbacks
                                         );
#endif
extern BOOL __stdcall D3DGetDriverInfo(LPDDHAL_GETDRIVERINFODATA lpData);

extern BOOL DestroyItemArrays(void);
#endif // NVD3D
#ifdef __cplusplus
}
#endif  // __cplusplus
#endif // _NVDD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\nvgpio.h ===
/*----------------------------------------------------------------------------*/
/*
 * nvgpio.h
 *
 */

#ifdef __cplusplus
extern "C"
{
#endif

DWORD nvGPIOInit ( ULONG ourRoot, ULONG ourDev, ULONG ourChannel, NvChannel* pNV, UINT subchan );
DWORD nvGPIOUnnit();
DWORD nvGPIOWrite ( DWORD regAddr, BYTE regData );
DWORD nvGPIORead ( DWORD regAddr, BYTE* pData );
DWORD nvVIPWrite ( DWORD regAddr, DWORD regData, DWORD dataSize );
DWORD nvVIPRead ( DWORD regAddr, DWORD* pBuf, DWORD dataSize );

/* backdoors (hopefully temporary) */
DWORD nvRegWrite ( DWORD regAddr, UINT regData );
DWORD nvRegRead ( DWORD regAddr, UINT* pData );
DWORD nvGPIOSetControlObj ( void* pObj );
VOID* nvGPIOGetControlObj();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\nvd3ddrv.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997 SGS-THOMSON Microelectronics  All Rights Reserved.
 *
 *  File:       nvd3ddrv.c
 *  Content:    master D3D include file - OS specific includes
 *
 ***************************************************************************/

#ifndef WINNT
#include <conio.h>
#include "ddrawi.h"
#include "ddmini.h"
#include <d3dhal.h>
#include "nvwin32.h"
#else

#include <stddef.h>
#include <stdarg.h>
#include <limits.h>
#include <d3d.h>

#include <winerror.h>
#include <wingdi.h>
#include <winddi.h>
#include <mmsystem.h>
#include <devioctl.h>

#include <ioaccess.h>
#include <math.h>
#include <dmemmgr.h>
#include <dx95type.h>
#include "nvapi.h"

//
// Type redefs excluded from dx95type.h.
//

typedef PDD_DIRECTDRAW_LOCAL            LPDDRAWI_DIRECTDRAW_LCL; //HMH
typedef D3DNTHAL_DP2CLEAR               *LPD3DNTHAL_DP2CLEAR;  //HMH
typedef LPD3DNTHAL_DP2CLEAR             LPD3DHAL_DP2CLEAR;     //HMH
typedef D3DNTHAL_DP2SETRENDERTARGET     *LPD3DNTHAL_DP2SETRENDERTARGET;  //HMH
typedef LPD3DNTHAL_DP2SETRENDERTARGET   LPD3DHAL_DP2SETRENDERTARGET;     //HMH
typedef D3DNTHAL_DP2TEXBLT     *LPD3DNTHAL_DP2TEXBLT;  //HMH
typedef LPD3DNTHAL_DP2TEXBLT   LPD3DHAL_DP2TEXBLT;     //HMH
typedef D3DNTHAL_DP2STATESET            *LPD3DNTHAL_DP2STATESET; //HMH
typedef LPD3DNTHAL_DP2STATESET          LPD3DHAL_DP2STATESET; //HMH

typedef D3DNTHAL_D3DEXTENDEDCAPS D3DHAL_D3DEXTENDEDCAPS;
typedef PDD_SURFACE_INT LPDDRAWI_DDRAWSURFACE_INT;
typedef D3DNTHAL_DP2POINTS *LPD3DNTHAL_DP2POINTS;
typedef D3DNTHAL_DP2RENDERSTATE *LPD3DNTHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2LINELIST *LPD3DNTHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST *LPD3DNTHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP *LPD3DNTHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST *LPD3DNTHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2TRIANGLESTRIP *LPD3DNTHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN *LPD3DNTHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE *LPD3DNTHAL_DP2TEXTURESTAGESTATE;

typedef LPD3DNTHAL_DP2POINTS LPD3DHAL_DP2POINTS;
typedef LPD3DNTHAL_DP2RENDERSTATE LPD3DHAL_DP2RENDERSTATE;
typedef LPD3DNTHAL_DP2LINELIST LPD3DHAL_DP2LINELIST;
typedef LPD3DNTHAL_DP2INDEXEDLINELIST LPD3DHAL_DP2INDEXEDLINELIST;
typedef LPD3DNTHAL_DP2LINESTRIP LPD3DHAL_DP2LINESTRIP;
typedef LPD3DNTHAL_DP2STARTVERTEX LPD3DHAL_DP2STARTVERTEX;
typedef LPD3DNTHAL_DP2TRIANGLELIST LPD3DHAL_DP2TRIANGLELIST;
typedef LPD3DNTHAL_DP2TRIANGLESTRIP LPD3DHAL_DP2TRIANGLESTRIP;
typedef LPD3DNTHAL_DP2TRIANGLEFAN LPD3DHAL_DP2TRIANGLEFAN;
typedef LPD3DNTHAL_DP2TEXTURESTAGESTATE LPD3DHAL_DP2TEXTURESTAGESTATE;
typedef LPD3DNTHAL_DP2VIEWPORTINFO LPD3DHAL_DP2VIEWPORTINFO;
typedef LPD3DNTHAL_DP2WINFO LPD3DHAL_DP2WINFO;
typedef LPD3DNTHAL_DP2TRIANGLEFAN_IMM LPD3DHAL_DP2TRIANGLEFAN_IMM;
#define NvGetFlatDataSelector() (0xffffffff)

/*
 * NT doesn't define the DX5 Clear routine's data structure, but the DX5 driver
 * routine can still be called from the DX6 clear routine to do fast buffer
 * clears, so need to define this ourselves (taken from d3d.h)
 */
#if 0
typedef struct _D3DHAL_CLEARDATA
{
    DWORD               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEARDATA;
typedef D3DHAL_CLEARDATA FAR *LPD3DHAL_CLEARDATA;
#endif
/*
 * These represent the "OS Independent" RM entry points. For NT they are functions
 * in the display driver which package the parms into a IOCTL packet and make
 * an IOCTL call to the miniport where the RM lives.
 */

#define NvRmOpen() \
    NvOpen(pDriverData->ppdev->hDriver)
#define NvRmAllocContextDma(hClient, hDma, hClass, flags, base, limit) \
    NvAllocContextDma(pDriverData->ppdev->hDriver, hClient, hDma, hClass, flags, base, limit)
#define NvRmFree(hClient, hParent, hObj) \
    NvFree(pDriverData->ppdev->hDriver, hClient, hParent, hObj)
#define NvRmAllocChannelPio(hClient, hDev, hChannel, hClass, hErrorCtx, ppChannel, flags) \
    NvAllocChannelPio(pDriverData->ppdev->hDriver, (hClient), hDev, (hChannel), (hClass), (hErrorCtx), (ppChannel), (flags))
#define NvRmAllocChannelDma(hClient, hDev, hChan, hClass, hErrorCtx, hDataCtx, offset, ppChan) \
    NvAllocChannelDma(pDriverData->ppdev->hDriver, (hClient), hDev, (hChan), (hClass), (hErrorCtx), (hDataCtx), (offset), (ppChan))
#define NvRmAllocMemory(hClient, hPar, hMem, hClass, fl, ppAddr, pLim) \
    NvAllocMemory(pDriverData->ppdev->hDriver, hClient, hPar, hMem, hClass, fl, ppAddress, pLim)
#define NvRmConfigGet(hClient, hDevice, index, pValue) \
    NvConfigGet(pDriverData->ppdev->hDriver, hClient, hDevice, index, pValue)
#define NvRmConfigSet(hClient, hDevice, index, newValue, pOldValue) \
    NvConfigSet(pDriverData->ppdev->hDriver, hClient, hDevice, index, newValue, pOldValue)
#define NvRmAllocObject(hCli, hChan, hObj, hCls) \
    NvAllocObject(pDriverData->ppdev->hDriver, hCli, hChan, hObj, hCls)
#define NvRmAlloc(hCli, hChan, hObj, hCls, parms) \
    NvAlloc(pDriverData->ppdev->hDriver, hCli, hChan, hObj, hCls, parms)

/*
 * This macro is used to force the driver to check the PDEV flag to
 * determine if overlay is supported in the current video mode. Eventually
 * we want to change this to use the internal driver routine, but we'll
 * need to redefine the NT RM entry point name to do it.
 */
#define GetVideoScalerBandwidthStatus32(surfaceFlags) \
    (pDriverData->ppdev->bHwVidOvl)

/*
 * Macros for GDI functions missing from Win2K.
 */
#define IntersectRect(pIntersect, pSrc, pDst) \
    bIntersect((PRECTL) (pSrc), (PRECTL) (pDst), (PRECTL) (pIntersect))

/*
 * Macros for DirectX heap manager functions.
 */
#define DDHAL32_VidMemAlloc(pdrv, heap, x, y) \
    HeapVidMemAllocAligned((LPVIDMEM)pDriverData->ppdev->AgpHeap, x, y, \
        &(pDriverData->ppdev->AgpHeapAlignment), &(pDriverData->ppdev->AgpDummyPitch))

#define DDHAL32_VidMemFree(pdrv, heap, surface) \
    { \
    if (pDriverData->ppdev->AgpHeap->lpHeap) \
        { \
        VidMemFree((pDriverData->ppdev->AgpHeap->lpHeap), \
          ((ULONG) (surface) - (ULONG) (pDriverData->ppdev->AgpHeapBase))); \
        } \
    }

#define NV_SLEEP
#define NV_SLEEPFLIP
#define SetPriorityClass(a, b)
#define SetThreadPriority(a, b)
#define GetCurrentThread()
#define GetCurrentProcess()
#define GetSystemInfo(a)

//********************************************************************
// Global defs.
//********************************************************************
extern SURFACEALIGNMENT    AgpHeapAlignment;
extern LONG                AgpDummyPitch;

#include "basetsd.h"             // for compiling 64-bit Merced codes.
#include <ntddvdeo.h>
#include "memstruc.h"
#include "ddmini.h"
#include "nvEscDef.h"
#include "driver.h"
#include "nvntioctl.h"
#include "nvos.h"
#endif // #ifdef WINNT
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\nv432.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1998 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1998  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

 

 /***************************************************************************\
|*                                                                           *|
|*                         NV Architecture Interface                         *|
|*                                                                           *|
|*  <nv32.h> defines a 32-bit wide naming convention  for the functionality  *|
|*  of NVIDIA's Unified Media Architecture (TM).                             *|
|*                                                                           *|
 \***************************************************************************/


#ifndef NV32_INCLUDED
#define NV32_INCLUDED
#ifdef __cplusplus
extern "C" {
#endif

#include <nvtypes.h>

#include "nv332.h"

 /***************************************************************************\
|*                                NV Classes                                 *|
 \***************************************************************************/

/*
 * These structures indicate the offsets of hardware registers corresponding to
 * the methods of each class.  Since the first 256 bytes of each subchannel is 
 * the NvControlPio registers, the hexadecimal offsets in comments start at 
 * 0x100.
 */


/* class NV01_ROOT */
#define  NV01_ROOT                                                 (0x00000000)
/* NvNotification[] fields and values */
#define NV000_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv000Typedef, Nv01Root;
#define  NV000_TYPEDEF                                             nv01Root


/* class NV01_CLASS */
#define  NV01_CLASS                                                (0x00000001)
#define  NV1_CLASS                                                 (0x00000001)
/* NvNotification[] fields and values */
#define NV001_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv001Typedef, Nv01Class;
#define  Nv1Class                                                  Nv01Class
#define  nv1Class                                                  nv01Class
#define  NV001_TYPEDEF                                             nv01Class

/* class NV01_CONTEXT_DMA_FROM_MEMORY */
#define  NV01_CONTEXT_DMA_FROM_MEMORY                              (0x00000002)
#define  NV1_CONTEXT_DMA_FROM_MEMORY                               (0x00000002)
/* NvNotification[] fields and values */
#define NV002_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv002Typedef, Nv01ContextDmaFromMemory;
#define  Nv1ContextDmaFromMemory                       Nv01ContextDmaFromMemory
#define  nv1ContextDmaFromMemory                       nv01ContextDmaFromMemory
#define  NV002_TYPEDEF                                 nv01ContextDmaFromMemory


/* class NV01_CONTEXT_DMA_TO_MEMORY */
#define  NV01_CONTEXT_DMA_TO_MEMORY                                (0x00000003)
#define  NV1_CONTEXT_DMA_TO_MEMORY                                 (0x00000003)
/* NvNotification[] fields and values */
#define NV003_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv003Typedef, Nv01ContextDmaToMemory;
#define  Nv1ContextDmaToMemory                           Nv01ContextDmaToMemory
#define  nv1ContextDmaToMemory                           nv01ContextDmaToMemory
#define  NV003_TYPEDEF                                   nv01ContextDmaToMemory


/* class NV01_TIMER */
#define  NV01_TIMER                                                (0x00000004)
#define  NV1_TIMER                                                 (0x00000004)
/* NvNotification[] elements */
#define NV004_NOTIFIERS_NOTIFY                                     (0)
#define NV004_NOTIFIERS_SET_ALARM_NOTIFY                           (1)
/* NvNotification[] fields and values */
#define NV004_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV004_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV004_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV004_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV004_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV004_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV004_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV004_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01d];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 struct {                      /* start of method                   0300-    */
  U032 nanoseconds[2];         /* nsec since 1970-01-01 0=immediate    0-   7*/
 } SetAlarmTime;               /* end of method                         -0307*/
 V032 Reserved02[0x001];
 V032 SetAlarmNotify;          /* NV004_SET_ALARM_NOTIFY_*          030c-030f*/
 V032 Reserved03[0x73c];
} Nv004Typedef, Nv01Timer;
#define Nv1Timer                                                   Nv01Timer
#define nv1Timer                                                   nv01Timer
#define NV004_TYPEDEF                                              nv01Timer
/* dma method offsets, fields, and values */
#define NV004_SET_OBJECT                                           (0x00000000)
#define NV004_NO_OPERATION                                         (0x00000100)
#define NV004_NOTIFY                                               (0x00000104)
#define NV004_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV004_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV004_STOP_TRANSFER                                        (0x00000108)
#define NV004_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV004_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV004_SET_ALARM_TIME                                       (0x00000300)
#define NV004_SET_ALARM_NOTIFY                                     (0x0000030C)
#define NV004_SET_ALARM_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NV004_SET_ALARM_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)

typedef V032 Nv005Typedef;

typedef V032 Nv006Typedef;

typedef V032 Nv007Typedef;

typedef V032 Nv008Typedef;

typedef V032 Nv009Typedef;

typedef V032 Nv00aTypedef;

typedef V032 Nv00bTypedef;

typedef V032 Nv00cTypedef;

typedef V032 Nv00dTypedef;

typedef V032 Nv00eTypedef;

typedef V032 Nv00fTypedef;

typedef V032 Nv010Typedef;

typedef V032 Nv011Typedef;


/* class NV01_BETA_SOLID */
#define  NV01_BETA_SOLID                                           (0x00000012)
#define  NV1_BETA_SOLID                                            (0x00000012)
/* NvNotification[] elements */
#define NV012_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV012_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV012_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV012_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV012_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV012_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV012_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV012_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetBetaOutput;           /* NV01_PATCHCORD_BETA               0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetBeta1d31;             /* S1d31 beta value                  0300-0303*/
 V032 Reserved03[0x73f];
} Nv012Typedef, Nv01BetaSolid;
#define Nv1BetaSolid                                              Nv01BetaSolid
#define nv1BetaSolid                                              nv01BetaSolid
#define NV012_TYPEDEF                                             nv01BetaSolid
/* dma method offsets, fields, and values */
#define NV012_SET_OBJECT                                           (0x00000000)
#define NV012_NO_OPERATION                                         (0x00000100)
#define NV012_NOTIFY                                               (0x00000104)
#define NV012_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV012_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV012_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV012_SET_BETA_OUTPUT                                      (0x00000200)
#define NV012_SET_BETA_1D31                                        (0x00000300)

typedef V032 Nv013Typedef;

typedef V032 Nv014Typedef;

typedef V032 Nv015Typedef;

typedef V032 Nv016Typedef;


/* class NV01_IMAGE_SOLID */
#define  NV01_IMAGE_SOLID                                          (0x00000017)
#define  NV1_IMAGE_SOLID                                           (0x00000017)
/* NvNotification[] elements */
#define NV017_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV017_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV017_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV017_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV017_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV017_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV017_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV017_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV01_PATCHCORD_IMAGE              0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetColorFormat;          /* NV017_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColor;                /* source color                      0304-0307*/
 V032 Reserved03[0x73e];
} Nv017Typedef, Nv01ImageSolid;
#define Nv1ImageSolid                                            Nv01ImageSolid
#define nv1ImageSolid                                            nv01ImageSolid
#define NV017_TYPEDEF                                            nv01ImageSolid
/* dma method offsets, fields, and values */
#define NV017_SET_OBJECT                                           (0x00000000)
#define NV017_NO_OPERATION                                         (0x00000100)
#define NV017_NOTIFY                                               (0x00000104)
#define NV017_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV017_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV017_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV017_SET_IMAGE_OUTPUT                                     (0x00000200)
#define NV017_SET_COLOR_FORMAT                                     (0x00000300)
#define NV017_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV017_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV017_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV017_SET_COLOR                                            (0x00000304)


/* class NV01_IMAGE_PATTERN */
#define  NV01_IMAGE_PATTERN                                        (0x00000018)
#define  NV1_IMAGE_PATTERN                                         (0x00000018)
/* NvNotification[] elements */
#define NV018_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV018_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV018_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV018_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV018_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV018_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV018_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV018_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV01_PATCHCORD_IMAGE              0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetColorFormat;          /* NV018_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV018_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 SetMonochromeShape;      /* NV018_SET_MONOCHROME_SHAPE_*      0308-030b*/
 V032 Reserved03[0x001];
 V032 SetMonochromeColor0;     /* color of 0 pixels                 0310-0313*/
 V032 SetMonochromeColor1;     /* color of 1 pixels                 0314-0317*/
 V032 SetMonochromePattern0;   /* first  32 bits of pattern data    0318-031b*/
 V032 SetMonochromePattern1;   /* second 32 bits of pattern data    031c-031f*/
 V032 Reserved05[0x738];
} Nv018Typedef, Nv01ImagePattern;
#define Nv1ImagePattern                                        Nv01ImagePattern
#define nv1ImagePattern                                        nv01ImagePattern
#define NV018_TYPEDEF                                          nv01ImagePattern
/* dma method offsets, fields, and values */
#define NV018_SET_OBJECT                                           (0x00000000)
#define NV018_NO_OPERATION                                         (0x00000100)
#define NV018_NOTIFY                                               (0x00000104)
#define NV018_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV018_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV018_SET_IMAGE_OUTPUT                                     (0x00000200)
#define NV018_SET_COLOR_FORMAT                                     (0x00000300)
#define NV018_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV018_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV018_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV018_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV018_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV018_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV018_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV018_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV018_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV018_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV018_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV018_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV018_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV018_SET_MONOCHORME_PATTERN1                              (0x0000031C)


/* class NV01_IMAGE_BLACK_RECTANGLE */
#define  NV01_IMAGE_BLACK_RECTANGLE                                (0x00000019)
#define  NV1_IMAGE_BLACK_RECTANGLE                                 (0x00000019)
/* NvNotification[] elements */
#define NV019_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV019_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV019_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV019_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV019_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV019_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV019_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV019_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV01_PATCHCORD_IMAGE              0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetPoint;                /* y_x S16_S16                       0300-0303*/
 V032 SetSize;                 /* height_width U16_U16              0304-0307*/
 V032 Reserved03[0x73e];
} Nv019Typedef, Nv01ImageBlackRectangle;
#define Nv1ImageBlackRectangle                          Nv01ImageBlackRectangle
#define nv1ImageBlackRectangle                          nv01ImageBlackRectangle
#define NV019_TYPEDEF                                   nv01ImageBlackRectangle
/* dma method offsets, fields, and values */
#define NV019_SET_OBJECT                                           (0x00000000)
#define NV019_NO_OPERATION                                         (0x00000100)
#define NV019_NOTIFY                                               (0x00000104)
#define NV019_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV019_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV019_SET_IMAGE_OUTPUT                                     (0x00000200)
#define NV019_SET_POINT                                            (0x00000300)
#define NV019_SET_POINT_X                                          15:0
#define NV019_SET_POINT_Y                                          31:16
#define NV019_SET_SIZE                                             (0x00000304)
#define NV019_SET_SIZE_WIDTH                                       15:0
#define NV019_SET_SIZE_HEIGHT                                      31:16

typedef V032 Nv01aTypedef;

typedef V032 Nv01bTypedef;


/* class NV01_RENDER_SOLID_LIN */
#define  NV01_RENDER_SOLID_LIN                                     (0x0000001C)
#define  NV1_RENDER_SOLID_LIN                                      (0x0000001C)
/* NvNotification[] elements */
#define NV01C_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01C_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV01C_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV01C_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point0;                 /* y_x S16_S16 in pixels                0-   3*/
  V032 point1;                 /* y_x S16_S16 in pixels                4-   7*/
 } Lin[16];                    /* end of aliased methods in array       -047f*/
 struct {                      /* start of aliased methods in array 0480-    */
  S032 point0X;                /* in pixels, 0 at left                 0-   3*/
  S032 point0Y;                /* in pixels, 0 at top                  4-   7*/
  S032 point1X;                /* in pixels, 0 at left                 8-   b*/
  S032 point1Y;                /* in pixels, 0 at top                  c-   f*/
 } Lin32[8];                   /* end of aliased methods in array       -04ff*/
 V032 PolyLin[32];             /* y_x S16_S16 in pixels             0500-057f*/
 struct {                      /* start of aliased methods in array 0580-    */
  S032 x;                      /* in pixels, 0 at left                 0-   3*/
  S032 y;                      /* in pixels, 0 at top                  4-   7*/
 } PolyLin32[16];              /* end of aliased methods in array       -05ff*/
 struct {                      /* start of aliased methods in array 0600-    */
  V032 color;                  /* source color                         0-   3*/
  V032 point;                  /* y_x S16_S16 in pixels                4-   7*/
 } ColorPolyLin[16];           /* end of aliased methods in array       -067f*/
 V032 Reserved03[0x660];
} Nv01cTypedef, Nv01RenderSolidLin;
#define Nv1RenderSolidLin                                    Nv01RenderSolidLin
#define nv1RenderSolidLin                                    nv01RenderSolidLin
#define NV01C_TYPEDEF                                        nv01RenderSolidLin
/* dma method offsets, fields, and values */
#define NV01C_SET_OBJECT                                           (0x00000000)
#define NV01C_NO_OPERATION                                         (0x00000100)
#define NV01C_NOTIFY                                               (0x00000104)
#define NV01C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01C_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV01C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01C_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01C_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01C_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01C_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01C_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01C_SET_OPERATION                                        (0x000002FC)
#define NV01C_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01C_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01C_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01C_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01C_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01C_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01C_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01C_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01C_COLOR                                                (0x00000304)
#define NV01C_LIN(a)                                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT0(a)                                        (0x00000400\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT0_X                                         15:0
#define NV01C_LIN_POINT0_Y                                         31:16
#define NV01C_LIN_POINT1(a)                                        (0x00000404\
                                                                   +(a)*0x0008)
#define NV01C_LIN_POINT1_X                                         15:0
#define NV01C_LIN_POINT1_Y                                         31:16
#define NV01C_LIN32(a)                                             (0x00000480\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT0_X(a)                                    (0x00000480\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT0_Y(a)                                    (0x00000484\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT1_X(a)                                    (0x00000488\
                                                                   +(a)*0x0010)
#define NV01C_LIN32_POINT1_Y(a)                                    (0x0000048C\
                                                                   +(a)*0x0010)
#define NV01C_POLY_LIN(a)                                          (0x00000500\
                                                                   +(a)*0x0004)
#define NV01C_POLY_LIN_X                                           15:0
#define NV01C_POLY_LIN_Y                                           31:16
#define NV01C_POLY_LIN32(a)                                        (0x00000580\
                                                                   +(a)*0x0008)
#define NV01C_POLY_LIN32_X(a)                                      (0x00000580\
                                                                   +(a)*0x0008)
#define NV01C_POLY_LIN32_Y(a)                                      (0x00000584\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN(a)                                    (0x00000600\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_COLOR(a)                              (0x00000600\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_POINT(a)                              (0x00000604\
                                                                   +(a)*0x0008)
#define NV01C_COLOR_POLY_LIN_POINT_X                               15:0
#define NV01C_COLOR_POLY_LIN_POINT_Y                               31:16


/* class NV01_RENDER_SOLID_TRIANGLE */
#define  NV01_RENDER_SOLID_TRIANGLE                                (0x0000001D)
#define  NV1_RENDER_SOLID_TRIANGLE                                 (0x0000001D)
/* NvNotification[] elements */
#define NV01D_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01D_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV01D_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV01D_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x002];
 V032 TrianglePoint0;          /* y_x S16_S16 in pixels             0310-0313*/
 V032 TrianglePoint1;          /* y_x S16_S16 in pixels             0314-0317*/
 V032 TrianglePoint2;          /* y_x S16_S16 in pixels             0318-031b*/
 V032 Reserved03[0x001];
 S032 Triangle32Point0X;       /* in pixels, 0 at left              0320-0323*/
 S032 Triangle32Point0Y;       /* in pixels, 0 at top               0324-0327*/
 S032 Triangle32Point1X;       /* in pixels, 0 at left              0328-032b*/
 S032 Triangle32Point1Y;       /* in pixels, 0 at top               032c-032f*/
 S032 Triangle32Point2X;       /* in pixels, 0 at left              0330-0333*/
 S032 Triangle32Point2Y;       /* in pixels, 0 at top               0334-0337*/
 V032 Reserved04[0x032];
 V032 Trimesh[32];             /* y_x S16_S16 in pixels             0400-047f*/
 struct {                      /* start of aliased methods in array 0480-    */
  S032 x;                      /* in pixels, 0 at left                 0-   3*/
  S032 y;                      /* in pixels, 0 at top                  4-   7*/
 } Trimesh32[16];              /* end of aliased methods in array       -04ff*/
 struct {                      /* start of aliased methods in array 0500-    */
  V032 color;                  /* source color                         0-   3*/
  V032 y0_x0;                  /* S16_S16 in pixels, 0 at top left     4-   7*/
  V032 y1_x1;                  /* S16_S16 in pixels, 0 at top left     8-   b*/
  V032 y2_x2;                  /* S16_S16 in pixels, 0 at top left     c-   f*/
 } ColorTriangle[8];           /* end of aliased methods in array       -057f*/
 struct {                      /* start of aliased methods in array 0580-    */
  V032 color;                  /* source color                         0-   3*/
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left     4-   7*/
 } ColorTrimesh[16];           /* end of aliased methods in array       -05ff*/
 V032 Reserved05[0x680];
} Nv01dTypedef, Nv01RenderSolidTriangle;
#define Nv1RenderSolidTriangle                          Nv01RenderSolidTriangle
#define nv1RenderSolidTriangle                          nv01RenderSolidTriangle
#define NV01D_TYPEDEF                                   nv01RenderSolidTriangle
/* dma method offsets, fields, and values */
#define NV01D_SET_OBJECT                                           (0x00000000)
#define NV01D_NO_OPERATION                                         (0x00000100)
#define NV01D_NOTIFY                                               (0x00000104)
#define NV01D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV01D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01D_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01D_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01D_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01D_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01D_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01D_SET_OPERATION                                        (0x000002FC)
#define NV01D_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01D_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01D_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01D_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01D_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01D_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01D_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01D_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01D_COLOR                                                (0x00000304)
#define NV01D_TRIANGLE_POINT0                                      (0x00000310)
#define NV01D_TRIANGLE_POINT0_X                                    15:0
#define NV01D_TRIANGLE_POINT0_Y                                    31:16
#define NV01D_TRIANGLE_POINT1                                      (0x00000314)
#define NV01D_TRIANGLE_POINT1_X                                    15:0
#define NV01D_TRIANGLE_POINT1_Y                                    31:16
#define NV01D_TRIANGLE_POINT2                                      (0x00000318)
#define NV01D_TRIANGLE_POINT2_X                                    15:0
#define NV01D_TRIANGLE_POINT2_Y                                    31:16
#define NV01D_TRIANGLE32_POINT0_X                                  (0x00000320)
#define NV01D_TRIANGLE32_POINT0_Y                                  (0x00000324)
#define NV01D_TRIANGLE32_POINT1_X                                  (0x00000328)
#define NV01D_TRIANGLE32_POINT1_Y                                  (0x0000032C)
#define NV01D_TRIANGLE32_POINT2_X                                  (0x00000330)
#define NV01D_TRIANGLE32_POINT2_Y                                  (0x00000334)
#define NV01D_TRIMESH(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
#define NV01D_TRIMESH_X                                            15:0
#define NV01D_TRIMESH_Y                                            31:16
#define NV01D_TRIMESH32(a)                                         (0x00000480\
                                                                   +(a)*0x0008)
#define NV01D_TRIMESH32_X(a)                                       (0x00000480\
                                                                   +(a)*0x0008)
#define NV01D_TRIMESH32_Y(a)                                       (0x00000484\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIANGLE(a)                                    (0x00000500\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_COLOR(a)                              (0x00000500\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT0(a)                             (0x00000504\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT0_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT0_Y                              31:16
#define NV01D_COLOR_TRIANGLE_POINT1(a)                             (0x00000508\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT1_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT1_Y                              31:16
#define NV01D_COLOR_TRIANGLE_POINT2(a)                             (0x0000050C\
                                                                   +(a)*0x0010)
#define NV01D_COLOR_TRIANGLE_POINT2_X                              15:0
#define NV01D_COLOR_TRIANGLE_POINT2_Y                              31:16
#define NV01D_COLOR_TRIMESH(a)                                     (0x00000580\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_COLOR(a)                               (0x00000580\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_POINT(a)                               (0x00000584\
                                                                   +(a)*0x0008)
#define NV01D_COLOR_TRIMESH_POINT_X                                15:0
#define NV01D_COLOR_TRIMESH_POINT_Y                                31:16


/* class NV01_RENDER_SOLID_RECTANGLE */
#define  NV01_RENDER_SOLID_RECTANGLE                               (0x0000001E)
#define  NV1_RENDER_SOLID_RECTANGLE                                (0x0000001E)
/* NvNotification[] elements */
#define NV01E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01E_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV01E_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV01E_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* y_x S16_S16                          0-   3*/
  V032 size;                   /* height_width U16_U16                 4-   7*/
 } Rectangle[16];              /* end of method in array in array       -047f*/
 V032 Reserved03[0x6e0];
} Nv01eTypedef, Nv01RenderSolidRectangle;
#define Nv1RenderSolidRectangle                        Nv01RenderSolidRectangle
#define nv1RenderSolidRectangle                        nv01RenderSolidRectangle
#define NV01E_TYPEDEF                                  nv01RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV01E_SET_OBJECT                                           (0x00000000)
#define NV01E_NO_OPERATION                                         (0x00000100)
#define NV01E_NOTIFY                                               (0x00000104)
#define NV01E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV01E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01E_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01E_SET_OPERATION                                        (0x000002FC)
#define NV01E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01E_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01E_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01E_COLOR                                                (0x00000304)
#define NV01E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT_X                                    15:0
#define NV01E_RECTANGLE_POINT_Y                                    31:16
#define NV01E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV01E_RECTANGLE_SIZE_HEIGHT                                31:16


/* class NV01_IMAGE_BLIT */
#define  NV01_IMAGE_BLIT                                           (0x0000001F)
#define  NV1_IMAGE_BLIT                                            (0x0000001F)
/* NvNotification[] elements */
#define NV01F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV01F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV01F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV01F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV01F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV01F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01F_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV01_IMAGE_SOLID                  0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                018c-018f*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0190-0193*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0194-0197*/
 V032 SetContextSurfaceSource; /* NV03_CONTEXT_SURFACE_1            0198-019b*/
 V032 SetContextSurfaceDestin; /* NV03_CONTEXT_SURFACE_0            019c-019f*/
 V032 Reserved01[0x057];
 V032 SetOperation;            /* NV01F_SET_OPERATION_*             02fc-02ff*/
 V032 ControlPointIn;          /* y_x U16_U16, pixels, top left src 0300-0303*/
 V032 ControlPointOut;         /* y_x S16_S16, pixels, top left dst 0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels    0308-030b*/
 V032 Reserved02[0x73d];
} Nv01fTypedef, Nv01ImageBlit;
#define Nv1ImageBlit                                              Nv01ImageBlit
#define nv1ImageBlit                                              nv01ImageBlit
#define NV01F_TYPEDEF                                             nv01ImageBlit
/* dma method offsets, fields, and values */
#define NV01F_SET_OBJECT                                           (0x00000000)
#define NV01F_NO_OPERATION                                         (0x00000100)
#define NV01F_NOTIFY                                               (0x00000104)
#define NV01F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV01F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV01F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV01F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV01F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV01F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV01F_SET_CONTEXT_SURFACE_SOURCE                           (0x00000198)
#define NV01F_SET_CONTEXT_SURFACE_DESTIN                           (0x0000019C)
#define NV01F_SET_OPERATION(s)                                     (0x000002FC)
#define NV01F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01F_CONTROL_POINT_IN                                     (0x00000300)
#define NV01F_CONTROL_POINT_IN_X                                   15:0
#define NV01F_CONTROL_POINT_IN_Y                                   31:16
#define NV01F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV01F_CONTROL_POINT_OUT_X                                  15:0
#define NV01F_CONTROL_POINT_OUT_Y                                  31:16
#define NV01F_SIZE                                                 (0x00000308)
#define NV01F_SIZE_WIDTH                                           15:0
#define NV01F_SIZE_HEIGHT                                          31:16

typedef V032 Nv020Typedef;


/* class NV01_IMAGE_FROM_CPU */
#define  NV01_IMAGE_FROM_CPU                                       (0x00000021)
#define  NV1_IMAGE_FROM_CPU                                        (0x00000021)
/* NvNotification[] elements */
#define NV021_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV021_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV021_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV021_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV021_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV021_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV021_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV01_IMAGE_SOLID                  0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                018c-018f*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0190-0193*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0194-0197*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV021_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV021_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels             0304-0307*/
 V032 SizeOut;                 /* height_width U16_U16, pixels, dst 0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16, pixels, src 030c-030f*/
 V032 Reserved02[0x03c];
 V032 Color[32];               /* packed pixel(s) to add to image   0400-047f*/
 V032 Reserved03[0x6e0];
} Nv021Typedef, Nv01ImageFromCpu;
#define Nv1ImageFromCpu                                        Nv01ImageFromCpu
#define nv1ImageFromCpu                                        nv01ImageFromCpu
#define NV021_TYPEDEF                                          nv01ImageFromCpu
/* dma method offsets, fields, and values */
#define NV021_SET_OBJECT                                           (0x00000000)
#define NV021_NO_OPERATION                                         (0x00000100)
#define NV021_NOTIFY                                               (0x00000104)
#define NV021_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV021_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV021_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV021_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV021_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV021_SET_CONTEXT_ROP                                      (0x00000190)
#define NV021_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV021_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV021_SET_OPERATION                                        (0x000002FC)
#define NV021_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV021_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV021_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV021_SET_COLOR_FORMAT                                     (0x00000300)
#define NV021_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV021_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV021_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV021_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV021_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV021_POINT                                                (0x00000304)
#define NV021_POINT_X                                              15:0
#define NV021_POINT_Y                                              31:16
#define NV021_SIZE_OUT                                             (0x00000308)
#define NV021_SIZE_OUT_WIDTH                                       15:0
#define NV021_SIZE_OUT_HEIGHT                                      31:16
#define NV021_SIZE_IN                                              (0x0000030C)
#define NV021_SIZE_IN_WIDTH                                        15:0
#define NV021_SIZE_IN_HEIGHT                                       31:16
#define NV021_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)

typedef V032 Nv022Typedef;

typedef V032 Nv023Typedef;

typedef V032 Nv024Typedef;

typedef V032 Nv025Typedef;

typedef V032 Nv026Typedef;

typedef V032 Nv027Typedef;

typedef V032 Nv028Typedef;

typedef V032 Nv029Typedef;

typedef V032 Nv02aTypedef;

typedef V032 Nv02bTypedef;

typedef V032 Nv02cTypedef;

typedef V032 Nv02dTypedef;

typedef V032 Nv02eTypedef;

typedef V032 Nv02fTypedef;


/* class NV01_NULL */
#define  NV01_NULL                                                 (0x00000030)
#define  NV1_NULL                                                  (0x00000030)
/* NvNotification[] fields and values */
#define NV030_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv030Typedef, Nv01Null;
#define  Nv1Null                                                   Nv01Null
#define  nv1Null                                                   nv01Null
#define  NV030_TYPEDEF                                             nv01Null

typedef V032 Nv031Typedef;

typedef V032 Nv032Typedef;

typedef V032 Nv033Typedef;

typedef V032 Nv034Typedef;

typedef V032 Nv035Typedef;



/* class NV03_STRETCHED_IMAGE_FROM_CPU */
#define  NV03_STRETCHED_IMAGE_FROM_CPU                             (0x00000036)
#define  NV3_STRETCHED_IMAGE_FROM_CPU                              (0x00000036)
/* NvNotification[] elements */
#define NV036_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV036_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV036_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV036_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV036_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV036_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV036_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV036_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV01_IMAGE_SOLID                  0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV036_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV036_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SizeIn;                  /* height_width U16_U16 in texels    0304-0307*/
 V032 DeltaDxDu;               /* S12d20 ratio dx/du                0308-030b*/
 V032 DeltaDyDv;               /* S12d20 ratio dy/dv                030c-030f*/
 V032 ClipPoint;               /* y_x S16_S16                       0310-0313*/
 V032 ClipSize;                /* height_width U16_U16              0314-0317*/
 V032 Point12d4;               /* y_x S12d4_S12d4 in pixels         0318-031b*/
 V032 Reserved02[0x039];
 V032 Color[1792];             /* source colors (packed texels)     0400-1fff*/
} Nv036Typedef, Nv03StretchedImageFromCpu;
#define Nv3StretchedImageFromCpu                      Nv03StretchedImageFromCpu
#define nv3StretchedImageFromCpu                      nv03StretchedImageFromCpu
#define NV036_TYPEDEF                                 nv03StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV036_SET_OBJECT                                           (0x00000000)
#define NV036_NO_OPERATION                                         (0x00000100)
#define NV036_NOTIFY                                               (0x00000104)
#define NV036_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV036_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV036_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV036_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV036_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV036_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV036_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV036_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV036_SET_OPERATION                                        (0x000002FC)
#define NV036_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV036_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV036_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV036_SET_COLOR_FORMAT                                     (0x00000300)
#define NV036_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV036_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV036_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV036_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV036_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV036_SIZE_IN                                              (0x00000304)
#define NV036_SIZE_IN_WIDTH                                        15:0
#define NV036_SIZE_IN_HEIGHT                                       31:16
#define NV036_DELTA_DX_DU                                          (0x00000308)
#define NV036_DELTA_DY_DV                                          (0x0000030C)
#define NV036_CLIP_POINT                                           (0x00000310)
#define NV036_CLIP_POINT_X                                         15:0
#define NV036_CLIP_POINT_Y                                         31:16
#define NV036_CLIP_SIZE                                            (0x00000314)
#define NV036_CLIP_SIZE_WIDTH                                      15:0
#define NV036_CLIP_SIZE_HEIGHT                                     31:16
#define NV036_POINT_12D4                                           (0x00000318)
#define NV036_POINT_12D4_X                                         15:0
#define NV036_POINT_12D4_Y                                         31:16
#define NV036_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


/* class NV03_SCALED_IMAGE_FROM_MEMORY */
#define  NV03_SCALED_IMAGE_FROM_MEMORY                             (0x00000037)
#define  NV3_SCALED_IMAGE_FROM_MEMORY                              (0x00000037)
/* NvNotification[] elements */
#define NV037_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV037_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV037_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV037_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV037_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV037_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV037_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV037_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0194-0197*/
 V032 Reserved01[0x05A];
 V032 SetColorFormat;          /* NV037_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetOperation;            /* NV037_SET_OPERATION_*             0304-0307*/
 V032 ClipPoint;               /* y_x S16_S16                       0308-030b*/
 V032 ClipSize;                /* height_width U16_U16              030c-030f*/
 V032 ImageOutPoint;           /* y_x S16_S16                       0310-0313*/
 V032 ImageOutSize;            /* height_width U16_U16              0314-0317*/
 V032 DeltaDuDx;               /* S12d20 ratio du/dx                0318-031b*/
 V032 DeltaDvDy;               /* S12d20 ratio dv/dy                031c-031f*/
 V032 Reserved02[0x038];
 V032 ImageInSize;             /* height_width U16_U16              0400-0403*/
 U032 ImageInPitch;            /* bytes, vertical pixel delta       0404-0407*/
 U032 ImageInOffset;           /* byte offset of top-left texel     0408-040b*/
 V032 ImageInPoint;            /* v_u U12d4_U12d4                   040c-040f*/
 V032 Reserved03[0x6fc];
} Nv037Typedef, Nv03ScaledImageFromMemory;
#define Nv3ScaledImageFromMemory                      Nv03ScaledImageFromMemory
#define nv3ScaledImageFromMemory                      nv03ScaledImageFromMemory
#define NV037_TYPEDEF                                 nv03ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV037_SET_OBJECT                                           (0x00000000)
#define NV037_NO_OPERATION                                         (0x00000100)
#define NV037_NOTIFY                                               (0x00000104)
#define NV037_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV037_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV037_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV037_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV037_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV037_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV037_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV037_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV037_SET_COLOR_FORMAT                                     (0x00000300)
#define NV037_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV037_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV037_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV037_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV037_SET_COLOR_FORMAT_LE_V8YB8U8YA8                       (0x00000005)
#define NV037_SET_COLOR_FORMAT_LE_YB8V8YA8U8                       (0x00000006)
#define NV037_SET_OPERATION                                        (0x00000304)
#define NV037_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV037_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV037_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV037_CLIP_POINT                                           (0x00000308)
#define NV037_CLIP_POINT_X                                         15:0
#define NV037_CLIP_POINT_Y                                         31:16
#define NV037_CLIP_SIZE                                            (0x0000030C)
#define NV037_CLIP_SIZE_WIDTH                                      15:0
#define NV037_CLIP_SIZE_HEIGHT                                     31:16
#define NV037_IMAGE_OUT_POINT                                      (0x00000310)
#define NV037_IMAGE_OUT_POINT_X                                    15:0
#define NV037_IMAGE_OUT_POINT_Y                                    31:16
#define NV037_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV037_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV037_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV037_DELTA_DU_DX                                          (0x00000318)
#define NV037_DELTA_DV_DY                                          (0x0000031C)
#define NV037_IMAGE_IN_SIZE                                        (0x00000400)
#define NV037_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV037_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV037_IMAGE_IN_PITCH                                       (0x00000404)
#define NV037_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV037_IMAGE_IN_POINT                                       (0x0000040C)
#define NV037_IMAGE_IN_POINT_U                                     15:0
#define NV037_IMAGE_IN_POINT_V                                     31:16


/* class NV04_DVD_SUBPICTURE */
#define  NV04_DVD_SUBPICTURE                                       (0x00000038)
#define  NV4_DVD_SUBPICTURE                                        (0x00000038)
/* NvNotification[] elements */
#define NV038_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV038_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV038_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV038_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV038_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV038_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV038_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV038_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaOverlay;    /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaImageIn;    /* NV01_CONTEXT_DMA_FROM_MEMORY      0188-018b*/
 V032 SetContextDmaImageOut;   /* NV01_CONTEXT_DMA_TO_MEMORY        018c-018f*/
 V032 Reserved01[0x05c];
 V032 ImageOutPoint;           /* y_x S16_S16                       0300-0303*/
 V032 ImageOutSize;            /* height_width U16_U16              0304-0307*/
 U032 ImageOutFormat;          /* color_pitch V16_U16               0308-030b*/
 U032 ImageOutOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 ImageInDeltaDuDx;        /* S12d20 ratio du/dx                0310-0313*/
 V032 ImageInDeltaDvDy;        /* S12d20 ratio dv/dy                0314-0317*/
 V032 ImageInSize;             /* height_width U16_U16 in texels    0318-031b*/
 V032 ImageInFormat;           /* color_pitch V16_U16               031c-031f*/
 U032 ImageInOffset;           /* byte offset of top-left texel     0320-0323*/
 V032 ImageInPoint;            /* v_u U12d4_U12d4 in texels         0324-0317*/
 V032 OverlayDeltaDuDx;        /* S12d20 ratio du/dx                0328-032b*/
 V032 OverlayDeltaDvDy;        /* S12d20 ratio dv/dy                032c-032f*/
 V032 OverlaySize;             /* height_width U16_U16 in texels    0330-0333*/
 V032 OverlayFormat;           /* color_pitch V16_U16               0334-0337*/
 U032 OverlayOffset;           /* byte offset of top-left texel     0338-033b*/
 V032 OverlayPoint;            /* v_u U12d4_U12d4 in texels         033c-033f*/
 V032 Reserved02[0x730];
} Nv038Typedef, Nv04DvdSubpicture;
#define Nv4DvdSubpicture                                      Nv04DvdSubpicture
#define nv4DvdSubpicture                                      nv04DvdSubpicture
#define NV038_TYPEDEF                                         nv04DvdSubpicture
/* dma method offsets, fields, and values */
#define NV038_SET_OBJECT                                           (0x00000000)
#define NV038_NO_OPERATION                                         (0x00000100)
#define NV038_NOTIFY                                               (0x00000104)
#define NV038_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV038_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV038_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV038_SET_CONTEXT_DMA_OVERLAY                              (0x00000184)
#define NV038_SET_CONTEXT_DMA_IMAGE_IN                             (0x00000188)
#define NV038_SET_CONTEXT_DMA_IMAGE_OUT                            (0x0000018C)
#define NV038_IMAGE_OUT_POINT                                      (0x00000300)
#define NV038_IMAGE_OUT_POINT_X                                    15:0
#define NV038_IMAGE_OUT_POINT_Y                                    31:16
#define NV038_IMAGE_OUT_SIZE                                       (0x00000304)
#define NV038_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV038_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV038_IMAGE_OUT_FORMAT                                     (0x00000308)
#define NV038_IMAGE_OUT_FORMAT_PITCH                               15:0
#define NV038_IMAGE_OUT_FORMAT_COLOR                               31:16
#define NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8                 (0x00000001)
#define NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8                 (0x00000002)
#define NV038_IMAGE_OUT_OFFSET                                     (0x0000030C)
#define NV038_IMAGE_IN_DELTA_DU_DX                                 (0x00000310)
#define NV038_IMAGE_IN_DELTA_DV_DY                                 (0x00000314)
#define NV038_IMAGE_IN_SIZE                                        (0x00000318)
#define NV038_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV038_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV038_IMAGE_IN_FORMAT                                      (0x0000031C)
#define NV038_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV038_IMAGE_IN_FORMAT_COLOR                                31:16
#define NV038_IMAGE_IN_FORMAT_COLOR_LE_V8YB8U8YA8                  (0x00000001)
#define NV038_IMAGE_IN_FORMAT_COLOR_LE_YB8V8YA8U8                  (0x00000002)
#define NV038_IMAGE_IN_OFFSET                                      (0x00000320)
#define NV038_IMAGE_IN_POINT                                       (0x00000324)
#define NV038_IMAGE_IN_POINT_U                                     15:0
#define NV038_IMAGE_IN_POINT_V                                     31:16
#define NV038_OVERLAY_DELTA_DU_DX                                  (0x00000328)
#define NV038_OVERLAY_DELTA_DV_DY                                  (0x0000032C)
#define NV038_OVERLAY_SIZE                                         (0x00000330)
#define NV038_OVERLAY_SIZE_WIDTH                                   15:0
#define NV038_OVERLAY_SIZE_HEIGHT                                  31:16
#define NV038_OVERLAY_FORMAT                                       (0x00000334)
#define NV038_OVERLAY_FORMAT_PITCH                                 15:0
#define NV038_OVERLAY_FORMAT_COLOR                                 31:16
#define NV038_OVERLAY_FORMAT_COLOR_LE_A8V8U8Y8                     (0x00000001)
#define NV038_OVERLAY_FORMAT_COLOR_LE_A4V6YB6A4U6YA6               (0x00000002)
#define NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT                  (0x00000003)
#define NV038_OVERLAY_OFFSET                                       (0x00000338)
#define NV038_OVERLAY_POINT                                        (0x0000033C)
#define NV038_OVERLAY_POINT_U                                      15:0
#define NV038_OVERLAY_POINT_V                                      31:16


/* class NV03_MEMORY_TO_MEMORY_FORMAT */
#define  NV03_MEMORY_TO_MEMORY_FORMAT                              (0x00000039)
#define  NV3_MEMORY_TO_MEMORY_FORMAT                               (0x00000039)
/* NvNotification[] elements */
#define NV039_NOTIFIERS_NOTIFY                                     (0)
#define NV039_NOTIFIERS_BUFFER_NOTIFY                              (1)
/* NvNotification[] fields and values */
#define NV039_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV039_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV039_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV039_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV039_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV039_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV039_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaBufferIn;   /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaBufferOut;  /* NV01_CONTEXT_DMA_TO_MEMORY        0188-018b*/
 V032 Reserved01[0x060];
 U032 OffsetIn;                /* src offset in bytes               030c-030f*/
 U032 OffsetOut;               /* dst offset in bytes               0310-0313*/
 S032 PitchIn;                 /* delta in bytes, vert pixel delta  0314-0317*/
 S032 PitchOut;                /* delta in bytes, vert pixel delta  0318-031b*/
 U032 LineLengthIn;            /* in bytes                          031c-031f*/
 U032 LineCount;               /* in lines                          0320-0323*/
 V032 Format;                  /* out_in U24_U8                     0324-0327*/
 V032 BufferNotify;            /* NV039_BUFFER_NOTIFY_*             0328-032b*/
 V032 Reserved02[0x735];
} Nv039Typedef, Nv03MemoryToMemoryFormat;
#define Nv3MemoryToMemoryFormat                        Nv03MemoryToMemoryFormat
#define nv3MemoryToMemoryFormat                        nv03MemoryToMemoryFormat
#define NV039_TYPEDEF                                  nv03MemoryToMemoryFormat
/* dma method offsets, fields, and values */
#define NV039_SET_OBJECT                                           (0x00000000)
#define NV039_NO_OPERATION                                         (0x00000100)
#define NV039_NOTIFY                                               (0x00000104)
#define NV039_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV039_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV039_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV039_SET_CONTEXT_DMA_BUFFER_IN                            (0x00000184)
#define NV039_SET_CONTEXT_DMA_BUFFER_OUT                           (0x00000188)
#define NV039_OFFSET_IN                                            (0x0000030C)
#define NV039_OFFSET_OUT                                           (0x00000310)
#define NV039_PITCH_IN                                             (0x00000314)
#define NV039_PITCH_OUT                                            (0x00000318)
#define NV039_LINE_LENGTH_IN                                       (0x0000031C)
#define NV039_LINE_COUNT                                           (0x00000320)
#define NV039_FORMAT                                               (0x00000324)
#define NV039_FORMAT_IN                                            7:0
#define NV039_FORMAT_OUT                                           31:8
#define NV039_BUFFER_NOTIFY                                        (0x00000328)
#define NV039_BUFFER_NOTIFY_WRITE_ONLY                             (0x00000000)
#define NV039_BUFFER_NOTIFY_WRITE_THEN_AWAKEN                      (0x00000001)

typedef V032 Nv03aTypedef;

typedef V032 Nv03bTypedef;

typedef V032 Nv03cTypedef;



/* class NV01_CONTEXT_DMA_IN_MEMORY */
#define  NV01_CONTEXT_DMA_IN_MEMORY                                (0x0000003D)
#define  NV1_CONTEXT_DMA_IN_MEMORY                                 (0x0000003D)
/* NvNotification[] fields and values */
#define NV03D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv03dTypedef, Nv01ContextDmaInMemory;
#define  Nv1ContextDmaInMemory                           Nv01ContextDmaInMemory
#define  nv1ContextDmaInMemory                           nv01ContextDmaInMemory
#define  NV03D_TYPEDEF                                   nv01ContextDmaInMemory


/* object NV01_CONTEXT_ERROR_TO_MEMORY */
#define   NV01_CONTEXT_ERROR_TO_MEMORY                             (0x0000003E)
#define   NV1_CONTEXT_ERROR_TO_MEMORY                              (0x0000003E)
/* NvNotification[] fields and values */
#define NV03E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv03eTypedef, Nv01ContextErrorToMemory;
#define  Nv1ContextErrorToMemory                       Nv01ContextErrorToMemory
#define  nv1ContextErrorToMemory                       nv01ContextErrorToMemory
#define  NV03E_TYPEDEF                                 nv01ContextErrorToMemory


/* class NV01_MEMORY_PRIVILEGED */
#define  NV01_MEMORY_PRIVILEGED                                    (0x0000003F)
#define  NV1_MEMORY_PRIVILEGED                                     (0x0000003F)
/* NvNotification[] fields and values */
#define NV03F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv03fTypedef, Nv01MemoryPrivileged;
#define  Nv1MemoryPrivileged                               Nv01MemoryPrivileged
#define  nv1MemoryPrivileged                               nv01MemoryPrivileged
#define  NV03F_TYPEDEF                                     nv01MemoryPrivileged


/* class NV01_MEMORY_USER */
#define  NV01_MEMORY_USER                                          (0x00000040)
#define  NV1_MEMORY_USER                                           (0x00000040)
/* NvNotification[] fields and values */
#define NV040_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv040Typedef, Nv01MemoryUser;
#define  Nv1MemoryUser                                           Nv01MemoryUser
#define  nv1MemoryUser                                           nv01MemoryUser
#define  NV040_TYPEDEF                                           nv01MemoryUser

typedef V032 Nv041Typedef;


/* class NV04_CONTEXT_SURFACES_2D */
#define  NV04_CONTEXT_SURFACES_2D                                  (0x00000042)
#define  NV4_CONTEXT_SURFACES_2D                                   (0x00000042)
/* NvNotification[] elements */
#define NV042_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV042_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV042_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV042_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV042_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV042_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV042_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV042_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImageSource;/* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaImageDestin;/* NV01_CONTEXT_DMA_IN_MEMORY        0188-018b*/
 V032 Reserved01[0x05d];
 V032 SetColorFormat;          /* NV042_SET_COLOR_FORMAT_*          0300-0303*/
 U032 SetPitch;                /* destin_source U16_U16             0304-0307*/
 U032 SetOffsetSource;         /* byte offset of top-left pixel     0308-030b*/
 U032 SetOffsetDestin;         /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved02[0x73c];
} Nv042Typedef, Nv04ContextSurfaces2d;
#define Nv4ContextSurfaces2D                              Nv04ContextSurfaces2D
#define nv4ContextSurfaces2D                              nv04ContextSurfaces2D
#define NV042_TYPEDEF                                     nv04ContextSurfaces2D
/* dma method offsets, fields, and values */
#define NV042_SET_OBJECT                                           (0x00000000)
#define NV042_NO_OPERATION                                         (0x00000100)
#define NV042_NOTIFY                                               (0x00000104)
#define NV042_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV042_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV042_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV042_SET_CONTEXT_DMA_IMAGE_SOURCE                         (0x00000184)
#define NV042_SET_CONTEXT_DMA_IMAGE_DESTIN                         (0x00000188)
#define NV042_SET_COLOR_FORMAT                                     (0x00000300)
#define NV042_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV042_SET_COLOR_FORMAT_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV042_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000004)
#define NV042_SET_COLOR_FORMAT_LE_Y16                              (0x00000005)
#define NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV042_SET_COLOR_FORMAT_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV042_SET_COLOR_FORMAT_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV042_SET_COLOR_FORMAT_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV042_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x0000000A)
#define NV042_SET_COLOR_FORMAT_LE_Y32                              (0x0000000B)
#define NV042_SET_PITCH                                            (0x00000304)
#define NV042_SET_PITCH_SOURCE                                     15:0
#define NV042_SET_PITCH_DESTIN                                     31:16
#define NV042_SET_OFFSET_SOURCE                                    (0x00000308)
#define NV042_SET_OFFSET_DESTIN                                    (0x0000030C)


/* class NV03_CONTEXT_ROP */
#define  NV03_CONTEXT_ROP                                          (0x00000043)
#define  NV3_CONTEXT_ROP                                           (0x00000043)
/* NvNotification[] elements */
#define NV043_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV043_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV043_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV043_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV043_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV043_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV043_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV043_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetRop5;                 /* 32-bit ROP5                       0300-0303*/
 V032 Reserved02[0x73f];
} Nv043Typedef, Nv03ContextRop;
#define Nv3ContextRop                                            Nv03ContextRop
#define nv3ContextRop                                            nv03ContextRop
#define NV043_TYPEDEF                                            nv03ContextRop
/* dma method offsets, fields, and values */
#define NV043_SET_OBJECT                                           (0x00000000)
#define NV043_NO_OPERATION                                         (0x00000100)
#define NV043_NOTIFY                                               (0x00000104)
#define NV043_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV043_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV043_SET_ROP5                                             (0x00000300)


/* class NV04_CONTEXT_PATTERN */
#define  NV04_CONTEXT_PATTERN                                      (0x00000044)
#define  NV4_CONTEXT_PATTERN                                       (0x00000044)
/* NvNotification[] elements */
#define NV044_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV044_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV044_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV044_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV044_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV044_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV044_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV044_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetColorFormat;          /* NV044_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV044_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 SetMonochromeShape;      /* NV044_SET_MONOCHROME_SHAPE_*      0308-030b*/
 V032 SetPatternSelect;        /* NV044_SET_PATTERN_SELECT_*        030c-030f*/
 V032 SetMonochromeColor0;     /* color of 0 pixels                 0310-0313*/
 V032 SetMonochromeColor1;     /* color of 1 pixels                 0314-0317*/
 V032 SetMonochromePattern0;   /* first  32 bits of pattern data    0318-031b*/
 V032 SetMonochromePattern1;   /* second 32 bits of pattern data    031c-031f*/
 V032 Reserved02[0x038];
 V032 SetPatternY8[16];        /* y3_y2_y1_y0 U8_U8_U8_U8           0400-043f*/
 V032 Reserved03[0x030];
 V032 SetPatternR5G6B5[32];    /* see text                          0500-057f*/
 V032 Reserved04[0x020];
 V032 SetPatternX1R5G5B5[32];  /* see text                          0600-067f*/
 V032 Reserved05[0x020];
 V032 SetPatternX8R8G8B8[64];  /* ignore_red_green_blue U8_U8_U8_U8 0700-07ff*/
 V032 Reserved06[0x600];
} Nv044Typedef, Nv04ImagePattern;
#define Nv4ImagePattern                                        Nv04ImagePattern
#define nv4ImagePattern                                        nv04ImagePattern
#define NV044_TYPEDEF                                          nv04ImagePattern
/* dma method offsets, fields, and values */
#define NV044_SET_OBJECT                                           (0x00000000)
#define NV044_NO_OPERATION                                         (0x00000100)
#define NV044_NOTIFY                                               (0x00000104)
#define NV044_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV044_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV044_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV044_SET_COLOR_FORMAT                                     (0x00000300)
#define NV044_SET_COLOR_FORMAT_LE_A16R5G6B5                        (0x00000001)
#define NV044_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV044_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV044_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV044_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV044_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV044_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV044_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV044_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV044_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV044_SET_PATTERN_SELECT                                   (0x0000030C)
#define NV044_SET_PATTERN_SELECT_MONOCHROME                        (0x00000001)
#define NV044_SET_PATTERN_SELECT_COLOR                             (0x00000002)
#define NV044_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV044_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV044_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV044_SET_MONOCHORME_PATTERN1                              (0x0000031C)
#define NV044_SET_PATTERN_Y8(i)                                    (0x00000400\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_Y8_Y0                                    7:0
#define NV044_SET_PATTERN_Y8_Y1                                    15:8
#define NV044_SET_PATTERN_Y8_Y2                                    23:16
#define NV044_SET_PATTERN_Y8_Y3                                    31:24
#define NV044_SET_PATTERN_R5G6B5(i)                                (0x00000500\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_R5G6B5_BLUE0                             4:0
#define NV044_SET_PATTERN_R5G6B5_GREEN0                            10:5
#define NV044_SET_PATTERN_R5G6B5_RED0                              15:11
#define NV044_SET_PATTERN_R5G6B5_BLUE1                             20:16
#define NV044_SET_PATTERN_R5G6B5_GREEN1                            26:21
#define NV044_SET_PATTERN_R5G6B5_RED1                              31:27
#define NV044_SET_PATTERN_X1R5G5B5(i)                              (0x00000600\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_X1R5G5B5_BLUE0                           4:0
#define NV044_SET_PATTERN_X1R5G5B5_GREEN0                          9:5
#define NV044_SET_PATTERN_X1R5G5B5_RED0                            14:10
#define NV044_SET_PATTERN_X1R5G5B5_IGNORE0                         15:15
#define NV044_SET_PATTERN_X1R5G5B5_BLUE1                           20:16
#define NV044_SET_PATTERN_X1R5G5B5_GREEN1                          25:21
#define NV044_SET_PATTERN_X1R5G5B5_RED1                            30:26
#define NV044_SET_PATTERN_X1R5G5B5_IGNORE1                         31:31
#define NV044_SET_PATTERN_X8R8G8B8(i)                              (0x00000700\
                                                                   +(i)*0x0004)
#define NV044_SET_PATTERN_X8R8G8B8_BLUE                            7:0
#define NV044_SET_PATTERN_X8R8G8B8_GREEN                           15:8
#define NV044_SET_PATTERN_X8R8G8B8_RED                             23:16
#define NV044_SET_PATTERN_X8R8G8B8_IGNORE                          31:24

typedef V032 Nv045Typedef;


/* class NV03_VIDEO_LUT_CURSOR_DAC */
#define  NV03_VIDEO_LUT_CURSOR_DAC                                 (0x00000046)
/* NvNotification[] elements */
#define NV046_NOTIFIERS_NOTIFY                                     (0)
#define NV046_NOTIFIERS_SET_IMAGE(b)                               (1+(b))
#define NV046_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (3+(b))
#define NV046_NOTIFIERS_SET_LUT(b)                                 (5+(b))
#define NV046_NOTIFIERS_SET_CURSOR_IMAGE(b)                        (7+(b))
#define NV046_NOTIFIERS_SET_CURSOR_POINT(b)                        (9+(b))
/* NvNotification[] fields and values */
#define NV046_NOTIFICATION_INFO16_OFFSET_VALID                     (0x0001)
#define NV046_NOTIFICATION_INFO16_OFFSET_INVALID                   (0x0002)
#define NV046_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV046_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV046_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV046_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV046_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV046_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV046_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV046_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV046_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01D];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-018b*/
 V032 SetContextDmaLut;        /* NV01_CONTEXT_DMA_FROM_MEMORY      018c-018f*/
 V032 SetContextDmaCursor;     /* NV01_CONTEXT_DMA_FROM_MEMORY      0190-0193*/
 V032 Reserved01[0x05B];
 struct {                      /* start of methods in array         0300-    */
  U032 offset;                 /* byte offset of top-left pixel        0-   3*/
  V032 format;                 /* pitch_color_field_notify             4-   7*/
 } SetImage[2];                /* end of methods in array               -030f*/
 V032 GetImageOffsetNotify[2]; /* NV046_GET_IMAGE_OFFSET_NOTIFY_*   0310-0317*/
 V032 SetLut[2];               /* notify_offset V02_U30             0318-031f*/
 V032 SetCursorImage[2];       /* notify_offset V02_U30             0320-0327*/
 V032 SetCursorPoint[2];       /* notify_y_x V02_S14_S16            0328-032f*/
 V032 SetDacImageSize;         /* height_width U16_U16 in pixels    0330-0333*/
 V032 SetDacHorizontalSync;    /* width_start U16_U16 in pixels     0334-0337*/
 V032 SetDacVerticalSync;      /* width_start U16_U16 in pixels     0338-033b*/
 V032 SetDacTotalSize;         /* height_width U16_U16 in pixels    033c-033f*/
 U032 SetDacPixelClock;        /* in Hertz                          0340-0343*/
 V032 Reserved02[0x72F];
} Nv046Typedef, nv03VideoLutCursorDac;
#define NV046_TYPEDEF                                     nv03VideoLutCursorDac
/* dma method offsets, fields, and values */
#define NV046_SET_OBJECT                                           (0x00000000)
#define NV046_NO_OPERATION                                         (0x00000100)
#define NV046_NOTIFY                                               (0x00000104)
#define NV046_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV046_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV046_STOP_TRANSFER                                        (0x00000108)
#define NV046_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV046_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV046_SET_CONTEXT_DMA_IMAGE(b)                             (0x00000184\
                                                                   +(b)*0x0004)
#define NV046_SET_CONTEXT_DMA_LUT                                  (0x0000018C)
#define NV046_SET_CONTEXT_DMA_CURSOR                               (0x00000190)
#define NV046_SET_IMAGE(b)                                         (0x00000300\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_OFFSET(b)                                  (0x00000300\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_FORMAT(b)                                  (0x00000304\
                                                                   +(b)*0x0008)
#define NV046_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV046_SET_IMAGE_FORMAT_COLOR                               23:16
#define NV046_SET_IMAGE_FORMAT_COLOR_LUT_LE_Y8                     (0x00000000)
#define NV046_SET_IMAGE_FORMAT_COLOR_BYPASS_LE_R5G6B5              (0x00000001)
#define NV046_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1R5G5B5              (0x00000002)
#define NV046_SET_IMAGE_FORMAT_COLOR_LE_BYPASS1X7R8G8B8            (0x00000003)
#define NV046_SET_IMAGE_FORMAT_FIELD                               29:24
#define NV046_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV046_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV046_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV046_SET_IMAGE_FORMAT_NOTIFY                              31:30
#define NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000310\
                                                                   +(b)*0x0004)
#define NV046_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_SET_LUT(b)                                           (0x00000318\
                                                                   +(b)*0x0004)
#define NV046_SET_LUT_OFFSET                                       29:0
#define NV046_SET_LUT_NOTIFY                                       31:30
#define NV046_SET_LUT_NOTIFY_WRITE_ONLY                            (0x00000000)
#define NV046_SET_LUT_NOTIFY_WRITE_THEN_AWAKEN                     (0x00000001)
#define NV046_SET_CURSOR_IMAGE(b)                                  (0x00000320\
                                                                   +(b)*0x0004)
#define NV046_SET_CURSOR_IMAGE_OFFSET                              29:0
#define NV046_SET_CURSOR_IMAGE_NOTIFY                              31:30
#define NV046_SET_CURSOR_IMAGE_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_SET_CURSOR_IMAGE_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_SET_CURSOR_POINT(b)                                  (0x00000328\
                                                                   +(b)*0x0004)
#define NV046_SET_CURSOR_POINT_X                                   15:0
#define NV046_SET_CURSOR_POINT_Y                                   29:16
#define NV046_SET_CURSOR_POINT_NOTIFY                              31:30
#define NV046_SET_CURSOR_POINT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV046_SET_CURSOR_POINT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV046_SET_DAC_IMAGE_SIZE                                   (0x00000330)
#define NV046_SET_DAC_IMAGE_SIZE_WIDTH                             15:0
#define NV046_SET_DAC_IMAGE_SIZE_HEIGHT                            31:16
#define NV046_SET_DAC_HORIZONTAL_SYNC                              (0x00000334)
#define NV046_SET_DAC_HORIZONTAL_SYNC_START                        15:0
#define NV046_SET_DAC_HORIZONTAL_SYNC_WIDTH                        31:16
#define NV046_SET_DAC_VERTICAL_SYNC                                (0x00000338)
#define NV046_SET_DAC_VERTICAL_SYNC_START                          15:0
#define NV046_SET_DAC_VERTICAL_SYNC_WIDTH                          31:16
#define NV046_SET_DAC_TOTAL_SIZE                                   (0x0000033C)
#define NV046_SET_DAC_TOTAL_SIZE_WIDTH                             15:0
#define NV046_SET_DAC_TOTAL_SIZE_HEIGHT                            31:16
#define NV046_SET_DAC_PIXEL_CLOCK                                  (0x00000340)

typedef V032 Nv047Typedef;


/* class NV03_DX3_TEXTURED_TRIANGLE */
#define  NV03_DX3_TEXTURED_TRIANGLE                                (0x00000048)
#define  NV3_DX3_TEXTURED_TRIANGLE                                 (0x00000048)
/* NvNotification[] elements */
#define NV048_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV048_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV048_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV048_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV048_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV048_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV048_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaTexture;    /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextSurfaceColor;  /* NV03_CONTEXT_SURFACE_2            018c-018f*/
 V032 SetContextSurfaceZeta;   /* NV03_CONTEXT_SURFACE_3            0190-0193*/
 V032 Reserved01[0x05c];
 U032 TextureOffset;           /* offset in bytes                   0304-0307*/
 V032 TextureFormat;           /* see text                          0308-030b*/
 V032 TextureFilter;           /* ignore_sizeAdjust_spreadY_spreadX 030c-030f*/
 V032 FogColor;                /* X8R8G8B8 fog color                0310-0313*/
 V032 Control0;                /* see text                          0314-0317*/
 V032 Control1;                /* alphafunc_alpharef V24_U8         0318-031b*/
 V032 Reserved02[0x339];
 struct {                      /* start of method in array          1000-    */
  V032 specular;               /* fog_i5-i0, U0d8_U4_U4_U4_U4_U4_U4   00-  03*/
  V032 color;                  /* X8R8G8B8 or A8R8G8B8                04-  07*/
  F032 sx;                     /* screen x coordinate                 08-  0b*/
  F032 sy;                     /* screen y coordinate                 0c-  0f*/
  F032 sz;                     /* screen z coordinate                 10-  13*/
  F032 rhw;                    /* reciprocal homogeneous W (1/W)      14-  17*/
  F032 tu;                     /* texture u coordinate                18-  1b*/
  F032 tv;                     /* texture v coordinate                1c-  1f*/
 } Tlvertex[128];              /* end of method in array                -1fff*/
} Nv048Typedef, Nv03Dx3TexturedTriangle;
#define Nv3Dx3TexturedTriangle                          Nv03Dx3TexturedTriangle
#define nv3Dx3TexturedTriangle                          nv03Dx3TexturedTriangle
#define NV048_TYPEDEF                                   nv03Dx3TexturedTriangle
/* dma method offsets, fields, and values */
#define NV048_SET_OBJECT                                           (0x00000000)
#define NV048_NO_OPERATION                                         (0x00000100)
#define NV048_NOTIFY                                               (0x00000104)
#define NV048_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV048_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV048_SET_CONTEXT_DMA_TEXTURE                              (0x00000184)
#define NV048_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV048_SET_CONTEXT_SURFACE_COLOR                            (0x0000018C)
#define NV048_SET_CONTEXT_SURFACE_ZETA                             (0x00000190)
#define NV048_TEXTURE_OFFSET                                       (0x00000304)
#define NV048_TEXTURE_FORMAT                                       (0x00000308)
#define NV048_TEXTURE_FORMAT_VALUE                                 15:0
#define NV048_TEXTURE_FORMAT_KEY                                   19:16
#define NV048_TEXTURE_FORMAT_KEY_DISABLED                          (0x00000000)
#define NV048_TEXTURE_FORMAT_KEY_ENABLED                           (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR                                 23:20
#define NV048_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                     (0x00000000)
#define NV048_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                     (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                     (0x00000002)
#define NV048_TEXTURE_FORMAT_COLOR_LE_R5G6B5                       (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN                              27:24
#define NV048_TEXTURE_FORMAT_SIZE_MIN_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FORMAT_SIZE_MAX                              31:28
#define NV048_TEXTURE_FORMAT_SIZE_MAX_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FILTER                                       (0x0000030C)
#define NV048_TEXTURE_FILTER_SPREAD_X                              4:0
#define NV048_TEXTURE_FILTER_IGNORE0                               7:5
#define NV048_TEXTURE_FILTER_SPREAD_Y                              12:8
#define NV048_TEXTURE_FILTER_IGNORE1                               15:13
#define NV048_TEXTURE_FILTER_SIZE_ADJUST                           23:16
#define NV048_TEXTURE_FILTER_IGNORE2                               31:24
#define NV048_FOG_COLOR                                            (0x00000310)
#define NV048_CONTROL0                                             (0x00000314)
#define NV048_CONTROL0_INTERPOLATOR                                3:0
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CORNER                     (0x00000000)
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CENTER                     (0x00000001)
#define NV048_CONTROL0_INTERPOLATOR_FOH_CENTER                     (0x00000002)
#define NV048_CONTROL0_WRAP_U                                      5:4
#define NV048_CONTROL0_WRAP_U_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_U_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_U_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_U_CLAMP                                (0x00000003)
#define NV048_CONTROL0_WRAP_V                                      7:6
#define NV048_CONTROL0_WRAP_V_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_V_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_V_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_V_CLAMP                                (0x00000003)
#define NV048_CONTROL0_COLOR_FORMAT                                9:8
#define NV048_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8                    (0x00000000)
#define NV048_CONTROL0_COLOR_FORMAT_LE_A8R8G8B8                    (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR                                11:10
#define NV048_CONTROL0_SOURCE_COLOR_NORMAL                         (0x00000000)
#define NV048_CONTROL0_SOURCE_COLOR_COLOR_INVERSE                  (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_INVERSE                  (0x00000002)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_ONE                      (0x00000003)
#define NV048_CONTROL0_CULLING                                     14:12
#define NV048_CONTROL0_CULLING_NONE                                (0x00000001)
#define NV048_CONTROL0_CULLING_COUNTERCLOCKWISE                    (0x00000002)
#define NV048_CONTROL0_CULLING_CLOCKWISE                           (0x00000003)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE                        15:15
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV048_CONTROL0_ZFUNC                                       19:16
#define NV048_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV048_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV048_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV048_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV048_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV048_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV048_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV048_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV048_CONTROL0_ZETA_WRITE                                  23:20
#define NV048_CONTROL0_ZETA_WRITE_NEVER                            (0x00000000)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA                            (0x00000001)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA_ZETA                       (0x00000002)
#define NV048_CONTROL0_ZETA_WRITE_ZETA                             (0x00000003)
#define NV048_CONTROL0_ZETA_WRITE_ALWAYS                           (0x00000004)
#define NV048_CONTROL0_COLOR_WRITE                                 27:24
#define NV048_CONTROL0_COLOR_WRITE_NEVER                           (0x00000000)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA                           (0x00000001)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA_ZETA                      (0x00000002)
#define NV048_CONTROL0_COLOR_WRITE_ZETA                            (0x00000003)
#define NV048_CONTROL0_COLOR_WRITE_ALWAYS                          (0x00000004)
#define NV048_CONTROL0_ROP                                         28:28
#define NV048_CONTROL0_ROP_BLEND_AND                               (0x00000000)
#define NV048_CONTROL0_ROP_ADD_WITH_SATURATION                     (0x00000001)
#define NV048_CONTROL0_BLEND_BETA                                  29:29
#define NV048_CONTROL0_BLEND_BETA_SRCALPHA                         (0x00000000)
#define NV048_CONTROL0_BLEND_BETA_DESTCOLOR                        (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT0                                30:30
#define NV048_CONTROL0_BLEND_INPUT0_DESTCOLOR                      (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT0_ZERO                           (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT1                                31:31
#define NV048_CONTROL0_BLEND_INPUT1_SRCCOLOR                       (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT1_ZERO                           (0x00000001)
#define NV048_CONTROL1                                             (0x00000318)
#define NV048_CONTROL1_ALPHAREF                                    7:0
#define NV048_CONTROL1_ALPHAFUNC                                   31:8
#define NV048_CONTROL1_ALPHAFUNC_NEVER                             (0x00000001)
#define NV048_CONTROL1_ALPHAFUNC_LESS                              (0x00000002)
#define NV048_CONTROL1_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV048_CONTROL1_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV048_CONTROL1_ALPHAFUNC_GREATER                           (0x00000005)
#define NV048_CONTROL1_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV048_CONTROL1_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV048_CONTROL1_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV048_TLVERTEX(a)                                          (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR(a)                                 (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR_I0                                 3:0
#define NV048_TLVERTEX_SPECULAR_I1                                 7:4
#define NV048_TLVERTEX_SPECULAR_I2                                 11:8
#define NV048_TLVERTEX_SPECULAR_I3                                 15:12
#define NV048_TLVERTEX_SPECULAR_I4                                 19:16
#define NV048_TLVERTEX_SPECULAR_I5                                 23:20
#define NV048_TLVERTEX_SPECULAR_FOG                                31:24
#define NV048_TLVERTEX_COLOR(a)                                    (0x00001004\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SX(a)                                       (0x00001008\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SY(a)                                       (0x0000100C\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SZ(a)                                       (0x00001010\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_RHW(a)                                      (0x00001014\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TU(a)                                       (0x00001018\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TV(a)                                       (0x0000101C\
                                                                   +(a)*0x0020)

typedef V032 Nv049Typedef;


/* class NV04_GDI_RECTANGLE_TEXT */
#define  NV04_GDI_RECTANGLE_TEXT                                   (0x0000004A)
#define  NV4_GDI_RECTANGLE_TEXT                                    (0x0000004A)
/* NvNotification[] elements */
#define NV04A_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV04A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* memory data structures */
typedef struct {               /* start of data structure           0000-    */
   V032 size;                  /* height_width U16_U16 in pixels       0-   3*/
   V032 monochrome[1];         /* 32 monochrome pixels per write       4-   7*/
} Nv04aCharacter8[];           /* end of data structure                 -0007*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels       0-   3*/
  V032 monochrome[3];          /* 32 monochrome pixels per write       4-   f*/
} Nv04aCharacter16[];          /* end of data structure                 -000f*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels      00-  03*/
  V032 monochrome[7];          /* 32 monochrome pixels per write      04-  1f*/
} Nv04aCharacter32[];          /* end of data structure                 -001f*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels      00-  03*/
  V032 monochrome[15];         /* 32 monochrome pixels per write      04-  3f*/
} Nv04aCharacter64[];          /* end of data structure                 -003f*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels      00-  03*/
  V032 monochrome[31];         /* 32 monochrome pixels per write      04-  7f*/
} Nv04aCharacter128[];         /* end of data structure                 -007f*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels      00-  03*/
  V032 monochrome[63];         /* 32 monochrome pixels per write      04-  ff*/
} Nv04aCharacter256[];         /* end of data structure                 -00ff*/
typedef struct {               /* start of data structure           0000-    */
  V032 size;                   /* height_width U16_U16 in pixels     000- 003*/
  V032 monochrome[127];        /* 32 monochrome pixels per write     004- 1ff*/
} Nv04aCharacter512[];         /* end of data structure                 -01ff*/
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV04A_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaFonts;      /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV04A_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV04A_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV04A_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 Reserved02[0x03D];
 V032 Color1A;                 /* rectangle color                   03fc-03ff*/
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* x_y S16_S16 in pixels                0-   3*/
  V032 size;                   /* width_height U16_U16 in pixels       4-   7*/
 } UnclippedRectangle[32];     /* end of aliased methods in array       -04ff*/
 V032 Reserved03[0x03D];
 V032 ClipPoint0B;             /* top_left S16_S16 in pixels        05f4-05f7*/
 V032 ClipPoint1B;             /* bottom_right S16_S16 in pixels    05f8-05fb*/
 V032 Color1B;                 /* rectangle color                   05fc-05ff*/
 struct {                      /* start of aliased methods in array 0600-    */
  V032 point0;                 /* top_left S16_S16 in pixels           0-   3*/
  V032 point1;                 /* bottom_right S16_S16 in pixels       4-   7*/
 } ClippedRectangle[32];       /* end of aliased methods in array       -06ff*/
 V032 Reserved04[0x03B];
 V032 ClipPoint0C;             /* top_left S16_S16 in pixels        07ec-07ef*/
 V032 ClipPoint1C;             /* bottom_right S16_S16 in pixe      07f0-07f3*/
 V032 Color1C;                 /* color of 1 pixels                 07f4-07f7*/
 V032 SizeC;                   /* height_width U16_U16 in pixels    07f8-07fb*/
 V032 PointC;                  /* y_x S16_S16 in pixels             07fc-07ff*/
 V032 MonochromeColor1C[128];  /* 32 monochrome pixels per write    0800-09ff*/
 V032 Reserved05[0x079];
 V032 ClipPoint0E;             /* top_left S16_S16 in pixels        0be4-0be7*/
 V032 ClipPoint1E;             /* bottom_right S16_S16 in pixels    0be8-0beb*/
 V032 Color0E;                 /* color of 0 pixels                 0bec-0bef*/
 V032 Color1E;                 /* color of 1 pixels                 0bf0-0bf3*/
 V032 SizeInE;                 /* height_width U16_U16 in pixels    0bf4-0bf7*/
 V032 SizeOutE;                /* height_width U16_U16 in pixels    0bf8-0bfb*/
 V032 PointE;                  /* y_x S16_S16 in pixels             0bfc-0bff*/
 V032 MonochromeColor01E[128]; /* 32 monochrome pixels per write    0c00-0dff*/
 V032 Reserved06[0x07C];
 V032 FontF;                   /* pitch_offset V4_U28               0ff0-0ff3*/
 V032 ClipPoint0F;             /* top_left S16_S16 in pixels        0ff4-0ff7*/
 V032 ClipPoint1F;             /* bottom_right S16_S16 in pixels    0ff8-0ffb*/
 V032 Color1F;                 /* color of 1 pixels                 0ffc-0fff*/
 V032 CharacterColor1F[256];   /* y_x_index S12_S12_U8              1000-13ff*/
 V032 Reserved07[0x0FC];
 V032 FontG;                   /* pitch_offset V4_U28               17f0-17f3*/
 V032 ClipPoint0G;             /* top_left S16_S16 in pixels        17f4-17f7*/
 V032 ClipPoint1G;             /* bottom_right S16_S16 in pixels    17f8-17fb*/
 V032 Color1G;                 /* color of 1 pixels                 17fc-17ff*/
 struct {                      /* start of aliased methods in array 1800-    */
  V032 point;                  /* y_x S16_S16 in pixels                0-   3*/
  U032 index;                  /* 0<=index<=65525                      4-   7*/
 } CharacterColor1G[256];      /* end of aliased methods in array       -1fff*/
} Nv04aTypedef, Nv04GdiRectangleText;
#define Nv4GdiRectangleText                                Nv04GdiRectangleText
#define nv4GdiRectangleText                                nv04GdiRectangleText
#define NV04A_TYPEDEF                                      nv04GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04A_SET_OBJECT                                           (0x00000000)
#define NV04A_NO_OPERATION                                         (0x00000100)
#define NV04A_NOTIFY                                               (0x00000104)
#define NV04A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04A_SET_CONTEXT_DMA_FONTS                                (0x00000184)
#define NV04A_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV04A_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV04A_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV04A_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV04A_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV04A_SET_OPERATION                                        (0x000002FC)
#define NV04A_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04A_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04A_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04A_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV04A_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV04A_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV04A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04A_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV04A_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04A_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04A_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04A_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04A_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04A_COLOR1_A                                             (0x000003FC)
#define NV04A_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_POINT_X                          15:0
#define NV04A_UNCLIPPED_RECTANGLE_POINT_Y                          31:16
#define NV04A_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04A_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       15:0
#define NV04A_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      31:16
#define NV04A_CLIP_POINT0_B                                        (0x000005F4)
#define NV04A_CLIP_POINT0_B_LEFT                                   15:0
#define NV04A_CLIP_POINT0_B_TOP                                    31:16
#define NV04A_CLIP_POINT1_B                                        (0x000005F8)
#define NV04A_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04A_COLOR1_B                                             (0x000005FC)
#define NV04A_CLIPPED_RECTANGLE(a)                                 (0x00000600\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_0                            (0x00000600\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_0_LEFT                       15:0
#define NV04A_CLIPPED_RECTANGLE_POINT_0_TOP                        31:16
#define NV04A_CLIPPED_RECTANGLE_POINT_1                            (0x00000604\
                                                                   +(a)*0x0008)
#define NV04A_CLIPPED_RECTANGLE_POINT_1_RIGHT                      15:0
#define NV04A_CLIPPED_RECTANGLE_POINT_1_BOTTOM                     31:16
#define NV04A_CLIP_POINT0_C                                        (0x000007EC)
#define NV04A_CLIP_POINT0_C_LEFT                                   15:0
#define NV04A_CLIP_POINT0_C_TOP                                    31:16
#define NV04A_CLIP_POINT1_C                                        (0x000007F0)
#define NV04A_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04A_COLOR1_C                                             (0x000007F4)
#define NV04A_SIZE_C                                               (0x000007F8)
#define NV04A_SIZE_C_WIDTH                                         15:0
#define NV04A_SIZE_C_HEIGHT                                        31:16
#define NV04A_POINT_C                                              (0x000007FC)
#define NV04A_POINT_C_X                                            15:0
#define NV04A_POINT_C_Y                                            31:16
#define NV04A_MONOCHROME_COLOR1_C(a)                               (0x00000800\
                                                                   +(a)*0x0004)
#define NV04A_CLIP_POINT0_E                                        (0x00000BE4)
#define NV04A_CLIP_POINT0_E_LEFT                                   15:0
#define NV04A_CLIP_POINT0_E_TOP                                    31:16
#define NV04A_CLIP_POINT1_E                                        (0x00000BE8)
#define NV04A_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04A_COLOR0_E                                             (0x00000BEC)
#define NV04A_COLOR1_E                                             (0x00000BF0)
#define NV04A_SIZE_IN_E                                            (0x00000BF4)
#define NV04A_SIZE_IN_E_WIDTH                                      15:0
#define NV04A_SIZE_IN_E_HEIGHT                                     31:16
#define NV04A_SIZE_OUT_E                                           (0x00000BF8)
#define NV04A_SIZE_OUT_E_WIDTH                                     15:0
#define NV04A_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04A_POINT_E                                              (0x00000BFC)
#define NV04A_POINT_E_X                                            15:0
#define NV04A_POINT_E_Y                                            31:16
#define NV04A_MONOCHROME_COLOR01_E(a)                              (0x00000C00\
                                                                   +(a)*0x0004
#define NV04A_FONT_F                                               (0x00000FF0)
#define NV04A_FONT_F_OFFSET                                        27:0
#define NV04A_FONT_F_PITCH                                         31:28
#define NV04A_FONT_F_PITCH_8                                       (0x00000003)
#define NV04A_FONT_F_PITCH_16                                      (0x00000004)
#define NV04A_FONT_F_PITCH_32                                      (0x00000005)
#define NV04A_FONT_F_PITCH_64                                      (0x00000006)
#define NV04A_FONT_F_PITCH_128                                     (0x00000007)
#define NV04A_FONT_F_PITCH_256                                     (0x00000008)
#define NV04A_FONT_F_PITCH_512                                     (0x00000009)
#define NV04A_CLIP_POINT0_F                                        (0x00000FF4)
#define NV04A_CLIP_POINT0_F_LEFT                                   15:0
#define NV04A_CLIP_POINT0_F_TOP                                    31:16
#define NV04A_CLIP_POINT1_F                                        (0x00000FF8)
#define NV04A_CLIP_POINT1_F_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_F_BOTTOM                                 31:16
#define NV04A_COLOR1_F                                             (0x00000FFC)
#define NV04A_CHARACTER_COLOR1_F(a)                                (0x00001000\
                                                                   +(a)*0x0004)
#define NV04A_CHARACTER_COLOR1_F_INDEX                             7:0
#define NV04A_CHARACTER_COLOR1_F_X                                 19:8
#define NV04A_CHARACTER_COLOR1_F_Y                                 31:20
#define NV04A_FONT_G                                               (0x000017F0)
#define NV04A_FONT_G_OFFSET                                        27:0
#define NV04A_FONT_G_PITCH                                         31:28
#define NV04A_FONT_G_PITCH_8                                       (0x00000003)
#define NV04A_FONT_G_PITCH_16                                      (0x00000004)
#define NV04A_FONT_G_PITCH_32                                      (0x00000005)
#define NV04A_FONT_G_PITCH_64                                      (0x00000006)
#define NV04A_FONT_G_PITCH_128                                     (0x00000007)
#define NV04A_FONT_G_PITCH_256                                     (0x00000008)
#define NV04A_FONT_G_PITCH_512                                     (0x00000009)
#define NV04A_CLIP_POINT0_G                                        (0x000017F4)
#define NV04A_CLIP_POINT0_G_LEFT                                   15:0
#define NV04A_CLIP_POINT0_G_TOP                                    31:16
#define NV04A_CLIP_POINT1_G                                        (0x000017F8)
#define NV04A_CLIP_POINT1_G_RIGHT                                  15:0
#define NV04A_CLIP_POINT1_G_BOTTOM                                 31:16
#define NV04A_COLOR1_G                                             (0x000017FC)
#define NV04A_CHARACTER_COLOR1_G(a)                                (0x00001800\
                                                                   +(a)*0x0008)
#define NV04A_CHARACTER_COLOR1_G_POINT(a)                          (0x00001800\
                                                                   +(a)*0x0008)
#define NV04A_CHARACTER_COLOR1_G_POINT_X                           15:0
#define NV04A_CHARACTER_COLOR1_G_POINT_Y                           31:16
#define NV04A_CHARACTER_COLOR1_G_INDEX(a)                          (0x00001804\
                                                                   +(a)*0x0008)


/* class NV03_GDI_RECTANGLE_TEXT */
#define  NV03_GDI_RECTANGLE_TEXT                                   (0x0000004B)
#define  NV3_GDI_RECTANGLE_TEXT                                    (0x0000004B)
/* NvNotification[] elements */
#define NV04B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV04B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV04B_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextPattern;       /* NV01_IMAGE_PATTERN                0184-0187*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0188-018b*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   018c-018f*/
 V032 SetContextSurface;       /* NV03_CONTEXT_SURFACE_0            0190-0193*/
 V032 Reserved01[0x05a];
 V032 SetOperation;            /* NV04B_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV04B_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV04B_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 Reserved02[0x03d];
 V032 Color1A;                 /* rectangle color                   03fc-03ff*/
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* x_y S16_S16 in pixels                0-   3*/
  V032 size;                   /* width_height U16_U16 in pixels       4-   7*/
 } UnclippedRectangle[64];     /* end of aliased methods in array       -05ff*/
 V032 Reserved03[0x07D];
 V032 ClipPoint0B;             /* top_left S16_S16 in pixels        07f4-07f7*/
 V032 ClipPoint1B;             /* bottom_right S16_S16 in pixels    07f8-07fb*/
 V032 Color1B;                 /* rectangle color                   07fc-07ff*/
 struct {                      /* start of aliased methods in array 0800-    */
  V032 point0;                 /* top_left S16_S16 in pixels           0-   3*/
  V032 point1;                 /* bottom_right S16_S16 in pixels       4-   7*/
 } ClippedRectangle[64];       /* end of aliased methods in array       -09ff*/
 V032 Reserved04[0x07B];
 V032 ClipPoint0C;             /* top_left S16_S16 in pixels        0bec-0bef*/
 V032 ClipPoint1C;             /* bottom_right S16_S16 in pixels    0bf0-0bf3*/
 V032 Color1C;                 /* color of 1 pixels                 0bf4-0bf7*/
 V032 SizeC;                   /* height_width U16_U16 in pixels    0bf8-0bfb*/
 V032 PointC;                  /* y_x S16_S16 in pixels             0bfc-0bff*/
 V032 MonochromeColor1C[128];  /* 32 monochrome pixels per write    0c00-0dff*/
 V032 Reserved05[0x07A];
 V032 ClipPoint0D;             /* top_left S16_S16 in pixels        0fe8-0feb*/
 V032 ClipPoint1D;             /* bottom_right S16_S16 in pixels    0fec-0fef*/
 V032 Color1D;                 /* color of 1 pixels                 0ff0-0ff3*/
 V032 SizeInD;                 /* height_width U16_U16 in pixels    0ff4-0ff7*/
 V032 SizeOutD;                /* height_width U16_U16 in pixels    0ff8-0ffb*/
 V032 PointD;                  /* y_x S16_S16 in pixels             0ffc-0fff*/
 V032 MonochromeColor1D[128];  /* 32 monochrome pixels per write    1000-11ff*/
 V032 Reserved06[0x079];
 V032 ClipPoint0E;             /* top_left S16_S16 in pixels        13e4-13e7*/
 V032 ClipPoint1E;             /* bottom_right S16_S16 in pixels    13e8-13eb*/
 V032 Color0E;                 /* color of 0 pixels                 13ec-13ef*/
 V032 Color1E;                 /* color of 1 pixels                 13f0-13f3*/
 V032 SizeInE;                 /* height_width U16_U16 in pixels    13f4-13f7*/
 V032 SizeOutE;                /* height_width U16_U16 in pixels    13f8-13fb*/
 V032 PointE;                  /* y_x S16_S16 in pixels             13fc-13ff*/
 V032 MonochromeColor01E[128]; /* 32 monochrome pixels per write    1400-15ff*/
 V032 Reserved07[0x280];
} Nv04bTypedef, Nv03GdiRectangleText;
#define Nv3GdiRectangleText                                Nv03GdiRectangleText
#define nv3GdiRectangleText                                nv03GdiRectangleText
#define NV04B_TYPEDEF                                      nv03GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04B_SET_OBJECT                                           (0x00000000)
#define NV04B_NO_OPERATION                                         (0x00000100)
#define NV04B_NOTIFY                                               (0x00000104)
#define NV04B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04B_SET_CONTEXT_PATTERN                                  (0x00000184)
#define NV04B_SET_CONTEXT_ROP                                      (0x00000188)
#define NV04B_SET_CONTEXT_BETA1                                    (0x0000018C)
#define NV04B_SET_CONTEXT_SURFACE                                  (0x00000190)
#define NV04B_SET_OPERATION                                        (0x000002FC)
#define NV04B_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04B_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04B_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04B_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV04B_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04B_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04B_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04B_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04B_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04B_COLOR1_A                                             (0x000003FC)
#define NV04B_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT_X                          15:0
#define NV04B_UNCLIPPED_RECTANGLE_POINT_Y                          31:16
#define NV04B_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       15:0
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      31:16
#define NV04B_CLIP_POINT0_B                                        (0x000007F4)
#define NV04B_CLIP_POINT0_B_LEFT                                   15:0
#define NV04B_CLIP_POINT0_B_TOP                                    31:16
#define NV04B_CLIP_POINT1_B                                        (0x000007F8)
#define NV04B_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04B_COLOR1_B                                             (0x000007FC)
#define NV04B_CLIPPED_RECTANGLE(a)                                 (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0(a)                          (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0_LEFT                        15:0
#define NV04B_CLIPPED_RECTANGLE_POINT0_TOP                         31:16
#define NV04B_CLIPPED_RECTANGLE_POINT1(a)                          (0x00000804\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT1_RIGHT                       15:0
#define NV04B_CLIPPED_RECTANGLE_POINT1_BOTTOM                      31:16
#define NV04B_CLIP_POINT0_C                                        (0x00000BEC)
#define NV04B_CLIP_POINT0_C_LEFT                                   15:0
#define NV04B_CLIP_POINT0_C_TOP                                    31:16
#define NV04B_CLIP_POINT1_C                                        (0x00000BF0)
#define NV04B_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04B_COLOR1_C                                             (0x00000BF4)
#define NV04B_SIZE_C                                               (0x00000BF8)
#define NV04B_SIZE_C_WIDTH                                         15:0
#define NV04B_SIZE_C_HEIGHT                                        31:16
#define NV04B_POINT_C                                              (0x00000BFC)
#define NV04B_POINT_C_X                                            15:0
#define NV04B_POINT_C_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_C(a)                               (0x00000C00\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_D                                        (0x00000FE8)
#define NV04B_CLIP_POINT0_D_LEFT                                   15:0
#define NV04B_CLIP_POINT0_D_TOP                                    31:16
#define NV04B_CLIP_POINT1_D                                        (0x00000FEC)
#define NV04B_CLIP_POINT1_D_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_D_BOTTOM                                 31:16
#define NV04B_COLOR1_D                                             (0x00000FF0)
#define NV04B_SIZE_IN_D                                            (0x00000FF4)
#define NV04B_SIZE_IN_D_WIDTH                                      15:0
#define NV04B_SIZE_IN_D_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_D                                           (0x00000FF8)
#define NV04B_SIZE_OUT_D_WIDTH                                     15:0
#define NV04B_SIZE_OUT_D_HEIGHT                                    31:16
#define NV04B_POINT_D                                              (0x00000FFC)
#define NV04B_POINT_D_X                                            15:0
#define NV04B_POINT_D_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_D(a)                               (0x00001000\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_E                                        (0x000013E4)
#define NV04B_CLIP_POINT0_E_LEFT                                   15:0
#define NV04B_CLIP_POINT0_E_TOP                                    31:16
#define NV04B_CLIP_POINT1_E                                        (0x000013E8)
#define NV04B_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04B_COLOR0_E                                             (0x000013EC)
#define NV04B_COLOR1_E                                             (0x000013F0)
#define NV04B_SIZE_IN_E                                            (0x000013F4)
#define NV04B_SIZE_IN_E_WIDTH                                      15:0
#define NV04B_SIZE_IN_E_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_E                                           (0x000013F8)
#define NV04B_SIZE_OUT_E_WIDTH                                     15:0
#define NV04B_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04B_POINT_E                                              (0x000013FC)
#define NV04B_POINT_E_X                                            15:0
#define NV04B_POINT_E_Y                                            31:16
#define NV04B_MONOCHROME_COLOR01_E(a)                              (0x00001400\
                                                                   +(a)*0x0004)

typedef V032 Nv04cTypedef;


/* class NV03_EXTERNAL_VIDEO_DECODER */
#define  NV03_EXTERNAL_VIDEO_DECODER                               (0x0000004D)
/* NvNotification[] elements */
#define NV04D_NOTIFIERS_NOTIFY                                     (0)
#define NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(b)                   (1+(b))
#define NV04D_NOTIFIERS_GET_VBI_OFFSET_NOTIFY(b)                   (3+(b))
#define NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(b)                 (5+(b))
#define NV04D_NOTIFIERS_GET_IMAGE_OFFSET_NOTIFY(b)                 (7+(b))
/* NvNotification[] fields and values */
#define NV04D_NOTIFICATION_INFO16_FIELD_NOT_STARTED                (0x0000)
#define NV04D_NOTIFICATION_INFO16_FIELD_VALID_OFFSET               (0x0001)
#define NV04D_NOTIFICATION_INFO16_FIELD_DONE                       (0x0002)
#define NV04D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04D_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04D_NOTIFY_*                   0104-0107*/
 NvV32 StopTransferVbi;         /* NV04D_STOP_TRANSFER_VBI_VALUE    0108-010b*/
 NvV32 StopTransferImage;       /* NV04D_STOP_TRANSFER_IMAGE_VALUE  010c-010f*/
 NvV32 Reserved00[0x01c];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaVbi[2];     /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 Reserved01[0x05a];
 NvU32 SetImageStartLine;       /* lines                            02fc-02ff*/
 struct {                       /* start of methods in array        0300-    */
  NvV32 size;                   /* height_firstLine U16_U16            0-   3*/
  NvU32 offset;                 /* byte offset of top-left pixel       4-   7*/
  NvV32 format;                 /* notify_field_pitch V8_V8_U16        8-   b*/
 } SetVbi[2];                   /* end of methods in array              -0317*/
 NvV32 GetVbiOffsetNotify[2];   /* NV04D_GET_VBI_OFFSET_NOTIFY_*    0318-031f*/
 struct {                       /* start of methods in array        0320-    */
  NvV32 sizeIn;                 /* height_width U16_U16 in pixels      0-   3*/
  NvV32 sizeOut;                /* height_width U16_U16 in pixels      4-   7*/
  NvU32 offset;                 /* byte offset of top-left pixel       8-   b*/
  NvV32 format;                 /* notify_field_pitch V8_V8_U16        c-   f*/
 } SetImage[2];                 /* end of methods in array              -033f*/
 NvV32 GetImageOffsetNotify[2]; /* NV04D_GET_IMAGE_OFFSET_NOTIFY_*  0340-0347*/
 NvV32 Reserved02[0x72e];
} Nv04dTypedef, Nv03ExternalVideoDecoder;
#define NV04D_TYPEDEF                                  nv03ExternalVideoDecoder
/* dma method offsets, fields, and values */
#define NV04D_SET_OBJECT                                           (0x00000000)
#define NV04D_NO_OPERATION                                         (0x00000100)
#define NV04D_NOTIFY                                               (0x00000104)
#define NV04D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04D_STOP_TRANSFER_VBI                                    (0x00000108)
#define NV04D_STOP_TRANSFER_VBI_VALUE                              (0x00000000)
#define NV04D_STOP_TRANSFER_IMAGE                                  (0x0000010C)
#define NV04D_STOP_TRANSFER_IMAGE_VALUE                            (0x00000000)
#define NV04D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04D_SET_CONTEXT_DMA_VBI(b)                               (0x00000184\
                                                                   +(b)*0x0004)
#define NV04D_SET_CONTEXT_DMA_IMAGE(b)                             (0x0000018C\
                                                                   +(b)*0x0004)
#define NV04D_SET_IMAGE_START_LINE                                 (0x000002FC)
#define NV04D_SET_VBI(b)                                           (0x00000300\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_SIZE(b)                                      (0x00000300\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_SIZE_FIRST_LINE                              15:0
#define NV04D_SET_VBI_SIZE_HEIGHT                                  31:16
#define NV04D_SET_VBI_OFFSET(b)                                    (0x00000304\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_FORMAT(b)                                    (0x00000308\
                                                                   +(b)*0x000C)
#define NV04D_SET_VBI_FORMAT_PITCH                                 15:0
#define NV04D_SET_VBI_FORMAT_FIELD                                 23:16
#define NV04D_SET_VBI_FORMAT_FIELD_PROGRESSIVE                     (0x00000000)
#define NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD                      (0x00000001)
#define NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD                       (0x00000002)
#define NV04D_SET_VBI_FORMAT_NOTIFY                                31:24
#define NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV04D_GET_VBI_OFFSET_NOTIFY(b)                             (0x00000318\
                                                                   +(b)*0x0004)
#define NV04D_GET_VBI_OFFSET_NOTIFY_WRITE_ONLY                     (0x00000000)
#define NV04D_GET_VBI_OFFSET_NOTIFY_WRITE_THEN_AWAKEN              (0x00000001)
#define NV04D_SET_IMAGE(b)                                         (0x00000320\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_IN(b)                                 (0x00000320\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_IN_WIDTH                              15:0
#define NV04D_SET_IMAGE_SIZE_IN_HEIGHT                             31:16
#define NV04D_SET_IMAGE_SIZE_OUT(b)                                (0x00000324\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_SIZE_OUT_WIDTH                             15:0
#define NV04D_SET_IMAGE_SIZE_OUT_HEIGHT                            31:16
#define NV04D_SET_IMAGE_OFFSET(b)                                  (0x00000328\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_FORMAT(b)                                  (0x0000032C\
                                                                   +(b)*0x0010)
#define NV04D_SET_IMAGE_FORMAT_PITCH                               15:0
#define NV04D_SET_IMAGE_FORMAT_FIELD                               23:16
#define NV04D_SET_IMAGE_FORMAT_FIELD_PROGRESSIVE                   (0x00000000)
#define NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD                    (0x00000001)
#define NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD                     (0x00000002)
#define NV04D_SET_IMAGE_FORMAT_NOTIFY                              31:24
#define NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY(b)                           (0x00000340\
                                                                   +(b)*0x0004)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_ONLY                   (0x00000000)
#define NV04D_GET_IMAGE_OFFSET_NOTIFY_WRITE_THEN_AWAKEN            (0x00000001)



/* class NV03_EXTERNAL_VIDEO_DECOMPRESSOR */
#define  NV03_EXTERNAL_VIDEO_DECOMPRESSOR                          (0x0000004E)
/* NvNotification[] elements */
#define NV04E_NOTIFIERS_NOTIFY                                     (0)
#define NV04E_NOTIFIERS_SET_DATA_NOTIFY(b)                         (1+(b))
#define NV04E_NOTIFIERS_SET_IMAGE_NOTIFY(b)                        (3+(b))
/* NvNotification[] fields and values */
#define NV04E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04E_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV04E_NOTIFY_*                   0104-0107*/
 NvV32 StopTransfer;            /* NV04E_STOP_TRANSFER_VALUE        0108-010b*/
 NvV32 Reserved00[0x01d];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaData[2];    /* NV01_CONTEXT_DMA                 0184-018b*/
 NvV32 SetContextDmaImage[2];   /* NV01_CONTEXT_DMA                 018c-0193*/
 NvV32 Reserved01[0x05b];
 struct {                       /* start of methods in array        0300-    */
  NvU32 offset;                 /* in bytes                            0-   3*/
  NvU32 length;                 /* in bytes                            4-   7*/
  NvV32 notify;                 /* NV04E_SET_DATA_NOTIFY_*             8-   b*/
 } SetData[2];                  /* end of methods in array              -0317*/
 struct {                       /* start of methods in array        0318-    */
  NvV32 formatIn;               /* zero_field V16_V16                 00-  03*/
  NvV32 size;                   /* height_width U16_U16 in pixels     04-  07*/
  NvU32 offsetOut;              /* byte offset of top-left pixel      08-  0b*/
  NvV32 formatOut;              /* ignore_pitch V16_U16               0c-  0f*/
  NvV32 notify;                 /* NV04E_SET_IMAGE_NOTIFY_*           10-  13*/
 } SetImage[2];                 /* end of methods in array              -033f*/
 NvV32 Reserved02[0x730];
} Nv04eTypedef, Nv03ExternalVideoDecompressor;
#define NV04E_TYPEDEF                             nv03ExternalVideoDecompressor
/* dma method offsets, fields, and values */
#define NV04E_SET_OBJECT                                           (0x00000000)
#define NV04E_NO_OPERATION                                         (0x00000100)
#define NV04E_NOTIFY                                               (0x00000104)
#define NV04E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04E_STOP_TRANSFER                                        (0x00000108)
#define NV04E_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV04E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04E_SET_CONTEXT_DMA_DATA(b)                              (0x00000184\
                                                                   +(b)*0x0004)
#define NV04E_SET_CONTEXT_DMA_IMAGE(b)                             (0x0000018C\
                                                                   +(b)*0x0004)
#define NV04E_SET_DATA(b)                                          (0x00000300\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_OFFSET(b)                                   (0x00000300\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_LENGTH(b)                                   (0x00000304\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_NOTIFY(b)                                   (0x00000308\
                                                                   +(b)*0x000C)
#define NV04E_SET_DATA_NOTIFY_WRITE_ONLY                           (0x00000000)
#define NV04E_SET_DATA_NOTIFY_WRITE_THEN_AWAKEN                    (0x00000001)
#define NV04E_SET_IMAGE(b)                                         (0x00000318\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_IN(b)                               (0x00000318\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD                            15:0
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_PROGRESSIVE                (0x00000001)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_EVEN_FIELD                 (0x00000002)
#define NV04E_SET_IMAGE_FORMAT_IN_FIELD_ODD_FIELD                  (0x00000003)
#define NV04E_SET_IMAGE_FORMAT_IN_ZERO                             31:16
#define NV04E_SET_IMAGE_SIZE(b)                                    (0x0000031C\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_SIZE_WIDTH                                 15:0
#define NV04E_SET_IMAGE_SIZE_HEIGHT                                31:16
#define NV04E_SET_IMAGE_OFFSET_OUT(b)                              (0x00000320\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_OUT(b)                              (0x00000324\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_FORMAT_OUT_PITCH                           15:0
#define NV04E_SET_IMAGE_FORMAT_OUT_IGNORE                          31:16
#define NV04E_SET_IMAGE_NOTIFY(b)                                  (0x00000324\
                                                                   +(b)*0x0014)
#define NV04E_SET_IMAGE_NOTIFY_WRITE_ONLY                          (0x00000000)
#define NV04E_SET_IMAGE_NOTIFY_WRITE_THEN_AWAKEN                   (0x00000001)
/* obsolete stuff */
#define NV3_EXTERNAL_VIDEO_DECOMPRESSOR                            (0x0000004E)
#define Nv3ExternalVideoDecompressor              Nv03ExternalVideoDecompressor
#define nv3ExternalVideoDecompressor              nv03ExternalVideoDecompressor




/* class NV01_EXTERNAL_PARALLEL_BUS */
#define  NV01_EXTERNAL_PARALLEL_BUS                                (0x0000004F)
#define  NV1_EXTERNAL_PARALLEL_BUS                                 (0x0000004F)
/* NvNotification[] elements */
#define NV04F_NOTIFIERS_NOTIFY                                     (0)
#define NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV04F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV04F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV04F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV04F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV04F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV04F_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV04F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV04F_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV04F_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01d];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 WriteSize;               /* address_data U16_U16              0300-0303*/
 U032 WriteAddress;            /* in bytes                          0304-0307*/
 V032 WriteData;               /* data                              0308-030b*/
 V032 ReadSize;                /* address_data U16_U16              030c-030f*/
 U032 ReadAddress;             /* in bytes                          0310-0313*/
 V032 ReadGetDataNotify;       /* NV04F_READ_GET_DATA_NOTIFY_*      0314-0317*/
 V032 SetInterruptNotify;      /* NV04F_SET_INTERRUPT_NOTIFY_*      0318-031b*/
 V032 Reserved02[0x739];
} Nv04fTypedef, Nv01ExternalParallelBus;
#define Nv1ExternalParallelBus                          Nv01ExternalParallelBus
#define nv1ExternalParallelBus                          nv01ExternalParallelBus
#define NV04F_TYPEDEF                                   nv01ExternalParallelBus
/* dma method offsets, fields, and values */
#define NV04F_SET_OBJECT                                           (0x00000000)
#define NV04F_NO_OPERATION                                         (0x00000100)
#define NV04F_NOTIFY                                               (0x00000104)
#define NV04F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV04F_STOP_TRANSFER                                        (0x00000108)
#define NV04F_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV04F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04F_WRITE                                                (0x00000300)
#define NV04F_WRITE_SIZE                                           (0x00000300)
#define NV04F_WRITE_SIZE_DATA                                      15:0
#define NV04F_WRITE_SIZE_ADDRESS                                   31:16
#define NV04F_WRITE_ADDRESS                                        (0x00000304)
#define NV04F_WRITE_DATA                                           (0x00000308)
#define NV04F_READ                                                 (0x0000030C)
#define NV04F_READ_SIZE                                            (0x0000030C)
#define NV04F_READ_SIZE_DATA                                       15:0
#define NV04F_READ_SIZE_ADDRESS                                    31:16
#define NV04F_READ_ADDRESS                                         (0x00000310)
#define NV04F_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV04F_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV04F_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV04F_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV04F_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV04F_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)


/* class NV03_EXTERNAL_MONITOR_BUS */
#define  NV03_EXTERNAL_MONITOR_BUS                                 (0x00000050)
#define  NV3_EXTERNAL_MONITOR_BUS                                  (0x00000050)
/* NvNotification[] elements */
#define NV050_NOTIFIERS_NOTIFY                                     (0)
#define NV050_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV050_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV050_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV050_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV050_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV050_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV050_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV050_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV050_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV050_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV050_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01d];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 WriteSize;               /* address_data U16_U16              0300-0303*/
 U032 WriteAddress;            /* in bytes                          0304-0307*/
 V032 WriteData;               /* data                              0308-030b*/
 V032 ReadSize;                /* address_data U16_U16              030c-030f*/
 U032 ReadAddress;             /* in bytes                          0310-0313*/
 V032 ReadGetDataNotify;       /* NV050_READ_GET_DATA_NOTIFY_*      0314-0317*/
 V032 SetInterruptNotify;      /* NV050_SET_INTERRUPT_NOTIFY_*      0318-031b*/
 V032 Reserved02[0x739];
} Nv050Typedef, Nv03ExternalMonitorBus;
#define Nv3ExternalMonitorBus                            Nv03ExternalMonitorBus
#define nv3ExternalMonitorBus                            nv03ExternalMonitorBus
#define NV050_TYPEDEF                                    nv03ExternalMonitorBus
/* dma method offsets, fields, and values */
#define NV050_SET_OBJECT                                           (0x00000000)
#define NV050_NO_OPERATION                                         (0x00000100)
#define NV050_NOTIFY                                               (0x00000104)
#define NV050_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV050_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV050_STOP_TRANSFER                                        (0x00000108)
#define NV050_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV050_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV050_WRITE                                                (0x00000300)
#define NV050_WRITE_SIZE                                           (0x00000300)
#define NV050_WRITE_SIZE_DATA                                      15:0
#define NV050_WRITE_SIZE_ADDRESS                                   31:16
#define NV050_WRITE_ADDRESS                                        (0x00000304)
#define NV050_WRITE_DATA                                           (0x00000308)
#define NV050_READ                                                 (0x0000030C)
#define NV050_READ_SIZE                                            (0x0000030C)
#define NV050_READ_SIZE_DATA                                       15:0
#define NV050_READ_SIZE_ADDRESS                                    31:16
#define NV050_READ_ADDRESS                                         (0x00000310)
#define NV050_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV050_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV050_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV050_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV050_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV050_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)


/* class NV03_EXTERNAL_SERIAL_BUS */
#define  NV03_EXTERNAL_SERIAL_BUS                                  (0x00000051)
#define  NV3_EXTERNAL_SERIAL_BUS                                   (0x00000051)
/* NvNotification[] elements */
#define NV051_NOTIFIERS_NOTIFY                                     (0)
#define NV051_NOTIFICATION_READ_GET_DATA_NOTIFY                    (1)
#define NV051_NOTIFICATION_SET_INTERRUPT_NOTIFY                    (2)
/* NvNotification[] fields and values */
#define NV051_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV051_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV051_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV051_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV051_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV051_NOTIFICATION_STATUS_WARNING_INVALID_DATA             (0x0001)
#define NV051_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV051_NOTIFY_*                    0104-0107*/
 V032 StopTransfer;            /* NV051_STOP_TRANSFER_VALUE         0108-010b*/
 V032 Reserved00[0x01d];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 WriteSize;               /* address_data U16_U16              0300-0303*/
 U032 WriteAddress;            /* in bytes                          0304-0307*/
 V032 WriteData;               /* data                              0308-030b*/
 V032 ReadSize;                /* address_data U16_U16              030c-030f*/
 U032 ReadAddress;             /* in bytes                          0310-0313*/
 V032 ReadGetDataNotify;       /* NV051_READ_GET_DATA_NOTIFY_*      0314-0317*/
 V032 SetInterruptNotify;      /* NV051_SET_INTERRUPT_NOTIFY_*      0318-031b*/
 V032 Reserved02[0x739];
} Nv051Typedef, Nv03ExternalSerialBus;
#define Nv3ExternalSerialBus                              Nv03ExternalSerialBus
#define nv3ExternalSerialBus                              nv03ExternalSerialBus
#define NV051_TYPEDEF                                     nv03ExternalSerialBus
/* dma method offsets, fields, and values */
#define NV051_SET_OBJECT                                           (0x00000000)
#define NV051_NO_OPERATION                                         (0x00000100)
#define NV051_NOTIFY                                               (0x00000104)
#define NV051_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV051_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV051_STOP_TRANSFER                                        (0x00000108)
#define NV051_STOP_TRANSFER_VALUE                                  (0x00000000)
#define NV051_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV051_WRITE                                                (0x00000300)
#define NV051_WRITE_SIZE                                           (0x00000300)
#define NV051_WRITE_SIZE_DATA                                      15:0
#define NV051_WRITE_SIZE_ADDRESS                                   31:16
#define NV051_WRITE_ADDRESS                                        (0x00000304)
#define NV051_WRITE_DATA                                           (0x00000308)
#define NV051_READ                                                 (0x0000030C)
#define NV051_READ_SIZE                                            (0x0000030C)
#define NV051_READ_SIZE_DATA                                       15:0
#define NV051_READ_SIZE_ADDRESS                                    31:16
#define NV051_READ_ADDRESS                                         (0x00000310)
#define NV051_READ_GET_DATA_NOTIFY                                 (0x00000314)
#define NV051_READ_GET_DATA_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV051_READ_GET_DATA_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)
#define NV051_SET_INTERRUPT_NOTIFY                                 (0x00000318)
#define NV051_SET_INTERRUPT_NOTIFY_WRITE_ONLY                      (0x00000000)
#define NV051_SET_INTERRUPT_NOTIFY_WRITE_THEN_AWAKEN               (0x00000001)


/* class NV04_CONTEXT_SURFACE_SWIZZLED */
#define  NV04_CONTEXT_SURFACE_SWIZZLED                             (0x00000052)
#define  NV4_CONTEXT_SURFACE_SWIZZLED                              (0x00000052)
/* NvNotification[] elements */
#define NV052_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV052_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV052_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV052_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV052_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV052_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV052_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV052_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetFormat;               /* height_width_color V8_V8_V16      0300-0303*/
 U032 SetOffset;               /* byte offset of top-left pixel     0304-0307*/
 V032 Reserved02[0x73e];
} Nv052Typedef, Nv04ContextSurfaceSwizzled;
#define Nv4ContextSurfaceSwizzled                    Nv04ContextSurfaceSwizzled
#define nv4ContextSurfaceSwizzled                    nv04ContextSurfaceSwizzled
#define NV052_TYPEDEF                                nv04ContextSurfaceSwizzled
/* dma method offsets, fields, and values */
#define NV052_SET_OBJECT                                           (0x00000000)
#define NV052_NO_OPERATION                                         (0x00000100)
#define NV052_NOTIFY                                               (0x00000104)
#define NV052_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV052_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV052_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV052_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV052_SET_FORMAT                                           (0x00000300)
#define NV052_SET_FORMAT_COLOR                                     15:0
#define NV052_SET_FORMAT_COLOR_LE_Y8                               (0x00000001)
#define NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000002)
#define NV052_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000003)
#define NV052_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000004)
#define NV052_SET_FORMAT_COLOR_LE_Y16                              (0x00000005)
#define NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000006)
#define NV052_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000007)
#define NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000008)
#define NV052_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000009)
#define NV052_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x0000000A)
#define NV052_SET_FORMAT_COLOR_LE_Y32                              (0x0000000B)
#define NV052_SET_FORMAT_WIDTH                                     23:16
#define NV052_SET_FORMAT_WIDTH_1                                   (0x00000000)
#define NV052_SET_FORMAT_WIDTH_2                                   (0x00000001)
#define NV052_SET_FORMAT_WIDTH_4                                   (0x00000002)
#define NV052_SET_FORMAT_WIDTH_8                                   (0x00000003)
#define NV052_SET_FORMAT_WIDTH_16                                  (0x00000004)
#define NV052_SET_FORMAT_WIDTH_32                                  (0x00000005)
#define NV052_SET_FORMAT_WIDTH_64                                  (0x00000006)
#define NV052_SET_FORMAT_WIDTH_128                                 (0x00000007)
#define NV052_SET_FORMAT_WIDTH_256                                 (0x00000008)
#define NV052_SET_FORMAT_WIDTH_512                                 (0x00000009)
#define NV052_SET_FORMAT_WIDTH_1024                                (0x0000000A)
#define NV052_SET_FORMAT_WIDTH_2048                                (0x0000000B)
#define NV052_SET_FORMAT_HEIGHT                                    31:24
#define NV052_SET_FORMAT_HEIGHT_1                                  (0x00000000)
#define NV052_SET_FORMAT_HEIGHT_2                                  (0x00000001)
#define NV052_SET_FORMAT_HEIGHT_4                                  (0x00000002)
#define NV052_SET_FORMAT_HEIGHT_8                                  (0x00000003)
#define NV052_SET_FORMAT_HEIGHT_16                                 (0x00000004)
#define NV052_SET_FORMAT_HEIGHT_32                                 (0x00000005)
#define NV052_SET_FORMAT_HEIGHT_64                                 (0x00000006)
#define NV052_SET_FORMAT_HEIGHT_128                                (0x00000007)
#define NV052_SET_FORMAT_HEIGHT_256                                (0x00000008)
#define NV052_SET_FORMAT_HEIGHT_512                                (0x00000009)
#define NV052_SET_FORMAT_HEIGHT_1024                               (0x0000000A)
#define NV052_SET_FORMAT_HEIGHT_2048                               (0x0000000B)
#define NV052_SET_OFFSET                                           (0x00000304)


/* class NV04_CONTEXT_SURFACES_ARGB_ZS */
#define  NV04_CONTEXT_SURFACES_ARGB_ZS                             (0x00000053)
#define  NV4_CONTEXT_SURFACES_ARGB_ZS                              (0x00000053)
/* NvNotification[] elements */
#define NV053_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV053_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV053_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV053_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV053_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV053_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV053_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV053_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaColor;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextDmaZeta;       /* NV01_CONTEXT_DMA                 0188-018b*/
 NvV32 Reserved01[0x05b];
 NvV32 SetClipHorizontal;       /* width_x U16_U16                  02F8-02FB*/
 NvV32 SetClipVertical;         /* height_y U16_U16                 02FC-02FF*/
 NvV32 SetFormat;               /* height_width_type_color all V8   0300-0303*/
 NvV32 SetClipSize;             /* height_width U16_U16             0304-0307*/
 NvU32 SetPitch;                /* zeta_color U16_U16               0308-030b*/
 NvU32 SetOffsetColor;          /* byte offset of top-left pixel    030c-030f*/
 NvU32 SetOffsetZeta;           /* byte offset of top-left pixel    0310-0313*/
 NvV32 Reserved02[0x73b];
} Nv053Typedef, Nv04ContextSurfacesArgbZs;
#define Nv4ContextSurfacesArgbZs                      Nv04ContextSurfacesArgbZs
#define nv4ContextSurfacesArgbZs                      nv04ContextSurfacesArgbZs
#define NV053_TYPEDEF                                 nv04ContextSurfacesArgbZs
/* dma method offsets, fields, and values */
#define NV053_SET_OBJECT                                           (0x00000000)
#define NV053_NO_OPERATION                                         (0x00000100)
#define NV053_NOTIFY                                               (0x00000104)
#define NV053_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV053_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV053_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV053_SET_CONTEXT_DMA_COLOR                                (0x00000184)
#define NV053_SET_CONTEXT_DMA_ZETA                                 (0x00000188)
#define NV053_SET_CLIP_HORIZONTAL                                  (0x000002F8)
#define NV053_SET_CLIP_HORIZONTAL_X                                15:0
#define NV053_SET_CLIP_HORIZONTAL_WIDTH                            31:16
#define NV053_SET_CLIP_VERTICAL                                    (0x000002FC)
#define NV053_SET_CLIP_VERTICAL_Y                                  15:0
#define NV053_SET_CLIP_VERTICAL_HEIGHT                             31:16
#define NV053_SET_FORMAT                                           (0x00000300)
#define NV053_SET_FORMAT_COLOR                                     7:0
#define NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_Z1R5G5B5                (0x00000001)
#define NV053_SET_FORMAT_COLOR_LE_X1R5G5B5_O1R5G5B5                (0x00000002)
#define NV053_SET_FORMAT_COLOR_LE_R5G6B5                           (0x00000003)
#define NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_Z8R8G8B8                (0x00000004)
#define NV053_SET_FORMAT_COLOR_LE_X8R8G8B8_O8R8G8B8                (0x00000005)
#define NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_Z1A7R8G8B8            (0x00000006)
#define NV053_SET_FORMAT_COLOR_LE_X1A7R8G8B8_O1A7R8G8B8            (0x00000007)
#define NV053_SET_FORMAT_COLOR_LE_A8R8G8B8                         (0x00000008)
#define NV053_SET_FORMAT_TYPE                                      15:8
#define NV053_SET_FORMAT_TYPE_PITCH                                (0x00000001)
#define NV053_SET_FORMAT_TYPE_SWIZZLE                              (0x00000002)
#define NV053_SET_FORMAT_WIDTH                                     23:16
#define NV053_SET_FORMAT_HEIGHT                                    31:24
#define NV053_SET_CLIP_SIZE                                        (0x00000304)
#define NV053_SET_CLIP_SIZE_WIDTH                                  15:0
#define NV053_SET_CLIP_SIZE_HEIGHT                                 31:16
#define NV053_SET_PITCH                                            (0x00000308)
#define NV053_SET_PITCH_COLOR                                      15:0
#define NV053_SET_PITCH_ZETA                                       31:16
#define NV053_SET_OFFSET_COLOR                                     (0x0000030C)
#define NV053_SET_OFFSET_ZETA                                      (0x00000310)


/* class NV04_DX5_TEXTURED_TRIANGLE */
#define  NV04_DX5_TEXTURED_TRIANGLE                                (0x00000054)
#define  NV4_DX5_TEXTURED_TRIANGLE                                 (0x00000054)
/* NvNotification[] elements */
#define NV054_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV054_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV054_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV054_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV054_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV054_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV054_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV054_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaA;          /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaB;          /* NV01_CONTEXT_DMA_FROM_MEMORY      0188-018b*/
 V032 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_ARGB_ZS     018c-018f*/
 V032 Reserved01[0x05c];
 V032 ColorKey;                /* texture color key value           0300-0303*/
 U032 Offset;                  /* texture offset in bytes           0304-0307*/
 V032 Format;                  /* see text                          0308-030b*/
 V032 Filter;                  /* see text                          030c-030f*/
 V032 Blend;                   /* see text                          0310-0313*/
 V032 Control;                 /* see text                          0314-0317*/
 V032 FogColor;                /* X8R8G8B8 fog color                0318-031b*/
 V032 Reserved02[0x039];
 struct {                      /* start of method in array          0400-    */
  F032 sx;                     /* screen x coordinate                 00-  03*/
  F032 sy;                     /* screen y coordinate                 04-  07*/
  F032 sz;                     /* screen z coordinate                 08-  0b*/
  F032 rhw;                    /* reciprocal homogeneous W (1/W)      0c-  0f*/
  V032 color;                  /* A8R8G8B8                            10-  13*/
  V032 specular;               /* F8R8G8B8                            14-  17*/
  F032 tu;                     /* texture u coordinate                18-  1b*/
  F032 tv;                     /* texture v coordinate                1c-  1f*/
 } Tlvertex[16];               /* end of method in array                -05ff*/
 V032 DrawPrimitive[64];       /* see text                          0600-06ff*/
 V032 Reserved03[0x640];
} Nv054Typedef, Nv04Dx5TexturedTriangle;
#define Nv4Dx5TexturedTriangle                          Nv04Dx5TexturedTriangle
#define nv4Dx5TexturedTriangle                          nv04Dx5TexturedTriangle
#define NV054_TYPEDEF                                   nv04Dx5TexturedTriangle
/* dma method offsets, fields, and values */
#define NV054_SET_OBJECT                                           (0x00000000)
#define NV054_NO_OPERATION                                         (0x00000100)
#define NV054_NOTIFY                                               (0x00000104)
#define NV054_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV054_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV054_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV054_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV054_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV054_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV054_COLOR_KEY                                            (0x00000300)
#define NV054_OFFSET                                               (0x00000304)
#define NV054_FORMAT                                               (0x00000308)
#define NV054_FORMAT_CONTEXT_DMA                                   1:0
#define NV054_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV054_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV054_FORMAT_COLORKEYENABLE                                3:2
#define NV054_FORMAT_COLORKEYENABLE_FALSE                          (0x00000000)
#define NV054_FORMAT_COLORKEYENABLE_TRUE                           (0x00000001)
#define NV054_FORMAT_ORIGIN_ZOH                                    5:4
#define NV054_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV054_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV054_FORMAT_ORIGIN_FOH                                    7:6
#define NV054_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV054_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV054_FORMAT_COLOR                                         11:8
#define NV054_FORMAT_COLOR_LE_Y8                                   (0x00000001)
#define NV054_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV054_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV054_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV054_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV054_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV054_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV054_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV054_FORMAT_BASE_SIZE_U                                   19:16
#define NV054_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV054_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV054_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV054_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV054_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV054_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV054_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV054_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV054_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV054_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV054_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV054_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV054_FORMAT_BASE_SIZE_V                                   23:20
#define NV054_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV054_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV054_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV054_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV054_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV054_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV054_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV054_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV054_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV054_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV054_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV054_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV054_FORMAT_TEXTUREADDRESSU                               26:24
#define NV054_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV054_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV054_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV054_FORMAT_WRAPU                                         27:27
#define NV054_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV054_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSV                               30:28
#define NV054_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV054_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV054_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV054_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV054_FORMAT_WRAPV                                         31:31
#define NV054_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV054_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV054_FILTER                                               (0x0000030C)
#define NV054_FILTER_KERNEL_SIZE_X                                 7:0
#define NV054_FILTER_KERNEL_SIZE_Y                                 14:8
#define NV054_FILTER_MIPMAP_DITHER_ENABLE                          15:15
#define NV054_FILTER_MIPMAP_DITHER_ENABLE_FALSE                    (0x00000000)
#define NV054_FILTER_MIPMAP_DITHER_ENABLE_TRUE                     (0x00000001)
#define NV054_FILTER_MIPMAPLODBIAS                                 23:16
#define NV054_FILTER_TEXTUREMIN                                    26:24
#define NV054_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV054_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV054_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV054_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV054_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV054_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE                     27:27
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE               (0x00000000)
#define NV054_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE                (0x00000001)
#define NV054_FILTER_TEXTUREMAG                                    30:28
#define NV054_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV054_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV054_FILTER_TEXTUREMAG_MIPNEAREST                         (0x00000003)
#define NV054_FILTER_TEXTUREMAG_MIPLINEAR                          (0x00000004)
#define NV054_FILTER_TEXTUREMAG_LINEARMIPNEAREST                   (0x00000005)
#define NV054_FILTER_TEXTUREMAG_LINEARMIPLINEAR                    (0x00000006)
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE                    31:31
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE              (0x00000000)
#define NV054_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE               (0x00000001)
#define NV054_BLEND                                                (0x00000310)
#define NV054_BLEND_TEXTUREMAPBLEND                                3:0
#define NV054_BLEND_TEXTUREMAPBLEND_DECAL                          (0x00000001)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATE                       (0x00000002)
#define NV054_BLEND_TEXTUREMAPBLEND_DECALALPHA                     (0x00000003)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATEALPHA                  (0x00000004)
#define NV054_BLEND_TEXTUREMAPBLEND_DECALMASK                      (0x00000005)
#define NV054_BLEND_TEXTUREMAPBLEND_MODULATEMASK                   (0x00000006)
#define NV054_BLEND_TEXTUREMAPBLEND_COPY                           (0x00000007)
#define NV054_BLEND_TEXTUREMAPBLEND_ADD                            (0x00000008)
#define NV054_BLEND_MASK_BIT                                       5:4
#define NV054_BLEND_MASK_BIT_LSB                                   (0x00000001)
#define NV054_BLEND_MASK_BIT_MSB                                   (0x00000002)
#define NV054_BLEND_SHADEMODE                                      7:6
#define NV054_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV054_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV054_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV054_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV054_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV054_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV054_BLEND_SPECULARENABLE                                 15:12
#define NV054_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV054_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV054_BLEND_FOGENABLE                                      19:16
#define NV054_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV054_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV054_BLEND_ALPHABLENDENABLE                               23:20
#define NV054_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV054_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV054_BLEND_SRCBLEND                                       27:24
#define NV054_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV054_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV054_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV054_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV054_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV054_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV054_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV054_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV054_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV054_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV054_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV054_BLEND_DESTBLEND                                      31:28
#define NV054_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV054_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV054_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV054_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV054_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV054_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV054_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV054_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV054_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV054_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV054_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV054_CONTROL                                              (0x00000314)
#define NV054_CONTROL_ALPHAREF                                     7:0
#define NV054_CONTROL_ALPHAFUNC                                    11:8
#define NV054_CONTROL_ALPHAFUNC_NEVER                              (0x00000001)
#define NV054_CONTROL_ALPHAFUNC_LESS                               (0x00000002)
#define NV054_CONTROL_ALPHAFUNC_EQUAL                              (0x00000003)
#define NV054_CONTROL_ALPHAFUNC_LESSEQUAL                          (0x00000004)
#define NV054_CONTROL_ALPHAFUNC_GREATER                            (0x00000005)
#define NV054_CONTROL_ALPHAFUNC_NOTEQUAL                           (0x00000006)
#define NV054_CONTROL_ALPHAFUNC_GREATEREQUAL                       (0x00000007)
#define NV054_CONTROL_ALPHAFUNC_ALWAYS                             (0x00000008)
#define NV054_CONTROL_ALPHATESTENABLE                              12:12
#define NV054_CONTROL_ALPHATESTENABLE_FALSE                        (0x00000000)
#define NV054_CONTROL_ALPHATESTENABLE_TRUE                         (0x00000001)
#define NV054_CONTROL_ORIGIN                                       13:13
#define NV054_CONTROL_ORIGIN_CENTER                                (0x00000000)
#define NV054_CONTROL_ORIGIN_CORNER                                (0x00000001)
#define NV054_CONTROL_ZENABLE                                      15:14
#define NV054_CONTROL_ZENABLE_FALSE                                (0x00000000)
#define NV054_CONTROL_ZENABLE_TRUE                                 (0x00000001)
#define NV054_CONTROL_ZFUNC                                        19:16
#define NV054_CONTROL_ZFUNC_NEVER                                  (0x00000001)
#define NV054_CONTROL_ZFUNC_LESS                                   (0x00000002)
#define NV054_CONTROL_ZFUNC_EQUAL                                  (0x00000003)
#define NV054_CONTROL_ZFUNC_LESSEQUAL                              (0x00000004)
#define NV054_CONTROL_ZFUNC_GREATER                                (0x00000005)
#define NV054_CONTROL_ZFUNC_NOTEQUAL                               (0x00000006)
#define NV054_CONTROL_ZFUNC_GREATEREQUAL                           (0x00000007)
#define NV054_CONTROL_ZFUNC_ALWAYS                                 (0x00000008)
#define NV054_CONTROL_CULLMODE                                     21:20
#define NV054_CONTROL_CULLMODE_NONE                                (0x00000001)
#define NV054_CONTROL_CULLMODE_CW                                  (0x00000002)
#define NV054_CONTROL_CULLMODE_CCW                                 (0x00000003)
#define NV054_CONTROL_DITHERENABLE                                 22:22
#define NV054_CONTROL_DITHERENABLE_FALSE                           (0x00000000)
#define NV054_CONTROL_DITHERENABLE_TRUE                            (0x00000001)
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE                         23:23
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE_FALSE                   (0x00000000)
#define NV054_CONTROL_Z_PERSPECTIVE_ENABLE_TRUE                    (0x00000001)
#define NV054_CONTROL_ZWRITEENABLE                                 29:24
#define NV054_CONTROL_ZWRITEENABLE_FALSE                           (0x00000000)
#define NV054_CONTROL_ZWRITEENABLE_TRUE                            (0x00000001)
#define NV054_CONTROL_Z_FORMAT                                     31:30
#define NV054_CONTROL_Z_FORMAT_FIXED                               (0x00000001)
#define NV054_CONTROL_Z_FORMAT_FLOAT                               (0x00000002)
#define NV054_FOG_COLOR                                            (0x00000318)
#define NV054_TLVERTEX(i)                                          (0x00000400\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SX(i)                                       (0x00000400\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SY(i)                                       (0x00000404\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SZ(i)                                       (0x00000408\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_RHW(i)                                      (0x0000040C\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_COLOR(i)                                    (0x00000410\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_COLOR_BLUE                                  7:0
#define NV054_TLVERTEX_COLOR_GREEN                                 15:8
#define NV054_TLVERTEX_COLOR_RED                                   23:16
#define NV054_TLVERTEX_COLOR_ALPHA                                 31:24
#define NV054_TLVERTEX_SPECULAR(i)                                 (0x00000414\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_SPECULAR_BLUE                               7:0
#define NV054_TLVERTEX_SPECULAR_GREEN                              15:8
#define NV054_TLVERTEX_SPECULAR_RED                                23:16
#define NV054_TLVERTEX_SPECULAR_FOG                                31:24
#define NV054_TLVERTEX_TU(i)                                       (0x00000418\
                                                                   +(i)*0x0020)
#define NV054_TLVERTEX_TV(i)                                       (0x0000041C\
                                                                   +(i)*0x0020)
#define NV054_DRAW_PRIMITIVE(a)                                    (0x00000600\
                                                                   +(a)*0x0004)
#define NV054_DRAW_PRIMITIVE_I0                                    3:0
#define NV054_DRAW_PRIMITIVE_I1                                    7:4
#define NV054_DRAW_PRIMITIVE_I2                                    11:8
#define NV054_DRAW_PRIMITIVE_I3                                    15:12
#define NV054_DRAW_PRIMITIVE_I4                                    19:16
#define NV054_DRAW_PRIMITIVE_I5                                    31:20


/* class NV04_DX6_MULTI_TEXTURE_TRIANGLE */
#define  NV04_DX6_MULTI_TEXTURE_TRIANGLE                           (0x00000055)
#define  NV4_DX6_MULTI_TEXTURE_TRIANGLE                            (0x00000055)
/* NvNotification[] elements */
#define NV055_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV055_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV055_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV055_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV055_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV055_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV055_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV055_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaA;          /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextDmaB;          /* NV01_CONTEXT_DMA_FROM_MEMORY      0188-018b*/
 V032 SetContextSurfaces;      /* NV01_CONTEXT_SURFACES_ARGB_ZS     018c-018f*/
 V032 Reserved01[0x05e];
 U032 Offset[2];               /* offset in bytes                   0308-030f*/
 V032 Format[2];               /* see text                          0310-0317*/
 V032 Filter[2];               /* see text                          0318-031f*/
 V032 Combine0Alpha;           /* see text                          0320-0323*/
 V032 Combine0Color;           /* see text                          0324-0327*/
 V032 Reserved02[0x001];
 V032 Combine1Alpha;           /* see text                          032c-032f*/
 V032 Combine1Color;           /* see text                          0330-0333*/
 V032 CombineFactor;           /* A8R8G8B8                          0334-0337*/
 V032 Blend;                   /* see text                          0338-033b*/
 V032 Control0;                /* see text                          033c-033f*/
 V032 Control1;                /* see text                          0340-0343*/
 V032 Control2;                /* see text                          0344-0347*/
 V032 FogColor;                /* X8R8G8B8 fog color                0348-034b*/
 V032 Reserved03[0x02D];
 struct {                      /* start of method in array          0400-    */
  F032 sx;                     /* screen x coordinate                 00-  03*/
  F032 sy;                     /* screen y coordinate                 04-  07*/
  F032 sz;                     /* screen z coordinate                 08-  0b*/
  F032 rhw;                    /* reciprocal homogeneous W (1/W)      0c-  0f*/
  V032 color;                  /* A8R8G8B8                            10-  13*/
  V032 specular;               /* F8R8G8B8                            14-  17*/
  F032 tu0;                    /* texture 0 u coordinate              18-  1b*/
  F032 tv0;                    /* texture 0 v coordinate              1c-  1f*/
  F032 tu1;                    /* texture 1 u coordinate              20-  23*/
  F032 tv1;                    /* texture 1 v coordinate              24-  27*/
 } Tlmtvertex[8];              /* end of method in array                -053f*/
 V032 DrawPrimitive[48];       /* see text                          0540-05ff*/
 V032 Reserved04[0x680];
} Nv055Typedef, Nv04Dx6MultiTextureTriangle;
#define Nv4Dx6MultiTextureTriangle                  Nv04Dx6MultiTextureTriangle
#define nv4Dx6MultiTextureTriangle                  nv04Dx6MultiTextureTriangle
#define NV055_TYPEDEF                               nv04Dx6MultiTextureTriangle
/* dma method offsets, fields, and values */
#define NV055_SET_OBJECT                                           (0x00000000)
#define NV055_NO_OPERATION                                         (0x00000100)
#define NV055_NOTIFY                                               (0x00000104)
#define NV055_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV055_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV055_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV055_SET_CONTEXT_DMA_A                                    (0x00000184)
#define NV055_SET_CONTEXT_DMA_B                                    (0x00000188)
#define NV055_SET_CONTEXT_SURFACES                                 (0x0000018C)
#define NV055_OFFSET(b)                                            (0x00000308\
                                                                   +(b)*0x0004)
#define NV055_FORMAT(b)                                            (0x00000310\
                                                                   +(b)*0x0004)
#define NV055_FORMAT_CONTEXT_DMA                                   3:0
#define NV055_FORMAT_CONTEXT_DMA_A                                 (0x00000001)
#define NV055_FORMAT_CONTEXT_DMA_B                                 (0x00000002)
#define NV055_FORMAT_ORIGIN_ZOH                                    5:4
#define NV055_FORMAT_ORIGIN_ZOH_CENTER                             (0x00000001)
#define NV055_FORMAT_ORIGIN_ZOH_CORNER                             (0x00000002)
#define NV055_FORMAT_ORIGIN_FOH                                    7:6
#define NV055_FORMAT_ORIGIN_FOH_CENTER                             (0x00000001)
#define NV055_FORMAT_ORIGIN_FOH_CORNER                             (0x00000002)
#define NV055_FORMAT_COLOR                                         11:8
#define NV055_FORMAT_COLOR_LE_AY8                                  (0x00000001)
#define NV055_FORMAT_COLOR_LE_A1R5G5B5                             (0x00000002)
#define NV055_FORMAT_COLOR_LE_X1R5G5B5                             (0x00000003)
#define NV055_FORMAT_COLOR_LE_A4R4G4B4                             (0x00000004)
#define NV055_FORMAT_COLOR_LE_R5G6B5                               (0x00000005)
#define NV055_FORMAT_COLOR_LE_A8R8G8B8                             (0x00000006)
#define NV055_FORMAT_COLOR_LE_X8R8G8B8                             (0x00000007)
#define NV055_FORMAT_MIPMAP_LEVELS                                 15:12
#define NV055_FORMAT_BASE_SIZE_U                                   19:16
#define NV055_FORMAT_BASE_SIZE_U_1                                 (0x00000000)
#define NV055_FORMAT_BASE_SIZE_U_2                                 (0x00000001)
#define NV055_FORMAT_BASE_SIZE_U_4                                 (0x00000002)
#define NV055_FORMAT_BASE_SIZE_U_8                                 (0x00000003)
#define NV055_FORMAT_BASE_SIZE_U_16                                (0x00000004)
#define NV055_FORMAT_BASE_SIZE_U_32                                (0x00000005)
#define NV055_FORMAT_BASE_SIZE_U_64                                (0x00000006)
#define NV055_FORMAT_BASE_SIZE_U_128                               (0x00000007)
#define NV055_FORMAT_BASE_SIZE_U_256                               (0x00000008)
#define NV055_FORMAT_BASE_SIZE_U_512                               (0x00000009)
#define NV055_FORMAT_BASE_SIZE_U_1024                              (0x0000000A)
#define NV055_FORMAT_BASE_SIZE_U_2048                              (0x0000000B)
#define NV055_FORMAT_BASE_SIZE_V                                   23:20
#define NV055_FORMAT_BASE_SIZE_V_1                                 (0x00000000)
#define NV055_FORMAT_BASE_SIZE_V_2                                 (0x00000001)
#define NV055_FORMAT_BASE_SIZE_V_4                                 (0x00000002)
#define NV055_FORMAT_BASE_SIZE_V_8                                 (0x00000003)
#define NV055_FORMAT_BASE_SIZE_V_16                                (0x00000004)
#define NV055_FORMAT_BASE_SIZE_V_32                                (0x00000005)
#define NV055_FORMAT_BASE_SIZE_V_64                                (0x00000006)
#define NV055_FORMAT_BASE_SIZE_V_128                               (0x00000007)
#define NV055_FORMAT_BASE_SIZE_V_256                               (0x00000008)
#define NV055_FORMAT_BASE_SIZE_V_512                               (0x00000009)
#define NV055_FORMAT_BASE_SIZE_V_1024                              (0x0000000A)
#define NV055_FORMAT_BASE_SIZE_V_2048                              (0x0000000B)
#define NV055_FORMAT_TEXTUREADDRESSU                               26:24
#define NV055_FORMAT_TEXTUREADDRESSU_WRAP                          (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSU_MIRROR                        (0x00000002)
#define NV055_FORMAT_TEXTUREADDRESSU_CLAMP                         (0x00000003)
#define NV055_FORMAT_TEXTUREADDRESSU_BORDER                        (0x00000004)
#define NV055_FORMAT_WRAPU                                         27:27
#define NV055_FORMAT_WRAPU_FALSE                                   (0x00000000)
#define NV055_FORMAT_WRAPU_TRUE                                    (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSV                               30:28
#define NV055_FORMAT_TEXTUREADDRESSV_WRAP                          (0x00000001)
#define NV055_FORMAT_TEXTUREADDRESSV_MIRROR                        (0x00000002)
#define NV055_FORMAT_TEXTUREADDRESSV_CLAMP                         (0x00000003)
#define NV055_FORMAT_TEXTUREADDRESSV_BORDER                        (0x00000004)
#define NV055_FORMAT_WRAPV                                         31:31
#define NV055_FORMAT_WRAPV_FALSE                                   (0x00000000)
#define NV055_FORMAT_WRAPV_TRUE                                    (0x00000001)
#define NV055_FILTER(b)                                            (0x00000318\
                                                                   +(b)*0x0004)
#define NV055_FILTER_KERNEL_SIZE_X                                 7:0
#define NV055_FILTER_KERNEL_SIZE_Y                                 14:8
#define NV055_FILTER_MIPMAP_DITHER_ENABLE                          15:15
#define NV055_FILTER_MIPMAP_DITHER_ENABLE_FALSE                    (0x00000000)
#define NV055_FILTER_MIPMAP_DITHER_ENABLE_TRUE                     (0x00000001)
#define NV055_FILTER_MIPMAPLODBIAS                                 23:16
#define NV055_FILTER_TEXTUREMIN                                    26:24
#define NV055_FILTER_TEXTUREMIN_NEAREST                            (0x00000001)
#define NV055_FILTER_TEXTUREMIN_LINEAR                             (0x00000002)
#define NV055_FILTER_TEXTUREMIN_MIPNEAREST                         (0x00000003)
#define NV055_FILTER_TEXTUREMIN_MIPLINEAR                          (0x00000004)
#define NV055_FILTER_TEXTUREMIN_LINEARMIPNEAREST                   (0x00000005)
#define NV055_FILTER_TEXTUREMIN_LINEARMIPLINEAR                    (0x00000006)
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE                     27:27
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_FALSE               (0x00000000)
#define NV055_FILTER_ANISOTROPIC_MINIFY_ENABLE_TRUE                (0x00000001)
#define NV055_FILTER_TEXTUREMAG                                    30:28
#define NV055_FILTER_TEXTUREMAG_NEAREST                            (0x00000001)
#define NV055_FILTER_TEXTUREMAG_LINEAR                             (0x00000002)
#define NV055_FILTER_TEXTUREMAG_MIPNEAREST                         (0x00000003)
#define NV055_FILTER_TEXTUREMAG_MIPLINEAR                          (0x00000004)
#define NV055_FILTER_TEXTUREMAG_LINEARMIPNEAREST                   (0x00000005)
#define NV055_FILTER_TEXTUREMAG_LINEARMIPLINEAR                    (0x00000006)
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE                    31:31
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_FALSE              (0x00000000)
#define NV055_FILTER_ANISOTROPIC_MAGNIFY_ENABLE_TRUE               (0x00000001)
#define NV055_COMBINE_0_ALPHA                                      (0x00000320)
#define NV055_COMBINE_0_ALPHA_INVERSE_0                            0:0
#define NV055_COMBINE_0_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_0                              1:1
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0                           7:2
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_1                            8:8
#define NV055_COMBINE_0_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_1                              9:9
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1                           15:10
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_2                            16:16
#define NV055_COMBINE_0_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_2                              17:17
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2                           23:18
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_INVERSE_3                            24:24
#define NV055_COMBINE_0_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_ALPHA_ALPHA_3                              25:25
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3                           28:26
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_ALPHA_OPERATION                            31:29
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_0_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_0_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_0_COLOR                                      (0x00000324)
#define NV055_COMBINE_0_COLOR_INVERSE_0                            0:0
#define NV055_COMBINE_0_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_0                              1:1
#define NV055_COMBINE_0_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0                           7:2
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_1                            8:8
#define NV055_COMBINE_0_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_1                              9:9
#define NV055_COMBINE_0_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1                           15:10
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_2                            16:16
#define NV055_COMBINE_0_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_2                              17:17
#define NV055_COMBINE_0_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2                           23:18
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_INVERSE_3                            24:24
#define NV055_COMBINE_0_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_0_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_0_COLOR_ALPHA_3                              25:25
#define NV055_COMBINE_0_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV055_COMBINE_0_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3                           28:26
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_0_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_0_COLOR_OPERATION                            31:29
#define NV055_COMBINE_0_COLOR_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_0_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_0_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_0_COLOR_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_0_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_1_ALPHA                                      (0x0000032C)
#define NV055_COMBINE_1_ALPHA_INVERSE_0                            0:0
#define NV055_COMBINE_1_ALPHA_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_0                              1:1
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0                           7:2
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_1                            8:8
#define NV055_COMBINE_1_ALPHA_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_1                              9:9
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1                           15:10
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_2                            16:16
#define NV055_COMBINE_1_ALPHA_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_2                              17:17
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2                           23:18
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_INVERSE_3                            24:24
#define NV055_COMBINE_1_ALPHA_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_ALPHA_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_ALPHA_ALPHA_3                              25:25
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3                           28:26
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_ALPHA_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_ALPHA_OPERATION                            31:29
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_1_ALPHA_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_1_ALPHA_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_1_COLOR                                      (0x00000330)
#define NV055_COMBINE_1_COLOR_INVERSE_0                            0:0
#define NV055_COMBINE_1_COLOR_INVERSE_0_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_0_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_0                              1:1
#define NV055_COMBINE_1_COLOR_ALPHA_0_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_0_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0                           7:2
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_0_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_1                            8:8
#define NV055_COMBINE_1_COLOR_INVERSE_1_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_1_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_1                              9:9
#define NV055_COMBINE_1_COLOR_ALPHA_1_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_1_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1                           15:10
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_1_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_2                            16:16
#define NV055_COMBINE_1_COLOR_INVERSE_2_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_2_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_2                              17:17
#define NV055_COMBINE_1_COLOR_ALPHA_2_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_2_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2                           23:18
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_2_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_INVERSE_3                            24:24
#define NV055_COMBINE_1_COLOR_INVERSE_3_NORMAL                     (0x00000000)
#define NV055_COMBINE_1_COLOR_INVERSE_3_INVERSE                    (0x00000001)
#define NV055_COMBINE_1_COLOR_ALPHA_3                              25:25
#define NV055_COMBINE_1_COLOR_ALPHA_3_COLOR                        (0x00000000)
#define NV055_COMBINE_1_COLOR_ALPHA_3_ALPHA                        (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3                           28:26
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_ZERO                      (0x00000001)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_FACTOR                    (0x00000002)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_DIFFUSE                   (0x00000003)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_INPUT                     (0x00000004)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE0                  (0x00000005)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURE1                  (0x00000006)
#define NV055_COMBINE_1_COLOR_ARGUMENT_3_TEXTURELOD                (0x00000007)
#define NV055_COMBINE_1_COLOR_OPERATION                            31:29
#define NV055_COMBINE_1_COLOR_OPERATION_ADD                        (0x00000001)
#define NV055_COMBINE_1_COLOR_OPERATION_ADD2                       (0x00000002)
#define NV055_COMBINE_1_COLOR_OPERATION_ADD4                       (0x00000003)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED                  (0x00000004)
#define NV055_COMBINE_1_COLOR_OPERATION_MUX                        (0x00000005)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDCOMPLEMENT              (0x00000006)
#define NV055_COMBINE_1_COLOR_OPERATION_ADDSIGNED2                 (0x00000007)
#define NV055_COMBINE_FACTOR                                       (0x00000334)
#define NV055_COMBINE_FACTOR_BLUE                                  7:0
#define NV055_COMBINE_FACTOR_GREEN                                 15:8
#define NV055_COMBINE_FACTOR_RED                                   23:16
#define NV055_COMBINE_FACTOR_ALPHA                                 31:24
#define NV055_BLEND                                                (0x00000338)
#define NV055_BLEND_MASK_BIT                                       5:0
#define NV055_BLEND_MASK_BIT_LSB                                   (0x00000010)
#define NV055_BLEND_MASK_BIT_MSB                                   (0x00000020)
#define NV055_BLEND_SHADEMODE                                      7:6
#define NV055_BLEND_SHADEMODE_FLAT                                 (0x00000001)
#define NV055_BLEND_SHADEMODE_GOURAUD                              (0x00000002)
#define NV055_BLEND_SHADEMODE_PHONG                                (0x00000003)
#define NV055_BLEND_TEXTUREPERSPECTIVE                             11:8
#define NV055_BLEND_TEXTUREPERSPECTIVE_FALSE                       (0x00000000)
#define NV055_BLEND_TEXTUREPERSPECTIVE_TRUE                        (0x00000001)
#define NV055_BLEND_SPECULARENABLE                                 15:12
#define NV055_BLEND_SPECULARENABLE_FALSE                           (0x00000000)
#define NV055_BLEND_SPECULARENABLE_TRUE                            (0x00000001)
#define NV055_BLEND_FOGENABLE                                      19:16
#define NV055_BLEND_FOGENABLE_FALSE                                (0x00000000)
#define NV055_BLEND_FOGENABLE_TRUE                                 (0x00000001)
#define NV055_BLEND_ALPHABLENDENABLE                               23:20
#define NV055_BLEND_ALPHABLENDENABLE_FALSE                         (0x00000000)
#define NV055_BLEND_ALPHABLENDENABLE_TRUE                          (0x00000001)
#define NV055_BLEND_SRCBLEND                                       27:24
#define NV055_BLEND_SRCBLEND_ZERO                                  (0x00000001)
#define NV055_BLEND_SRCBLEND_ONE                                   (0x00000002)
#define NV055_BLEND_SRCBLEND_SRCCOLOR                              (0x00000003)
#define NV055_BLEND_SRCBLEND_INVSRCCOLOR                           (0x00000004)
#define NV055_BLEND_SRCBLEND_SRCALPHA                              (0x00000005)
#define NV055_BLEND_SRCBLEND_INVSRCALPHA                           (0x00000006)
#define NV055_BLEND_SRCBLEND_DESTALPHA                             (0x00000007)
#define NV055_BLEND_SRCBLEND_INVDESTALPHA                          (0x00000008)
#define NV055_BLEND_SRCBLEND_DESTCOLOR                             (0x00000009)
#define NV055_BLEND_SRCBLEND_INVDESTCOLOR                          (0x0000000A)
#define NV055_BLEND_SRCBLEND_SRCALPHASAT                           (0x0000000B)
#define NV055_BLEND_DESTBLEND                                      31:28
#define NV055_BLEND_DESTBLEND_ZERO                                 (0x00000001)
#define NV055_BLEND_DESTBLEND_ONE                                  (0x00000002)
#define NV055_BLEND_DESTBLEND_SRCCOLOR                             (0x00000003)
#define NV055_BLEND_DESTBLEND_INVSRCCOLOR                          (0x00000004)
#define NV055_BLEND_DESTBLEND_SRCALPHA                             (0x00000005)
#define NV055_BLEND_DESTBLEND_INVSRCALPHA                          (0x00000006)
#define NV055_BLEND_DESTBLEND_DESTALPHA                            (0x00000007)
#define NV055_BLEND_DESTBLEND_INVDESTALPHA                         (0x00000008)
#define NV055_BLEND_DESTBLEND_DESTCOLOR                            (0x00000009)
#define NV055_BLEND_DESTBLEND_INVDESTCOLOR                         (0x0000000A)
#define NV055_BLEND_DESTBLEND_SRCALPHASAT                          (0x0000000B)
#define NV055_CONTROL0                                             (0x0000033C)
#define NV055_CONTROL0_ALPHAREF                                    7:0
#define NV055_CONTROL0_ALPHAFUNC                                   11:8
#define NV055_CONTROL0_ALPHAFUNC_NEVER                             (0x00000001)
#define NV055_CONTROL0_ALPHAFUNC_LESS                              (0x00000002)
#define NV055_CONTROL0_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV055_CONTROL0_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV055_CONTROL0_ALPHAFUNC_GREATER                           (0x00000005)
#define NV055_CONTROL0_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV055_CONTROL0_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV055_CONTROL0_ALPHAFUNC_ALWAYS                            (0x00000008)
#define NV055_CONTROL0_ALPHATESTENABLE                             12:12
#define NV055_CONTROL0_ALPHATESTENABLE_FALSE                       (0x00000000)
#define NV055_CONTROL0_ALPHATESTENABLE_TRUE                        (0x00000001)
#define NV055_CONTROL0_ORIGIN                                      13:13
#define NV055_CONTROL0_ORIGIN_CENTER                               (0x00000000)
#define NV055_CONTROL0_ORIGIN_CORNER                               (0x00000001)
#define NV055_CONTROL0_ZENABLE                                     15:14
#define NV055_CONTROL0_ZENABLE_FALSE                               (0x00000000)
#define NV055_CONTROL0_ZENABLE_TRUE                                (0x00000001)
#define NV055_CONTROL0_ZFUNC                                       19:16
#define NV055_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV055_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV055_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV055_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV055_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV055_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV055_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV055_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV055_CONTROL0_CULLMODE                                    21:20
#define NV055_CONTROL0_CULLMODE_NONE                               (0x00000001)
#define NV055_CONTROL0_CULLMODE_CW                                 (0x00000002)
#define NV055_CONTROL0_CULLMODE_CCW                                (0x00000003)
#define NV055_CONTROL0_DITHERENABLE                                22:22
#define NV055_CONTROL0_DITHERENABLE_FALSE                          (0x00000000)
#define NV055_CONTROL0_DITHERENABLE_TRUE                           (0x00000001)
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE                        23:23
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV055_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV055_CONTROL0_ZWRITEENABLE                                24:24
#define NV055_CONTROL0_ZWRITEENABLE_FALSE                          (0x00000000)
#define NV055_CONTROL0_ZWRITEENABLE_TRUE                           (0x00000001)
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE                        25:25
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE_FALSE                  (0x00000000)
#define NV055_CONTROL0_STENCIL_WRITE_ENABLE_TRUE                   (0x00000001)
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE                          26:26
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV055_CONTROL0_ALPHA_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV055_CONTROL0_RED_WRITE_ENABLE                            27:27
#define NV055_CONTROL0_RED_WRITE_ENABLE_FALSE                      (0x00000000)
#define NV055_CONTROL0_RED_WRITE_ENABLE_TRUE                       (0x00000001)
#define NV055_CONTROL0_GREEN_WRITE_ENABLE                          28:28
#define NV055_CONTROL0_GREEN_WRITE_ENABLE_FALSE                    (0x00000000)
#define NV055_CONTROL0_GREEN_WRITE_ENABLE_TRUE                     (0x00000001)
#define NV055_CONTROL0_BLUE_WRITE_ENABLE                           29:29
#define NV055_CONTROL0_BLUE_WRITE_ENABLE_FALSE                     (0x00000000)
#define NV055_CONTROL0_BLUE_WRITE_ENABLE_TRUE                      (0x00000001)
#define NV055_CONTROL0_Z_FORMAT                                    31:30
#define NV055_CONTROL0_Z_FORMAT_FIXED                              (0x00000001)
#define NV055_CONTROL0_Z_FORMAT_FLOAT                              (0x00000002)
#define NV055_CONTROL1                                             (0x00000340)
#define NV055_CONTROL1_STENCIL_TEST_ENABLE                         3:0
#define NV055_CONTROL1_STENCIL_TEST_ENABLE_FALSE                   (0x00000000)
#define NV055_CONTROL1_STENCIL_TEST_ENABLE_TRUE                    (0x00000001)
#define NV055_CONTROL1_STENCIL_FUNC                                7:4
#define NV055_CONTROL1_STENCIL_FUNC_NEVER                          (0x00000001)
#define NV055_CONTROL1_STENCIL_FUNC_LESS                           (0x00000002)
#define NV055_CONTROL1_STENCIL_FUNC_EQUAL                          (0x00000003)
#define NV055_CONTROL1_STENCIL_FUNC_LESSEQUAL                      (0x00000004)
#define NV055_CONTROL1_STENCIL_FUNC_GREATER                        (0x00000005)
#define NV055_CONTROL1_STENCIL_FUNC_NOTEQUAL                       (0x00000006)
#define NV055_CONTROL1_STENCIL_FUNC_GREATEREQUAL                   (0x00000007)
#define NV055_CONTROL1_STENCIL_FUNC_ALWAYS                         (0x00000008)
#define NV055_CONTROL1_STENCIL_REF                                 15:8
#define NV055_CONTROL1_STENCIL_MASK_READ                           23:16
#define NV055_CONTROL1_STENCIL_MASK_WRITE                          31:24
#define NV055_CONTROL2                                             (0x00000344)
#define NV055_CONTROL2_STENCIL_OP_FAIL                             3:0
#define NV055_CONTROL2_STENCIL_OP_FAIL_KEEP                        (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_FAIL_ZERO                        (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_FAIL_REPLACE                     (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INCRSAT                     (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_FAIL_DECRSAT                     (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INVERT                      (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_FAIL_INCR                        (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_FAIL_DECR                        (0x00000008)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL                            7:4
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_KEEP                       (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_ZERO                       (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_REPLACE                    (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT                    (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT                    (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INVERT                     (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_INCR                       (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_ZFAIL_DECR                       (0x00000008)
#define NV055_CONTROL2_STENCIL_OP_ZPASS                            31:8
#define NV055_CONTROL2_STENCIL_OP_ZPASS_KEEP                       (0x00000001)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_ZERO                       (0x00000002)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_REPLACE                    (0x00000003)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INCRSAT                    (0x00000004)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_DECRSAT                    (0x00000005)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INVERT                     (0x00000006)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_INCR                       (0x00000007)
#define NV055_CONTROL2_STENCIL_OP_ZPASS_DECR                       (0x00000008)
#define NV055_FOG_COLOR                                            (0x00000348)
#define NV055_TLMTVERTEX(i)                                        (0x00000400\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SX(i)                                     (0x00000400\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SY(i)                                     (0x00000404\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SZ(i)                                     (0x00000408\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_RHW(i)                                    (0x0000040C\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_COLOR(i)                                  (0x00000410\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_COLOR_BLUE                                7:0
#define NV055_TLMTVERTEX_COLOR_GREEN                               15:8
#define NV055_TLMTVERTEX_COLOR_RED                                 23:16
#define NV055_TLMTVERTEX_COLOR_ALPHA                               31:24
#define NV055_TLMTVERTEX_SPECULAR(i)                               (0x00000414\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_SPECULAR_BLUE                             7:0
#define NV055_TLMTVERTEX_SPECULAR_GREEN                            15:8
#define NV055_TLMTVERTEX_SPECULAR_RED                              23:16
#define NV055_TLMTVERTEX_SPECULAR_FOG                              31:24
#define NV055_TLMTVERTEX_TU0(i)                                    (0x00000418\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TV0(i)                                    (0x0000041C\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TU1(i)                                    (0x00000420\
                                                                   +(i)*0x0028)
#define NV055_TLMTVERTEX_TV1(i)                                    (0x00000424\
                                                                   +(i)*0x0028)
#define NV055_DRAW_PRIMITIVE(a)                                    (0x00000540\
                                                                   +(a)*0x0004)
#define NV055_DRAW_PRIMITIVE_I0                                    3:0
#define NV055_DRAW_PRIMITIVE_I1                                    7:4
#define NV055_DRAW_PRIMITIVE_I2                                    11:8
#define NV055_DRAW_PRIMITIVE_I3                                    15:12
#define NV055_DRAW_PRIMITIVE_I4                                    19:16
#define NV055_DRAW_PRIMITIVE_I5                                    31:20

typedef V032 Nv056Typedef;


/* class NV04_CONTEXT_COLOR_KEY */
#define  NV04_CONTEXT_COLOR_KEY                                    (0x00000057)
#define  NV4_CONTEXT_COLOR_KEY                                     (0x00000057)
/* NvNotification[] elements */
#define NV057_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV057_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV057_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV057_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV057_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV057_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV057_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV057_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetColorFormat;          /* NV057_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetColor;                /* source color                      0304-0307*/
 V032 Reserved02[0x73e];
} Nv057Typedef, Nv04ContextColorKey;
#define Nv4ContextColorKey                                  Nv04ContextColorKey
#define nv4ContextColorKey                                  nv04ContextColorKey
#define NV057_TYPEDEF                                       nv04ContextColorKey
/* dma method offsets, fields, and values */
#define NV057_SET_OBJECT                                           (0x00000000)
#define NV057_NO_OPERATION                                         (0x00000100)
#define NV057_NOTIFY                                               (0x00000104)
#define NV057_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV057_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV057_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV057_SET_COLOR_FORMAT                                     (0x00000300)
#define NV057_SET_COLOR_FORMAT_LE_A16R5G6B5                        (0x00000001)
#define NV057_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV057_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV057_SET_COLOR                                            (0x00000304)


/* class NV03_CONTEXT_SURFACE_0 */
#define  NV03_CONTEXT_SURFACE_0                                    (0x00000058)
#define  NV3_CONTEXT_SURFACE_0                                     (0x00000058)
/* NvNotification[] elements */
#define NV058_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV058_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV058_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV058_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV058_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV058_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV058_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV058_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV058_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv058Typedef, Nv03ContextSurface0;
#define Nv3ContextSurface0                                  Nv03ContextSurface0
#define nv3ContextSurface0                                  nv03ContextSurface0
#define NV058_TYPEDEF                                       nv03ContextSurface0
/* dma method offsets, fields, and values */
#define NV058_SET_OBJECT                                           (0x00000000)
#define NV058_NO_OPERATION                                         (0x00000100)
#define NV058_NOTIFY                                               (0x00000104)
#define NV058_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV058_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV058_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV058_SET_COLOR_FORMAT                                     (0x00000300)
#define NV058_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV058_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV058_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV058_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV058_SET_IMAGE_PITCH                                      (0x00000308)
#define NV058_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_1 */
#define  NV03_CONTEXT_SURFACE_1                                    (0x00000059)
#define  NV3_CONTEXT_SURFACE_1                                     (0x00000059)
/* NvNotification[] elements */
#define NV059_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV059_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV059_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV059_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV059_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV059_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV059_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV059_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV059_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv059Typedef, Nv03ContextSurface1;
#define Nv3ContextSurface1                                  Nv03ContextSurface1
#define nv3ContextSurface1                                  nv03ContextSurface1
#define NV059_TYPEDEF                                       nv03ContextSurface1
/* dma method offsets, fields, and values */
#define NV059_SET_OBJECT                                           (0x00000000)
#define NV059_NO_OPERATION                                         (0x00000100)
#define NV059_NOTIFY                                               (0x00000104)
#define NV059_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV059_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV059_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV059_SET_COLOR_FORMAT                                     (0x00000300)
#define NV059_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV059_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV059_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV059_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV059_SET_IMAGE_PITCH                                      (0x00000308)
#define NV059_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_2 */
#define  NV03_CONTEXT_SURFACE_2                                    (0x0000005A)
#define  NV3_CONTEXT_SURFACE_2                                     (0x0000005A)
/* NvNotification[] elements */
#define NV05A_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05A_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05A_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05A_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05A_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05A_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV05A_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv05aTypedef, Nv03ContextSurface2;
#define Nv3ContextSurface2                               Nv03ContextSurface2
#define nv3ContextSurface2                               nv03ContextSurface2
#define NV05A_TYPEDEF                                    nv03ContextSurface2
/* dma method offsets, fields, and values */
#define NV05A_SET_OBJECT                                           (0x00000000)
#define NV05A_NO_OPERATION                                         (0x00000100)
#define NV05A_NOTIFY                                               (0x00000104)
#define NV05A_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05A_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05A_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05A_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05A_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05A_SET_COLOR_FORMAT_DUMMY_0                             (0x01010000)
#define NV05A_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5_1              (0x01010001)
#define NV05A_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5_2              (0x01000000)
#define NV05A_SET_COLOR_FORMAT_DUMMY_3                             (0x00000001)
#define NV05A_SET_IMAGE_PITCH                                      (0x00000308)
#define NV05A_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_3 */
#define  NV03_CONTEXT_SURFACE_3                                    (0x0000005B)
#define  NV3_CONTEXT_SURFACE_3                                     (0x0000005B)
/* NvNotification[] elements */
#define NV05B_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05B_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05B_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05B_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05B_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_IN_MEMORY        0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV05B_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv05bTypedef, Nv03ContextSurface3;
#define Nv3ContextSurface3                                  Nv03ContextSurface3
#define nv3ContextSurface3                                  nv03ContextSurface3
#define NV05B_TYPEDEF                                       nv03ContextSurface3
/* dma method offsets, fields, and values */
#define NV05B_SET_OBJECT                                           (0x00000000)
#define NV05B_NO_OPERATION                                         (0x00000100)
#define NV05B_NOTIFY                                               (0x00000104)
#define NV05B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05B_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05B_SET_COLOR_FORMAT_DUMMY_0                             (0x01010000)
#define NV05B_SET_COLOR_FORMAT_DUMMY_1                             (0x01010001)
#define NV05B_SET_COLOR_FORMAT_DUMMY_2                             (0x01000000)
#define NV05B_SET_COLOR_FORMAT_DUMMY_3                             (0x00000001)
#define NV05B_SET_IMAGE_PITCH                                      (0x00000308)
#define NV05B_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV04_RENDER_SOLID_LIN */
#define  NV04_RENDER_SOLID_LIN                                     (0x0000005C)
#define  NV4_RENDER_SOLID_LIN                                      (0x0000005C)
/* NvNotification[] elements */
#define NV05C_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05C_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05C_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05C_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05C_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05C_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV05C_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV05C_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point0;                 /* y_x S16_S16 in pixels             0400-0403*/
  V032 point1;                 /* y_x S16_S16 in pixels             0404-0407*/
 } Lin[16];                    /* end of aliased methods in array       -047f*/
 struct {                      /* start of aliased methods in array 0480-    */
  S032 point0X;                /* in pixels, 0 at left                 0-   3*/
  S032 point0Y;                /* in pixels, 0 at top                  4-   7*/
  S032 point1X;                /* in pixels, 0 at left                 8-   b*/
  S032 point1Y;                /* in pixels, 0 at top                  c-   f*/
 } Lin32[8];                   /* end of aliased methods in array       -04ff*/
 V032 PolyLin[32];             /* y_x S16_S16 in pixels             0500-057f*/
 struct {                      /* start of method in array          0580-    */
  S032 x;                      /* in pixels, 0 at left                 0-   3*/
  S032 y;                      /* in pixels, 0 at top                  4-   7*/
 } PolyLin32[16];              /* end of aliased methods in array       -05ff*/
 struct {                      /* start of aliased methods in array 0600-    */
  V032 color;                  /* source color                         0-   3*/
  V032 point;                  /* y_x S16_S16 in pixels                4-   7*/
 } ColorPolyLin[16];           /* end of aliased methods in array       -067f*/
 V032 Reserved03[0x660];
} Nv05cTypedef, Nv04RenderSolidLin;
#define Nv4RenderSolidLin                                    Nv04RenderSolidLin
#define nv4RenderSolidLin                                    nv04RenderSolidLin
#define NV05C_TYPEDEF                                        nv04RenderSolidLin
/* dma method offsets, fields, and values */
#define NV05C_SET_OBJECT                                           (0x00000000)
#define NV05C_NO_OPERATION                                         (0x00000100)
#define NV05C_NOTIFY                                               (0x00000104)
#define NV05C_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05C_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05C_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05C_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05C_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05C_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05C_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05C_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05C_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05C_SET_OPERATION                                        (0x000002FC)
#define NV05C_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05C_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05C_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05C_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05C_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05C_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05C_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05C_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05C_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05C_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05C_COLOR                                                (0x00000304)
#define NV05C_LIN(a)                                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT0                                           (0x00000400\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT0_X                                         15:0
#define NV05C_LIN_POINT0_Y                                         31:16
#define NV05C_LIN_POINT1                                           (0x00000404\
                                                                   +(a)*0x0008)
#define NV05C_LIN_POINT1_X                                         15:0
#define NV05C_LIN_POINT1_Y                                         31:16
#define NV05C_LIN32(a)                                             (0x00000480\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT0_X                                       (0x00000480\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT0_Y                                       (0x00000484\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT1_X                                       (0x00000488\
                                                                   +(a)*0x0010)
#define NV05C_LIN32_POINT1_Y                                       (0x0000048C\
                                                                   +(a)*0x0010)
#define NV05C_POLY_LIN(a)                                          (0x00000500\
                                                                   +(a)*0x0004)
#define NV05C_POLY_LIN_X                                           15:0
#define NV05C_POLY_LIN_Y                                           31:16
#define NV05C_POLY_LIN32(a)                                        (0x00000580\
                                                                   +(a)*0x0008)
#define NV05C_POLY_LIN32_X                                         (0x00000580\
                                                                   +(a)*0x0008)
#define NV05C_POLY_LIN32_Y                                         (0x00000584\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN(a)                                    (0x00000600\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_COLOR                                 (0x00000600\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_POINT                                 (0x00000604\
                                                                   +(a)*0x0008)
#define NV05C_COLOR_POLY_LIN_POINT_X                               15:0
#define NV05C_COLOR_POLY_LIN_POINT_Y                               31:16


/* class NV04_RENDER_SOLID_TRIANGLE */
#define  NV04_RENDER_SOLID_TRIANGLE                                (0x0000005D)
#define  NV4_RENDER_SOLID_TRIANGLE                                 (0x0000005D)
/* NvNotification[] elements */
#define NV05D_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05D_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05D_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05D_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05D_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05D_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05D_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05D_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV05D_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV05D_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x002];
 V032 TrianglePoint0;          /* y_x S16_S16 in pixels             0310-0313*/
 V032 TrianglePoint1;          /* y_x S16_S16 in pixels             0314-0317*/
 V032 TrianglePoint2;          /* y_x S16_S16 in pixels             0318-031b*/
 V032 Reserved03[0x001];
 S032 Triangle32Point0X;       /* in pixels, 0 at left              0320-0323*/
 S032 Triangle32Point0Y;       /* in pixels, 0 at top               0324-0327*/
 S032 Triangle32Point1X;       /* in pixels, 0 at left              0328-032b*/
 S032 Triangle32Point1Y;       /* in pixels, 0 at top               032c-032f*/
 S032 Triangle32Point2X;       /* in pixels, 0 at left              0330-0333*/
 S032 Triangle32Point2Y;       /* in pixels, 0 at top               0334-0337*/
 V032 Reserved04[0x032];
 V032 Trimesh[32];             /* y_x S16_S16 in pixels             0400-047f*/
 struct {                      /* start of aliased methods in array 0480-    */
  S032 x;                      /* in pixels, 0 at left                 0-   3*/
  S032 y;                      /* in pixels, 0 at top                  4-   7*/
 } Trimesh32[16];              /* end of aliased methods in array       -04ff*/
 struct {                      /* start of aliased methods in array 0500-    */
  V032 color;                  /* source color                         0-   3*/
  V032 point0;                 /* y_x S16_S16 in pixels                4-   7*/
  V032 point1;                 /* y_x S16_S16 in pixels                8-   b*/
  V032 point2;                 /* y_x S16_S16 in pixels                c-   f*/
 } ColorTriangle[8];           /* end of aliased methods in array       -057f*/
 struct {                      /* start of aliased methods in array 0580-    */
  V032 color;                  /* source color                         0-   3*/
  V032 point;                  /* y_x S16_S16 in pixels                4-   7*/
 } ColorTrimesh[16];           /* end of aliased methods in array       -05ff*/
 V032 Reserved05[0x680];
} Nv05dTypedef, Nv04RenderSolidTriangle;
#define Nv4RenderSolidTriangle                          Nv04RenderSolidTriangle
#define nv4RenderSolidTriangle                          nv04RenderSolidTriangle
#define NV05D_TYPEDEF                                   nv04RenderSolidTriangle
/* dma method offsets, fields, and values */
#define NV05D_SET_OBJECT                                           (0x00000000)
#define NV05D_NO_OPERATION                                         (0x00000100)
#define NV05D_NOTIFY                                               (0x00000104)
#define NV05D_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05D_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05D_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05D_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05D_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05D_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05D_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05D_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05D_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05D_SET_OPERATION                                        (0x000002FC)
#define NV05D_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05D_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05D_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05D_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05D_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05D_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05D_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05D_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05D_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05D_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05D_COLOR                                                (0x00000304)
#define NV05D_TRIANGLE                                             (0x00000310)
#define NV05D_TRIANGLE_POINT0                                      (0x00000310)
#define NV05D_TRIANGLE_POINT0_X                                    15:0
#define NV05D_TRIANGLE_POINT0_Y                                    31:16
#define NV05D_TRIANGLE_POINT1                                      (0x00000314)
#define NV05D_TRIANGLE_POINT1_X                                    15:0
#define NV05D_TRIANGLE_POINT1_Y                                    31:16
#define NV05D_TRIANGLE_POINT2                                      (0x00000318)
#define NV05D_TRIANGLE_POINT2_X                                    15:0
#define NV05D_TRIANGLE_POINT2_Y                                    31:16
#define NV05D_TRIANGLE32_POINT0_X                                  (0x00000320)
#define NV05D_TRIANGLE32_POINT0_Y                                  (0x00000324)
#define NV05D_TRIANGLE32_POINT1_X                                  (0x00000328)
#define NV05D_TRIANGLE32_POINT1_Y                                  (0x0000032C)
#define NV05D_TRIANGLE32_POINT2_X                                  (0x00000330)
#define NV05D_TRIANGLE32_POINT2_Y                                  (0x00000334)
#define NV05D_TRIMESH(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
#define NV05D_TRIMESH_X                                            15:0
#define NV05D_TRIMESH_Y                                            31:16
#define NV05D_TRIMESH32(a)                                         (0x00000480\
                                                                   +(a)*0x0008)
#define NV05D_TRIMESH32_X(a)                                       (0x00000480\
                                                                   +(a)*0x0008)
#define NV05D_TRIMESH32_Y(a)                                       (0x00000484\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIANGLE(a)                                    (0x00000500\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_COLOR(a)                              (0x00000500\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT0(a)                             (0x00000504\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT0_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT0_Y                              31:16
#define NV05D_COLOR_TRIANGLE_POINT1(a)                             (0x00000508\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT1_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT1_Y                              31:16
#define NV05D_COLOR_TRIANGLE_POINT2(a)                             (0x0000050C\
                                                                   +(a)*0x0010)
#define NV05D_COLOR_TRIANGLE_POINT2_X                              15:0
#define NV05D_COLOR_TRIANGLE_POINT2_Y                              31:16
#define NV05D_COLOR_TRIMESH(a)                                     (0x00000580\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_COLOR(a)                               (0x00000580\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_POINT(a)                               (0x00000584\
                                                                   +(a)*0x0008)
#define NV05D_COLOR_TRIMESH_POINT_X                                15:0
#define NV05D_COLOR_TRIMESH_POINT_Y                                31:16


/* class NV04_RENDER_SOLID_RECTANGLE */
#define  NV04_RENDER_SOLID_RECTANGLE                               (0x0000005E)
#define  NV4_RENDER_SOLID_RECTANGLE                                (0x0000005E)
/* NvNotification[] elements */
#define NV05E_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05E_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05E_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05E_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05E_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV05E_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV05E_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* y_x S16_S16                          0-   3*/
  V032 size;                   /* height_width U16_U16                 4-   7*/
 } Rectangle[16];              /* end of aliased methods in array       -047f*/
 V032 Reserved03[0x6e0];
} Nv05eTypedef, Nv04RenderSolidRectangle;
#define Nv4RenderSolidRectangle                        Nv04RenderSolidRectangle
#define nv4RenderSolidRectangle                        nv04RenderSolidRectangle
#define NV05E_TYPEDEF                                  nv04RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV05E_SET_OBJECT                                           (0x00000000)
#define NV05E_NO_OPERATION                                         (0x00000100)
#define NV05E_NOTIFY                                               (0x00000104)
#define NV05E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05E_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV05E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV05E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV05E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV05E_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV05E_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV05E_SET_OPERATION                                        (0x000002FC)
#define NV05E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05E_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05E_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05E_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05E_SET_COLOR_FORMAT_LE_X16R5G6B5                        (0x00000001)
#define NV05E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV05E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV05E_COLOR                                                (0x00000304)
#define NV05E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_POINT_X                                    15:0
#define NV05E_RECTANGLE_POINT_Y                                    31:16
#define NV05E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV05E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV05E_RECTANGLE_SIZE_HEIGHT                                31:16


/* class NV04_IMAGE_BLIT */
#define  NV04_IMAGE_BLIT                                           (0x0000005F)
#define  NV4_IMAGE_BLIT                                            (0x0000005F)
/* NvNotification[] elements */
#define NV05F_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV05F_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV05F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV05F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV05F_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV05F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV05F_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05F_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY            0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              018c-018f*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0190-0193*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0194-0197*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0198-019b*/
 V032 SetContextSurfaces;      /* NV04_CONTEXT_SURFACES_2D          019c-019f*/
 V032 Reserved01[0x057];
 V032 SetOperation;            /* NV05F_SET_OPERATION_*             02fc-02ff*/
 V032 ControlPointIn;          /* y_x U16_U16, pixels, top left src 0300-0303*/
 V032 ControlPointOut;         /* y_x S16_S16, pixels, top left dst 0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels    0308-030b*/
 V032 Reserved02[0x73d];
} Nv05fTypedef, Nv04ImageBlit;
#define Nv4ImageBlit                                              Nv04ImageBlit
#define nv4ImageBlit                                              nv04ImageBlit
#define NV05F_TYPEDEF                                             nv04ImageBlit
/* dma method offsets, fields, and values */
#define NV05F_SET_OBJECT                                           (0x00000000)
#define NV05F_NO_OPERATION                                         (0x00000100)
#define NV05F_NOTIFY                                               (0x00000104)
#define NV05F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05F_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV05F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV05F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV05F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV05F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV05F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV05F_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV05F_SET_CONTEXT_SURFACES                                 (0x0000019C)
#define NV05F_SET_OPERATION                                        (0x000002FC)
#define NV05F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV05F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV05F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV05F_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV05F_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV05F_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV05F_CONTROL_POINT_IN                                     (0x00000300)
#define NV05F_CONTROL_POINT_IN_X                                   15:0
#define NV05F_CONTROL_POINT_IN_Y                                   31:16
#define NV05F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV05F_CONTROL_POINT_OUT_X                                  15:0
#define NV05F_CONTROL_POINT_OUT_Y                                  31:16
#define NV05F_SIZE                                                 (0x00000308)
#define NV05F_SIZE_WIDTH                                           15:0
#define NV05F_SIZE_HEIGHT                                          31:16


/* class NV04_INDEXED_IMAGE_FROM_CPU */
#define  NV04_INDEXED_IMAGE_FROM_CPU                               (0x00000060)
#define  NV4_INDEXED_IMAGE_FROM_CPU                                (0x00000060)
/* NvNotification[] elements */
#define NV060_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV060_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV060_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV060_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV060_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV060_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV060_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV060_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaLut;        /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY            0188-018b*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        018c-018f*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0190-0193*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0194-0197*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0198-019b*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 019c-019f*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLED 01a0-01a3*/
 V032 Reserved01[0x090];
 V032 SetOperation;            /* NV060_SET_OPERATION_*             03e4-03e7*/
 V032 SetColorFormat;          /* NV060_SET_COLOR_FORMAT_*          03e8-03eb*/
 V032 IndexFormat;             /* NV060_INDEX_FORMAT_*              03ec-03ef*/
 U032 LutOffset;               /* offset in bytes                   03f0-03f3*/
 V032 Point;                   /* y_x S16_S16 in pixels             03f4-03f7*/
 V032 SizeOut;                 /* height_width U16_U16, pixels, dst 03f8-03fb*/
 V032 SizeIn;                  /* height_width U16_U16, pixels, src 03fc-03ff*/
 V032 Indices[1792];           /* source indices (packed texels)    0400-1fff*/
} Nv060Typedef, Nv04IndexedImageFromCpu;
#define Nv4IndexedImageFromCpu                          Nv04IndexedImageFromCpu
#define nv4IndexedImageFromCpu                          nv04IndexedImageFromCpu
#define NV060_TYPEDEF                                   nv04IndexedImageFromCpu
/* dma method offsets, fields, and values */
#define NV060_SET_OBJECT                                           (0x00000000)
#define NV060_NO_OPERATION                                         (0x00000100)
#define NV060_NOTIFY                                               (0x00000104)
#define NV060_NOTIFY_WRITE_ONLY                                   (0x00000000)
#define NV060_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV060_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV060_SET_CONTEXT_DMA_LUT                                  (0x00000184)
#define NV060_SET_CONTEXT_COLOR_KEY                                (0x00000188)
#define NV060_SET_CONTEXT_CLIP_RECTANGLE                           (0x0000018C)
#define NV060_SET_CONTEXT_PATTERN                                  (0x00000190)
#define NV060_SET_CONTEXT_ROP                                      (0x00000194)
#define NV060_SET_CONTEXT_BETA1                                    (0x00000198)
#define NV060_SET_CONTEXT_BETA4                                    (0x0000019C)
#define NV060_SET_CONTEXT_SURFACE                                  (0x000001A0)
#define NV060_SET_OPERATION                                        (0x000003E4)
#define NV060_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV060_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV060_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV060_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV060_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV060_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV060_INDEX_FORMAT                                         (0x000003EC)
#define NV060_INDEX_FORMAT_LE_I8                                   (0x00000000)
#define NV060_INDEX_FORMAT_SVGA65_I4                               (0x00000001)
#define NV060_SET_COLOR_FORMAT                                     (0x000003E8)
#define NV060_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV060_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV060_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV060_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV060_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV060_LUT_OFFSET                                           (0x000003F0)
#define NV060_POINT                                                (0x000003F4)
#define NV060_POINT_X                                              15:0
#define NV060_POINT_Y                                              31:16
#define NV060_SIZE_OUT                                             (0x000003F8)
#define NV060_SIZE_OUT_WIDTH                                       15:0
#define NV060_SIZE_OUT_HEIGHT                                      31:16
#define NV060_SIZE_IN                                              (0x000003FC)
#define NV060_SIZE_IN_WIDTH                                        15:0
#define NV060_SIZE_IN_HEIGHT                                       31:16
#define NV060_INDICES(a)                                           (0x00000400\
                                                                   +(a)*0x0004)


/* class NV04_IMAGE_FROM_CPU */
#define  NV04_IMAGE_FROM_CPU                                       (0x00000061)
#define  NV4_IMAGE_FROM_CPU                                        (0x00000061)
/* NvNotification[] elements */
#define NV061_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV061_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV061_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV061_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV061_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV061_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV061_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV061_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY            0184-0187*/
 V032 SetContextClipRectangle; /* NV01_IMAGE_BLACK_RECTANGLE        0188-018b*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              018c-018f*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  0190-0193*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0194-0197*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0198-019b*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          019c-019f*/
 V032 Reserved01[0x057];
 V032 SetOperation;            /* NV061_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV061_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels             0304-0307*/
 V032 SizeOut;                 /* height_width U16_U16, pixels, dst 0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16, pixels, src 030c-030f*/
 V032 Reserved02[0x03c];
 V032 Color[1792];             /* source colors (packed texels)     0400-1fff*/
} Nv061Typedef, Nv04ImageFromCpu;
#define Nv4ImageFromCpu                                        Nv04ImageFromCpu
#define nv4ImageFromCpu                                        nv04ImageFromCpu
#define NV061_TYPEDEF                                          nv04ImageFromCpu
/* dma method offsets, fields, and values */
#define NV061_SET_OBJECT                                           (0x00000000)
#define NV061_NO_OPERATION                                         (0x00000100)
#define NV061_NOTIFY                                               (0x00000104)
#define NV061_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV061_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV061_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV061_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV061_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV061_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV061_SET_CONTEXT_ROP                                      (0x00000190)
#define NV061_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV061_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV061_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV061_SET_OPERATION                                        (0x000002FC)
#define NV061_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV061_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV061_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV061_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV061_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV061_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV061_SET_COLOR_FORMAT                                     (0x00000300)
#define NV061_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV061_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV061_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV061_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV061_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV061_POINT                                                (0x00000304)
#define NV061_POINT_X                                              15:0
#define NV061_POINT_Y                                              31:16
#define NV061_SIZE_OUT                                             (0x00000308)
#define NV061_SIZE_OUT_WIDTH                                       15:0
#define NV061_SIZE_OUT_HEIGHT                                      31:16
#define NV061_SIZE_IN                                              (0x0000030C)
#define NV061_SIZE_IN_WIDTH                                        15:0
#define NV061_SIZE_IN_HEIGHT                                       31:16
#define NV061_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)

typedef V032 Nv062Typedef;


/* class NV05_SCALED_IMAGE_FROM_MEMORY */
#define  NV05_SCALED_IMAGE_FROM_MEMORY                             (0x00000063)
/* NvNotification[] elements */
#define NV063_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV063_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV063_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV063_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV063_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV063_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV063_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV063_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaImage;      /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 0198-019b*/
 NvV32 Reserved01[0x059];
 NvV32 SetColorFormat;          /* NV063_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SetOperation;            /* NV063_SET_OPERATION_*            0304-0307*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0308-030b*/
 NvV32 ClipSize;                /* height_width U16_U16             030c-030f*/
 NvV32 ImageOutPoint;           /* y_x S16_S16                      0310-0313*/
 NvV32 ImageOutSize;            /* height_width U16_U16             0314-0317*/
 NvV32 DsDx;                    /* S12d20 ds/dx                     0318-031b*/
 NvV32 DtDy;                    /* S12d20 dt/dy                     031c-031f*/
 NvV32 SetColorConversion;      /* NV064_SET_COLOR_CONVERSION_*     0320-0323*/
 NvV32 Reserved02[0x037];
 NvV32 ImageInSize;             /* height_width U16_U16             0400-0403*/
 NvV32 ImageInFormat;           /* interpolator_origin_pitch        0404-0407*/
 NvU32 ImageInOffset;           /* bytes                            0408-040b*/
 NvV32 ImageInPoint;            /* v_u U12d4_U12d4                  040c-040f*/
 NvV32 Reserved03[0x6fc];
} Nv063Typedef, Nv05ScaledImageFromMemory;
#define NV063_TYPEDEF                                 nv05ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV063_SET_OBJECT                                           (0x00000000)
#define NV063_NO_OPERATION                                         (0x00000100)
#define NV063_NOTIFY                                               (0x00000104)
#define NV063_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV063_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV063_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV063_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV063_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV063_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV063_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV063_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV063_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV063_SET_COLOR_FORMAT                                     (0x00000300)
#define NV063_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV063_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV063_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV063_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV063_SET_COLOR_FORMAT_LE_CR8YB8CB8YA8                     (0x00000005)
#define NV063_SET_COLOR_FORMAT_LE_YB8CR8YA8CB8                     (0x00000006)
#define NV063_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV063_SET_OPERATION                                        (0x00000304)
#define NV063_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV063_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV063_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV063_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV063_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV063_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV063_CLIP_POINT                                           (0x00000308)
#define NV063_CLIP_POINT_X                                         15:0
#define NV063_CLIP_POINT_Y                                         31:16
#define NV063_CLIP_SIZE                                            (0x0000030C)
#define NV063_CLIP_SIZE_WIDTH                                      15:0
#define NV063_CLIP_SIZE_HEIGHT                                     31:16
#define NV063_IMAGE_OUT_POINT                                      (0x00000310)
#define NV063_IMAGE_OUT_POINT_X                                    15:0
#define NV063_IMAGE_OUT_POINT_Y                                    31:16
#define NV063_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV063_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV063_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV063_DS_DX                                                (0x00000318)
#define NV063_DT_DY                                                (0x0000031C)
#define NV063_SET_COLOR_CONVERSION                                 (0x00000320)
#define NV063_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV063_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV063_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV063_IMAGE_IN_SIZE                                        (0x00000400)
#define NV063_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV063_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV063_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV063_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV063_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV063_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV063_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV063_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV063_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV063_IMAGE_IN                                             (0x0000040C)
#define NV063_IMAGE_IN_POINT_U                                     15:0
#define NV063_IMAGE_IN_POINT_V                                     31:16

/* class NV05_INDEXED_IMAGE_FROM_CPU */
#define  NV05_INDEXED_IMAGE_FROM_CPU                               (0x00000064)
#define NV064_NOTIFIERS_NOTIFY                                     (0)
#define NV064_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV064_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV064_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV064_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV064_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV064_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV064_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextDmaLut;        /* NV01_CONTEXT_DMA                 0184-0187*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0188-018b*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      018c-018f*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0190-0193*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0194-0197*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                019c-019f*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLE 01a0-01a3*/
 NvV32 Reserved01[0x08f];
 NvV32 SetColorConversion;      /* NV064_SET_COLOR_CONVERSION_*     03e0-03e3*/
 NvV32 SetOperation;            /* NV064_SET_OPERATION_*            03e4-03e7*/
 NvV32 SetColorFormat;          /* NV064_SET_COLOR_FORMAT_*         03e8-03eb*/
 NvV32 IndexFormat;             /* NV064_INDEX_FORMAT_*             03ec-03ef*/
 NvU32 LutOffset;               /* offset in bytes                  03f0-03f3*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            03f4-03f7*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     03f8-03fb*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     03fc-03ff*/
 NvV32 Indices[1792];           /* source indices (packed texels)   0400-1fff*/
} Nv064Typedef, Nv05IndexedImageFromCpu;
#define NV064_TYPEDEF                                   nv05IndexedImageFromCpu
/* dma method offsets, fields, and values */
#define NV064_NO_OPERATION                                         (0x00000100)
#define NV064_NOTIFY                                               (0x00000104)
#define NV064_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV064_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV064_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV064_SET_CONTEXT_DMA_LUT                                  (0x00000184)
#define NV064_SET_CONTEXT_COLOR_KEY                                (0x00000188)
#define NV064_SET_CONTEXT_CLIP_RECTANGLE                           (0x0000018C)
#define NV064_SET_CONTEXT_PATTERN                                  (0x00000190)
#define NV064_SET_CONTEXT_ROP                                      (0x00000194)
#define NV064_SET_CONTEXT_BETA1                                    (0x00000198)
#define NV064_SET_CONTEXT_BETA4                                    (0x0000019C)
#define NV064_SET_CONTEXT_SURFACE                                  (0x000001A0)
#define NV064_SET_COLOR_CONVERSION                                 (0x000003E0)
#define NV064_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV064_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV064_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV064_SET_OPERATION                                        (0x000003E4)
#define NV064_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV064_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV064_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV064_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV064_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV064_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV064_SET_COLOR_FORMAT                                     (0x000003E8)
#define NV064_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV064_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV064_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV064_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV064_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV064_INDEX_FORMAT                                         (0x000003EC)
#define NV064_INDEX_FORMAT_LE_I8                                   (0x00000000)
#define NV064_INDEX_FORMAT_SVGA65_I4                               (0x00000001)
#define NV064_LUT_OFFSET                                           (0x000003F0)
#define NV064_POINT                                                (0x000003F4)
#define NV064_POINT_X                                              15:0
#define NV064_POINT_Y                                              31:16
#define NV064_SIZE_OUT                                             (0x000003F8)
#define NV064_SIZE_OUT_WIDTH                                       15:0
#define NV064_SIZE_OUT_HEIGHT                                      31:16
#define NV064_SIZE_IN                                              (0x000003FC)
#define NV064_SIZE_IN_WIDTH                                        15:0
#define NV064_SIZE_IN_HEIGHT                                       31:16
#define NV064_INDICES(a)                                           (0x00000400\
                                                                   +(a)*0x0004)
/* class NV05_IMAGE_FROM_CPU */
#define  NV05_IMAGE_FROM_CPU                                       (0x00000065)
#define NV065_NOTIFIERS_NOTIFY                                     (0)
#define NV065_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV065_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV065_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV065_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV065_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV065_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV065_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextClipRectangle; /* NV01_CONTEXT_CLIP_RECTANGLE      0188-018b*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             018c-018f*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 0190-0193*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0198-019b*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         019c-019f*/
 NvV32 Reserved01[0x056];
 NvV32 SetColorConversion;      /* NV065_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV065_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV065_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 Point;                   /* y_x S16_S16 in pixels            0304-0307*/
 NvV32 SizeOut;                 /* height_width U16_U16, pixels     0308-030b*/
 NvV32 SizeIn;                  /* height_width U16_U16, pixels     030c-030f*/
 NvV32 Reserved02[0x03c];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv065Typedef, Nv05ImageFromCpu;
#define NV065_TYPEDEF                                          nv05ImageFromCpu
/* dma method offsets, fields, and values */
#define NV065_NO_OPERATION                                         (0x00000100)
#define NV065_NOTIFY                                               (0x00000104)
#define NV065_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV065_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV065_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV065_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV065_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV065_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV065_SET_CONTEXT_ROP                                      (0x00000190)
#define NV065_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV065_SET_CONTEXT_BETA4                                    (0x00000198)
#define NV065_SET_CONTEXT_SURFACE                                  (0x0000019C)
#define NV065_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV065_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV065_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV065_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV065_SET_OPERATION                                        (0x000002FC)
#define NV065_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV065_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV065_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV065_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV065_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV065_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV065_SET_COLOR_FORMAT                                     (0x00000300)
#define NV065_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV065_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV065_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV065_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV065_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV065_POINT                                                (0x00000304)
#define NV065_POINT_X                                              15:0
#define NV065_POINT_Y                                              31:16
#define NV065_SIZE_OUT                                             (0x00000308)
#define NV065_SIZE_OUT_WIDTH                                       15:0
#define NV065_SIZE_OUT_HEIGHT                                      31:16
#define NV065_SIZE_IN                                              (0x0000030C)
#define NV065_SIZE_IN_WIDTH                                        15:0
#define NV065_SIZE_IN_HEIGHT                                       31:16
#define NV065_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)
 /* class NV05_STRETCHED_IMAGE_FROM_CPU */
#define  NV05_STRETCHED_IMAGE_FROM_CPU                             (0x00000066)
#define NV066_NOTIFIERS_NOTIFY                                     (0)
#define NV066_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV066_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV066_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV066_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV066_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV066_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)

/* pio method data structure */
typedef volatile struct {
 NvV32 NoOperation;             /* ignored                          0100-0103*/
 NvV32 Notify;                  /* NV066_NOTIFY_*                   0104-0107*/
 NvV32 Reserved00[0x01e];
 NvV32 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA                 0180-0183*/
 NvV32 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY           0184-0187*/
 NvV32 SetContextPattern;       /* NV04_CONTEXT_PATTERN             0188-018b*/
 NvV32 SetContextRop;           /* NV03_CONTEXT_ROP                 018c-018f*/
 NvV32 SetContextBeta1;         /* NV01_CONTEXT_BETA                0190-0193*/
 NvV32 SetContextBeta4;         /* NV04_CONTEXT_BETA                0194-0197*/
 NvV32 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D         0198-019b*/
 NvV32 Reserved01[0x057];
 NvV32 SetColorConversion;      /* NV066_SET_COLOR_CONVERSION_*     02f8-02fb*/
 NvV32 SetOperation;            /* NV066_SET_OPERATION_*            02fc-02ff*/
 NvV32 SetColorFormat;          /* NV066_SET_COLOR_FORMAT_*         0300-0303*/
 NvV32 SizeIn;                  /* height_width U16_U16 in texels   0304-0307*/
 NvV32 DxDs;                    /* S12d20 dx/ds                     0308-030b*/
 NvV32 DyDt;                    /* S12d20 dy/dt                     030c-030f*/
 NvV32 ClipPoint;               /* y_x S16_S16                      0310-0313*/
 NvV32 ClipSize;                /* height_width U16_U16             0314-0317*/
 NvV32 Point12d4;               /* y_x S12d4_S12d4 in pixels        0318-031b*/
 NvV32 Reserved02[0x039];
 NvV32 Color[1792];             /* source colors (packed texels)    0400-1fff*/
} Nv066Typedef, Nv05StretchedImageFromCpu;
#define NV066_TYPEDEF                                 nv05StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV066_NO_OPERATION                                         (0x00000100)
#define NV066_NOTIFY                                               (0x00000104)
#define NV066_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV066_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV066_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV066_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV066_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV066_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV066_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV066_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV066_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV066_SET_COLOR_CONVERSION                                 (0x000002F8)
#define NV066_SET_COLOR_CONVERSION_DITHER                          (0x00000000)
#define NV066_SET_COLOR_CONVERSION_TRUNCATE                        (0x00000001)
#define NV066_SET_COLOR_CONVERSION_SUBTRACT_TRUNCATE               (0x00000002)
#define NV066_SET_OPERATION                                        (0x000002FC)
#define NV066_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV066_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV066_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV066_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV066_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV066_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV066_SET_COLOR_FORMAT                                     (0x00000300)
#define NV066_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV066_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV066_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV066_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV066_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV066_SIZE_IN                                              (0x00000304)
#define NV066_SIZE_IN_WIDTH                                        15:0
#define NV066_SIZE_IN_HEIGHT                                       31:16
#define NV066_DX_DS                                                (0x00000308)
#define NV066_DY_DT                                                (0x0000030C)
#define NV066_CLIP_POINT                                           (0x00000310)
#define NV066_CLIP_POINT_X                                         15:0
#define NV066_CLIP_POINT_Y                                         31:16
#define NV066_CLIP_SIZE                                            (0x00000314)
#define NV066_CLIP_SIZE_WIDTH                                      15:0
#define NV066_CLIP_SIZE_HEIGHT                                     31:16
#define NV066_POINT_12D4                                           (0x00000318)
#define NV066_POINT_12D4_X                                         15:0
#define NV066_POINT_12D4_Y                                         31:16
#define NV066_COLOR(a)                                             (0x00000400\


typedef V032 Nv067Typedef;

typedef V032 Nv06dTypedef;

typedef V032 Nv06eTypedef;

typedef V032 Nv06fTypedef;

typedef V032 Nv070Typedef;

typedef V032 Nv071Typedef;


/* class NV04_CONTEXT_BETA */
#define  NV04_CONTEXT_BETA                                         (0x00000072)
#define  NV4_CONTEXT_BETA                                          (0x00000072)
/* NvNotification[] elements */
#define NV072_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV072_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV072_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV072_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV072_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV072_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV072_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV072_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetBetaFactor;           /* A8R8G8B8 beta values              0300-0303*/
 V032 Reserved02[0x73f];
} Nv072Typedef, Nv04ContextBeta;
#define Nv4ContextBeta                                          Nv04ContextBeta
#define nv4ContextBeta                                          nv04ContextBeta
#define NV072_TYPEDEF                                           nv04ContextBeta
/* dma method offsets, fields, and values */
#define NV072_SET_OBJECT                                           (0x00000000)
#define NV072_NO_OPERATION                                         (0x00000100)
#define NV072_NOTIFY                                               (0x00000104)
#define NV072_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV072_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV072_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV072_SET_BETA_FACTOR                                      (0x00000300)
#define NV072_SET_BETA_FACTOR_BLUE                                 7:0
#define NV072_SET_BETA_FACTOR_GREEN                                15:8
#define NV072_SET_BETA_FACTOR_RED                                  23:16
#define NV072_SET_BETA_FACTOR_ALPHA                                31:24

typedef V032 Nv073Typedef;

typedef V032 Nv074Typedef;

typedef V032 Nv075Typedef;


/* class NV04_STRETCHED_IMAGE_FROM_CPU */
#define  NV04_STRETCHED_IMAGE_FROM_CPU                             (0x00000076)
#define  NV4_STRETCHED_IMAGE_FROM_CPU                              (0x00000076)
/* NvNotification[] elements */
#define NV076_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV076_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV076_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV076_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV076_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV076_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV076_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV076_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextColorKey;      /* NV04_CONTEXT_COLOR_KEY            0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D          0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV076_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV076_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SizeIn;                  /* height_width U16_U16 in texels    0304-0307*/
 V032 DeltaDxDu;               /* S12d20 ratio dx/du                0308-030b*/
 V032 DeltaDyDv;               /* S12d20 ratio dy/dv                030c-030f*/
 V032 ClipPoint;               /* y_x S16_S16                       0310-0313*/
 V032 ClipSize;                /* height_width U16_U16              0314-0317*/
 V032 Point12d4;               /* y_x S12d4_S12d4 in pixels         0318-031b*/
 V032 Reserved02[0x039];
 V032 Color[1792];             /* source colors (packed texels)     0400-1fff*/
} Nv076Typedef, Nv04StretchedImageFromCpu;
#define Nv4StretchedImageFromCpu                      Nv04StretchedImageFromCpu
#define nv4StretchedImageFromCpu                      nv04StretchedImageFromCpu
#define NV076_TYPEDEF                                 nv04StretchedImageFromCpu
/* dma method offsets, fields, and values */
#define NV076_SET_OBJECT                                           (0x00000000)
#define NV076_NO_OPERATION                                         (0x00000100)
#define NV076_NOTIFY                                               (0x00000104)
#define NV076_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV076_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV076_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV076_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV076_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV076_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV076_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV076_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV076_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV076_SET_OPERATION                                        (0x000002FC)
#define NV076_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV076_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV076_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV076_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV076_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV076_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV076_SET_COLOR_FORMAT                                     (0x00000300)
#define NV076_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000001)
#define NV076_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV076_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV076_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV076_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV076_SIZE_IN                                              (0x00000304)
#define NV076_SIZE_IN_WIDTH                                        15:0
#define NV076_SIZE_IN_HEIGHT                                       31:16
#define NV076_DELTA_DX_DU                                          (0x00000308)
#define NV076_DELTA_DY_DV                                          (0x0000030C)
#define NV076_CLIP_POINT                                           (0x00000310)
#define NV076_CLIP_POINT_X                                         15:0
#define NV076_CLIP_POINT_Y                                         31:16
#define NV076_CLIP_SIZE                                            (0x00000314)
#define NV076_CLIP_SIZE_WIDTH                                      15:0
#define NV076_CLIP_SIZE_HEIGHT                                     31:16
#define NV076_POINT_12D4                                           (0x00000318)
#define NV076_POINT_12D4_X                                         15:0
#define NV076_POINT_12D4_Y                                         31:16
#define NV076_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)


/* class NV04_SCALED_IMAGE_FROM_MEMORY */
#define  NV04_SCALED_IMAGE_FROM_MEMORY                             (0x00000077)
#define  NV4_SCALED_IMAGE_FROM_MEMORY                              (0x00000077)
/* NvNotification[] elements */
#define NV077_NOTIFIERS_NOTIFY                                     (0)
/* NvNotification[] fields and values */
#define NV077_NOTIFICATION_STATUS_IN_PROGRESS                      (0x8000)
#define NV077_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV077_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV077_NOTIFICATION_STATUS_ERROR_INVALID_STATE              (0x1000)
#define NV077_NOTIFICATION_STATUS_ERROR_STATE_IN_USE               (0x0800)
#define NV077_NOTIFICATION_STATUS_DONE_SUCCESS                     (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV077_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV01_CONTEXT_DMA_TO_MEMORY        0180-0183*/
 V032 SetContextDmaImage;      /* NV01_CONTEXT_DMA_FROM_MEMORY      0184-0187*/
 V032 SetContextPattern;       /* NV04_CONTEXT_PATTERN              0188-018b*/
 V032 SetContextRop;           /* NV03_CONTEXT_ROP                  018c-018f*/
 V032 SetContextBeta1;         /* NV01_BETA_SOLID                   0190-0193*/
 V032 SetContextBeta4;         /* NV04_CONTEXT_BETA                 0194-0197*/
 V032 SetContextSurface;       /* NV04_CONTEXT_SURFACES_2D,SWIZZLED 0198-019b*/
 V032 Reserved01[0x059];
 V032 SetColorFormat;          /* NV077_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetOperation;            /* NV077_SET_OPERATION_*             0304-0307*/
 V032 ClipPoint;               /* y_x S16_S16                       0308-030b*/
 V032 ClipSize;                /* height_width U16_U16              030c-030f*/
 V032 ImageOutPoint;           /* y_x S16_S16                       0310-0313*/
 V032 ImageOutSize;            /* height_width U16_U16              0314-0317*/
 V032 DeltaDuDx;               /* S12d20 ratio du/dx                0318-031b*/
 V032 DeltaDvDy;               /* S12d20 ratio dv/dy                031c-031f*/
 V032 Reserved02[0x038];
 V032 ImageInSize;             /* height_width U16_U16              0400-0403*/
 U032 ImageInFormat;           /* interpolator_origin_pitch         0404-0407*/
 U032 ImageInOffset;           /* bytes                             0408-040b*/
 V032 ImageInPoint;            /* v_u U12d4_U12d4                   040c-040f*/
 V032 Reserved03[0x6fc];
} Nv077Typedef, Nv04ScaledImageFromMemory;
#define Nv4ScaledImageFromMemory                      Nv04ScaledImageFromMemory
#define nv4ScaledImageFromMemory                      nv04ScaledImageFromMemory
#define NV077_TYPEDEF                                 nv04ScaledImageFromMemory
/* dma method offsets, fields, and values */
#define NV077_SET_OBJECT                                           (0x00000000)
#define NV077_NO_OPERATION                                         (0x00000100)
#define NV077_NOTIFY                                               (0x00000104)
#define NV077_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV077_NOTIFY_WRITE_THEN_AWAKEN                             (0x00000001)
#define NV077_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV077_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV077_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV077_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV077_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV077_SET_CONTEXT_BETA4                                    (0x00000194)
#define NV077_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV077_SET_COLOR_FORMAT                                     (0x00000300)
#define NV077_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000001)
#define NV077_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000002)
#define NV077_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV077_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000004)
#define NV077_SET_COLOR_FORMAT_LE_V8YB8U8YA8                       (0x00000005)
#define NV077_SET_COLOR_FORMAT_LE_YB8V8YA8U8                       (0x00000006)
#define NV077_SET_COLOR_FORMAT_LE_R5G6B5                           (0x00000007)
#define NV077_SET_OPERATION                                        (0x00000304)
#define NV077_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV077_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV077_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV077_SET_OPERATION_SRCCOPY                                (0x00000003)
#define NV077_SET_OPERATION_SRCCOPY_PREMULT                        (0x00000004)
#define NV077_SET_OPERATION_BLEND_PREMULT                          (0x00000005)
#define NV077_CLIP_POINT                                           (0x00000308)
#define NV077_CLIP_POINT_X                                         15:0
#define NV077_CLIP_POINT_Y                                         31:16
#define NV077_CLIP_SIZE                                            (0x0000030C)
#define NV077_CLIP_SIZE_WIDTH                                      15:0
#define NV077_CLIP_SIZE_HEIGHT                                     31:16
#define NV077_IMAGE_OUT_POINT                                      (0x00000310)
#define NV077_IMAGE_OUT_POINT_X                                    15:0
#define NV077_IMAGE_OUT_POINT_Y                                    31:16
#define NV077_IMAGE_OUT_SIZE                                       (0x00000314)
#define NV077_IMAGE_OUT_SIZE_WIDTH                                 15:0
#define NV077_IMAGE_OUT_SIZE_HEIGHT                                31:16
#define NV077_DELTA_DU_DX                                          (0x00000318)
#define NV077_DELTA_DV_DY                                          (0x0000031C)
#define NV077_IMAGE_IN_SIZE                                        (0x00000400)
#define NV077_IMAGE_IN_SIZE_WIDTH                                  15:0
#define NV077_IMAGE_IN_SIZE_HEIGHT                                 31:16
#define NV077_IMAGE_IN_FORMAT                                      (0x00000404)
#define NV077_IMAGE_IN_FORMAT_PITCH                                15:0
#define NV077_IMAGE_IN_FORMAT_ORIGIN                               23:16
#define NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER                        (0x00000001)
#define NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER                        (0x00000002)
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR                         31:24
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH                     (0x00000000)
#define NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH                     (0x00000001)
#define NV077_IMAGE_IN_OFFSET                                      (0x00000408)
#define NV077_IMAGE_IN                                             (0x0000040C)
#define NV077_IMAGE_IN_POINT_U                                     15:0
#define NV077_IMAGE_IN_POINT_V                                     31:16

typedef V032 Nv078Typedef;

typedef V032 Nv079Typedef;

typedef V032 Nv07aTypedef;

typedef V032 Nv07bTypedef;

typedef V032 Nv07cTypedef;

typedef V032 Nv07dTypedef;

typedef V032 Nv07eTypedef;

typedef V032 Nv07fTypedef;


/* class NV01_DEVICE_0 */
#define  NV01_DEVICE_0                                             (0x00000080)
/* NvNotification[] fields and values */
#define NV080_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv080Typedef, Nv01Device0;
#define  NV080_TYPEDEF                                             nv01Device0


/* class NV01_DEVICE_1 */
#define  NV01_DEVICE_1                                             (0x00000081)
/* NvNotification[] fields and values */
#define NV081_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv081Typedef, Nv01Device1;
#define  NV081_TYPEDEF                                             nv01Device1


/* class NV01_DEVICE_2 */
#define  NV01_DEVICE_2                                             (0x00000082)
/* NvNotification[] fields and values */
#define NV082_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv082Typedef, Nv01Device2;
#define  NV082_TYPEDEF                                             nv01Device2


/* class NV01_DEVICE_3 */
#define  NV01_DEVICE_3                                             (0x00000083)
/* NvNotification[] fields and values */
#define NV083_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv083Typedef, Nv01Device3;
#define  NV083_TYPEDEF                                             nv01Device3


/* class NV01_DEVICE_4 */
#define  NV01_DEVICE_4                                             (0x00000084)
/* NvNotification[] fields and values */
#define NV084_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv084Typedef, Nv01Device4;
#define  NV084_TYPEDEF                                             nv01Device4


/* class NV01_DEVICE_5 */
#define  NV01_DEVICE_5                                             (0x00000085)
/* NvNotification[] fields and values */
#define NV085_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv085Typedef, Nv01Device5;
#define  NV085_TYPEDEF                                             nv01Device5


/* class NV01_DEVICE_6 */
#define  NV01_DEVICE_6                                             (0x00000086)
/* NvNotification[] fields and values */
#define NV086_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv086Typedef, Nv01Device6;
#define  NV086_TYPEDEF                                             nv01Device6


/* class NV01_DEVICE_7 */
#define  NV01_DEVICE_7                                             (0x00000087)
/* NvNotification[] fields and values */
#define NV087_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv087Typedef, Nv01Device7;
#define  NV087_TYPEDEF                                             nv01Device7



 /***************************************************************************\
|*                                 Channels                                  *|
 \***************************************************************************/

typedef V032 Nv068Typedef;

typedef V032 Nv069Typedef;


/* class NV03_CHANNEL_PIO */
#define  NV03_CHANNEL_PIO                                          (0x0000006A)
#define  NV3_CHANNEL_PIO                                           (0x0000006A)
/* NvNotification[] fields and values */
#define NV06A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
#define NV06A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06A_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL               (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 V032 Reserved00[0x003];
 U016 Free;                    /* free count, read only             0010-0011*/
 U016 Zero[3];                 /* zeroes, read only                 0012-0017*/
 V032 Reserved01[0x03A];
} Nv03ControlPio;
#define Nv3ControlPio                                    Nv03ControlPio
typedef volatile struct {
 V032 SetObject;               /* handle of current object          0000-0003*/
 Nv03ControlPio control;       /* flow control                      0000-00ff*/
 union {                       /* start of class methods            0100-    */
  NvClass                       nvClass;
  NvContextDmaFromMemory        contextDmaFromMemory;
  NvContextDmaToMemory          contextDmaToMemory;
  NvContextDmaInMemory          contextDmaInMemory;
  NvPatchcordVideo              patchcordVideo;
  NvVideoSink                   videoSink;
  NvVideoColormap               videoColormap;
  NvVideoFromMemory             videoFromMemory;
  NvVideoScaler                 videoScaler;
  NvVideoColorKey               videoColorKey;
  Nv000Typedef NV000_TYPEDEF;
  Nv001Typedef NV001_TYPEDEF;
  Nv002Typedef NV002_TYPEDEF;
  Nv003Typedef NV003_TYPEDEF;
  Nv004Typedef NV004_TYPEDEF;
  Nv005Typedef NV005_TYPEDEF;
  Nv006Typedef NV006_TYPEDEF;
  Nv007Typedef NV007_TYPEDEF;
  Nv008Typedef NV008_TYPEDEF;
  Nv009Typedef NV009_TYPEDEF;
  Nv00aTypedef NV00A_TYPEDEF;
  Nv00bTypedef NV00B_TYPEDEF;
  Nv00cTypedef NV00C_TYPEDEF;
  Nv00dTypedef NV00D_TYPEDEF;
  Nv00eTypedef NV00E_TYPEDEF;
  Nv00fTypedef NV00F_TYPEDEF;
  Nv010Typedef NV010_TYPEDEF;
  Nv011Typedef NV011_TYPEDEF;
  Nv012Typedef NV012_TYPEDEF;
  Nv013Typedef NV013_TYPEDEF;
  Nv014Typedef NV014_TYPEDEF;
  Nv015Typedef NV015_TYPEDEF;
  Nv016Typedef NV016_TYPEDEF;
  Nv017Typedef NV017_TYPEDEF;
  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01aTypedef NV01A_TYPEDEF;
  Nv01bTypedef NV01B_TYPEDEF;
  Nv01cTypedef NV01C_TYPEDEF;
  Nv01dTypedef NV01D_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv020Typedef NV020_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv022Typedef NV022_TYPEDEF;
  Nv023Typedef NV023_TYPEDEF;
  Nv024Typedef NV024_TYPEDEF;
  Nv025Typedef NV025_TYPEDEF;
  Nv026Typedef NV026_TYPEDEF;
  Nv027Typedef NV027_TYPEDEF;
  Nv028Typedef NV028_TYPEDEF;
  Nv029Typedef NV029_TYPEDEF;
  Nv02aTypedef NV02A_TYPEDEF;
  Nv02bTypedef NV02B_TYPEDEF;
  Nv02cTypedef NV02C_TYPEDEF;
  Nv02dTypedef NV02D_TYPEDEF;
  Nv02eTypedef NV02E_TYPEDEF;
  Nv02fTypedef NV02F_TYPEDEF;
  Nv030Typedef NV030_TYPEDEF;
  Nv031Typedef NV031_TYPEDEF;
  Nv032Typedef NV032_TYPEDEF;
  Nv033Typedef NV033_TYPEDEF;
  Nv034Typedef NV034_TYPEDEF;
  Nv035Typedef NV035_TYPEDEF;
  Nv036Typedef NV036_TYPEDEF;
  Nv037Typedef NV037_TYPEDEF;
  Nv038Typedef NV038_TYPEDEF;
  Nv039Typedef NV039_TYPEDEF;
  Nv03aTypedef NV03A_TYPEDEF;
  Nv03bTypedef NV03B_TYPEDEF;
  Nv03cTypedef NV03C_TYPEDEF;
  Nv03dTypedef NV03D_TYPEDEF;
  Nv03eTypedef NV03E_TYPEDEF;
  Nv03fTypedef NV03F_TYPEDEF;
  Nv040Typedef NV040_TYPEDEF;
  Nv041Typedef NV041_TYPEDEF;
  Nv042Typedef NV042_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv044Typedef NV044_TYPEDEF;
  Nv045Typedef NV045_TYPEDEF;
  Nv046Typedef NV046_TYPEDEF;
  Nv047Typedef NV047_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv049Typedef NV049_TYPEDEF;
  Nv04aTypedef NV04A_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv04cTypedef NV04C_TYPEDEF;
  Nv04dTypedef NV04D_TYPEDEF;
  Nv04eTypedef NV04E_TYPEDEF;
  Nv04fTypedef NV04F_TYPEDEF;
  Nv050Typedef NV050_TYPEDEF;
  Nv051Typedef NV051_TYPEDEF;
  Nv052Typedef NV052_TYPEDEF;
  Nv053Typedef NV053_TYPEDEF;
  Nv054Typedef NV054_TYPEDEF;
  Nv055Typedef NV055_TYPEDEF;
  Nv056Typedef NV056_TYPEDEF;
  Nv057Typedef NV057_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05aTypedef NV05A_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;
  Nv05cTypedef NV05C_TYPEDEF;
  Nv05dTypedef NV05D_TYPEDEF;
  Nv05eTypedef NV05E_TYPEDEF;
  Nv05fTypedef NV05F_TYPEDEF;
  Nv060Typedef NV060_TYPEDEF;
  Nv061Typedef NV061_TYPEDEF;
  Nv062Typedef NV062_TYPEDEF;
  Nv063Typedef NV063_TYPEDEF;
  Nv064Typedef NV064_TYPEDEF;
  Nv065Typedef NV065_TYPEDEF;
  Nv066Typedef NV066_TYPEDEF;
  Nv067Typedef NV067_TYPEDEF;
/*Nv068Typedef NV068_TYPEDEF;*/
/*Nv069Typedef NV069_TYPEDEF;*/
/*Nv06aTypedef NV06A_TYPEDEF;*/
/*Nv06bTypedef NV06B_TYPEDEF;*/
/*Nv06cTypedef NV06C_TYPEDEF;*/
  Nv06dTypedef NV06D_TYPEDEF;
  Nv06eTypedef NV06E_TYPEDEF;
  Nv06fTypedef NV06F_TYPEDEF;
  Nv070Typedef NV070_TYPEDEF;
  Nv071Typedef NV071_TYPEDEF;
  Nv072Typedef NV072_TYPEDEF;
  Nv073Typedef NV073_TYPEDEF;
  Nv074Typedef NV074_TYPEDEF;
  Nv075Typedef NV075_TYPEDEF;
  Nv076Typedef NV076_TYPEDEF;
  Nv077Typedef NV077_TYPEDEF;
  Nv078Typedef NV078_TYPEDEF;
  Nv079Typedef NV079_TYPEDEF;
  Nv07aTypedef NV07A_TYPEDEF;
  Nv07bTypedef NV07B_TYPEDEF;
  Nv07cTypedef NV07C_TYPEDEF;
  Nv07dTypedef NV07D_TYPEDEF;
  Nv07eTypedef NV07E_TYPEDEF;
  Nv07fTypedef NV07F_TYPEDEF;
  Nv080Typedef NV080_TYPEDEF;
  Nv081Typedef NV081_TYPEDEF;
  Nv082Typedef NV082_TYPEDEF;
  Nv083Typedef NV083_TYPEDEF;
  Nv084Typedef NV084_TYPEDEF;
  Nv085Typedef NV085_TYPEDEF;
  Nv086Typedef NV086_TYPEDEF;
  Nv087Typedef NV087_TYPEDEF;
 } /* cls */;                  /* end of class methods                  -1fff*/
} Nv03SubchannelPio;
#define Nv3SubchannelPio                                 Nv03SubchannelPio
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv03SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv03ChannelPio;              /* end of array of subchannels           -ffff*/
#define Nv3ChannelPio                                            Nv03ChannelPio
/* fields and values */
#define NV06A_FIFO_GUARANTEED_SIZE                                 (0x007C)
#define NV06A_FIFO_EMPTY                                           (0x007C)


/* class NV03_CHANNEL_DMA */
#define  NV03_CHANNEL_DMA                                          (0x0000006B)
/* NvNotification[] fields and values */
#define NV06B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv06bTypedef, Nv03ChannelDma;
#define  NV06B_TYPEDEF                                           nv03ChannelDma


/* class NV04_CHANNEL_DMA */
#define  NV04_CHANNEL_DMA                                          (0x0000006C)
#define  NV4_CHANNEL_DMA                                           (0x0000006C)
/* NvNotification[] fields and values */
#define NV06C_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT               (0x2000)
#define NV06C_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT           (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv06cTypedef, Nv04ChannelDma;
#define  Nv4ChannelDma                                           Nv04ChannelDma
#define  nv4ChannelDma                                           nv04ChannelDma
#define  NV06C_TYPEDEF                                           nv04ChannelDma
/* pio flow control data structure */
typedef volatile struct {
 V032 reserved00[0x010];
 U032 Put;                     /* put offset, write only            0040-0043*/
 U032 Get;                     /* get offset, read only             0044-0047*/
 V032 reserved01[0x7EE];
} Nv04ControlDma;
#define  Nv4ControlDma                                           Nv04ControlDma



 /***************************************************************************\
|*                            Well Known Objects                             *|
 \***************************************************************************/


/* object NV01_NULL_OBJECT */
#define   NV01_NULL_OBJECT                                         (0x00000000)
#define   NV1_NULL_OBJECT                                          (0x00000000)



 /***************************************************************************\
|*                               Notification                                *|
 \***************************************************************************/


/***** NvNotification Structure *****/
/*
 * NV objects return information about method completion to clients via an 
 * array of notification structures in main memory.
 *
 * The client sets the status field to NV???_NOTIFICATION_STATUS_IN_PROGRESS. 
 * NV fills in the NvNotification[] data structure in the following order: 
 * timeStamp, otherInfo32, otherInfo16, and then status.
 */


/* memory data structures */
typedef volatile struct {
 struct {                      /*                                   0000-    */
  U032 nanoseconds[2];         /* nanoseconds since Jan. 1, 1970       0-   7*/
 } timeStamp;                  /*                                       -0007*/
 V032 info32;                  /* info returned depends on method   0008-000b*/
 V016 info16;                  /* info returned depends on method   000c-000d*/
 V016 status;                  /* user sets bit 15, NV sets status  000e-000f*/
} NvNotification;
/* status values */



#ifdef __cplusplus
};
#endif
#endif /* NV32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\NVDDOBJ.H ===
;/*
;***************************************************************************
;                                                                           *
;   Copyright (C) 1995, 1998 NVidia Corporation. All Rights Reserved.       *
;                                                                           *
;***************************************************************************
;*/

#ifndef NVARCH
ERROR! NVARCH must be defined. Definition of NV3, NV4, NV10, etc. is obsolete.
#endif

#if (NVARCH >= 0x04)
#define NV_IN_PROGRESS          0x8000
#else
#define NV_IN_PROGRESS          0xFF
#endif

#define NV_DD_COMMON_DMA_BUFFER_SIZE    32768
// win9x driver does not use these values anymore
#define NV_DD_DMA_PUSH_BUFFER_SIZE      (2*1024*1024)
#define NV_DD_DMA_PUSH_BUFFER_SIZE_LRG  (4*1024*1024)

#define NV_VIDEO_NOTIFIER_BUFFER_SIZE   3 * sizeof(NvNotification)

#define NV_STATUS_DONE_OK          0

#if (NVARCH >= 0x04)

#define videoColorKey                  NVFF6_TYPEDEF
#define videoScaler                    NVFF7_TYPEDEF
#define videoFromMemory                NVFF8_TYPEDEF
#define videoColormap                  NVFF9_TYPEDEF
#define videoSink                      NVFFA_TYPEDEF
#define patchcordVideo                 NVFFB_TYPEDEF
#define contextDmaInMemory             NVFFC_TYPEDEF
#define contextDmaToMemory             NVFFD_TYPEDEF
#define contextDmaFromMemory           NVFFE_TYPEDEF

#undef  NVFF8_SET_CONTEXT_DMA_NOTIFIES
#define NVFF8_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#undef  NVFF8_SET_VIDEO_OUTPUT
#define NVFF8_SET_VIDEO_OUTPUT                           (0x00000200)
#undef  NVFF8_IMAGE_SCAN_OFFSET
#define NVFF8_IMAGE_SCAN_OFFSET                          (0x00000300)
#undef  NVFF9_SET_VIDEO_OUTPUT
#define NVFF9_SET_VIDEO_OUTPUT                           (0x00000200)
#undef  NVFFA_SET_VIDEO_INPUT
#define NVFFA_SET_VIDEO_INPUT                            (0x00000200)
#undef  NVFFF_SET_CONTEXT_DMA_NOTIFIES
#define NVFFF_SET_CONTEXT_DMA_NOTIFIES                   (0x00000180)
#undef  NVFFF_CREATE_OFFSET
#define NVFFF_CREATE_OFFSET                              (0x00000300)
#undef  NVFFF_DESTROY_OFFSET
#define NVFFF_DESTROY_OFFSET                             (0x00000304)

// subchannels in primary channel
                                        // default object on this sub-channel
#define NV_DD_ROP                  0    // NV_DD_CONTEXT_ROP - NV03_CONTEXT_ROP (0x043)
#define NV_DD_SURFACES             1    // NV_DD_SURFACES_2D - NV4/10_CONTEXT_SURFACES_2D (0x042/0x062)
#define NV_DD_ROP_RECT_AND_TEXT    2    // NV_DD_ROP_GDI_RECT_AND_TEXT - NV4_GDI_RECTANGLE_TEXT (0x04a)
#define NV_DD_BLIT                 3    // NV_DD_IMAGE_BLIT  - NV4_IMAGE_BLIT (0x05f)
#define NV_DD_IMAGE                4    // NV_DD_IMAGE_FROM_CPU - NV4_IMAGE_FROM_CPU (0x061)
#define NV_DD_STRETCH              5    // NV_DD_STRETCHED_IMAGE_FROM_CPU/or one of many NV_DD_SCALED_IMAGE_FROM_MEMORY - NV04/05_STRETCHED/SCALED_IMAGE_FROM_CPU/MEMORY (0x066/0x076)
#define NV_DD_CELSIUS              6    // D3D_CELSIUS_PRIMITIVE - CELSIUS_PRIMITIVE (0x056, 0x096, or 0x1196)
#define NV_DD_KELVIN               6    // D3D_KELVIN_PRIMITIVE - KELVIN_PRIMITIVE (0x097)
#ifdef WINNT // Remove this when DX7 port is complete
#define NV_DD_TRANSCOLOR           6
#endif // WINNT
#define NV_DD_SPARE                7

// subchannels in secondary channel
#define NV_DD_SUBCH_DAC            0    // D3D_DAC_xxx

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].nv3ContextRop
#define dDrawSurfaces                  subchannel[NV_DD_SURFACES].nv4ContextSurfaces2D
#define dDrawRopRectAndText            subchannel[NV_DD_ROP_RECT_AND_TEXT].nv4GdiRectangleText
#define dDrawBlit                      subchannel[NV_DD_BLIT].nv1ImageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].nv1ImageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_TRANSCOLOR].nv4ContextColorKey
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#define dDrawSubchannelOffset(I)       (I * 0x00002000)

#define dVideoControlHdr               subchannel[0]
#define dVideoControl                  subchannel[0].Nv10VideoLutCursorDac
#define dVideoOverlayHdr               subchannel[1]
#define dVideoOverlay                  subchannel[1].Nv10VideoOverlay
#define dVideoDVDSubPictureHdr         subchannel[2]
#define dVideoDVDSubPicture            subchannel[2].Nv10DvdSubpicture
#define dVideoImageBlitHdr             subchannel[3]
#define dVideoImageBlit                subchannel[3].Nv04ImageBlit
#define dVideoSurface2DHdr             subchannel[4]
#define dVideoSurface2D                subchannel[4].Nv10ContextSurfaces2d

#define NV_DMA_PUSHER_JUMP             0x20000000

/* DMA pusher offsets */
#define SET_ROP_OFFSET                                          NV043_SET_ROP5
#define SURFACES_2D_SET_COLOR_FORMAT_OFFSET                     NV042_SET_COLOR_FORMAT
#define SURFACES_2D_PITCH_OFFSET                                NV042_SET_PITCH
#define SURFACES_2D_DEST_OFFSET                                 NV042_SET_OFFSET_DESTIN
#define IMAGE_BLACK_RECTANGLE_POINT_OFFSET                      NV019_SET_POINT
#define RECT_AND_TEXT_NO_OPERATION_OFFSET                       NV04A_NO_OPERATION
#define RECT_AND_TEXT_NOTIFY_OFFSET                             NV04A_NOTIFY
#define RECT_AND_TEXT_COLOR1A_OFFSET                            NV04A_COLOR1_A
#define RECT_AND_TEXT_CLIPPOINT0B_OFFSET                        NV04A_CLIP_POINT0_B
#define RECT_AND_TEXT_CLIPPEDRECT_POINT0_OFFSET                 NV04A_CLIPPED_RECTANGLE(0)
#define BLIT_POINT_IN_OFFSET                                    NV05F_CONTROL_POINT_IN
#define IMAGE_FROM_CPU_POINT_OFFSET                             NV061_POINT
#define IMAGE_FROM_CPU_COLOR_OFFSET                             NV061_COLOR(0)
#define STRETCHED_IMAGE_COLOR_FORMAT_OFFSET                     NV076_SET_COLOR_FORMAT
#define STRETCHED_IMAGE_SIZE_IN_OFFSET                          NV076_SIZE_IN
#define STRETCHED_IMAGE_COLOR_OFFSET                            NV076_COLOR(0)
#define SCALED_IMAGE_NOTIFY_OFFSET                              NV077_NOTIFY
#define SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET                   NV077_SET_CONTEXT_DMA_IMAGE
#define SCALED_IMAGE_CONTEXT_SURFACE_OFFSET                     NV077_SET_CONTEXT_SURFACE
#define SCALED_IMAGE_SET_COLOR_FORMAT                           NV077_SET_COLOR_FORMAT
#define SCALED_IMAGE_CLIPPOINT_OFFSET                           NV077_CLIP_POINT
#define SCALED_IMAGE_DELTADUDX_OFFSET                           NV077_DELTA_DU_DX
#define SCALED_IMAGE_IMAGE_OUT_POINT_OFFSET                     NV077_IMAGE_OUT_POINT
#define SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET                       NV077_IMAGE_IN_SIZE
#define SCALED_IMAGE_IMAGE_IN_POINT_OFFSET                      NV077_IMAGE_IN
#define SET_TRANSCOLOR_OFFSET                                   NV057_SET_COLOR
#define MEM_TO_MEM_FORMAT_BUFFER_IN_OFFSET                      NV039_SET_CONTEXT_DMA_BUFFER_IN
#define MEM_TO_MEM_FORMAT_BUFFER_OUT_OFFSET                     NV039_SET_CONTEXT_DMA_BUFFER_OUT
#define MEM_TO_MEM_FORMAT_OFFSET_IN_OFFSET                      NV039_OFFSET_IN
#define BETA4_SET_BETA_FACTOR_OFFSET                            NV072_SET_BETA_FACTOR
#define VIDEO_FROM_MEM_OFFSET_OFFSET                            NVFF8_IMAGE_SCAN_OFFSET
#define CONTEXT_DMA_FROM_MEM_NOTIFY_OFFSET                      NVFFE_NOTIFY
#define CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_OFFSET           NVFFE_SET_DMA_SPECIFIER
#define CONTEXT_DMA_FROM_MEM_SET_DMA_SPECIFIER_LIMIT_OFFSET     NVFFE_SET_DMA_SPECIFIER_LIMIT

#else   // !(NVARCH >= 0x04)

#define NV_DD_ROP                      0
#define NV_DD_IMAGE_IN_MEMORY          1
#define NV_DD_ROP_RECT_AND_TEXT        2
#define NV_DD_BLIT                     3
#define NV_DD_IMAGE                    4
#define NV_DD_STRETCH                  5
#define NV_DD_TRANSCOLOR               6
#define NV_DD_SPARE                    7

/* Default cached objects in Windows 95 Direct Draw patch */
#define dDrawRop                       subchannel[NV_DD_ROP].rop5Solid
#define dDrawImageInMemory             subchannel[NV_DD_IMAGE_IN_MEMORY].imageInMemory
#define dDrawRopRectAndText            subchannel[NV_DD_ROP_RECT_AND_TEXT].winRectAndTextFromCpu
#define dDrawBlit                      subchannel[NV_DD_BLIT].imageBlit
#define dDrawImageFromCpu              subchannel[NV_DD_IMAGE].imageFromCpu
#define dDrawStretch                   subchannel[NV_DD_STRETCH]
#define dDrawTransColor                subchannel[NV_DD_TRANSCOLOR].imageSolid
#define dDrawSpare                     subchannel[NV_DD_SPARE]

#endif  // !(NVARCH >= 0x04)
/*
      7 subchannels contain the default cached objects.  These objects
are expected to be loaded at all times except when one or more of them gets
temporarily replaced for an unusual rendering operation.  If a default cached
object does get temporarily replaced, it is expected to be restored immediately
after completion of the rendering operation which caused it's replacement.
There is a spare subchannel in the Direct Draw patch which is lazy evaluated
similarly to the one used in the display driver.

        In the Windows 95 Direct Draw patch description below outlined objects are
those expected to be cached in the 8 subchannels.  Objects with corners
marked only are objects which temporarily replace cached objects or which are
loaded into the eighth subchannel when used.  All other objects are created,
patched together, then never loaded again until the patch is destroyed.  Most of
those objects are in the interior of the patch and are referenced by row for
clear identification.  Patchcord object names are derived from the object
where their output originates (their source).


/* Windows 95 Double Buffered Direct Draw ROP3 Patch */


/*

   Objects

   Context DMA  Context DMA
    To Memory    To Memory
          . |    | . .-------. .               . .         . .---------------.
           MemToMem  |  Rop  |   Image Pattern      Image    |  Image Solid  |
            Format   | Solid |  (Alpha Enabled)     Black    |(Alpha Enabled)|
          '        ' '-------' '               '  Rectangle  '---------------'
                           |        |            '         '         |
                          P|I       |              |                 |
                           |  .-----'     .--------'    .------------'
                           | P|I         P|I           P|I
 .               .         |  |           |             |
    (Sync) Rect     P      |  |           |             |       P
     And Text     ------------------------------------------------->.
 '               '  I      |  |           |             |       I   |
                           |  |           |             |           |
                          P|IP|I         P|I           P|I          |
 .---------------.         V  V           |             V           |
 |   Rop Rect    |  P   Image Rop  P      V     P     Image     P   |
 |   And Text    |----->   And   ------------------>Color Key------>|       1
 '---------------'  I   ^          I      |     I               I   |
                       P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.----------------.         V  V           V             V           |
| Image From CPU |  P   Image Rop  P    Image   P     Image     P   |
|(Alpha Disabled)|----->   And   ----->Stencil----->Color Key------>|       2
'----------------'  I   ^          I            I               I   |
                       P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           V             V           |
  Image From CPU    P   Image Rop  P    Image   P     Image     P   |
 (Alt Pxl Depth)  ----->   And   ----->Stencil----->Color Key------>|       3
'                '  I   ^          I            I               I   |
 CtxDmaFromSysMem      P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.---|------------.         V  V           |             V           |
|  Scaled RGB    |  P   Image Rop  P      V     P     Image     P   |
|ImageFromSysMem |----->   And   ------------------>Color Key------>|       4
|(Alpna Disabled)|  I   ^          I      |     I               I   |
'----------------'     P|I |  |           |             |           |
 CtxDmaFromVidMem       | P|IP|I         P|I           P|I          |
.          |     .         V  V           |             V           |
   Scaled RGB       P   Image Rop  P      V     P     Image     P   |
 ImageFromVidMem  ----->   And   ------------------>Color Key------>|       5
 (Alpna Disabled)   I   ^          I      |     I               I   |
'                '     P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.   |            .      |  |  |           |             |           |
   Scaled UYVY      P   |  V  V    P      V     P       V       P   |
 ImageFromSysMem  ------------------------------------------------->|       6
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
           |            | P|IP|I         P|I           P|I          |
.          |     .         |  |           |             |           |
   Scaled UYVY      P   |  V  V    P      V     P       V       P   |
 ImageFromVidMem  ------------------------------------------------->|       7
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
    |                   | P|IP|I         P|I           P|I          |
.   |            .      |  |  |           |             |           |
   Scaled YUYV      P   |  V  V    P      V     P       V       P   |
 ImageFromSysMem  ------------------------------------------------->|       8
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
           |            | P|IP|I         P|I           P|I          |
.          |     .         |  |           |             |           |
   Scaled YUYV      P   |  V  V    P      V     P       V       P   |
 ImageFromVidMem  ------------------------------------------------->|       9
 (Alpna Disabled)   I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled UYVY    ------------------------------------------------->|       A
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled UYVY    ------------------------------------------------->|       B
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled YUYV    ------------------------------------------------->|       C
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled YUYV    ------------------------------------------------->|       D
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .      |  |  |           |             |           |
    Floating 0      P   |  V  V    P      V     P       V       P   |
   Scaled Y420    ------------------------------------------------->|       AA
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
 CtxDmaFromSysMem       | P|IP|I         P|I           P|I          |
.       |        .         |  |           |             |           |
    Floating 1      P   |  V  V    P      V     P       V       P   |
   Scaled Y420    ------------------------------------------------->|       BB
 ImageFromSysMem    I   ^  |  |    I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           |             |           |
  Stretched UV      P   Image Rop  P      V     P       V       P   |
      Image       ----->   And   ---------------------------------->|       CC
 (Alpna Disabled)   I   ^          I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.                .         V  V           |             V           |
    Stretched       P   Image Rop  P      V     P     Image     P   |
      Image       ----->   And   ------------------>Color Key------>|       DD
 (Alpna Disabled)   I   ^          I      |     I       |       I   |
'                '     P|I |  |           |             |           |
                        | P|IP|I         P|I           P|I          |
.----------------.         V  V           V             V           |
|   Image Blit   |  P   Image Rop  P    Image   P     Image     P   |
|(Alpha Disabled)|----->   And   ----->Stencil----->Color Key------>|       E
'------------^---'  I   ^          I            I               I   |
            P|I        P|I                                          |
             |          |                                           |
             |          |                                           |
             |          '------------------------------------.      |
             |                                               |      |
             |                                               |      |
             |                                              P|I    P|I
             |                                               |      |
            P|I                                              |      |
             |                                               |      |
             |                                               |      V
 .             .               .           .              .-------------.
     Source     --------------- Context DMA --------------| Destination |  P
  ImageInMemory                  InMemory                 |ImageInMemory|<----.
 '             '               '           '              '-------------'  I  |
                                  |    |                                      |
                                  |    '-------------------------.            |
                                  |                              |            |
 .              .          P      |                 P     .                .  |
  Render Solid   ----------------------------------------> Destination Zeta   |
  Zeta Rectangle           I      |                 I       ImageInMemory     |
 '              '                 |                       '                '  |
                                  |                                           |
                                  '------------------------------.            |
                                                                 |            |
                                                          .                .  |
 .             .      P                               P    Destination Zeta   |
   Render D3D   ----------------------------------------->  BufferInMemory    |
  Triangle Zeta       Z         P   Image    P        Z   '      ^         '  |
 '             '------------------>Stencil----------------------------------->| F
                                I            I                   |            |
                                                                P|Z           |
 .             .      P                               P          |            |
   Render D3D   -------------------------------------------------'            |
  Triangle Zeta       Z         P   Image    P        Z                       |
   From Video   ------------------>Stencil----------------------------------->' FF
     Memory                     I            I
 '             '

                            .                 .
  Floating Format               Y, U, V, UV
  Context DMA From --------- System Memory To  ---------------.
   System Memory             Vid Memory Format                |
                            '                 '               |
                                                       Context DMA To
                                                        Video Memory
                            .                 .               |
                                Y, U, V, UV                   |
         .------------------  Video Memory To  ---------------'
         |                   Vid Memory Format
 .                .         '                 '
  Context DMA From
    Video Memory
 ,                ,               .          .
       |    |                       Primary
       |    '--------------------- Video From ------Flip Primary Notifier
       |                             Memory         Context DMA To Memory
       |                          '          '
       |                            |      |
       |                            |      |
       |                           P|V    P|V
       |                            |      |
       |                            |      |   P   .            .
  .          .                      V      V//<---- Shared Video
     YUV422     P   .      .    P  .         . V      Colormap
   Video From -----> Video  ------>   Video        '            '
     Memory     V    Scaler     V   Color Key
  '          '      '      '       '         '
        |                               |
        |                               |
  Flip Overlay Notifier                P|V
  Context DMA To Memory                 |
                                        V
                                   .         .
                                      Video
                                      Sink
                                   '         '

*/


/* Video channel shared Display Driver and DDraw Object IDs */

//#define NV_VIDEO_NOTIFIER_CONTEXT_DMA_TO_MEMORY                 0x00008000 These 2 were allocated & freed, but
//#define NV_VIDEO_LUT_CURSOR_DAC_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x00008004 never referenced. 
#define NV_VIDEO_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0x00008008
#define NV_VIDEO_LUT_CURSOR_DAC                                 0x00008020
#define NV_VIDEO_OVERLAY                                        0x00008030
#define NV_VIDEO_DVD_SUBPICTURE                                 0x00008040
//#define NV_VIDEO_SURFACES_2D_A8R8G8B8                           0x00008050 no longer in use
//#define NV_VIDEO_CONTEXT_BETA4                                  0x00008060 no longer in use 
//#define NV_VIDEO_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT            0x00008070 no longer in use

/* Windows 9X Direct Draw Object IDs */


#define NV_DD_PIO_CONTEXT_DMA_FROM_SYSTEM_MEMORY                0xDD001000
#define NV_DD_DMA_CONTEXT_DMA_FROM_SYSTEM_MEMORY                0xDD001000
#define NV_DD_PIO_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001001
#define NV_DD_DMA_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001001
#define NV_DD_PIO_CONTEXT_DMA_FROM_VIDEO_MEMORY                 0xDD001002
#define NV_DD_DMA_CONTEXT_DMA_FROM_VIDEO_MEMORY                 0xDD001002
#define NV_DD_PIO_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001003
#define NV_DD_DMA_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001003
#define NV_DD_PIO_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001004
#define NV_DD_DMA_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001004
#define NV_DD_PIO_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001005
#define NV_DD_DMA_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001005
#define NV_DD_PIO_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001006
#define NV_DD_DMA_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD001006
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW        0xDD001007
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_OVERLAY_SHADOW        0xDD001007
#define NV_DD_DMA_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY        0xDD001009
#define NV_DD_DMA_FLOATING_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY 0xDD00100A
#define NV_DD_DMA_TRIANGLE_CONTEXT_DMA_FROM_SYSTEM_MEMORY       0xDD00100B
#define NV_DD_PIO_CONTEXT_DMA_IN_VIDEO_MEMORY                   0xDD001010
#define NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY                   0xDD001010
#define NV_DD_PIO_COMBINER_EVENT_NOTIFIER                       0xDD001014
#define NV_DD_DMA_COMBINER_EVENT_NOTIFIER                       0xDD001014
#define NV_DD_PIO_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD001015
#define NV_DD_DMA_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD001015
#define NV_DD_PIO_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001016
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017
#define NV_DD_DMA_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001017
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY_0 0xDD001017
#define NV_DD_PIO_CONTEXT_DMA_TO_SYSTEM_MEMORY                  0xDD001018
#define NV_DD_DMA_CONTEXT_DMA_TO_SYSTEM_MEMORY                  0xDD001018

#ifdef NV3
#define NV_DD_PIO_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0xDD001019
#define NV_DD_DMA_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0xDD001019
#endif

#define NV_DD_SCALED_IMAGE_CONTEXT_IID                          0xDD001019

#define NV_DD_DMA_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY    0xDD00101A
#define NV_DD_PIO_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD00101B
#define NV_DD_DMA_BUFFER_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0xDD00101B
#define NV_DD_PIO_CONTEXT_DMA_TO_VIDEO_MEMORY                   0xDD00101C
#define NV_DD_DMA_CONTEXT_DMA_TO_VIDEO_MEMORY                   0xDD00101C
#define NV_DD_PIO_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0xDD00101D
#define NV_DD_DMA_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0xDD00101D
#define NV_DD_PIO_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY_1 0xDD00101E
#define NV_DD_PIO_COLOUR_CONTROL_EVENT_NOTIFIER                 0xDD00101F
#define NV_DD_DMA_COLOUR_CONTROL_EVENT_NOTIFIER                 0xDD00101F

#define NV_DD_VIDEO_MEMORY_TO_SYSTEM_MEMORY_FORMAT              0xDD001020
#define NV_DD_CONTEXT_ROP                                       0xDD001030
#define NV_DD_ROP5_SOLID                                        0xDD001030
#define NV_DD_P_I_ROP5_SOLID                                    0xDD001031
#define NV_DD_P_B_BETA_SOLID                                    0xDD001041
#define NV_DD_CONTEXT_PATTERN                                   0xDD001050
#define NV_DD_IMAGE_PATTERN                                     0xDD001050
#define NV_DD_P_I_IMAGE_PATTERN                                 0xDD001051
#define NV_DD_IMAGE_BLACK_RECTANGLE                             0xDD001060
#define NV_DD_P_I_IMAGE_BLACK_RECTANGLE                         0xDD001061
#define NV_DD_CONTEXT_COLOR_KEY                                 0xDD001070
#define NV_DD_COLOR_KEY_IMAGE_SOLID                             0xDD001070
#define NV_DD_P_I_COLOR_KEY_IMAGE_SOLID                         0xDD001071
#define NV_DD_CONTEXT_BETA4                                     0xDD001080

#define NV_DD_DMA_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0xDD001090 // to 0xDD00109F (need one per head)

#define NV_DD_ROP_GDI_RECT_AND_TEXT                             0xDD001100
#define NV_DD_P_I_ROP_GDI_RECT_AND_TEXT                         0xDD001101
#define NV_DD_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU                0xDD00110A
#define NV_DD_P_I_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU            0xDD00110B
#define NV_DD_IMAGE_FROM_CPU                                    0xDD001200
#define NV_DD_P_I_IMAGE_FROM_CPU                                0xDD001201
#define NV_DD_IMAGE_BLEND_FROM_CPU                              0xDD001300
#define NV_DD_P_I_IMAGE_BLEND_FROM_CPU                          0xDD001301
#define NV_DD_STRETCHED_IMAGE_FROM_CPU                          0xDD001400
#define NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU                      0xDD001401
#ifdef NV3
#define NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY               0xDD001500
#endif
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY           0xDD001501
#define NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY       0xDD001508
#define NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY 0xDD001509
#define NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY        0xDD00150A
#define NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY                0xDD001510
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY            0xDD001511
#define NV_DD_SRCCOPY_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY        0xDD001518
#define NV_DD_ABLEND_NOSRCALPHA_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY 0xDD001519
#define NV_DD_ABLEND_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY         0xDD00151A
#define NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY              0xDD001520
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY          0xDD001521
#define NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY               0xDD001530
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY           0xDD001531
#define NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY              0xDD001540
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY          0xDD001541
#define NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY               0xDD001550
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY           0xDD001551
#define NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0xDD001560
#define NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0xDD001561
#define NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0xDD001570
#define NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0xDD001571
#define NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0xDD001580
#define NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0xDD001581
#define NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0xDD001590
#define NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0xDD001591
#define NV_DD_SCALED_IMAGE_IID                                  0xDD0015A0
#define NV_DD_GENERIC_STRETCHED_IMAGE                           0xDD0015A1
#define NV_DD_STRETCHED_UV_IMAGE_FROM_CPU                       0xDD001600
#define NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU                   0xDD001601

#define NV_DD_IMAGE_BLIT                                        0xDD001800
#define NV_DD_P_I_IMAGE_BLIT                                    0xDD001801
#define NV_DD_SRCCOPY_IMAGE_BLIT                                0xDD001808
#define NV_DD_SRCCOPY_PREMULT_A8R8G8B8_IMAGE_BLIT               0xDD00180A
#define NV_DD_P_I_ALT_IMAGE_FROM_CPU                            0xDD001901
#define NV_DD_RENDER_SOLID_ZETA_RECTANGLE                       0xDD001A00
#define NV_DD_P_I_RENDER_SOLID_ZETA_RECTANGLE                   0xDD001A01

#define NV_D3D_RENDER_TRIANGLE_ZETA                             0xDD001B00
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA                         0xDD001B01
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA                         0xDD001B02
#define NV_D3D_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY           0xDD001B03
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0xDD001B04
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0xDD001B05
#define NV_D3D_FLOATING_RENDER_TRIANGLE_ZETA                    0xDD001B06
#define NV_D3D_FLOATING_P_I_RENDER_TRIANGLE_ZETA                0xDD001B07
#define NV_D3D_FLOATING_P_Z_RENDER_TRIANGLE_ZETA                0xDD001B08

// floating dma contexts for DVD acceleration
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V            0xDD001C00
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V            0xDD001C00
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V0           0xDD001C00
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V0           0xDD001C00
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V1           0xDD001C01
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V1           0xDD001C01
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V2           0xDD001C02
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V2           0xDD001C02
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V3           0xDD001C03
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V3           0xDD001C03
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V4           0xDD001C04
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V4           0xDD001C04
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V5           0xDD001C05
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V5           0xDD001C05
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V6           0xDD001C06
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V6           0xDD001C06
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V7           0xDD001C07
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V7           0xDD001C07
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V8           0xDD001C08
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V8           0xDD001C08
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V9           0xDD001C09
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2V9           0xDD001C09
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VA           0xDD001C0A
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VA           0xDD001C0A
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VB           0xDD001C0B
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VB           0xDD001C0B
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VC           0xDD001C0C
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VC           0xDD001C0C
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VD           0xDD001C0D
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VD           0xDD001C0D
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VE           0xDD001C0E
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VE           0xDD001C0E
#define NV_DD_PIO_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VF           0xDD001C0F
#define NV_DD_DMA_FLOATING_CONTEXT_DMA_IN_SYSTEM_S2VF           0xDD001C0F

#define NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY     0xDD001D00
#define NV_DD_DMA_FLOATING_MC_IDCT1_CONTEXT_DMA_FROM_MEMORY     (NV_DD_DMA_FLOATING_MC_IDCT0_CONTEXT_DMA_FROM_MEMORY+1)
#define NV_DD_DMA_FLOATING_MC_IDCT2_CONTEXT_DMA_FROM_MEMORY     (NV_DD_DMA_FLOATING_MC_IDCT1_CONTEXT_DMA_FROM_MEMORY+1)
#define NV_DD_DMA_FLOATING_MC_IDCT3_CONTEXT_DMA_FROM_MEMORY     (NV_DD_DMA_FLOATING_MC_IDCT2_CONTEXT_DMA_FROM_MEMORY+1)

// defined in CFlipper, but listed here to keep this list comprehensive
// #define CFlipper::SEMAPHORE_CONTEXT_DMA_IN_MEMORY            0xDD001E00
// #define CFlipper::SEMAPHORE_CONTEXT_DMA_FROM_MEMORY          0xDD001E01

/* Patch interior */

#define NV_DD_IMAGE_ROP_AND_1                                   0xDD002110
#define NV_DD_P_I_IMAGE_ROP_AND_1                               0xDD002111
#define NV_DD_IMAGE_COLOR_KEY_1                                 0xDD002130
#define NV_DD_P_I_IMAGE_COLOR_KEY_1                             0xDD002131

#define NV_DD_IMAGE_ROP_AND_2                                   0xDD002210
#define NV_DD_P_I_IMAGE_ROP_AND_2                               0xDD002211
#define NV_DD_IMAGE_STENCIL_2                                   0xDD002220
#define NV_DD_P_I_IMAGE_STENCIL_2                               0xDD002221
#define NV_DD_IMAGE_COLOR_KEY_2                                 0xDD002230
#define NV_DD_P_I_IMAGE_COLOR_KEY_2                             0xDD002231

#define NV_DD_IMAGE_ROP_AND_3                                   0xDD002310
#define NV_DD_P_I_IMAGE_ROP_AND_3                               0xDD002311
#define NV_DD_IMAGE_STENCIL_3                                   0xDD002320
#define NV_DD_P_I_IMAGE_STENCIL_3                               0xDD002321
#define NV_DD_IMAGE_COLOR_KEY_3                                 0xDD002330
#define NV_DD_P_I_IMAGE_COLOR_KEY_3                             0xDD002331

#define NV_DD_IMAGE_ROP_AND_4                                   0xDD002410
#define NV_DD_P_I_IMAGE_ROP_AND_4                               0xDD002411
#define NV_DD_IMAGE_COLOR_KEY_4                                 0xDD002430
#define NV_DD_P_I_IMAGE_COLOR_KEY_4                             0xDD002431

#define NV_DD_IMAGE_ROP_AND_5                                   0xDD002510
#define NV_DD_P_I_IMAGE_ROP_AND_5                               0xDD002511
#define NV_DD_IMAGE_COLOR_KEY_5                                 0xDD002530
#define NV_DD_P_I_IMAGE_COLOR_KEY_5                             0xDD002531

#define NV_DD_IMAGE_ROP_AND_C                                   0xDD002C10
#define NV_DD_P_I_IMAGE_ROP_AND_C                               0xDD002C11

#define NV_DD_IMAGE_ROP_AND_D                                   0xDD002D10
#define NV_DD_P_I_IMAGE_ROP_AND_D                               0xDD002D11
#define NV_DD_IMAGE_COLOR_KEY_D                                 0xDD002D30
#define NV_DD_P_I_IMAGE_COLOR_KEY_D                             0xDD002D31

#define NV_DD_IMAGE_ROP_AND_E                                   0xDD002E10
#define NV_DD_P_I_IMAGE_ROP_AND_E                               0xDD002E11
#define NV_DD_IMAGE_STENCIL_E                                   0xDD002E20
#define NV_DD_P_I_IMAGE_STENCIL_E                               0xDD002E21
#define NV_DD_IMAGE_COLOR_KEY_E                                 0xDD002E30
#define NV_DD_P_I_IMAGE_COLOR_KEY_E                             0xDD002E31

#define NV_DD_IMAGE_STENCIL_F                                   0xDD002F20
#define NV_DD_P_I_IMAGE_STENCIL_F                               0xDD002F21

#define NV_DD_IMAGE_STENCIL_F3                                  0xDD002F30
#define NV_DD_P_I_IMAGE_STENCIL_F3                              0xDD002F31

#define NV_DD_IMAGE_STENCIL_FF                                  0xDD002FF0
#define NV_DD_P_I_IMAGE_STENCIL_FF                              0xDD002FF1

/* Patch back end */

#define NV_DD_SURFACES_2D                                       0xDD003F00
#define NV_DD_DST_IMAGE_IN_MEMORY                               0xDD003F00
#define NV_DD_P_I_DST_IMAGE_IN_MEMORY                           0xDD003F01
#define NV_DD_SURFACES_2D_A8R8G8B8                              0xDD003F02
#define NV_DD_SURFACES_3D                                       0xDD003F03
#define NV_DD_SURFACES_SWIZZLED                                 0xDD003F04
#define NV_DD_SRC_IMAGE_IN_MEMORY                               0xDD003F10
#define NV_DD_P_I_SRC_IMAGE_IN_MEMORY                           0xDD003F11
#define NV_DD_ZETA_IMAGE_IN_MEMORY                              0xDD003F20
#define NV_D3D_ZETA_BUFFER_IN_MEMORY                            0xDD003F30
#define NV_D3D_P_Z_ZETA_BUFFER_IN_MEMORY                        0xDD003F31

#define NV_DD_PRIMARY_VIDEO_FROM_MEMORY                         0xDD003F80
#define NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY                     0xDD003F81
#define NV_DD_YUV422_VIDEO_FROM_MEMORY                          0xDD003F90
#define NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY                      0xDD003F91
#define NV_DD_VIDEO_SCALER                                      0xDD003FA0
#define NV_DD_P_V_VIDEO_SCALER                                  0xDD003FA1
#define NV_DD_VIDEO_COLOR_KEY                                   0xDD003FB0
#define NV_DD_P_V_VIDEO_COLOR_KEY                               0xDD003FB1
#define NV_DD_SHARED_VIDEO_COLORMAP                             0xDD003FC0
#define NV_DD_P_V_SHARED_VIDEO_COLORMAP                         0xDD003FC1

#define NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT            0xDD003FD0
#define NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT            0xDD003FD1
#define NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT            0xDD003FD2
#define NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT           0xDD003FD3
#define NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT             0xDD003FE0
#define NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT             0xDD003FE1
#define NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT             0xDD003FE2
#define NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT            0xDD003FE3
#define NV_DD_GENERIC_MTMF_1                                    0xDD003FE7
#define NV_DD_GENERIC_MTMF_2                                    0xDD003FE8
#define NV_DD_VIDEO_SINK                                        0xDD003FF0

#define NV_DD_COMMON_DMA_BUFFER                                 0xDD004000
#define NV_DD_PIO_CONTEXT_ERROR_TO_MEMORY                       0xDD004010
#define NV_DD_DEV_PIO                                           0xDD004020

// channels
#define NV_DD_DEV_DMA                                           0xDD005020
//                                                              0xDD005021  reserved
#define NV_DD_DEV_VIDEO                                         0xDD005030
//                                                              0xDD005031  reserved
#define NV_DD_DEV_VPE                                           0xDD005040
//                                                              0xDD005041  reserved
#define NV_DD_DEV_DAC                                           0xDD005050
//                                                              0xDD005051  reserved

#define NV_DD_VIDEO_LUT_CURSOR_DAC                              0xDD006020
//                                                              0xDD006021-0xDD00604f  reserved for multi-head
#define NV_DD_VIDEO_LUT_CURSOR_DAC_2                            0xDD006050
//                                                              0xDD006051-0xDD00606f  reserved for multi-head

#define NV_DD_GLOBALDATA_MEMORY                                 0xDD008020
#define NV_DD_GLOBALDATA_MEMORY_NVDD32_CONTEXT                  0xDD008021
#define NV_DD_GLOBALDATA_MEMORY_NVDD32_CONTEXT_CONTENTS         0xDD008022
#define NV_DD_IPM                                               0xDD008026
#define NV_DD_CONTEXTDMA_MEMORY                                 0xDD008030

#define NV_DD_INDEXED_IMAGE_FROM_CPU                            0xDD00A000

#ifdef WINNT
// Pushbuf and default VB IDs needed for Win2k RM AGP allocator.
#define NV_DD_AGP_PUSHBUF                                       0xDD00A001
#endif // WINNT



// Events
#define NV_DD_EVENT_IDLE_SYNC                                   0xDD00C000
#define NV_DD_EVENT_CONVERT_SYNC                                0xDD00C001
#define NV_DD_EVENT_DVD_SUBPICTURE                              0xDD00C002
#define NV_DD_EVENT_ALPHA_BLIT_SYNC                             0xDD00C003
#define NV_DD_EVENT_VIDEO_TO_SYSTEM_SYNC                        0xDD00C004
#define NV_DD_EVENT_SYSTEM_TO_VIDEO_SYNC                        0xDD00C005
#define NV_DD_EVENT_COMBINER_SYNC                               0xDD00C006
#define NV_DD_EVENT_DMABLT_TO_VID                               0xDD00C007
#define NV_DD_EVENT_OVL_FLIP1                                   0xDD00C008
#define NV_DD_EVENT_OVL_FLIP2                                   0xDD00C009
#define NV_DD_EVENT_DFILTER_SYNC                                0xDD00C00A
#define NV_DD_EVENT_FSMIRROR                                    0xDD00C00B
#define NV_DD_EVENT_PRIMARY0_FLIP1                              0xDD00C00C
#define NV_DD_EVENT_PRIMARY0_FLIP2                              0xDD00C00D
#define NV_DD_EVENT_PRIMARY1_FLIP1                              0xDD00C00E
#define NV_DD_EVENT_PRIMARY1_FLIP2                              0xDD00C00F
#define NV_DD_EVENT_TIMER                                       0xDD00C010
#define NV_DD_EVENT_FOURCCBLT                                   0xDD00C020

// Floating context DMA's for system surfaces (reserve a block of 256 for now)
// HWFIX: note that context DMA IDs are incremented by 2 on each creation,
//        and to fix a hw hash error, we must swap bits 1 and 2 with bits 11 and 22
//        to hit the hash function bits on each iteration
#define MAX_FLOATING_CONTEXT_DMA                                0x40
#define MASK_FLOATING_CONTEXT_DMA_ID                            0xFFBFF005  // bits 2 and 22 swapped
#define FLOATING_CONTEXT_DMA_ID                                 0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_BASE                         0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_0                            0xDD00D001
#define NV_DD_FLOATING_CONTEXT_DMA_7FF                          0xDD00DFFF

#if (NVARCH < 0x4)
#define NV_DD_BETA_SOLID                                        0xDD001040
#define NV_DD_STRETCHED_UV_IMAGE_FROM_CPU                       0xDD001600
#define NV_DD_ALT_IMAGE_FROM_CPU                                0xDD001900
#define NV_DD_DMA_CONTEXT_ERROR_TO_MEMORY                       0xDD005010 //nv3 only
#endif

// D3D objects

// naming convention:
// D3Dxxxyy
// where xxx = object class number
//        yy = enumerator, in case we have more than one object of type xxx

// DMA contexts.

#ifdef WINNT  // Still needed by old DX6 Win2k driver!!
#define D3D_CONTEXT_LINEAR_TEXTURE_FROM_MEMORY                  0xD3D00201
#define D3D_CONTEXT_SWIZZLED_TEXTURE_FROM_MEMORY                0xD3D00202
#endif // Still needed by old DX6 win2k driver

#define D3D_CONTEXT_xxx_unused_xxx                              0xD3D00201
#define D3D_CONTEXT_DMA_HOST_MEMORY                             0xD3D00202  // pci or agp context (growable for surfaces)

// Surface contexts.
#define D3D_CONTEXT_SURFACE_SWIZZLED                            0xD3D05201
#define D3D_CONTEXT_SURFACES_ARGB_ZS                            0xD3D05301

// D3D 2D rendering objects.
#define D3D_RENDER_SOLID_RECTANGLE                              0xD3D05E01  // Currently used for Z and Buffer Clears
#define D3D_RENDER_SOLID_RECTANGLE_2                            0xD3D05E02  // pseudo texblit notifiers
#define D3D_GDI_RECTANGLE_TEXT                                  0xD3D04A01  // Currently used for Z and Buffer Clears -- NV20 style
#define D3D_GDI_RECTANGLE_TEXT_2                                0xD3D04A02  //
#define D3D_SCALED_IMAGE_FROM_MEMORY                            0xD3D07701  // Used for swizzling textures.

// D3D Triangle objects.
#define D3D_DX5_TEXTURED_TRIANGLE                               0xD3D05401  // DX5 class triangle renderer.
#define D3D_DX6_MULTI_TEXTURE_TRIANGLE                          0xD3D05501  // Multi Texture/Stencil triangle renderer.

// Celsius primitive
#define D3D_CELSIUS_PRIMITIVE                                   0xD3D05601

// Kelvin primitive
#define D3D_KELVIN_PRIMITIVE                                    0xD3D09701

// IPM allocator
#define IPM_DEVICE_HANDLE                                       0xD3D01010
#define IPM_MEMORY_OBJECT_LO                                    0x10000000  // low
#define IPM_MEMORY_OBJECT_HI                                    0x1FFFFFFF  // high

// AGP allocator
#define AGP_DEVICE_HANDLE                                       0xD3D01011
#define AGP_MEMORY_OBJECT_LO                                    0x10000000  // low
#define AGP_MEMORY_OBJECT_HI                                    0x1FFFFFFF  // high

// see nvpatchinterface.h
//ff// FD mutual exclusion 
//ff#define FD_SEMAPHORE_HANDLE                                     0xDDFD0000
//ff#define FD_SEMAPHORE_206E_CONTEXT_DMA                           0xDDFD0001
//ff#define FD_SEMAPHORE_097_CONTEXT_DMA                            0xDDFD0002
//ff//          ... 1-32 should be considered used here for our channels ... 
//ff//#define FD_SEMAPHORE_CONTEXT_DMA                              0xDDFD0020
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\nvi2c.h ===
/*----------------------------------------------------------------------------*/
/*
 * nvi2c.h
 *
 */

#ifdef __cplusplus
extern "C"
{
#endif

DWORD nvI2CInit ( ULONG ourRoot, ULONG ourDev, ULONG ourChannel, NvChannel* pNV, UINT subchan, UINT baseInst );
DWORD nvI2CUninit();
DWORD nvI2CWriteByte ( UCHAR chipAddr, UCHAR regAddr, UCHAR regData );
DWORD nvI2CReadByte ( UCHAR chipAddr, UCHAR regAddr, UCHAR* pData );
DWORD nvI2CWriteWord ( UCHAR chipAddr, UCHAR regAddr, USHORT regData );
DWORD nvI2CReadWord ( UCHAR chipAddr, UCHAR regAddr, USHORT* pData );
DWORD nvI2CWriteBuf ( UCHAR* pBuf, UINT bufSize );
DWORD nvI2CReadBuf ( UCHAR* pBuf, UINT bufSize, UCHAR* pData, UINT readBufSize );
DWORD nvI2CWrite(UCHAR chipAddr, DWORD subAddrLen, UCHAR* subAddr, DWORD dataLen, UCHAR* data);
DWORD nvI2CRead(UCHAR chipAddr, DWORD subAddrLen, UCHAR* subAddr, DWORD dataLen, UCHAR* data);

/* backdoors (hopefully temporary) */
DWORD nvI2CSetControlObj ( void* pObj );
VOID* nvI2CGetControlObj ();

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\VERSION.H ===
/****************************************************************************
*                                                                           *
* THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY     *
* KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE       *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR     *
* PURPOSE.                                                                  *
*                                                                           *
* Copyright (C) 1993-95  Microsoft Corporation.  All Rights Reserved.       *
*                                                                           *
****************************************************************************/

#define OFFICIAL   1 
#define FINAL      1 

/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the         *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values            *
 *                                                                          *
 ****************************************************************************/

#ifndef VS_FF_DEBUG 
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include "ver.h"
#endif 

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/

#ifndef FROSTING
/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/
/* NVidia's definitions for these live in nvver.h
#ifndef WIN32
#define VERSION                     "4.02.100"
#endif                            
#define VER_PRODUCTVERSION_STR      "4.02.100\0"
#define VER_PRODUCTVERSION          4,02,0,100
#define VER_PRODUCTVERSION_DW       (0x0402000 | 100)
*/
#else
/*--------------------------------------------------------------*/
/* FROSTING Builds will need a higher version # than Windows 95 */
/*--------------------------------------------------------------*/
#ifndef WIN32
#define VERSION                     "4.05"
#endif
#define VER_PRODUCTVERSION_STR      "4.05\0"
#define VER_PRODUCTVERSION          4,05,0,000
#define VER_PRODUCTVERSION_DW       (0x04050000 | 000)
#endif

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifndef DEBUG
#define VER_DEBUG                   0
#else
#define VER_DEBUG                   VS_FF_DEBUG
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS16
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"

#ifndef FROSTING
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#else
#define VER_PRODUCTNAME_STR         "Microsoft\256  Plus!  for  Windows\256  95\0"
#endif

#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\src\nvgpio.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvgpio.c
 *
 *	General purpose parallel bus support using NV_EXTERNAL_PARALLEL_BUS.
 *
 * Build Info:
 *
 *	These routines can be compiled for either Ring3 or Ring0 use.
 *	Use -DDRIVER and -DVXD when compiling into a VxD and -DDRIVER and 
 *	-DWDM when compiling into WDM.
 */

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#ifdef VXD

#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>

#else

#include <windows.h>

/* 
 * some defines/typedef's so we don't have to include all the windows stuff 

#define	TRUE	1

typedef unsigned char	BYTE;
typedef unsigned char	UCHAR;
typedef int 		BOOL;
typedef unsigned long	DWORD;
typedef unsigned int	UINT;
 */

#endif /* VXD */

/* NV includes */
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>
#include <nvcm.h>

/* some register defines for direct access */
#define NV_PME_VIPREG_NBYTES                             0x00200300
#define NV_PME_VIPREG_ADDR                               0x00200304
#define NV_PME_VIPREG_DATA                               0x00200308
#define NV_PME_VIPREG_CTRL                               0x0020030c

#ifdef DRIVER
#include <nvrmr0api.h>
#else
#include <nvrmapi.h>
#endif
#include <nvrmarch.inc>

#include "nvgpio.h"

/*----------------------------------------------------------------------------*/
/*
 * debug stuff
 */

#ifdef DEBUG
#ifdef DRIVER
#ifdef VXD
/* VXD driver debug */
#define DPRINTF0(fmt) _Sprintf(gpioDbgBuf, fmt); Out_Debug_String(gpioDbgBuf)
#define DPRINTF1(fmt, arg1) _Sprintf(gpioDbgBuf, fmt, arg1); Out_Debug_String(gpioDbgBuf)
#define DPRINTF2(fmt, arg1, arg2) _Sprintf(gpioDbgBuf, fmt, arg1, arg2); Out_Debug_String(gpioDbgBuf)
#else
/* WDM driver debug */
#define DPRINTF0(fmt) DbgPrint(fmt )
#define DPRINTF1(fmt, arg1) DbgPrint(fmt, arg1 )
#define DPRINTF2(fmt, arg1, arg2) DbgPrint(fmt, arg1, arg2 )
#endif /* VXD */
#else
/* Ring3 debug */
#include <stdio.h>
#define DPRINTF0(fmt) sprintf(gpioDbgBuf, fmt); OutputDebugString(gpioDbgBuf)
#define DPRINTF1(fmt, arg1) sprintf(gpioDbgBuf, fmt, arg1); OutputDebugString(gpioDbgBuf)
#define DPRINTF2(fmt, arg1, arg2) sprintf(gpioDbgBuf, fmt, arg1, arg2); OutputDebugString(gpioDbgBuf)
#endif /* DRIVER */
#else
/* non-debug */
#define DPRINTF0(fmt)
#define DPRINTF1(fmt, arg1)
#define DPRINTF2(fmt, arg1, arg2)
#endif /* DEBUG */

#ifdef DEBUG
static char	gpioDbgBuf[80];
#endif

/*----------------------------------------------------------------------------*/
/*
 * some nvgpio defines/typedef's
 */

#define	NVGPIO_PARALLEL_BUS_INST	0x50000010
#define	NVGPIO_NOTIFY_DMA_CONTEXT_INST	0x50000011

typedef struct _NVGPIO {
    ULONG		root;
    ULONG		dev;
    ULONG		channel;
    NvChannel*		pNV;
    UINT		subchannel;
#ifdef USE_NV_LINEAR_BASE_ADDR
    ULONG		deviceBase;
#endif
    NvNotification	nvNotifier[3];
} NVGPIO, *PNVGPIO;

#define	VIPREG_TIMEOUT_CNT	1000		// arbitrary

#ifdef DRIVER
#define	NVRM_ALLOC_ROOT		NvRmR0AllocRoot
#define	NVRM_ALLOC_DEVICE	NvRmR0AllocDevice
#define	NVRM_ALLOC_CHANNEL_PIO	NvRmR0AllocChannelPio
#define	NVRM_ALLOC_CONTEXT_DMA	NvRmR0AllocContextDma
#define	NVRM_ALLOC_OBJECT	NvRmR0AllocObject
#define	NVRM_FREE		NvRmR0Free
#define	NVRM_INTERRUPT		NvRmR0Interrupt
#else
#define	NVRM_ALLOC_ROOT		NvRmAllocRoot
#define	NVRM_ALLOC_DEVICE	NvRmAllocDevice
#define	NVRM_ALLOC_CHANNEL_PIO	NvRmAllocChannelPio
#define	NVRM_ALLOC_CONTEXT_DMA	NvRmAllocContextDma
#define	NVRM_ALLOC_OBJECT	NvRmAllocObject
#define	NVRM_FREE		NvRmFree
#define	NVRM_INTERRUPT		NvRmInterrupt
#endif

void ourYield();

#ifdef DRIVER
#ifdef USE_NV_LINEAR_BASE_ADDR
extern ULONG callRmAPI(ULONG, DWORD, PVOID);
#endif
#endif

/*----------------------------------------------------------------------------*/
/*
 * global GPIO control object
 *
 * XXX it might be better to allocate this object elsewhere
 */

static NVGPIO	nvGPIO;
static PNVGPIO	pGPIO = &nvGPIO;

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOInit
 */

DWORD nvGPIOInit ( 
    ULONG	ourRoot,
    ULONG	ourDev,
    ULONG	ourChannel,
    NvChannel*	pNV,
    UINT	subchan )
{

    UINT	i;
    ULONG	flags;
    DWORD	rc;
    DWORD	err;
    UCHAR*	pNotifyBuf;

    DPRINTF0("nvGPIOInit: entering\n");

    /*
     * create an EXTERNAL_PARALLEL_BUS object
     */

    err = NVRM_ALLOC_OBJECT(ourRoot, ourChannel, NVGPIO_PARALLEL_BUS_INST, NV01_EXTERNAL_PARALLEL_BUS);

    if ( err != NVOS05_STATUS_SUCCESS ) {
	DPRINTF0("nvGPIOInit: NVRM_ALLOC_OBJECT of EXTERNAL_PARALLEL_BUS failed\n");
	return(1);
    }

    /*
     * initialize notifier for parallel bus object
     */

    DPRINTF0("nvGPIOInit: clearing notifier memory\n");

    pNotifyBuf = (UCHAR*) &(pGPIO->nvNotifier);
    for ( i = 0; i < sizeof(NvNotification)*3; i++ )
	pNotifyBuf[i] = 0;

    DPRINTF0("nvGPIOInit: initializing NvNotification objects\n" );

    pGPIO->nvNotifier[NV04F_NOTIFIERS_NOTIFY].status = 0;
    pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 0;
    pGPIO->nvNotifier[NV04F_NOTIFICATION_SET_INTERRUPT_NOTIFY].status = 0;

    /*
     * create DMA-to-memory context for notifer and plug in notify memory
     */

    DPRINTF0("nvGPIOInit: creating CONTEXT_DMA_TO_MEMORY object\n");

    flags = ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED;
    rc = NVRM_ALLOC_CONTEXT_DMA(ourRoot,
    			     NVGPIO_NOTIFY_DMA_CONTEXT_INST,
			     NV01_CONTEXT_DMA,
			     flags,
			     (PVOID) pNotifyBuf,
			     sizeof(NvNotification)*3 - 1 );
    if ( rc != ALLOC_CTX_DMA_STATUS_SUCCESS ) {
	DPRINTF0( "nvGPIOInit: NVRM_ALLOC_CONTEXT_DMA failed\n" );
	return(1);
    }

    /*
     * plug notifier into parallel bus object
     */

    DPRINTF0("nvGPIOInit: plugging notifier into parallel bus object\n");

    while ( pNV->subchannel[subchan].control.Free < 2*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv01ExternalParallelBus.SetContextDmaNotifies = 
	NVGPIO_NOTIFY_DMA_CONTEXT_INST;

#ifdef USE_NV_LINEAR_BASE_ADDR
#ifdef DRIVER
    pGPIO->deviceBase = callRmAPI(1050,0,NULL);	 /* 1050 = NVRM_API_GET_NV_ADDRESS */
#else
    pGPIO->deviceBase = NvDeviceBaseGet(NV_DEV_BASE,1);
#endif
#endif

    /*
     * misc wrap-up
     */

    DPRINTF0("nvGPIOInit: misc wrap-up\n");

    pGPIO->root = ourRoot;
    pGPIO->dev = ourDev;
    pGPIO->channel = ourChannel;
    pGPIO->pNV = pNV;
    pGPIO->subchannel = subchan;

    DPRINTF0("nvGPIOInit: exiting successfully\n");

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOUninit
 */

DWORD nvGPIOUninit()
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;

    DPRINTF0("nvGPIOUninit: entering\n");

    /*
     * XXX The below commented out code is to prevent a race condition with
     *     the synchronous NvRmFree's that occur afterwards.  The solution is
     *     to use NvRmInterrupt and watch the free count to tell when it's safe
     *     to use the synchronous free function.
     */

#ifdef COMMENT

    /*
     * unplug the context dma object
     */

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv01ExternalParallelBus.SetContextDmaNotifies = 0;

#endif /* COMMENT */

    /*
     * destroy objects created in nvGPIOInit
     */

    NVRM_FREE(pGPIO->root, pGPIO->channel, NVGPIO_PARALLEL_BUS_INST);
    NVRM_FREE(pGPIO->root, pGPIO->root, NVGPIO_NOTIFY_DMA_CONTEXT_INST);

    DPRINTF0("nvGPIOUninit: exiting successfully\n");

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOWrite - do a GPIO write of a byte
 *
 * Note: only single byte addresses are supported at this time
 */

DWORD nvGPIOWrite (
    DWORD	regAddr,
    BYTE	regData )
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;
    UINT	cnt;
    DWORD	vipCtrl;

    DPRINTF0("nvGPIOWrite: entering\n");

#ifdef USE_NV_LINEAR_BASE_ADDR

#ifdef NV10
    // Make sure there isn't a write pending
    cnt = 0;
    while ( (vipCtrl = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES))) & 0x100 ) {
	if ( ++cnt > VIPREG_TIMEOUT_CNT )
	    return(1);
    }
    // Do the write now
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES)) = 1;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_ADDR)) = (regAddr & 0xffff);
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_DATA)) = (DWORD)regData;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_CTRL)) = 0x100;
#else
    *((DWORD*)(pGPIO->deviceBase | 0x00200800 | regAddr*4)) = regData;
#endif

#else

    /*
     * send write request to the parallel bus object
     */

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteSize = 0x00010001;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteAddress = (U032)regAddr;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteData = (U032)regData;

#endif /* USE_NV_LINEAR_BASE_ADDR */

    DPRINTF0("nvGPIOWrite: exiting\n");

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIORead - do a GPIO read of a byte
 *
 * Note: only single byte addresses are supported at this time
 */

DWORD nvGPIORead (
    DWORD	regAddr,
    BYTE*	pData )
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;
    UINT	cnt;
    DWORD	vipCtrl;

    DPRINTF0( "nvGPIORead: entering\n" );

#ifdef USE_NV_LINEAR_BASE_ADDR

#ifdef NV10
    // go ahead and setup the read (XXX assumes there isn't another read in progress
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES)) = 1;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_ADDR)) = (regAddr & 0xffff);
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_CTRL)) = 0x1;
    // wait for the read to complete
    cnt = 0;
    while ( (vipCtrl = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES))) & 0x1 ) {
	if ( ++cnt > VIPREG_TIMEOUT_CNT )
	    return(1);
    }
    *pData = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_DATA));
#else
    *pData = *((DWORD*)(pGPIO->deviceBase | 0x00200800 | regAddr*4));
#endif

#else

    /*
     * clear the notifier
     */

    pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV04F_NOTIFICATION_STATUS_IN_PROGRESS;

    /*
     * send read request to the parallel bus object
     */

    DPRINTF0( "nvGPIORead: sending read request\n" );

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = 0x00010001;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = (U032)regAddr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV04F_NOTIFY_WRITE_ONLY;

    /*
     * wait for read to complete
     */

    DPRINTF0( "nvGPIORead: waiting for read to complete\n" );

    while ( (volatile) (pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	NV04F_NOTIFICATION_STATUS_IN_PROGRESS ) ourYield();

    /*
     * get the read data
     */

    *pData = (UCHAR)(volatile)(pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);

#endif /* USE_NV_LINEAR_BASE_ADDR */

    DPRINTF0( "nvGPIORead: exiting\n" );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvVIPWrite
 */

DWORD nvVIPWrite (
    DWORD	regAddr,
    DWORD	regData,
    DWORD	dataSize )
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;
    UINT	cnt;
    DWORD	vipCtrl;

    DPRINTF0("nvVIPWrite: entering\n");

#ifdef USE_NV_LINEAR_BASE_ADDR

#ifdef NV10
    // Make sure there isn't a write pending
    cnt = 0;
    while ( (vipCtrl = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES))) & 0x100 ) {
	if ( ++cnt > VIPREG_TIMEOUT_CNT )
	    return(1);
    }
    // Do the write now
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES)) = dataSize;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_ADDR)) = (regAddr & 0xffff);
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_DATA)) = (DWORD)regData;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_CTRL)) = 0x100;
#endif

#else

    /*
     * send write request to the parallel bus object
     */

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteSize = 0x00020000 | dataSize;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteAddress = (U032)regAddr;
    pNV->subchannel[subchan].nv01ExternalParallelBus.WriteData = (U032)regData;

#endif /* USE_NV_LINEAR_BASE_ADDR */

    DPRINTF0("nvVIPWrite: exiting\n");

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvVIPRead
 */

DWORD nvVIPRead (
    DWORD	regAddr,
    DWORD*	pData,
    DWORD	dataSize )
{

    NvChannel*	pNV = pGPIO->pNV;
    UINT	subchan = pGPIO->subchannel;
    UINT	cnt;
    DWORD	vipCtrl;

    DPRINTF0( "nvVIPRead: entering\n" );

#ifdef USE_NV_LINEAR_BASE_ADDR

#ifdef NV10
    // go ahead and setup the read (XXX assumes there isn't another read in progress
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES)) = 1;
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_ADDR)) = (regAddr & 0xffff);
    *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_CTRL)) = 0x1;
    // wait for the read to complete
    cnt = 0;
    while ( (vipCtrl = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_NBYTES))) & 0x1 ) {
	if ( ++cnt > VIPREG_TIMEOUT_CNT )
	    return(1);
    }
    *pData = *((DWORD*)(pGPIO->deviceBase | NV_PME_VIPREG_DATA));
#endif

#else

    /*
     * clear the notifier
     */

    pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV04F_NOTIFICATION_STATUS_IN_PROGRESS;

    /*
     * send read request to the parallel bus object
     */

    DPRINTF0( "nvVIPRead: sending read request\n" );

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = NVGPIO_PARALLEL_BUS_INST;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = 0x00020000 | dataSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = (U032)regAddr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV04F_NOTIFY_WRITE_ONLY;

    /*
     * wait for read to complete
     */

    DPRINTF0( "nvVIPRead: waiting for read to complete\n" );

    while ( (volatile) (pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	NV04F_NOTIFICATION_STATUS_IN_PROGRESS ) ourYield();

    /*
     * get the read data
     */

    *pData = (UCHAR)(volatile)(pGPIO->nvNotifier[NV04F_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);

#endif /* USE_NV_LINEAR_BASE_ADDR */

    DPRINTF0( "nvVIPRead: exiting\n" );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvRegWrite
 */

DWORD nvRegWrite (
    DWORD	regAddr,
    UINT	regData )
{

    DPRINTF0("nvRegWrite: entering\n");

#ifdef USE_NV_LINEAR_BASE_ADDR

    *((DWORD*)(pGPIO->deviceBase | regAddr)) = regData;

#endif

    DPRINTF0("nvRegWrite: exiting\n");

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvRegRead
 */

DWORD nvRegRead (
    DWORD	regAddr,
    UINT*	pData )
{

    DPRINTF0( "nvRegRead: entering\n" );

#ifdef USE_NV_LINEAR_BASE_ADDR

    *pData = *((DWORD*)(pGPIO->deviceBase | regAddr));

#endif

    DPRINTF0( "nvRegRead: exiting\n" );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * __GetFlatDataSelector - duplicate of NvGetFlatDataSelector()
 *
 * XXX Eventually, this function will be provided to us.
 */

int __GetFlatDataSelector()
{
    DWORD	Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*----------------------------------------------------------------------------*/
/*
 * ourYield()
 */

#ifdef VXD
VOID VXDINLINE
Time_Slice_Sleep(DWORD timeout)
{
    __asm mov eax, timeout
    VMMCall(Time_Slice_Sleep);
}
#endif

static void ourYield()
{
    NVRM_INTERRUPT(pGPIO->root, pGPIO->dev);
}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOSetControlObj - backdoor to set the ptr the global control object
 */

DWORD nvGPIOSetControlObj (
    VOID*	pObj )
{

    pGPIO = (NVGPIO*) pObj;

    DPRINTF0( "nvGPIOSetControlObj: exiting successfully\n" );

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvGPIOGetControlObj - backdoor to get the ptr the global control object
 */

VOID* nvGPIOGetControlObj ()
{

    DPRINTF0( "nvGPIOGetControlObj: exiting successfully\n" );

    return(pGPIO);

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\nvntd3d.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1995 Microsoft Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1995, 1998 NVidia Corporation.  All Rights Reserved.
 *  Portions Copyright (C) 1997 SGS-THOMSON Microelectronics  All Rights Reserved.
 *
 *  File:       nvd3ddrv.c
 *  Content:    master D3D include file - OS specific includes
 *
 ***************************************************************************/
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Type redefs excluded from dx95type.h.
//
#pragma warning(disable:4005)

#if (DIRECT3D_VERSION >= 0x0800)

#define D3DERR_TEXTURE_CREATE_FAILED MAKE_DDHRESULT(721)
#define D3DRS_EXTENTS 138

/*
 * This DDPF flag is used to indicate a DX8+ format capability entry in
 * the texture format list. It is not visible to applications.
 */
#define DDPF_D3DFORMAT                                          0x00200000l

/*
 * List of operations supported on formats in DX8+ texture list.
 * See the DX8 DDK for a complete description of these flags.
 */
#define D3DFORMAT_OP_TEXTURE                    0x00000001L
#define D3DFORMAT_OP_VOLUMETEXTURE              0x00000002L
#define D3DFORMAT_OP_CUBETEXTURE                0x00000004L
#define D3DFORMAT_OP_OFFSCREEN_RENDERTARGET     0x00000008L
#define D3DFORMAT_OP_SAME_FORMAT_RENDERTARGET   0x00000010L
#define D3DFORMAT_OP_BACKBUFFER                 0x00000020L
#define D3DFORMAT_OP_ZSTENCIL                   0x00000040L
#define D3DFORMAT_OP_ZSTENCIL_WITH_ARBITRARY_COLOR_DEPTH 0x00000080L

// D3DFORMAT_OP_D3DFMT_D16_LOCKABLE
// --------------------------------
//
// This flag is only valid on a format op list entry for D3DFMT_D16.
// This flag implies that the format is true 16 bit unsigned integer.
// This flag implies that the contents of a Z buffer of this format
// are persistent:
//  - The contents of the Z buffer will be the same from
//    the last EndScene (SceneCapture) to the next BeginScene.
//  - The contents of the Z buffer are not lost if the Z buffer
//    is attached to a different render target (until rendering takes
//    place, of course).
// This flag implies that data can be copied from one such surface
// to another (vidmem to vidmem, no stretch) via the Blt DDI.
#define D3DFORMAT_OP_D3DFMT_D16_LOCKABLE        0x00000200L

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * an index buffer.
 */
#define DDSCAPS2_INDEXBUFFER                    DDSCAPS2_RESERVED3

#else  // !(DIRECT3D_VERSION >= 0x0800)

typedef D3DNTHAL_DP2POINTS *LPD3DNTHAL_DP2POINTS;
typedef D3DNTHAL_DP2RENDERSTATE *LPD3DNTHAL_DP2RENDERSTATE;
typedef D3DNTHAL_DP2LINELIST *LPD3DNTHAL_DP2LINELIST;
typedef D3DNTHAL_DP2INDEXEDLINELIST *LPD3DNTHAL_DP2INDEXEDLINELIST;
typedef D3DNTHAL_DP2LINESTRIP *LPD3DNTHAL_DP2LINESTRIP;
typedef D3DNTHAL_DP2TRIANGLELIST *LPD3DNTHAL_DP2TRIANGLELIST;
typedef D3DNTHAL_DP2INDEXEDTRIANGLELIST *LPD3DNTHAL_DP2INDEXEDTRIANGLELIST; // nV addition
typedef D3DNTHAL_DP2TRIANGLESTRIP *LPD3DNTHAL_DP2TRIANGLESTRIP;
typedef D3DNTHAL_DP2TRIANGLEFAN *LPD3DNTHAL_DP2TRIANGLEFAN;
typedef D3DNTHAL_DP2TEXTURESTAGESTATE *LPD3DNTHAL_DP2TEXTURESTAGESTATE;
typedef D3DNTHAL_D3DEXTENDEDCAPS D3DHAL_D3DEXTENDEDCAPS;
typedef LPD3DNTHAL_DP2POINTS LPD3DHAL_DP2POINTS;
typedef LPD3DNTHAL_DP2RENDERSTATE LPD3DHAL_DP2RENDERSTATE;
typedef LPD3DNTHAL_DP2STATESET LPD3DHAL_DP2STATESET;
typedef LPD3DNTHAL_DP2ZRANGE LPD3DHAL_DP2ZRANGE;
typedef LPD3DNTHAL_DP2TEXBLT LPD3DHAL_DP2TEXBLT;
typedef LPD3DNTHAL_DP2SETPRIORITY LPD3DHAL_DP2SETPRIORITY;
typedef LPD3DNTHAL_DP2LINELIST LPD3DHAL_DP2LINELIST;
typedef LPD3DNTHAL_DP2INDEXEDLINELIST LPD3DHAL_DP2INDEXEDLINELIST;
typedef LPD3DNTHAL_DP2LINESTRIP LPD3DHAL_DP2LINESTRIP;
typedef LPD3DNTHAL_DP2STARTVERTEX LPD3DHAL_DP2STARTVERTEX;
typedef LPD3DNTHAL_DP2TRIANGLELIST LPD3DHAL_DP2TRIANGLELIST;
typedef LPD3DNTHAL_DP2INDEXEDTRIANGLELIST LPD3DHAL_DP2INDEXEDTRIANGLELIST;   // nV addition
typedef LPD3DNTHAL_DP2INDEXEDTRIANGLELIST2 LPD3DHAL_DP2INDEXEDTRIANGLELIST2; // nV addition
typedef LPD3DNTHAL_DP2TRIANGLESTRIP LPD3DHAL_DP2TRIANGLESTRIP;
typedef LPD3DNTHAL_DP2TRIANGLEFAN LPD3DHAL_DP2TRIANGLEFAN;
typedef LPD3DNTHAL_DP2TEXTURESTAGESTATE LPD3DHAL_DP2TEXTURESTAGESTATE;
typedef LPD3DNTHAL_DP2VIEWPORTINFO LPD3DHAL_DP2VIEWPORTINFO;
typedef LPD3DNTHAL_DP2WINFO LPD3DHAL_DP2WINFO;
typedef LPD3DNTHAL_DP2TRIANGLEFAN_IMM LPD3DHAL_DP2TRIANGLEFAN_IMM;
typedef LPD3DNTHAL_DP2SETRENDERTARGET LPD3DHAL_DP2SETRENDERTARGET;
typedef LPD3DNTHAL_DP2CLEAR LPD3DHAL_DP2CLEAR;
typedef LPD3DNTHAL_DP2SETCLIPPLANE LPD3DHAL_DP2SETCLIPPLANE;
typedef LPD3DNTHAL_DP2SETLIGHT LPD3DHAL_DP2SETLIGHT;
typedef LPD3DNTHAL_DP2SETMATERIAL LPD3DHAL_DP2SETMATERIAL;
typedef LPD3DNTHAL_DP2SETTRANSFORM LPD3DHAL_DP2SETTRANSFORM;
typedef LPD3DNTHAL_DP2CREATELIGHT LPD3DHAL_DP2CREATELIGHT;

#endif  // !(DIRECT3D_VERSION >= 0x0800)

typedef DD_D3DBUFCALLBACKS DDHAL_DDEXEBUFCALLBACKS;
typedef PDD_D3DBUFCALLBACKS LPDDHAL_DDEXEBUFCALLBACKS;
typedef PDD_SURFACE_INT LPDDRAWI_DDRAWSURFACE_INT;
typedef DD_MISCELLANEOUSCALLBACKS DDHAL_DDMISCELLANEOUSCALLBACKS;
typedef DD_MORESURFACECAPS DDMORESURFACECAPS;
typedef DD_NONLOCALVIDMEMCAPS DDNONLOCALVIDMEMCAPS;
typedef PDD_NONLOCALVIDMEMCAPS LPDDNONLOCALVIDMEMCAPS;

/*
 * DirectX7 types not redefined in DX95TYPE.H
 */
typedef PDD_DIRECTDRAW_LOCAL  LPDDRAWI_DIRECTDRAW_LCL;
#define NvGetFlatDataSelector() (0xffffffff)
// Values for dwDataType in D3DHAL_DP2SETLIGHT
#define D3DHAL_SETLIGHT_ENABLE   0
#define D3DHAL_SETLIGHT_DISABLE  1
// If this is set, light data will be passed in after the
// D3DLIGHT7 structure
#define D3DHAL_SETLIGHT_DATA     2

#define D3DHAL2_CB32_CLEAR              0x00000002L
#define D3DHAL2_CB32_DRAWONEPRIMITIVE   0x00000004L
#define D3DHAL2_CB32_DRAWONEINDEXEDPRIMITIVE 0x00000008L
#define D3DHAL2_CB32_DRAWPRIMITIVES     0x00000010L

/*
 * NT doesn't define the DX5 Clear routine's data structure, but the DX5 driver
 * routine can still be called from the DX6 clear routine to do fast buffer
 * clears, so need to define this ourselves (taken from d3d.h)
 */
#if (DIRECT3D_VERSION < 0x0800)

#ifndef IA64
typedef struct _D3DHAL_CLEARDATA
{
    DWORD               dwhContext;     // in:  Context handle

    // dwFlags can contain D3DCLEAR_TARGET or D3DCLEAR_ZBUFFER
    DWORD               dwFlags;        // in:  surfaces to clear

    DWORD               dwFillColor;    // in:  Color value for rtarget
    DWORD               dwFillDepth;    // in:  Depth value for Z buffer

    LPD3DRECT           lpRects;        // in:  Rectangles to clear
    DWORD               dwNumRects;     // in:  Number of rectangles

    HRESULT             ddrval;         // out: Return value
} D3DHAL_CLEARDATA;
typedef D3DHAL_CLEARDATA FAR *LPD3DHAL_CLEARDATA;
#endif

/*
 * DX7 DP2 structs not yet defined in d3dnthal.h.
 */
typedef D3DNTHAL_DP2SETTEXLOD   D3DHAL_DP2SETTEXLOD;
typedef LPD3DNTHAL_DP2SETTEXLOD LPD3DHAL_DP2SETTEXLOD;

#endif  // DIRECT3D_VERSION < 0x0800

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * a vertex buffer. Used by CreateVertexBuffer in D3D
 */
#define DDSCAPS2_VERTEXBUFFER                   DDSCAPS2_RESERVED1

/*
 * Indicates to the driver that the "execute" buffer that is to be created is actually
 * a command buffer. Used by internally in D3D
 */
#define DDSCAPS2_COMMANDBUFFER                  DDSCAPS2_RESERVED2

/*
 * Macros for GDI functions missing from Win2K.
 */
#define IntersectRect(pIntersect, pSrc, pDst) \
    bIntersect((PRECTL) (pSrc), (PRECTL) (pDst), (PRECTL) (pIntersect))

/*
 * Macros for DirectX heap manager functions. Under Win2k, these macros
 * call wrapper functions which massage the parameters, call the DX
 * heap manager,  and adjust the offset of the surface returned by the
 * the heap manager. This is done to minimize changes the the common code.
 */
typedef struct _GLOBALDATA GLOBALDATA;
FLATPTR NvWin2kDxAllocMem(GLOBALDATA *pDriverData, ULONG ulHeapId, ULONG ulSize);
#define DDHAL32_VidMemAlloc(pdrv, heap, x, y) \
    NvWin2kDxAllocMem(pDriverData, (heap), ((x) * (y)))

void NvWin2kDxFreeMem(GLOBALDATA *pDriverData, ULONG ulHeapId, FLATPTR fpOffset);
#define DDHAL32_VidMemFree(pdrv, heap, surface) \
    NvWin2kDxFreeMem(pDriverData, (heap), (surface))

/*
 * Actual protos for the NT display driver functions which perform the
 * Ioctl call to These represent the "OS Independent" RM entry points. For NT they are functions
 * in the display driver which package the parms into a IOCTL packet and make
 * an IOCTL call to the miniport where the RM lives.
 * For WinNT, these are defined in nvapi.c
 */
HANDLE  __cdecl NvOpen            (HANDLE);
VOID    __cdecl NvClose           (HANDLE);

// control codes
ULONG __cdecl NvAllocRoot       (HANDLE, ULONG, ULONG*);
ULONG __cdecl NvAllocDevice     (HANDLE, ULONG, ULONG, ULONG, PUCHAR);
ULONG __cdecl NvAllocContextDma (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvAllocChannelPio (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG);
ULONG __cdecl NvAllocChannelDma (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*);
ULONG __cdecl NvAllocMemory     (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG*);
ULONG __cdecl NvAllocObject     (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG __cdecl NvAlloc           (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID);
ULONG __cdecl NvFree            (HANDLE, ULONG, ULONG, ULONG);
#if !defined(WINNT) || defined(IA64)
ULONG __cdecl NvAllocEvent      (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID);
#else
ULONG __cdecl NvAllocEvent      (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG);
#endif
ULONG __cdecl NvFree            (HANDLE, ULONG, ULONG, ULONG);
ULONG __cdecl NvDmaFlowControl  (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG __cdecl NvArchHeap        (HANDLE, PVOID);
ULONG __cdecl NvConfigVersion   (HANDLE, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigGet       (HANDLE, ULONG, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigGetEx     (HANDLE, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvConfigSet       (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigSetEx     (HANDLE, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvConfigUpdate    (HANDLE, ULONG, ULONG, ULONG);
ULONG __cdecl NvGetDmaPushInfo  (HANDLE, ULONG, ULONG, ULONG, ULONG,ULONG);

/*
 * These represent the "OS Independent" RM entry points. For NT they are functions
 * in the display driver which package the parms into a IOCTL packet and make
 * an IOCTL call to the miniport where the RM lives.
 */

#define NvRmOpen() (!NULL)

#define NvRmClose() NULL

#define NvRmAllocRoot(pClient) \
        NvAllocRoot(ppdev->hDriver, NV01_ROOT, (pClient))

#define NvRmAllocDevice(hClient, hDevice, hClass, pName) \
    NvAllocDevice(ppdev->hDriver, hClient, hDevice, NV03_DEVICE_XX, (pName))
#define NvRmAllocContextDma(hClient, hDma, hClass, flags, base, limit) \
        NvAllocContextDma(ppdev->hDriver, hClient, hDma, hClass, flags, base, limit)

#define NvRmAlloc(hCli, hChan, hObj, hCls, parms) \
        NvAlloc(ppdev->hDriver, hCli, hChan, hObj, hCls, parms)

#define NvRmFree(hClient, hParent, hObj) \
        NvFree(ppdev->hDriver, hClient, hParent, hObj)

#define NvRmAllocChannelPio(hClient, hDev, hChan, hClass, hErrorCtx, ppChan, flags) \
        NvAllocChannelPio(ppdev->hDriver, (hClient), hDev, (hChan), (hClass), (hErrorCtx), (ppChan), (flags))

#define NvRmAllocChannelDma(hClient, hDev, hChan, hClass, hErrorCtx, hDataCtx, offset, ppChan) \
        NvAllocChannelDma(ppdev->hDriver, (hClient), hDev, (hChan), (hClass), (hErrorCtx), (hDataCtx), (offset), (ppChan))

#define NvRmAllocMemory(hClient, hPar, hMem, hClass, fl, ppAddr, pLim) \
        NvAllocMemory(ppdev->hDriver, hClient, hPar, hMem, hClass, fl, ppAddr, pLim)

#define NvRmAllocObject(hCli, hChan, hObj, hCls) \
        NvAllocObject(ppdev->hDriver, hCli, hChan, hObj, hCls)

#define NvRmGetConfigEx(hCli, hDevice, index, pValue, dummy) \
        NvGetConfigEx(ppdev->hDriver, hCli, hDevice, index, (pValue))

#define NvRmConfigGet(hCli, hDevice, index, pValue) \
        NvConfigGet(ppdev->hDriver, hCli, hDevice, index, (pValue))
#define NvRmConfigGetEx(hCli, hDevice, index, pParams, paramSize) \
        NvConfigGetEx(ppdev->hDriver, hCli, hDevice, index, pParams, paramSize)

#define NvRmConfigSet(hCli, hDev, index, newValue, pOldValue) \
        NvConfigSet(ppdev->hDriver, hCli, hDev, index, newValue, (pOldValue))

#define NvRmAllocObject(hCli, hChan, hObj, hCls) \
        NvAllocObject(ppdev->hDriver, hCli, hChan, hObj, hCls)

#if !defined(WINNT) || defined(IA64)
#define NvRmAllocEvent(hCli, hPar, hObjNew, hClass, index, hEvent) \
        NvAllocEvent(ppdev->hDriver, hCli, hPar, hObjNew, hClass, index, hEvent)

#else
#define NvRmAllocEvent(hCli, hPar, hObjNew, hClass, index, hEvent) \
        NvAllocEvent(ppdev->hDriver, hCli, hPar, hObjNew, hClass, index, (ULONG)hEvent)

#endif
#define NV_SLEEP     Sleep(0)
#define NV_SLEEP1    Sleep(1)
#define NV_SLEEP2    Sleep(2)
#define NV_SLEEP3    Sleep(3)
#define NV_SLEEP4    Sleep(4)
#define NV_SLEEP5    Sleep(5)
#define NV_SLEEPFLIP Sleep(1)

#define SetPriorityClass(a, b)
#define SetThreadPriority(a, b)
#define GetCurrentThread()
#define GetSystemInfo(a)
#define GetCurrentProcessId() ((DWORD)EngGetCurrentProcessId())
#define IsBadReadPtr(nop, nop1) ((nop) == NULL)
#define RegCloseKey(nop) NULL;

/*
 Obtain the amount of available memory in megabytes.
 */
#define GlobalMemoryStatus(pms) \
    (pms)->dwTotalPhys = (DWORD)ppdev->SysMemInfo.SystemMemorySize

#define EXTERN_DDAPI    WINAPI

/*
 * Global memory allocation macros.
 */
#define HeapCreate(nop, nop1, nop2)       (!NULL)
#define HeapDestroy(heap)                 (TRUE)
#define HeapAlloc(nop, nop1, size)            EngAllocMem(FL_ZERO_MEMORY, (size), 'x_VN')
#define HeapFree(nop, nop1, ptr)              { \
    if (ptr != NULL)            \
    {                           \
    EngFreeMem((ptr));          \
    }                           \
}
#define HeapRealloc(nop, ptr, size)     {   \
                                            HeapFree(nop, nop, (ptr)); \
                                            *((PULONG)(ptr)) = HeapAlloc(nop, nop, size); \
                                        }

// HeapSize should never be used on NT. it doesn't work.
#define HeapSize(nop,nop1,nop2)         { _asm int 3 }

/*
 * User mode memory allocation functions. There are no Globalxxx fcts in NT
 * kernel mode.
 */
#define GlobalAlloc(nop, size)  \
    EngAllocUserMem((size), 'x_VN')
#define GlobalLock(ptr) (ptr)
#define GlobalUnlock(nop)
#define GlobalFree(ptr)     \
    EngFreeUserMem(ptr)
#define Sleep(time)         \
    nvDelay()
#define GetCurrentProcess() \
    EngGetProcessHandle()

#define GetThreadPriority(a) \
    (0)
#define GetPriorityClass(a) \
    (0)
#define ConvertRing3EventToRing0(a) \
    HANDLE (0)
#define CreateEventA(a, b, c, d) \
    (0)
#define CreateThread(a, b, c, d, e, f) \
    (0)
#define OpenEventA(a, b, c) \
    (0)
#define CloseHandle(a)
#define GetTickCount()  0

//
// WINNT BUG - disable misc C lib, OS functions til we come up with a better
// solution.
//

#ifdef CreateFile
#undef CreateFile
#endif
#define CreateFile(a,b,c,d,e,f,g) (INVALID_HANDLE_VALUE)

#ifdef WriteFile
#undef WriteFile
#endif
#define WriteFile(a,b,c,d,e)

#ifdef SetFilePointer
#undef SetFilePointer
#endif
#define SetFilePointer(a,b,c,d)

#ifdef FlushFileBuffers
#undef FlushFileBuffers
#endif
#define FlushFileBuffers(a)

#ifdef QueryPerformanceCounter
#undef QueryPerformanceCounter
#endif
#define QueryPerformanceCounter(a) EngQueryPerformanceCounter((__int64 *)a)

#ifdef QueryPerformanceFrequency
#undef QueryPerformanceFrequency
#endif
#define QueryPerformanceFrequency(a) EngQueryPerformanceFrequency((__int64 *)a)

#ifdef RegQueryValueEx
#undef RegQueryValueEx
#endif
#define RegQueryValueEx(a,b,c,d,e,f) TRUE

#ifdef RegOpenKeyEx
#undef RegOpenKeyEx
#endif
#define RegOpenKeyEx(a,b,c,d,e) TRUE

#ifdef IsBadReadPtr
#undef IsBadReadPtr
#endif
#define IsBadReadPtr(a,b) FALSE

#ifdef IsBadWritePtr
#undef IsBadWritePtr
#endif
#define IsBadWritePtr(a,b) FALSE

/*
 * Debug print function, defined in NT display driver file DEBUG.C.
 */
#if defined(DEVELOP) || defined(DEBUG)
VOID DebugPrint(
    LONG  DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );
#endif // (DEVELOP || DEBUG)

#ifdef __cplusplus
}
#endif // __cplusplus

#define DX7_DEVICE_OBJECT_HANDLE 0x0c7c6c5
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\src\nvi2c.c ===
/*----------------------------------------------------------------------------*/
/*
 * nvi2c.c
 *
 *	I2C functionality using the NV_EXTERNAL_SERIAL_BUS object.
 *
 * Build Info:
 *
 *	These routines can be compiled for either Ring3 or Ring0 use.
 *	Use -DDRIVER and -DVXD when compiling into a VxD and -DDRIVER and 
 *	-DWDM when compiling into WDM.
 */

#ifdef nv3
#define	NV3
#endif

#ifdef nv4
#define	NV4
#endif

#ifdef nv10
#define	NV10
#endif

/*----------------------------------------------------------------------------*/
/*
 * include files
 */

#ifdef VXD

#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>

#else

#include <stdio.h>
#include <windows.h>

/* 
 * some defines/typedef's so we don't have to include all the windows stuff 

#define	TRUE	1

typedef unsigned char	BYTE;
typedef unsigned char	UCHAR;
typedef int 		BOOL;
typedef unsigned long	DWORD;
typedef unsigned int	UINT;
typedef unsigned short	USHORT;
 */

#endif /* VXD */

/* NV includes */
#include <nv32.h>
#include <nvtypes.h>
#include <nvmacros.h>
#include <nvwin32.h>
#include <nvos.h>

#ifdef DRIVER
#include <nvrmr0api.h>
#else
#include <nvrmapi.h>
#endif

#include "nvi2c.h"

/*----------------------------------------------------------------------------*/
/*
 * debug stuff
 */

#ifdef DEBUG
#ifdef DRIVER
#ifdef VXD
/* VXD driver debug */
#define DPRINTF0(fmt) _Sprintf(i2cDbgBuf, fmt); Out_Debug_String(i2cDbgBuf)
#define DPRINTF1(fmt, arg1) _Sprintf(i2cDbgBuf, fmt, arg1); Out_Debug_String(i2cDbgBuf)
#define DPRINTF2(fmt, arg1, arg2) _Sprintf(i2cDbgBuf, fmt, arg1, arg2); Out_Debug_String(i2cDbgBuf)
#else
/* WDM driver debug */
#define DPRINTF0(fmt) DbgPrint(fmt )
#define DPRINTF1(fmt, arg1) DbgPrint(fmt, arg1 )
#define DPRINTF2(fmt, arg1, arg2) DbgPrint(fmt, arg1, arg2 )
#endif /* VXD */
#else
/* Ring3 debug */
#include <stdio.h>
#define DPRINTF0(fmt) sprintf(i2cDbgBuf, fmt); OutputDebugString(i2cDbgBuf)
#define DPRINTF1(fmt, arg1) sprintf(i2cDbgBuf, fmt, arg1); OutputDebugString(i2cDbgBuf)
#define DPRINTF2(fmt, arg1, arg2) sprintf(i2cDbgBuf, fmt, arg1, arg2); OutputDebugString(i2cDbgBuf)
#define DPRINTF3(fmt, arg1, arg2, arg3 ) sprintf(i2cDbgBuf, fmt, arg1, arg2, arg3); OutputDebugString(i2cDbgBuf)
#endif /* DRIVER */
#else
/* non-debug */
#define DPRINTF0(fmt)
#define DPRINTF1(fmt, arg1)
#define DPRINTF2(fmt, arg1, arg2)
#endif /* DEBUG */

static char	i2cDbgBuf[80];

/*----------------------------------------------------------------------------*/
/*
 * misc defines/typedef's
 */

#define	NVI2C_BASE_INST			0x50000001
#define	NVI2C_SERIAL_BUS		0
#define	NVI2C_NOTIFY_DMA_CONTEXT	1
#define	NVI2C_DEVICE			2
#define	NVI2C_CHANNEL			3

typedef struct _NVI2C {
    ULONG		externalAllocd;
    ULONG		root;
    ULONG		dev;
    ULONG		channel;
    NvChannel*		pNV;
    UINT		subchannel;
    UINT		baseInst;
    NvNotification	nvNotifier[3];
    UINT		addrSize;
} NVI2C, *PNVI2C;

#ifdef DRIVER
#define	NVRM_ALLOC_ROOT		NvRmR0AllocRoot
#define	NVRM_ALLOC_DEVICE	NvRmR0AllocDevice
#define	NVRM_ALLOC_CHANNEL_PIO	NvRmR0AllocChannelPio
#define	NVRM_ALLOC_CONTEXT_DMA	NvRmR0AllocContextDma
#define	NVRM_ALLOC_OBJECT	NvRmR0AllocObject
#define	NVRM_FREE		NvRmR0Free
#define	NVRM_INTERRUPT		NvRmR0Interrupt
#else
#define	NVRM_ALLOC_ROOT		NvRmAllocRoot
#define	NVRM_ALLOC_DEVICE	NvRmAllocDevice
#define	NVRM_ALLOC_CHANNEL_PIO	NvRmAllocChannelPio
#define	NVRM_ALLOC_CONTEXT_DMA	NvRmAllocContextDma
#define	NVRM_ALLOC_OBJECT	NvRmAllocObject
#define	NVRM_FREE		NvRmFree
#define	NVRM_INTERRUPT		NvRmInterrupt
#endif

#define	NVI2C_READ_TIMEOUT	10000

void __yield();

/*----------------------------------------------------------------------------*/
/*
 * global I2C control object
 *
 * XXX it might be better to allocate this object elsewhere
 */

static NVI2C	nvI2C;
static PNVI2C	pI2C = &nvI2C;


/*----------------------------------------------------------------------------*/
/*
 * nvI2CInit
 */

DWORD nvI2CInit (
    ULONG	ourRoot,
    ULONG	ourDev,
    ULONG	ourChannel,
    NvChannel*	pChannel,
    UINT	subchan,
    UINT	baseInst )
{

    UINT	i;
    ULONG	flags;
    DWORD	rc;
    DWORD	err;
    UCHAR*	pNotifyBuf;
    NvChannel*	pNV;
    char	devName[32];

    DPRINTF0( "nvI2CInit: entering\n" );

    /*
     * check if user wants to use a specific base instance for our objects
     */

    if ( baseInst == 0 ) {
    	baseInst = NVI2C_BASE_INST;
    }

    /*
     * check if we need to allocate root, device and channel
     */

    if ( pChannel == NULL ) {

	/*
	 * get a NV channel
	 */

	err = NVRM_ALLOC_ROOT(&ourRoot);
	if ( err != NVOS01_STATUS_SUCCESS ) {
	    DPRINTF0("nvI2CInit: NVRM_ALLOC_ROOT failed\n");
	    return(1);
	}

	ourDev = baseInst + NVI2C_DEVICE;
	err = NVRM_ALLOC_DEVICE(ourRoot, 
			        ourDev, 
			        NV01_DEVICE_0, 
			        devName);
	if ( err != NVOS06_STATUS_SUCCESS ) {
	    DPRINTF0("nvI2CInit: NVRM_ALLOC_DEVICE failed\n");
	    NVRM_FREE(ourRoot, ourRoot, ourRoot);
	    return(1);
	}

	ourChannel = baseInst + NVI2C_CHANNEL;
	err = NVRM_ALLOC_CHANNEL_PIO(ourRoot,
				     ourDev,
				     ourChannel,
    #ifdef NV3
				     NV03_CHANNEL_PIO,
    #else
				     NV03_CHANNEL_PIO,
    #endif
				     0,
				     (PVOID) &pNV,
				     0);

	if ( err != NVOS04_STATUS_SUCCESS ) {
	    DPRINTF0("nvI2CInit: NVRM_ALLOC_CHANNEL_PIO failed\n");
	    NVRM_FREE(ourRoot, ourRoot, ourDev);
	    NVRM_FREE(ourRoot, ourRoot, ourRoot);
	    return(1);
	}

	if ( pNV == NULL ) {
	    DPRINTF0("nvI2CInit: null channel ptr returned by NVRM_ALLOC_CHANNEL_PIO\n");
	    NVRM_FREE(ourRoot, ourDev, ourChannel);
	    NVRM_FREE(ourRoot, ourRoot, ourDev);
	    NVRM_FREE(ourRoot, ourRoot, ourRoot);
	    return(1);
	}

	pI2C->externalAllocd = FALSE;
    }
    else {

        /*
	 * use the channel ptr (and root and device and channel id) that was passed to us
	 */

        pNV = pChannel;

	pI2C->externalAllocd = TRUE;

    }

    /*
     * create an EXTERNAL_SERIAL_BUS object
     */

#ifdef NV3
    err = NVRM_ALLOC_OBJECT(ourRoot, ourChannel, baseInst+NVI2C_SERIAL_BUS, NV_EXTERNAL_SERIAL_BUS);
#else
    err = NVRM_ALLOC_OBJECT(ourRoot, ourChannel, baseInst+NVI2C_SERIAL_BUS, NV04_EXTERNAL_SERIAL_BUS);
#endif

    if ( err != NVOS05_STATUS_SUCCESS ) {
	DPRINTF0("nvI2CInit: NVRM_ALLOC_OBJECT of EXTERNAL_SERIAL_BUS failed\n");
	return(1);
    }

    /*
     * initialize notifier for serial bus object
     */

    DPRINTF0( "nvI2CInit: clearing notifier memory\n" );

    pNotifyBuf = (UCHAR*) &(pI2C->nvNotifier);
    for ( i = 0; i < sizeof(NvNotification)*3; i++ )
	pNotifyBuf[i] = 0;

    DPRINTF0( "nvI2CInit: initializing NvNotification objects\n" );

#ifdef NV3
    pI2C->nvNotifier[NV_051_NOTIFICATION_NOTIFY].status = 0;
    pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status = 0;
    pI2C->nvNotifier[NV_051_NOTIFICATION_SET_INTERRUPT_NOTIFY].status = 0;
#else
    pI2C->nvNotifier[NV051_NOTIFIERS_NOTIFY].status = 0;
    pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 0;
    pI2C->nvNotifier[NV051_NOTIFICATION_SET_INTERRUPT_NOTIFY].status = 0;
#endif

    /*
     * create DMA-to-memory context for notifer and plug in notify memory
     */

    DPRINTF0( "nvI2CInit: creating CONTEXT_DMA_TO_MEMORY object\n" );

    flags = NVOS03_FLAGS_ACCESS_READ_WRITE | NVOS03_FLAGS_COHERENCY_UNCACHED;
    rc = NVRM_ALLOC_CONTEXT_DMA(ourRoot,
    			     baseInst + NVI2C_NOTIFY_DMA_CONTEXT,
			     NV01_CONTEXT_DMA,
			     flags,
			     (PVOID) pNotifyBuf,
			     sizeof(NvNotification)*3 - 1 );
    if ( rc != NVOS03_STATUS_SUCCESS ) {
	DPRINTF0( "nvI2CInit: NVRM_ALLOC_CONTEXT_DMA failed\n" );
	return(1);
    }

    /*
     * plug notifier into serial bus object
     */

    DPRINTF0( "nvI2CInit: plugging notifer into serial bus object\n" );

#ifdef NV3
    while ( pNV->subchannel[subchan].control.free < 2*4 );

    pNV->subchannel[subchan].control.object = baseInst + NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.SetContextDmaNotifies = 
	baseInst + NVI2C_NOTIFY_DMA_CONTEXT;
#else
    while ( pNV->subchannel[subchan].control.Free < 2*4 );

    pNV->subchannel[subchan].SetObject = baseInst + NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.SetContextDmaNotifies = 
	baseInst + NVI2C_NOTIFY_DMA_CONTEXT;
#endif

    /*
     * misc wrap-up
     */

    DPRINTF0( "nvI2CInit: misc wrap-up\n" );

    pI2C->addrSize = 2;	/* default is 16-bit addresses */
    pI2C->root = ourRoot;
    pI2C->dev = ourDev;
    pI2C->channel = ourChannel;
    pI2C->pNV = pNV;
    pI2C->subchannel = subchan;
    pI2C->baseInst = baseInst;

    DPRINTF0( "nvI2CInit: exiting successfully\n" );

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CUninit
 *
 * XXX for now don't compile into a Ring0 driver
 */

DWORD nvI2CUninit()
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;

    DPRINTF0( "nvI2CUninit: entering\n" );

    /*
     * XXX The below commented out code is to prevent a race condition with
     *     the synchronous NvRmFree's that occur afterwards.  The solution is
     *     to use NvRmInterrupt and watch the free count to tell when it's safe
     *     to use the synchronous free function.
     */

#ifdef COMMENT

    /*
     * unplug the context dma object
     */

#ifdef NV3
    pNV->subchannel[subchan].control.object = pI2C->baseInst + NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.SetContextDmaNotifies = 0;
#else
    pNV->subchannel[subchan].SetObject = pI2C->baseInst + NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.SetContextDmaNotifies = 0;
#endif

#endif /* COMMENT */

    /*
     * destroy objects created in nvI2CInit
     */

    NVRM_FREE(pI2C->root, pI2C->channel, pI2C->baseInst+NVI2C_SERIAL_BUS);
    NVRM_FREE(pI2C->root, pI2C->root, pI2C->baseInst+NVI2C_NOTIFY_DMA_CONTEXT);

    /*
     * free root, device, and channel if we allocated them
     */

    if ( pI2C->externalAllocd == FALSE ) {
	NVRM_FREE(pI2C->root, pI2C->dev, pI2C->channel);
	NVRM_FREE(pI2C->root, pI2C->root, pI2C->dev);
	NVRM_FREE(pI2C->root, pI2C->root, pI2C->root);
    }

    DPRINTF0( "nvI2CUninit: exiting\n" );

    return(0);

}
 
/*----------------------------------------------------------------------------*/
/*
 * nvI2CWriteByte
 */

DWORD nvI2CWriteByte (
    UCHAR	chipAddr,
    UCHAR	regAddr,
    UCHAR	data )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	writeSize = (pI2C->addrSize << 16) | 0x00000001;
    UINT	addr = (regAddr << 8) | chipAddr;

    DPRINTF0( "nvI2CWriteByte: entering\n" );

    /*
     * send write request to the serial bus object
     */

#ifdef NV3
    DPRINTF0("nvI2CWriteByte: doing NV3 write\n");

    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Write.size = writeSize;
    pNV->subchannel[subchan].externalSerialBus.Write.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Write.data = data;
#else
    DPRINTF0("nvWriteI2CByte: doing NV4 write\n");

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteSize = writeSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteData = data;
#endif

    DPRINTF0( "nvI2CWriteByte: exiting\n" );

    return(0);

}
    
/*----------------------------------------------------------------------------*/
/*
 * nvI2CReadByte
 */

DWORD nvI2CReadByte (
    UCHAR	chipAddr,
    UCHAR	regAddr,
    UCHAR*	pData )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	readSize = (pI2C->addrSize << 16) | 0x00000001;
    UINT	addr = (regAddr << 8) | chipAddr;
    UINT	timeOut = NVI2C_READ_TIMEOUT;

    DPRINTF0( "nvI2CReadByte: entering\n" );

    /*
     * clear the notifier
     */

#ifdef NV3
    pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status = NV_STATUS_IN_PROGRESS;
#else
    pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV051_NOTIFICATION_STATUS_IN_PROGRESS;
#endif

    /*
     * send read request to the serial bus object
     */

    DPRINTF0( "nvI2CReadByte: sending read request\n" );

#ifdef NV3
    DPRINTF0("nvI2CReadByte: doing NV3 read\n");

    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Read.size = readSize;
    pNV->subchannel[subchan].externalSerialBus.Read.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Read.getDataNotify = 
	NV_051_NOTIFY_WRITE_ONLY;
#else
    DPRINTF0("nvI2CReadByte: doing NV4 read\n");

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = readSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV051_NOTIFY_WRITE_ONLY;
#endif

    /*
     * wait for read to complete
     */

    DPRINTF0( "nvI2CReadByte: waiting for read to complete\n" );

    while ( timeOut > 0 ) {

#ifdef NV3
	if ( (volatile) (pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status) == NV_STATUS_IN_PROGRESS ) {
#else
	if ( (volatile) (pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	    NV051_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif
	    /* data is not ready yet */
	    timeOut--;
	    __yield();
	}
	else {
	    /* stop waiting, the data is ready */
	    break; 
	}

    }

    if ( timeOut == 0 ) {
	DPRINTF0( "nvI2CReadByte: error, read timed out\n" );
	return(1);
    }

    /*
     * get the read data
     */

#ifdef NV3
    *pData = (UCHAR)(volatile)(pI2C->nvNotifier[NV_051_NOTIFICATION_READ].otherInfo32);
#else
    *pData = (UCHAR)(volatile)(pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);
#endif

    DPRINTF1( "nvI2CReadByte: exiting, with read data = 0x%x\n", *pData );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CWriteWord
 */

DWORD nvI2CWriteWord (
    UCHAR	chipAddr,
    UCHAR	regAddr,
    USHORT	data )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	writeSize = (pI2C->addrSize << 16) | 0x00000002;
    UINT	addr = (regAddr << 8) | chipAddr;
    UINT	uiData;

    DPRINTF0( "nvI2CWriteWord: entering\n" );

    /*
     * swap data bytes
     */

    uiData = ((data & 0xff) << 8) | ((data >> 8) & 0xff);

    /*
     * send write request to the serial bus object
     */

#ifdef NV3
    DPRINTF0("nvI2CWriteWord: doing NV3 write\n");

    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Write.size = writeSize;
    pNV->subchannel[subchan].externalSerialBus.Write.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Write.data = uiData;
#else
    DPRINTF0("nvI2CWriteWord: doing NV4 write\n");

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteSize = writeSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteData = uiData;
#endif

    DPRINTF0( "nvI2CWriteWord: exiting\n" );

    return(0);

}
    
/*----------------------------------------------------------------------------*/
/*
 * nvI2CReadWord
 */

DWORD nvI2CReadWord (
    UCHAR	chipAddr,
    UCHAR	regAddr,
    USHORT*	pData )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	readSize = (pI2C->addrSize << 16) | 0x00000002;
    UINT	addr = (regAddr << 8) | chipAddr;
    USHORT	data;
    UINT	timeOut = NVI2C_READ_TIMEOUT;

    DPRINTF0( "nvI2CReadWord: entering\n" );

    /*
     * clear the notifier
     */

#ifdef NV3
    pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status = NV_STATUS_IN_PROGRESS;
#else
    pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV051_NOTIFICATION_STATUS_IN_PROGRESS;
#endif

    /*
     * send read request to the serial bus object
     */

    DPRINTF0( "nvI2CReadWord: sending read request\n" );

#ifdef NV3
    DPRINTF0("nvI2CReadWord: doing NV3 read\n");

    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Read.size = readSize;
    pNV->subchannel[subchan].externalSerialBus.Read.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Read.getDataNotify = 
	NV_051_NOTIFY_WRITE_ONLY;
#else
    DPRINTF0("nvI2CReadWord: doing NV4 read\n");

    while ( pNV->subchannel[subchan].control.Free < 4*4 );

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = readSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV051_NOTIFY_WRITE_ONLY;
#endif

    /*
     * wait for read to complete
     */

    DPRINTF0( "nvI2CReadWord: waiting for read to complete\n" );

    while ( timeOut > 0 ) {

#ifdef NV3
	if ( (volatile) (pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status) == NV_STATUS_IN_PROGRESS ) {
#else
	if ( (volatile) (pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	    NV051_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif
	    /* data is not ready yet */
	    timeOut--;
	    __yield();
	}
	else {
	    /* stop waiting, the data is ready */
	    break; 
	}

    }

    if ( timeOut == 0 ) {
	DPRINTF0( "nvI2CReadWord: error, read timed out\n" );
	return(1);
    }

    /*
     * get the read data
     */

#ifdef NV3
    data = (USHORT)(volatile)(pI2C->nvNotifier[NV_051_NOTIFICATION_READ].otherInfo32);
#else
    data = (USHORT)(volatile)(pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);
#endif

    *pData = ((data & 0xff) << 8) | ((data >> 8) & 0xff);

    DPRINTF1( "nvReadI2CWord: exiting, with read data = 0x%x\n", *pData );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CWriteBuf - do a I2C "write" of a variable length buffer of bytes
 *
 * Note: the current implemenation of the external serial class object
 *	 does not allow for more then 8 bytes total (address and data)
 *	 to be transmitted in a single I2C "transaction".
 */

DWORD nvI2CWriteBuf (
    UCHAR*	pBuf,
    UINT	bufSize )
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	i, tmp;
    UINT	writeSize;
    UINT	addr;
    UINT	data;

    DPRINTF0( "nvI2CWriteBuf: entering\n" );

    /*
     * construct proper addr and data values using contents of pBuf
     */

    addr = 0;

    for ( i = 0; (i < 4) && (i < bufSize); i++ ) {
        tmp = (pBuf[i] & 0xff) << (i*8);
	addr = addr | tmp;
    }

    writeSize = i << 16;

    data = 0;

    for ( i = 4; (i < 8) && (i < bufSize); i++ ) {
        tmp = (pBuf[i] & 0xff) << ((i-4)*8);
	data = data | tmp;
    }

    writeSize = writeSize | (i-4);

    DPRINTF1( "nvI2CWriteBuf: addr = %x\n", addr );
    DPRINTF1( "nvI2CWriteBuf: data = %x\n", data );
    DPRINTF1( "nvI2CWriteBuf: writeSize = %x\n", writeSize );
    
    /*
     * send write request to the serial bus object
     */

#ifdef NV3
    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Write.size = writeSize;
    pNV->subchannel[subchan].externalSerialBus.Write.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Write.data = data;
#else
    while ( pNV->subchannel[subchan].control.Free < 4*4 ) 
        __yield();

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteSize = writeSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.WriteData = data;
#endif

    DPRINTF0( "nvI2CWriteBuf: exiting\n" );

    return(0);

}
    
/*----------------------------------------------------------------------------*/
/*
 * nvI2CReadBuf - do a I2C "read" of a buffer of bytes using a variable length address
 *
 * Note: the address buffer and read buffer is limited to a maximum of 4 bytes
 */

DWORD nvI2CReadBuf (
    UCHAR*	pBuf,		/* address buffer */
    UINT	bufSize,	/* size of address buffer, max 4 */
    UCHAR*	pData,
    UINT	readBufSize)
{

    NvChannel*	pNV = pI2C->pNV;
    UINT	subchan = pI2C->subchannel;
    UINT	i, tmp;
    UINT	readSize;
    UINT	addr;
    UINT	data;
    UINT	timeOut = NVI2C_READ_TIMEOUT;
#ifdef DO_TIMING
    UINT	deltaLo, startLo;
#endif

    DPRINTF0( "nvI2CReadBuf: entering\n" );

    /*
     * construct proper addr and data values using contents of pBuf
     */

    addr = 0;

    for ( i = 0; (i < 4) && (i < bufSize); i++ ) {
        tmp = pBuf[i] << (i*8);
	addr = addr | tmp;
    }

    readSize = (i << 16) | (readBufSize & 0x0000ffff);

    /*
     * clear the notifier
     */

#ifdef NV3
    pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status = NV_STATUS_IN_PROGRESS;
#else
    pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status = 
	NV051_NOTIFICATION_STATUS_IN_PROGRESS;
#endif

    /*
     * send read request to the serial bus object
     */

    DPRINTF1( "nvI2CReadBuf: addr = %x\n", addr );
    DPRINTF1( "nvI2CReadBuf: readSize = %x\n", readSize );
    
    DPRINTF0( "nvI2CReadBuf: sending read request\n" );

#ifdef NV3
    while ( pNV->subchannel[subchan].control.free < 4*4 );

    pNV->subchannel[subchan].control.object = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].externalSerialBus.Read.size = readSize;
    pNV->subchannel[subchan].externalSerialBus.Read.address = addr;
    pNV->subchannel[subchan].externalSerialBus.Read.getDataNotify = 
	NV_051_NOTIFY_WRITE_ONLY;
#else
    while ( pNV->subchannel[subchan].control.Free < 4*4 )
        __yield();

#ifdef DO_TIMING
    startLo = clockop(1);	/* start timing */
#endif

    pNV->subchannel[subchan].SetObject = pI2C->baseInst+NVI2C_SERIAL_BUS;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadSize = readSize;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadAddress = addr;
    pNV->subchannel[subchan].nv04ExternalSerialBus.ReadGetDataNotify = 
	NV051_NOTIFY_WRITE_ONLY;
#endif

    /*
     * wait for read to complete
     */

#ifndef DO_TIMING
    DPRINTF0( "nvI2CReadBuf: waiting for read to complete\n" );
#endif

    while ( timeOut > 0 ) {

#ifdef NV3
	if ( (volatile) (pI2C->nvNotifier[NV_051_NOTIFICATION_READ].status) == NV_STATUS_IN_PROGRESS ) {
#else
	if ( (volatile) (pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].status) == 
	    NV051_NOTIFICATION_STATUS_IN_PROGRESS ) {
#endif
	    /* data is not ready yet */
	    timeOut--;
	    __yield();
	}
	else {
	    /* stop waiting, the data is ready */
	    break; 
	}

    }

    if ( timeOut == 0 ) {
	DPRINTF0( "nvI2CReadWord: error, read timed out\n" );
	return(1);
    }

    /*
     * get the read data
     */

#ifdef NV3
    data = (UINT)(volatile)(pI2C->nvNotifier[NV_051_NOTIFICATION_READ].otherInfo32);
#else
    data = (UINT)(volatile)(pI2C->nvNotifier[NV051_NOTIFICATION_READ_GET_DATA_NOTIFY].info32);
#endif

#ifdef DO_TIMING
    deltaLo = clockop(0);	 /* stop timing */
#ifdef DRIVER
    _Sprintf( i2cDbgBuf, "nvi2CReadBuf: startLo = %d\n", startLo );
    Out_Debug_String ( i2cDbgBuf );
    _Sprintf( i2cDbgBuf, "nvi2CReadBuf: deltaLo = %d\n", deltaLo );
    Out_Debug_String ( i2cDbgBuf );
#else
    fprintf( stdout, "nvi2CReadBuf: startLo = %d\n", startLo );
    fprintf( stdout, "nvi2CReadBuf: deltaLo = %d\n", deltaLo );
#endif
#endif /* DO_TIMING */

    DPRINTF1( "nvI2CReadBuf: data = %x\n", data );

    /*
     * reorder the bytes since we're actually being passed a ptr to bytes
     */

    for ( i = 0; i < readBufSize; i++ ) {
	pData[i] = data & 0xff;
	data = data >> 8;
    }

    DPRINTF0( "nvI2CReadBuf: exiting\n" );

    return(0);

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CWrite
 *
 */

DWORD nvI2CWrite (
    UCHAR	chipAddr, 
    DWORD	subAddrLen, 
    UCHAR*	subAddr, 
    DWORD	dataLen, 
    UCHAR*	data)
{

    UINT	i;
    UINT	dindex;
    UCHAR	buf[8];
    UINT	bufSize;
    UINT	m;
    UINT	rc = 0;

    if ( (subAddrLen < 1) || (dataLen < 1) ) {
    	return(1);
    }

    buf[0] = chipAddr;
    for ( i = 1; i <= subAddrLen; i++ ) {
        buf[i] = subAddr[i-1];
    }
    dindex = i;

    i = 0;
    do {
        m = i & 0x3;
        buf[dindex+m] = data[i];
	if ( (m == 3) || (i == dataLen-1) ) {
	    bufSize = dindex+m+1;
	    rc |= nvI2CWriteBuf(buf, bufSize);
	}
    }
    while( ++i < dataLen );

    return(rc);

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CRead
 *
 */

DWORD nvI2CRead (
    UCHAR	chipAddr, 
    DWORD	subAddrLen, 
    UCHAR*	subAddr, 
    DWORD	dataLen, 
    UCHAR*	data)
{

    UINT	i;
    UINT	dindex;
    UCHAR	buf[8];
    UINT	bufSize;

    if ( (subAddrLen > 3) || (dataLen > 1) ) {
    	return(1);
    }

    buf[0] = chipAddr;
    for ( i = 1; i <= subAddrLen; i++ ) {
        buf[i] = subAddr[i-1];
    }
    dindex = i;

    bufSize = dindex;

    return ( nvI2CReadBuf(buf, bufSize, data, 1) );

}


/*----------------------------------------------------------------------------*/
/*
 * __GetFlatDataSelector - duplicate of NvGetFlatDataSelector()
 *
 * XXX Eventually, this function will be provided to us.
 */

static int __GetFlatDataSelector()
{
    DWORD	Selector;

    _asm xor eax, eax
    _asm mov ax, ds
    _asm mov Selector, eax
    return (Selector);
}

/*----------------------------------------------------------------------------*/
/*
 * __yield()
 */

#ifdef VXD
VOID VXDINLINE
Time_Slice_Sleep(DWORD timeout)
{
    __asm mov eax, timeout
    VMMCall(Time_Slice_Sleep);
}
#endif

static void __yield()
{
    NVRM_INTERRUPT(pI2C->root, pI2C->dev);
}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CSetControlObj - backdoor to set the ptr the global control object
 */

DWORD nvI2CSetControlObj (
    VOID*	pObj )
{

    pI2C = (NVI2C*) pObj;

    DPRINTF0( "nvI2CSetControlObj: exiting successfully\n" );

    return(0);	/* return 0 to indicate success */

}

/*----------------------------------------------------------------------------*/
/*
 * nvI2CGetControlObj - backdoor to get the ptr the global control object
 */

VOID* nvI2CGetControlObj ()
{

    DPRINTF0( "nvI2CGetControlObj: exiting successfully\n" );

    return(pI2C);

}

/*----------------------------------------------------------------------------*/
/*
 * utility real-time clock routines
 */

#ifdef DO_TIMING

UINT
clockcount( UINT* phi, UINT* plo )
{

    UINT        hi, lo;

    /* emit RDTSC instruction to get clock count */
    __asm
    {
        _emit   0x0f 
        _emit   0x31
        mov         hi, edx
        mov         lo, eax
    }

    *phi = hi;
    *plo = lo;

    return(lo);

}

UINT
deltacount ( 
    UINT startHi, 
    UINT startLo, 
    UINT stopHi, 
    UINT stopLo, 
    UINT* deltaHi, 
    UINT* deltaLo )
{

    if ( stopLo > startLo ) {
        *deltaLo = stopLo - startLo;
	*deltaHi = stopHi - startHi;
    }
    else {
    	*deltaLo = 0xffffffff - ( startLo - stopLo );
	*deltaHi = stopHi - startHi - 1;
    }

    return(*deltaLo);

}

/* 
 * clockop() only works for delta processor clocks < 2^32 - 1 
 * which is ~14 seconds on 300MHz clock
 *
 * start > op = 1, stop -> op = 0
 */

UINT clockop( UINT op )	
{

    static UINT	startHi, startLo;
    static UINT	stopHi, stopLo;
    static UINT	deltaHi, deltaLo;

    if ( op ) {
    	clockcount ( &startHi, &startLo );
	return(startLo);
    }
    else {
    	clockcount ( &stopHi, &stopLo );
    	deltacount ( startHi, startLo, stopHi, stopLo, &deltaHi, &deltaLo );
	return(deltaLo);
    }

}

#endif /* DO_TIMING */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\NVWIN32.H ===
#ifndef NVWIN32_INCLUDED
#define NVWIN32_INCLUDED
 /***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#ifndef NV32_INCLUDED
#include "nv32.h"                       /* for Nv3/4/10 Channel typedef */
#endif

#define NV_SLEEP     Sleep(0)
#define NV_SLEEP1    Sleep(1)
#define NV_SLEEP2    Sleep(2)
#define NV_SLEEP3    Sleep(3)
#define NV_SLEEP4    Sleep(4)
#define NV_SLEEP5    Sleep(5)
#define NV_SLEEPFLIP Sleep(1)

/***************************************************************************
 *                   NVIDIA-supplied routines                              *
 ***************************************************************************/

/***** Hardware access *****/

/*
 * NvOpen() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpen(char *);

#ifdef NOTHERENOTNOW

// this is commented out because somebody defined it else where to get their stuff working even
// though the SDK has it defined here...  ah well so much for standardization!
/*
 * NvOpenDma() opens a 64KB channel (shared memory region) to the chip.
 * Pass NULL as the parameter for the default NV1 chip in the computer.
 */
extern NvChannel * __stdcall NvOpenDma(char *, int, int, int);

#endif //0

/*
 * NvClose() closes the channel to the chip and attempts to
 * clean up all objects created in that channel.
 */
extern int                  __stdcall NvClose(NvChannel *);

/***** Operating Environment routines *****/
/*
 * NvWait() waits to be "awakened" after requesting notification with
 * the NV_OS_NOTIFY_WILL_SLEEP style.
 * Note that in Windows 3.1 any Windows message will wake up the
 * application.
 */
extern int  __stdcall NvWait( NvChannel *);

/*
 * NvNotifyEvent() specifies a Windows event for NV to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_EVENT style.
 *    first parameter is the NvChannel
 *    second is the Ring0 Win32 event handle
 */
extern int  __stdcall NvNotifyEvent( NvChannel *, int);

/*
 * NvNotifyMsg() specifies a Windows message for NV1 to send to the
 * application after requesting notifications with the
 * NV_OS_NOTIFY_MESSAGE style.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvNotifyMsg(NvChannel *, int, int);

/*
 * NvAllocEvent() specifies a Windows event or callback for NV to send to the
 * application after requesting notifications with the
 * NV_OS_WRITE_THEN_AWAKEN style.
 *    first parameter is the NvChannel
 *    second is the object name
 *    third is the notify index
 *    fourth is the notify event type (NV_OS_EVENT_*)
 *    fifth is the lower 32bits of the 64bit event data
 *    sixth is the upper 32bits of the 64bit event data
 */
extern int  __stdcall NvAllocEvent(NvChannel *, int, int, int, int, int);

/*
 * NvErrorMsg() specifies a Windows message for NV to send to the
 * application upon detecting an error.
 *    first parameter is the NvChannel
 *    second is the HWND window handle
 *    third is the Windows message that the Resource Manager should send
 */
extern int  __stdcall NvErrorMsg(NvChannel *, int, int);

/*
 * Although Win32 applications have a flat address space, on the X86 
 * architecture they still have a single selector that you must supply as
 *    contextDmaToMemory.SetDmaSpecifier.address[1].
 */
extern int  __stdcall NvGetFlatDataSelector(void);
extern int  __stdcall NvGetFlatCodeSelector(void);

/*
 * NvConfigVersion() returns an NV version number indicating the NV version.
 * The format of this is 0x00010206, where
 *  - 0x0001 is the chip architecture
 *  -   0x02 is the software release
 *  -   0x06 is the minor revision
 */
extern int  __stdcall NvConfigVersion(void);

#define NV_CHIP_ARCH(ver)   ((ver) >> 16)
#define NV_SW_RELEASE(ver)  (((ver) >> 8) & 0xFF)
#define NV_MINOR_REV(ver)   ((ver) & 0xFF)



/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** OS-dependent constants *****/

/* This posts a new architecture event */
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

/* This puts the process to sleep awaiting notification */
#define NV_OS_NOTIFY_WILL_SLEEP	   0x00000003

/* This puts a message in the client's message queue upon notification */
#define NV_OS_NOTIFY_MESSAGE	   0x00000002

/* This posts a Win32 event to the client upon notification */
#define NV_OS_NOTIFY_EVENT  	   0x00000004

/* This posts a Ring0 event to the client upon notification */
#define NV_OS_NOTIFY_VM_EVENT  	   0x00000005

/* Event Types */
#define NV_OS_EVENT_VXD_CALLBACK   0x00000000
#define NV_OS_EVENT_WIN32_EVENT    0x00000001
#define NV_OS_EVENT_VM_EVENT       0x00000002
#define NV_OS_EVENT_WIN32_MSG      0x00000003
#define NV_OS_EVENT_WIN16          0x00000004
#define NV_OS_EVENT_INVALID        0xFFFFFFFF


/***************************************************************************
 *                     OS Resource Strings                                 *
 ***************************************************************************/

/* Maximum length of an OS string (conservative, actual is about 24) */
#define NV_OS_MAX_NAME_LENGTH      32

/***** OS resource names for sources and sinks of samples *****/

/* for NV_VIDEO_SINK */
#define NV_OS_VIDEO_MONITOR        "CON:"

/* for NV_IMAGE_TO_VIDEO. The HWND window handle should replace %u */
#define NV_OS_CANVAS_WINDOW        "WND%u:"

/* for NV_AUDIO_SINK */
#define NV_OS_LINE_OUT_LEFT        "LIN:\\LEFT"
#define NV_OS_LINE_OUT_RIGHT       "LIN:\\RIGHT"

/* for NV_AUDIO_SOURCE */
#define NV_OS_LINE_IN_LEFT         "LIN:\\LEFT"
#define NV_OS_LINE_IN_RIGHT        "LIN:\\RIGHT"
#define NV_OS_MIC_IN_LEFT          "MIC:\\LEFT"
#define NV_OS_MIC_IN_RIGHT         "MIC:\\RIGHT"


/***** Many devices can provide samples for NV_GAME_PORT_SOURCE *****/

/* Raw potentiometer data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 8 channels (0-7) replaces %d */
/* NOTE: The NV_OS_POT O/S string changed to "POTA%d:". The 2.0 and higher
 * Resource Manager will generate NV_ERROR1_NO_SUCH_OBJECT if there is no 
 * joystick connected. This string means nothing to the 1.20 Resource Manager.
 * For backwards compatibility, use NV_OS_GAME_PORT ("POT%d:"): both the 2.0 
 * and 1.20 Resource Manager will not generate an error if no joystick is
 * connected.
 */
#define NV_OS_POT                      "POTA%d:"
/* XXX Old name preserved for compatibility, use NV_OS_POT */
#define NV_OS_GAME_PORT                "POT%d:"


/* Calibrated joystick data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_JOYSTICK_BUTTONS         "JOY%d:\\BUTTONS"

#define NV_OS_JOYSTICK_BUTTON_TRIGGER  0x0001
#define NV_OS_JOYSTICK_BUTTON_SELECT   0x0002
#define NV_OS_JOYSTICK_BUTTON_A        0x0004
#define NV_OS_JOYSTICK_BUTTON_B        0x0008

#define NV_OS_JOYSTICK_X_AXIS          "JOY%d:\\X_AXIS"
#define NV_OS_JOYSTICK_Y_AXIS          "JOY%d:\\Y_AXIS"


/* Pedal data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_PEDALS                   "PEDALS%d:"


/* Throttle data on analog connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* XXX Not yet implemented */
#define NV_OS_THROTTLE                 "THROTTLE%d:"


/* 8-button game pad data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_PAD_BUTTONS              "PAD%d:"
/* XXX Old name preserved for compatibility, use NV_OS_PAD_BUTTONS */
#define NV_OS_PAD                      "PAD%d:"

#define NV_OS_PAD_BUTTON_START         0x0001
#define NV_OS_PAD_BUTTON_RIGHT         0x0002
#define NV_OS_PAD_BUTTON_LEFT          0x0004
#define NV_OS_PAD_BUTTON_UP            0x0008
#define NV_OS_PAD_BUTTON_DOWN          0x0010
#define NV_OS_PAD_BUTTON_A             0x0020
#define NV_OS_PAD_BUTTON_B             0x0040
#define NV_OS_PAD_BUTTON_C             0x0080
#define NV_OS_PAD_BUTTON_X             0x0100
#define NV_OS_PAD_BUTTON_Y             0x0200
#define NV_OS_PAD_BUTTON_Z             0x0400
#define NV_OS_PAD_BUTTON_TOP_RIGHT     0x0800
#define NV_OS_PAD_BUTTON_TOP_LEFT      0x1000


/* 3-axis yoke data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 6 channels (0-5) replaces %d */
#define NV_OS_YOKE_BUTTONS             "YOKE%d:\\BUTTONS"

#define NV_OS_YOKE_BUTTON_START        0x0001
#define NV_OS_YOKE_BUTTON_RIGHT        0x0002
#define NV_OS_YOKE_BUTTON_LEFT         0x0004
#define NV_OS_YOKE_BUTTON_UP           0x0008
#define NV_OS_YOKE_BUTTON_DOWN         0x0010
#define NV_OS_YOKE_BUTTON_A            0x0020
#define NV_OS_YOKE_BUTTON_B            0x0040
#define NV_OS_YOKE_BUTTON_C            0x0080
#define NV_OS_YOKE_BUTTON_X            0x0100
#define NV_OS_YOKE_BUTTON_Y            0x0200
#define NV_OS_YOKE_BUTTON_Z            0x0400
#define NV_OS_YOKE_BUTTON_TOP_RIGHT    0x0800
#define NV_OS_YOKE_BUTTON_TOP_LEFT     0x1000

#define NV_OS_YOKE_X_AXIS              "YOKE%d:\\X_AXIS"
#define NV_OS_YOKE_Y_AXIS              "YOKE%d:\\Y_AXIS"
#define NV_OS_YOKE_Z_AXIS              "YOKE%d:\\Z_AXIS"

/* 2-axis gun position data on Sega Saturn connector from NV_GAME_PORT_SOURCE. */
/* One of the 2 channels (0-1) replaces %d */
/* The HWND window handle should replace %u */
#define NV_OS_GUN_BUTTONS              "GUN%dWND%u:\\BUTTONS"

#define NV_OS_GUN_BUTTON_START         0x0001
#define NV_OS_GUN_BUTTON_TRIGGER	   0x0002

#define NV_OS_GUN_X_POSITION		   "GUN%dWND%u:\\X_POS"
#define NV_OS_GUN_Y_POSITION		   "GUN%dWND%u:\\Y_POS"

/* Value returned if gun is still determing X/Y coordinate */
#define NV_OS_GUN_POSITION_COUNTING    0xFFFE
/* Value returned if gun is off screen or outside canvas) */
#define NV_OS_GUN_POSITION_OFF_SCREEN  0xFFFF

/***** WATCOM special handling *****/
/* WATCOM 10.0 compiler needs special declaration of these functions */
#ifdef __WATCOMC__
#pragma aux (__stdcall) NvOpen "*";
#pragma aux (__stdcall) NvClose "*";
#pragma aux (__stdcall) NvWait "*";
#pragma aux (__stdcall) NvNotifyMsg "*";
#pragma aux (__stdcall) NvErrorMsg "*";
#pragma aux (__stdcall) NvGetFlatDataSelector "*";
#pragma aux (__stdcall) NvGetFlatCodeSelector "*";
#ifdef _WIN32  // don't do this for the DOS compile!!
#pragma aux (__stdcall) NvConfigVersion "*";
#endif
#endif /* __WATCOMC__ */

#ifdef __cplusplus
};
#endif
#endif /* NVWIN32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\common\win9x\inc\TVOUT.H ===
#ifndef _TVOUT_H_
#define _TVOUT_H_
//
// the follow file defines the VIDEO_PARAMETER structure and calling parameters
// change to the ChangeDisplaySettingEx() Win32 API. 
//
// The audience for this file are Win32 developers who want to call
// ChangeDisplaySettingEx with the CDS_VIDEOPARAMETERS flag set, and
// display driver developers who want to implement the VIDEO_PARAMETERS 
// escape in their Control() function.

// Display driver Escape value to get/set the parameters.
//
#define VIDEO_PARAMETERS        3077    // escape value used in Control()

// Flags for ChangeDisplaySettings 
// these must match the flags in WINUSER.H 

#define CDS_UPDATEREGISTRY  0x00000001
#define CDS_TEST            0x00000002
#define CDS_FULLSCREEN      0x00000004
#define CDS_GLOBAL          0x00000008
#define CDS_SET_PRIMARY     0x00000010
#define CDS_VIDEOPARAMETERS 0x00000020

/* Return values for ChangeDisplaySettings */
#define DISP_CHANGE_SUCCESSFUL       0
#define DISP_CHANGE_RESTART          1
#define DISP_CHANGE_FAILED          -1
#define DISP_CHANGE_BADMODE         -2
#define DISP_CHANGE_NOTUPDATED      -3
#define DISP_CHANGE_BADFLAGS        -4
#define DISP_CHANGE_BADPARAM        -5
#define DISP_CHANGE_BADESC          -6

// the GUID for this structure is:
//    {02C62061-1097-11d1-920F-00A024DF156E}
// or  static const GUID <<name>> = { 0x2c62061, 0x1097, 0x11d1, { 0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e } };
// or DEFINE_GUID(<<name>>,           0x2c62061, 0x1097, 0x11d1,   0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e);

#ifndef GUID_DEFINED
#define GUID_DEFINED

typedef struct _GUID {          // size is 16 // same as winnt.h
    DWORD   Data1;
    WORD    Data2;
    WORD    Data3;
    BYTE    Data4[8];
} GUID;
#endif

typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         // GUID for this structure
    DWORD dwOffset;                     // leave it 0 for now.
    DWORD dwCommand;                    // VP_COMMAND_*            SET or GET
    DWORD dwFlags;                      // bitfield, defined below SET or GET
    DWORD dwMode;                       // bitfield, defined below SET or GET
    DWORD dwTVStandard;                 // bitfield, defined below SET or GET
    DWORD dwAvailableModes;             // bitfield, defined below GET
    DWORD dwAvailableTVStandard;        // bitfield, defined below GET
    DWORD dwFlickerFilter;              // value                   SET or GET
    DWORD dwOverScanX;                  // value                   SET or GET
    DWORD dwOverScanY;                  //                         SET or GET
    DWORD dwMaxUnscaledX;               // value                   SET or GET
    DWORD dwMaxUnscaledY;               //                         SET or GET
    DWORD dwPositionX;                  // value                   SET or GET
    DWORD dwPositionY;                  //                         SET or GET
    DWORD dwBrightness;                 // value                   SET or GET
    DWORD dwContrast;                   // value                   SET or GET
    DWORD dwCPType;                     // copy protection type    SET or GET
    DWORD dwCPCommand;                  // VP_CP_CMD_
    DWORD dwCPStandard;                 // what TV standards CP is available on. GET
    DWORD dwCPKey;
    DWORD bCP_APSTriggerBits;           // (a dword for alignment) SET(bits 0 and 1 valid).
    BYTE  bOEMCopyProtection[256];      // oem specific copy protection data SET or GET
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, FAR *LPVIDEOPARAMETERS;

#define VP_COMMAND_GET          0x0001  // size set, return caps.
                                        // returned Flags = 0 if not supported.
#define VP_COMMAND_SET          0x0002  // size and params set.

#define VP_FLAGS_TV_MODE        0x0001
#define VP_FLAGS_TV_STANDARD    0x0002
#define VP_FLAGS_FLICKER        0x0004
#define VP_FLAGS_OVERSCAN       0x0008
#define VP_FLAGS_MAX_UNSCALED   0x0010  // do not use on SET
#define VP_FLAGS_POSITION       0x0020
#define VP_FLAGS_BRIGHTNESS     0x0040
#define VP_FLAGS_CONTRAST       0x0080
#define VP_FLAGS_COPYPROTECT    0x0100

#define VP_MODE_WIN_GRAPHICS    0x0001
#define VP_MODE_TV_PLAYBACK     0x0002  // optimize for TV video playback

#define VP_TV_STANDARD_NTSC_M   0x0001  //        75 IRE Setup
#define VP_TV_STANDARD_NTSC_M_J 0x0002  // Japan,  0 IRE Setup
#define VP_TV_STANDARD_PAL_B    0x0004  // Europe, SE Asia, Pacific, Middle East, Africa (25 lines/frame, 50 fields/s & 4.43361875 MHz)
#define VP_TV_STANDARD_PAL_D    0x0008  // Warsaw Pact & China (also PAL K) Same as PAL B, different audio carrier
#define VP_TV_STANDARD_PAL_H    0x0010  // Belgium, Gibralter, Liberia & Malta - UHF standard, PAL B for VHF
#define VP_TV_STANDARD_PAL_I    0x0020  // UK, Ireland, Hong Kong, S. Africa - Same as PAL B but different audio carrier 
#define VP_TV_STANDARD_PAL_M    0x0040  // Brazil - NTSC rates, PAL encoding (525 lines/frame, 60 fields/s, & 3.57671149 MHz) 
#define VP_TV_STANDARD_PAL_N    0x0080  // Argentina - Similar to PAL B but lower audio & color carrier
#define VP_TV_STANDARD_SECAM_B  0x0100  
#define VP_TV_STANDARD_SECAM_D  0x0200
#define VP_TV_STANDARD_SECAM_G  0x0400
#define VP_TV_STANDARD_SECAM_H  0x0800
#define VP_TV_STANDARD_SECAM_K  0x1000
#define VP_TV_STANDARD_SECAM_K1 0x2000
#define VP_TV_STANDARD_SECAM_L  0x4000
#define VP_TV_STANDARD_WIN_VGA  0x8000
// and the rest
#define VP_TV_STANDARD_NTSC_433 0x00010000  
#define VP_TV_STANDARD_PAL_G    0x00020000
#define VP_TV_STANDARD_PAL_60   0x00040000
#define VP_TV_STANDARD_SECAM_L1 0x00080000

#define VP_CP_TYPE_APS_TRIGGER  0x0001  // DVD trigger bits only
#define VP_CP_TYPE_MACROVISION  0x0002  // full macrovision data available

#define VP_CP_CMD_ACTIVATE      0x0001  // CP command type
#define VP_CP_CMD_DEACTIVATE    0x0002
#define VP_CP_CMD_CHANGE        0x0004
    

typedef struct _MACROVISION {
    WORD    wVersion;
    WORD    wFlags;
    BYTE    bCPCData;
    BYTE    bCPSData[34];
} MACROVISION, *PMACROVISION, FAR *LPMACROVISION;

#define MV_FLAGS_CPC_ONLY   0x0001
#define MV_FLAGS_CPS_ONLY   0x0002      // dont know if this is valid or not.
#define MV_FLAGS_CPC_CPS    0x0004      // both 8 bit and 132 bits are def'ed.

#endif  // _TVOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusState.h ===
#ifndef _NVCELSIUSSTATE_H
#define _NVCELSIUSSTATE_H

/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusState.h                                                  *
*     Constants and macros associated with nvCelsiusState.cpp               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)   22June99     created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x010)

// general HW capabilities exported to D3D ----------------------------------

#define CELSIUS_MAXVERTEXCOUNT                    32768
#define CELSIUS_MAXBUFFERSIZE                     0

#define CELSIUS_CAPS_GUARD_BAND_LEFT             -1.0e8f  // nv10 can use a guardband as large as 1e25, but 1e8 appears
#define CELSIUS_CAPS_GUARD_BAND_TOP              -1.0e8f  // to be the largest value that the game re-volt will handle.
#define CELSIUS_CAPS_GUARD_BAND_RIGHT             1.0e8f  // anything larger aggravates an app bug that causes it to
#define CELSIUS_CAPS_GUARD_BAND_BOTTOM            1.0e8f  // send us completely broken geometry.

#define CELSIUS_CAPS_MAX_TEXTURE_REPEAT           8192 // the constraint on nv10 is actually du/dx < 8192
#define CELSIUS_CAPS_MAX_TEXTURE_ASPECT_RATIO     0
#define CELSIUS_CAPS_MAX_ANISOTROPY               2    // Means we support anisotropic filtering.
#define CELSIUS_CAPS_EXTENTS_ADJUST               0

#define CELSIUS_CAPS_MAX_UV_PAIRS                 8    // Number of texture uv's supported.

#define CELSIUS_CAPS_FVF_CAPS                     (CELSIUS_CAPS_MAX_UV_PAIRS | D3DFVFCAPS_DONOTSTRIPELEMENTS)
#define CELSIUS_CAPS_MAX_TEXTURE_BLEND_STATES     8
#define CELSIUS_CAPS_MAX_SIMULTANEOUS_TEXTURES    2

// DX7 stuff
#define CELSIUS_CAPS_MAX_ACTIVE_LIGHTS            8
#define CELSIUS_CAPS_MAX_USER_CLIP_PLANES         0    // we can do 4, but it's not orthogonal to texturing, so WHQL won't let us export it
#define CELSIUS_CAPS_MAX_VERTEX_BLEND_MATRICES    2

// DX8 stuff
#define CELSIUS_CAPS_MAX_STREAMS                  16
#define CELSIUS_CAPS_MAX_PSHADER_CONSTS           16
#define CELSIUS_CAPS_MAX_VSHADER_CONSTS           0
#define CELSIUS_CAPS_MAX_VSHADER_TEMPS            0

// general HW capabilities used internally by driver ------------------------

#define CELSIUS_NUM_COMBINERS            2           // virtual combiner stages
#define CELSIUS_NUM_TEXTURES             2           // texture units

#define CELSIUS_ALIGNMENT_MIN           64
#define CELSIUS_PAGE_MASK               0xfffff000

#define CELSIUS_VIEWPORT_BOUND          2048

// Because our h/w is OpenGL'ized, we must D3D'ize it by adding 0.5 so
// that D3D pixels line up with OpenGL pixels.  Halfsubpixelbias is
// to adjust for floating point numbers which are not accurately
// represented.  E.g., -.7 is actually represented as -.699999
// If coordinates were only positive, this would be ok since it would
// result in being just to the left of the pixel center (integer coord).
// But, since the viewport is -2K...2K and the negative portion is used
// first, we actually end up being to the right of pixel center.
// Since the h/w doesn't do rounding to nearest 1/16 of a pixel, we
// adjust this here by subtracting 1/32 to round it.
#define CELSIUS_D3D2OGL                 0.5f
#define CELSIUS_HALFSUBPIXELBIAS        0.03125f     // round to nearest 1/16 pixel grid
#define CELSIUS_BORDER                  (-CELSIUS_VIEWPORT_BOUND + CELSIUS_D3D2OGL - CELSIUS_HALFSUBPIXELBIAS)

#define TEXTUREPM                       0xCAFEBEEF   // arbitrary identifier
#define TSS_USES_NULL_TEXTURE           0x1

#define CELSIUS_MAX_WINDOWS             8

#define CELSIUS_Z_SCALE16               65535.0f     // 2^16 - 1
#define CELSIUS_Z_SCALE24               16777215.0f  // 2^24 - 1
#define CELSIUS_Z_SCALE16_INV           (1.0f / CELSIUS_Z_SCALE16)
#define CELSIUS_Z_SCALE24_INV           (1.0f / CELSIUS_Z_SCALE24)

// maximum vertices = maximum method data size / maximum vertex size
//                  = 2^11 DWORDs / 16 DWORDs
//                  = 128
#define CELSIUS_MAX_INLINE_VERTICES     120

// maximum fog scale = 2^13. (the HW has 14 bits. we leave one for roundoff)
#define CELSIUS_MAX_FOG_SCALE           8192.0f

#define NONINC_METHOD(method) (0x40000000 | method)

// combiner input masks
#define CELSIUS_COMBINER_A_SOURCE_MASK  0x0f000000
#define CELSIUS_COMBINER_B_SOURCE_MASK  0x000f0000
#define CELSIUS_COMBINER_C_SOURCE_MASK  0x00000f00
#define CELSIUS_COMBINER_D_SOURCE_MASK  0x0000000f

// combiner inputs
typedef enum _celsiusCombinerInput {
    celsiusCombinerInputA = 0,
    celsiusCombinerInputB = 1,
    celsiusCombinerInputC = 2,
    celsiusCombinerInputD = 3,
} celsiusCombinerInput;

// the positions of the inputs in the input control words
static DWORD celsiusCombinerInputShift[4] = {24, 16, 8, 0};

//---------------------------------------------------------------------------
// dirty bits

// celsius uses 0x0000FFFF
// kelvin  uses 0xFFFF0000
#define CELSIUS_DIRTY_DEFAULTS          0x00000001
#define CELSIUS_DIRTY_TL_MODE           0x00000002
#define CELSIUS_DIRTY_FVF               0x00000004
#define CELSIUS_DIRTY_SURFACE           0x00000008
#define CELSIUS_DIRTY_TRANSFORM         0x00000010
#define CELSIUS_DIRTY_TEXTURE_TRANSFORM 0x00000020
#define CELSIUS_DIRTY_CONTROL0          0x00000040
#define CELSIUS_DIRTY_COMBINERS         0x00000080
#define CELSIUS_DIRTY_TEXTURE_STATE     0x00000100
#define CELSIUS_DIRTY_LIGHTS            0x00000200
#define CELSIUS_DIRTY_MISC_STATE        0x00000400
#define CELSIUS_DIRTY_SPECFOG_COMBINER  0x00000800
#define CELSIUS_DIRTY_PIXEL_SHADER      0x00001000

#define CELSIUS_DIRTY_REALLY_FILTHY     (CELSIUS_DIRTY_DEFAULTS          | \
                                         CELSIUS_DIRTY_TL_MODE           | \
                                         CELSIUS_DIRTY_FVF               | \
                                         CELSIUS_DIRTY_SURFACE           | \
                                         CELSIUS_DIRTY_TRANSFORM         | \
                                         CELSIUS_DIRTY_TEXTURE_TRANSFORM | \
                                         CELSIUS_DIRTY_CONTROL0          | \
                                         CELSIUS_DIRTY_COMBINERS         | \
                                         CELSIUS_DIRTY_TEXTURE_STATE     | \
                                         CELSIUS_DIRTY_LIGHTS            | \
                                         CELSIUS_DIRTY_MISC_STATE        | \
                                         CELSIUS_DIRTY_SPECFOG_COMBINER  | \
                                         CELSIUS_DIRTY_PIXEL_SHADER)

//---------------------------------------------------------------------------

// values for the texture stage <=> texture unit mappings
#define CELSIUS_UNUSED                          0xdeadbeef
#define CELSIUS_COMBINER_REG_TEX0               0x00000008      // the combiner's first texture register
                                                                // (data from first texture unit provided we always pack the tex units)

// values for texture unit status
#define CELSIUS_TEXUNITSTATUS_IDLE              0x00000000      // texture unit is unused
#define CELSIUS_TEXUNITSTATUS_USER              0x00000001      // texture unit has a real user-supplied texture
#define CELSIUS_TEXUNITSTATUS_DEFAULT           0x00000002      // texture unit has the default texture
#define CELSIUS_TEXUNITSTATUS_CLIP              0x00000004      // texture unit is being used to handle user clip plnes

#define CELSIUS_TEX_MATRIX_HACK_THRESHOLD       0.0001f         // the value that the broken element must exceed
                                                                // before the texture matrix hack will be enabled.

// general celsius state flags
#define CELSIUS_FLAG_PASSTHROUGHMODE            0x00000001      // are we in passthrough mode?
#define CELSIUS_FLAG_ZFOG                       0x00000002      // are we using z for fog?
#define CELSIUS_FLAG_TEXSTATENEEDSINVMV         0x00000004      // inverse modelview matrix is needed b/c of texture state
#define CELSIUS_FLAG_LIGHTINGNEEDSINVMV         0x00000008      // inverse modelview matrix is needed b/c of light state
#define CELSIUS_FLAG_COMBINERSNEEDSPECULAR      0x00000010      // specular is referenced as a combiner (TSS) input
#define CELSIUS_FLAG_SETUPFAILURE               0x00000020      // did we fail to give the app what it really wanted for one reason or another?
#define CELSIUS_FLAG_COMPUTE_TESS_VTX_STRIDE    0x00000040

// per-texture-unit and per-combiner state flags
#define CELSIUS_FLAG_USERTEXCOORDSNEEDED(i)     (0x00000100 << (4*(i)))  // are user texture coordinates needed by HW texture unit i?
#define CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(i)  (0x00000200 << (4*(i)))  // are we using the hack to get around broken cube maps in passthru mode?
#define CELSIUS_FLAG_TEXMATRIXHACK(i)           (0x00000400 << (4*(i)))  // are we using the hack to get around a broken texture matrix in unit i?
#define CELSIUS_FLAG_TEXMATRIXSWFIX(i)          (0x00000800 << (4*(i)))  // this stage needs a full SW work-around for the broken texture matrix
#define CELSIUS_FLAG_WDIVIDE(i)                 (0x00010000 << (4*(i)))  // is w-divide enabled in HW texture unit i?
#define CELSIUS_FLAG_WSOURCE(i)                 (0x00020000 << (4*(i)))  // can w be sourced from this unit for the purposes of w-buffering?
#define CELSIUS_FLAG_DOTPRODUCT3(i)             (0x00040000 << (4*(i)))  // this stage uses DOTPRODUCT3 as a colorop
#define CELSIUS_FLAG_ADDCOMPLEMENTRGB(i)        (0x00080000 << (4*(i)))  // this stage uses nv4's ADDCOMPLEMENT as a colorop
#define CELSIUS_FLAG_ADDCOMPLEMENTALPHA(i)      (0x01000000 << (4*(i)))  // this stage uses nv4's ADDCOMPLEMENT as an alphaop

#ifdef STOMP_TEX_COORDS
#define CELSIUS_FLAG_STOMP_4TH_COORD(i)         (0x02000000 << (4*(i)))  // stupid app fix: stomp 4th texcoord to 1.0 when they moronically send down extraneous coordinates

#define CELSIUS_FLAG_STOMP_4TH_COORD_MASK       (CELSIUS_FLAG_STOMP_4TH_COORD(0) | CELSIUS_FLAG_STOMP_4TH_COORD(1))
#endif  // STOMP_TEX_COORDS

#define CELSIUS_MASK_TEXMATRIXHACKS             (CELSIUS_FLAG_TEXMATRIXHACK(0)  | CELSIUS_FLAG_TEXMATRIXHACK(1) |   \
                                                 CELSIUS_FLAG_TEXMATRIXSWFIX(0) | CELSIUS_FLAG_TEXMATRIXSWFIX(1))

#ifdef STOMP_TEX_COORDS
#define CELSIUS_MASK_INNERLOOPUNIQUENESS        (CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)    | CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)    |    \
                                                 CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) |    \
                                                 CELSIUS_FLAG_TEXMATRIXHACK(0)          | CELSIUS_FLAG_TEXMATRIXHACK(1)          |    \
                                                 CELSIUS_FLAG_TEXMATRIXSWFIX(0)         | CELSIUS_FLAG_TEXMATRIXSWFIX(1)         |    \
                                                 CELSIUS_FLAG_STOMP_4TH_COORD(0)        | CELSIUS_FLAG_STOMP_4TH_COORD(1))
#else  // !STOMP_TEX_COORDS
#define CELSIUS_MASK_INNERLOOPUNIQUENESS        (CELSIUS_FLAG_USERTEXCOORDSNEEDED(0)    | CELSIUS_FLAG_USERTEXCOORDSNEEDED(1)    |    \
                                                 CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(0) | CELSIUS_FLAG_PASSTHROUGHCUBEMAPPING(1) |    \
                                                 CELSIUS_FLAG_TEXMATRIXHACK(0)          | CELSIUS_FLAG_TEXMATRIXHACK(1)          |    \
                                                 CELSIUS_FLAG_TEXMATRIXSWFIX(0)         | CELSIUS_FLAG_TEXMATRIXSWFIX(1))
#endif  // !STOMP_TEX_COORDS

#define CELSIUS_MASK_COMBINERPROGRAMUNIQUENESS  (CELSIUS_FLAG_DOTPRODUCT3(0) | CELSIUS_FLAG_DOTPRODUCT3(1) | CELSIUS_FLAG_COMBINERSNEEDSPECULAR)

#define CELSIUS_SET_NUM_TEX_COORDS(stage,num)   ((num) << (4*(stage)))
#define CELSIUS_GET_NUM_TEX_COORDS(value,stage) (((value) >> (4*(stage))) & 0xf)

// inner loop constants
#define CELSIUS_ILMASK_PRIMTYPE        0x0000ffff
#define CELSIUS_ILFLAG_LEGACY          0x00010000  // use legacy strides
#define CELSIUS_ILFLAG_CMHACK          0x00020000  // use tex matrix hack vertex copy routine
#define CELSIUS_ILFLAG_NOCULL          0x00040000  // no culling

#define CELSIUS_ILMASK_LOOPTYPE        0xf0000000  // type of inner loop
#define CELSIUS_ILFLAG_IX_VB_PRIM      0x00000000
#define CELSIUS_ILFLAG_IX_STR_PRIM     0x10000000
#define CELSIUS_ILFLAG_IX_INL_PRIM     0x20000000
#define CELSIUS_ILFLAG_IX_INL_TRI_LIST 0x40000000
#define CELSIUS_ILFLAG_IX_DVB_TRI      0x60000000
#define CELSIUS_ILFLAG_OR_VB_PRIM      0x80000000
#define CELSIUS_ILFLAG_OR_STR_PRIM     0x90000000
#define CELSIUS_ILFLAG_OR_INL_PRIM     0xa0000000
#define CELSIUS_ILFLAG_OR_INL_TRI_LIST 0xc0000000
#define CELSIUS_ILFLAG_SUPER_TRI_LIST  0xe0000000

#define CELSIUS_SHORT_INDEXED_PRIM_COUNT_CUTOFF     25    // prim length before we introduce culling
#define CELSIUS_SHORT_ORDERED_PRIM_COUNT_CUTOFF     25

// xPipe / Super-tri constants
#define CELSIUS_CULLFLAG_MODELOK       0x00000001

// xPipe / Super-tri inner loop flags. These ought to be in the inner loop flags above, but we don't have enough
// flag bits.
#define CELSIUS_STILFLAG_STDEFVB       0x00000001  // default VB is used (affects supertri logic)
#define CELSIUS_STILFLAG_MODEL         0x00000002  // Model Culling
#define CELSIUS_STILFLAG_XFORM         0x00000004  // Xform / clipcheck / cull
#define CELSIUS_STILFLAG_HIBW          0x00000008  // High bandwidth mode -- check all triangles

#ifdef WIN2K_DX7OPT
// copy of system memory vertices into hardware readable VB's
#define CELSIUS_CPFLAG_SYS2AGP         0x00000001
#define CELSIUS_CPFLAG_RESTORE         0x00000002
#define CELSIUS_CPFLAG_UPDATEMAP       0x00000004
#endif

// types
typedef void (__stdcall *CELSIUSDISPATCHPRIMITIVE)(void);

#ifdef STATE_CULL
#define CELSIUS_HWSTATE_SIZE (0x1000 >> 2)
#endif

//---------------------------------------------------------------------------

// forward definitions
class CVertexShader;

//---------------------------------------------------------------------------

// information about the state of the celsius object. these values are:
// a. shadowed from the HW so we can detect changes, or
// b. derived from several others and cached here to avoid
//    lengthy recalculation every time they're needed

class CCelsiusState
{
    //
    // intermediate state
    //
public:
#ifdef STATE_CULL
    DWORD hwState[CELSIUS_HWSTATE_SIZE];                // shadow of the hw state
    DWORD valid[CELSIUS_HWSTATE_SIZE];                  // shadow state invalidation
#endif

// bank
    DWORD          dwZEnable;                           // z-buffering? w-buffering?
    DWORD          dwSavedTexUnitToTexStageMapping[2];  // backup of mapping state so that pixel shaders can restore state when disabled
    DWORD          pfnVertexCopy;                       // routine that copies the actual vertices
    DWORD          _pad4[2];
// bank
#ifdef WIN2K_DX7OPT
    DWORD          dwSTBuff_VBOffset;                 // SuperTriangle lookaside buffer vertex buffer offset
    DWORD          dwCPFlags;                         // Copy flags
    DWORD          dw_DP2VertexLength;                // pdp2d->dwVertexLength
    DWORD          dw_DP2VertexOffset;                // pdp2d->dwVertexOffset
    DWORD          dwPromoVBOffset;
    CVertexBuffer *pPromo_DP2VertexBuffer;            // Pointer to promoted vertex buffer supplied by DP2 (or NULL)
    CVertexBuffer *pSave_VertexBufferInUse;           // vertex buffer to program in SetCelsiusState
    DWORD          _pad5[1];
#endif

//////////////////////////////////////////////////////////////////////////////
// smart celsius
//////////////////////////////////////////////////////////////////////////////

public:
    // workaround for a nv10 decode bug. fixed for all other chips, but harmless if used
    // apply before the following methods:-
    //   NV056_SET_SURFACE_CLIP_HORIZONTAL
    //   NV056_SET_SURFACE_CLIP_VERTICAL
    //   NV056_SET_SURFACE_FORMAT
    //   NV056_SET_SURFACE_PITCH
    //   NV056_SET_SURFACE_COLOR_OFFSET
    //   NV056_SET_SURFACE_ZETA_OFFSET
    //   NV056_SET_FOG_MODE
    //   NV056_SET_WINDOW_CLIP_TYPE
    //   NV056_SET_WINDOW_CLIP_HORIZONTAL(i)
    //   NV056_SET_WINDOW_CLIP_VERTICAL(i)
    __forceinline void prep_wait_for_idle_nv10 (void)
    {
        nvPushData (0,0x00040000 | (NV_DD_CELSIUS << 13) | NV056_NO_OPERATION);
        nvPushData (1,0);
        nvPusherAdjust (2);
    }
    void set (DWORD dwOffset, DWORD dwData0)
    {
#ifdef STATE_CULL
        BOOL bSend = FALSE;
        if (dwOffset & 0x1000) {
            // drawing method. must send
            bSend = TRUE;
        }
        else {
            DWORD dwIndex = (dwOffset & 0xfff) >> 2;
            if ((hwState[dwIndex+0] != dwData0) ||
                (!valid[dwIndex]))
            {
                bSend = TRUE;
                hwState[dwIndex+0] = dwData0;
                valid[dwIndex] = 1;
            }
        }
        if (bSend) 
#endif
        {
            getDC()->nvPusher.push (0, 0x00040000 | (NV_DD_CELSIUS << 13) | dwOffset);
            getDC()->nvPusher.push (1, dwData0);
            getDC()->nvPusher.adjust (2);
        }
    }
    void set2 (DWORD dwOffset, DWORD dwData0, DWORD dwData1)
    {
#ifdef STATE_CULL
        BOOL bSend = FALSE;
        if (dwOffset & 0x1000) {
            // drawing method. must send
            bSend = TRUE;
        }
        else {
            DWORD dwIndex = (dwOffset & 0xfff) >> 2;
            if ((hwState[dwIndex+0] != dwData0) ||
                (hwState[dwIndex+1] != dwData1) ||
                (!valid[dwIndex]))
            {
                bSend = TRUE;
                hwState[dwIndex+0] = dwData0;
                hwState[dwIndex+1] = dwData1;
                valid[dwIndex] = 1;
            }
        }
        if (bSend)
#endif
        {
            getDC()->nvPusher.push (0, 0x00080000 | (NV_DD_CELSIUS << 13) | dwOffset);
            getDC()->nvPusher.push (1, dwData0);
            getDC()->nvPusher.push (2, dwData1);
            getDC()->nvPusher.adjust (3);
        }
    }
    void set3 (DWORD dwOffset, DWORD dwData0, DWORD dwData1, DWORD dwData2)
    {
#ifdef STATE_CULL
        BOOL bSend = FALSE;
        if (dwOffset & 0x1000) {
            // drawing method. must send
            bSend = TRUE;
        }
        else {
            DWORD dwIndex = (dwOffset & 0xfff) >> 2;
            if ((hwState[dwIndex+0] != dwData0) ||
                (hwState[dwIndex+1] != dwData1) ||
                (hwState[dwIndex+2] != dwData2) ||
                (!valid[dwIndex]))
            {
                bSend = TRUE;
                hwState[dwIndex+0] = dwData0;
                hwState[dwIndex+1] = dwData1;
                hwState[dwIndex+2] = dwData2;
                valid[dwIndex] = 1;
            }
        }
        if (bSend)
#endif
        {
            getDC()->nvPusher.push (0, 0x000C0000 | (NV_DD_CELSIUS << 13) | dwOffset);
            getDC()->nvPusher.push (1, dwData0);
            getDC()->nvPusher.push (2, dwData1);
            getDC()->nvPusher.push (3, dwData2);
            getDC()->nvPusher.adjust (4);
        }
    }
    void set4 (DWORD dwOffset, DWORD dwData0, DWORD dwData1, DWORD dwData2, DWORD dwData3)
    {
#ifdef STATE_CULL
        BOOL bSend = FALSE;
        if (dwOffset & 0x1000) {
            // drawing method. must send
            bSend = TRUE;
        }
        else {
            DWORD dwIndex = (dwOffset & 0xfff) >> 2;
            if ((hwState[dwIndex+0] != dwData0) ||
                (hwState[dwIndex+1] != dwData1) ||
                (hwState[dwIndex+2] != dwData2) ||
                (hwState[dwIndex+3] != dwData3) ||
                (!valid[dwIndex]))
            {
                bSend = TRUE;
                hwState[dwIndex+0] = dwData0;
                hwState[dwIndex+1] = dwData1;
                hwState[dwIndex+2] = dwData2;
                hwState[dwIndex+3] = dwData3;
                valid[dwIndex] = 1;
            }
        }
        if (bSend)
#endif
        {
            getDC()->nvPusher.push (0, 0x00100000 | (NV_DD_CELSIUS << 13) | dwOffset);
            getDC()->nvPusher.push (1, dwData0);
            getDC()->nvPusher.push (2, dwData1);
            getDC()->nvPusher.push (3, dwData2);
            getDC()->nvPusher.push (4, dwData3);
            getDC()->nvPusher.adjust (5);
        }
    }

    //////////////////////////////////////////////////////////////////////////

    __forceinline void setf (DWORD dwOffset,float fData)
    {
        set (dwOffset,*(DWORD*)&fData);
    }
    __forceinline void set2f (DWORD dwOffset,float fData0,float fData1)
    {
        set2(dwOffset, *(DWORD*)&fData0, *(DWORD*)&fData1);
    }
    __forceinline void set3f (DWORD dwOffset,float fData0,float fData1,float fData2)
    {
        set3(dwOffset, *(DWORD*)&fData0, *(DWORD*)&fData1, *(DWORD*)&fData2);
    }
    __forceinline void set4f (DWORD dwOffset,float fData0,float fData1,float fData2,float fData3)
    {
        set4(dwOffset, *(DWORD*)&fData0, *(DWORD*)&fData1, *(DWORD*)&fData2, *(DWORD*)&fData3);
    }

    //////////////////////////////////////////////////////////////////////////
    // for cubemapping we need to move r into q's slot since HW can't actually see r and uses q instead
    // if the user doesn't give us a texture transform, just use a munged identity matrix
    void setTextureTransformMatrixCubeMapIdent (DWORD dwName)
    {
        set4f (dwName +  0,1.0f,0.0f,0.0f,0.0f);
        set4f (dwName + 16,0.0f,1.0f,0.0f,0.0f);
        set4f (dwName + 32,0.0f,0.0f,0.0f,0.0f);
        set4f (dwName + 48,0.0f,0.0f,1.0f,0.0f);
    }
    // if the user gave a matrix, move the third column to the 4th and transpose
    void setTextureTransformMatrixCubeMap (DWORD dwName,D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0,pMatrix->_11,pMatrix->_21,pMatrix->_31,pMatrix->_41);
        set4f (dwName + 16,pMatrix->_12,pMatrix->_22,pMatrix->_32,pMatrix->_42);
        set4f (dwName + 32,0.0f,        0.0f,        0.0f,        0.0f        );
        set4f (dwName + 48,pMatrix->_13,pMatrix->_23,pMatrix->_33,pMatrix->_43);
    }

    // the form of the texture transform matrix varies depending on the number
    // of texture coords and on whether or not projection is enabled.
    // 1.) if there are two texture coordinates, then only the upper left
    // 3x3 is used. openGL and kelvin, however, always put q in the fourth position.
    // for these cases, we need to expand the 3x3 to a 4x4 and then transpose
    // 2.) if projection is disabled it is OUR reponsibility to override the
    // last column of the matrix with [0 0 0 1]' to produce q==1.0
    // type A : expand, override, and transpose
    void setTextureTransformMatrixTypeA (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // type B : override, and transpose
    void setTextureTransformMatrixTypeB (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, 0.0f,         0.0f,         0.0f,         1.0f        );
    }
    // type C : expand and transpose
    void setTextureTransformMatrixTypeC (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, 0.0f,         pMatrix->_31);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, 0.0f,         pMatrix->_32);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, pMatrix->_13, pMatrix->_23, 0.0f,         pMatrix->_33);
    }
    // type D : just transpose
    void setTextureTransformMatrixTypeD (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, 0.0f,         0.0f,         0.0f,         0.0f        );
        set4f (dwName + 48, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
    }

    void setInverseModelViewMatrix (DWORD dwName, D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_12, pMatrix->_13, pMatrix->_14);
        set4f (dwName + 16, pMatrix->_21, pMatrix->_22, pMatrix->_23, pMatrix->_24);
        set4f (dwName + 32, pMatrix->_31, pMatrix->_32, pMatrix->_33, pMatrix->_34);
    }

    // transpose the matrix since d3d does {v}[M] instead of [M]{v}'
    void setMatrixTransposed (DWORD dwName,D3DMATRIX *pMatrix)
    {
        set4f (dwName +  0, pMatrix->_11, pMatrix->_21, pMatrix->_31, pMatrix->_41);
        set4f (dwName + 16, pMatrix->_12, pMatrix->_22, pMatrix->_32, pMatrix->_42);
        set4f (dwName + 32, pMatrix->_13, pMatrix->_23, pMatrix->_33, pMatrix->_43);
        set4f (dwName + 48, pMatrix->_14, pMatrix->_24, pMatrix->_34, pMatrix->_44);
    }

    //////////////////////////////////////////////////////////////////////////

    void setMatrixIdent (DWORD dwName)
    {
        set4f (dwName +  0,1.0f,0.0f,0.0f,0.0f);
        set4f (dwName + 16,0.0f,1.0f,0.0f,0.0f);
        set4f (dwName + 32,0.0f,0.0f,1.0f,0.0f);
        set4f (dwName + 48,0.0f,0.0f,0.0f,1.0f);
    }

    //////////////////////////////////////////////////////////////////////////

public:
    inline void queueTLNOP (void)
    {
        getDC()->nvPusher.push (0,0x00040000 | (NV_DD_CELSIUS << 13) | NV056_TL_NOP);
        getDC()->nvPusher.push (1,0);
        getDC()->nvPusher.adjust (2);
    }

public:
};

// prototypes ---------------------------------------------------------------

// update all state of the celsius object
// should be called prior to rendering
HRESULT __stdcall nvSetCelsiusState        (PNVD3DCONTEXT pContext);
HRESULT           nvSetCelsiusVertexFormat (PNVD3DCONTEXT pContext);
HRESULT           nvSetCelsiusTextureState (PNVD3DCONTEXT pContext);
HRESULT           nvSetCelsiusMiscState    (PNVD3DCONTEXT pContext);

CELSIUSDISPATCHPRIMITIVE nvCelsiusGetDispatchRoutine (PNVD3DCONTEXT pConext,DWORD dwFlags);

#endif  // NVARCH >= 0x010

#endif  // _NVCELSIUSSTATE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusNvTSS.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvCelsiusNvTSS.h
//      Celsius 2 stage combiner setup routines.
//
// **************************************************************************
//
//  History:
//      Lorie Sixia Deng       12Dec99         NV10 development
//
// **************************************************************************

#ifndef _NVCELSIUSNVTSS_H
#define _NVCELSIUSNVTSS_H

#define COMBINER_STATUS 0

#if (NVARCH >= 0x10)

// prototypes
BOOL nvCheckBumpMapStates          (PNVD3DCONTEXT pContext, int nStage);
BOOL nvCelsiusCheck3Stage2Textures (PNVD3DCONTEXT pContext);
BOOL nvCelsiusCheck2Stage1Combiner (PNVD3DCONTEXT pContext);
BOOL nvCelsiusCheck3StageSpecial (PNVD3DCONTEXT pContext);


HRESULT nvSetCelsius8StageBumpMapCombiners  (PNVD3DCONTEXT pContext);
HRESULT nvSetCelsius4StageBumpMapCombiners  (PNVD3DCONTEXT pContext);
HRESULT nvCelsiusSetTextures3StageCombiners (PNVD3DCONTEXT pContext);
HRESULT nvCelsiusSet2Stage1Combiner (PNVD3DCONTEXT pContext);
HRESULT nvCelsiusSet3StageSpecial (PNVD3DCONTEXT pContext);

#endif//NVARCH >= 0x10
#endif//_NVCELSIUSNVTSS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusTables.h ===
#ifndef _NVCELSIUSTABLES_H
#define _NVCELSIUSTABLES_H

/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusTables.h                                                 *
*     Constants and macros associated with nvCelsiusTables.cpp              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler    (bertrem)    23June99    created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x010)

// table for looking up pre-computed combiner settings for legacy texture blends
extern DWORD celsiusTextureBlendSettings[D3D_TBLEND_MAX+1][4];
extern DWORD celsiusTextureBlendDefault[4];

// table of dependencies between d3d renderstates and celsius state
extern DWORD celsiusDirtyBitsFromRenderState[D3D_RENDERSTATE_MAX+1];

// table of dependencies between d3d texture stage states and celsius state
extern DWORD celsiusDirtyBitsFromTextureStageState[D3D_TEXSTAGESTATE_MAX+1];

// table mapping dp2ops to the celsius method values associated with them.
extern DWORD celsiusBeginEndOp[D3D_DP2OP_MAX+1];

// table mapping dp2ops to the scale and bias required to calculate
// the number of vertices from the number of primitives.
extern DWORD celsiusPrimitiveToPrimitiveMagic[D3D_DP2OP_MAX+1];

#ifdef DEBUG
// table for primitive names
extern char* celsiusPrimitiveName[D3D_DP2OP_MAX+1];
#endif

#endif  // NVARCH >= 0x010

#endif  // _NVCELSIUSTABLES_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusAA.h ===
#ifndef _NVCELSIUSAA_H
#define _NVCELSIUSAA_H

/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 *
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusAA.h                                                     *
*     prototypes for aa routines                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal                      12Jan2000   created                *
*                                                                           *
\***************************************************************************/

#if (NVARCH >= 0x010)

struct AAAppCompatState
{
    LPTSTR lpApp;
    BOOL bNoAA;
    BOOL bPath;
    BOOL bDiscardFBContents;
    BOOL bAlwaysMagnifyUponUnlock;
    BOOL bMinifyUponEndScene;
    BOOL bDither;
    BOOL bBlitSync;
    BOOL bDiscardSRT;
    BOOL bAllowSpecial;
};

#define AA_ENABLED(pDriverData, pContext) \
    (((pDriverData)->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK) \
     && (((pContext)->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE) \
     || ((pDriverData)->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK)))

struct AASTATE
{
    enum
    {
        FLAG_ENABLED        = 0x80000000,       // aa is enabled and in use
        FLAG_INIT           = 0x20000000,       // aa is ready (super buffers exist)
        FLAG_SUSPENDED      = 0x10000000,       // aa is enabled but suspended for render to texture


        FLAG_RT_VALID       = 0x00800000,       // render target valid
        FLAG_ZB_VALID       = 0x00400000,       // zeta buffer valid
        FLAG_SRT_VALID      = 0x00200000,       // super render target valid
        FLAG_SZB_VALID      = 0x00100000,       // super zeta buffer valid

        MASK_BSCOUNT        = 0x00000ff0,
            BSC_RESET           = 0x200,
            BSC_DEC             = 0x010,

        MASK_METHOD         = 0x00000007,
            METHOD_1x2          = 0,
            METHOD_2x2lod       = 1,
            METHOD_2x2          = 2,
            METHOD_2x2spec      = 3,
            METHOD_3x3lod       = 4,
            METHOD_3x3          = 5,
            METHOD_4x4lod       = 6,
            METHOD_4x4          = 7,
    };
// bank
protected:
    DWORD dwFlags;

public:
    AAAppCompatState mAppCompat;

    CSimpleSurface *pSuperRenderTarget;
    CSimpleSurface *pSuperZetaBuffer;
    CSimpleSurface *pBlitTempSpace;

    float fWidthAmplifier;
    float fHeightAmplifier;
    DWORD dwDepthAmplifier;

    DWORD dwOriginalRenderTargetWidth;
    DWORD dwOriginalRenderTargetHeight;
    DWORD dwOriginalZBHandle;

    float fLODBias;
    DWORD dwLinePointSize;

    // helpers
    inline void setFlags (DWORD dwMask)
    {
        dwFlags |= dwMask;
        invalidateState();
    }

    inline void modFlags (DWORD dwAndMask,DWORD dwOrMask)
    {
        dwFlags &= dwAndMask;
        dwFlags |= dwOrMask;
        invalidateState();
    }

    inline BOOL isInit (void) const
    {
        return dwFlags & AASTATE::FLAG_INIT;
    }

    inline BOOL isEnabled (void) const
    {
        return dwFlags & AASTATE::FLAG_ENABLED;
    }

    inline BOOL isSuspended (void) const
    {
        return dwFlags & AASTATE::FLAG_SUSPENDED;
    }

    inline BOOL isRenderTargetValid (void) const
    {
        return dwFlags & AASTATE::FLAG_RT_VALID;
    }

    inline BOOL isSuperBufferValid (void) const
    {
        return dwFlags & AASTATE::FLAG_SRT_VALID;
    }

    inline BOOL isZetaBufferValid (void) const
    {
        return dwFlags & AASTATE::FLAG_ZB_VALID;
    }

    inline BOOL isSuperZBValid (void) const
    {
        return dwFlags & AASTATE::FLAG_SZB_VALID;
    }

    inline void invalidateSRT() {
        dwFlags &= ~FLAG_SRT_VALID;
    }

    inline void makeRenderBuffersMatch (PNVD3DCONTEXT pContext);
    inline void makeZBuffersMatch (PNVD3DCONTEXT pContext);

    // In the next four functions, we assume that at least one of the
    // buffers (of each type, either color or Z), is valid.
    // Instantiated in nvCelsiusAA.cpp
    void makeRenderTargetValid (PNVD3DCONTEXT pContext);
    void makeZetaBufferValid (PNVD3DCONTEXT pContext);
    void makeSuperBufferValid (PNVD3DCONTEXT pContext);
    void makeSuperZBValid (PNVD3DCONTEXT pContext);

    inline DWORD getMethod (void) const
    {
        return dwFlags & AASTATE::MASK_METHOD;
    }

    inline void bsReset (void)
    {
        dwFlags &= ~MASK_BSCOUNT;
        dwFlags |=  BSC_RESET;
    }

    inline BOOL bsDec (void)
    {
        if (dwFlags & MASK_BSCOUNT)
        {
            dwFlags -= BSC_DEC;
            return 0;
        }
        return 1;
    }

    inline BOOL WantEnabled (PNVD3DCONTEXT pContext);

    // The next few parts basically parallel various parts fo the driver.
    // They are called just before the various D3D functions are executed
    // to prepare the AA buffers for proper use.

    inline void BeginScene (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) Create(pContext);
    }

    inline void EndScene (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;

#ifndef WINNT   // WinNT requires that we minify on endscene in windowed apps
        if (mAppCompat.bMinifyUponEndScene)
#endif
        {
            makeRenderTargetValid(pContext);
        }
    }

    inline void Flip (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;

        if (!(dwFlags & AASTATE::FLAG_RT_VALID)) {
            // Don't set both buffers valid unless we are
            // actively making the render target valid.
            makeRenderTargetValid(pContext);
            if (mAppCompat.bDiscardFBContents) {
                // We don't care what happens to the superbuffer after
                // this, so either buffer can be valid
                setFlags(AASTATE::FLAG_SRT_VALID);
            }
        }
    }

    inline void Lock (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        makeRenderTargetValid(pContext);
    }

    inline void LockZ (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        makeZetaBufferValid(pContext);
    }

    inline void Unlock (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        //invalidateSRT();
        if (mAppCompat.bAlwaysMagnifyUponUnlock) makeSuperBufferValid(pContext);
    }

    inline void UnlockZ (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        if (mAppCompat.bAlwaysMagnifyUponUnlock) makeSuperZBValid(pContext);
    }

    inline void Rendering (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;

        makeSuperBufferValid(pContext);
        makeSuperZBValid(pContext);
    }

    inline void Minify (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        makeRenderTargetValid(pContext);
    }

    inline void MinifyZ (PNVD3DCONTEXT pContext)
    {
        if (!isEnabled()) return;
        makeZetaBufferValid(pContext);
    }

    void Create          (PNVD3DCONTEXT pContext);
    void invalidateState (void);

};

//
// prototypes
//
PNVD3DCONTEXT nvCelsiusAAFindContext         (CSimpleSurface *pSurface);
BOOL          nvCelsiusAACanCreate           (LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl);
BOOL          nvCelsiusAACreate              (PNVD3DCONTEXT pContext);
BOOL          nvCelsiusAADestroy             (PNVD3DCONTEXT pContext);
void          nvCelsiusAASelectSuperBuffers  (PNVD3DCONTEXT pContext);
void          nvCelsiusAASelectNormalBuffers (PNVD3DCONTEXT pContext,BOOL bPreserveBufferContents);
void          nvCelsiusAAMagnify             (PNVD3DCONTEXT pContext);
void          nvCelsiusAAMinify              (PNVD3DCONTEXT pContext);
void          nvCelsiusAAMagnifyZ            (PNVD3DCONTEXT pContext);
void          nvCelsiusAAMinifyZ             (PNVD3DCONTEXT pContext);


#endif  // NVARCH >= 0x010

#endif  // _NVCELSIUSAA_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusAACompatibility.h ===
// AA_ON                   The default
// NO_AA_ON	           Use if AA just seems fundamentally broken	
// DISCARD_FB              The default
// DONT_DISCARD_FB         Use if there seems to be 2D corruption: missing buttons,
//                         cursor trails, etc
// DONT_MAGNIFY_ON_UNLOCK  The default
// MAGNIFY_ON_UNLOCK       Try this as a secondary measure for 2D corruption
// DONT_MINIFY_ON_ENDSCENE The default
// MINIFY_ON_ENDSCENE      Use for windowed apps if the scene doesn't seem to be updating
// DONT_DITHER             The default
// DITHER                  Use if color banding seems to be a problem. May cause weird
//                         color effects for 2D
// BLIT_SYNC		   Force blitting to always sync the render and super render targets by always blitting to the render target
// NO_BLIT_SYNC		   The Default
// DISCARD_SRT		   Invalidate the super render target when the render target changes
// DONT_DISCARD_SRT        The default
// ALLOW_SPECIAL	         The default
// DONT_ALLOW_SPECIAL	   Force down one level if special is set
//
// If you can't seem to get a game working, make sure you have the right .exe file.  Some
// games launch other exe files.  Check the game directories for other .exe files, and try using 
// those

// Default settings to cut-n-paste from
// appcompat("game.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//Descent: Freespace 2
appcompat("fs2.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//Omikron, the Nomad Soul
appcompat("nomad.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)


//Crusaders of Might and Magic, demo ('crusaders' matches 'crusaders demo.exe') and full version presumably.
appcompat("crusaders", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
appcompat("crusaders.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)


appcompat("eqgame.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
appcompat("bend.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

appcompat("powerslide.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

appcompat("hiddenevil.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("mcm2.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("allegiance.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)


// Apps that just break when dithering is on
// Wild Wild West
appcompat("vrdmfc.exe", NO_PATH, AA_ON, DISCARD_FB, MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
// Superbike
appcompat("bike.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("revolt.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)


//RogueSpear
appcompat("roguespear.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("rainbowsix.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

// baseball 20001
appcompat("baseball2001.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

appcompat("lemans.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

// Turned off because it doesn't react well to buffers not being allocated =)
appcompat("c:\\program files\\motoracer\\go.exe", FULL_PATH, NO_AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

// NON FUNCTIONAL with AA (IE, There not worth the trouble)
appcompat("moto.exe",  NO_PATH, NO_AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
appcompat("df2.exe",  NO_PATH, NO_AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

appcompat("nascar", NO_PATH, NO_AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)
appcompat("f1_2000.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

appcompat("avp.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//MTM2, retail and demo
appcompat("monster.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("monsterx.exe", NO_PATH, AA_ON, DONT_DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Madden 99
appcompat("madnd3d.exe", NO_PATH, AA_ON, DISCARD_FB, MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//Homeworld
appcompat("homeworld.exe", NO_PATH, AA_ON, DISCARD_FB, MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//Machines
appcompat("machines.exe", NO_PATH, NO_AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Shogun
appcompat("shogdemo.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("shogun.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

appcompat("hellbndx.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("shadows.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, ALLOW_SPECIAL)

//KA-52 Team Alligator
appcompat("sldteam2.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//USAF
appcompat("usaf.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("usafdemo.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

appcompat("revenant.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//ground control
appcompat("gc.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, ALLOW_SPECIAL)

//sports car GT
appcompat("spcar.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

// Nocturne
appcompat("nocturne.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

// Mech warrior
appcompat("mech3demo.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Panzer Commander  
appcompat("panzer.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Fox BB2k
appcompat("foxbb2k.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

appcompat("td5_d3d.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, MINIFY_ON_ENDSCENE, DONT_DITHER, BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Everquest
appcompat("everquest.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("eqgame.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

// Layrinth
appcompat("thelabyrinth.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Links 2001
appcompat("linkslauncher.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)
appcompat("linksmmi.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//Vampire
appcompat("vampire.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

//championship bass
appcompat("championshipbass.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DONT_DITHER, NO_BLIT_SYNC, DONT_DISCARD_SRT, DONT_ALLOW_SPECIAL)

// Psygnosis Expert Pool
appcompat("pool.exe", NO_PATH, AA_ON, DISCARD_FB, DONT_MAGNIFY_ON_UNLOCK, DONT_MINIFY_ON_ENDSCENE, DITHER, NO_BLIT_SYNC, DISCARD_SRT, DONT_ALLOW_SPECIAL)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\inc\nvCelsiusStateHelp.h ===
// **************************************************************************
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NOTICE TO USER:   The source code  is copyrighted under  U.S. and
//     international laws.  Users and possessors of this source code are
//     hereby granted a nonexclusive,  royalty-free copyright license to
//     use this code in individual and commercial software.
//
//     Any use of this source code must include,  in the user documenta-
//     tion and  internal comments to the code,  notices to the end user
//     as follows:
//
//       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.
//
//     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY
//     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"
//     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-
//     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,
//     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-
//     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL
//     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-
//     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-
//     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION
//     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF
//     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.
//
//     U.S. Government  End  Users.   This source code  is a "commercial
//     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),
//     consisting  of "commercial  computer  software"  and  "commercial
//     computer  software  documentation,"  as such  terms  are  used in
//     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-
//     ment only as  a commercial end item.   Consistent with  48 C.F.R.
//     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),
//     all U.S. Government End Users  acquire the source code  with only
//     those rights set forth herein.
//
// ********************************* Direct 3D ******************************
//
//  Module: nvCelsiusStateHelp.h
//      Constants, macros, and prototypes for nvCelsiusStateHelp.cpp
//
// **************************************************************************
//
//  History:
//       Craig Duttweiler        27Sep99         created
//
// **************************************************************************

#ifndef _NVCELSIUSSTATEHELP_H
#define _NVCELSIUSSTATEHELP_H

#if (NVARCH >= 0x010)

// combiner program hash table stuff

#define D3DTA_FLAGMASK           (D3DTA_COMPLEMENT | D3DTA_ALPHAREPLICATE)
#define NVTSSARGMASK(dwArg)      ((dwArg & D3DTA_SELECTMASK) | ((dwArg & D3DTA_FLAGMASK) >> 1))

#define CELSIUSCPTABLE_INDEXMASK 0x7f  // should be <= 0xff
#define CELSIUSCPTABLE_SIZE      (CELSIUSCPTABLE_INDEXMASK+1)

typedef struct __CELSIUSCOMBINERPROGRAM {
    // tags
    DWORD dwTSSMask0;
    DWORD dwTSSMask1;
    // data
    DWORD dwStateFlags;
    DWORD dwColorICW[2];
    DWORD dwColorOCW[2];
    DWORD dwAlphaICW[2];
    DWORD dwAlphaOCW[2];
    DWORD dwTexUnitMapping[2];
    DWORD dwNumActiveStages;
    // link to resolve hash collisions
    struct __CELSIUSCOMBINERPROGRAM *pNext;
} CELSIUSCOMBINERPROGRAM, *PCELSIUSCOMBINERPROGRAM;

//---------------------------------------------------------------------------

// prototypes

void  explut (float n, float *l, float *m);
DWORD nvCelsiusBuildTSSMask                   (PNVD3DCONTEXT pContext, DWORD dwStage);
BOOL  nvCelsiusCombinersSetFromHashTable      (PNVD3DCONTEXT pContext, DWORD dwTSSMask0, DWORD dwTSSMask1);
void  nvCelsiusCombinersAddProgramToHashTable (PCELSIUSCOMBINERPROGRAM pProgram);
BOOL  nvCelsiusCombinersAddToHashTable        (PNVD3DCONTEXT pContext, DWORD dwTSSMask0, DWORD dwTSSMask1);
DWORD nvCelsiusValidateTextureStageState      (LPD3DHAL_VALIDATETEXTURESTAGESTATEDATA);

#endif  // NVARCH >= 0x010

#endif  // _NVCELSIUSSTATEHELP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusAA.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusAA.cpp                                                   *
*   Celsius antialiasing                                                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Ben de Waal             11Jan2000       NV15 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"


#if (NVARCH >= 0x10)

//////////////////////////////////////////////////////////////////////////////
// super buffer info
//
struct AAMETHODINFO
{
    float fXScale;
    float fYScale;
    DWORD dwLODBias;
    DWORD dwLinePointSize; 
};

static AAMETHODINFO g_aAAMethodInfo[] =
{
   // X     Y     bias(4.4) line/point size (6.3)
    { 1.0f, 2.0f, 0x00,          0x0C           },// 1x2
    { 2.0f, 2.0f, 0x10,          0x10           },// 2x2 lod
    { 2.0f, 2.0f, 0x00,          0x10           },// 2x2
    { 2.0f, 2.0f, 0x00,          0x10           },// 2x2 spec
    { 3.0f, 3.0f, 0x19,          0x18           },// 3x3 lod
    { 3.0f, 3.0f, 0x00,          0x18           },// 3x3
    { 4.0f, 4.0f, 0x20,          0x20           },// 4x4 lod
    { 4.0f, 4.0f, 0x00,          0x20           },// 4x4
};

// Methods starting with this one require a temporary work space for blits.
#define FIRST_TEMP_SPACE_METHOD 3

__declspec(dllexport) void nvCelsiusAAInitCompatibilitySettings();
__declspec(dllexport) void nvCelsiusAAGetCompatibilitySettings(PNVD3DCONTEXT);

extern char* nvGetCommandLine();

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAFindContext
//
PNVD3DCONTEXT nvCelsiusAAFindContext
(
    CSimpleSurface *pSurface
)
{

    //if the surface is NULL (i.e. we tried to get a CSimpleSurface from
    //a CTexture object this will be null.  Combine that with a NULL zbuffer
    //and we'll return a context that matches.  BAD.

    if(!pSurface) return NULL;

    // AA is enabled for some context. Now we have to find out which one
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext)
    {
        // is this the one?
        if (pContext->pZetaBuffer == pSurface)
        {
            return pContext;
        }
        if (pContext->pRenderTarget == pSurface)
        {
            return pContext;
        }

        // next
        pContext = pContext->pContextNext;
    }

    // not found
    return NULL;
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAACanCreate
//
BOOL nvCelsiusAACanCreate
(
    LPDDRAWI_DDRAWSURFACE_LCL pDDSLcl
)
{
    //
    // figure out if we have enough memory to create AA buffers.
    //  AA may still fail if the memory is not available at nvCelsiusAACreate() time which
    //  is invoked when AA renderstate is set (i.e. this function may give false positives).
    //

    //
    // does registry allow it and do we have to right AA bits set
    //
    DWORD dwCaps  = pDDSLcl->ddsCaps.dwCaps;
    DWORD dwCaps2 = pDDSLcl->lpSurfMore->ddsCapsEx.dwCaps2;
    if (!(dwCaps & DDSCAPS_3DDEVICE)
     || !(dwCaps2 & DDSCAPS2_HINTANTIALIASING)
     || !(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK))
    {
        return TRUE; // since AA is not enabled, allow creation to continue
    }

    //
    // extract surface info
    //
    DWORD dwBufferWidth  = pDDSLcl->lpGbl->wWidth;
    DWORD dwBufferHeight = pDDSLcl->lpGbl->wHeight;

    DWORD dwBufferBPP    = (pDDSLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT)
                         ? (pDDSLcl->lpGbl->ddpfSurface.dwRGBBitCount / 8)
                         : (GET_MODE_BPP() / 8);

    //
    // try all combinations
    //
    DWORD dwAAMethodMax = getDC()->nvD3DRegistryData.regAntiAliasQuality - 1;
    for (DWORD dwAAMethod = dwAAMethodMax; !(dwAAMethod & 0x80000000); dwAAMethod--)
    {
        //
        // set up data
        //
        float fWidthAmplifier  = g_aAAMethodInfo[dwAAMethod].fXScale;
        float fHeightAmplifier = g_aAAMethodInfo[dwAAMethod].fYScale;

        /*
        //
        // check again if we can AA this buffer
        //
        if (((dwBufferWidth  * fWidthAmplifier)  > 2048.0f)
         || ((dwBufferHeight * fHeightAmplifier) > 2048.0f))
        {
            // next
            continue;
        }
        */


        //
        // see if we can allocate all the memory required by computation
        //   we will have 2 super buffers and usually 3 normal buffers
        //
        DWORD dwMemoryRequired  = DWORD(2 * dwBufferWidth * fWidthAmplifier * dwBufferHeight * fHeightAmplifier * dwBufferBPP
                                      + 3 * dwBufferWidth *                   dwBufferHeight *                    dwBufferBPP);
              dwMemoryRequired += dwMemoryRequired / 20; // add 5% wastage

        if (dwMemoryRequired > (DWORD)pDriverData->VideoHeapTotal)
        {
            continue;
        }

        //
        // this looks like a good combination - accept
        //
        return TRUE;
    }

    //
    // none found - fail
    //
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAACreate
//
BOOL nvCelsiusAACreate
(
    PNVD3DCONTEXT pContext
)
{    
    dbgTracePush ("nvCelsiusAACreate");
    if (pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_KELVIN) {   // Kelvin has it's own AA functions
        dbgTracePop();
        return FALSE;
    }

    if (pContext->aa.mAppCompat.bNoAA){
        dbgTracePop();
        return FALSE;
    }

    //
    // check if this is really a celsius machine
    //
    if (!(pDriverData->nvD3DPerfData.dwNVClasses & NVCLASS_FAMILY_CELSIUS))
    {
        // no, clear the reg bit and bye bye
        getDC()->nvD3DRegistryData.regD3DEnableBits1 &= ~D3D_REG_ANTIALIASENABLE_MASK;
        dbgTracePop();
        return FALSE;
    }

    //
    // check if we can AA this buffer
    //
    if (!(getDC()->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK) // aa enabled
     || !pContext->pRenderTarget                        // must exist
     || pContext->pRenderTarget->isSwizzled())          // cannot be swizzled
    {
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"nvCelsiusAACreate: AA failed because render target either does not exist or it is swizzled.");
        dbgTracePop();
        return FALSE;
    }

    // do not AA when rendering to texture
    if (pContext->pRenderTarget->getWrapper()->getTexture()) {
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"nvCelsiusAACreate: AA failed because render target is a texture.");
        dbgTracePop();
        return FALSE;
    }

    // extract current render buffer information
    //
    DWORD           dwBufferWidth  = pContext->pRenderTarget->getWidth();
    DWORD           dwBufferHeight = pContext->pRenderTarget->getHeight();
    CSimpleSurface *pRenderTarget  = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer    = pContext->pZetaBuffer;

    //objects created already?
    if (pContext->aa.isInit())
    {
        //check whether the target dimension changed
        //if not, save some work, keep the old AA buffer
        if ((dwBufferWidth        == pContext->aa.dwOriginalRenderTargetWidth)
         && (dwBufferHeight       == pContext->aa.dwOriginalRenderTargetHeight)
         && (pContext->dwZBHandle == pContext->aa.dwOriginalZBHandle))
        {
            dbgTracePop();
            return TRUE;
        }
        //if the dimension changed, destroy the old aa buffer and continue to build a new one
        else
            nvCelsiusAADestroy(pContext);
    }

    nvCelsiusAAInitCompatibilitySettings();
    nvCelsiusAAGetCompatibilitySettings(pContext);

    // This one is needed to catch the first pass through
    if (pContext->aa.mAppCompat.bNoAA) return FALSE;

    //initialize the original RenderTarget dimension
    pContext->aa.dwOriginalRenderTargetWidth  = dwBufferWidth;
    pContext->aa.dwOriginalRenderTargetHeight = dwBufferHeight;
    pContext->aa.dwOriginalZBHandle           = pContext->dwZBHandle;

    DWORD dwAAMethodMax;

    // attempt to find the highest quality super buffer
    if (pContext->pRenderTarget && (pContext->pRenderTarget->getMultiSampleBits() > 1)) {
        if (pContext->pRenderTarget->getMultiSampleBits() == 2) {
            dwAAMethodMax = 0;
        } else if (pContext->pRenderTarget->getMultiSampleBits() == 4) {
            dwAAMethodMax = 2;
        } else {
            DPF("Bad number of multisample bits: %d", pContext->pRenderTarget->getMultiSampleBits());
            dbgD3DError();
        }
    } else {
        dwAAMethodMax = getDC()->nvD3DRegistryData.regAntiAliasQuality - 1;
    }

    for (DWORD dwAAMethod = dwAAMethodMax; !(dwAAMethod & 0x80000000); dwAAMethod--)
    {
        //
        // set up data
        //

        //Smetimes we dont want to allow special setting
        if ((dwAAMethod  == AASTATE::METHOD_2x2spec) && !(pContext->aa.mAppCompat.bAllowSpecial))
            continue;

        // never allow us to drop down to 2x2 special.
        // Only allow it if it is explicitly requested.
        if ((dwAAMethod == AASTATE::METHOD_2x2spec) && (dwAAMethodMax > AASTATE::METHOD_2x2spec))
            continue;

        pContext->aa.fWidthAmplifier  = g_aAAMethodInfo[dwAAMethod].fXScale;
        pContext->aa.fHeightAmplifier = g_aAAMethodInfo[dwAAMethod].fYScale;
        pContext->aa.fLODBias         = float(g_aAAMethodInfo[dwAAMethod].dwLODBias) / 16.0f;
        pContext->aa.dwDepthAmplifier = 1;
        pContext->aa.dwLinePointSize  = g_aAAMethodInfo[dwAAMethod].dwLinePointSize;
        pContext->aa.modFlags (~AASTATE::MASK_METHOD,dwAAMethod);
        DPF_LEVEL (NVDBG_LEVEL_INFO,"Attempting %fx%f...",pContext->aa.fWidthAmplifier,pContext->aa.fHeightAmplifier);

        /*
        //
        // check again if we can AA this buffer
        //
        if (((dwBufferWidth  * pContext->aa.fWidthAmplifier)  > 2048.0f)
         || ((dwBufferHeight * pContext->aa.fHeightAmplifier) > 2048.0f))
        {
            // next
            DPF_LEVEL (NVDBG_LEVEL_INFO,"    ...not addressable.");
            continue;
            
        }
        */

        DWORD dwMem = (DWORD)(2*pContext->aa.fWidthAmplifier*pContext->aa.fHeightAmplifier*pRenderTarget->getBPP()*pRenderTarget->getWidth()*pRenderTarget->getHeight());
        if (dwMem > (DWORD)pDriverData->VideoHeapFree) {
            // next
            continue;
        }

        // create super frame buffer
        //
        pContext->aa.pSuperRenderTarget = new CSimpleSurface;
        if (!pContext->aa.pSuperRenderTarget)
        {
            // failed
            return FALSE;
        }

        // Ask to be created as Tiled memory in the Zbuffer area (Bank 1) -- this reduces memory bank collisions.
        DWORD dwPitch = DWORD(0.5f + pRenderTarget->getWidth() * pContext->aa.fWidthAmplifier * pRenderTarget->getBPP());
              dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;

        if (!pContext->aa.pSuperRenderTarget->create(NULL,
                                                     pRenderTarget->getFormat(),
                                                     DWORD(0.5f + pRenderTarget->getWidth()  * pContext->aa.fWidthAmplifier),
                                                     DWORD(0.5f + pRenderTarget->getHeight() * pContext->aa.fHeightAmplifier),
                                                     pRenderTarget->getDepth()               * pContext->aa.dwDepthAmplifier,
                                                     1,
                                                     pRenderTarget->getBPPRequested(),
                                                     pRenderTarget->getBPP(),
                                                     dwPitch,
                                                     pRenderTarget->getHeapLocation(),
                                                     pRenderTarget->getHeapLocation(),
                                                     (CSimpleSurface::ALLOCATE_TILED | CSimpleSurface::ALLOCATE_AS_ZBUFFER_UNC)
#ifdef CAPTURE
                                                    ,CAPTURE_SURFACE_KIND_TARGET
#endif
                                                     ))
        {
            // failed - clean up
            delete pContext->aa.pSuperRenderTarget;
            pContext->aa.pSuperRenderTarget = NULL;
            // next
            DPF_LEVEL (NVDBG_LEVEL_INFO,"    ...not enough frame buffer space.");
            continue;
        }

        //
        // create super z buffer
        //
        // Ask to be created as Tiled memory to force it to go on Bank 0 --- reduces memory collisions
        if (pZetaBuffer)
        {
            pContext->aa.pSuperZetaBuffer = new CSimpleSurface;
            if (!pContext->aa.pSuperZetaBuffer)
            {
                // failed
                pContext->aa.pSuperRenderTarget->destroy();
                delete pContext->aa.pSuperRenderTarget;
                pContext->aa.pSuperRenderTarget = NULL;
                return FALSE;
            }
            DWORD dwPitch = DWORD(0.5f + pZetaBuffer->getWidth() * pContext->aa.fWidthAmplifier * pZetaBuffer->getBPP());
                  dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
            if (!pContext->aa.pSuperZetaBuffer->create(NULL,
                                                         pZetaBuffer->getFormat(),
                                                         DWORD(0.5f + pZetaBuffer->getWidth()  * pContext->aa.fWidthAmplifier),
                                                         DWORD(0.5f + pZetaBuffer->getHeight() * pContext->aa.fHeightAmplifier),
                                                         pZetaBuffer->getDepth()               * pContext->aa.dwDepthAmplifier,
                                                         1,
                                                         pZetaBuffer->getBPPRequested(),
                                                         pZetaBuffer->getBPP(),
                                                         dwPitch,
                                                         pZetaBuffer->getHeapLocation(),
                                                         pZetaBuffer->getHeapLocation(),
                                                         CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                                                        ,CAPTURE_SURFACE_KIND_ZETA
#endif
                                                         ))

            {
                // failed - clean up
                delete pContext->aa.pSuperZetaBuffer;
                pContext->aa.pSuperZetaBuffer = NULL;
                pContext->aa.pSuperRenderTarget->destroy();
                delete pContext->aa.pSuperRenderTarget;
                pContext->aa.pSuperRenderTarget = NULL;
                // next
                DPF_LEVEL (NVDBG_LEVEL_INFO,"    ...not enough z buffer space.");
                continue;
            }
        }

#ifdef  STEREO_SUPPORT
        if (STEREO_ENABLED)
        {
            pContext->aa.pSuperRenderTarget->tagNotReal();
            pContext->aa.pSuperRenderTarget->createStereo();
            pContext->aa.pSuperZetaBuffer->tagNotReal();
            pContext->aa.pSuperZetaBuffer->createStereo();
        }
#endif  //STEREO_SUPPORT

        //
        // if necessary, create blit temporary space
        //
        if (dwAAMethod >= FIRST_TEMP_SPACE_METHOD) {
            pContext->aa.pBlitTempSpace = new CSimpleSurface;
            if (!pContext->aa.pBlitTempSpace)
            {
                // failed - clean up
                if (pContext->aa.pSuperZetaBuffer) {
                    pContext->aa.pSuperZetaBuffer->destroy();
                    delete pContext->aa.pSuperZetaBuffer;
                    pContext->aa.pSuperZetaBuffer = NULL;
                }
                pContext->aa.pSuperRenderTarget->destroy();
                delete pContext->aa.pSuperRenderTarget;
                pContext->aa.pSuperRenderTarget = NULL;
                return FALSE;
            }
            DWORD dwPitch = 2 * pRenderTarget->getWidth() * pRenderTarget->getBPP();
                  dwPitch = (dwPitch + pDriverData->dwSurfaceAlignPad) & ~pDriverData->dwSurfaceAlignPad;
            if (!pContext->aa.pBlitTempSpace->create(NULL,
                                                     pRenderTarget->getFormat(),
                                                     pRenderTarget->getWidth()  * 2,
                                                     pRenderTarget->getHeight() * 2,
                                                     pRenderTarget->getDepth()  * pContext->aa.dwDepthAmplifier,
                                                     1,
                                                     pRenderTarget->getBPPRequested(),
                                                     pRenderTarget->getBPP(),
                                                     dwPitch,
                                                     pRenderTarget->getHeapLocation(),
                                                     pRenderTarget->getHeapLocation(),
                                                     CSimpleSurface::ALLOCATE_TILED
#ifdef CAPTURE
                                                    ,CAPTURE_SURFACE_KIND_TARGET
#endif
                                                     ))
            {
                // failed - clean up
                delete pContext->aa.pBlitTempSpace;
                pContext->aa.pBlitTempSpace = NULL;
                if (pContext->aa.pSuperZetaBuffer) {
                    pContext->aa.pSuperZetaBuffer->destroy();
                    delete pContext->aa.pSuperZetaBuffer;
                    pContext->aa.pSuperZetaBuffer = NULL;
                }
                pContext->aa.pSuperRenderTarget->destroy();
                delete pContext->aa.pSuperRenderTarget;
                pContext->aa.pSuperRenderTarget = NULL;
                // next
                DPF_LEVEL (NVDBG_LEVEL_INFO,"    ...not enough blit temporary buffer space.");
                continue;
            }
        }

        // success
        break;
    }
    if (dwAAMethod & 0x80000000)
    {
        pContext->aa.fWidthAmplifier  = 1.0;
        pContext->aa.fHeightAmplifier = 1.0;
        pContext->aa.fLODBias         = 0.0;
        pContext->aa.dwLinePointSize  = 1;
        DPF_LEVEL (NVDBG_LEVEL_ERROR,"nvCelsiusAACreate: AA failed due to lack of memory or limited drawable area.");
        dbgTracePop();
        return FALSE;
    }

    //
    // update flags
    //
    pContext->aa.modFlags (~(AASTATE::FLAG_ENABLED),
                            (AASTATE::FLAG_INIT));
    pContext->aa.bsReset();
    getDC()->dwAAContextCount ++;

    //walk the pcontext list and update anyone else's pcontext->aa data
    //if they point to the same targets here
    PNVD3DCONTEXT pTempContext = (PNVD3DCONTEXT) getDC()->dwContextListHead;
    while (pTempContext) {
        if (pTempContext != pContext && pTempContext->pRenderTarget == pContext->pRenderTarget) {
            pTempContext->aa.pSuperRenderTarget = pContext->aa.pSuperRenderTarget;
            pTempContext->aa.pBlitTempSpace = pContext->aa.pBlitTempSpace;
        }
        if (pTempContext != pContext && pTempContext->pZetaBuffer == pContext->pZetaBuffer) {
            pTempContext->aa.pSuperZetaBuffer = pContext->aa.pSuperZetaBuffer;
        }
        pTempContext = pTempContext->pContextNext;
    }


    // Make wrapper objects
    CNvObject *pWrapper;

    if (pContext->aa.pSuperRenderTarget) {
        pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)pContext->aa.pSuperRenderTarget);
        pContext->aa.pSuperRenderTarget->setWrapper(pWrapper);
    }

    if (pContext->aa.pSuperZetaBuffer) {
        pWrapper = new CNvObject(0);
        pWrapper->setObject(CNvObject::NVOBJ_SIMPLESURFACE, (void *)pContext->aa.pSuperZetaBuffer);
        pContext->aa.pSuperZetaBuffer->setWrapper(pWrapper);
    }

    pContext->aa.modFlags(~AASTATE::FLAG_SRT_VALID & ~AASTATE::FLAG_SZB_VALID, AASTATE::FLAG_RT_VALID | AASTATE::FLAG_ZB_VALID);

    // Always select super buffers
    nvCelsiusAASelectSuperBuffers(pContext);

    //
    // done
    //
    dbgTracePop();
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAADestroy
//
BOOL nvCelsiusAADestroy
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAADestroy");

    //walk the pcontext list and update anyone else's pcontext->aa data
    //if they point to the same targets here

    CSimpleSurface *pRenderTarget = pContext->pRenderTarget;
    CSimpleSurface *pZetaBuffer = pContext->pZetaBuffer;

    PNVD3DCONTEXT pTempContext = pContext;
    pContext = (PNVD3DCONTEXT)getDC()->dwContextListHead;
    while (pContext) {

        //
        // do we have AA objects?
        //
        if (pContext->aa.isInit())
        {
            BOOL bDestroyed = FALSE;
            //
            // destroy objects
            //
            if (getDC()->nvPusher.getSize() > 0 &&
                getDC()->nvPusher.isValid()){
                // only do this if push buffer is valid.  This
                // additional check is due to the fact we can get
                // an nvCelsiusAADestroy calling into here AFTER
                // the pushbuffer has been destroyed on Win2K, in
                // this case you can't minify.
                nvCelsiusAASelectNormalBuffers (pContext,TRUE);
            }

            if (pContext == pTempContext) {
                CNvObject *pWrapper = pContext->aa.pSuperRenderTarget->getWrapper();
                if (pWrapper) {
                    pWrapper->release();
                } else {
                    // SRT has no wrapper object!
                    nvAssert(0);
                }
                if (pContext->aa.pSuperZetaBuffer) {
                    pWrapper = pContext->aa.pSuperZetaBuffer->getWrapper();
                    if (pWrapper) {
                        pWrapper->release();
                    } else {
                        // SZB has no wrapper object!
                        nvAssert(0);
                    }
                    bDestroyed = TRUE;
                }
                if (pContext->aa.pBlitTempSpace) {
                    pContext->aa.pBlitTempSpace->destroy();
                    delete pContext->aa.pBlitTempSpace;
                    bDestroyed = TRUE;
                }
            }

            if (pContext->pRenderTarget == pRenderTarget) {
                pContext->aa.pSuperRenderTarget = NULL;
                pContext->aa.pBlitTempSpace = NULL;
                bDestroyed = TRUE;
            }
            if (pContext->pZetaBuffer == pZetaBuffer) {
                pContext->aa.pSuperZetaBuffer = NULL;
                bDestroyed = TRUE;
            }
            if (bDestroyed) {
                //
                // update flags
                //
                pContext->aa.modFlags (~(AASTATE::FLAG_INIT | AASTATE::FLAG_ENABLED),0);
                if(getDC()->dwAAContextCount > 0)
                    getDC()->dwAAContextCount --;
            }
        }
        pContext = pContext->pContextNext;
    }

    dbgTracePop();
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAASelectSuperBuffers
//
void nvCelsiusAASelectSuperBuffers
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAASelectSuperBuffers");
/*
    if (!pContext->aa.isSuperCurrent())
    {
        //
        // update state
        //
        pContext->aa.setFlags (AASTATE::FLAG_SUPERCURRENT);
    }
*/
    //
    // done
    //
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAASelectNormalBuffers
//
void nvCelsiusAASelectNormalBuffers
(
    PNVD3DCONTEXT pContext,
    BOOL          bPreserveBufferContents
)
{
    dbgTracePush ("nvCelsiusAASelectNormalBuffers");
/*
    if (pContext->aa.isSuperCurrent())
    {
        //
        // minify buffer if it has valuable information
        //
        if (bPreserveBufferContents)
        {

            nvCelsiusAAMinify (pContext);
        }

        //
        // update state
        //
        pContext->aa.modFlags (~AASTATE::FLAG_SUPERCURRENT,0);
    }
*/
    //
    // done
    //
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAScaledBltHW
//
inline void nvCelsiusAAScaledBltHW
(
    PNVD3DCONTEXT pContext,

    DWORD         dwSrcOffset,
    DWORD         dwSrcPitch,
    DWORD         dwSrcPoint,       // 12.4:12.4
    DWORD         dwSrcSize,        // 16:16                2 <= x <= 2046

    DWORD         dwDstOffset,
    DWORD         dwDstPitch,
    DWORD         dwDstPoint,       // 16:16
    DWORD         dwDstSize,        // 16:16

    DWORD         dwDsDx,           // 12.20
    DWORD         dwDtDy,           // 12.20

    DWORD         dwFormat,
    BOOL          bFOH,
    BOOL          bCenter,
    BOOL          bDither
)
{
    dbgTracePush ("nvCelsiusAAScaledBltHW");

    assert (~nv062SurfaceFormat[dwFormat]);
    assert (~nv089SurfaceFormat[dwFormat]);

    dwSrcSize += 0x00010001;
    dwSrcSize &= 0xfffefffe;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_ROP) | SET_ROP_OFFSET | 0x40000);
    nvPushData(1, (SRCCOPY >> 16));
    nvPusherAdjust(2);
    pDriverData->bltData.dwLastRop = (SRCCOPY >> 16);

    /*
    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_SURFACES) | NV062_SET_CONTEXT_DMA_IMAGE_SOURCE | 0x080000);
    nvPushData ( 1, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDMAImageSource
    nvPushData ( 2, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDMAImageDestin
    nvPusherAdjust (3);
    */


    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_SURFACES) | SURFACES_2D_SET_COLOR_FORMAT_OFFSET | 0x100000);
    nvPushData ( 1, nv062SurfaceFormat[dwFormat]);    // SetColorFormat
    nvPushData ( 2, (dwDstPitch << 16) | dwSrcPitch); // SetPitch
    nvPushData ( 3, dwSrcOffset);                     // SetOffset
    nvPushData ( 4, dwDstOffset);                     // SetOffset
    nvPusherAdjust (5);
    pDriverData->bltData.dwLastColourFormat = nv062SurfaceFormat[dwFormat];
    pDriverData->bltData.dwLastCombinedPitch = (dwDstPitch << 16) | dwSrcPitch;
    pDriverData->bltData.dwLastSrcOffset = dwSrcOffset;
    pDriverData->bltData.dwLastDstOffset = dwDstOffset;

    nvPushData(0, dDrawSubchannelOffset(NV_DD_SPARE) | 0x40000);
    nvPushData(1, NV_DD_CONTEXT_COLOR_KEY);
    nvPushData(2, dDrawSubchannelOffset(NV_DD_SPARE) | SET_TRANSCOLOR_OFFSET | 0x40000);
    nvPushData(3, 0);
    nvPusherAdjust(4);
    pDriverData->bltData.dwLastColourKey = 0xFFFFFFFF;
    pDriverData->dDrawSpareSubchannelObject = NV_DD_CONTEXT_COLOR_KEY;


    nvPushData ( 0, dDrawSubchannelOffset(NV_DD_STRETCH) | 0x40000);
    nvPushData ( 1, NV_DD_SCALED_IMAGE_IID);
    nvPushData ( 2, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CONTEXT_DMA_IMAGE_OFFSET | 0x40000);
    nvPushData ( 3, NV_DD_DMA_CONTEXT_DMA_IN_VIDEO_MEMORY); // SetContextDmaImage
    nvPushData ( 4, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_SET_COLOR_FORMAT | 0x40000);
    nvPushData ( 5, nv089SurfaceFormat[dwFormat]); // SetColorFormat
    nvPushData ( 6, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_CLIPPOINT_OFFSET | 0x180000);
    nvPushData ( 7, dwDstPoint);             // ClipPoint
    nvPushData ( 8, dwDstSize);              // ClipSize
    nvPushData ( 9, dwDstPoint);             // ImageOutPoint
    nvPushData (10, dwDstSize);              // ImageOutSize
    nvPushData (11, dwDsDx);                 // DsDx
    nvPushData (12, dwDtDy);                 // DtDy
    nvPushData (13, dDrawSubchannelOffset(NV_DD_STRETCH) | SCALED_IMAGE_IMAGE_IN_SIZE_OFFSET | 0x100000);
    nvPushData (14, dwSrcSize);              // ImageInSize
    nvPushData (15, (bFOH ? (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_FOH << 24)
                          : (NV077_IMAGE_IN_FORMAT_INTERPOLATOR_ZOH << 24)) |     // ImageInFormat
                    (bCenter ? (NV077_IMAGE_IN_FORMAT_ORIGIN_CENTER << 16)
                             : (NV077_IMAGE_IN_FORMAT_ORIGIN_CORNER << 16)) |
                    dwSrcPitch);
    nvPushData (16, dwSrcOffset);            // ImageInOffset
    nvPushData (17, dwSrcPoint);             // ImageInPoint

    if (bDither) {
        nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
        nvPushData (19, NV089_SET_COLOR_CONVERSION_DITHER); // SetColorFormat
        nvPusherAdjust (20);
    } else {
        nvPushData (18, dDrawSubchannelOffset(NV_DD_STRETCH) | NV089_SET_COLOR_CONVERSION | 0x40000);
        nvPushData (19, NV089_SET_COLOR_CONVERSION_TRUNCATE); // SetColorFormat
        nvPusherAdjust (20);
//        nvPusherAdjust (18);
    }

    nvPusherStart (TRUE);

    pDriverData->TwoDRenderingOccurred   = TRUE;
    pDriverData->ThreeDRenderingOccurred = 0;

    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAScaledBlt
//
void nvCelsiusAAScaledBlt
(
    PNVD3DCONTEXT pContext,

    DWORD         dwSrcOffset,
    DWORD         dwSrcPitch,
    DWORD         dwSrcX,           // 12.4
    DWORD         dwSrcY,           // 16
    DWORD         dwSrcWidth,
    DWORD         dwSrcHeight,

    DWORD         dwDstOffset,
    DWORD         dwDstPitch,
    DWORD         dwDstX,           // 16
    DWORD         dwDstY,           // 16
    DWORD         dwDstWidth,
    DWORD         dwDstHeight,

    DWORD         dwDsDx,           // 12.20     assume integer scaling
    DWORD         dwDtDy,           // 12.20

    DWORD         dwFormat,
    BOOL          bFOH,
    BOOL          bCenter,
    BOOL          bDither
)
{
    dbgTracePush ("nvCelsiusAAScaledBlt");

    // limit width
    if (dwSrcWidth > 2046)
    {
        DWORD dwDstSplit = 1024 / (dwDsDx >> 20);
        DWORD dwSrcSplit = dwDstSplit * (dwDsDx >> 20);

        nvCelsiusAAScaledBlt (pContext,
                              dwSrcOffset,dwSrcPitch,dwSrcX,dwSrcY,dwSrcSplit,dwSrcHeight,
                              dwDstOffset,dwDstPitch,dwDstX,dwDstY,dwDstSplit,dwDstHeight,
                              dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

        nvCelsiusAAScaledBlt (pContext,
                              dwSrcOffset,dwSrcPitch,dwSrcX + (dwSrcSplit << 4),dwSrcY,dwSrcWidth - dwSrcSplit,dwSrcHeight,
                              dwDstOffset,dwDstPitch,dwDstX + dwDstSplit,dwDstY,dwDstWidth - dwDstSplit,dwDstHeight,
                              dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

        return;
    }

    // limit height
    if (dwSrcHeight > 2047)
    {
        DWORD dwDstSplit = 1024 / (dwDtDy >> 20);
        DWORD dwSrcSplit = dwDstSplit * (dwDtDy >> 20);

        nvCelsiusAAScaledBlt (pContext,
                              dwSrcOffset,dwSrcPitch,dwSrcX,dwSrcY,dwSrcWidth,dwSrcSplit,
                              dwDstOffset,dwDstPitch,dwDstX,dwDstY,dwDstWidth,dwDstSplit,
                              dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

        nvCelsiusAAScaledBlt (pContext,
                              dwSrcOffset,dwSrcPitch,dwSrcX,dwSrcY + (dwSrcSplit << 4),dwSrcWidth,dwSrcHeight - dwSrcSplit,
                              dwDstOffset,dwDstPitch,dwDstX,dwDstY + dwDstSplit,dwDstWidth,dwDstHeight - dwDstSplit,
                              dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

        return;
    }

    // Lie about format for Z buffers
    switch (dwFormat) {
    case NV_SURFACE_FORMAT_Z16:
        dwFormat = NV_SURFACE_FORMAT_R5G6B5;
        break;
    case NV_SURFACE_FORMAT_Z24S8:
    case NV_SURFACE_FORMAT_Z24X8:
        dwFormat = NV_SURFACE_FORMAT_A8R8G8B8;
        break;
    }

    // attempt to minimize the subrect offset (nvCelsius is not too kosher with large subrects)
    DWORD dwBPP = nvSurfaceFormatToBPP[dwFormat];

    dwSrcOffset += dwBPP * (dwSrcX >> 4) + dwSrcPitch * (dwSrcY >> 4);
    dwSrcX      &= 0xf;
    dwSrcY      &= 0xf;
    if (dwSrcOffset & NV_BYTE_ALIGNMENT_PAD)
    {
        dwSrcX      += ((dwSrcOffset & NV_BYTE_ALIGNMENT_PAD) / dwBPP) << 4;
        dwSrcOffset &= ~NV_BYTE_ALIGNMENT_PAD;
    }

    dwDstOffset += dwBPP * dwDstX + dwDstPitch * dwDstY;;
    dwDstX       = 0;
    dwDstY       = 0;
    if (dwDstOffset & NV_BYTE_ALIGNMENT_PAD)
    {
        dwDstX      += (dwDstOffset & NV_BYTE_ALIGNMENT_PAD) / dwBPP;
        dwDstOffset &= ~NV_BYTE_ALIGNMENT_PAD;
    }

    // send to hardware
    nvCelsiusAAScaledBltHW (pContext,
                            dwSrcOffset,dwSrcPitch,(dwSrcY << 16) | dwSrcX,(dwSrcHeight << 16) | dwSrcWidth,
                            dwDstOffset,dwDstPitch,(dwDstY << 16) | dwDstX,(dwDstHeight << 16) | dwDstWidth,
                            dwDsDx,dwDtDy,dwFormat,bFOH,bCenter,bDither);

    dbgTracePop();
}


//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMagnify
//
static void nvCelsiusAAMagnifyInternal
(
    PNVD3DCONTEXT pContext,
    CSimpleSurface *pSrc,
    CSimpleSurface *pDst
)
{
    dbgTracePush ("nvCelsiusAAMagnifyInternal");

    switch (pContext->aa.getMethod())
    {
        case AASTATE::METHOD_1x2:
        {
            nvCelsiusAAScaledBlt (pContext,

                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  8,
                                  4,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00100000,
                                  0x00080000,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }
        case AASTATE::METHOD_2x2lod:
        case AASTATE::METHOD_2x2:
        {
            nvCelsiusAAScaledBlt (pContext,

                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  4,
                                  4,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00080000,
                                  0x00080000,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }
        
        case AASTATE::METHOD_2x2spec:
        {
           //change 2x2 special into 2x2
           pContext->aa.modFlags(~1,0); 
           
           nvCelsiusAAScaledBlt  (pContext,
                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  4,
                                  4,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00080000,
                                  0x00080000,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }

        case AASTATE::METHOD_3x3lod:
        case AASTATE::METHOD_3x3:
        {
            nvCelsiusAAScaledBlt (pContext,

                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  3,
                                  3,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00055555,
                                  0x00055555,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }
        case AASTATE::METHOD_4x4lod:
        case AASTATE::METHOD_4x4:
        {
            nvCelsiusAAScaledBlt (pContext,

                                  pSrc->getOffset(),
                                  pSrc->getPitch(),
                                  2,
                                  2,
                                  pSrc->getWidth(),
                                  pSrc->getHeight(),

                                  pDst->getOffset(),
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00040000,
                                  0x00040000,

                                  pSrc->getFormat(),
                                  FALSE,
                                  FALSE,
                                  FALSE);
            break;
        }
    }
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMinifyInternal
//
static void nvCelsiusAAMinifyInternal
(
    PNVD3DCONTEXT pContext,
    BOOL bFOH,
    CSimpleSurface *pSrc,
    CSimpleSurface *pDst
)
{
    dbgTracePush ("nvCelsiusAAMinifyInternal");

    // Note: some of the source width/height parameters have 2
    // subtracted from them.  Some apps that were not designed for AA
    // have artifacts on the edge if we do not clamp the bottom and right
    // edges.

    switch (pContext->aa.getMethod())
    {
        case AASTATE::METHOD_1x2:
        {
            nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                  pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                  pSrc->getPitch(),
                                  0,
                                  bFOH ? 8 : 0,
                                  pSrc->getWidth(),
                                  pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                  pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00100000,
                                  0x00200000,

                                  pDst->getFormat(),
                                  bFOH,
                                  TRUE,
                                  pContext->aa.mAppCompat.bDither);
            break;
        }
        case AASTATE::METHOD_2x2lod:
        case AASTATE::METHOD_2x2:
        {
            nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                  pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                  pSrc->getPitch(),
                                  bFOH ? 8 : 0,
                                  bFOH ? 8 : 0,
                                  pSrc->getWidth()-2,
                                  pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                  GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                  pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                  pDst->getPitch(),
                                  0,
                                  0,
                                  pDst->getWidth(),
                                  pDst->getHeight(),

                                  0x00200000,
                                  0x00200000,

                                  pDst->getFormat(),
                                  bFOH,
                                  TRUE,
                                  pContext->aa.mAppCompat.bDither);
            break;
        }
        case AASTATE::METHOD_2x2spec:
        {
            if (bFOH) {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      8,
                                      8,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth(),
                                      pSrc->getHeight(),

                                      0x00100000,
                                      0x00100000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);

                nvCelsiusAAScaledBlt (pContext,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      8,
                                      8,
                                      pSrc->getWidth(),
                                      pSrc->getHeight(),

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);
            }
            else {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);
            }
            break;
        }
        case AASTATE::METHOD_3x3lod:
        case AASTATE::METHOD_3x3:
        {
            if (bFOH) {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      4,
                                      4,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      0,
                                      0,
                                      (pSrc->getWidth() * 2) / 3,
                                      (pSrc->getHeight() * 2) / 3,

                                      0x00180000,
                                      0x00180000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);

                nvCelsiusAAScaledBlt (pContext,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      8,
                                      8,
                                      (pSrc->getWidth() * 2) / 3,
                                      (pSrc->getHeight() * 2) / 3,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);
            }
            else {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00300000,
                                      0x00300000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      FALSE);
            }
            break;
        }
        case AASTATE::METHOD_4x4lod:
        case AASTATE::METHOD_4x4:
        {
            if (bFOH) {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      8,
                                      8,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth() / 2,
                                      pSrc->getHeight() / 2,

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      pContext->aa.mAppCompat.bDither);

                nvCelsiusAAScaledBlt (pContext,

                                      pContext->aa.pBlitTempSpace->getOffset(),
                                      pContext->aa.pBlitTempSpace->getPitch(),
                                      8,
                                      8,
                                      pSrc->getWidth() / 2,
                                      pSrc->getHeight() / 2,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00200000,
                                      0x00200000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      pContext->aa.mAppCompat.bDither);
            }
            else {
                nvCelsiusAAScaledBlt (pContext,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pSrc),
#else   //STEREO_SUPPORT==0
                                      pSrc->getOffset(),
#endif  //STEREO_SUPPORT
                                      pSrc->getPitch(),
                                      0,
                                      0,
                                      pSrc->getWidth()-2,
                                      pSrc->getHeight()-2,

#ifdef  STEREO_SUPPORT
                                      GetStereoOffset(pDst),
#else   //STEREO_SUPPORT==0
                                      pDst->getOffset(),
#endif  //STEREO_SUPPORT
                                      pDst->getPitch(),
                                      0,
                                      0,
                                      pDst->getWidth(),
                                      pDst->getHeight(),

                                      0x00400000,
                                      0x00400000,

                                      pDst->getFormat(),
                                      bFOH,
                                      TRUE,
                                      pContext->aa.mAppCompat.bDither);
            }
            break;
        }
        default:
        {
            DPF ("INVALID AA METHOD - impossible condition");
            dbgD3DError();
            break;
        }
    }

    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMagnify
//
void nvCelsiusAAMagnify
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAAMagnify");
    nvCelsiusAAMagnifyInternal(pContext,
                               pContext->pRenderTarget,
                               pContext->aa.pSuperRenderTarget);
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMinify
//
void nvCelsiusAAMinify
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAAMinify");

#ifdef  STEREO_SUPPORT
    if (STEREO_ACTIVATED)
    {
		//We can't mess up the pStereoData->dwLastEye or use SetupStereoContext
		//for that matter. Those are higher level primitives.
		DWORD dwLastEye = pStereoData->dwLastEye;
		pStereoData->dwLastEye = EYE_LEFT;
        nvCelsiusAAMinifyInternal(pContext,
                                  TRUE, // filter colors
                                  pContext->aa.pSuperRenderTarget,
                                  pContext->pRenderTarget);
        pStereoData->dwLastEye = EYE_RIGHT;
        nvCelsiusAAMinifyInternal(pContext,
                                  TRUE, // filter colors
                                  pContext->aa.pSuperRenderTarget,
                                  pContext->pRenderTarget);
		pStereoData->dwLastEye = dwLastEye;
		pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SURFACE;
    } else
#endif  //STEREO_SUPPORT
        nvCelsiusAAMinifyInternal(pContext,
                                  TRUE, // filter colors
                                  pContext->aa.pSuperRenderTarget,
                                  pContext->pRenderTarget);

    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMagnifyZ
//
void nvCelsiusAAMagnifyZ
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAAMagnifyZ");
    if (pContext->pZetaBuffer && pContext->aa.pSuperZetaBuffer) {
        nvCelsiusAAMagnifyInternal(pContext,
                                 pContext->pZetaBuffer,
                                 pContext->aa.pSuperZetaBuffer);
    }
    dbgTracePop();
}

//////////////////////////////////////////////////////////////////////////////
// nvCelsiusAAMinifyZ
//
void nvCelsiusAAMinifyZ
(
    PNVD3DCONTEXT pContext
)
{
    dbgTracePush ("nvCelsiusAAMinifyZ");

    if (pContext->pZetaBuffer && pContext->aa.pSuperZetaBuffer) {
        nvCelsiusAAMinifyInternal(pContext,
                                  FALSE, // never filter Z's
                                  pContext->aa.pSuperZetaBuffer,
                                  pContext->pZetaBuffer);
    }

    dbgTracePop();
}



#ifdef WINNT
    // No way on God's green earth we should need more than 32k.
    #define MAX_AAFILE_SIZE 32768
#endif
#ifndef WINNT
    #define DYNAMIC_AA_COMPAT_SETTINGS
#endif



// Dynamically loaded settings

AAAppCompatState *AAAppSettings = 0;

struct AANameValue {
    char *lpName;
    BOOL bValue;
};

AANameValue AANamesToValues[] = {
    {"DISCARD_FB",               TRUE},
    {"DONT_DISCARD_FB",          FALSE},
    {"MAGNIFY_ON_UNLOCK",        TRUE},
    {"DONT_MAGNIFY_ON_UNLOCK",   FALSE},
    {"MINIFY_ON_ENDSCENE",       TRUE},
    {"DONT_MINIFY_ON_ENDSCENE",  FALSE},
    {"DITHER",                   TRUE},
    {"DONT_DITHER",              FALSE},
    {"NO_AA_ON",                 TRUE},
    {"AA_ON",                    FALSE},
    {"BLIT_SYNC",                TRUE},
    {"NO_BLIT_SYNC",             FALSE},
    {"DISCARD_SRT",              TRUE},
    {"DONT_DISCARD_SRT",         FALSE},
    {"ALLOW_SPECIAL",            TRUE},
    {"DONT_ALLOW_SPECIAL",       FALSE},
    {"FULL_PATH",                TRUE},
    {"NO_PATH",                  FALSE},
    {0,                          FALSE}
};


// Compiled-in settings

#define DISCARD_FB               TRUE
#define DONT_DISCARD_FB          FALSE
#define MAGNIFY_ON_UNLOCK        TRUE
#define DONT_MAGNIFY_ON_UNLOCK   FALSE
#define MINIFY_ON_ENDSCENE       TRUE
#define DONT_MINIFY_ON_ENDSCENE  FALSE
#define DITHER                   TRUE
#define DONT_DITHER              FALSE
#define NO_AA_ON                 TRUE
#define AA_ON                    FALSE
#define BLIT_SYNC                TRUE
#define NO_BLIT_SYNC             FALSE
#define DISCARD_SRT              TRUE
#define DONT_DISCARD_SRT         FALSE
#define ALLOW_SPECIAL            TRUE
#define DONT_ALLOW_SPECIAL       FALSE
#define FULL_PATH                TRUE
#define NO_PATH                  FALSE

// The macros in nvCelsiusAACompatibility.h get expanded out to array entries
#define appcompat(app, path, no_aa, discard_fb, magnify_on_unlock, minify_on_endscene, dither, blitsync, discard_srt, special) \
    {app, path, no_aa, discard_fb, magnify_on_unlock, minify_on_endscene, dither, blitsync, discard_srt, special},


AAAppCompatState AAAppSettingsCompiled[] = {
#include "nvCelsiusAACompatibility.h"
    {0, FALSE, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, TRUE}
};


////////////////////////////////////
// Gets the unadorned (no path, no params) name 
// of the calling exe file.  Won't work in 
// Win2k until we figure out a better way than
// accessing the offset directly.

void GetExecutableName(LPTSTR pOut, DWORD dwSize, PNVD3DCONTEXT pContext) {

#ifndef WINNT
    LPTSTR pCmdLine = GetCommandLine();
#else
    LPTSTR pCmdLine = nvGetCommandLine(); 
#endif

    LPTSTR pStr, pExe;
    BOOL bInQuotes = 0;

    // quick check
    if (*pCmdLine == '\"') {
        pCmdLine++;
        bInQuotes = TRUE;
    }

    // strip path and leave the raw executable name
    for (pExe = pCmdLine; *pCmdLine != '\0'; pCmdLine++) {
        if (*pCmdLine == '"') bInQuotes = !bInQuotes;

        if (!bInQuotes && *pCmdLine <= ' ') {
            break;
        }
        if (*pCmdLine == '\\' || *pCmdLine == ':') {
            pExe = pCmdLine + 1;
        }
    }

    for (int i=0; pExe[i] != '\0'; i++) {
        if (pExe[i] >= 'A' && pExe[i] <= 'Z') pExe[i] += 'a' - 'A';
    }

    strncpy(pOut, pExe, dwSize);

    // early string termination if quote, space, or control character is detected
    for (pStr = pOut; *pStr != '\0'; pStr++) {
        if (*pStr == '\"' || *pStr <= ' ') {
            *pStr = '\0';
        }
    }

    pOut[dwSize-1] = '\0';       // Just to be safe
}


// Get Full name, including path
void GetFullExecutableName(LPTSTR pOut, DWORD dwSize, PNVD3DCONTEXT pContext) {

#ifndef WINNT
    LPTSTR pCmdLine = GetCommandLine();
#else
    LPTSTR pCmdLine = nvGetCommandLine(); 
#endif

    LPTSTR pExe;
    BOOL bInQuotes = 0;

    if(pCmdLine[0] != '\0'){
        pExe = pCmdLine+1;
        pExe[strlen(pExe)] = '\0';
    }
    else{
        pExe = pCmdLine;
    }   

    for (int i=0; pExe[i] != '\0'; i++) {
        if (pExe[i] >= 'A' && pExe[i] <= 'Z') pExe[i] += 'a' - 'A';
    }

    strncpy(pOut, pExe, dwSize);
    pOut[dwSize-1] = '\0';       // Just to be safe
}


#define WORD_CHAR(x) ((((x) >= 'a') && ((x) <= 'z')) || (((x) >= 'A') && ((x) <= 'Z')) || ((x) == '_'))

__declspec(dllexport) void nvCelsiusAAInitCompatibilitySettings()
{

#ifdef DYNAMIC_AA_COMPAT_SETTINGS
    DWORD i;
    DWORD dwCurSetting = 0;

    if (pDriverData->nvD3DRegistryData.regAAReadCompatibilityFile != 0xd3dbeef) {
        AAAppSettings = AAAppSettingsCompiled;
    }

    if (AAAppSettings) return;

    // Hard-coded filename.  If it's not found, use the
    HANDLE hFile = NvCreateFile("\\NvCelsiusAACompatibility.h",
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);


    // Note: this parsing is "quick-and dirty."  Fortunately, no one
    // outside of NVIDIA should care.
    if ((hFile != INVALID_HANDLE_VALUE) && (hFile != NULL)) {
        DWORD dwNumBytes, dwSize;
        LPTSTR lpStr;

#ifndef WINNT
        dwSize = GetFileSize(hFile, NULL);
        lpStr = new char[dwSize];
        NvReadFile(hFile, lpStr, dwSize, &dwNumBytes, NULL);
#else
        lpStr = new char[MAX_AAFILE_SIZE];
        for (i =0; i< MAX_AAFILE_SIZE; i++) {
            NvReadFile(hFile, lpStr+i,1,&dwNumBytes, NULL);
            if (dwNumBytes == 0) {
                lpStr[i] = '\0';
                break;
            }
        }
        dwSize = i;
#endif

        DWORD dwNumSettings = 1; // Start with 1 to make room for the default
        for (i=0; i<dwSize; i++) {
            // Skip comment lines
            if (lpStr[i] == '/') {
                while (lpStr[i] != '\n') i++;
            }

            // The number of () pairs should be equal to the number of
            // settings there are in the file
            if (lpStr[i] == '(') {
                dwNumSettings++;
            }
        }

        AAAppSettings = new AAAppCompatState[dwNumSettings];

        // Iterate over all characters in the file
        for (i=0; i<dwSize; i++) {
            // Skip comment lines
            if (lpStr[i] == '/') {
                while (lpStr[i] != '\n') i++;
            }

            if (lpStr[i] == '(') {
                char lpIdent[256];
                DWORD j;

                while (lpStr[i-1] != '"') i++;
                j = 0;
                while (lpStr[i] != '"') lpIdent[j++] = lpStr[i++];
                lpIdent[j] = '\0';


                AAAppSettings[dwCurSetting].lpApp = new char[strlen(lpIdent) +1];
                strcpy(AAAppSettings[dwCurSetting].lpApp, lpIdent);

                DWORD dwParam = 0;
                while (1) {
                    while (!WORD_CHAR(lpStr[i]) && lpStr[i] != ')') i++;
                    if (lpStr[i] == ')') break;

                    j = 0;
                    while (WORD_CHAR(lpStr[i])) lpIdent[j++] = lpStr[i++];
                    lpIdent[j] = '\0';

                    // Find the name to value matching of the identifier
                    for (DWORD k=0; AANamesToValues[k].lpName != 0; k++) {
                        if (strcmp(AANamesToValues[k].lpName, lpIdent) == 0) break;
                    }

                    *(&(AAAppSettings[dwCurSetting].bPath) + dwParam) = AANamesToValues[k].bValue;
                    dwParam++;
                }
                dwCurSetting++;
            }

        }

        delete [] lpStr;

        // Make default setting
        AAAppSettings[dwCurSetting].lpApp = 0;
        AAAppSettings[dwCurSetting].bNoAA = FALSE;
        AAAppSettings[dwCurSetting].bPath = FALSE;
        AAAppSettings[dwCurSetting].bDiscardFBContents = TRUE;
        AAAppSettings[dwCurSetting].bAlwaysMagnifyUponUnlock = FALSE;
        AAAppSettings[dwCurSetting].bMinifyUponEndScene = FALSE;
        AAAppSettings[dwCurSetting].bDither = FALSE;
        AAAppSettings[dwCurSetting].bBlitSync = FALSE;
        AAAppSettings[dwCurSetting].bDiscardSRT = TRUE;
        AAAppSettings[dwCurSetting].bAllowSpecial = TRUE;
    } else {
        AAAppSettings = AAAppSettingsCompiled;
    }
#else
    AAAppSettings = AAAppSettingsCompiled;
#endif
}



__declspec(dllexport) void nvCelsiusAAGetCompatibilitySettings
(
    PNVD3DCONTEXT pContext
)
{
    DWORD i;
    char pExe[256];

    // Should never happen, I think...
    nvAssert(pContext);
    nvAssert(AAAppSettings);

    // Get name of exe (sans path) and convert to lowercase
    //GetExecutableName(pExe, 256);
    //for (i=0; pExe[i] != '\0'; i++) {
    //   if (pExe[i] >= 'A' && pExe[i] <= 'Z') pExe[i] += 'a' - 'A';
    //}

    // Iterate through list, stopping on the last one (has null for the filename),
    // or on the one that matches.
    for (i=0; AAAppSettings[i].lpApp != 0; i++)
    {
        if (AAAppSettings[i].bPath) {
            GetFullExecutableName(pExe, 256, pContext);
        } else {
            GetExecutableName(pExe, 256, pContext);
        }

        if (strcmp(pExe, AAAppSettings[i].lpApp) == 0)
        {
            pContext->aa.mAppCompat = AAAppSettings[i];
            return;
        }
    }

    // App not found, use default...
    pContext->aa.mAppCompat = AAAppSettings[i];
}

// AASTATE functionality ----------------------------------------------------

inline void AASTATE::makeRenderBuffersMatch (PNVD3DCONTEXT pContext)
{
    if ((dwFlags & FLAG_RT_VALID) && (dwFlags & FLAG_SRT_VALID)) return;
    if (dwFlags & FLAG_RT_VALID) {
        nvCelsiusAAMagnify(pContext);
        dwFlags |= FLAG_SRT_VALID;
        return;
    }
    if (dwFlags & FLAG_SRT_VALID) {
        nvCelsiusAAMinify(pContext);
        dwFlags |= FLAG_RT_VALID;
        return;
    }
}

inline void AASTATE::makeZBuffersMatch (PNVD3DCONTEXT pContext)
{
    if ((dwFlags & FLAG_ZB_VALID) && (dwFlags & FLAG_SZB_VALID)) return;
    if (dwFlags & FLAG_ZB_VALID) {
        nvCelsiusAAMagnifyZ(pContext);
        dwFlags |= FLAG_SZB_VALID;
        return;
    }
    if (dwFlags & FLAG_SZB_VALID) {
        nvCelsiusAAMinifyZ(pContext);
        dwFlags |= FLAG_ZB_VALID;
        return;
    }
}

inline BOOL AASTATE::WantEnabled (PNVD3DCONTEXT pContext)
{
    return ((pDriverData->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASENABLE_MASK)
        && (pContext->dwRenderState[D3DRENDERSTATE_ANTIALIAS] != D3DANTIALIAS_NONE)
        || (pDriverData->nvD3DRegistryData.regD3DEnableBits1 & D3D_REG_ANTIALIASFORCEENABLE_MASK)
        || (pContext->pRenderTarget && (pContext->pRenderTarget->getMultiSampleBits() > 1)));
}

void AASTATE::makeRenderTargetValid (PNVD3DCONTEXT pContext)
{
    if (!(dwFlags & FLAG_RT_VALID))
    {
        nvCelsiusAAMinify(pContext);
        dwFlags |= FLAG_RT_VALID;
    }
    dwFlags &= ~FLAG_SRT_VALID;
}

void AASTATE::makeZetaBufferValid (PNVD3DCONTEXT pContext)
{
    if (!pContext->aa.pSuperZetaBuffer)
        return;

    if (!(dwFlags & FLAG_ZB_VALID))
    {
        nvCelsiusAAMinifyZ(pContext);
        dwFlags |= FLAG_ZB_VALID;
    }
    dwFlags &= ~FLAG_SZB_VALID;
}

void AASTATE::makeSuperBufferValid (PNVD3DCONTEXT pContext)
{
    if (!(dwFlags & FLAG_SRT_VALID))
    {
        nvCelsiusAAMagnify(pContext);
        //flags can get modified in the function above, the optimizer uses the cached, unmodified value.
        //force loading through the pointer to work around it.
        pContext->aa.dwFlags |= FLAG_SRT_VALID;
    }
    pContext->aa.dwFlags &= ~FLAG_RT_VALID;
}

void AASTATE::makeSuperZBValid (PNVD3DCONTEXT pContext) {

    if (!pContext->aa.pSuperZetaBuffer)
        return;

    if (!(dwFlags & FLAG_SZB_VALID))
    {
        nvCelsiusAAMagnifyZ(pContext);
        pContext->aa.dwFlags |= FLAG_SZB_VALID;
    }
    pContext->aa.dwFlags &= ~FLAG_ZB_VALID;
}

void AASTATE::Create (PNVD3DCONTEXT pContext)
{
    if (WantEnabled(pContext))
    {
        if (nvCelsiusAACreate(pContext))
        {
            // enable AA
            setFlags (AASTATE::FLAG_ENABLED);
        }
    }
}

void AASTATE::invalidateState (void)
{
    PNVD3DCONTEXT pContext = (PNVD3DCONTEXT)(DWORD(this) - OFFSETOF(NVD3DCONTEXT,aa)); // we know aa lives in context (not good practice)
    pContext->hwState.dwDirtyFlags |= CELSIUS_DIRTY_SURFACE
                                   |  CELSIUS_DIRTY_TRANSFORM
                                   |  CELSIUS_DIRTY_TEXTURE_STATE
                                   |  CELSIUS_DIRTY_SPECFOG_COMBINER
                                   |  CELSIUS_DIRTY_MISC_STATE;
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusColorCombiner.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusColorCombiner.cpp                                        *
*       Routines for programming the celsius color combiner                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        02Mar99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

//---------------------------------------------------------------------------

// Set a color input to to 1 or -1

void SetColorInputOne (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                       DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_0);

    pContext->hwState.dwColorICW[dwCombinerStage] &= ~(DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_MAP, ~0) << celsiusCombinerInputShift[eInput]);
    pContext->hwState.dwColorICW[dwCombinerStage] &= ~(DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_ALPHA, ~0) << celsiusCombinerInputShift[eInput]);
    pContext->hwState.dwColorICW[dwCombinerStage] &= ~(DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, ~0) << celsiusCombinerInputShift[eInput]);

    pContext->hwState.dwColorICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Set the input mapping mode for the given stage and input

void SetColorMapping (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                       DWORD dwCombinerStage, DWORD dwMapping)
{
    pContext->hwState.dwColorICW[dwCombinerStage] &= ~(DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_MAP, 0xffffffff)  << celsiusCombinerInputShift[eInput]);
    pContext->hwState.dwColorICW[dwCombinerStage] |= (DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_MAP, dwMapping) << celsiusCombinerInputShift[eInput]);
}

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT SelectColorInput (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                          BOOL bComplement, BOOL bExpandNormal, BOOL bAlphaReplicate)
{
    DWORD dwICW = 0;

    switch (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwD3DStage != 0 && (pContext->tssState[0].dwValue[D3DTSS_RESULTARG] != D3DTA_TEMP) ) {
                // Output from previous stage
                dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP])) {
                // if we don't actually have a texture, default to the 'current'.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
                dwICW |= DRF_NUM(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, CELSIUS_COMBINER_REG_TEX0 + pContext->hwState.dwNextAvailableTextureUnit);
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_SPECULAR:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_5);
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMBINERSNEEDSPECULAR;
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_SOURCE, _REG_D);
            break;
        default:
            DPF ("unknown / illegal color argument '%d' in SelectColorInput",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            dbgD3DError();
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            break;
    }

    // Now handle the alpha replicate and complement flags

    bAlphaReplicate |= (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_ALPHAREPLICATE);

    dwICW |= bAlphaReplicate ? DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _TRUE) :
                               DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_ALPHA, _FALSE);

    bComplement = ((pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_COMPLEMENT) ^
                   ((bComplement) ? D3DTA_COMPLEMENT : 0))
                  ?
                  TRUE : FALSE;

    if (bExpandNormal) {
        dwICW |= bComplement ? DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NEGATE) :
                               DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _EXPAND_NORMAL);
    }
    else {
        dwICW |= bComplement ? DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_INVERT) :
                               DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_D_MAP, _UNSIGNED_IDENTITY);
    }

    pContext->hwState.dwColorICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);
    return (0);
}

//---------------------------------------------------------------------------

// Select the input into A
static HRESULT combineselect1 (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // A * 1
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

// Select the input into D
static HRESULT combineselect2 (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply D * 1
    SetColorInputOne (pContext, celsiusCombinerInputC, hdStage, FALSE);
    hr = SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // A & B default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemodulate (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * B
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineadd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1(B)
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    // Make B 1
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Multiply 1(C) * D
    SetColorInputOne (pContext, celsiusCombinerInputC, hdStage, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + D

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinesub (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Multiply D * -1
    SetColorInputOne (pContext, celsiusCombinerInputC, hdStage, TRUE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    // Implicit A + -D

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineaddsmooth (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply A * 1
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Make C: (1-arg1), make D: arg2
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, TRUE, FALSE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combineblendalpha (PNVD3DCONTEXT pContext, int hdStage, int dxStage, int type)
{
    HRESULT hr = 0;
    int     temp;
    BOOL    bAlphaReplicate;

    // if the last stage involved a dot3 operation, pull alpha_current from the last stage's color channels
    // rather than its alpha channel, because the copy into the latter will have been deferred and the value
    // will not yet be available there.
    bAlphaReplicate = ((type==D3DTA_CURRENT) &&
                       (hdStage > 0) &&
                       (pContext->hwState.dwStateFlags & CELSIUS_FLAG_DOTPRODUCT3(hdStage-1))) ? FALSE : TRUE;

    // A gets alpha, as appropriate
    if (type == TEXTUREPM) {
        // Make A=1 since texture is already pre-multiplied
        SetColorInputOne (pContext, celsiusCombinerInputA, hdStage, FALSE);
        // set type again for making C (1-alpha) below
        type = D3DTA_TEXTURE;
    }
    else {
        temp = pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2];
        pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2] = type;
        hr |= SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, bAlphaReplicate);
        pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2] = temp;
    }

    // B gets arg1
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);

    // C gets 1-alpha
    temp = pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG1];
    pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG1] = type;
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, TRUE, FALSE, bAlphaReplicate);
    pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG1] = temp;

    // D gets arg2
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

// The way D3D does this, it essentially allows using texture from stage 1
// in stage1 twice.  D3D does not normally allow you to use a texture in
// stage 0 and stage1.  This way, D3D allows you to modulate in (effectively)
// stage 0 and then do whatever it is you are going to do in stage1.  The
// key is that we use the texture from stage1 (since there is really no texture
// in stage 0)

// Premodulate in stage (i-1) is effectively selectarg1
// Then, in stage i, modulate current color (the above) with texture in stage i
// Then, do the operation chosen for stage i

static HRESULT combinepremodulate (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;
    int temp, premodulate = 1;

    DPF ("pre-modulationis totally broken");
    dbgD3DError();

    if (dxStage == 0) {
        if (pContext->tssState[1].dwValue[D3DTSS_COLOROP] != D3DTOP_DISABLE) {
            // This modulates selectarg1(stage0) with texture(stage1) now!
            // The right solution is really to wait and see if there is a stage 1
            // make A: colorArg1(0), make B: texture(nextstage)
            hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            // This is a bit of a hack here since we use colorarg from stage 0
            // but we get the texture from stage 1 (told to in SelectB)
            temp = pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2];
            pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2] = D3DTA_TEXTURE;
            hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
            // reset back arg2
            pContext->tssState[dxStage].dwValue[D3DTSS_COLORARG2] = temp;
        }
        else {
            // asked to do premodulate on a single texture stage -- just pass down
            // the colorarg1
            hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
            SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
        }
    }
    else // well, right now we only handle two stages (we could compress these)
    {
        // if pre-modulate is called in stage1, we could modulate with
        // texture from next stage. But, we'd have to handle settexture a bit
        // differently. For now, we'll just use selectarg1
        hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
        SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);

        //DCR check for premodulate on stage 0?
    }

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemodulatealpha (PNVD3DCONTEXT pContext, int hdStage, int dxStage, int complement)
{
    HRESULT hr;

    // A * 1
    hr = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // Set C alpha(arg1), Set D: arg2
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, complement, FALSE, TRUE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemodulatecolor (PNVD3DCONTEXT pContext, int hdStage, int dxStage, int complement)
{
    HRESULT hr;

    // A * B
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, complement, FALSE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    // Set C alpha(arg1), Set D: 1
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, TRUE);
    SetColorInputOne (pContext, celsiusCombinerInputD, hdStage, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinedotproduct (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // Multiply expanded A * expanded B
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, TRUE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, TRUE, FALSE);
    // C & D default to zero

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinemultiplyadd (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;

    // set A to arg1
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    //set B to 1
    SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    // set C to arg2
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    //set D to arg3
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);

    return (hr);
}

//---------------------------------------------------------------------------

static HRESULT combinelerp (PNVD3DCONTEXT pContext, int hdStage, int dxStage)
{
    HRESULT hr;
    
    // Multiply A * B
    hr  = SelectColorInput (pContext, celsiusCombinerInputA, hdStage, dxStage, D3DTSS_COLORARG0, FALSE, FALSE, FALSE);
    hr |= SelectColorInput (pContext, celsiusCombinerInputB, hdStage, dxStage, D3DTSS_COLORARG1, FALSE, FALSE, FALSE);
    //set C to 1 - arg1
    hr |= SelectColorInput (pContext, celsiusCombinerInputC, hdStage, dxStage, D3DTSS_COLORARG0, TRUE, FALSE, FALSE);
    //set D to arg3
    hr |= SelectColorInput (pContext, celsiusCombinerInputD, hdStage, dxStage, D3DTSS_COLORARG2, FALSE, FALSE, FALSE);
    
    return (hr);
}

//---------------------------------------------------------------------------

// Set up output combiners

void ConstructOutputColorCombiners(PNVD3DCONTEXT pContext, int enable, int stage, int bias, int shift, int dotAB, int dotCD, int outtemp)
{
    outtemp  &= (stage != 1);

    if (!enable) {
        assert(stage > 0);  // stage 0 should always be enabled
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_0);
        return;
    }

    // select bias operation
    if (stage == 0) {

        if (shift == 0) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _NOSHIFT);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _NOSHIFT_BIAS);
        }
        else if (shift == 1) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
        }
        else if (shift == 2) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _SHIFTLEFTBY2);
            else
                // we can't shift by 2 and bias. do the best we can...
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
        }

        // select mux enable
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_MUX_SELECT, _LSB);  // the '1' is not a typo
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_MUX_ENABLE, _FALSE);

        // select AB dot enable
        if (dotAB)
        {
            pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_AB_DOT_ENABLE, _TRUE);

            if(dotCD)//select CD dot enable, and the sum as final result
            {
                if (outtemp)
                    pContext->hwState.dwColorOCW[stage] |= (DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)|
                                                            DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_SUM_DST, _REG_D));
                else
                    pContext->hwState.dwColorOCW[stage] |= (DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)|
                                                            DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_SUM_DST, _REG_C));
            }
            else //if only AB dot enabled, put A*B as the final result
            {
                if (outtemp)
                    pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_AB_DST, _REG_D); 
                else
                    pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_AB_DST, _REG_C); 
            }
        }
        else //select the sum as final result
        {
            if (outtemp)
                pContext->hwState.dwColorOCW[stage] |=  DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_SUM_DST, _REG_D);
            else
                pContext->hwState.dwColorOCW[stage] |=  DRF_DEF(056, _SET_COMBINER0_COLOR, _OCW_SUM_DST, _REG_C);
        }
    }

    else { // stage 1

        if (shift == 0) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _NOSHIFT);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _NOSHIFT_BIAS);
        }
        else if (shift == 1) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1_BIAS);
        }
        else if (shift == 2) {
            if (bias == 0)
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _SHIFTLEFTBY2);
            else
                pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_OPERATION, _SHIFTLEFTBY1);
        }

        // select mux enable
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_MUX_SELECT, _LSB);
        pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_MUX_ENABLE, _FALSE);

        // select AB dot enable
        if (dotAB)
        {
            pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_AB_DOT_ENABLE, _TRUE);

            if(dotCD)// select CD dot enable, and sum as final result
            {
                if (outtemp)
                    pContext->hwState.dwColorOCW[stage] |= (DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)|
                                                                DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_D));
                else
                    pContext->hwState.dwColorOCW[stage] |= (DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_CD_DOT_ENABLE, _TRUE)|
                                                                DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_C));
            }
            else //if only AB dot enabled, put A*B as the final result
            {
                if (outtemp)
                    pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_AB_DST, _REG_D);
                else
                    pContext->hwState.dwColorOCW[stage] |= DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_AB_DST, _REG_C); 
            }
        }
        else //select the sum as final result
        {
            if (outtemp)
                pContext->hwState.dwColorOCW[stage] |=  DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_D);
            else
                pContext->hwState.dwColorOCW[stage] |=  DRF_DEF(056, _SET_COMBINER1_COLOR, _OCW_SUM_DST, _REG_C);
        }
    }
}

//---------------------------------------------------------------------------

BOOL ConstructColorCombiners (PNVD3DCONTEXT pContext, int hdStage, int dxStage )
{
    int     dotproduct, bias, shift;
    BOOL    enable, stageactive;
    HRESULT hr = 0;

    dotproduct = 0;
    bias = 0;
    shift = 0;
    enable = TRUE;
    stageactive = TRUE;

    pContext->hwState.dwColorICW[hdStage] = 0;
    pContext->hwState.dwColorOCW[hdStage] = 0;

    switch (pContext->tssState[dxStage].dwValue[D3DTSS_COLOROP]) {
        default:
        case D3DTOP_DISABLE:
            if (dxStage == 0) { // only construct for stage 0
                // Default is diffuse color, make A=diffuse, B=1, C=D=0
                pContext->hwState.dwColorICW[hdStage] |= DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
                SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
            }
            else {
                enable = FALSE; // don't enable output combiner
            }
            stageactive = FALSE;
            break;
        case D3DTOP_SELECTARG1:
            hr = combineselect1 (pContext, hdStage, dxStage);
            break;
        case D3DTOP_SELECTARG2: // same as 2 from above
            hr = combineselect2 (pContext, hdStage, dxStage);
            break;
        case D3DTOP_MODULATE4X:
            shift++;
        case D3DTOP_MODULATE2X:
            shift++;
        case D3DTOP_MODULATE:
            hr = combinemodulate (pContext, hdStage, dxStage);
            break;
        case D3DTOP_ADDSIGNED2X: // same as addsigned with following change
            shift = 1;
        case D3DTOP_ADDSIGNED:   // same as add with following change
            bias = 1;
        case D3DTOP_ADD:
            hr = combineadd (pContext, hdStage, dxStage);
            break;
        case D3DTOP_SUBTRACT:
            hr = combinesub (pContext, hdStage, dxStage);
            break;
        case D3DTOP_ADDSMOOTH:
            hr = combineaddsmooth (pContext, hdStage, dxStage);
            break;
        case D3DTOP_BLENDDIFFUSEALPHA:
            hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_DIFFUSE);
            break;
        case D3DTOP_BLENDTEXTUREALPHA:
            hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_TEXTURE);
            break;
        case D3DTOP_BLENDFACTORALPHA:
            hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_TFACTOR);
            break;
        case D3DTOP_BLENDTEXTUREALPHAPM:
            hr = combineblendalpha (pContext, hdStage, dxStage, TEXTUREPM);
            break;
        case D3DTOP_BLENDCURRENTALPHA:
            hr = combineblendalpha (pContext, hdStage, dxStage, D3DTA_CURRENT);
            break;
        case D3DTOP_PREMODULATE:
            hr = combinepremodulate (pContext, hdStage, dxStage);
            break;
        case D3DTOP_MODULATEALPHA_ADDCOLOR:
            hr = combinemodulatealpha (pContext, hdStage, dxStage, 0);
            break;
        case D3DTOP_MODULATECOLOR_ADDALPHA:
            hr = combinemodulatecolor (pContext, hdStage, dxStage, 0);
            break;
        case D3DTOP_MODULATEINVALPHA_ADDCOLOR:
            hr = combinemodulatealpha (pContext, hdStage, dxStage, 1); // complement
            break;
        case D3DTOP_MODULATEINVCOLOR_ADDALPHA:
            hr = combinemodulatecolor (pContext, hdStage, dxStage, 1); // complement
            break;
        case D3DTOP_BUMPENVMAP:
            break;
        case D3DTOP_BUMPENVMAPLUMINANCE:
            break;
        case D3DTOP_DOTPRODUCT3:
            hr = combinedotproduct (pContext, hdStage, dxStage);
            dotproduct = 1;
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_DOTPRODUCT3(hdStage);
            break;
        case D3DTOP_MULTIPLYADD:
            hr = combinemultiplyadd (pContext, hdStage, dxStage);
            break;
        case D3DTOP_LERP:
            hr = combinelerp (pContext, hdStage, dxStage);
            break;
        }

    if (hr == TSS_USES_NULL_TEXTURE) {
        // this stage references a non-existent texture. just set it back to "select current"
        if (hdStage == 0) {
            // current = diffuse in stage 0
            pContext->hwState.dwColorICW[hdStage] = DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_4);
        }
        else {
            pContext->hwState.dwColorICW[hdStage] = DRF_DEF(056, _SET_COMBINER_COLOR, _ICW_A_SOURCE, _REG_C);
        }
        SetColorInputOne (pContext, celsiusCombinerInputB, hdStage, FALSE);
    }

    ConstructOutputColorCombiners (pContext, enable, hdStage, bias, shift, dotproduct, 0, 
                                   pContext->tssState[dxStage].dwValue[D3DTSS_RESULTARG] == D3DTA_TEMP);

    return (stageactive);
}

#endif  // NVARCH == 0x10
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\ddraw\celsius\src\nvCelsiusAlphaCombiner.cpp ===
/*
 * Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.
 * THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
 * NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
 * IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
 */
/********************************* Direct 3D *******************************\
*                                                                           *
* Module: nvCelsiusAlphaCombiner.cpp                                        *
*       Routines for programming the celsiusalpha combiner                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Craig Duttweiler        02Mar99         NV10 development            *
*                                                                           *
\***************************************************************************/
#include "nvprecomp.h"

#if (NVARCH >= 0x10)

//---------------------------------------------------------------------------

// Set an alpha input to to 1 or -1

void SetAlphaInputOne (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                       DWORD dwCombinerStage, BOOL bNegate)
{
    DWORD dwICW = 0;

    dwICW |= bNegate ? DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _EXPAND_NORMAL) :
                       DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_MAP, _UNSIGNED_INVERT);

    dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_ALPHA, _FALSE);
    dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_0);

    pContext->hwState.dwAlphaICW[dwCombinerStage] |= (dwICW << celsiusCombinerInputShift[eInput]);
}

//---------------------------------------------------------------------------

// Select the source for combiner input eInput in combiner stage
// dwCombinerStage from argument dwD3DTSSArg in D3D stage dwD3DStage.
// return TSS_USES_NULL_TEXTURE if we reference a texture we don't have

HRESULT SelectAlphaInput (PNVD3DCONTEXT pContext, celsiusCombinerInput eInput,
                          DWORD dwCombinerStage, DWORD dwD3DStage, DWORD dwD3DTSSArg,
                          BOOL bComplement, BOOL bExpandNormal)
{
    DWORD dwICW = 0;

    switch (pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK) {
        case D3DTA_CURRENT:
            if (dwD3DStage != 0 && (pContext->tssState[0].dwValue[D3DTSS_RESULTARG] != D3DTA_TEMP)) {
            // Output from previous stage
                dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_C);
                break;
            }
            // else, default to diffuse below
        case D3DTA_DIFFUSE:
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_4);
            break;
        case D3DTA_TEXTURE:
            if (!(pContext->tssState[dwD3DStage].dwValue[D3DTSS_TEXTUREMAP])) {
                // if we don't actually have a texture, default to the 'current' alpha.
                // yes, this is actually the d3d default: select texture with no texture.
                // my mama done told me, my name was duh microsoft.
                return (TSS_USES_NULL_TEXTURE);
            }
            else {
                pContext->hwState.dwTexUnitToTexStageMapping[pContext->hwState.dwNextAvailableTextureUnit] = dwD3DStage;
                dwICW |= DRF_NUM(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, CELSIUS_COMBINER_REG_TEX0 + pContext->hwState.dwNextAvailableTextureUnit);
            }
            break;
        case D3DTA_TFACTOR:
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_1);
            break;
        case D3DTA_TEMP:
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_D);
            break;
        case D3DTA_SPECULAR: //specular is an invalid arg.
            dwICW |= DRF_DEF(056, _SET_COMBINER_ALPHA, _ICW_D_SOURCE, _REG_5);
            
            DPF ("Specular Alpha doesn't exist in Celsius, rendering corruption will result.",
                 pContext->tssState[dwD3DStage].dwValue[dwD3DTSSArg] & D3DTA_SELECTMASK);
            
            dbgD3DError();
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_SETUPFAILURE;
            pContext->hwState.dwStateFlags |= CELSIUS_FLAG_COMBINERSNEEDSPECULAR;
            
            brea