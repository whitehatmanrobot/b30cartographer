00000
#define SSRVOPT_WINHTTP             0x00800000
#define SSRVOPT_WININET             0x01000000

#define SSRVOPT_MAX                 0x0100000

#define SSRVOPT_RESET               ((ULONG_PTR)-1)


#define NUM_SSRVOPTS                30

#define SSRVACTION_TRACE        1
#define SSRVACTION_QUERYCANCEL  2
#define SSRVACTION_EVENT        3
#define SSRVACTION_EVENTW       4
#define SSRVACTION_SIZE         5

#define SYMSTOREOPT_COMPRESS        0x01
#define SYMSTOREOPT_OVERWRITE       0x02
#define SYMSTOREOPT_RETURNINDEX     0x04
#define SYMSTOREOPT_POINTER         0x08
#define SYMSTOREOPT_ALT_INDEX       0x10
#define SYMSTOREOPT_UNICODE         0x20
#define SYMSTOREOPT_PASS_IF_EXISTS  0x40

#ifdef DBGHELP_TRANSLATE_TCHAR
 #define SymInitialize                     SymInitializeW
 #define SymAddSymbol                      SymAddSymbolW
 #define SymDeleteSymbol                   SymDeleteSymbolW
 #define SearchTreeForFile                 SearchTreeForFileW
 #define UnDecorateSymbolName              UnDecorateSymbolNameW
 #define SymGetLineFromName64              SymGetLineFromNameW64
 #define SymGetLineFromAddr64              SymGetLineFromAddrW64
 #define SymGetLineNext64                  SymGetLineNextW64
 #define SymGetLinePrev64                  SymGetLinePrevW64
 #define SymFromName                       SymFromNameW
 #define SymFindExecutableImage            SymFindExecutableImageW
 #define FindExecutableImageEx             FindExecutableImageExW
 #define SymSearch                         SymSearchW
 #define SymEnumLines                      SymEnumLinesW
 #define SymEnumSourceLines                SymEnumSourceLinesW
 #define SymGetTypeFromName                SymGetTypeFromNameW
 #define SymEnumSymbolsForAddr             SymEnumSymbolsForAddrW
 #define SymFromAddr                       SymFromAddrW
 #define SymMatchString                    SymMatchStringW
 #define SymEnumSourceFiles                SymEnumSourceFilesW
 #define SymEnumSymbols                    SymEnumSymbolsW
 #define SymLoadModuleEx                   SymLoadModuleExW
 #define SymSetSearchPath                  SymSetSearchPathW
 #define SymGetSearchPath                  SymGetSearchPathW
 #define EnumDirTree                       EnumDirTreeW
 #define SymFromToken                      SymFromTokenW
 #define SymFromIndex                      SymFromIndexW
 #define SymGetScope                       SymGetScopeW
 #define SymNext                           SymNextW
 #define SymPrev                           SymPrevW
 #define SymEnumTypes                      SymEnumTypesW
 #define SymEnumTypesByName                SymEnumTypesByNameW
 #define SymRegisterCallback64             SymRegisterCallbackW64
 #define SymFindDebugInfoFile              SymFindDebugInfoFileW
 #define FindDebugInfoFileEx               FindDebugInfoFileExW
 #define SymFindFileInPath                 SymFindFileInPathW
 #define SymEnumerateModules64             SymEnumerateModulesW64
 #define SymSetHomeDirectory               SymSetHomeDirectoryW
 #define SymGetHomeDirectory               SymGetHomeDirectoryW
 #define SymGetSourceFile                  SymGetSourceFileW
 #define SymGetSourceFileToken             SymGetSourceFileTokenW
 #define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
 #define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
 #define SymGetSourceFileToken             SymGetSourceFileTokenW
 #define SymGetFileLineOffsets64           SymGetFileLineOffsetsW64
 #define SymFindFileInPath                 SymFindFileInPathW
 #define SymMatchFileName                  SymMatchFileNameW
 #define SymGetSourceFileFromToken         SymGetSourceFileFromTokenW
 #define SymGetSourceVarFromToken          SymGetSourceVarFromTokenW
 #define SymGetModuleInfo64                SymGetModuleInfoW64
 #define SymSrvIsStore                     SymSrvIsStoreW
 #define SymSrvDeltaName                   SymSrvDeltaNameW
 #define SymSrvGetSupplement               SymSrvGetSupplementW
 #define SymSrvStoreSupplement             SymSrvStoreSupplementW
 #define SymSrvGetFileIndexes              SymSrvGetFileIndexes
 #define SymSrvGetFileIndexString          SymSrvGetFileIndexStringW
 #define SymSrvStoreFile                   SymSrvStoreFileW
 #define SymGetSymbolFile                  SymGetSymbolFileW
 #define EnumerateLoadedModules64          EnumerateLoadedModulesW64
 #define EnumerateLoadedModulesEx          EnumerateLoadedModulesExW
 #define SymSrvGetFileIndexInfo            SymSrvGetFileIndexInfoW

 #define IMAGEHLP_LINE64                   IMAGEHLP_LINEW64
 #define PIMAGEHLP_LINE64                  PIMAGEHLP_LINEW64
 #define SYMBOL_INFO                       SYMBOL_INFOW
 #define PSYMBOL_INFO                      PSYMBOL_INFOW
 #define SYMBOL_INFO_PACKAGE               SYMBOL_INFO_PACKAGEW
 #define PSYMBOL_INFO_PACKAGE              PSYMBOL_INFO_PACKAGEW
 #define FIND_EXE_FILE_CALLBACK            FIND_EXE_FILE_CALLBACKW
 #define PFIND_EXE_FILE_CALLBACK           PFIND_EXE_FILE_CALLBACKW
 #define SYM_ENUMERATESYMBOLS_CALLBACK     SYM_ENUMERATESYMBOLS_CALLBACKW
 #define PSYM_ENUMERATESYMBOLS_CALLBACK    PSYM_ENUMERATESYMBOLS_CALLBACKW
 #define SRCCODEINFO                       SRCCODEINFOW
 #define PSRCCODEINFO                      PSRCCODEINFOW
 #define SOURCEFILE                        SOURCEFILEW
 #define PSOURCEFILE                       PSOURCEFILEW
 #define SYM_ENUMSOURECFILES_CALLBACK      SYM_ENUMSOURCEFILES_CALLBACKW
 #define PSYM_ENUMSOURCEFILES_CALLBACK     PSYM_ENUMSOURECFILES_CALLBACKW
 #define IMAGEHLP_CBA_EVENT                IMAGEHLP_CBA_EVENTW
 #define PIMAGEHLP_CBA_EVENT               PIMAGEHLP_CBA_EVENTW
 #define PENUMDIRTREE_CALLBACK             PENUMDIRTREE_CALLBACKW
 #define IMAGEHLP_DEFERRED_SYMBOL_LOAD64   IMAGEHLP_DEFERRED_SYMBOL_LOADW64
 #define PIMAGEHLP_DEFERRED_SYMBOL_LOAD64  PIMAGEHLP_DEFERRED_SYMBOL_LOADW64
 #define PFIND_DEBUG_FILE_CALLBACK         PFIND_DEBUG_FILE_CALLBACKW
 #define PFINDFILEINPATHCALLBACK           PFINDFILEINPATHCALLBACKW
 #define IMAGEHLP_MODULE64                 IMAGEHLP_MODULEW64
 #define PIMAGEHLP_MODULE64                PIMAGEHLP_MODULEW64
 #define SYMSRV_INDEX_INFO                 SYMSRV_INDEX_INFOW
 #define PSYMSRV_INDEX_INFO                PSYMSRV_INDEX_INFOW

 #define PSYMBOLSERVERPROC                 PSYMBOLSERVERPROCW
 #define PSYMBOLSERVERPINGPROC             PSYMBOLSERVERPINGPROCW
#endif

// -----------------------------------------------------------------
// The following APIs exist only for backwards compatibility
// with a pre-release version documented in an MSDN release.

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in PVOID id,
    __in DWORD two,
    __in DWORD three,
    __in DWORD flags,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
    );

// You should use SymFindFileInPath if you want to maintain
// future compatibility.

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
FindFileInSearchPath(
    __in HANDLE hprocess,
    __in PCSTR SearchPath,
    __in PCSTR FileName,
    __in DWORD one,
    __in DWORD two,
    __in DWORD three,
    __out_ecount(MAX_PATH + 1) PSTR FilePath
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumSym(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW64(
    __in HANDLE hProcess,
    __in ULONG64 BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );


#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymEnumerateSymbols SymEnumerateSymbols64
#define SymEnumerateSymbolsW SymEnumerateSymbolsW64
#else
DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbols(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );

DBHLP_DEPRECIATED
BOOL
IMAGEAPI
SymEnumerateSymbolsW(
    __in HANDLE hProcess,
    __in ULONG BaseOfDll,
    __in PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback,
    __in_opt PVOID UserContext
    );
#endif

// use SymLoadModuleEx

DWORD64
IMAGEAPI
SymLoadModule64(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD64 BaseOfDll,
    __in DWORD SizeOfDll
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymLoadModule SymLoadModule64
#else
DWORD
IMAGEAPI
SymLoadModule(
    __in HANDLE hProcess,
    __in_opt HANDLE hFile,
    __in_opt PCSTR ImageName,
    __in_opt PCSTR ModuleName,
    __in DWORD BaseOfDll,
    __in DWORD SizeOfDll
    );
#endif

BOOL
IMAGEAPI
SymGetSymNext64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
    );

BOOL
IMAGEAPI
SymGetSymNextW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymNext SymGetSymNext64
#define SymGetSymNextW SymGetSymNextW64
#else
BOOL
IMAGEAPI
SymGetSymNext(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
    );

BOOL
IMAGEAPI
SymGetSymNextW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
    );
#endif

BOOL
IMAGEAPI
SymGetSymPrev64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL64 Symbol
    );

BOOL
IMAGEAPI
SymGetSymPrevW64(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW64 Symbol
    );

#if !defined(_IMAGEHLP_SOURCE_) && defined(_IMAGEHLP64)
#define SymGetSymPrev SymGetSymPrev64
#define SymGetSymPrevW SymGetSymPrevW64
#else
BOOL
IMAGEAPI
SymGetSymPrev(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOL Symbol
    );

BOOL
IMAGEAPI
SymGetSymPrevW(
    __in HANDLE hProcess,
    __inout PIMAGEHLP_SYMBOLW Symbol
    );
#endif


// These values should not be used.
// They have been replaced by SYMFLAG_ values.

#define SYMF_OMAP_GENERATED   0x00000001
#define SYMF_OMAP_MODIFIED    0x00000002
#define SYMF_REGISTER         0x00000008
#define SYMF_REGREL           0x00000010
#define SYMF_FRAMEREL         0x00000020
#define SYMF_PARAMETER        0x00000040
#define SYMF_LOCAL            0x00000080
#define SYMF_CONSTANT         0x00000100
#define SYMF_EXPORT           0x00000200
#define SYMF_FORWARDER        0x00000400
#define SYMF_FUNCTION         0x00000800
#define SYMF_VIRTUAL          0x00001000
#define SYMF_THUNK            0x00002000
#define SYMF_TLSREL           0x00004000

// These values should also not be used.
// They have been replaced by SYMFLAG_ values.

#define IMAGEHLP_SYMBOL_INFO_VALUEPRESENT          1
#define IMAGEHLP_SYMBOL_INFO_REGISTER              SYMF_REGISTER        // 0x0008
#define IMAGEHLP_SYMBOL_INFO_REGRELATIVE           SYMF_REGREL          // 0x0010
#define IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE         SYMF_FRAMEREL        // 0x0020
#define IMAGEHLP_SYMBOL_INFO_PARAMETER             SYMF_PARAMETER       // 0x0040
#define IMAGEHLP_SYMBOL_INFO_LOCAL                 SYMF_LOCAL           // 0x0080
#define IMAGEHLP_SYMBOL_INFO_CONSTANT              SYMF_CONSTANT        // 0x0100
#define IMAGEHLP_SYMBOL_FUNCTION                   SYMF_FUNCTION        // 0x0800
#define IMAGEHLP_SYMBOL_VIRTUAL                    SYMF_VIRTUAL         // 0x1000
#define IMAGEHLP_SYMBOL_THUNK                      SYMF_THUNK           // 0x2000
#define IMAGEHLP_SYMBOL_INFO_TLSRELATIVE           SYMF_TLSREL          // 0x4000

#include <poppack.h>


#include <pshpack4.h>

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200)    /* Zero length array */
#pragma warning(disable:4201)    /* Nameless struct/union */
#endif
#endif

#define MINIDUMP_SIGNATURE ('PMDM')
#define MINIDUMP_VERSION   (42899)
typedef DWORD RVA;
typedef ULONG64 RVA64;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR {
    ULONG32 DataSize;
    RVA Rva;
} MINIDUMP_LOCATION_DESCRIPTOR;

typedef struct _MINIDUMP_LOCATION_DESCRIPTOR64 {
    ULONG64 DataSize;
    RVA64 Rva;
} MINIDUMP_LOCATION_DESCRIPTOR64;


typedef struct _MINIDUMP_MEMORY_DESCRIPTOR {
    ULONG64 StartOfMemoryRange;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_MEMORY_DESCRIPTOR, *PMINIDUMP_MEMORY_DESCRIPTOR;

// DESCRIPTOR64 is used for full-memory minidumps where
// all of the raw memory is laid out sequentially at the
// end of the dump.  There is no need for individual RVAs
// as the RVA is the base RVA plus the sum of the preceeding
// data blocks.
typedef struct _MINIDUMP_MEMORY_DESCRIPTOR64 {
    ULONG64 StartOfMemoryRange;
    ULONG64 DataSize;
} MINIDUMP_MEMORY_DESCRIPTOR64, *PMINIDUMP_MEMORY_DESCRIPTOR64;


typedef struct _MINIDUMP_HEADER {
    ULONG32 Signature;
    ULONG32 Version;
    ULONG32 NumberOfStreams;
    RVA StreamDirectoryRva;
    ULONG32 CheckSum;
    union {
        ULONG32 Reserved;
        ULONG32 TimeDateStamp;
    };
    ULONG64 Flags;
} MINIDUMP_HEADER, *PMINIDUMP_HEADER;

//
// The MINIDUMP_HEADER field StreamDirectoryRva points to 
// an array of MINIDUMP_DIRECTORY structures.
//

typedef struct _MINIDUMP_DIRECTORY {
    ULONG32 StreamType;
    MINIDUMP_LOCATION_DESCRIPTOR Location;
} MINIDUMP_DIRECTORY, *PMINIDUMP_DIRECTORY;


typedef struct _MINIDUMP_STRING {
    ULONG32 Length;         // Length in bytes of the string
    WCHAR   Buffer [0];     // Variable size buffer
} MINIDUMP_STRING, *PMINIDUMP_STRING;



//
// The MINIDUMP_DIRECTORY field StreamType may be one of the following types.
// Types will be added in the future, so if a program reading the minidump
// header encounters a stream type it does not understand it should ignore
// the data altogether. Any tag above LastReservedStream will not be used by
// the system and is reserved for program-specific information.
//

typedef enum _MINIDUMP_STREAM_TYPE {

    UnusedStream                = 0,
    ReservedStream0             = 1,
    ReservedStream1             = 2,
    ThreadListStream            = 3,
    ModuleListStream            = 4,
    MemoryListStream            = 5,
    ExceptionStream             = 6,
    SystemInfoStream            = 7,
    ThreadExListStream          = 8,
    Memory64ListStream          = 9,
    CommentStreamA              = 10,
    CommentStreamW              = 11,
    HandleDataStream            = 12,
    FunctionTableStream         = 13,
    UnloadedModuleListStream    = 14,
    MiscInfoStream              = 15,
    MemoryInfoListStream        = 16,
    ThreadInfoListStream        = 17,
    HandleOperationListStream   = 18,
    TokenStream                 = 19,

    ceStreamNull                = 0x8000,
    ceStreamSystemInfo          = 0x8001,
    ceStreamException           = 0x8002,
    ceStreamModuleList          = 0x8003,
    ceStreamProcessList         = 0x8004,
    ceStreamThreadList          = 0x8005, 
    ceStreamThreadContextList   = 0x8006,
    ceStreamThreadCallStackList = 0x8007,
    ceStreamMemoryVirtualList   = 0x8008,
    ceStreamMemoryPhysicalList  = 0x8009,
    ceStreamBucketParameters    = 0x800A,     
    ceStreamProcessModuleMap    = 0x800B,
    ceStreamDiagnosisList       = 0x800C,

    LastReservedStream          = 0xffff

} MINIDUMP_STREAM_TYPE;


//
// The minidump system information contains processor and
// Operating System specific information.
// 

//
// CPU information is obtained from one of two places.
//
//  1) On x86 computers, CPU_INFORMATION is obtained from the CPUID
//     instruction. You must use the X86 portion of the union for X86
//     computers.
//
//  2) On non-x86 architectures, CPU_INFORMATION is obtained by calling
//     IsProcessorFeatureSupported().
//

typedef union _CPU_INFORMATION {

    //
    // X86 platforms use CPUID function to obtain processor information.
    //
    
    struct {

        //
        // CPUID Subfunction 0, register EAX (VendorId [0]),
        // EBX (VendorId [1]) and ECX (VendorId [2]).
        //
        
        ULONG32 VendorId [ 3 ];
        
        //
        // CPUID Subfunction 1, register EAX
        //
        
        ULONG32 VersionInformation;

        //
        // CPUID Subfunction 1, register EDX
        //
        
        ULONG32 FeatureInformation;
        

        //
        // CPUID, Subfunction 80000001, register EBX. This will only
        // be obtained if the vendor id is "AuthenticAMD".
        //
        
        ULONG32 AMDExtendedCpuFeatures;

    } X86CpuInfo;

    //
    // Non-x86 platforms use processor feature flags.
    //
    
    struct {

        ULONG64 ProcessorFeatures [ 2 ];
        
    } OtherCpuInfo;

} CPU_INFORMATION, *PCPU_INFORMATION;
        
typedef struct _MINIDUMP_SYSTEM_INFO {

    //
    // ProcessorArchitecture, ProcessorLevel and ProcessorRevision are all
    // taken from the SYSTEM_INFO structure obtained by GetSystemInfo( ).
    //
    
    USHORT ProcessorArchitecture;
    USHORT ProcessorLevel;
    USHORT ProcessorRevision;

    union {
        USHORT Reserved0;
        struct {
            UCHAR NumberOfProcessors;
            UCHAR ProductType;
        };
    };

    //
    // MajorVersion, MinorVersion, BuildNumber, PlatformId and
    // CSDVersion are all taken from the OSVERSIONINFO structure
    // returned by GetVersionEx( ).
    //
    
    ULONG32 MajorVersion;
    ULONG32 MinorVersion;
    ULONG32 BuildNumber;
    ULONG32 PlatformId;

    //
    // RVA to a CSDVersion string in the string table.
    //
    
    RVA CSDVersionRva;

    union {
        ULONG32 Reserved1;
        struct {
            USHORT SuiteMask;
            USHORT Reserved2;
        };
    };

    CPU_INFORMATION Cpu;

} MINIDUMP_SYSTEM_INFO, *PMINIDUMP_SYSTEM_INFO;


//
// The minidump thread contains standard thread
// information plus an RVA to the memory for this 
// thread and an RVA to the CONTEXT structure for
// this thread.
//


//
// ThreadId must be 4 bytes on all architectures.
//

C_ASSERT (sizeof ( ((PPROCESS_INFORMATION)0)->dwThreadId ) == 4);

typedef struct _MINIDUMP_THREAD {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_THREAD, *PMINIDUMP_THREAD;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD Threads [0];
} MINIDUMP_THREAD_LIST, *PMINIDUMP_THREAD_LIST;


typedef struct _MINIDUMP_THREAD_EX {
    ULONG32 ThreadId;
    ULONG32 SuspendCount;
    ULONG32 PriorityClass;
    ULONG32 Priority;
    ULONG64 Teb;
    MINIDUMP_MEMORY_DESCRIPTOR Stack;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
    MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
} MINIDUMP_THREAD_EX, *PMINIDUMP_THREAD_EX;

//
// The thread list is a container of threads.
//

typedef struct _MINIDUMP_THREAD_EX_LIST {
    ULONG32 NumberOfThreads;
    MINIDUMP_THREAD_EX Threads [0];
} MINIDUMP_THREAD_EX_LIST, *PMINIDUMP_THREAD_EX_LIST;


//
// The MINIDUMP_EXCEPTION is the same as EXCEPTION on Win64.
//

typedef struct _MINIDUMP_EXCEPTION  {
    ULONG32 ExceptionCode;
    ULONG32 ExceptionFlags;
    ULONG64 ExceptionRecord;
    ULONG64 ExceptionAddress;
    ULONG32 NumberParameters;
    ULONG32 __unusedAlignment;
    ULONG64 ExceptionInformation [ EXCEPTION_MAXIMUM_PARAMETERS ];
} MINIDUMP_EXCEPTION, *PMINIDUMP_EXCEPTION;


//
// The exception information stream contains the id of the thread that caused
// the exception (ThreadId), the exception record for the exception
// (ExceptionRecord) and an RVA to the thread context where the exception
// occured.
//

typedef struct MINIDUMP_EXCEPTION_STREAM {
    ULONG32 ThreadId;
    ULONG32  __alignment;
    MINIDUMP_EXCEPTION ExceptionRecord;
    MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
} MINIDUMP_EXCEPTION_STREAM, *PMINIDUMP_EXCEPTION_STREAM;


//
// The MINIDUMP_MODULE contains information about a
// a specific module. It includes the CheckSum and
// the TimeDateStamp for the module so the module
// can be reloaded during the analysis phase.
//

typedef struct _MINIDUMP_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
    VS_FIXEDFILEINFO VersionInfo;
    MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
    MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
    ULONG64 Reserved0;                          // Reserved for future use.
    ULONG64 Reserved1;                          // Reserved for future use.
} MINIDUMP_MODULE, *PMINIDUMP_MODULE;   


//
// The minidump module list is a container for modules.
//

typedef struct _MINIDUMP_MODULE_LIST {
    ULONG32 NumberOfModules;
    MINIDUMP_MODULE Modules [ 0 ];
} MINIDUMP_MODULE_LIST, *PMINIDUMP_MODULE_LIST;


//
// Memory Ranges
//

typedef struct _MINIDUMP_MEMORY_LIST {
    ULONG32 NumberOfMemoryRanges;
    MINIDUMP_MEMORY_DESCRIPTOR MemoryRanges [0];
} MINIDUMP_MEMORY_LIST, *PMINIDUMP_MEMORY_LIST;

typedef struct _MINIDUMP_MEMORY64_LIST {
    ULONG64 NumberOfMemoryRanges;
    RVA64 BaseRva;
    MINIDUMP_MEMORY_DESCRIPTOR64 MemoryRanges [0];
} MINIDUMP_MEMORY64_LIST, *PMINIDUMP_MEMORY64_LIST;


//
// Support for user supplied exception information.
//

typedef struct _MINIDUMP_EXCEPTION_INFORMATION {
    DWORD ThreadId;
    PEXCEPTION_POINTERS ExceptionPointers;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION, *PMINIDUMP_EXCEPTION_INFORMATION;

typedef struct _MINIDUMP_EXCEPTION_INFORMATION64 {
    DWORD ThreadId;
    ULONG64 ExceptionRecord;
    ULONG64 ContextRecord;
    BOOL ClientPointers;
} MINIDUMP_EXCEPTION_INFORMATION64, *PMINIDUMP_EXCEPTION_INFORMATION64;


//
// Support for capturing system handle state at the time of the dump.
//

// Per-handle object information varies according to
// the OS, the OS version, the processor type and
// so on.  The minidump gives a minidump identifier
// to each possible data format for identification
// purposes but does not control nor describe the actual data.
typedef enum _MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE {
    MiniHandleObjectInformationNone,
    MiniThreadInformation1,
    MiniMutantInformation1,
    MiniMutantInformation2,
    MiniProcessInformation1,
    MiniProcessInformation2,
    MiniHandleObjectInformationTypeMax
} MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE;

typedef struct _MINIDUMP_HANDLE_OBJECT_INFORMATION {
    RVA NextInfoRva;
    ULONG32 InfoType;
    ULONG32 SizeOfInfo;
    // Raw information follows.
} MINIDUMP_HANDLE_OBJECT_INFORMATION;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
} MINIDUMP_HANDLE_DESCRIPTOR, *PMINIDUMP_HANDLE_DESCRIPTOR;

typedef struct _MINIDUMP_HANDLE_DESCRIPTOR_2 {
    ULONG64 Handle;
    RVA TypeNameRva;
    RVA ObjectNameRva;
    ULONG32 Attributes;
    ULONG32 GrantedAccess;
    ULONG32 HandleCount;
    ULONG32 PointerCount;
    RVA ObjectInfoRva;
    ULONG32 Reserved0;
} MINIDUMP_HANDLE_DESCRIPTOR_2, *PMINIDUMP_HANDLE_DESCRIPTOR_2;

// The latest MINIDUMP_HANDLE_DESCRIPTOR definition.
typedef MINIDUMP_HANDLE_DESCRIPTOR_2 MINIDUMP_HANDLE_DESCRIPTOR_N;
typedef MINIDUMP_HANDLE_DESCRIPTOR_N *PMINIDUMP_HANDLE_DESCRIPTOR_N;

typedef struct _MINIDUMP_HANDLE_DATA_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 NumberOfDescriptors;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_DATA_STREAM, *PMINIDUMP_HANDLE_DATA_STREAM;

// Some operating systems can track the last operations
// performed on a handle.  For example, Application Verifier
// can enable this for some versions of Windows.  The
// handle operation list collects handle operations
// known for the dump target.
// Each entry is an AVRF_HANDLE_OPERATION.
typedef struct _MINIDUMP_HANDLE_OPERATION_LIST {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
    ULONG32 Reserved;
} MINIDUMP_HANDLE_OPERATION_LIST, *PMINIDUMP_HANDLE_OPERATION_LIST;


//
// Support for capturing dynamic function table state at the time of the dump.
//

typedef struct _MINIDUMP_FUNCTION_TABLE_DESCRIPTOR {
    ULONG64 MinimumAddress;
    ULONG64 MaximumAddress;
    ULONG64 BaseAddress;
    ULONG32 EntryCount;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_DESCRIPTOR, *PMINIDUMP_FUNCTION_TABLE_DESCRIPTOR;

typedef struct _MINIDUMP_FUNCTION_TABLE_STREAM {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfDescriptor;
    ULONG32 SizeOfNativeDescriptor;
    ULONG32 SizeOfFunctionEntry;
    ULONG32 NumberOfDescriptors;
    ULONG32 SizeOfAlignPad;
} MINIDUMP_FUNCTION_TABLE_STREAM, *PMINIDUMP_FUNCTION_TABLE_STREAM;


//
// The MINIDUMP_UNLOADED_MODULE contains information about a
// a specific module that was previously loaded but no
// longer is.  This can help with diagnosing problems where
// callers attempt to call code that is no longer loaded.
//

typedef struct _MINIDUMP_UNLOADED_MODULE {
    ULONG64 BaseOfImage;
    ULONG32 SizeOfImage;
    ULONG32 CheckSum;
    ULONG32 TimeDateStamp;
    RVA ModuleNameRva;
} MINIDUMP_UNLOADED_MODULE, *PMINIDUMP_UNLOADED_MODULE;


//
// The minidump unloaded module list is a container for unloaded modules.
//

typedef struct _MINIDUMP_UNLOADED_MODULE_LIST {
    ULONG32 SizeOfHeader;
    ULONG32 SizeOfEntry;
    ULONG32 NumberOfEntries;
} MINIDUMP_UNLOADED_MODULE_LIST, *PMINIDUMP_UNLOADED_MODULE_LIST;


//
// The miscellaneous information stream contains a variety
// of small pieces of information.  A member is valid if
// it's within the available size and its corresponding
// bit is set.
//

#define MINIDUMP_MISC1_PROCESS_ID            0x00000001
#define MINIDUMP_MISC1_PROCESS_TIMES         0x00000002
#define MINIDUMP_MISC1_PROCESSOR_POWER_INFO  0x00000004
#define MINIDUMP_MISC3_PROCESS_INTEGRITY     0x00000010
#define MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS 0x00000020
#define MINIDUMP_MISC3_TIMEZONE              0x00000040
#define MINIDUMP_MISC3_PROTECTED_PROCESS     0x00000080

typedef struct _MINIDUMP_MISC_INFO {
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
} MINIDUMP_MISC_INFO, *PMINIDUMP_MISC_INFO;

typedef struct _MINIDUMP_MISC_INFO_2 {
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
} MINIDUMP_MISC_INFO_2, *PMINIDUMP_MISC_INFO_2;

typedef struct _MINIDUMP_MISC_INFO_3 {
    ULONG32 SizeOfInfo;
    ULONG32 Flags1;
    ULONG32 ProcessId;
    ULONG32 ProcessCreateTime;
    ULONG32 ProcessUserTime;
    ULONG32 ProcessKernelTime;
    ULONG32 ProcessorMaxMhz;
    ULONG32 ProcessorCurrentMhz;
    ULONG32 ProcessorMhzLimit;
    ULONG32 ProcessorMaxIdleState;
    ULONG32 ProcessorCurrentIdleState;
    ULONG32 ProcessIntegrityLevel;
    ULONG32 ProcessExecuteFlags;
    ULONG32 ProtectedProcess;
    ULONG32 TimeZoneId;
    TIME_ZONE_INFORMATION TimeZone;
} MINIDUMP_MISC_INFO_3, *PMINIDUMP_MISC_INFO_3;

// The latest MINIDUMP_MISC_INFO definition.
typedef MINIDUMP_MISC_INFO_3 MINIDUMP_MISC_INFO_N;
typedef MINIDUMP_MISC_INFO_N* PMINIDUMP_MISC_INFO_N;


//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

typedef struct _MINIDUMP_MEMORY_INFO {
    ULONG64 BaseAddress;
    ULONG64 AllocationBase;
    ULONG32 AllocationProtect;
    ULONG32 __alignment1;
    ULONG64 RegionSize;
    ULONG32 State;
    ULONG32 Protect;
    ULONG32 Type;
    ULONG32 __alignment2;
} MINIDUMP_MEMORY_INFO, *PMINIDUMP_MEMORY_INFO;

typedef struct _MINIDUMP_MEMORY_INFO_LIST {
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG64 NumberOfEntries;
} MINIDUMP_MEMORY_INFO_LIST, *PMINIDUMP_MEMORY_INFO_LIST;

    
//
// The memory information stream contains memory region
// description information.  This stream corresponds to
// what VirtualQuery would return for the process the
// dump was created for.
//

// Thread dump writer status flags.
#define MINIDUMP_THREAD_INFO_ERROR_THREAD    0x00000001
#define MINIDUMP_THREAD_INFO_WRITING_THREAD  0x00000002
#define MINIDUMP_THREAD_INFO_EXITED_THREAD   0x00000004
#define MINIDUMP_THREAD_INFO_INVALID_INFO    0x00000008
#define MINIDUMP_THREAD_INFO_INVALID_CONTEXT 0x00000010
#define MINIDUMP_THREAD_INFO_INVALID_TEB     0x00000020

typedef struct _MINIDUMP_THREAD_INFO {
    ULONG32 ThreadId;
    ULONG32 DumpFlags;
    ULONG32 DumpError;
    ULONG32 ExitStatus;
    ULONG64 CreateTime;
    ULONG64 ExitTime;
    ULONG64 KernelTime;
    ULONG64 UserTime;
    ULONG64 StartAddress;
    ULONG64 Affinity;
} MINIDUMP_THREAD_INFO, *PMINIDUMP_THREAD_INFO;

typedef struct _MINIDUMP_THREAD_INFO_LIST {
    ULONG SizeOfHeader;
    ULONG SizeOfEntry;
    ULONG NumberOfEntries;
} MINIDUMP_THREAD_INFO_LIST, *PMINIDUMP_THREAD_INFO_LIST;

//
// Support for token information.
//
typedef struct _MINIDUMP_TOKEN_INFO_HEADER {
    ULONG   TokenSize;   // The size of the token structure.
    ULONG   TokenId;     // The PID in NtOpenProcessToken() call or TID in NtOpenThreadToken() call.
    ULONG64 TokenHandle; // The handle value returned.
} MINIDUMP_TOKEN_INFO_HEADER, *PMINIDUMP_TOKEN_INFO_HEADER;

typedef struct _MINIDUMP_TOKEN_INFO_LIST {
    ULONG TokenListSize;
    ULONG TokenListEntries;
    ULONG ListHeaderSize;
    ULONG ElementHeaderSize;
} MINIDUMP_TOKEN_INFO_LIST, *PMINIDUMP_TOKEN_INFO_LIST;

//
// Support for arbitrary user-defined information.
//

typedef struct _MINIDUMP_USER_RECORD {
    ULONG32 Type;
    MINIDUMP_LOCATION_DESCRIPTOR Memory;
} MINIDUMP_USER_RECORD, *PMINIDUMP_USER_RECORD;


typedef struct _MINIDUMP_USER_STREAM {
    ULONG32 Type;
    ULONG BufferSize;
    PVOID Buffer;

} MINIDUMP_USER_STREAM, *PMINIDUMP_USER_STREAM;


typedef struct _MINIDUMP_USER_STREAM_INFORMATION {
    ULONG UserStreamCount;
    PMINIDUMP_USER_STREAM UserStreamArray;
} MINIDUMP_USER_STREAM_INFORMATION, *PMINIDUMP_USER_STREAM_INFORMATION;

//
// Callback support.
//

typedef enum _MINIDUMP_CALLBACK_TYPE {
    ModuleCallback,
    ThreadCallback,
    ThreadExCallback,
    IncludeThreadCallback,
    IncludeModuleCallback,
    MemoryCallback,
    CancelCallback,
    WriteKernelMinidumpCallback,
    KernelMinidumpStatusCallback,
    RemoveMemoryCallback,
    IncludeVmRegionCallback,
    IoStartCallback,
    IoWriteAllCallback,
    IoFinishCallback,
    ReadMemoryFailureCallback,
    SecondaryFlagsCallback,
} MINIDUMP_CALLBACK_TYPE;


typedef struct _MINIDUMP_THREAD_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
} MINIDUMP_THREAD_CALLBACK, *PMINIDUMP_THREAD_CALLBACK;


typedef struct _MINIDUMP_THREAD_EX_CALLBACK {
    ULONG ThreadId;
    HANDLE ThreadHandle;
    CONTEXT Context;
    ULONG SizeOfContext;
    ULONG64 StackBase;
    ULONG64 StackEnd;
    ULONG64 BackingStoreBase;
    ULONG64 BackingStoreEnd;
} MINIDUMP_THREAD_EX_CALLBACK, *PMINIDUMP_THREAD_EX_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_THREAD_CALLBACK {
    ULONG ThreadId;
} MINIDUMP_INCLUDE_THREAD_CALLBACK, *PMINIDUMP_INCLUDE_THREAD_CALLBACK;


typedef enum _THREAD_WRITE_FLAGS {
    ThreadWriteThread            = 0x0001,
    ThreadWriteStack             = 0x0002,
    ThreadWriteContext           = 0x0004,
    ThreadWriteBackingStore      = 0x0008,
    ThreadWriteInstructionWindow = 0x0010,
    ThreadWriteThreadData        = 0x0020,
    ThreadWriteThreadInfo        = 0x0040,
} THREAD_WRITE_FLAGS;

typedef struct _MINIDUMP_MODULE_CALLBACK {
    PWCHAR FullPath;
    ULONG64 BaseOfImage;
    ULONG SizeOfImage;
    ULONG CheckSum;
    ULONG TimeDateStamp;
    VS_FIXEDFILEINFO VersionInfo;
    PVOID CvRecord; 
    ULONG SizeOfCvRecord;
    PVOID MiscRecord;
    ULONG SizeOfMiscRecord;
} MINIDUMP_MODULE_CALLBACK, *PMINIDUMP_MODULE_CALLBACK;


typedef struct _MINIDUMP_INCLUDE_MODULE_CALLBACK {
    ULONG64 BaseOfImage;
} MINIDUMP_INCLUDE_MODULE_CALLBACK, *PMINIDUMP_INCLUDE_MODULE_CALLBACK;


typedef enum _MODULE_WRITE_FLAGS {
    ModuleWriteModule        = 0x0001,
    ModuleWriteDataSeg       = 0x0002,
    ModuleWriteMiscRecord    = 0x0004,
    ModuleWriteCvRecord      = 0x0008,
    ModuleReferencedByMemory = 0x0010,
    ModuleWriteTlsData       = 0x0020,
    ModuleWriteCodeSegs      = 0x0040,
} MODULE_WRITE_FLAGS;


typedef struct _MINIDUMP_IO_CALLBACK {
    HANDLE Handle;
    ULONG64 Offset;
    PVOID Buffer;
    ULONG BufferBytes;
} MINIDUMP_IO_CALLBACK, *PMINIDUMP_IO_CALLBACK;


typedef struct _MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
{
    ULONG64 Offset;
    ULONG Bytes;
    HRESULT FailureStatus;
} MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
  *PMINIDUMP_READ_MEMORY_FAILURE_CALLBACK;


typedef struct _MINIDUMP_CALLBACK_INPUT {
    ULONG ProcessId;
    HANDLE ProcessHandle;
    ULONG CallbackType;
    union {
        HRESULT Status;
        MINIDUMP_THREAD_CALLBACK Thread;
        MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
        MINIDUMP_MODULE_CALLBACK Module;
        MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
        MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
        MINIDUMP_IO_CALLBACK Io;
        MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
        ULONG SecondaryFlags;
    };
} MINIDUMP_CALLBACK_INPUT, *PMINIDUMP_CALLBACK_INPUT;

typedef struct _MINIDUMP_CALLBACK_OUTPUT {
    union {
        ULONG ModuleWriteFlags;
        ULONG ThreadWriteFlags;
        ULONG SecondaryFlags;
        struct {
            ULONG64 MemoryBase;
            ULONG MemorySize;
        };
        struct {
            BOOL CheckCancel;
            BOOL Cancel;
        };
        HANDLE Handle;
        struct {
            MINIDUMP_MEMORY_INFO VmRegion;
            BOOL Continue;
        };
        HRESULT Status;
    };
} MINIDUMP_CALLBACK_OUTPUT, *PMINIDUMP_CALLBACK_OUTPUT;

        
//
// A normal minidump contains just the information
// necessary to capture stack traces for all of the
// existing threads in a process.
//
// A minidump with data segments includes all of the data
// sections from loaded modules in order to capture
// global variable contents.  This can make the dump much
// larger if many modules have global data.
//
// A minidump with full memory includes all of the accessible
// memory in the process and can be very large.  A minidump
// with full memory always has the raw memory data at the end
// of the dump so that the initial structures in the dump can
// be mapped directly without having to include the raw
// memory information.
//
// Stack and backing store memory can be filtered to remove
// data unnecessary for stack walking.  This can improve
// compression of stacks and also deletes data that may
// be private and should not be stored in a dump.
// Memory can also be scanned to see what modules are
// referenced by stack and backing store memory to allow
// omission of other modules to reduce dump size.
// In either of these modes the ModuleReferencedByMemory flag
// is set for all modules referenced before the base
// module callbacks occur.
//
// On some operating systems a list of modules that were
// recently unloaded is kept in addition to the currently
// loaded module list.  This information can be saved in
// the dump if desired.
//
// Stack and backing store memory can be scanned for referenced
// pages in order to pick up data referenced by locals or other
// stack memory.  This can increase the size of a dump significantly.
//
// Module paths may contain undesired information such as user names
// or other important directory names so they can be stripped.  This
// option reduces the ability to locate the proper image later
// and should only be used in certain situations.
//
// Complete operating system per-process and per-thread information can
// be gathered and stored in the dump.
//
// The virtual address space can be scanned for various types
// of memory to be included in the dump.
//
// Code which is concerned with potentially private information
// getting into the minidump can set a flag that automatically
// modifies all existing and future flags to avoid placing
// unnecessary data in the dump.  Basic data, such as stack
// information, will still be included but optional data, such
// as indirect memory, will not.
//
// When doing a full memory dump it's possible to store all
// of the enumerated memory region descriptive information
// in a memory information stream.
//
// Additional thread information beyond the basic thread
// structure can be collected if desired.
//
// A minidump with code segments includes all of the code
// and code-related sections from loaded modules in order
// to capture executable content.
//
// MiniDumpWithoutAuxiliaryState turns off any secondary,
// auxiliary-supported memory gathering.
//
// MiniDumpWithFullAuxiliaryState asks any present auxiliary
// data providers to include all of their state in the dump.
// The exact set of what is provided depends on the auxiliary.
// This can be quite large.
//

typedef enum _MINIDUMP_TYPE {
    MiniDumpNormal                         = 0x00000000,
    MiniDumpWithDataSegs                   = 0x00000001,
    MiniDumpWithFullMemory                 = 0x00000002,
    MiniDumpWithHandleData                 = 0x00000004,
    MiniDumpFilterMemory                   = 0x00000008,
    MiniDumpScanMemory                     = 0x00000010,
    MiniDumpWithUnloadedModules            = 0x00000020,
    MiniDumpWithIndirectlyReferencedMemory = 0x00000040,
    MiniDumpFilterModulePaths              = 0x00000080,
    MiniDumpWithProcessThreadData          = 0x00000100,
    MiniDumpWithPrivateReadWriteMemory     = 0x00000200,
    MiniDumpWithoutOptionalData            = 0x00000400,
    MiniDumpWithFullMemoryInfo             = 0x00000800,
    MiniDumpWithThreadInfo                 = 0x00001000,
    MiniDumpWithCodeSegs                   = 0x00002000,
    MiniDumpWithoutAuxiliaryState          = 0x00004000,
    MiniDumpWithFullAuxiliaryState         = 0x00008000,
    MiniDumpWithPrivateWriteCopyMemory     = 0x00010000,
    MiniDumpIgnoreInaccessibleMemory       = 0x00020000,
    MiniDumpWithTokenInformation           = 0x00040000,
    MiniDumpValidTypeFlags                 = 0x0007ffff,
} MINIDUMP_TYPE;

//
// In addition to the primary flags provided to
// MiniDumpWriteDump there are additional, less
// frequently used options queried via the secondary
// flags callback.
//
// MiniSecondaryWithoutPowerInfo suppresses the minidump
// query that retrieves processor power information for
// MINIDUMP_MISC_INFO.
//
    
typedef enum _MINIDUMP_SECONDARY_FLAGS {
    MiniSecondaryWithoutPowerInfo = 0x00000001,

    MiniSecondaryValidFlags       = 0x00000001,
} MINIDUMP_SECONDARY_FLAGS;


//
// The minidump callback should modify the FieldsToWrite parameter to reflect
// what portions of the specified thread or module should be written to the
// file.
//

typedef
BOOL
(WINAPI * MINIDUMP_CALLBACK_ROUTINE) (
    __inout PVOID CallbackParam,
    __in    PMINIDUMP_CALLBACK_INPUT CallbackInput,
    __inout PMINIDUMP_CALLBACK_OUTPUT CallbackOutput
    );

typedef struct _MINIDUMP_CALLBACK_INFORMATION {
    MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
    PVOID CallbackParam;
} MINIDUMP_CALLBACK_INFORMATION, *PMINIDUMP_CALLBACK_INFORMATION;



//++
//
// PVOID
// RVA_TO_ADDR(
//     PVOID Mapping,
//     ULONG Rva
//     )
//
// Routine Description:
//
//     Map an RVA that is contained within a mapped file to it's associated
//     flat address.
//
// Arguments:
//
//     Mapping - Base address of mapped file containing the RVA.
//
//     Rva - An Rva to fixup.
//
// Return Values:
//
//     A pointer to the desired data.
//
//--

#define RVA_TO_ADDR(Mapping,Rva) ((PVOID)(((ULONG_PTR) (Mapping)) + (Rva)))

BOOL
WINAPI
MiniDumpWriteDump(
    __in HANDLE hProcess,
    __in DWORD ProcessId,
    __in HANDLE hFile,
    __in MINIDUMP_TYPE DumpType,
    __in_opt PMINIDUMP_EXCEPTION_INFORMATION ExceptionParam,
    __in_opt PMINIDUMP_USER_STREAM_INFORMATION UserStreamParam,
    __in_opt PMINIDUMP_CALLBACK_INFORMATION CallbackParam
    );

BOOL
WINAPI
MiniDumpReadDumpStream(
    __in PVOID BaseOfDump,
    __in ULONG StreamNumber,
    __deref_out_opt PMINIDUMP_DIRECTORY * Dir,
    __deref_out_opt PVOID * StreamPointer,
    __out_opt ULONG * StreamSize
    );

#if defined(_MSC_VER)
#if _MSC_VER >= 800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4200)    /* Zero length array */
#pragma warning(default:4201)    /* Nameless struct/union */
#endif
#endif
#endif

#include <poppack.h>

#ifdef __cplusplus
}
#endif


#endif // _IMAGEHLP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\imapi2error.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
Copyright (c) Microsoft Corporation. All rights reserved.
--*/

#ifndef _IMAPI2ERROR_
#define _IMAPI2ERROR_


//
// Error Messages used throughout IMAPIv2
// Range: 0x80AA0000 - 0x80AA00FF
//

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: E_IMAPI_REQUEST_CANCELLED
//
// MessageText:
//
// The request was cancelled.
//
#define E_IMAPI_REQUEST_CANCELLED        ((HRESULT)0xC0AA0002L)

//
// MessageId: E_IMAPI_RECORDER_REQUIRED
//
// MessageText:
//
// The request requires a current disc recorder to be selected.
//
#define E_IMAPI_RECORDER_REQUIRED        ((HRESULT)0xC0AA0003L)

//
// MessageId: S_IMAPI_SPEEDADJUSTED
//
// MessageText:
//
// The requested write speed was not supported by the drive and the speed was adjusted.
//
#define S_IMAPI_SPEEDADJUSTED            ((HRESULT)0x00AA0004L)

//
// MessageId: S_IMAPI_ROTATIONADJUSTED
//
// MessageText:
//
// The requested rotation type was not supported by the drive and the rotation type was adjusted.
//
#define S_IMAPI_ROTATIONADJUSTED         ((HRESULT)0x00AA0005L)

//
// MessageId: S_IMAPI_BOTHADJUSTED
//
// MessageText:
//
// The requested write speed and rotation type were not supported by the drive and they were both adjusted.
//
#define S_IMAPI_BOTHADJUSTED             ((HRESULT)0x00AA0006L)

//
// MessageId: E_IMAPI_BURN_VERIFICATION_FAILED
//
// MessageText:
//
// The disc did not pass burn verification and may contain corrupt data or be unusable. 
//
#define E_IMAPI_BURN_VERIFICATION_FAILED ((HRESULT)0xC0AA0007L)


//
// Error Messages for IDiscMaster2
// Range: 0x80AA0100 - 0x80AA01FF
//


//
// Error Messages for IDiscRecorder2
// Range: 0x80AA0200 - 0x80AA02FF
//

//
// MessageId: S_IMAPI_COMMAND_HAS_SENSE_DATA
//
// MessageText:
//
// The device accepted the command, but returned sense data, indicating an error.
//
#define S_IMAPI_COMMAND_HAS_SENSE_DATA   ((HRESULT)0x00AA0200L)

//
// MessageId: E_IMAPI_RECORDER_NO_SUCH_MODE_PAGE
//
// MessageText:
//
// The device reported that the requested mode page (and type) is not present.
//
#define E_IMAPI_RECORDER_NO_SUCH_MODE_PAGE ((HRESULT)0xC0AA0201L)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_NO_MEDIA
//
// MessageText:
//
// There is no media in the device.
//
#define E_IMAPI_RECORDER_MEDIA_NO_MEDIA  ((HRESULT)0xC0AA0202L)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_INCOMPATIBLE
//
// MessageText:
//
// The media is not compatible or of unknown physical format.
//
#define E_IMAPI_RECORDER_MEDIA_INCOMPATIBLE ((HRESULT)0xC0AA0203L)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_UPSIDE_DOWN
//
// MessageText:
//
// The media is inserted upside down.
//
#define E_IMAPI_RECORDER_MEDIA_UPSIDE_DOWN ((HRESULT)0xC0AA0204L)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_BECOMING_READY
//
// MessageText:
//
// The drive reported that it is in the process of becoming ready.  Please try the request again later.
//
#define E_IMAPI_RECORDER_MEDIA_BECOMING_READY ((HRESULT)0xC0AA0205L)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_FORMAT_IN_PROGRESS
//
// MessageText:
//
// The media is currently being formatted.  Please wait for the format to complete before attempting to use the media.
//
#define E_IMAPI_RECORDER_MEDIA_FORMAT_IN_PROGRESS ((HRESULT)0xC0AA0206L)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_BUSY
//
// MessageText:
//
// The drive reported that it is performing a long-running operation, such as finishing a write.  The drive may be unusable for a long period of time.
//
#define E_IMAPI_RECORDER_MEDIA_BUSY      ((HRESULT)0xC0AA0207L)

//
// MessageId: E_IMAPI_RECORDER_INVALID_MODE_PARAMETERS
//
// MessageText:
//
// The drive reported that the combination of parameters provided in the mode page for a MODE SELECT command were not supported.
//
#define E_IMAPI_RECORDER_INVALID_MODE_PARAMETERS ((HRESULT)0xC0AA0208L)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_WRITE_PROTECTED
//
// MessageText:
//
// The drive reported that the media is write protected.
//
#define E_IMAPI_RECORDER_MEDIA_WRITE_PROTECTED ((HRESULT)0xC0AA0209L)

//
// MessageId: E_IMAPI_RECORDER_NO_SUCH_FEATURE
//
// MessageText:
//
// The feature page requested is not supported by the device.
//
#define E_IMAPI_RECORDER_NO_SUCH_FEATURE ((HRESULT)0xC0AA020AL)

//
// MessageId: E_IMAPI_RECORDER_FEATURE_IS_NOT_CURRENT
//
// MessageText:
//
// The feature page requested is supported, but is not marked as current.
//
#define E_IMAPI_RECORDER_FEATURE_IS_NOT_CURRENT ((HRESULT)0xC0AA020BL)

//
// MessageId: E_IMAPI_RECORDER_GET_CONFIGURATION_NOT_SUPPORTED
//
// MessageText:
//
// The drive does not support the GET CONFIGURATION command.
//
#define E_IMAPI_RECORDER_GET_CONFIGURATION_NOT_SUPPORTED ((HRESULT)0xC0AA020CL)

//
// MessageId: E_IMAPI_RECORDER_COMMAND_TIMEOUT
//
// MessageText:
//
// The device failed to accept the command within the timeout period. This may be caused by the device having entered an inconsistent state, or the timeout value for the command may need to be increased.
//
#define E_IMAPI_RECORDER_COMMAND_TIMEOUT ((HRESULT)0xC0AA020DL)

//
// MessageId: E_IMAPI_RECORDER_DVD_STRUCTURE_NOT_PRESENT
//
// MessageText:
//
// The device failed to accept the command within the timeout period. This may be caused by the device having entered an inconsistent state, or the timeout value for the command may need to be increased.
//
#define E_IMAPI_RECORDER_DVD_STRUCTURE_NOT_PRESENT ((HRESULT)0xC0AA020EL)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_SPEED_MISMATCH
//
// MessageText:
//
// The media's speed is incompatible with the device.  This may be caused by using higher or lower speed media than the range of speeds supported by the device.
//
#define E_IMAPI_RECORDER_MEDIA_SPEED_MISMATCH ((HRESULT)0xC0AA020FL)

//
// MessageId: E_IMAPI_RECORDER_LOCKED
//
// MessageText:
//
// The device associated with this recorder during the last operation has been exclusively locked, causing this operation to failed.
//
#define E_IMAPI_RECORDER_LOCKED          ((HRESULT)0xC0AA0210L)

//
// MessageId: E_IMAPI_RECORDER_CLIENT_NAME_IS_NOT_VALID
//
// MessageText:
//
// The client name is not valid.
//
#define E_IMAPI_RECORDER_CLIENT_NAME_IS_NOT_VALID ((HRESULT)0xC0AA0211L)

//
// MessageId: E_IMAPI_RECORDER_MEDIA_NOT_FORMATTED
//
// MessageText:
//
// The media is not formatted. Please format the media before attempting to use it.
//
#define E_IMAPI_RECORDER_MEDIA_NOT_FORMATTED ((HRESULT)0xC0AA0212L)

//
// MessageId: E_IMAPI_RECORDER_INVALID_RESPONSE_FROM_DEVICE
//
// MessageText:
//
// The device reported unexpected or invalid data for a command.
//
#define E_IMAPI_RECORDER_INVALID_RESPONSE_FROM_DEVICE ((HRESULT)0xC0AA02FFL)


//
// Error Messages for IWriteEngine2
// Range: 0x80AA0300 - 0x80AA03FF
//

//
// MessageId: E_IMAPI_LOSS_OF_STREAMING
//
// MessageText:
//
// The write failed because the drive did not receive data quickly enough to continue writing. Moving the source data to the local computer, reducing the write speed, or enabling a "buffer underrun free" setting may resolve this issue.
//
#define E_IMAPI_LOSS_OF_STREAMING        ((HRESULT)0xC0AA0300L)

//
// MessageId: E_IMAPI_UNEXPECTED_RESPONSE_FROM_DEVICE
//
// MessageText:
//
// The write failed because the drive returned error information that could not be recovered from.
//
#define E_IMAPI_UNEXPECTED_RESPONSE_FROM_DEVICE ((HRESULT)0xC0AA0301L)

//
// MessageId: S_IMAPI_WRITE_NOT_IN_PROGRESS
//
// MessageText:
//
// There is no write operation currently in progress.
//
#define S_IMAPI_WRITE_NOT_IN_PROGRESS    ((HRESULT)0x00AA0302L)


//
// Error Messages for IDiscFormat2Data
// Range: 0x80AA0400 - 0x80AA04FF
//

//
// MessageId: E_IMAPI_DF2DATA_WRITE_IN_PROGRESS
//
// MessageText:
//
// There is currently a write operation in progress.
//
#define E_IMAPI_DF2DATA_WRITE_IN_PROGRESS ((HRESULT)0xC0AA0400L)

//
// MessageId: E_IMAPI_DF2DATA_WRITE_NOT_IN_PROGRESS
//
// MessageText:
//
// There is no write operation currently in progress.
//
#define E_IMAPI_DF2DATA_WRITE_NOT_IN_PROGRESS ((HRESULT)0xC0AA0401L)

//
// MessageId: E_IMAPI_DF2DATA_INVALID_MEDIA_STATE
//
// MessageText:
//
// The requested operation is only valid with supported media.
//
#define E_IMAPI_DF2DATA_INVALID_MEDIA_STATE ((HRESULT)0xC0AA0402L)

//
// MessageId: E_IMAPI_DF2DATA_STREAM_NOT_SUPPORTED
//
// MessageText:
//
// The provided stream to write is not supported.
//
#define E_IMAPI_DF2DATA_STREAM_NOT_SUPPORTED ((HRESULT)0xC0AA0403L)

//
// MessageId: E_IMAPI_DF2DATA_STREAM_TOO_LARGE_FOR_CURRENT_MEDIA
//
// MessageText:
//
// The provided stream to write is too large for the currently inserted media.
//
#define E_IMAPI_DF2DATA_STREAM_TOO_LARGE_FOR_CURRENT_MEDIA ((HRESULT)0xC0AA0404L)

//
// MessageId: E_IMAPI_DF2DATA_MEDIA_NOT_BLANK
//
// MessageText:
//
// Overwriting non-blank media is not allowed without the ForceOverwrite property set to VARIANT_TRUE.
//
#define E_IMAPI_DF2DATA_MEDIA_NOT_BLANK  ((HRESULT)0xC0AA0405L)

//
// MessageId: E_IMAPI_DF2DATA_MEDIA_IS_NOT_SUPPORTED
//
// MessageText:
//
// The current media type is unsupported.
//
#define E_IMAPI_DF2DATA_MEDIA_IS_NOT_SUPPORTED ((HRESULT)0xC0AA0406L)

//
// MessageId: E_IMAPI_DF2DATA_RECORDER_NOT_SUPPORTED
//
// MessageText:
//
// This device does not support the operations required by this disc format.
//
#define E_IMAPI_DF2DATA_RECORDER_NOT_SUPPORTED ((HRESULT)0xC0AA0407L)

//
// MessageId: E_IMAPI_DF2DATA_CLIENT_NAME_IS_NOT_VALID
//
// MessageText:
//
// The client name is not valid.
//
#define E_IMAPI_DF2DATA_CLIENT_NAME_IS_NOT_VALID ((HRESULT)0xC0AA0408L)


//
// Error Messages for IDiscFormat2TrackAtOnce
// Range: 0x80AA0500 - 0x80AA05FF
//

//
// MessageId: E_IMAPI_DF2TAO_WRITE_IN_PROGRESS
//
// MessageText:
//
// There is currently a write operation in progress.
//
#define E_IMAPI_DF2TAO_WRITE_IN_PROGRESS ((HRESULT)0xC0AA0500L)

//
// MessageId: E_IMAPI_DF2TAO_WRITE_NOT_IN_PROGRESS
//
// MessageText:
//
// There is no write operation currently in progress.
//
#define E_IMAPI_DF2TAO_WRITE_NOT_IN_PROGRESS ((HRESULT)0xC0AA0501L)

//
// MessageId: E_IMAPI_DF2TAO_MEDIA_IS_NOT_PREPARED
//
// MessageText:
//
// The requested operation is only valid when media has been "prepared".
//
#define E_IMAPI_DF2TAO_MEDIA_IS_NOT_PREPARED ((HRESULT)0xC0AA0502L)

//
// MessageId: E_IMAPI_DF2TAO_MEDIA_IS_PREPARED
//
// MessageText:
//
// The requested operation is not valid when media has been "prepared" but not released.
//
#define E_IMAPI_DF2TAO_MEDIA_IS_PREPARED ((HRESULT)0xC0AA0503L)

//
// MessageId: E_IMAPI_DF2TAO_PROPERTY_FOR_BLANK_MEDIA_ONLY
//
// MessageText:
//
// The property cannot be changed once the media has been written to.
//
#define E_IMAPI_DF2TAO_PROPERTY_FOR_BLANK_MEDIA_ONLY ((HRESULT)0xC0AA0504L)

//
// MessageId: E_IMAPI_DF2TAO_TABLE_OF_CONTENTS_EMPTY_DISC
//
// MessageText:
//
// The table of contents cannot be retrieved from an empty disc.
//
#define E_IMAPI_DF2TAO_TABLE_OF_CONTENTS_EMPTY_DISC ((HRESULT)0xC0AA0505L)

//
// MessageId: E_IMAPI_DF2TAO_MEDIA_IS_NOT_BLANK
//
// MessageText:
//
// Only blank CD-R/RW media is supported.
//
#define E_IMAPI_DF2TAO_MEDIA_IS_NOT_BLANK ((HRESULT)0xC0AA0506L)

//
// MessageId: E_IMAPI_DF2TAO_MEDIA_IS_NOT_SUPPORTED
//
// MessageText:
//
// Only blank CD-R/RW media is supported.
//
#define E_IMAPI_DF2TAO_MEDIA_IS_NOT_SUPPORTED ((HRESULT)0xC0AA0507L)

//
// MessageId: E_IMAPI_DF2TAO_TRACK_LIMIT_REACHED
//
// MessageText:
//
// CD-R and CD-RW media support a maximum of 99 audio tracks.
//
#define E_IMAPI_DF2TAO_TRACK_LIMIT_REACHED ((HRESULT)0xC0AA0508L)

//
// MessageId: E_IMAPI_DF2TAO_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough space left on the media to add the provided audio track.
//
#define E_IMAPI_DF2TAO_NOT_ENOUGH_SPACE  ((HRESULT)0xC0AA0509L)

//
// MessageId: E_IMAPI_DF2TAO_NO_RECORDER_SPECIFIED
//
// MessageText:
//
// You cannot prepare the media until you choose a recorder to use.
//
#define E_IMAPI_DF2TAO_NO_RECORDER_SPECIFIED ((HRESULT)0xC0AA050AL)

//
// MessageId: E_IMAPI_DF2TAO_INVALID_ISRC
//
// MessageText:
//
// The ISRC provided is not valid.
//
#define E_IMAPI_DF2TAO_INVALID_ISRC      ((HRESULT)0xC0AA050BL)

//
// MessageId: E_IMAPI_DF2TAO_INVALID_MCN
//
// MessageText:
//
// The Media Catalog Number provided is not valid.
//
#define E_IMAPI_DF2TAO_INVALID_MCN       ((HRESULT)0xC0AA050CL)

//
// MessageId: E_IMAPI_DF2TAO_STREAM_NOT_SUPPORTED
//
// MessageText:
//
// The provided audio stream is not valid.
//
#define E_IMAPI_DF2TAO_STREAM_NOT_SUPPORTED ((HRESULT)0xC0AA050DL)

//
// MessageId: E_IMAPI_DF2TAO_RECORDER_NOT_SUPPORTED
//
// MessageText:
//
// This device does not support the operations required by this disc format.
//
#define E_IMAPI_DF2TAO_RECORDER_NOT_SUPPORTED ((HRESULT)0xC0AA050EL)

//
// MessageId: E_IMAPI_DF2TAO_CLIENT_NAME_IS_NOT_VALID
//
// MessageText:
//
// The client name is not valid.
//
#define E_IMAPI_DF2TAO_CLIENT_NAME_IS_NOT_VALID ((HRESULT)0xC0AA050FL)


//
// Error Messages for IDiscFormat2RawCD
// Range: 0x80AA0600 - 0x80AA06FF
//
// 0x0605, 0x0608, 0x060B, 0x060C are not used

//
// MessageId: E_IMAPI_DF2RAW_WRITE_IN_PROGRESS
//
// MessageText:
//
// There is currently a write operation in progress.
//
#define E_IMAPI_DF2RAW_WRITE_IN_PROGRESS ((HRESULT)0xC0AA0600L)

//
// MessageId: E_IMAPI_DF2RAW_WRITE_NOT_IN_PROGRESS
//
// MessageText:
//
// There is no write operation currently in progress.
//
#define E_IMAPI_DF2RAW_WRITE_NOT_IN_PROGRESS ((HRESULT)0xC0AA0601L)

//
// MessageId: E_IMAPI_DF2RAW_MEDIA_IS_NOT_PREPARED
//
// MessageText:
//
// The requested operation is only valid when media has been "prepared".
//
#define E_IMAPI_DF2RAW_MEDIA_IS_NOT_PREPARED ((HRESULT)0xC0AA0602L)

//
// MessageId: E_IMAPI_DF2RAW_MEDIA_IS_PREPARED
//
// MessageText:
//
// The requested operation is not valid when media has been "prepared" but not released.
//
#define E_IMAPI_DF2RAW_MEDIA_IS_PREPARED ((HRESULT)0xC0AA0603L)

//
// MessageId: E_IMAPI_DF2RAW_CLIENT_NAME_IS_NOT_VALID
//
// MessageText:
//
// The client name is not valid.
//
#define E_IMAPI_DF2RAW_CLIENT_NAME_IS_NOT_VALID ((HRESULT)0xC0AA0604L)

//
// MessageId: E_IMAPI_DF2RAW_MEDIA_IS_NOT_BLANK
//
// MessageText:
//
// Only blank CD-R/RW media is supported.
//
#define E_IMAPI_DF2RAW_MEDIA_IS_NOT_BLANK ((HRESULT)0xC0AA0606L)

//
// MessageId: E_IMAPI_DF2RAW_MEDIA_IS_NOT_SUPPORTED
//
// MessageText:
//
// Only blank CD-R/RW media is supported.
//
#define E_IMAPI_DF2RAW_MEDIA_IS_NOT_SUPPORTED ((HRESULT)0xC0AA0607L)

//
// MessageId: E_IMAPI_DF2RAW_NOT_ENOUGH_SPACE
//
// MessageText:
//
// There is not enough space on the media to add the provided session.
//
#define E_IMAPI_DF2RAW_NOT_ENOUGH_SPACE  ((HRESULT)0xC0AA0609L)

//
// MessageId: E_IMAPI_DF2RAW_NO_RECORDER_SPECIFIED
//
// MessageText:
//
// You cannot prepare the media until you choose a recorder to use.
//
#define E_IMAPI_DF2RAW_NO_RECORDER_SPECIFIED ((HRESULT)0xC0AA060AL)

//
// MessageId: E_IMAPI_DF2RAW_STREAM_NOT_SUPPORTED
//
// MessageText:
//
// The provided audio stream is not valid.
//
#define E_IMAPI_DF2RAW_STREAM_NOT_SUPPORTED ((HRESULT)0xC0AA060DL)

//
// MessageId: E_IMAPI_DF2RAW_DATA_BLOCK_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The requested data block type is not supported by the current device.
//
#define E_IMAPI_DF2RAW_DATA_BLOCK_TYPE_NOT_SUPPORTED ((HRESULT)0xC0AA060EL)

//
// MessageId: E_IMAPI_DF2RAW_STREAM_LEADIN_TOO_SHORT
//
// MessageText:
//
// The stream does not contain a sufficient number of sectors in the leadin for the current media.
//
#define E_IMAPI_DF2RAW_STREAM_LEADIN_TOO_SHORT ((HRESULT)0xC0AA060FL)

//
// MessageId: E_IMAPI_DF2RAW_RECORDER_NOT_SUPPORTED
//
// MessageText:
//
// This device does not support the operations required by this disc format.
//
#define E_IMAPI_DF2RAW_RECORDER_NOT_SUPPORTED ((HRESULT)0xC0AA0610L)


//
// Error Messages for IDiscFormat2Erase
// Range: 0x80AA0900 - 0x80AA09FF
//

//
// MessageId: E_IMAPI_ERASE_RECORDER_IN_USE
//
// MessageText:
//
// The format is currently using the disc recorder for an erase operation.
// Please wait for the erase to complete before attempting to set or clear the
// current disc recorder.
//
#define E_IMAPI_ERASE_RECORDER_IN_USE    ((HRESULT)0x80AA0900L)

//
// MessageId: E_IMAPI_ERASE_ONLY_ONE_RECORDER_SUPPORTED
//
// MessageText:
//
// The erase format only supports one recorder.  You must clear the current
// recorder before setting a new one.
//
#define E_IMAPI_ERASE_ONLY_ONE_RECORDER_SUPPORTED ((HRESULT)0x80AA0901L)

//
// MessageId: E_IMAPI_ERASE_DISC_INFORMATION_TOO_SMALL
//
// MessageText:
//
// The drive did not report sufficient data for a READ DISC INFORMATION command.
// The drive may not be supported, or the media may not be correct.
//
#define E_IMAPI_ERASE_DISC_INFORMATION_TOO_SMALL ((HRESULT)0x80AA0902L)

//
// MessageId: E_IMAPI_ERASE_MODE_PAGE_2A_TOO_SMALL
//
// MessageText:
//
// The drive did not report sufficient data for a MODE SENSE (page 0x2A) command.
// The drive may not be supported, or the media may not be correct.
//
#define E_IMAPI_ERASE_MODE_PAGE_2A_TOO_SMALL ((HRESULT)0x80AA0903L)

//
// MessageId: E_IMAPI_ERASE_MEDIA_IS_NOT_ERASABLE
//
// MessageText:
//
// The drive reported that the media is not erasable.
//
#define E_IMAPI_ERASE_MEDIA_IS_NOT_ERASABLE ((HRESULT)0x80AA0904L)

//
// MessageId: E_IMAPI_ERASE_DRIVE_FAILED_ERASE_COMMAND
//
// MessageText:
//
// The drive failed the erase command.
//
#define E_IMAPI_ERASE_DRIVE_FAILED_ERASE_COMMAND ((HRESULT)0x80AA0905L)

//
// MessageId: E_IMAPI_ERASE_TOOK_LONGER_THAN_ONE_HOUR
//
// MessageText:
//
// The drive did not complete the erase in one hour.  The drive may require a power cycle, media removal, or other manual intervention to resume proper operation.
//
#define E_IMAPI_ERASE_TOOK_LONGER_THAN_ONE_HOUR ((HRESULT)0x80AA0906L)

//
// MessageId: E_IMAPI_ERASE_UNEXPECTED_DRIVE_RESPONSE_DURING_ERASE
//
// MessageText:
//
// The drive returned an unexpected error during the erase.  The the media may be
// unusable, the erase may be complete, or the drive may still be in the process
// of erasing the disc.
//
#define E_IMAPI_ERASE_UNEXPECTED_DRIVE_RESPONSE_DURING_ERASE ((HRESULT)0x80AA0907L)

//
// MessageId: E_IMAPI_ERASE_DRIVE_FAILED_SPINUP_COMMAND
//
// MessageText:
//
// The drive returned an error for a START UNIT (spinup) command.  Manual intervention may be required.
//
#define E_IMAPI_ERASE_DRIVE_FAILED_SPINUP_COMMAND ((HRESULT)0x80AA0908L)

//
// MessageId: E_IMAPI_ERASE_MEDIA_IS_NOT_SUPPORTED
//
// MessageText:
//
// The current media type is unsupported.
//
#define E_IMAPI_ERASE_MEDIA_IS_NOT_SUPPORTED ((HRESULT)0xC0AA0909L)

//
// MessageId: E_IMAPI_ERASE_RECORDER_NOT_SUPPORTED
//
// MessageText:
//
// This device does not support the operations required by this disc format.
//
#define E_IMAPI_ERASE_RECORDER_NOT_SUPPORTED ((HRESULT)0xC0AA090AL)

//
// MessageId: E_IMAPI_ERASE_CLIENT_NAME_IS_NOT_VALID
//
// MessageText:
//
// The client name is not valid.
//
#define E_IMAPI_ERASE_CLIENT_NAME_IS_NOT_VALID ((HRESULT)0xC0AA090BL)


//
// Error Messages for IRawCDImageCreator
// Range: 0x80AA0A00 - 0x80AA0AFF
//

//
// MessageId: E_IMAPI_RAW_IMAGE_IS_READ_ONLY
//
// MessageText:
//
// The image has become read-only from a call to CreateResultImage().  
// The object can no longer be modified.
//
#define E_IMAPI_RAW_IMAGE_IS_READ_ONLY   ((HRESULT)0x80AA0A00L)

//
// MessageId: E_IMAPI_RAW_IMAGE_TOO_MANY_TRACKS
//
// MessageText:
//
// No more tracks may be added, as CD media is restricted to track numbers 
// between 1 and 99.
//
#define E_IMAPI_RAW_IMAGE_TOO_MANY_TRACKS ((HRESULT)0x80AA0A01L)

//
// MessageId: E_IMAPI_RAW_IMAGE_SECTOR_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The requested sector type is not supported.
//
#define E_IMAPI_RAW_IMAGE_SECTOR_TYPE_NOT_SUPPORTED ((HRESULT)0x80AA0A02L)

//
// MessageId: E_IMAPI_RAW_IMAGE_NO_TRACKS
//
// MessageText:
//
// Tracks must be added to the image before using this function.
//
#define E_IMAPI_RAW_IMAGE_NO_TRACKS      ((HRESULT)0x80AA0A03L)

//
// MessageId: E_IMAPI_RAW_IMAGE_TRACKS_ALREADY_ADDED
//
// MessageText:
//
// Tracks may not be added to the image prior to the use of this function.
//
#define E_IMAPI_RAW_IMAGE_TRACKS_ALREADY_ADDED ((HRESULT)0x80AA0A04L)

//
// MessageId: E_IMAPI_RAW_IMAGE_INSUFFICIENT_SPACE
//
// MessageText:
//
// Adding the track would result in exceeding the limit for the start of the leadout.
//
#define E_IMAPI_RAW_IMAGE_INSUFFICIENT_SPACE ((HRESULT)0x80AA0A05L)

//
// MessageId: E_IMAPI_RAW_IMAGE_TOO_MANY_TRACK_INDEXES
//
// MessageText:
//
// Adding the track index would result in exceeding the 99 index limit.
//
#define E_IMAPI_RAW_IMAGE_TOO_MANY_TRACK_INDEXES ((HRESULT)0x80AA0A06L)

//
// MessageId: E_IMAPI_RAW_IMAGE_TRACK_INDEX_NOT_FOUND
//
// MessageText:
//
// The specified LBA offset is not in the list of track indexes.
//
#define E_IMAPI_RAW_IMAGE_TRACK_INDEX_NOT_FOUND ((HRESULT)0x80AA0A07L)

//
// MessageId: S_IMAPI_RAW_IMAGE_TRACK_INDEX_ALREADY_EXISTS
//
// MessageText:
//
// The specified LBA offset is already in the list of track indexes.
//
#define S_IMAPI_RAW_IMAGE_TRACK_INDEX_ALREADY_EXISTS ((HRESULT)0x00AA0A08L)

//
// MessageId: E_IMAPI_RAW_IMAGE_TRACK_INDEX_OFFSET_ZERO_CANNOT_BE_CLEARED
//
// MessageText:
//
// Index 1 (LBA offset zero) may not be cleared.
//
#define E_IMAPI_RAW_IMAGE_TRACK_INDEX_OFFSET_ZERO_CANNOT_BE_CLEARED ((HRESULT)0x80AA0A09L)

//
// MessageId: E_IMAPI_RAW_IMAGE_TRACK_INDEX_TOO_CLOSE_TO_OTHER_INDEX
//
// MessageText:
//
// Each index must have a minimum size of ten sectors.
//
#define E_IMAPI_RAW_IMAGE_TRACK_INDEX_TOO_CLOSE_TO_OTHER_INDEX ((HRESULT)0x80AA0A0AL)

#endif /* _IMAPI2ERROR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ImageTranscode.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for imagetranscode.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imagetranscode_h__
#define __imagetranscode_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITranscodeImage_FWD_DEFINED__
#define __ITranscodeImage_FWD_DEFINED__
typedef interface ITranscodeImage ITranscodeImage;
#endif 	/* __ITranscodeImage_FWD_DEFINED__ */


#ifndef __ImageTranscode_FWD_DEFINED__
#define __ImageTranscode_FWD_DEFINED__

#ifdef __cplusplus
typedef class ImageTranscode ImageTranscode;
#else
typedef struct ImageTranscode ImageTranscode;
#endif /* __cplusplus */

#endif 	/* __ImageTranscode_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"
#include "propidl.h"
#include "shobjidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __ITranscodeImage_INTERFACE_DEFINED__
#define __ITranscodeImage_INTERFACE_DEFINED__

/* interface ITranscodeImage */
/* [unique][uuid][object] */ 

typedef /* [v1_enum] */ 
enum tagTI_FLAGS
    {	TI_BITMAP	= 1,
	TI_JPEG	= 2
    } 	TI_FLAGS;


EXTERN_C const IID IID_ITranscodeImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BAE86DDD-DC11-421c-B7AB-CC55D1D65C44")
    ITranscodeImage : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TranscodeImage( 
            /* [in] */ __RPC__in_opt IShellItem *pShellItem,
            /* [in] */ UINT uiMaxWidth,
            /* [in] */ UINT uiMaxHeight,
            /* [in] */ DWORD flags,
            /* [in] */ __RPC__in_opt IStream *pvImage,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITranscodeImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITranscodeImage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITranscodeImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITranscodeImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *TranscodeImage )( 
            __RPC__in ITranscodeImage * This,
            /* [in] */ __RPC__in_opt IShellItem *pShellItem,
            /* [in] */ UINT uiMaxWidth,
            /* [in] */ UINT uiMaxHeight,
            /* [in] */ DWORD flags,
            /* [in] */ __RPC__in_opt IStream *pvImage,
            /* [out] */ __RPC__out UINT *puiWidth,
            /* [out] */ __RPC__out UINT *puiHeight);
        
        END_INTERFACE
    } ITranscodeImageVtbl;

    interface ITranscodeImage
    {
        CONST_VTBL struct ITranscodeImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITranscodeImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITranscodeImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITranscodeImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITranscodeImage_TranscodeImage(This,pShellItem,uiMaxWidth,uiMaxHeight,flags,pvImage,puiWidth,puiHeight)	\
    ( (This)->lpVtbl -> TranscodeImage(This,pShellItem,uiMaxWidth,uiMaxHeight,flags,pvImage,puiWidth,puiHeight) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITranscodeImage_INTERFACE_DEFINED__ */



#ifndef __TranscodeLibrary_LIBRARY_DEFINED__
#define __TranscodeLibrary_LIBRARY_DEFINED__

/* library TranscodeLibrary */
/* [version][uuid] */ 


EXTERN_C const IID LIBID_TranscodeLibrary;

EXTERN_C const CLSID CLSID_ImageTranscode;

#ifdef __cplusplus

class DECLSPEC_UUID("17B75166-928F-417d-9685-64AA135565C1")
ImageTranscode;
#endif
#endif /* __TranscodeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\imapi2.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for imapi2.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imapi2_h__
#define __imapi2_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDiscMaster2_FWD_DEFINED__
#define __IDiscMaster2_FWD_DEFINED__
typedef interface IDiscMaster2 IDiscMaster2;
#endif 	/* __IDiscMaster2_FWD_DEFINED__ */


#ifndef __DDiscMaster2Events_FWD_DEFINED__
#define __DDiscMaster2Events_FWD_DEFINED__
typedef interface DDiscMaster2Events DDiscMaster2Events;
#endif 	/* __DDiscMaster2Events_FWD_DEFINED__ */


#ifndef __IDiscRecorder2Ex_FWD_DEFINED__
#define __IDiscRecorder2Ex_FWD_DEFINED__
typedef interface IDiscRecorder2Ex IDiscRecorder2Ex;
#endif 	/* __IDiscRecorder2Ex_FWD_DEFINED__ */


#ifndef __IDiscRecorder2_FWD_DEFINED__
#define __IDiscRecorder2_FWD_DEFINED__
typedef interface IDiscRecorder2 IDiscRecorder2;
#endif 	/* __IDiscRecorder2_FWD_DEFINED__ */


#ifndef __IWriteEngine2_FWD_DEFINED__
#define __IWriteEngine2_FWD_DEFINED__
typedef interface IWriteEngine2 IWriteEngine2;
#endif 	/* __IWriteEngine2_FWD_DEFINED__ */


#ifndef __IWriteEngine2EventArgs_FWD_DEFINED__
#define __IWriteEngine2EventArgs_FWD_DEFINED__
typedef interface IWriteEngine2EventArgs IWriteEngine2EventArgs;
#endif 	/* __IWriteEngine2EventArgs_FWD_DEFINED__ */


#ifndef __DWriteEngine2Events_FWD_DEFINED__
#define __DWriteEngine2Events_FWD_DEFINED__
typedef interface DWriteEngine2Events DWriteEngine2Events;
#endif 	/* __DWriteEngine2Events_FWD_DEFINED__ */


#ifndef __IDiscFormat2_FWD_DEFINED__
#define __IDiscFormat2_FWD_DEFINED__
typedef interface IDiscFormat2 IDiscFormat2;
#endif 	/* __IDiscFormat2_FWD_DEFINED__ */


#ifndef __IDiscFormat2Erase_FWD_DEFINED__
#define __IDiscFormat2Erase_FWD_DEFINED__
typedef interface IDiscFormat2Erase IDiscFormat2Erase;
#endif 	/* __IDiscFormat2Erase_FWD_DEFINED__ */


#ifndef __DDiscFormat2EraseEvents_FWD_DEFINED__
#define __DDiscFormat2EraseEvents_FWD_DEFINED__
typedef interface DDiscFormat2EraseEvents DDiscFormat2EraseEvents;
#endif 	/* __DDiscFormat2EraseEvents_FWD_DEFINED__ */


#ifndef __IDiscFormat2Data_FWD_DEFINED__
#define __IDiscFormat2Data_FWD_DEFINED__
typedef interface IDiscFormat2Data IDiscFormat2Data;
#endif 	/* __IDiscFormat2Data_FWD_DEFINED__ */


#ifndef __DDiscFormat2DataEvents_FWD_DEFINED__
#define __DDiscFormat2DataEvents_FWD_DEFINED__
typedef interface DDiscFormat2DataEvents DDiscFormat2DataEvents;
#endif 	/* __DDiscFormat2DataEvents_FWD_DEFINED__ */


#ifndef __IDiscFormat2DataEventArgs_FWD_DEFINED__
#define __IDiscFormat2DataEventArgs_FWD_DEFINED__
typedef interface IDiscFormat2DataEventArgs IDiscFormat2DataEventArgs;
#endif 	/* __IDiscFormat2DataEventArgs_FWD_DEFINED__ */


#ifndef __IDiscFormat2TrackAtOnce_FWD_DEFINED__
#define __IDiscFormat2TrackAtOnce_FWD_DEFINED__
typedef interface IDiscFormat2TrackAtOnce IDiscFormat2TrackAtOnce;
#endif 	/* __IDiscFormat2TrackAtOnce_FWD_DEFINED__ */


#ifndef __DDiscFormat2TrackAtOnceEvents_FWD_DEFINED__
#define __DDiscFormat2TrackAtOnceEvents_FWD_DEFINED__
typedef interface DDiscFormat2TrackAtOnceEvents DDiscFormat2TrackAtOnceEvents;
#endif 	/* __DDiscFormat2TrackAtOnceEvents_FWD_DEFINED__ */


#ifndef __IDiscFormat2TrackAtOnceEventArgs_FWD_DEFINED__
#define __IDiscFormat2TrackAtOnceEventArgs_FWD_DEFINED__
typedef interface IDiscFormat2TrackAtOnceEventArgs IDiscFormat2TrackAtOnceEventArgs;
#endif 	/* __IDiscFormat2TrackAtOnceEventArgs_FWD_DEFINED__ */


#ifndef __IDiscFormat2RawCD_FWD_DEFINED__
#define __IDiscFormat2RawCD_FWD_DEFINED__
typedef interface IDiscFormat2RawCD IDiscFormat2RawCD;
#endif 	/* __IDiscFormat2RawCD_FWD_DEFINED__ */


#ifndef __DDiscFormat2RawCDEvents_FWD_DEFINED__
#define __DDiscFormat2RawCDEvents_FWD_DEFINED__
typedef interface DDiscFormat2RawCDEvents DDiscFormat2RawCDEvents;
#endif 	/* __DDiscFormat2RawCDEvents_FWD_DEFINED__ */


#ifndef __IDiscFormat2RawCDEventArgs_FWD_DEFINED__
#define __IDiscFormat2RawCDEventArgs_FWD_DEFINED__
typedef interface IDiscFormat2RawCDEventArgs IDiscFormat2RawCDEventArgs;
#endif 	/* __IDiscFormat2RawCDEventArgs_FWD_DEFINED__ */


#ifndef __IBurnVerification_FWD_DEFINED__
#define __IBurnVerification_FWD_DEFINED__
typedef interface IBurnVerification IBurnVerification;
#endif 	/* __IBurnVerification_FWD_DEFINED__ */


#ifndef __IWriteSpeedDescriptor_FWD_DEFINED__
#define __IWriteSpeedDescriptor_FWD_DEFINED__
typedef interface IWriteSpeedDescriptor IWriteSpeedDescriptor;
#endif 	/* __IWriteSpeedDescriptor_FWD_DEFINED__ */


#ifndef __IMultisession_FWD_DEFINED__
#define __IMultisession_FWD_DEFINED__
typedef interface IMultisession IMultisession;
#endif 	/* __IMultisession_FWD_DEFINED__ */


#ifndef __IMultisessionSequential_FWD_DEFINED__
#define __IMultisessionSequential_FWD_DEFINED__
typedef interface IMultisessionSequential IMultisessionSequential;
#endif 	/* __IMultisessionSequential_FWD_DEFINED__ */


#ifndef __IMultisessionSequential2_FWD_DEFINED__
#define __IMultisessionSequential2_FWD_DEFINED__
typedef interface IMultisessionSequential2 IMultisessionSequential2;
#endif 	/* __IMultisessionSequential2_FWD_DEFINED__ */


#ifndef __IMultisessionRandomWrite_FWD_DEFINED__
#define __IMultisessionRandomWrite_FWD_DEFINED__
typedef interface IMultisessionRandomWrite IMultisessionRandomWrite;
#endif 	/* __IMultisessionRandomWrite_FWD_DEFINED__ */


#ifndef __IStreamPseudoRandomBased_FWD_DEFINED__
#define __IStreamPseudoRandomBased_FWD_DEFINED__
typedef interface IStreamPseudoRandomBased IStreamPseudoRandomBased;
#endif 	/* __IStreamPseudoRandomBased_FWD_DEFINED__ */


#ifndef __IStreamConcatenate_FWD_DEFINED__
#define __IStreamConcatenate_FWD_DEFINED__
typedef interface IStreamConcatenate IStreamConcatenate;
#endif 	/* __IStreamConcatenate_FWD_DEFINED__ */


#ifndef __IStreamInterleave_FWD_DEFINED__
#define __IStreamInterleave_FWD_DEFINED__
typedef interface IStreamInterleave IStreamInterleave;
#endif 	/* __IStreamInterleave_FWD_DEFINED__ */


#ifndef __IRawCDImageCreator_FWD_DEFINED__
#define __IRawCDImageCreator_FWD_DEFINED__
typedef interface IRawCDImageCreator IRawCDImageCreator;
#endif 	/* __IRawCDImageCreator_FWD_DEFINED__ */


#ifndef __IRawCDImageTrackInfo_FWD_DEFINED__
#define __IRawCDImageTrackInfo_FWD_DEFINED__
typedef interface IRawCDImageTrackInfo IRawCDImageTrackInfo;
#endif 	/* __IRawCDImageTrackInfo_FWD_DEFINED__ */


#ifndef __IBlockRange_FWD_DEFINED__
#define __IBlockRange_FWD_DEFINED__
typedef interface IBlockRange IBlockRange;
#endif 	/* __IBlockRange_FWD_DEFINED__ */


#ifndef __IBlockRangeList_FWD_DEFINED__
#define __IBlockRangeList_FWD_DEFINED__
typedef interface IBlockRangeList IBlockRangeList;
#endif 	/* __IBlockRangeList_FWD_DEFINED__ */


#ifndef __IWriteEngine2EventArgs_FWD_DEFINED__
#define __IWriteEngine2EventArgs_FWD_DEFINED__
typedef interface IWriteEngine2EventArgs IWriteEngine2EventArgs;
#endif 	/* __IWriteEngine2EventArgs_FWD_DEFINED__ */


#ifndef __IDiscFormat2DataEventArgs_FWD_DEFINED__
#define __IDiscFormat2DataEventArgs_FWD_DEFINED__
typedef interface IDiscFormat2DataEventArgs IDiscFormat2DataEventArgs;
#endif 	/* __IDiscFormat2DataEventArgs_FWD_DEFINED__ */


#ifndef __IDiscFormat2TrackAtOnceEventArgs_FWD_DEFINED__
#define __IDiscFormat2TrackAtOnceEventArgs_FWD_DEFINED__
typedef interface IDiscFormat2TrackAtOnceEventArgs IDiscFormat2TrackAtOnceEventArgs;
#endif 	/* __IDiscFormat2TrackAtOnceEventArgs_FWD_DEFINED__ */


#ifndef __IDiscFormat2RawCDEventArgs_FWD_DEFINED__
#define __IDiscFormat2RawCDEventArgs_FWD_DEFINED__
typedef interface IDiscFormat2RawCDEventArgs IDiscFormat2RawCDEventArgs;
#endif 	/* __IDiscFormat2RawCDEventArgs_FWD_DEFINED__ */


#ifndef __IWriteSpeedDescriptor_FWD_DEFINED__
#define __IWriteSpeedDescriptor_FWD_DEFINED__
typedef interface IWriteSpeedDescriptor IWriteSpeedDescriptor;
#endif 	/* __IWriteSpeedDescriptor_FWD_DEFINED__ */


#ifndef __DDiscMaster2Events_FWD_DEFINED__
#define __DDiscMaster2Events_FWD_DEFINED__
typedef interface DDiscMaster2Events DDiscMaster2Events;
#endif 	/* __DDiscMaster2Events_FWD_DEFINED__ */


#ifndef __DWriteEngine2Events_FWD_DEFINED__
#define __DWriteEngine2Events_FWD_DEFINED__
typedef interface DWriteEngine2Events DWriteEngine2Events;
#endif 	/* __DWriteEngine2Events_FWD_DEFINED__ */


#ifndef __DDiscFormat2EraseEvents_FWD_DEFINED__
#define __DDiscFormat2EraseEvents_FWD_DEFINED__
typedef interface DDiscFormat2EraseEvents DDiscFormat2EraseEvents;
#endif 	/* __DDiscFormat2EraseEvents_FWD_DEFINED__ */


#ifndef __DDiscFormat2DataEvents_FWD_DEFINED__
#define __DDiscFormat2DataEvents_FWD_DEFINED__
typedef interface DDiscFormat2DataEvents DDiscFormat2DataEvents;
#endif 	/* __DDiscFormat2DataEvents_FWD_DEFINED__ */


#ifndef __DDiscFormat2TrackAtOnceEvents_FWD_DEFINED__
#define __DDiscFormat2TrackAtOnceEvents_FWD_DEFINED__
typedef interface DDiscFormat2TrackAtOnceEvents DDiscFormat2TrackAtOnceEvents;
#endif 	/* __DDiscFormat2TrackAtOnceEvents_FWD_DEFINED__ */


#ifndef __DDiscFormat2RawCDEvents_FWD_DEFINED__
#define __DDiscFormat2RawCDEvents_FWD_DEFINED__
typedef interface DDiscFormat2RawCDEvents DDiscFormat2RawCDEvents;
#endif 	/* __DDiscFormat2RawCDEvents_FWD_DEFINED__ */


#ifndef __IRawCDImageCreator_FWD_DEFINED__
#define __IRawCDImageCreator_FWD_DEFINED__
typedef interface IRawCDImageCreator IRawCDImageCreator;
#endif 	/* __IRawCDImageCreator_FWD_DEFINED__ */


#ifndef __IRawCDImageTrackInfo_FWD_DEFINED__
#define __IRawCDImageTrackInfo_FWD_DEFINED__
typedef interface IRawCDImageTrackInfo IRawCDImageTrackInfo;
#endif 	/* __IRawCDImageTrackInfo_FWD_DEFINED__ */


#ifndef __IBurnVerification_FWD_DEFINED__
#define __IBurnVerification_FWD_DEFINED__
typedef interface IBurnVerification IBurnVerification;
#endif 	/* __IBurnVerification_FWD_DEFINED__ */


#ifndef __IBlockRange_FWD_DEFINED__
#define __IBlockRange_FWD_DEFINED__
typedef interface IBlockRange IBlockRange;
#endif 	/* __IBlockRange_FWD_DEFINED__ */


#ifndef __IBlockRangeList_FWD_DEFINED__
#define __IBlockRangeList_FWD_DEFINED__
typedef interface IBlockRangeList IBlockRangeList;
#endif 	/* __IBlockRangeList_FWD_DEFINED__ */


#ifndef __MsftDiscMaster2_FWD_DEFINED__
#define __MsftDiscMaster2_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftDiscMaster2 MsftDiscMaster2;
#else
typedef struct MsftDiscMaster2 MsftDiscMaster2;
#endif /* __cplusplus */

#endif 	/* __MsftDiscMaster2_FWD_DEFINED__ */


#ifndef __MsftDiscRecorder2_FWD_DEFINED__
#define __MsftDiscRecorder2_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftDiscRecorder2 MsftDiscRecorder2;
#else
typedef struct MsftDiscRecorder2 MsftDiscRecorder2;
#endif /* __cplusplus */

#endif 	/* __MsftDiscRecorder2_FWD_DEFINED__ */


#ifndef __MsftWriteEngine2_FWD_DEFINED__
#define __MsftWriteEngine2_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftWriteEngine2 MsftWriteEngine2;
#else
typedef struct MsftWriteEngine2 MsftWriteEngine2;
#endif /* __cplusplus */

#endif 	/* __MsftWriteEngine2_FWD_DEFINED__ */


#ifndef __MsftDiscFormat2Erase_FWD_DEFINED__
#define __MsftDiscFormat2Erase_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftDiscFormat2Erase MsftDiscFormat2Erase;
#else
typedef struct MsftDiscFormat2Erase MsftDiscFormat2Erase;
#endif /* __cplusplus */

#endif 	/* __MsftDiscFormat2Erase_FWD_DEFINED__ */


#ifndef __MsftDiscFormat2Data_FWD_DEFINED__
#define __MsftDiscFormat2Data_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftDiscFormat2Data MsftDiscFormat2Data;
#else
typedef struct MsftDiscFormat2Data MsftDiscFormat2Data;
#endif /* __cplusplus */

#endif 	/* __MsftDiscFormat2Data_FWD_DEFINED__ */


#ifndef __MsftDiscFormat2TrackAtOnce_FWD_DEFINED__
#define __MsftDiscFormat2TrackAtOnce_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftDiscFormat2TrackAtOnce MsftDiscFormat2TrackAtOnce;
#else
typedef struct MsftDiscFormat2TrackAtOnce MsftDiscFormat2TrackAtOnce;
#endif /* __cplusplus */

#endif 	/* __MsftDiscFormat2TrackAtOnce_FWD_DEFINED__ */


#ifndef __MsftDiscFormat2RawCD_FWD_DEFINED__
#define __MsftDiscFormat2RawCD_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftDiscFormat2RawCD MsftDiscFormat2RawCD;
#else
typedef struct MsftDiscFormat2RawCD MsftDiscFormat2RawCD;
#endif /* __cplusplus */

#endif 	/* __MsftDiscFormat2RawCD_FWD_DEFINED__ */


#ifndef __MsftStreamZero_FWD_DEFINED__
#define __MsftStreamZero_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftStreamZero MsftStreamZero;
#else
typedef struct MsftStreamZero MsftStreamZero;
#endif /* __cplusplus */

#endif 	/* __MsftStreamZero_FWD_DEFINED__ */


#ifndef __MsftStreamPrng001_FWD_DEFINED__
#define __MsftStreamPrng001_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftStreamPrng001 MsftStreamPrng001;
#else
typedef struct MsftStreamPrng001 MsftStreamPrng001;
#endif /* __cplusplus */

#endif 	/* __MsftStreamPrng001_FWD_DEFINED__ */


#ifndef __MsftStreamConcatenate_FWD_DEFINED__
#define __MsftStreamConcatenate_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftStreamConcatenate MsftStreamConcatenate;
#else
typedef struct MsftStreamConcatenate MsftStreamConcatenate;
#endif /* __cplusplus */

#endif 	/* __MsftStreamConcatenate_FWD_DEFINED__ */


#ifndef __MsftStreamInterleave_FWD_DEFINED__
#define __MsftStreamInterleave_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftStreamInterleave MsftStreamInterleave;
#else
typedef struct MsftStreamInterleave MsftStreamInterleave;
#endif /* __cplusplus */

#endif 	/* __MsftStreamInterleave_FWD_DEFINED__ */


#ifndef __MsftWriteSpeedDescriptor_FWD_DEFINED__
#define __MsftWriteSpeedDescriptor_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftWriteSpeedDescriptor MsftWriteSpeedDescriptor;
#else
typedef struct MsftWriteSpeedDescriptor MsftWriteSpeedDescriptor;
#endif /* __cplusplus */

#endif 	/* __MsftWriteSpeedDescriptor_FWD_DEFINED__ */


#ifndef __MsftMultisessionSequential_FWD_DEFINED__
#define __MsftMultisessionSequential_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftMultisessionSequential MsftMultisessionSequential;
#else
typedef struct MsftMultisessionSequential MsftMultisessionSequential;
#endif /* __cplusplus */

#endif 	/* __MsftMultisessionSequential_FWD_DEFINED__ */


#ifndef __MsftMultisessionRandomWrite_FWD_DEFINED__
#define __MsftMultisessionRandomWrite_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftMultisessionRandomWrite MsftMultisessionRandomWrite;
#else
typedef struct MsftMultisessionRandomWrite MsftMultisessionRandomWrite;
#endif /* __cplusplus */

#endif 	/* __MsftMultisessionRandomWrite_FWD_DEFINED__ */


#ifndef __MsftRawCDImageCreator_FWD_DEFINED__
#define __MsftRawCDImageCreator_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftRawCDImageCreator MsftRawCDImageCreator;
#else
typedef struct MsftRawCDImageCreator MsftRawCDImageCreator;
#endif /* __cplusplus */

#endif 	/* __MsftRawCDImageCreator_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_imapi2_0000_0000 */
/* [local] */ 



























#define	IMAPI_SECTOR_SIZE	( 2048 )

#define IMAPI2_DEFAULT_COMMAND_TIMEOUT 10
typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_MEDIA_PHYSICAL_TYPE
    {	IMAPI_MEDIA_TYPE_UNKNOWN	= 0,
	IMAPI_MEDIA_TYPE_CDROM	= 0x1,
	IMAPI_MEDIA_TYPE_CDR	= 0x2,
	IMAPI_MEDIA_TYPE_CDRW	= 0x3,
	IMAPI_MEDIA_TYPE_DVDROM	= 0x4,
	IMAPI_MEDIA_TYPE_DVDRAM	= 0x5,
	IMAPI_MEDIA_TYPE_DVDPLUSR	= 0x6,
	IMAPI_MEDIA_TYPE_DVDPLUSRW	= 0x7,
	IMAPI_MEDIA_TYPE_DVDPLUSR_DUALLAYER	= 0x8,
	IMAPI_MEDIA_TYPE_DVDDASHR	= 0x9,
	IMAPI_MEDIA_TYPE_DVDDASHRW	= 0xa,
	IMAPI_MEDIA_TYPE_DVDDASHR_DUALLAYER	= 0xb,
	IMAPI_MEDIA_TYPE_DISK	= 0xc,
	IMAPI_MEDIA_TYPE_DVDPLUSRW_DUALLAYER	= 0xd,
	IMAPI_MEDIA_TYPE_HDDVDROM	= 0xe,
	IMAPI_MEDIA_TYPE_HDDVDR	= 0xf,
	IMAPI_MEDIA_TYPE_HDDVDRAM	= 0x10,
	IMAPI_MEDIA_TYPE_BDROM	= 0x11,
	IMAPI_MEDIA_TYPE_BDR	= 0x12,
	IMAPI_MEDIA_TYPE_BDRE	= 0x13,
	IMAPI_MEDIA_TYPE_MAX	= 0x13
    } 	IMAPI_MEDIA_PHYSICAL_TYPE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_MEDIA_PHYSICAL_TYPE *PIMAPI_MEDIA_PHYSICAL_TYPE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_MEDIA_WRITE_PROTECT_STATE
    {	IMAPI_WRITEPROTECTED_UNTIL_POWERDOWN	= 0x1,
	IMAPI_WRITEPROTECTED_BY_CARTRIDGE	= 0x2,
	IMAPI_WRITEPROTECTED_BY_MEDIA_SPECIFIC_REASON	= 0x4,
	IMAPI_WRITEPROTECTED_BY_SOFTWARE_WRITE_PROTECT	= 0x8,
	IMAPI_WRITEPROTECTED_BY_DISC_CONTROL_BLOCK	= 0x10,
	IMAPI_WRITEPROTECTED_READ_ONLY_MEDIA	= 0x4000
    } 	IMAPI_MEDIA_WRITE_PROTECT_STATE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_MEDIA_WRITE_PROTECT_STATE *PIMAPI_MEDIA_WRITE_PROTECT_STATE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_READ_TRACK_ADDRESS_TYPE
    {	IMAPI_READ_TRACK_ADDRESS_TYPE_LBA	= 0,
	IMAPI_READ_TRACK_ADDRESS_TYPE_TRACK	= 1,
	IMAPI_READ_TRACK_ADDRESS_TYPE_SESSION	= 2
    } 	IMAPI_READ_TRACK_ADDRESS_TYPE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_READ_TRACK_ADDRESS_TYPE *PIMAPI_READ_TRACK_ADDRESS_TYPE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_MODE_PAGE_REQUEST_TYPE
    {	IMAPI_MODE_PAGE_REQUEST_TYPE_CURRENT_VALUES	= 0,
	IMAPI_MODE_PAGE_REQUEST_TYPE_CHANGEABLE_VALUES	= 1,
	IMAPI_MODE_PAGE_REQUEST_TYPE_DEFAULT_VALUES	= 2,
	IMAPI_MODE_PAGE_REQUEST_TYPE_SAVED_VALUES	= 3
    } 	IMAPI_MODE_PAGE_REQUEST_TYPE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_MODE_PAGE_REQUEST_TYPE *PIMAPI_MODE_PAGE_REQUEST_TYPE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_MODE_PAGE_TYPE
    {	IMAPI_MODE_PAGE_TYPE_READ_WRITE_ERROR_RECOVERY	= 0x1,
	IMAPI_MODE_PAGE_TYPE_MRW	= 0x3,
	IMAPI_MODE_PAGE_TYPE_WRITE_PARAMETERS	= 0x5,
	IMAPI_MODE_PAGE_TYPE_CACHING	= 0x8,
	IMAPI_MODE_PAGE_TYPE_INFORMATIONAL_EXCEPTIONS	= 0x1c,
	IMAPI_MODE_PAGE_TYPE_TIMEOUT_AND_PROTECT	= 0x1d,
	IMAPI_MODE_PAGE_TYPE_POWER_CONDITION	= 0x1a,
	IMAPI_MODE_PAGE_TYPE_LEGACY_CAPABILITIES	= 0x2a
    } 	IMAPI_MODE_PAGE_TYPE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_MODE_PAGE_TYPE *PIMAPI_MODE_PAGE_TYPE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_FEATURE_PAGE_TYPE
    {	IMAPI_FEATURE_PAGE_TYPE_PROFILE_LIST	= 0,
	IMAPI_FEATURE_PAGE_TYPE_CORE	= 0x1,
	IMAPI_FEATURE_PAGE_TYPE_MORPHING	= 0x2,
	IMAPI_FEATURE_PAGE_TYPE_REMOVABLE_MEDIUM	= 0x3,
	IMAPI_FEATURE_PAGE_TYPE_WRITE_PROTECT	= 0x4,
	IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_READABLE	= 0x10,
	IMAPI_FEATURE_PAGE_TYPE_CD_MULTIREAD	= 0x1d,
	IMAPI_FEATURE_PAGE_TYPE_CD_READ	= 0x1e,
	IMAPI_FEATURE_PAGE_TYPE_DVD_READ	= 0x1f,
	IMAPI_FEATURE_PAGE_TYPE_RANDOMLY_WRITABLE	= 0x20,
	IMAPI_FEATURE_PAGE_TYPE_INCREMENTAL_STREAMING_WRITABLE	= 0x21,
	IMAPI_FEATURE_PAGE_TYPE_SECTOR_ERASABLE	= 0x22,
	IMAPI_FEATURE_PAGE_TYPE_FORMATTABLE	= 0x23,
	IMAPI_FEATURE_PAGE_TYPE_HARDWARE_DEFECT_MANAGEMENT	= 0x24,
	IMAPI_FEATURE_PAGE_TYPE_WRITE_ONCE	= 0x25,
	IMAPI_FEATURE_PAGE_TYPE_RESTRICTED_OVERWRITE	= 0x26,
	IMAPI_FEATURE_PAGE_TYPE_CDRW_CAV_WRITE	= 0x27,
	IMAPI_FEATURE_PAGE_TYPE_MRW	= 0x28,
	IMAPI_FEATURE_PAGE_TYPE_ENHANCED_DEFECT_REPORTING	= 0x29,
	IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_RW	= 0x2a,
	IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R	= 0x2b,
	IMAPI_FEATURE_PAGE_TYPE_RIGID_RESTRICTED_OVERWRITE	= 0x2c,
	IMAPI_FEATURE_PAGE_TYPE_CD_TRACK_AT_ONCE	= 0x2d,
	IMAPI_FEATURE_PAGE_TYPE_CD_MASTERING	= 0x2e,
	IMAPI_FEATURE_PAGE_TYPE_DVD_DASH_WRITE	= 0x2f,
	IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_READ	= 0x30,
	IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_R_WRITE	= 0x31,
	IMAPI_FEATURE_PAGE_TYPE_DOUBLE_DENSITY_CD_RW_WRITE	= 0x32,
	IMAPI_FEATURE_PAGE_TYPE_LAYER_JUMP_RECORDING	= 0x33,
	IMAPI_FEATURE_PAGE_TYPE_CD_RW_MEDIA_WRITE_SUPPORT	= 0x37,
	IMAPI_FEATURE_PAGE_TYPE_BD_PSEUDO_OVERWRITE	= 0x38,
	IMAPI_FEATURE_PAGE_TYPE_DVD_PLUS_R_DUAL_LAYER	= 0x3b,
	IMAPI_FEATURE_PAGE_TYPE_BD_READ	= 0x40,
	IMAPI_FEATURE_PAGE_TYPE_BD_WRITE	= 0x41,
	IMAPI_FEATURE_PAGE_TYPE_HD_DVD_READ	= 0x50,
	IMAPI_FEATURE_PAGE_TYPE_HD_DVD_WRITE	= 0x51,
	IMAPI_FEATURE_PAGE_TYPE_POWER_MANAGEMENT	= 0x100,
	IMAPI_FEATURE_PAGE_TYPE_SMART	= 0x101,
	IMAPI_FEATURE_PAGE_TYPE_EMBEDDED_CHANGER	= 0x102,
	IMAPI_FEATURE_PAGE_TYPE_CD_ANALOG_PLAY	= 0x103,
	IMAPI_FEATURE_PAGE_TYPE_MICROCODE_UPDATE	= 0x104,
	IMAPI_FEATURE_PAGE_TYPE_TIMEOUT	= 0x105,
	IMAPI_FEATURE_PAGE_TYPE_DVD_CSS	= 0x106,
	IMAPI_FEATURE_PAGE_TYPE_REAL_TIME_STREAMING	= 0x107,
	IMAPI_FEATURE_PAGE_TYPE_LOGICAL_UNIT_SERIAL_NUMBER	= 0x108,
	IMAPI_FEATURE_PAGE_TYPE_MEDIA_SERIAL_NUMBER	= 0x109,
	IMAPI_FEATURE_PAGE_TYPE_DISC_CONTROL_BLOCKS	= 0x10a,
	IMAPI_FEATURE_PAGE_TYPE_DVD_CPRM	= 0x10b,
	IMAPI_FEATURE_PAGE_TYPE_FIRMWARE_INFORMATION	= 0x10c,
	IMAPI_FEATURE_PAGE_TYPE_AACS	= 0x10d,
	IMAPI_FEATURE_PAGE_TYPE_VCPS	= 0x110
    } 	IMAPI_FEATURE_PAGE_TYPE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_FEATURE_PAGE_TYPE *PIMAPI_FEATURE_PAGE_TYPE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_PROFILE_TYPE
    {	IMAPI_PROFILE_TYPE_INVALID	= 0,
	IMAPI_PROFILE_TYPE_NON_REMOVABLE_DISK	= 0x1,
	IMAPI_PROFILE_TYPE_REMOVABLE_DISK	= 0x2,
	IMAPI_PROFILE_TYPE_MO_ERASABLE	= 0x3,
	IMAPI_PROFILE_TYPE_MO_WRITE_ONCE	= 0x4,
	IMAPI_PROFILE_TYPE_AS_MO	= 0x5,
	IMAPI_PROFILE_TYPE_CDROM	= 0x8,
	IMAPI_PROFILE_TYPE_CD_RECORDABLE	= 0x9,
	IMAPI_PROFILE_TYPE_CD_REWRITABLE	= 0xa,
	IMAPI_PROFILE_TYPE_DVDROM	= 0x10,
	IMAPI_PROFILE_TYPE_DVD_DASH_RECORDABLE	= 0x11,
	IMAPI_PROFILE_TYPE_DVD_RAM	= 0x12,
	IMAPI_PROFILE_TYPE_DVD_DASH_REWRITABLE	= 0x13,
	IMAPI_PROFILE_TYPE_DVD_DASH_RW_SEQUENTIAL	= 0x14,
	IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_SEQUENTIAL	= 0x15,
	IMAPI_PROFILE_TYPE_DVD_DASH_R_DUAL_LAYER_JUMP	= 0x16,
	IMAPI_PROFILE_TYPE_DVD_PLUS_RW	= 0x1a,
	IMAPI_PROFILE_TYPE_DVD_PLUS_R	= 0x1b,
	IMAPI_PROFILE_TYPE_DDCDROM	= 0x20,
	IMAPI_PROFILE_TYPE_DDCD_RECORDABLE	= 0x21,
	IMAPI_PROFILE_TYPE_DDCD_REWRITABLE	= 0x22,
	IMAPI_PROFILE_TYPE_DVD_PLUS_RW_DUAL	= 0x2a,
	IMAPI_PROFILE_TYPE_DVD_PLUS_R_DUAL	= 0x2b,
	IMAPI_PROFILE_TYPE_BD_ROM	= 0x40,
	IMAPI_PROFILE_TYPE_BD_R_SEQUENTIAL	= 0x41,
	IMAPI_PROFILE_TYPE_BD_R_RANDOM_RECORDING	= 0x42,
	IMAPI_PROFILE_TYPE_BD_REWRITABLE	= 0x43,
	IMAPI_PROFILE_TYPE_HD_DVD_ROM	= 0x50,
	IMAPI_PROFILE_TYPE_HD_DVD_RECORDABLE	= 0x51,
	IMAPI_PROFILE_TYPE_HD_DVD_RAM	= 0x52,
	IMAPI_PROFILE_TYPE_NON_STANDARD	= 0xffff
    } 	IMAPI_PROFILE_TYPE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_PROFILE_TYPE *PIMAPI_PROFILE_TYPE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_FORMAT2_DATA_WRITE_ACTION
    {	IMAPI_FORMAT2_DATA_WRITE_ACTION_VALIDATING_MEDIA	= 0,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_FORMATTING_MEDIA	= 0x1,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_INITIALIZING_HARDWARE	= 0x2,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_CALIBRATING_POWER	= 0x3,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_WRITING_DATA	= 0x4,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_FINALIZATION	= 0x5,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_COMPLETED	= 0x6,
	IMAPI_FORMAT2_DATA_WRITE_ACTION_VERIFYING	= 0x7
    } 	IMAPI_FORMAT2_DATA_WRITE_ACTION;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_FORMAT2_DATA_WRITE_ACTION *PIMAPI_FORMAT2_DATA_WRITE_ACTION;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_FORMAT2_DATA_MEDIA_STATE
    {	IMAPI_FORMAT2_DATA_MEDIA_STATE_UNKNOWN	= 0,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_INFORMATIONAL_MASK	= 0xf,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MASK	= 0xfc00,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_OVERWRITE_ONLY	= 0x1,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_RANDOMLY_WRITABLE	= 0x1,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_BLANK	= 0x2,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_APPENDABLE	= 0x4,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_FINAL_SESSION	= 0x8,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_DAMAGED	= 0x400,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_ERASE_REQUIRED	= 0x800,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_NON_EMPTY_SESSION	= 0x1000,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_WRITE_PROTECTED	= 0x2000,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_FINALIZED	= 0x4000,
	IMAPI_FORMAT2_DATA_MEDIA_STATE_UNSUPPORTED_MEDIA	= 0x8000
    } 	IMAPI_FORMAT2_DATA_MEDIA_STATE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_FORMAT2_DATA_MEDIA_STATE *PIMAPI_FORMAT2_DATA_MEDIA_STATE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_FORMAT2_TAO_WRITE_ACTION
    {	IMAPI_FORMAT2_TAO_WRITE_ACTION_UNKNOWN	= 0,
	IMAPI_FORMAT2_TAO_WRITE_ACTION_PREPARING	= 0x1,
	IMAPI_FORMAT2_TAO_WRITE_ACTION_WRITING	= 0x2,
	IMAPI_FORMAT2_TAO_WRITE_ACTION_FINISHING	= 0x3,
	IMAPI_FORMAT2_TAO_WRITE_ACTION_VERIFYING	= 0x4
    } 	IMAPI_FORMAT2_TAO_WRITE_ACTION;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_FORMAT2_TAO_WRITE_ACTION *PIMAPI_FORMAT2_TAO_WRITE_ACTION;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE
    {	IMAPI_FORMAT2_RAW_CD_SUBCODE_PQ_ONLY	= 0x1,
	IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_COOKED	= 0x2,
	IMAPI_FORMAT2_RAW_CD_SUBCODE_IS_RAW	= 0x3
    } 	IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE *PIMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_FORMAT2_RAW_CD_WRITE_ACTION
    {	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_UNKNOWN	= 0,
	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_PREPARING	= 0x1,
	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_WRITING	= 0x2,
	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION_FINISHING	= 0x3
    } 	IMAPI_FORMAT2_RAW_CD_WRITE_ACTION;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_FORMAT2_RAW_CD_WRITE_ACTION *PIMAPI_FORMAT2_RAW_CD_WRITE_ACTION;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_CD_SECTOR_TYPE
    {	IMAPI_CD_SECTOR_AUDIO	= 0,
	IMAPI_CD_SECTOR_MODE_ZERO	= 0x1,
	IMAPI_CD_SECTOR_MODE1	= 0x2,
	IMAPI_CD_SECTOR_MODE2FORM0	= 0x3,
	IMAPI_CD_SECTOR_MODE2FORM1	= 0x4,
	IMAPI_CD_SECTOR_MODE2FORM2	= 0x5,
	IMAPI_CD_SECTOR_MODE1RAW	= 0x6,
	IMAPI_CD_SECTOR_MODE2FORM0RAW	= 0x7,
	IMAPI_CD_SECTOR_MODE2FORM1RAW	= 0x8,
	IMAPI_CD_SECTOR_MODE2FORM2RAW	= 0x9
    } 	IMAPI_CD_SECTOR_TYPE;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_CD_SECTOR_TYPE *PIMAPI_CD_SECTOR_TYPE;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_CD_TRACK_DIGITAL_COPY_SETTING
    {	IMAPI_CD_TRACK_DIGITAL_COPY_PERMITTED	= 0,
	IMAPI_CD_TRACK_DIGITAL_COPY_PROHIBITED	= 0x1,
	IMAPI_CD_TRACK_DIGITAL_COPY_SCMS	= 0x2
    } 	IMAPI_CD_TRACK_DIGITAL_COPY_SETTING;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_CD_TRACK_DIGITAL_COPY_SETTING *PIMAPI_CD_TRACK_DIGITAL_COPY_SETTING;

typedef /* [public][helpstring][v1_enum] */ 
enum _IMAPI_BURN_VERIFICATION_LEVEL
    {	IMAPI_BURN_VERIFICATION_NONE	= 0,
	IMAPI_BURN_VERIFICATION_QUICK	= 1,
	IMAPI_BURN_VERIFICATION_FULL	= 2
    } 	IMAPI_BURN_VERIFICATION_LEVEL;

typedef /* [public][helpstring][v1_enum] */ enum _IMAPI_BURN_VERIFICATION_LEVEL *PIMAPI_BURN_VERIFICATION_LEVEL;

// begin_wpp config
// CUSTOM_TYPE(IMAPI_MEDIA_PHYSICAL_TYPE,            ItemEnum(_IMAPI_MEDIA_PHYSICAL_TYPE));
// CUSTOM_TYPE(IMAPI_MEDIA_WRITE_PROTECT_STATE,      ItemEnum(_IMAPI_MEDIA_WRITE_PROTECT_STATE));
// CUSTOM_TYPE(IMAPI_READ_TRACK_ADDRESS_TYPE,        ItemEnum(_IMAPI_READ_TRACK_ADDRESS_TYPE));
// CUSTOM_TYPE(IMAPI_MODE_PAGE_REQUEST_TYPE,         ItemEnum(_IMAPI_MODE_PAGE_REQUEST_TYPE));
// CUSTOM_TYPE(IMAPI_MODE_PAGE_TYPE,                 ItemEnum(_IMAPI_MODE_PAGE_TYPE));
// CUSTOM_TYPE(IMAPI_FEATURE_PAGE_TYPE,              ItemEnum(_IMAPI_FEATURE_PAGE_TYPE));
// CUSTOM_TYPE(IMAPI_PROFILE_TYPE,                   ItemEnum(_IMAPI_PROFILE_TYPE));
// CUSTOM_TYPE(IMAPI_FORMAT2_DATA_WRITE_ACTION,      ItemEnum(_IMAPI_FORMAT2_DATA_WRITE_ACTION));
// CUSTOM_TYPE(IMAPI_FORMAT2_DATA_MEDIA_STATE,       ItemEnum(_IMAPI_FORMAT2_DATA_MEDIA_STATE));
// CUSTOM_TYPE(IMAPI_FORMAT2_TAO_WRITE_ACTION,       ItemEnum(_IMAPI_FORMAT2_TAO_WRITE_ACTION));
// CUSTOM_TYPE(IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE, ItemEnum(_IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE));
// CUSTOM_TYPE(IMAPI_FORMAT2_RAW_CD_WRITE_ACTION,    ItemEnum(_IMAPI_FORMAT2_RAW_CD_WRITE_ACTION));
// CUSTOM_TYPE(IMAPI_CD_SECTOR_DATA_TYPE,            ItemEnum(_IMAPI_CD_SECTOR_TYPE));
// CUSTOM_TYPE(IMAPI_CD_TRACK_DIGITAL_COPY_SETTING,  ItemEnum(_IMAPI_CD_TRACK_DIGITAL_COPY_SETTING));
// CUSTOM_TYPE(IMAPI_BURN_VERIFICATION_LEVEL,        ItemEnum(_IMAPI_BURN_VERIFICATION_LEVEL));
// end_wpp


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0000_v0_0_s_ifspec;

#ifndef __IDiscMaster2_INTERFACE_DEFINED__
#define __IDiscMaster2_INTERFACE_DEFINED__

/* interface IDiscMaster2 */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscMaster2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354130-7F64-5B0F-8F00-5D77AFBE261E")
    IDiscMaster2 : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IEnumVARIANT **ppunk) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsSupportedEnvironment( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscMaster2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscMaster2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscMaster2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscMaster2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscMaster2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscMaster2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscMaster2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscMaster2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IDiscMaster2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IEnumVARIANT **ppunk);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IDiscMaster2 * This,
            /* [in] */ LONG index,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IDiscMaster2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSupportedEnvironment )( 
            __RPC__in IDiscMaster2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        END_INTERFACE
    } IDiscMaster2Vtbl;

    interface IDiscMaster2
    {
        CONST_VTBL struct IDiscMaster2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscMaster2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscMaster2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscMaster2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscMaster2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscMaster2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscMaster2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscMaster2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscMaster2_get__NewEnum(This,ppunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppunk) ) 

#define IDiscMaster2_get_Item(This,index,value)	\
    ( (This)->lpVtbl -> get_Item(This,index,value) ) 

#define IDiscMaster2_get_Count(This,value)	\
    ( (This)->lpVtbl -> get_Count(This,value) ) 

#define IDiscMaster2_get_IsSupportedEnvironment(This,value)	\
    ( (This)->lpVtbl -> get_IsSupportedEnvironment(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscMaster2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0001 */
/* [local] */ 

#define DISPID_DDISCMASTER2EVENTS_DEVICEADDED   0x100
#define DISPID_DDISCMASTER2EVENTS_DEVICEREMOVED 0x101


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0001_v0_0_s_ifspec;

#ifndef __DDiscMaster2Events_INTERFACE_DEFINED__
#define __DDiscMaster2Events_INTERFACE_DEFINED__

/* interface DDiscMaster2Events */
/* [helpstring][unique][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_DDiscMaster2Events;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354131-7F64-5B0F-8F00-5D77AFBE261E")
    DDiscMaster2Events : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NotifyDeviceAdded( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in BSTR uniqueId) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE NotifyDeviceRemoved( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in BSTR uniqueId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DDiscMaster2EventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DDiscMaster2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DDiscMaster2Events * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DDiscMaster2Events * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DDiscMaster2Events * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DDiscMaster2Events * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DDiscMaster2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DDiscMaster2Events * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NotifyDeviceAdded )( 
            __RPC__in DDiscMaster2Events * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in BSTR uniqueId);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *NotifyDeviceRemoved )( 
            __RPC__in DDiscMaster2Events * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in BSTR uniqueId);
        
        END_INTERFACE
    } DDiscMaster2EventsVtbl;

    interface DDiscMaster2Events
    {
        CONST_VTBL struct DDiscMaster2EventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DDiscMaster2Events_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DDiscMaster2Events_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DDiscMaster2Events_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DDiscMaster2Events_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DDiscMaster2Events_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DDiscMaster2Events_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DDiscMaster2Events_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DDiscMaster2Events_NotifyDeviceAdded(This,object,uniqueId)	\
    ( (This)->lpVtbl -> NotifyDeviceAdded(This,object,uniqueId) ) 

#define DDiscMaster2Events_NotifyDeviceRemoved(This,object,uniqueId)	\
    ( (This)->lpVtbl -> NotifyDeviceRemoved(This,object,uniqueId) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DDiscMaster2Events_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0002 */
/* [local] */ 

typedef /* [range] */ __RPC__range(0,0xffff) ULONG ULONG_IMAPI2_DVD_STRUCTURE;

typedef /* [range] */ __RPC__range(0,0xfffffff) ULONG ULONG_IMAPI2_ADAPTER_DESCRIPTOR;

typedef /* [range] */ __RPC__range(0,0xfffffff) ULONG ULONG_IMAPI2_DEVICE_DESCRIPTOR;

typedef /* [range] */ __RPC__range(0,0x10002) ULONG ULONG_IMAPI2_DISC_INFORMATION;

typedef /* [range] */ __RPC__range(0,0x10002) ULONG ULONG_IMAPI2_TRACK_INFORMATION;

typedef /* [range] */ __RPC__range(0,0x100) ULONG ULONG_IMAPI2_FEATURE_PAGE;

typedef /* [range] */ __RPC__range(0,0x101) ULONG ULONG_IMAPI2_MODE_PAGE;

typedef /* [range] */ __RPC__range(0,0x10000) ULONG ULONG_IMAPI2_ALL_FEATURE_PAGES;

typedef /* [range] */ __RPC__range(0,0x3f) ULONG ULONG_IMAPI2_ALL_PROFILES;

typedef /* [range] */ __RPC__range(0,0x7ffb) ULONG ULONG_IMAPI2_ALL_MODE_PAGES;

typedef /* [range] */ __RPC__range(1,0x7fffffff) ULONG ULONG_IMAPI2_NONZERO;

typedef /* [range] */ __RPC__range(0,0x7fffffff) ULONG ULONG_IMAPI2_NOT_NEGATIVE;



extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0002_v0_0_s_ifspec;

#ifndef __IDiscRecorder2Ex_INTERFACE_DEFINED__
#define __IDiscRecorder2Ex_INTERFACE_DEFINED__

/* interface IDiscRecorder2Ex */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IDiscRecorder2Ex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354132-7F64-5B0F-8F00-5D77AFBE261E")
    IDiscRecorder2Ex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendCommandNoData( 
            /* [size_is][ref][in] */ __RPC__in_ecount_full(CdbSize) BYTE *Cdb,
            /* [range][in] */ __RPC__in_range(6,16) ULONG CdbSize,
            /* [ref][out] */ __RPC__out_ecount_full(18) BYTE SenseBuffer[ 18 ],
            /* [in] */ ULONG Timeout) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendCommandSendDataToDevice( 
            /* [size_is][ref][in] */ __RPC__in_ecount_full(CdbSize) BYTE *Cdb,
            /* [range][in] */ __RPC__in_range(6,16) ULONG CdbSize,
            /* [ref][out] */ __RPC__out_ecount_full(18) BYTE SenseBuffer[ 18 ],
            /* [in] */ ULONG Timeout,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(BufferSize) BYTE *Buffer,
            /* [in] */ ULONG_IMAPI2_NONZERO BufferSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendCommandGetDataFromDevice( 
            /* [size_is][ref][in] */ __RPC__in_ecount_full(CdbSize) BYTE *Cdb,
            /* [range][in] */ __RPC__in_range(6,16) ULONG CdbSize,
            /* [ref][out] */ __RPC__out_ecount_full(18) BYTE SenseBuffer[ 18 ],
            /* [in] */ ULONG Timeout,
            /* [length_is][size_is][ref][out] */ __RPC__out_ecount_part(BufferSize, *BufferFetched) BYTE *Buffer,
            /* [in] */ ULONG_IMAPI2_NONZERO BufferSize,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_NOT_NEGATIVE *BufferFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReadDvdStructure( 
            /* [range][in] */ __RPC__in_range(0,0xff) ULONG format,
            /* [in] */ ULONG address,
            /* [range][in] */ __RPC__in_range(0,0xff) ULONG layer,
            /* [range][in] */ __RPC__in_range(0,0x3) ULONG agid,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*count) BYTE **data,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_DVD_STRUCTURE *count) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendDvdStructure( 
            /* [range][in] */ __RPC__in_range(0,0xff) ULONG format,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(count) BYTE *data,
            /* [in] */ ULONG_IMAPI2_DVD_STRUCTURE count) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAdapterDescriptor( 
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **data,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_ADAPTER_DESCRIPTOR *byteSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDeviceDescriptor( 
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **data,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_DEVICE_DESCRIPTOR *byteSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDiscInformation( 
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **discInformation,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_DISC_INFORMATION *byteSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTrackInformation( 
            /* [in] */ ULONG address,
            /* [in] */ IMAPI_READ_TRACK_ADDRESS_TYPE addressType,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **trackInformation,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_TRACK_INFORMATION *byteSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetFeaturePage( 
            /* [in] */ IMAPI_FEATURE_PAGE_TYPE requestedFeature,
            /* [in] */ BOOLEAN currentFeatureOnly,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **featureData,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_FEATURE_PAGE *byteSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetModePage( 
            /* [in] */ IMAPI_MODE_PAGE_TYPE requestedModePage,
            /* [in] */ IMAPI_MODE_PAGE_REQUEST_TYPE requestType,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **modePageData,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_MODE_PAGE *byteSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetModePage( 
            /* [in] */ IMAPI_MODE_PAGE_REQUEST_TYPE requestType,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(byteSize) BYTE *data,
            /* [in] */ ULONG_IMAPI2_MODE_PAGE byteSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSupportedFeaturePages( 
            /* [in] */ BOOLEAN currentFeatureOnly,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) IMAPI_FEATURE_PAGE_TYPE **featureData,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_ALL_FEATURE_PAGES *byteSize) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSupportedProfiles( 
            /* [in] */ BOOLEAN currentOnly,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*validProfiles) IMAPI_PROFILE_TYPE **profileTypes,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_ALL_PROFILES *validProfiles) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSupportedModePages( 
            /* [in] */ IMAPI_MODE_PAGE_REQUEST_TYPE requestType,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*validPages) IMAPI_MODE_PAGE_TYPE **modePageTypes,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_ALL_MODE_PAGES *validPages) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetByteAlignmentMask( 
            /* [retval][ref][out] */ __RPC__out ULONG *value) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMaximumNonPageAlignedTransferSize( 
            /* [retval][ref][out] */ __RPC__out ULONG *value) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetMaximumPageAlignedTransferSize( 
            /* [retval][ref][out] */ __RPC__out ULONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscRecorder2ExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscRecorder2Ex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscRecorder2Ex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendCommandNoData )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(CdbSize) BYTE *Cdb,
            /* [range][in] */ __RPC__in_range(6,16) ULONG CdbSize,
            /* [ref][out] */ __RPC__out_ecount_full(18) BYTE SenseBuffer[ 18 ],
            /* [in] */ ULONG Timeout);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendCommandSendDataToDevice )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(CdbSize) BYTE *Cdb,
            /* [range][in] */ __RPC__in_range(6,16) ULONG CdbSize,
            /* [ref][out] */ __RPC__out_ecount_full(18) BYTE SenseBuffer[ 18 ],
            /* [in] */ ULONG Timeout,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(BufferSize) BYTE *Buffer,
            /* [in] */ ULONG_IMAPI2_NONZERO BufferSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendCommandGetDataFromDevice )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(CdbSize) BYTE *Cdb,
            /* [range][in] */ __RPC__in_range(6,16) ULONG CdbSize,
            /* [ref][out] */ __RPC__out_ecount_full(18) BYTE SenseBuffer[ 18 ],
            /* [in] */ ULONG Timeout,
            /* [length_is][size_is][ref][out] */ __RPC__out_ecount_part(BufferSize, *BufferFetched) BYTE *Buffer,
            /* [in] */ ULONG_IMAPI2_NONZERO BufferSize,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_NOT_NEGATIVE *BufferFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReadDvdStructure )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [range][in] */ __RPC__in_range(0,0xff) ULONG format,
            /* [in] */ ULONG address,
            /* [range][in] */ __RPC__in_range(0,0xff) ULONG layer,
            /* [range][in] */ __RPC__in_range(0,0x3) ULONG agid,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*count) BYTE **data,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_DVD_STRUCTURE *count);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendDvdStructure )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [range][in] */ __RPC__in_range(0,0xff) ULONG format,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(count) BYTE *data,
            /* [in] */ ULONG_IMAPI2_DVD_STRUCTURE count);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAdapterDescriptor )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **data,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_ADAPTER_DESCRIPTOR *byteSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDeviceDescriptor )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **data,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_DEVICE_DESCRIPTOR *byteSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDiscInformation )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **discInformation,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_DISC_INFORMATION *byteSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTrackInformation )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [in] */ ULONG address,
            /* [in] */ IMAPI_READ_TRACK_ADDRESS_TYPE addressType,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **trackInformation,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_TRACK_INFORMATION *byteSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetFeaturePage )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [in] */ IMAPI_FEATURE_PAGE_TYPE requestedFeature,
            /* [in] */ BOOLEAN currentFeatureOnly,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **featureData,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_FEATURE_PAGE *byteSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetModePage )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [in] */ IMAPI_MODE_PAGE_TYPE requestedModePage,
            /* [in] */ IMAPI_MODE_PAGE_REQUEST_TYPE requestType,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) BYTE **modePageData,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_MODE_PAGE *byteSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetModePage )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [in] */ IMAPI_MODE_PAGE_REQUEST_TYPE requestType,
            /* [size_is][ref][in] */ __RPC__in_ecount_full(byteSize) BYTE *data,
            /* [in] */ ULONG_IMAPI2_MODE_PAGE byteSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSupportedFeaturePages )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [in] */ BOOLEAN currentFeatureOnly,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*byteSize) IMAPI_FEATURE_PAGE_TYPE **featureData,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_ALL_FEATURE_PAGES *byteSize);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSupportedProfiles )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [in] */ BOOLEAN currentOnly,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*validProfiles) IMAPI_PROFILE_TYPE **profileTypes,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_ALL_PROFILES *validProfiles);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSupportedModePages )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [in] */ IMAPI_MODE_PAGE_REQUEST_TYPE requestType,
            /* [size_is][size_is][ref][out] */ __RPC__deref_out_ecount_full_opt(*validPages) IMAPI_MODE_PAGE_TYPE **modePageTypes,
            /* [ref][out] */ __RPC__out ULONG_IMAPI2_ALL_MODE_PAGES *validPages);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetByteAlignmentMask )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [retval][ref][out] */ __RPC__out ULONG *value);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMaximumNonPageAlignedTransferSize )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [retval][ref][out] */ __RPC__out ULONG *value);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetMaximumPageAlignedTransferSize )( 
            __RPC__in IDiscRecorder2Ex * This,
            /* [retval][ref][out] */ __RPC__out ULONG *value);
        
        END_INTERFACE
    } IDiscRecorder2ExVtbl;

    interface IDiscRecorder2Ex
    {
        CONST_VTBL struct IDiscRecorder2ExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscRecorder2Ex_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscRecorder2Ex_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscRecorder2Ex_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscRecorder2Ex_SendCommandNoData(This,Cdb,CdbSize,SenseBuffer,Timeout)	\
    ( (This)->lpVtbl -> SendCommandNoData(This,Cdb,CdbSize,SenseBuffer,Timeout) ) 

#define IDiscRecorder2Ex_SendCommandSendDataToDevice(This,Cdb,CdbSize,SenseBuffer,Timeout,Buffer,BufferSize)	\
    ( (This)->lpVtbl -> SendCommandSendDataToDevice(This,Cdb,CdbSize,SenseBuffer,Timeout,Buffer,BufferSize) ) 

#define IDiscRecorder2Ex_SendCommandGetDataFromDevice(This,Cdb,CdbSize,SenseBuffer,Timeout,Buffer,BufferSize,BufferFetched)	\
    ( (This)->lpVtbl -> SendCommandGetDataFromDevice(This,Cdb,CdbSize,SenseBuffer,Timeout,Buffer,BufferSize,BufferFetched) ) 

#define IDiscRecorder2Ex_ReadDvdStructure(This,format,address,layer,agid,data,count)	\
    ( (This)->lpVtbl -> ReadDvdStructure(This,format,address,layer,agid,data,count) ) 

#define IDiscRecorder2Ex_SendDvdStructure(This,format,data,count)	\
    ( (This)->lpVtbl -> SendDvdStructure(This,format,data,count) ) 

#define IDiscRecorder2Ex_GetAdapterDescriptor(This,data,byteSize)	\
    ( (This)->lpVtbl -> GetAdapterDescriptor(This,data,byteSize) ) 

#define IDiscRecorder2Ex_GetDeviceDescriptor(This,data,byteSize)	\
    ( (This)->lpVtbl -> GetDeviceDescriptor(This,data,byteSize) ) 

#define IDiscRecorder2Ex_GetDiscInformation(This,discInformation,byteSize)	\
    ( (This)->lpVtbl -> GetDiscInformation(This,discInformation,byteSize) ) 

#define IDiscRecorder2Ex_GetTrackInformation(This,address,addressType,trackInformation,byteSize)	\
    ( (This)->lpVtbl -> GetTrackInformation(This,address,addressType,trackInformation,byteSize) ) 

#define IDiscRecorder2Ex_GetFeaturePage(This,requestedFeature,currentFeatureOnly,featureData,byteSize)	\
    ( (This)->lpVtbl -> GetFeaturePage(This,requestedFeature,currentFeatureOnly,featureData,byteSize) ) 

#define IDiscRecorder2Ex_GetModePage(This,requestedModePage,requestType,modePageData,byteSize)	\
    ( (This)->lpVtbl -> GetModePage(This,requestedModePage,requestType,modePageData,byteSize) ) 

#define IDiscRecorder2Ex_SetModePage(This,requestType,data,byteSize)	\
    ( (This)->lpVtbl -> SetModePage(This,requestType,data,byteSize) ) 

#define IDiscRecorder2Ex_GetSupportedFeaturePages(This,currentFeatureOnly,featureData,byteSize)	\
    ( (This)->lpVtbl -> GetSupportedFeaturePages(This,currentFeatureOnly,featureData,byteSize) ) 

#define IDiscRecorder2Ex_GetSupportedProfiles(This,currentOnly,profileTypes,validProfiles)	\
    ( (This)->lpVtbl -> GetSupportedProfiles(This,currentOnly,profileTypes,validProfiles) ) 

#define IDiscRecorder2Ex_GetSupportedModePages(This,requestType,modePageTypes,validPages)	\
    ( (This)->lpVtbl -> GetSupportedModePages(This,requestType,modePageTypes,validPages) ) 

#define IDiscRecorder2Ex_GetByteAlignmentMask(This,value)	\
    ( (This)->lpVtbl -> GetByteAlignmentMask(This,value) ) 

#define IDiscRecorder2Ex_GetMaximumNonPageAlignedTransferSize(This,value)	\
    ( (This)->lpVtbl -> GetMaximumNonPageAlignedTransferSize(This,value) ) 

#define IDiscRecorder2Ex_GetMaximumPageAlignedTransferSize(This,value)	\
    ( (This)->lpVtbl -> GetMaximumPageAlignedTransferSize(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscRecorder2Ex_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0003 */
/* [local] */ 

#define DISPID_IDISCRECORDER2_EJECTMEDIA             0x100
#define DISPID_IDISCRECORDER2_CLOSETRAY              0x101
#define DISPID_IDISCRECORDER2_ACQUIREEXCLUSIVEACCESS 0x102
#define DISPID_IDISCRECORDER2_RELEASEEXCLUSIVEACCESS 0x103
#define DISPID_IDISCRECORDER2_DISABLEMCN             0x104
#define DISPID_IDISCRECORDER2_ENABLEMCN              0x105
#define DISPID_IDISCRECORDER2_INITIALIZEDISCRECORDER 0x106
#define DISPID_IDISCRECORDER2_ACTIVEDISCRECORDER     DISPID_VALUE
#define DISPID_IDISCRECORDER2_VENDORID               0x201
#define DISPID_IDISCRECORDER2_PRODUCTID              0x202
#define DISPID_IDISCRECORDER2_PRODUCTREVISION        0x203
#define DISPID_IDISCRECORDER2_VOLUMENAME             0x204
#define DISPID_IDISCRECORDER2_VOLUMEPATHNAMES        0x205
#define DISPID_IDISCRECORDER2_DEVICECANLOADMEDIA     0x206
#define DISPID_IDISCRECORDER2_LEGACYDEVICENUMBER     0x207
#define DISPID_IDISCRECORDER2_SUPPORTEDFEATUREPAGES  0x208
#define DISPID_IDISCRECORDER2_CURRENTFEATUREPAGES    0x209
#define DISPID_IDISCRECORDER2_SUPPORTEDPROFILES      0x20A
#define DISPID_IDISCRECORDER2_CURRENTPROFILES        0x20B
#define DISPID_IDISCRECORDER2_SUPPORTEDMODEPAGES     0x20C
#define DISPID_IDISCRECORDER2_EXCLUSIVEACCESSOWNER   0x20D


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0003_v0_0_s_ifspec;

#ifndef __IDiscRecorder2_INTERFACE_DEFINED__
#define __IDiscRecorder2_INTERFACE_DEFINED__

/* interface IDiscRecorder2 */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscRecorder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354133-7F64-5B0F-8F00-5D77AFBE261E")
    IDiscRecorder2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EjectMedia( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseTray( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AcquireExclusiveAccess( 
            /* [in] */ VARIANT_BOOL force,
            /* [in] */ __RPC__in BSTR __MIDL__IDiscRecorder20000) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseExclusiveAccess( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisableMcn( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EnableMcn( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InitializeDiscRecorder( 
            /* [in] */ __RPC__in BSTR recorderUniqueId) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveDiscRecorder( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VendorId( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProductId( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProductRevision( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VolumeName( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VolumePathNames( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DeviceCanLoadMedia( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LegacyDeviceNumber( 
            /* [retval][ref][out] */ __RPC__out LONG *legacyDeviceNumber) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedFeaturePages( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentFeaturePages( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedProfiles( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentProfiles( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedModePages( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExclusiveAccessOwner( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscRecorder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscRecorder2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscRecorder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscRecorder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscRecorder2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscRecorder2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscRecorder2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscRecorder2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EjectMedia )( 
            __RPC__in IDiscRecorder2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CloseTray )( 
            __RPC__in IDiscRecorder2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AcquireExclusiveAccess )( 
            __RPC__in IDiscRecorder2 * This,
            /* [in] */ VARIANT_BOOL force,
            /* [in] */ __RPC__in BSTR __MIDL__IDiscRecorder20000);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseExclusiveAccess )( 
            __RPC__in IDiscRecorder2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisableMcn )( 
            __RPC__in IDiscRecorder2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EnableMcn )( 
            __RPC__in IDiscRecorder2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InitializeDiscRecorder )( 
            __RPC__in IDiscRecorder2 * This,
            /* [in] */ __RPC__in BSTR recorderUniqueId);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ActiveDiscRecorder )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VendorId )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProductId )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProductRevision )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeName )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumePathNames )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DeviceCanLoadMedia )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LegacyDeviceNumber )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *legacyDeviceNumber);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedFeaturePages )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentFeaturePages )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedProfiles )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProfiles )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedModePages )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExclusiveAccessOwner )( 
            __RPC__in IDiscRecorder2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        END_INTERFACE
    } IDiscRecorder2Vtbl;

    interface IDiscRecorder2
    {
        CONST_VTBL struct IDiscRecorder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscRecorder2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscRecorder2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscRecorder2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscRecorder2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscRecorder2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscRecorder2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscRecorder2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscRecorder2_EjectMedia(This)	\
    ( (This)->lpVtbl -> EjectMedia(This) ) 

#define IDiscRecorder2_CloseTray(This)	\
    ( (This)->lpVtbl -> CloseTray(This) ) 

#define IDiscRecorder2_AcquireExclusiveAccess(This,force,__MIDL__IDiscRecorder20000)	\
    ( (This)->lpVtbl -> AcquireExclusiveAccess(This,force,__MIDL__IDiscRecorder20000) ) 

#define IDiscRecorder2_ReleaseExclusiveAccess(This)	\
    ( (This)->lpVtbl -> ReleaseExclusiveAccess(This) ) 

#define IDiscRecorder2_DisableMcn(This)	\
    ( (This)->lpVtbl -> DisableMcn(This) ) 

#define IDiscRecorder2_EnableMcn(This)	\
    ( (This)->lpVtbl -> EnableMcn(This) ) 

#define IDiscRecorder2_InitializeDiscRecorder(This,recorderUniqueId)	\
    ( (This)->lpVtbl -> InitializeDiscRecorder(This,recorderUniqueId) ) 

#define IDiscRecorder2_get_ActiveDiscRecorder(This,value)	\
    ( (This)->lpVtbl -> get_ActiveDiscRecorder(This,value) ) 

#define IDiscRecorder2_get_VendorId(This,value)	\
    ( (This)->lpVtbl -> get_VendorId(This,value) ) 

#define IDiscRecorder2_get_ProductId(This,value)	\
    ( (This)->lpVtbl -> get_ProductId(This,value) ) 

#define IDiscRecorder2_get_ProductRevision(This,value)	\
    ( (This)->lpVtbl -> get_ProductRevision(This,value) ) 

#define IDiscRecorder2_get_VolumeName(This,value)	\
    ( (This)->lpVtbl -> get_VolumeName(This,value) ) 

#define IDiscRecorder2_get_VolumePathNames(This,value)	\
    ( (This)->lpVtbl -> get_VolumePathNames(This,value) ) 

#define IDiscRecorder2_get_DeviceCanLoadMedia(This,value)	\
    ( (This)->lpVtbl -> get_DeviceCanLoadMedia(This,value) ) 

#define IDiscRecorder2_get_LegacyDeviceNumber(This,legacyDeviceNumber)	\
    ( (This)->lpVtbl -> get_LegacyDeviceNumber(This,legacyDeviceNumber) ) 

#define IDiscRecorder2_get_SupportedFeaturePages(This,value)	\
    ( (This)->lpVtbl -> get_SupportedFeaturePages(This,value) ) 

#define IDiscRecorder2_get_CurrentFeaturePages(This,value)	\
    ( (This)->lpVtbl -> get_CurrentFeaturePages(This,value) ) 

#define IDiscRecorder2_get_SupportedProfiles(This,value)	\
    ( (This)->lpVtbl -> get_SupportedProfiles(This,value) ) 

#define IDiscRecorder2_get_CurrentProfiles(This,value)	\
    ( (This)->lpVtbl -> get_CurrentProfiles(This,value) ) 

#define IDiscRecorder2_get_SupportedModePages(This,value)	\
    ( (This)->lpVtbl -> get_SupportedModePages(This,value) ) 

#define IDiscRecorder2_get_ExclusiveAccessOwner(This,value)	\
    ( (This)->lpVtbl -> get_ExclusiveAccessOwner(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscRecorder2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0004 */
/* [local] */ 

#define DISPID_IWRITEENGINE2_WRITESECTION              0x200
#define DISPID_IWRITEENGINE2_CANCELWRITE               0x201
#define DISPID_IWRITEENGINE2_DISCRECORDER              0x100
#define DISPID_IWRITEENGINE2_USESTREAMINGWRITE12       0x101
#define DISPID_IWRITEENGINE2_STARTINGSECTORSPERSECOND  0x102
#define DISPID_IWRITEENGINE2_ENDINGSECTORSPERSECOND    0x103
#define DISPID_IWRITEENGINE2_BYTESPERSECTOR            0x104
#define DISPID_IWRITEENGINE2_WRITEINPROGRESS           0x105


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0004_v0_0_s_ifspec;

#ifndef __IWriteEngine2_INTERFACE_DEFINED__
#define __IWriteEngine2_INTERFACE_DEFINED__

/* interface IWriteEngine2 */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IWriteEngine2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354135-7F64-5B0F-8F00-5D77AFBE261E")
    IWriteEngine2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteSection( 
            /* [in] */ __RPC__in_opt IStream *data,
            /* [in] */ LONG startingBlockAddress,
            /* [in] */ LONG numberOfBlocks) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelWrite( void) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Recorder( 
            /* [in] */ __RPC__in_opt IDiscRecorder2Ex *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recorder( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2Ex **value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseStreamingWrite12( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseStreamingWrite12( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartingSectorsPerSecond( 
            /* [in] */ LONG value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartingSectorsPerSecond( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_EndingSectorsPerSecond( 
            /* [in] */ LONG value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EndingSectorsPerSecond( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BytesPerSector( 
            /* [in] */ LONG value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BytesPerSector( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WriteInProgress( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteEngine2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWriteEngine2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWriteEngine2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWriteEngine2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWriteEngine2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteSection )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ __RPC__in_opt IStream *data,
            /* [in] */ LONG startingBlockAddress,
            /* [in] */ LONG numberOfBlocks);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CancelWrite )( 
            __RPC__in IWriteEngine2 * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Recorder )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2Ex *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recorder )( 
            __RPC__in IWriteEngine2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2Ex **value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseStreamingWrite12 )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseStreamingWrite12 )( 
            __RPC__in IWriteEngine2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartingSectorsPerSecond )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ LONG value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartingSectorsPerSecond )( 
            __RPC__in IWriteEngine2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_EndingSectorsPerSecond )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ LONG value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndingSectorsPerSecond )( 
            __RPC__in IWriteEngine2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BytesPerSector )( 
            __RPC__in IWriteEngine2 * This,
            /* [in] */ LONG value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BytesPerSector )( 
            __RPC__in IWriteEngine2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteInProgress )( 
            __RPC__in IWriteEngine2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        END_INTERFACE
    } IWriteEngine2Vtbl;

    interface IWriteEngine2
    {
        CONST_VTBL struct IWriteEngine2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteEngine2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWriteEngine2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWriteEngine2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWriteEngine2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWriteEngine2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWriteEngine2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWriteEngine2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWriteEngine2_WriteSection(This,data,startingBlockAddress,numberOfBlocks)	\
    ( (This)->lpVtbl -> WriteSection(This,data,startingBlockAddress,numberOfBlocks) ) 

#define IWriteEngine2_CancelWrite(This)	\
    ( (This)->lpVtbl -> CancelWrite(This) ) 

#define IWriteEngine2_put_Recorder(This,value)	\
    ( (This)->lpVtbl -> put_Recorder(This,value) ) 

#define IWriteEngine2_get_Recorder(This,value)	\
    ( (This)->lpVtbl -> get_Recorder(This,value) ) 

#define IWriteEngine2_put_UseStreamingWrite12(This,value)	\
    ( (This)->lpVtbl -> put_UseStreamingWrite12(This,value) ) 

#define IWriteEngine2_get_UseStreamingWrite12(This,value)	\
    ( (This)->lpVtbl -> get_UseStreamingWrite12(This,value) ) 

#define IWriteEngine2_put_StartingSectorsPerSecond(This,value)	\
    ( (This)->lpVtbl -> put_StartingSectorsPerSecond(This,value) ) 

#define IWriteEngine2_get_StartingSectorsPerSecond(This,value)	\
    ( (This)->lpVtbl -> get_StartingSectorsPerSecond(This,value) ) 

#define IWriteEngine2_put_EndingSectorsPerSecond(This,value)	\
    ( (This)->lpVtbl -> put_EndingSectorsPerSecond(This,value) ) 

#define IWriteEngine2_get_EndingSectorsPerSecond(This,value)	\
    ( (This)->lpVtbl -> get_EndingSectorsPerSecond(This,value) ) 

#define IWriteEngine2_put_BytesPerSector(This,value)	\
    ( (This)->lpVtbl -> put_BytesPerSector(This,value) ) 

#define IWriteEngine2_get_BytesPerSector(This,value)	\
    ( (This)->lpVtbl -> get_BytesPerSector(This,value) ) 

#define IWriteEngine2_get_WriteInProgress(This,value)	\
    ( (This)->lpVtbl -> get_WriteInProgress(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWriteEngine2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0005 */
/* [local] */ 

#define DISPID_IWRITEENGINE2EVENTARGS_STARTLBA             0x100
#define DISPID_IWRITEENGINE2EVENTARGS_SECTORCOUNT          0x101
#define DISPID_IWRITEENGINE2EVENTARGS_LASTREADLBA          0x102
#define DISPID_IWRITEENGINE2EVENTARGS_LASTWRITTENLBA       0x103
#define DISPID_IWRITEENGINE2EVENTARGS_TOTALDEVICEBUFFER    0x104
#define DISPID_IWRITEENGINE2EVENTARGS_USEDDEVICEBUFFER     0x105
#define DISPID_IWRITEENGINE2EVENTARGS_TOTALSYSTEMBUFFER    0x106
#define DISPID_IWRITEENGINE2EVENTARGS_USEDSYSTEMBUFFER     0x107
#define DISPID_IWRITEENGINE2EVENTARGS_FREESYSTEMBUFFER     0x108


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0005_v0_0_s_ifspec;

#ifndef __IWriteEngine2EventArgs_INTERFACE_DEFINED__
#define __IWriteEngine2EventArgs_INTERFACE_DEFINED__

/* interface IWriteEngine2EventArgs */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IWriteEngine2EventArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354136-7F64-5B0F-8F00-5D77AFBE261E")
    IWriteEngine2EventArgs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartLba( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SectorCount( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastReadLba( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastWrittenLba( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalSystemBuffer( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsedSystemBuffer( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FreeSystemBuffer( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteEngine2EventArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWriteEngine2EventArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWriteEngine2EventArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWriteEngine2EventArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartLba )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SectorCount )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastReadLba )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastWrittenLba )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalSystemBuffer )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedSystemBuffer )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeSystemBuffer )( 
            __RPC__in IWriteEngine2EventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        END_INTERFACE
    } IWriteEngine2EventArgsVtbl;

    interface IWriteEngine2EventArgs
    {
        CONST_VTBL struct IWriteEngine2EventArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteEngine2EventArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWriteEngine2EventArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWriteEngine2EventArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWriteEngine2EventArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWriteEngine2EventArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWriteEngine2EventArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWriteEngine2EventArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWriteEngine2EventArgs_get_StartLba(This,value)	\
    ( (This)->lpVtbl -> get_StartLba(This,value) ) 

#define IWriteEngine2EventArgs_get_SectorCount(This,value)	\
    ( (This)->lpVtbl -> get_SectorCount(This,value) ) 

#define IWriteEngine2EventArgs_get_LastReadLba(This,value)	\
    ( (This)->lpVtbl -> get_LastReadLba(This,value) ) 

#define IWriteEngine2EventArgs_get_LastWrittenLba(This,value)	\
    ( (This)->lpVtbl -> get_LastWrittenLba(This,value) ) 

#define IWriteEngine2EventArgs_get_TotalSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_TotalSystemBuffer(This,value) ) 

#define IWriteEngine2EventArgs_get_UsedSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_UsedSystemBuffer(This,value) ) 

#define IWriteEngine2EventArgs_get_FreeSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_FreeSystemBuffer(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWriteEngine2EventArgs_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0006 */
/* [local] */ 

#define DISPID_DWRITEENGINE2EVENTS_UPDATE 0x100


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0006_v0_0_s_ifspec;

#ifndef __DWriteEngine2Events_INTERFACE_DEFINED__
#define __DWriteEngine2Events_INTERFACE_DEFINED__

/* interface DWriteEngine2Events */
/* [helpstring][unique][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_DWriteEngine2Events;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354137-7F64-5B0F-8F00-5D77AFBE261E")
    DWriteEngine2Events : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in_opt IDispatch *progress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DWriteEngine2EventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DWriteEngine2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DWriteEngine2Events * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DWriteEngine2Events * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DWriteEngine2Events * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DWriteEngine2Events * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DWriteEngine2Events * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DWriteEngine2Events * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            __RPC__in DWriteEngine2Events * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in_opt IDispatch *progress);
        
        END_INTERFACE
    } DWriteEngine2EventsVtbl;

    interface DWriteEngine2Events
    {
        CONST_VTBL struct DWriteEngine2EventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DWriteEngine2Events_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DWriteEngine2Events_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DWriteEngine2Events_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DWriteEngine2Events_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DWriteEngine2Events_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DWriteEngine2Events_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DWriteEngine2Events_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DWriteEngine2Events_Update(This,object,progress)	\
    ( (This)->lpVtbl -> Update(This,object,progress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DWriteEngine2Events_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0007 */
/* [local] */ 

#define DISPID_IDISCFORMAT2_RECORDERSUPPORTED        0x800
#define DISPID_IDISCFORMAT2_MEDIASUPPORTED           0x801
#define DISPID_IDISCFORMAT2_MEDIAPHYSICALLYBLANK     0x700
#define DISPID_IDISCFORMAT2_MEDIAHEURISTICALLYBLANK  0x701
#define DISPID_IDISCFORMAT2_SUPPORTEDMEDIATYPES      0x702


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0007_v0_0_s_ifspec;

#ifndef __IDiscFormat2_INTERFACE_DEFINED__
#define __IDiscFormat2_INTERFACE_DEFINED__

/* interface IDiscFormat2 */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscFormat2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354152-8F64-5B0F-8F00-5D77AFBE261E")
    IDiscFormat2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsRecorderSupported( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsCurrentMediaSupported( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaPhysicallyBlank( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaHeuristicallyBlank( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedMediaTypes( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscFormat2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscFormat2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscFormat2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscFormat2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscFormat2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscFormat2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscFormat2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscFormat2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsRecorderSupported )( 
            __RPC__in IDiscFormat2 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsCurrentMediaSupported )( 
            __RPC__in IDiscFormat2 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaPhysicallyBlank )( 
            __RPC__in IDiscFormat2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaHeuristicallyBlank )( 
            __RPC__in IDiscFormat2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedMediaTypes )( 
            __RPC__in IDiscFormat2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        END_INTERFACE
    } IDiscFormat2Vtbl;

    interface IDiscFormat2
    {
        CONST_VTBL struct IDiscFormat2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscFormat2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscFormat2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscFormat2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscFormat2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscFormat2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscFormat2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscFormat2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscFormat2_IsRecorderSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsRecorderSupported(This,recorder,value) ) 

#define IDiscFormat2_IsCurrentMediaSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsCurrentMediaSupported(This,recorder,value) ) 

#define IDiscFormat2_get_MediaPhysicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaPhysicallyBlank(This,value) ) 

#define IDiscFormat2_get_MediaHeuristicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaHeuristicallyBlank(This,value) ) 

#define IDiscFormat2_get_SupportedMediaTypes(This,value)	\
    ( (This)->lpVtbl -> get_SupportedMediaTypes(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscFormat2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0008 */
/* [local] */ 

#define DISPID_IDISCFORMAT2ERASE_RECORDER            0x100
#define DISPID_IDISCFORMAT2ERASE_FULLERASE           0x101
#define DISPID_IDISCFORMAT2ERASE_MEDIATYPE           0x102
#define DISPID_IDISCFORMAT2ERASE_CLIENTNAME          0x103
#define DISPID_IDISCFORMAT2ERASE_ERASEMEDIA          0x201


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0008_v0_0_s_ifspec;

#ifndef __IDiscFormat2Erase_INTERFACE_DEFINED__
#define __IDiscFormat2Erase_INTERFACE_DEFINED__

/* interface IDiscFormat2Erase */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscFormat2Erase;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354156-8F64-5B0F-8F00-5D77AFBE261E")
    IDiscFormat2Erase : public IDiscFormat2
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Recorder( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recorder( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FullErase( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FullErase( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPhysicalMediaType( 
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ClientName( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClientName( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EraseMedia( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscFormat2EraseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscFormat2Erase * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscFormat2Erase * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscFormat2Erase * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsRecorderSupported )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsCurrentMediaSupported )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaPhysicallyBlank )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaHeuristicallyBlank )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedMediaTypes )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Recorder )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recorder )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FullErase )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullErase )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPhysicalMediaType )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientName )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientName )( 
            __RPC__in IDiscFormat2Erase * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *EraseMedia )( 
            __RPC__in IDiscFormat2Erase * This);
        
        END_INTERFACE
    } IDiscFormat2EraseVtbl;

    interface IDiscFormat2Erase
    {
        CONST_VTBL struct IDiscFormat2EraseVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscFormat2Erase_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscFormat2Erase_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscFormat2Erase_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscFormat2Erase_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscFormat2Erase_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscFormat2Erase_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscFormat2Erase_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscFormat2Erase_IsRecorderSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsRecorderSupported(This,recorder,value) ) 

#define IDiscFormat2Erase_IsCurrentMediaSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsCurrentMediaSupported(This,recorder,value) ) 

#define IDiscFormat2Erase_get_MediaPhysicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaPhysicallyBlank(This,value) ) 

#define IDiscFormat2Erase_get_MediaHeuristicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaHeuristicallyBlank(This,value) ) 

#define IDiscFormat2Erase_get_SupportedMediaTypes(This,value)	\
    ( (This)->lpVtbl -> get_SupportedMediaTypes(This,value) ) 


#define IDiscFormat2Erase_put_Recorder(This,value)	\
    ( (This)->lpVtbl -> put_Recorder(This,value) ) 

#define IDiscFormat2Erase_get_Recorder(This,value)	\
    ( (This)->lpVtbl -> get_Recorder(This,value) ) 

#define IDiscFormat2Erase_put_FullErase(This,value)	\
    ( (This)->lpVtbl -> put_FullErase(This,value) ) 

#define IDiscFormat2Erase_get_FullErase(This,value)	\
    ( (This)->lpVtbl -> get_FullErase(This,value) ) 

#define IDiscFormat2Erase_get_CurrentPhysicalMediaType(This,value)	\
    ( (This)->lpVtbl -> get_CurrentPhysicalMediaType(This,value) ) 

#define IDiscFormat2Erase_put_ClientName(This,value)	\
    ( (This)->lpVtbl -> put_ClientName(This,value) ) 

#define IDiscFormat2Erase_get_ClientName(This,value)	\
    ( (This)->lpVtbl -> get_ClientName(This,value) ) 

#define IDiscFormat2Erase_EraseMedia(This)	\
    ( (This)->lpVtbl -> EraseMedia(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscFormat2Erase_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0009 */
/* [local] */ 

#define DISPID_IDISCFORMAT2ERASEEVENTS_UPDATE 0x200


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0009_v0_0_s_ifspec;

#ifndef __DDiscFormat2EraseEvents_INTERFACE_DEFINED__
#define __DDiscFormat2EraseEvents_INTERFACE_DEFINED__

/* interface DDiscFormat2EraseEvents */
/* [helpstring][unique][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_DDiscFormat2EraseEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2735413A-7F64-5B0F-8F00-5D77AFBE261E")
    DDiscFormat2EraseEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ LONG elapsedSeconds,
            /* [in] */ LONG estimatedTotalSeconds) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DDiscFormat2EraseEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DDiscFormat2EraseEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DDiscFormat2EraseEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DDiscFormat2EraseEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DDiscFormat2EraseEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DDiscFormat2EraseEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DDiscFormat2EraseEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DDiscFormat2EraseEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            __RPC__in DDiscFormat2EraseEvents * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ LONG elapsedSeconds,
            /* [in] */ LONG estimatedTotalSeconds);
        
        END_INTERFACE
    } DDiscFormat2EraseEventsVtbl;

    interface DDiscFormat2EraseEvents
    {
        CONST_VTBL struct DDiscFormat2EraseEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DDiscFormat2EraseEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DDiscFormat2EraseEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DDiscFormat2EraseEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DDiscFormat2EraseEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DDiscFormat2EraseEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DDiscFormat2EraseEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DDiscFormat2EraseEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DDiscFormat2EraseEvents_Update(This,object,elapsedSeconds,estimatedTotalSeconds)	\
    ( (This)->lpVtbl -> Update(This,object,elapsedSeconds,estimatedTotalSeconds) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DDiscFormat2EraseEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0010 */
/* [local] */ 

#define DISPID_IDISCFORMAT2DATA_RECORDER                         0x100
#define DISPID_IDISCFORMAT2DATA_BUFFERUNDERRUNFREEDISABLED       0x101
#define DISPID_IDISCFORMAT2DATA_POSTGAPALREADYINIMAGE            0x104
#define DISPID_IDISCFORMAT2DATA_CURRENTMEDIASTATUS               0x106
#define DISPID_IDISCFORMAT2DATA_WRITEPROTECTSTATUS               0x107
#define DISPID_IDISCFORMAT2DATA_TOTALSECTORS                     0x108
#define DISPID_IDISCFORMAT2DATA_FREESECTORS                      0x109
#define DISPID_IDISCFORMAT2DATA_NEXTWRITABLEADDRESS              0x10A
#define DISPID_IDISCFORMAT2DATA_STARTSECTOROFPREVIOUSSESSION     0x10B
#define DISPID_IDISCFORMAT2DATA_LASTSECTOROFPREVIOUSSESSION      0x10C
#define DISPID_IDISCFORMAT2DATA_FORCEMEDIATOBECLOSED             0x10D
#define DISPID_IDISCFORMAT2DATA_DISABLEDVDCOMPATIBILITYMODE      0x10E
#define DISPID_IDISCFORMAT2DATA_CURRENTMEDIATYPE                 0x10F
#define DISPID_IDISCFORMAT2DATA_CLIENTNAME                       0x110
#define DISPID_IDISCFORMAT2DATA_REQUESTEDWRITESPEED              0x111
#define DISPID_IDISCFORMAT2DATA_REQUESTEDROTATIONTYPEISPURECAV   0x112
#define DISPID_IDISCFORMAT2DATA_CURRENTWRITESPEED                0x113
#define DISPID_IDISCFORMAT2DATA_CURRENTROTATIONTYPEISPURECAV     0x114
#define DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDS             0x115
#define DISPID_IDISCFORMAT2DATA_SUPPORTEDWRITESPEEDDESCRIPTORS   0x116
#define DISPID_IDISCFORMAT2DATA_FORCEOVERWRITE                   0x117
#define DISPID_IDISCFORMAT2DATA_MUTLISESSIONINTERFACES           0x118
#define DISPID_IDISCFORMAT2DATA_WRITE                            0x200
#define DISPID_IDISCFORMAT2DATA_CANCELWRITE                      0x201
#define DISPID_IDISCFORMAT2DATA_SETWRITESPEED                    0x202


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0010_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0010_v0_0_s_ifspec;

#ifndef __IDiscFormat2Data_INTERFACE_DEFINED__
#define __IDiscFormat2Data_INTERFACE_DEFINED__

/* interface IDiscFormat2Data */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscFormat2Data;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354153-9F64-5B0F-8F00-5D77AFBE261E")
    IDiscFormat2Data : public IDiscFormat2
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Recorder( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recorder( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BufferUnderrunFreeDisabled( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BufferUnderrunFreeDisabled( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PostgapAlreadyInImage( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PostgapAlreadyInImage( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentMediaStatus( 
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_DATA_MEDIA_STATE *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WriteProtectStatus( 
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_WRITE_PROTECT_STATE *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalSectorsOnMedia( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FreeSectorsOnMedia( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NextWritableAddress( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartAddressOfPreviousSession( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastWrittenAddressOfPreviousSession( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ForceMediaToBeClosed( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ForceMediaToBeClosed( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DisableConsumerDvdCompatibilityMode( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisableConsumerDvdCompatibilityMode( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPhysicalMediaType( 
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ClientName( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClientName( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedWriteSpeed( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedRotationTypeIsPureCAV( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentWriteSpeed( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentRotationTypeIsPureCAV( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedWriteSpeeds( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeeds) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedWriteSpeedDescriptors( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeedDescriptors) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ForceOverwrite( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ForceOverwrite( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MultisessionInterfaces( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ __RPC__in_opt IStream *data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelWrite( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetWriteSpeed( 
            /* [in] */ LONG RequestedSectorsPerSecond,
            /* [in] */ VARIANT_BOOL RotationTypeIsPureCAV) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscFormat2DataVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscFormat2Data * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscFormat2Data * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscFormat2Data * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscFormat2Data * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsRecorderSupported )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsCurrentMediaSupported )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaPhysicallyBlank )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaHeuristicallyBlank )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedMediaTypes )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Recorder )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recorder )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BufferUnderrunFreeDisabled )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferUnderrunFreeDisabled )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PostgapAlreadyInImage )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PostgapAlreadyInImage )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentMediaStatus )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_DATA_MEDIA_STATE *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteProtectStatus )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_WRITE_PROTECT_STATE *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalSectorsOnMedia )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeSectorsOnMedia )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NextWritableAddress )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartAddressOfPreviousSession )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastWrittenAddressOfPreviousSession )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ForceMediaToBeClosed )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForceMediaToBeClosed )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisableConsumerDvdCompatibilityMode )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisableConsumerDvdCompatibilityMode )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPhysicalMediaType )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientName )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientName )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedWriteSpeed )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedRotationTypeIsPureCAV )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentWriteSpeed )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentRotationTypeIsPureCAV )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedWriteSpeeds )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeeds);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedWriteSpeedDescriptors )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeedDescriptors);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ForceOverwrite )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ForceOverwrite )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MultisessionInterfaces )( 
            __RPC__in IDiscFormat2Data * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ __RPC__in_opt IStream *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CancelWrite )( 
            __RPC__in IDiscFormat2Data * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetWriteSpeed )( 
            __RPC__in IDiscFormat2Data * This,
            /* [in] */ LONG RequestedSectorsPerSecond,
            /* [in] */ VARIANT_BOOL RotationTypeIsPureCAV);
        
        END_INTERFACE
    } IDiscFormat2DataVtbl;

    interface IDiscFormat2Data
    {
        CONST_VTBL struct IDiscFormat2DataVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscFormat2Data_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscFormat2Data_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscFormat2Data_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscFormat2Data_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscFormat2Data_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscFormat2Data_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscFormat2Data_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscFormat2Data_IsRecorderSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsRecorderSupported(This,recorder,value) ) 

#define IDiscFormat2Data_IsCurrentMediaSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsCurrentMediaSupported(This,recorder,value) ) 

#define IDiscFormat2Data_get_MediaPhysicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaPhysicallyBlank(This,value) ) 

#define IDiscFormat2Data_get_MediaHeuristicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaHeuristicallyBlank(This,value) ) 

#define IDiscFormat2Data_get_SupportedMediaTypes(This,value)	\
    ( (This)->lpVtbl -> get_SupportedMediaTypes(This,value) ) 


#define IDiscFormat2Data_put_Recorder(This,value)	\
    ( (This)->lpVtbl -> put_Recorder(This,value) ) 

#define IDiscFormat2Data_get_Recorder(This,value)	\
    ( (This)->lpVtbl -> get_Recorder(This,value) ) 

#define IDiscFormat2Data_put_BufferUnderrunFreeDisabled(This,value)	\
    ( (This)->lpVtbl -> put_BufferUnderrunFreeDisabled(This,value) ) 

#define IDiscFormat2Data_get_BufferUnderrunFreeDisabled(This,value)	\
    ( (This)->lpVtbl -> get_BufferUnderrunFreeDisabled(This,value) ) 

#define IDiscFormat2Data_put_PostgapAlreadyInImage(This,value)	\
    ( (This)->lpVtbl -> put_PostgapAlreadyInImage(This,value) ) 

#define IDiscFormat2Data_get_PostgapAlreadyInImage(This,value)	\
    ( (This)->lpVtbl -> get_PostgapAlreadyInImage(This,value) ) 

#define IDiscFormat2Data_get_CurrentMediaStatus(This,value)	\
    ( (This)->lpVtbl -> get_CurrentMediaStatus(This,value) ) 

#define IDiscFormat2Data_get_WriteProtectStatus(This,value)	\
    ( (This)->lpVtbl -> get_WriteProtectStatus(This,value) ) 

#define IDiscFormat2Data_get_TotalSectorsOnMedia(This,value)	\
    ( (This)->lpVtbl -> get_TotalSectorsOnMedia(This,value) ) 

#define IDiscFormat2Data_get_FreeSectorsOnMedia(This,value)	\
    ( (This)->lpVtbl -> get_FreeSectorsOnMedia(This,value) ) 

#define IDiscFormat2Data_get_NextWritableAddress(This,value)	\
    ( (This)->lpVtbl -> get_NextWritableAddress(This,value) ) 

#define IDiscFormat2Data_get_StartAddressOfPreviousSession(This,value)	\
    ( (This)->lpVtbl -> get_StartAddressOfPreviousSession(This,value) ) 

#define IDiscFormat2Data_get_LastWrittenAddressOfPreviousSession(This,value)	\
    ( (This)->lpVtbl -> get_LastWrittenAddressOfPreviousSession(This,value) ) 

#define IDiscFormat2Data_put_ForceMediaToBeClosed(This,value)	\
    ( (This)->lpVtbl -> put_ForceMediaToBeClosed(This,value) ) 

#define IDiscFormat2Data_get_ForceMediaToBeClosed(This,value)	\
    ( (This)->lpVtbl -> get_ForceMediaToBeClosed(This,value) ) 

#define IDiscFormat2Data_put_DisableConsumerDvdCompatibilityMode(This,value)	\
    ( (This)->lpVtbl -> put_DisableConsumerDvdCompatibilityMode(This,value) ) 

#define IDiscFormat2Data_get_DisableConsumerDvdCompatibilityMode(This,value)	\
    ( (This)->lpVtbl -> get_DisableConsumerDvdCompatibilityMode(This,value) ) 

#define IDiscFormat2Data_get_CurrentPhysicalMediaType(This,value)	\
    ( (This)->lpVtbl -> get_CurrentPhysicalMediaType(This,value) ) 

#define IDiscFormat2Data_put_ClientName(This,value)	\
    ( (This)->lpVtbl -> put_ClientName(This,value) ) 

#define IDiscFormat2Data_get_ClientName(This,value)	\
    ( (This)->lpVtbl -> get_ClientName(This,value) ) 

#define IDiscFormat2Data_get_RequestedWriteSpeed(This,value)	\
    ( (This)->lpVtbl -> get_RequestedWriteSpeed(This,value) ) 

#define IDiscFormat2Data_get_RequestedRotationTypeIsPureCAV(This,value)	\
    ( (This)->lpVtbl -> get_RequestedRotationTypeIsPureCAV(This,value) ) 

#define IDiscFormat2Data_get_CurrentWriteSpeed(This,value)	\
    ( (This)->lpVtbl -> get_CurrentWriteSpeed(This,value) ) 

#define IDiscFormat2Data_get_CurrentRotationTypeIsPureCAV(This,value)	\
    ( (This)->lpVtbl -> get_CurrentRotationTypeIsPureCAV(This,value) ) 

#define IDiscFormat2Data_get_SupportedWriteSpeeds(This,supportedSpeeds)	\
    ( (This)->lpVtbl -> get_SupportedWriteSpeeds(This,supportedSpeeds) ) 

#define IDiscFormat2Data_get_SupportedWriteSpeedDescriptors(This,supportedSpeedDescriptors)	\
    ( (This)->lpVtbl -> get_SupportedWriteSpeedDescriptors(This,supportedSpeedDescriptors) ) 

#define IDiscFormat2Data_put_ForceOverwrite(This,value)	\
    ( (This)->lpVtbl -> put_ForceOverwrite(This,value) ) 

#define IDiscFormat2Data_get_ForceOverwrite(This,value)	\
    ( (This)->lpVtbl -> get_ForceOverwrite(This,value) ) 

#define IDiscFormat2Data_get_MultisessionInterfaces(This,value)	\
    ( (This)->lpVtbl -> get_MultisessionInterfaces(This,value) ) 

#define IDiscFormat2Data_Write(This,data)	\
    ( (This)->lpVtbl -> Write(This,data) ) 

#define IDiscFormat2Data_CancelWrite(This)	\
    ( (This)->lpVtbl -> CancelWrite(This) ) 

#define IDiscFormat2Data_SetWriteSpeed(This,RequestedSectorsPerSecond,RotationTypeIsPureCAV)	\
    ( (This)->lpVtbl -> SetWriteSpeed(This,RequestedSectorsPerSecond,RotationTypeIsPureCAV) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscFormat2Data_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0011 */
/* [local] */ 

#define DISPID_DDISCFORMAT2DATAEVENTS_UPDATE  0x200


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0011_v0_0_s_ifspec;

#ifndef __DDiscFormat2DataEvents_INTERFACE_DEFINED__
#define __DDiscFormat2DataEvents_INTERFACE_DEFINED__

/* interface DDiscFormat2DataEvents */
/* [helpstring][unique][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_DDiscFormat2DataEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2735413C-7F64-5B0F-8F00-5D77AFBE261E")
    DDiscFormat2DataEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in_opt IDispatch *progress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DDiscFormat2DataEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DDiscFormat2DataEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DDiscFormat2DataEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DDiscFormat2DataEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DDiscFormat2DataEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DDiscFormat2DataEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DDiscFormat2DataEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DDiscFormat2DataEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            __RPC__in DDiscFormat2DataEvents * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in_opt IDispatch *progress);
        
        END_INTERFACE
    } DDiscFormat2DataEventsVtbl;

    interface DDiscFormat2DataEvents
    {
        CONST_VTBL struct DDiscFormat2DataEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DDiscFormat2DataEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DDiscFormat2DataEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DDiscFormat2DataEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DDiscFormat2DataEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DDiscFormat2DataEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DDiscFormat2DataEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DDiscFormat2DataEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DDiscFormat2DataEvents_Update(This,object,progress)	\
    ( (This)->lpVtbl -> Update(This,object,progress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DDiscFormat2DataEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0012 */
/* [local] */ 

#define DISPID_IDISCFORMAT2DATAEVENTARGS_ELAPSEDTIME            0x300
#define DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDREMAININGTIME 0x301
#define DISPID_IDISCFORMAT2DATAEVENTARGS_ESTIMATEDTOTALTIME     0x302
#define DISPID_IDISCFORMAT2DATAEVENTARGS_CURRENTACTION          0x303


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0012_v0_0_s_ifspec;

#ifndef __IDiscFormat2DataEventArgs_INTERFACE_DEFINED__
#define __IDiscFormat2DataEventArgs_INTERFACE_DEFINED__

/* interface IDiscFormat2DataEventArgs */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscFormat2DataEventArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2735413D-7F64-5B0F-8F00-5D77AFBE261E")
    IDiscFormat2DataEventArgs : public IWriteEngine2EventArgs
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ElapsedTime( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemainingTime( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalTime( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAction( 
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_DATA_WRITE_ACTION *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscFormat2DataEventArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscFormat2DataEventArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscFormat2DataEventArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscFormat2DataEventArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartLba )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SectorCount )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastReadLba )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastWrittenLba )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalSystemBuffer )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedSystemBuffer )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeSystemBuffer )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ElapsedTime )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemainingTime )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalTime )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAction )( 
            __RPC__in IDiscFormat2DataEventArgs * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_DATA_WRITE_ACTION *value);
        
        END_INTERFACE
    } IDiscFormat2DataEventArgsVtbl;

    interface IDiscFormat2DataEventArgs
    {
        CONST_VTBL struct IDiscFormat2DataEventArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscFormat2DataEventArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscFormat2DataEventArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscFormat2DataEventArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscFormat2DataEventArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscFormat2DataEventArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscFormat2DataEventArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscFormat2DataEventArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscFormat2DataEventArgs_get_StartLba(This,value)	\
    ( (This)->lpVtbl -> get_StartLba(This,value) ) 

#define IDiscFormat2DataEventArgs_get_SectorCount(This,value)	\
    ( (This)->lpVtbl -> get_SectorCount(This,value) ) 

#define IDiscFormat2DataEventArgs_get_LastReadLba(This,value)	\
    ( (This)->lpVtbl -> get_LastReadLba(This,value) ) 

#define IDiscFormat2DataEventArgs_get_LastWrittenLba(This,value)	\
    ( (This)->lpVtbl -> get_LastWrittenLba(This,value) ) 

#define IDiscFormat2DataEventArgs_get_TotalSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_TotalSystemBuffer(This,value) ) 

#define IDiscFormat2DataEventArgs_get_UsedSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_UsedSystemBuffer(This,value) ) 

#define IDiscFormat2DataEventArgs_get_FreeSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_FreeSystemBuffer(This,value) ) 


#define IDiscFormat2DataEventArgs_get_ElapsedTime(This,value)	\
    ( (This)->lpVtbl -> get_ElapsedTime(This,value) ) 

#define IDiscFormat2DataEventArgs_get_RemainingTime(This,value)	\
    ( (This)->lpVtbl -> get_RemainingTime(This,value) ) 

#define IDiscFormat2DataEventArgs_get_TotalTime(This,value)	\
    ( (This)->lpVtbl -> get_TotalTime(This,value) ) 

#define IDiscFormat2DataEventArgs_get_CurrentAction(This,value)	\
    ( (This)->lpVtbl -> get_CurrentAction(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscFormat2DataEventArgs_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0013 */
/* [local] */ 

#define DISPID_IDISCFORMAT2TAO_RECORDER                          0x100
#define DISPID_IDISCFORMAT2TAO_BUFFERUNDERRUNFREEDISABLED        0x102
#define DISPID_IDISCFORMAT2TAO_NUMBEROFEXISTINGTRACKS            0x103
#define DISPID_IDISCFORMAT2TAO_TOTALSECTORSONMEDIA               0x104
#define DISPID_IDISCFORMAT2TAO_FREESECTORSONMEDIA                0x105
#define DISPID_IDISCFORMAT2TAO_USEDSECTORSONMEDIA                0x106
#define DISPID_IDISCFORMAT2TAO_DONOTFINALIZEMEDIA                0x107
#define DISPID_IDISCFORMAT2TAO_EXPECTEDTABLEOFCONTENTS           0x10A
#define DISPID_IDISCFORMAT2TAO_CURRENTMEDIATYPE                  0x10B
#define DISPID_IDISCFORMAT2TAO_CLIENTNAME                        0x10E
#define DISPID_IDISCFORMAT2TAO_REQUESTEDWRITESPEED               0x10F
#define DISPID_IDISCFORMAT2TAO_REQUESTEDROTATIONTYPEISPURECAV    0x110
#define DISPID_IDISCFORMAT2TAO_CURRENTWRITESPEED                 0x111
#define DISPID_IDISCFORMAT2TAO_CURRENTROTATIONTYPEISPURECAV      0x112
#define DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDS              0x113
#define DISPID_IDISCFORMAT2TAO_SUPPORTEDWRITESPEEDDESCRIPTORS    0x114
#define DISPID_IDISCFORMAT2TAO_PREPAREMEDIA                      0x200
#define DISPID_IDISCFORMAT2TAO_ADDAUDIOTRACK                     0x201
#define DISPID_IDISCFORMAT2TAO_CANCELADDTRACK                    0x202
#define DISPID_IDISCFORMAT2TAO_FINISHMEDIA                       0x203
#define DISPID_IDISCFORMAT2TAO_SETWRITESPEED                     0x204


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0013_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0013_v0_0_s_ifspec;

#ifndef __IDiscFormat2TrackAtOnce_INTERFACE_DEFINED__
#define __IDiscFormat2TrackAtOnce_INTERFACE_DEFINED__

/* interface IDiscFormat2TrackAtOnce */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscFormat2TrackAtOnce;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354154-8F64-5B0F-8F00-5D77AFBE261E")
    IDiscFormat2TrackAtOnce : public IDiscFormat2
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PrepareMedia( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddAudioTrack( 
            /* [in] */ __RPC__in_opt IStream *data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelAddTrack( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseMedia( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetWriteSpeed( 
            /* [in] */ LONG RequestedSectorsPerSecond,
            /* [in] */ VARIANT_BOOL RotationTypeIsPureCAV) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Recorder( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recorder( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BufferUnderrunFreeDisabled( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BufferUnderrunFreeDisabled( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfExistingTracks( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalSectorsOnMedia( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FreeSectorsOnMedia( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsedSectorsOnMedia( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DoNotFinalizeMedia( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DoNotFinalizeMedia( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExpectedTableOfContents( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPhysicalMediaType( 
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ClientName( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClientName( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedWriteSpeed( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedRotationTypeIsPureCAV( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentWriteSpeed( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentRotationTypeIsPureCAV( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedWriteSpeeds( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeeds) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedWriteSpeedDescriptors( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeedDescriptors) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscFormat2TrackAtOnceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscFormat2TrackAtOnce * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscFormat2TrackAtOnce * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscFormat2TrackAtOnce * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsRecorderSupported )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsCurrentMediaSupported )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaPhysicallyBlank )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaHeuristicallyBlank )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedMediaTypes )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PrepareMedia )( 
            __RPC__in IDiscFormat2TrackAtOnce * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddAudioTrack )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ __RPC__in_opt IStream *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CancelAddTrack )( 
            __RPC__in IDiscFormat2TrackAtOnce * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseMedia )( 
            __RPC__in IDiscFormat2TrackAtOnce * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetWriteSpeed )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ LONG RequestedSectorsPerSecond,
            /* [in] */ VARIANT_BOOL RotationTypeIsPureCAV);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Recorder )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recorder )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BufferUnderrunFreeDisabled )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferUnderrunFreeDisabled )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfExistingTracks )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalSectorsOnMedia )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeSectorsOnMedia )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedSectorsOnMedia )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DoNotFinalizeMedia )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DoNotFinalizeMedia )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpectedTableOfContents )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPhysicalMediaType )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientName )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientName )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedWriteSpeed )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedRotationTypeIsPureCAV )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentWriteSpeed )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentRotationTypeIsPureCAV )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedWriteSpeeds )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeeds);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedWriteSpeedDescriptors )( 
            __RPC__in IDiscFormat2TrackAtOnce * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeedDescriptors);
        
        END_INTERFACE
    } IDiscFormat2TrackAtOnceVtbl;

    interface IDiscFormat2TrackAtOnce
    {
        CONST_VTBL struct IDiscFormat2TrackAtOnceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscFormat2TrackAtOnce_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscFormat2TrackAtOnce_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscFormat2TrackAtOnce_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscFormat2TrackAtOnce_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscFormat2TrackAtOnce_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscFormat2TrackAtOnce_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscFormat2TrackAtOnce_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscFormat2TrackAtOnce_IsRecorderSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsRecorderSupported(This,recorder,value) ) 

#define IDiscFormat2TrackAtOnce_IsCurrentMediaSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsCurrentMediaSupported(This,recorder,value) ) 

#define IDiscFormat2TrackAtOnce_get_MediaPhysicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaPhysicallyBlank(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_MediaHeuristicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaHeuristicallyBlank(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_SupportedMediaTypes(This,value)	\
    ( (This)->lpVtbl -> get_SupportedMediaTypes(This,value) ) 


#define IDiscFormat2TrackAtOnce_PrepareMedia(This)	\
    ( (This)->lpVtbl -> PrepareMedia(This) ) 

#define IDiscFormat2TrackAtOnce_AddAudioTrack(This,data)	\
    ( (This)->lpVtbl -> AddAudioTrack(This,data) ) 

#define IDiscFormat2TrackAtOnce_CancelAddTrack(This)	\
    ( (This)->lpVtbl -> CancelAddTrack(This) ) 

#define IDiscFormat2TrackAtOnce_ReleaseMedia(This)	\
    ( (This)->lpVtbl -> ReleaseMedia(This) ) 

#define IDiscFormat2TrackAtOnce_SetWriteSpeed(This,RequestedSectorsPerSecond,RotationTypeIsPureCAV)	\
    ( (This)->lpVtbl -> SetWriteSpeed(This,RequestedSectorsPerSecond,RotationTypeIsPureCAV) ) 

#define IDiscFormat2TrackAtOnce_put_Recorder(This,value)	\
    ( (This)->lpVtbl -> put_Recorder(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_Recorder(This,value)	\
    ( (This)->lpVtbl -> get_Recorder(This,value) ) 

#define IDiscFormat2TrackAtOnce_put_BufferUnderrunFreeDisabled(This,value)	\
    ( (This)->lpVtbl -> put_BufferUnderrunFreeDisabled(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_BufferUnderrunFreeDisabled(This,value)	\
    ( (This)->lpVtbl -> get_BufferUnderrunFreeDisabled(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_NumberOfExistingTracks(This,value)	\
    ( (This)->lpVtbl -> get_NumberOfExistingTracks(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_TotalSectorsOnMedia(This,value)	\
    ( (This)->lpVtbl -> get_TotalSectorsOnMedia(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_FreeSectorsOnMedia(This,value)	\
    ( (This)->lpVtbl -> get_FreeSectorsOnMedia(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_UsedSectorsOnMedia(This,value)	\
    ( (This)->lpVtbl -> get_UsedSectorsOnMedia(This,value) ) 

#define IDiscFormat2TrackAtOnce_put_DoNotFinalizeMedia(This,value)	\
    ( (This)->lpVtbl -> put_DoNotFinalizeMedia(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_DoNotFinalizeMedia(This,value)	\
    ( (This)->lpVtbl -> get_DoNotFinalizeMedia(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_ExpectedTableOfContents(This,value)	\
    ( (This)->lpVtbl -> get_ExpectedTableOfContents(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_CurrentPhysicalMediaType(This,value)	\
    ( (This)->lpVtbl -> get_CurrentPhysicalMediaType(This,value) ) 

#define IDiscFormat2TrackAtOnce_put_ClientName(This,value)	\
    ( (This)->lpVtbl -> put_ClientName(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_ClientName(This,value)	\
    ( (This)->lpVtbl -> get_ClientName(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_RequestedWriteSpeed(This,value)	\
    ( (This)->lpVtbl -> get_RequestedWriteSpeed(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_RequestedRotationTypeIsPureCAV(This,value)	\
    ( (This)->lpVtbl -> get_RequestedRotationTypeIsPureCAV(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_CurrentWriteSpeed(This,value)	\
    ( (This)->lpVtbl -> get_CurrentWriteSpeed(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_CurrentRotationTypeIsPureCAV(This,value)	\
    ( (This)->lpVtbl -> get_CurrentRotationTypeIsPureCAV(This,value) ) 

#define IDiscFormat2TrackAtOnce_get_SupportedWriteSpeeds(This,supportedSpeeds)	\
    ( (This)->lpVtbl -> get_SupportedWriteSpeeds(This,supportedSpeeds) ) 

#define IDiscFormat2TrackAtOnce_get_SupportedWriteSpeedDescriptors(This,supportedSpeedDescriptors)	\
    ( (This)->lpVtbl -> get_SupportedWriteSpeedDescriptors(This,supportedSpeedDescriptors) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscFormat2TrackAtOnce_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0014 */
/* [local] */ 

#define DISPID_DDISCFORMAT2TAOEVENTS_UPDATE  0x200


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0014_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0014_v0_0_s_ifspec;

#ifndef __DDiscFormat2TrackAtOnceEvents_INTERFACE_DEFINED__
#define __DDiscFormat2TrackAtOnceEvents_INTERFACE_DEFINED__

/* interface DDiscFormat2TrackAtOnceEvents */
/* [helpstring][unique][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_DDiscFormat2TrackAtOnceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2735413F-7F64-5B0F-8F00-5D77AFBE261E")
    DDiscFormat2TrackAtOnceEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in_opt IDispatch *progress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DDiscFormat2TrackAtOnceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DDiscFormat2TrackAtOnceEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DDiscFormat2TrackAtOnceEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DDiscFormat2TrackAtOnceEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DDiscFormat2TrackAtOnceEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DDiscFormat2TrackAtOnceEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DDiscFormat2TrackAtOnceEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DDiscFormat2TrackAtOnceEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            __RPC__in DDiscFormat2TrackAtOnceEvents * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in_opt IDispatch *progress);
        
        END_INTERFACE
    } DDiscFormat2TrackAtOnceEventsVtbl;

    interface DDiscFormat2TrackAtOnceEvents
    {
        CONST_VTBL struct DDiscFormat2TrackAtOnceEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DDiscFormat2TrackAtOnceEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DDiscFormat2TrackAtOnceEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DDiscFormat2TrackAtOnceEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DDiscFormat2TrackAtOnceEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DDiscFormat2TrackAtOnceEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DDiscFormat2TrackAtOnceEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DDiscFormat2TrackAtOnceEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DDiscFormat2TrackAtOnceEvents_Update(This,object,progress)	\
    ( (This)->lpVtbl -> Update(This,object,progress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DDiscFormat2TrackAtOnceEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0015 */
/* [local] */ 

#define DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTTRACKNUMBER     0x300
#define DISPID_IDISCFORMAT2TAOEVENTARGS_CURRENTACTION          0x301
#define DISPID_IDISCFORMAT2TAOEVENTARGS_ELAPSEDTIME            0x302
#define DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDREMAININGTIME 0x303
#define DISPID_IDISCFORMAT2TAOEVENTARGS_ESTIMATEDTOTALTIME     0x304


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0015_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0015_v0_0_s_ifspec;

#ifndef __IDiscFormat2TrackAtOnceEventArgs_INTERFACE_DEFINED__
#define __IDiscFormat2TrackAtOnceEventArgs_INTERFACE_DEFINED__

/* interface IDiscFormat2TrackAtOnceEventArgs */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscFormat2TrackAtOnceEventArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354140-7F64-5B0F-8F00-5D77AFBE261E")
    IDiscFormat2TrackAtOnceEventArgs : public IWriteEngine2EventArgs
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentTrackNumber( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAction( 
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_TAO_WRITE_ACTION *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ElapsedTime( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemainingTime( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscFormat2TrackAtOnceEventArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscFormat2TrackAtOnceEventArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartLba )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SectorCount )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastReadLba )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastWrittenLba )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalSystemBuffer )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedSystemBuffer )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeSystemBuffer )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentTrackNumber )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAction )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_TAO_WRITE_ACTION *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ElapsedTime )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemainingTime )( 
            __RPC__in IDiscFormat2TrackAtOnceEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        END_INTERFACE
    } IDiscFormat2TrackAtOnceEventArgsVtbl;

    interface IDiscFormat2TrackAtOnceEventArgs
    {
        CONST_VTBL struct IDiscFormat2TrackAtOnceEventArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscFormat2TrackAtOnceEventArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscFormat2TrackAtOnceEventArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscFormat2TrackAtOnceEventArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscFormat2TrackAtOnceEventArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscFormat2TrackAtOnceEventArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscFormat2TrackAtOnceEventArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscFormat2TrackAtOnceEventArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscFormat2TrackAtOnceEventArgs_get_StartLba(This,value)	\
    ( (This)->lpVtbl -> get_StartLba(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_SectorCount(This,value)	\
    ( (This)->lpVtbl -> get_SectorCount(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_LastReadLba(This,value)	\
    ( (This)->lpVtbl -> get_LastReadLba(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_LastWrittenLba(This,value)	\
    ( (This)->lpVtbl -> get_LastWrittenLba(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_TotalSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_TotalSystemBuffer(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_UsedSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_UsedSystemBuffer(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_FreeSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_FreeSystemBuffer(This,value) ) 


#define IDiscFormat2TrackAtOnceEventArgs_get_CurrentTrackNumber(This,value)	\
    ( (This)->lpVtbl -> get_CurrentTrackNumber(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_CurrentAction(This,value)	\
    ( (This)->lpVtbl -> get_CurrentAction(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_ElapsedTime(This,value)	\
    ( (This)->lpVtbl -> get_ElapsedTime(This,value) ) 

#define IDiscFormat2TrackAtOnceEventArgs_get_RemainingTime(This,value)	\
    ( (This)->lpVtbl -> get_RemainingTime(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscFormat2TrackAtOnceEventArgs_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0016 */
/* [local] */ 

#define DISPID_IDISCFORMAT2RAWCD_RECORDER                        0x100
#define DISPID_IDISCFORMAT2RAWCD_BUFFERUNDERRUNFREEDISABLED      0x102
#define DISPID_IDISCFORMAT2RAWCD_STARTOFNEXTSESSION              0x103
#define DISPID_IDISCFORMAT2RAWCD_LASTPOSSIBLESTARTOFLEADOUT      0x104
#define DISPID_IDISCFORMAT2RAWCD_CURRENTMEDIATYPE                0x105
#define DISPID_IDISCFORMAT2RAWCD_SUPPORTEDDATASECTORTYPES        0x108
#define DISPID_IDISCFORMAT2RAWCD_REQUESTEDDATASECTORTYPE         0x109
#define DISPID_IDISCFORMAT2RAWCD_CLIENTNAME                      0x10A
#define DISPID_IDISCFORMAT2RAWCD_REQUESTEDWRITESPEED             0x10B
#define DISPID_IDISCFORMAT2RAWCD_REQUESTEDROTATIONTYPEISPURECAV  0x10C
#define DISPID_IDISCFORMAT2RAWCD_CURRENTWRITESPEED               0x10D
#define DISPID_IDISCFORMAT2RAWCD_CURRENTROTATIONTYPEISPURECAV    0x10E
#define DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDS            0x10F
#define DISPID_IDISCFORMAT2RAWCD_SUPPORTEDWRITESPEEDDESCRIPTORS  0x110
#define DISPID_IDISCFORMAT2RAWCD_PREPAREMEDIA                    0x200
#define DISPID_IDISCFORMAT2RAWCD_WRITEMEDIA                      0x201
#define DISPID_IDISCFORMAT2RAWCD_WRITEMEDIAWITHVALIDATION        0x202
#define DISPID_IDISCFORMAT2RAWCD_CANCELWRITE                     0x203
#define DISPID_IDISCFORMAT2RAWCD_RELEASEMEDIA                    0x204
#define DISPID_IDISCFORMAT2RAWCD_SETWRITESPEED                   0x205


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0016_v0_0_s_ifspec;

#ifndef __IDiscFormat2RawCD_INTERFACE_DEFINED__
#define __IDiscFormat2RawCD_INTERFACE_DEFINED__

/* interface IDiscFormat2RawCD */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscFormat2RawCD;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354155-8F64-5B0F-8F00-5D77AFBE261E")
    IDiscFormat2RawCD : public IDiscFormat2
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE PrepareMedia( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteMedia( 
            /* [in] */ __RPC__in_opt IStream *data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE WriteMedia2( 
            /* [in] */ __RPC__in_opt IStream *data,
            /* [in] */ LONG streamLeadInSectors) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CancelWrite( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseMedia( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetWriteSpeed( 
            /* [in] */ LONG RequestedSectorsPerSecond,
            /* [in] */ VARIANT_BOOL RotationTypeIsPureCAV) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Recorder( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Recorder( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BufferUnderrunFreeDisabled( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BufferUnderrunFreeDisabled( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartOfNextSession( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastPossibleStartOfLeadout( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPhysicalMediaType( 
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedSectorTypes( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_RequestedSectorType( 
            /* [in] */ IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedSectorType( 
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ClientName( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ClientName( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedWriteSpeed( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestedRotationTypeIsPureCAV( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentWriteSpeed( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentRotationTypeIsPureCAV( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedWriteSpeeds( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeeds) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SupportedWriteSpeedDescriptors( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeedDescriptors) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscFormat2RawCDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscFormat2RawCD * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscFormat2RawCD * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscFormat2RawCD * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsRecorderSupported )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IsCurrentMediaSupported )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *recorder,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaPhysicallyBlank )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaHeuristicallyBlank )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedMediaTypes )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *PrepareMedia )( 
            __RPC__in IDiscFormat2RawCD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteMedia )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ __RPC__in_opt IStream *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *WriteMedia2 )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ __RPC__in_opt IStream *data,
            /* [in] */ LONG streamLeadInSectors);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CancelWrite )( 
            __RPC__in IDiscFormat2RawCD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseMedia )( 
            __RPC__in IDiscFormat2RawCD * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetWriteSpeed )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ LONG RequestedSectorsPerSecond,
            /* [in] */ VARIANT_BOOL RotationTypeIsPureCAV);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Recorder )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Recorder )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BufferUnderrunFreeDisabled )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BufferUnderrunFreeDisabled )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartOfNextSession )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastPossibleStartOfLeadout )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentPhysicalMediaType )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedSectorTypes )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_RequestedSectorType )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedSectorType )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ClientName )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ClientName )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedWriteSpeed )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestedRotationTypeIsPureCAV )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentWriteSpeed )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentRotationTypeIsPureCAV )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedWriteSpeeds )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeeds);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SupportedWriteSpeedDescriptors )( 
            __RPC__in IDiscFormat2RawCD * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *supportedSpeedDescriptors);
        
        END_INTERFACE
    } IDiscFormat2RawCDVtbl;

    interface IDiscFormat2RawCD
    {
        CONST_VTBL struct IDiscFormat2RawCDVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscFormat2RawCD_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscFormat2RawCD_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscFormat2RawCD_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscFormat2RawCD_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscFormat2RawCD_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscFormat2RawCD_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscFormat2RawCD_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscFormat2RawCD_IsRecorderSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsRecorderSupported(This,recorder,value) ) 

#define IDiscFormat2RawCD_IsCurrentMediaSupported(This,recorder,value)	\
    ( (This)->lpVtbl -> IsCurrentMediaSupported(This,recorder,value) ) 

#define IDiscFormat2RawCD_get_MediaPhysicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaPhysicallyBlank(This,value) ) 

#define IDiscFormat2RawCD_get_MediaHeuristicallyBlank(This,value)	\
    ( (This)->lpVtbl -> get_MediaHeuristicallyBlank(This,value) ) 

#define IDiscFormat2RawCD_get_SupportedMediaTypes(This,value)	\
    ( (This)->lpVtbl -> get_SupportedMediaTypes(This,value) ) 


#define IDiscFormat2RawCD_PrepareMedia(This)	\
    ( (This)->lpVtbl -> PrepareMedia(This) ) 

#define IDiscFormat2RawCD_WriteMedia(This,data)	\
    ( (This)->lpVtbl -> WriteMedia(This,data) ) 

#define IDiscFormat2RawCD_WriteMedia2(This,data,streamLeadInSectors)	\
    ( (This)->lpVtbl -> WriteMedia2(This,data,streamLeadInSectors) ) 

#define IDiscFormat2RawCD_CancelWrite(This)	\
    ( (This)->lpVtbl -> CancelWrite(This) ) 

#define IDiscFormat2RawCD_ReleaseMedia(This)	\
    ( (This)->lpVtbl -> ReleaseMedia(This) ) 

#define IDiscFormat2RawCD_SetWriteSpeed(This,RequestedSectorsPerSecond,RotationTypeIsPureCAV)	\
    ( (This)->lpVtbl -> SetWriteSpeed(This,RequestedSectorsPerSecond,RotationTypeIsPureCAV) ) 

#define IDiscFormat2RawCD_put_Recorder(This,value)	\
    ( (This)->lpVtbl -> put_Recorder(This,value) ) 

#define IDiscFormat2RawCD_get_Recorder(This,value)	\
    ( (This)->lpVtbl -> get_Recorder(This,value) ) 

#define IDiscFormat2RawCD_put_BufferUnderrunFreeDisabled(This,value)	\
    ( (This)->lpVtbl -> put_BufferUnderrunFreeDisabled(This,value) ) 

#define IDiscFormat2RawCD_get_BufferUnderrunFreeDisabled(This,value)	\
    ( (This)->lpVtbl -> get_BufferUnderrunFreeDisabled(This,value) ) 

#define IDiscFormat2RawCD_get_StartOfNextSession(This,value)	\
    ( (This)->lpVtbl -> get_StartOfNextSession(This,value) ) 

#define IDiscFormat2RawCD_get_LastPossibleStartOfLeadout(This,value)	\
    ( (This)->lpVtbl -> get_LastPossibleStartOfLeadout(This,value) ) 

#define IDiscFormat2RawCD_get_CurrentPhysicalMediaType(This,value)	\
    ( (This)->lpVtbl -> get_CurrentPhysicalMediaType(This,value) ) 

#define IDiscFormat2RawCD_get_SupportedSectorTypes(This,value)	\
    ( (This)->lpVtbl -> get_SupportedSectorTypes(This,value) ) 

#define IDiscFormat2RawCD_put_RequestedSectorType(This,value)	\
    ( (This)->lpVtbl -> put_RequestedSectorType(This,value) ) 

#define IDiscFormat2RawCD_get_RequestedSectorType(This,value)	\
    ( (This)->lpVtbl -> get_RequestedSectorType(This,value) ) 

#define IDiscFormat2RawCD_put_ClientName(This,value)	\
    ( (This)->lpVtbl -> put_ClientName(This,value) ) 

#define IDiscFormat2RawCD_get_ClientName(This,value)	\
    ( (This)->lpVtbl -> get_ClientName(This,value) ) 

#define IDiscFormat2RawCD_get_RequestedWriteSpeed(This,value)	\
    ( (This)->lpVtbl -> get_RequestedWriteSpeed(This,value) ) 

#define IDiscFormat2RawCD_get_RequestedRotationTypeIsPureCAV(This,value)	\
    ( (This)->lpVtbl -> get_RequestedRotationTypeIsPureCAV(This,value) ) 

#define IDiscFormat2RawCD_get_CurrentWriteSpeed(This,value)	\
    ( (This)->lpVtbl -> get_CurrentWriteSpeed(This,value) ) 

#define IDiscFormat2RawCD_get_CurrentRotationTypeIsPureCAV(This,value)	\
    ( (This)->lpVtbl -> get_CurrentRotationTypeIsPureCAV(This,value) ) 

#define IDiscFormat2RawCD_get_SupportedWriteSpeeds(This,supportedSpeeds)	\
    ( (This)->lpVtbl -> get_SupportedWriteSpeeds(This,supportedSpeeds) ) 

#define IDiscFormat2RawCD_get_SupportedWriteSpeedDescriptors(This,supportedSpeedDescriptors)	\
    ( (This)->lpVtbl -> get_SupportedWriteSpeedDescriptors(This,supportedSpeedDescriptors) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscFormat2RawCD_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0017 */
/* [local] */ 

#define DISPID_DDISCFORMAT2RAWCDEVENTS_UPDATE  0x200


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0017_v0_0_s_ifspec;

#ifndef __DDiscFormat2RawCDEvents_INTERFACE_DEFINED__
#define __DDiscFormat2RawCDEvents_INTERFACE_DEFINED__

/* interface DDiscFormat2RawCDEvents */
/* [helpstring][unique][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_DDiscFormat2RawCDEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354142-7F64-5B0F-8F00-5D77AFBE261E")
    DDiscFormat2RawCDEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in_opt IDispatch *progress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DDiscFormat2RawCDEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DDiscFormat2RawCDEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DDiscFormat2RawCDEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DDiscFormat2RawCDEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DDiscFormat2RawCDEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DDiscFormat2RawCDEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DDiscFormat2RawCDEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DDiscFormat2RawCDEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            __RPC__in DDiscFormat2RawCDEvents * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in_opt IDispatch *progress);
        
        END_INTERFACE
    } DDiscFormat2RawCDEventsVtbl;

    interface DDiscFormat2RawCDEvents
    {
        CONST_VTBL struct DDiscFormat2RawCDEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DDiscFormat2RawCDEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DDiscFormat2RawCDEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DDiscFormat2RawCDEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DDiscFormat2RawCDEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DDiscFormat2RawCDEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DDiscFormat2RawCDEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DDiscFormat2RawCDEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DDiscFormat2RawCDEvents_Update(This,object,progress)	\
    ( (This)->lpVtbl -> Update(This,object,progress) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DDiscFormat2RawCDEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0018 */
/* [local] */ 

#define DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTTRACKNUMBER     0x300
#define DISPID_IDISCFORMAT2RAWCDEVENTARGS_CURRENTACTION          0x301
#define DISPID_IDISCFORMAT2RAWCDEVENTARGS_ELAPSEDTIME            0x300
#define DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDREMAININGTIME 0x301
#define DISPID_IDISCFORMAT2RAWCDEVENTARGS_ESTIMATEDTOTALTIME     0x302


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0018_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0018_v0_0_s_ifspec;

#ifndef __IDiscFormat2RawCDEventArgs_INTERFACE_DEFINED__
#define __IDiscFormat2RawCDEventArgs_INTERFACE_DEFINED__

/* interface IDiscFormat2RawCDEventArgs */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IDiscFormat2RawCDEventArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354143-7F64-5B0F-8F00-5D77AFBE261E")
    IDiscFormat2RawCDEventArgs : public IWriteEngine2EventArgs
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CurrentAction( 
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_RAW_CD_WRITE_ACTION *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ElapsedTime( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RemainingTime( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscFormat2RawCDEventArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDiscFormat2RawCDEventArgs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartLba )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SectorCount )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastReadLba )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastWrittenLba )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalSystemBuffer )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedSystemBuffer )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeSystemBuffer )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentAction )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_RAW_CD_WRITE_ACTION *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ElapsedTime )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RemainingTime )( 
            __RPC__in IDiscFormat2RawCDEventArgs * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        END_INTERFACE
    } IDiscFormat2RawCDEventArgsVtbl;

    interface IDiscFormat2RawCDEventArgs
    {
        CONST_VTBL struct IDiscFormat2RawCDEventArgsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscFormat2RawCDEventArgs_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscFormat2RawCDEventArgs_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscFormat2RawCDEventArgs_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscFormat2RawCDEventArgs_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDiscFormat2RawCDEventArgs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDiscFormat2RawCDEventArgs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDiscFormat2RawCDEventArgs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDiscFormat2RawCDEventArgs_get_StartLba(This,value)	\
    ( (This)->lpVtbl -> get_StartLba(This,value) ) 

#define IDiscFormat2RawCDEventArgs_get_SectorCount(This,value)	\
    ( (This)->lpVtbl -> get_SectorCount(This,value) ) 

#define IDiscFormat2RawCDEventArgs_get_LastReadLba(This,value)	\
    ( (This)->lpVtbl -> get_LastReadLba(This,value) ) 

#define IDiscFormat2RawCDEventArgs_get_LastWrittenLba(This,value)	\
    ( (This)->lpVtbl -> get_LastWrittenLba(This,value) ) 

#define IDiscFormat2RawCDEventArgs_get_TotalSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_TotalSystemBuffer(This,value) ) 

#define IDiscFormat2RawCDEventArgs_get_UsedSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_UsedSystemBuffer(This,value) ) 

#define IDiscFormat2RawCDEventArgs_get_FreeSystemBuffer(This,value)	\
    ( (This)->lpVtbl -> get_FreeSystemBuffer(This,value) ) 


#define IDiscFormat2RawCDEventArgs_get_CurrentAction(This,value)	\
    ( (This)->lpVtbl -> get_CurrentAction(This,value) ) 

#define IDiscFormat2RawCDEventArgs_get_ElapsedTime(This,value)	\
    ( (This)->lpVtbl -> get_ElapsedTime(This,value) ) 

#define IDiscFormat2RawCDEventArgs_get_RemainingTime(This,value)	\
    ( (This)->lpVtbl -> get_RemainingTime(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscFormat2RawCDEventArgs_INTERFACE_DEFINED__ */


#ifndef __IBurnVerification_INTERFACE_DEFINED__
#define __IBurnVerification_INTERFACE_DEFINED__

/* interface IBurnVerification */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IBurnVerification;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D2FFD834-958B-426d-8470-2A13879C6A91")
    IBurnVerification : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BurnVerificationLevel( 
            /* [in] */ IMAPI_BURN_VERIFICATION_LEVEL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BurnVerificationLevel( 
            /* [retval][ref][out] */ __RPC__out IMAPI_BURN_VERIFICATION_LEVEL *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBurnVerificationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBurnVerification * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBurnVerification * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBurnVerification * This);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BurnVerificationLevel )( 
            __RPC__in IBurnVerification * This,
            /* [in] */ IMAPI_BURN_VERIFICATION_LEVEL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BurnVerificationLevel )( 
            __RPC__in IBurnVerification * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_BURN_VERIFICATION_LEVEL *value);
        
        END_INTERFACE
    } IBurnVerificationVtbl;

    interface IBurnVerification
    {
        CONST_VTBL struct IBurnVerificationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBurnVerification_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBurnVerification_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBurnVerification_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBurnVerification_put_BurnVerificationLevel(This,value)	\
    ( (This)->lpVtbl -> put_BurnVerificationLevel(This,value) ) 

#define IBurnVerification_get_BurnVerificationLevel(This,value)	\
    ( (This)->lpVtbl -> get_BurnVerificationLevel(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBurnVerification_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0020 */
/* [local] */ 

#define IMAPI_SECTORS_PER_SECOND_AT_1X_CD      75
#define IMAPI_SECTORS_PER_SECOND_AT_1X_DVD     680
#define IMAPI_SECTORS_PER_SECOND_AT_1X_BD      2195
#define IMAPI_SECTORS_PER_SECOND_AT_1X_HD_DVD  4568


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0020_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0020_v0_0_s_ifspec;

#ifndef __IWriteSpeedDescriptor_INTERFACE_DEFINED__
#define __IWriteSpeedDescriptor_INTERFACE_DEFINED__

/* interface IWriteSpeedDescriptor */
/* [helpstring][unique][uuid][dual][object] */ 


EXTERN_C const IID IID_IWriteSpeedDescriptor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354144-7F64-5B0F-8F00-5D77AFBE261E")
    IWriteSpeedDescriptor : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaType( 
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RotationTypeIsPureCAV( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WriteSpeed( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteSpeedDescriptorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IWriteSpeedDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IWriteSpeedDescriptor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IWriteSpeedDescriptor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IWriteSpeedDescriptor * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IWriteSpeedDescriptor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IWriteSpeedDescriptor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IWriteSpeedDescriptor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaType )( 
            __RPC__in IWriteSpeedDescriptor * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_MEDIA_PHYSICAL_TYPE *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RotationTypeIsPureCAV )( 
            __RPC__in IWriteSpeedDescriptor * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteSpeed )( 
            __RPC__in IWriteSpeedDescriptor * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        END_INTERFACE
    } IWriteSpeedDescriptorVtbl;

    interface IWriteSpeedDescriptor
    {
        CONST_VTBL struct IWriteSpeedDescriptorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteSpeedDescriptor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWriteSpeedDescriptor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWriteSpeedDescriptor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWriteSpeedDescriptor_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IWriteSpeedDescriptor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IWriteSpeedDescriptor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IWriteSpeedDescriptor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IWriteSpeedDescriptor_get_MediaType(This,value)	\
    ( (This)->lpVtbl -> get_MediaType(This,value) ) 

#define IWriteSpeedDescriptor_get_RotationTypeIsPureCAV(This,value)	\
    ( (This)->lpVtbl -> get_RotationTypeIsPureCAV(This,value) ) 

#define IWriteSpeedDescriptor_get_WriteSpeed(This,value)	\
    ( (This)->lpVtbl -> get_WriteSpeed(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWriteSpeedDescriptor_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0021 */
/* [local] */ 

#define DISPID_IMULTISESSION_SUPPORTEDONCURRENTMEDIA 0x100
#define DISPID_IMULTISESSION_INUSE                   0x101
#define DISPID_IMULTISESSION_IMPORTRECORDER          0x102


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0021_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0021_v0_0_s_ifspec;

#ifndef __IMultisession_INTERFACE_DEFINED__
#define __IMultisession_INTERFACE_DEFINED__

/* interface IMultisession */
/* [helpstring][unique][uuid][dual][object] */ 


EXTERN_C const IID IID_IMultisession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354150-7F64-5B0F-8F00-5D77AFBE261E")
    IMultisession : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsSupportedOnCurrentMediaState( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_InUse( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InUse( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImportRecorder( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultisessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMultisession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMultisession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMultisession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IMultisession * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IMultisession * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IMultisession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMultisession * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSupportedOnCurrentMediaState )( 
            __RPC__in IMultisession * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InUse )( 
            __RPC__in IMultisession * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InUse )( 
            __RPC__in IMultisession * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImportRecorder )( 
            __RPC__in IMultisession * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value);
        
        END_INTERFACE
    } IMultisessionVtbl;

    interface IMultisession
    {
        CONST_VTBL struct IMultisessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultisession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMultisession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMultisession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMultisession_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMultisession_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMultisession_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMultisession_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMultisession_get_IsSupportedOnCurrentMediaState(This,value)	\
    ( (This)->lpVtbl -> get_IsSupportedOnCurrentMediaState(This,value) ) 

#define IMultisession_put_InUse(This,value)	\
    ( (This)->lpVtbl -> put_InUse(This,value) ) 

#define IMultisession_get_InUse(This,value)	\
    ( (This)->lpVtbl -> get_InUse(This,value) ) 

#define IMultisession_get_ImportRecorder(This,value)	\
    ( (This)->lpVtbl -> get_ImportRecorder(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMultisession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0022 */
/* [local] */ 

#define DISPID_IMULTISESSION_FIRSTDATASESSION             0x200
#define DISPID_IMULTISESSION_STARTSECTOROFPREVIOUSSESSION 0x201
#define DISPID_IMULTISESSION_LASTSECTOROFPREVIOUSSESSION  0x202
#define DISPID_IMULTISESSION_NEXTWRITABLEADDRESS          0x203
#define DISPID_IMULTISESSION_FREESECTORS                  0x204
#define DISPID_IMULTISESSION_WRITEUNITSIZE                0x205


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0022_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0022_v0_0_s_ifspec;

#ifndef __IMultisessionSequential_INTERFACE_DEFINED__
#define __IMultisessionSequential_INTERFACE_DEFINED__

/* interface IMultisessionSequential */
/* [helpstring][unique][uuid][dual][object] */ 


EXTERN_C const IID IID_IMultisessionSequential;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354151-7F64-5B0F-8F00-5D77AFBE261E")
    IMultisessionSequential : public IMultisession
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsFirstDataSession( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartAddressOfPreviousSession( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastWrittenAddressOfPreviousSession( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NextWritableAddress( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FreeSectorsOnMedia( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultisessionSequentialVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMultisessionSequential * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMultisessionSequential * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMultisessionSequential * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IMultisessionSequential * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IMultisessionSequential * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IMultisessionSequential * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMultisessionSequential * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSupportedOnCurrentMediaState )( 
            __RPC__in IMultisessionSequential * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InUse )( 
            __RPC__in IMultisessionSequential * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InUse )( 
            __RPC__in IMultisessionSequential * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImportRecorder )( 
            __RPC__in IMultisessionSequential * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFirstDataSession )( 
            __RPC__in IMultisessionSequential * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartAddressOfPreviousSession )( 
            __RPC__in IMultisessionSequential * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastWrittenAddressOfPreviousSession )( 
            __RPC__in IMultisessionSequential * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NextWritableAddress )( 
            __RPC__in IMultisessionSequential * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeSectorsOnMedia )( 
            __RPC__in IMultisessionSequential * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        END_INTERFACE
    } IMultisessionSequentialVtbl;

    interface IMultisessionSequential
    {
        CONST_VTBL struct IMultisessionSequentialVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultisessionSequential_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMultisessionSequential_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMultisessionSequential_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMultisessionSequential_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMultisessionSequential_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMultisessionSequential_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMultisessionSequential_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMultisessionSequential_get_IsSupportedOnCurrentMediaState(This,value)	\
    ( (This)->lpVtbl -> get_IsSupportedOnCurrentMediaState(This,value) ) 

#define IMultisessionSequential_put_InUse(This,value)	\
    ( (This)->lpVtbl -> put_InUse(This,value) ) 

#define IMultisessionSequential_get_InUse(This,value)	\
    ( (This)->lpVtbl -> get_InUse(This,value) ) 

#define IMultisessionSequential_get_ImportRecorder(This,value)	\
    ( (This)->lpVtbl -> get_ImportRecorder(This,value) ) 


#define IMultisessionSequential_get_IsFirstDataSession(This,value)	\
    ( (This)->lpVtbl -> get_IsFirstDataSession(This,value) ) 

#define IMultisessionSequential_get_StartAddressOfPreviousSession(This,value)	\
    ( (This)->lpVtbl -> get_StartAddressOfPreviousSession(This,value) ) 

#define IMultisessionSequential_get_LastWrittenAddressOfPreviousSession(This,value)	\
    ( (This)->lpVtbl -> get_LastWrittenAddressOfPreviousSession(This,value) ) 

#define IMultisessionSequential_get_NextWritableAddress(This,value)	\
    ( (This)->lpVtbl -> get_NextWritableAddress(This,value) ) 

#define IMultisessionSequential_get_FreeSectorsOnMedia(This,value)	\
    ( (This)->lpVtbl -> get_FreeSectorsOnMedia(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMultisessionSequential_INTERFACE_DEFINED__ */


#ifndef __IMultisessionSequential2_INTERFACE_DEFINED__
#define __IMultisessionSequential2_INTERFACE_DEFINED__

/* interface IMultisessionSequential2 */
/* [helpstring][unique][uuid][dual][object] */ 


EXTERN_C const IID IID_IMultisessionSequential2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B507CA22-2204-11DD-966A-001AA01BBC58")
    IMultisessionSequential2 : public IMultisessionSequential
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WriteUnitSize( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultisessionSequential2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMultisessionSequential2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMultisessionSequential2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMultisessionSequential2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSupportedOnCurrentMediaState )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InUse )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InUse )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImportRecorder )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsFirstDataSession )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartAddressOfPreviousSession )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastWrittenAddressOfPreviousSession )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NextWritableAddress )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeSectorsOnMedia )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteUnitSize )( 
            __RPC__in IMultisessionSequential2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        END_INTERFACE
    } IMultisessionSequential2Vtbl;

    interface IMultisessionSequential2
    {
        CONST_VTBL struct IMultisessionSequential2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultisessionSequential2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMultisessionSequential2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMultisessionSequential2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMultisessionSequential2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMultisessionSequential2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMultisessionSequential2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMultisessionSequential2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMultisessionSequential2_get_IsSupportedOnCurrentMediaState(This,value)	\
    ( (This)->lpVtbl -> get_IsSupportedOnCurrentMediaState(This,value) ) 

#define IMultisessionSequential2_put_InUse(This,value)	\
    ( (This)->lpVtbl -> put_InUse(This,value) ) 

#define IMultisessionSequential2_get_InUse(This,value)	\
    ( (This)->lpVtbl -> get_InUse(This,value) ) 

#define IMultisessionSequential2_get_ImportRecorder(This,value)	\
    ( (This)->lpVtbl -> get_ImportRecorder(This,value) ) 


#define IMultisessionSequential2_get_IsFirstDataSession(This,value)	\
    ( (This)->lpVtbl -> get_IsFirstDataSession(This,value) ) 

#define IMultisessionSequential2_get_StartAddressOfPreviousSession(This,value)	\
    ( (This)->lpVtbl -> get_StartAddressOfPreviousSession(This,value) ) 

#define IMultisessionSequential2_get_LastWrittenAddressOfPreviousSession(This,value)	\
    ( (This)->lpVtbl -> get_LastWrittenAddressOfPreviousSession(This,value) ) 

#define IMultisessionSequential2_get_NextWritableAddress(This,value)	\
    ( (This)->lpVtbl -> get_NextWritableAddress(This,value) ) 

#define IMultisessionSequential2_get_FreeSectorsOnMedia(This,value)	\
    ( (This)->lpVtbl -> get_FreeSectorsOnMedia(This,value) ) 


#define IMultisessionSequential2_get_WriteUnitSize(This,value)	\
    ( (This)->lpVtbl -> get_WriteUnitSize(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMultisessionSequential2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0024 */
/* [local] */ 

#define DISPID_IMULTISESSION_LASTWRITTENADDRESS           0x206
#define DISPID_IMULTISESSION_SECTORSONMEDIA               0x207


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0024_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0024_v0_0_s_ifspec;

#ifndef __IMultisessionRandomWrite_INTERFACE_DEFINED__
#define __IMultisessionRandomWrite_INTERFACE_DEFINED__

/* interface IMultisessionRandomWrite */
/* [helpstring][unique][uuid][dual][object] */ 


EXTERN_C const IID IID_IMultisessionRandomWrite;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B507CA23-2204-11DD-966A-001AA01BBC58")
    IMultisessionRandomWrite : public IMultisession
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WriteUnitSize( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastWrittenAddress( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalSectorsOnMedia( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMultisessionRandomWriteVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMultisessionRandomWrite * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMultisessionRandomWrite * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMultisessionRandomWrite * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsSupportedOnCurrentMediaState )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_InUse )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InUse )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImportRecorder )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IDiscRecorder2 **value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WriteUnitSize )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastWrittenAddress )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalSectorsOnMedia )( 
            __RPC__in IMultisessionRandomWrite * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        END_INTERFACE
    } IMultisessionRandomWriteVtbl;

    interface IMultisessionRandomWrite
    {
        CONST_VTBL struct IMultisessionRandomWriteVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMultisessionRandomWrite_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMultisessionRandomWrite_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMultisessionRandomWrite_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMultisessionRandomWrite_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMultisessionRandomWrite_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMultisessionRandomWrite_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMultisessionRandomWrite_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMultisessionRandomWrite_get_IsSupportedOnCurrentMediaState(This,value)	\
    ( (This)->lpVtbl -> get_IsSupportedOnCurrentMediaState(This,value) ) 

#define IMultisessionRandomWrite_put_InUse(This,value)	\
    ( (This)->lpVtbl -> put_InUse(This,value) ) 

#define IMultisessionRandomWrite_get_InUse(This,value)	\
    ( (This)->lpVtbl -> get_InUse(This,value) ) 

#define IMultisessionRandomWrite_get_ImportRecorder(This,value)	\
    ( (This)->lpVtbl -> get_ImportRecorder(This,value) ) 


#define IMultisessionRandomWrite_get_WriteUnitSize(This,value)	\
    ( (This)->lpVtbl -> get_WriteUnitSize(This,value) ) 

#define IMultisessionRandomWrite_get_LastWrittenAddress(This,value)	\
    ( (This)->lpVtbl -> get_LastWrittenAddress(This,value) ) 

#define IMultisessionRandomWrite_get_TotalSectorsOnMedia(This,value)	\
    ( (This)->lpVtbl -> get_TotalSectorsOnMedia(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMultisessionRandomWrite_INTERFACE_DEFINED__ */


#ifndef __IStreamPseudoRandomBased_INTERFACE_DEFINED__
#define __IStreamPseudoRandomBased_INTERFACE_DEFINED__

/* interface IStreamPseudoRandomBased */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamPseudoRandomBased;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354145-7F64-5B0F-8F00-5D77AFBE261E")
    IStreamPseudoRandomBased : public IStream
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE put_Seed( 
            /* [in] */ ULONG value) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE get_Seed( 
            /* [out] */ __RPC__out ULONG *value) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE put_ExtendedSeed( 
            /* [size_is][in] */ __RPC__in_ecount_full(eCount) ULONG *values,
            /* [in] */ ULONG eCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE get_ExtendedSeed( 
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*eCount) ULONG **values,
            /* [out] */ __RPC__out ULONG *eCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamPseudoRandomBasedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamPseudoRandomBased * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamPseudoRandomBased * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IStreamPseudoRandomBased * This,
            /* [annotation] */ 
            __out_bcount_part(cb, *pcbRead)  void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IStreamPseudoRandomBased * This,
            /* [annotation] */ 
            __in_bcount(cb)  const void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IStreamPseudoRandomBased * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IStreamPseudoRandomBased * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbRead,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            __RPC__in IStreamPseudoRandomBased * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [out] */ __RPC__out STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppstm);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *put_Seed )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [in] */ ULONG value);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *get_Seed )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [out] */ __RPC__out ULONG *value);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *put_ExtendedSeed )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [size_is][in] */ __RPC__in_ecount_full(eCount) ULONG *values,
            /* [in] */ ULONG eCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *get_ExtendedSeed )( 
            __RPC__in IStreamPseudoRandomBased * This,
            /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*eCount) ULONG **values,
            /* [out] */ __RPC__out ULONG *eCount);
        
        END_INTERFACE
    } IStreamPseudoRandomBasedVtbl;

    interface IStreamPseudoRandomBased
    {
        CONST_VTBL struct IStreamPseudoRandomBasedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamPseudoRandomBased_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamPseudoRandomBased_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamPseudoRandomBased_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamPseudoRandomBased_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IStreamPseudoRandomBased_Write(This,pv,cb,pcbWritten)	\
    ( (This)->lpVtbl -> Write(This,pv,cb,pcbWritten) ) 


#define IStreamPseudoRandomBased_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IStreamPseudoRandomBased_SetSize(This,libNewSize)	\
    ( (This)->lpVtbl -> SetSize(This,libNewSize) ) 

#define IStreamPseudoRandomBased_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    ( (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten) ) 

#define IStreamPseudoRandomBased_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IStreamPseudoRandomBased_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IStreamPseudoRandomBased_LockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamPseudoRandomBased_UnlockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamPseudoRandomBased_Stat(This,pstatstg,grfStatFlag)	\
    ( (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag) ) 

#define IStreamPseudoRandomBased_Clone(This,ppstm)	\
    ( (This)->lpVtbl -> Clone(This,ppstm) ) 


#define IStreamPseudoRandomBased_put_Seed(This,value)	\
    ( (This)->lpVtbl -> put_Seed(This,value) ) 

#define IStreamPseudoRandomBased_get_Seed(This,value)	\
    ( (This)->lpVtbl -> get_Seed(This,value) ) 

#define IStreamPseudoRandomBased_put_ExtendedSeed(This,values,eCount)	\
    ( (This)->lpVtbl -> put_ExtendedSeed(This,values,eCount) ) 

#define IStreamPseudoRandomBased_get_ExtendedSeed(This,values,eCount)	\
    ( (This)->lpVtbl -> get_ExtendedSeed(This,values,eCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamPseudoRandomBased_INTERFACE_DEFINED__ */


#ifndef __IStreamConcatenate_INTERFACE_DEFINED__
#define __IStreamConcatenate_INTERFACE_DEFINED__

/* interface IStreamConcatenate */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamConcatenate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354146-7F64-5B0F-8F00-5D77AFBE261E")
    IStreamConcatenate : public IStream
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ __RPC__in_opt IStream *stream1,
            /* [in] */ __RPC__in_opt IStream *stream2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize2( 
            /* [size_is][in] */ __RPC__in_ecount_full(streamCount) IStream **streams,
            /* [in] */ ULONG streamCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Append( 
            /* [in] */ __RPC__in_opt IStream *stream) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Append2( 
            /* [size_is][in] */ __RPC__in_ecount_full(streamCount) IStream **streams,
            /* [in] */ ULONG streamCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamConcatenateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamConcatenate * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamConcatenate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamConcatenate * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IStreamConcatenate * This,
            /* [annotation] */ 
            __out_bcount_part(cb, *pcbRead)  void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IStreamConcatenate * This,
            /* [annotation] */ 
            __in_bcount(cb)  const void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IStreamConcatenate * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            __RPC__in IStreamConcatenate * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IStreamConcatenate * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbRead,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IStreamConcatenate * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            __RPC__in IStreamConcatenate * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            __RPC__in IStreamConcatenate * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            __RPC__in IStreamConcatenate * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            __RPC__in IStreamConcatenate * This,
            /* [out] */ __RPC__out STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IStreamConcatenate * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppstm);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IStreamConcatenate * This,
            /* [in] */ __RPC__in_opt IStream *stream1,
            /* [in] */ __RPC__in_opt IStream *stream2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize2 )( 
            __RPC__in IStreamConcatenate * This,
            /* [size_is][in] */ __RPC__in_ecount_full(streamCount) IStream **streams,
            /* [in] */ ULONG streamCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Append )( 
            __RPC__in IStreamConcatenate * This,
            /* [in] */ __RPC__in_opt IStream *stream);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Append2 )( 
            __RPC__in IStreamConcatenate * This,
            /* [size_is][in] */ __RPC__in_ecount_full(streamCount) IStream **streams,
            /* [in] */ ULONG streamCount);
        
        END_INTERFACE
    } IStreamConcatenateVtbl;

    interface IStreamConcatenate
    {
        CONST_VTBL struct IStreamConcatenateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamConcatenate_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamConcatenate_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamConcatenate_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamConcatenate_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IStreamConcatenate_Write(This,pv,cb,pcbWritten)	\
    ( (This)->lpVtbl -> Write(This,pv,cb,pcbWritten) ) 


#define IStreamConcatenate_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IStreamConcatenate_SetSize(This,libNewSize)	\
    ( (This)->lpVtbl -> SetSize(This,libNewSize) ) 

#define IStreamConcatenate_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    ( (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten) ) 

#define IStreamConcatenate_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IStreamConcatenate_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IStreamConcatenate_LockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamConcatenate_UnlockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamConcatenate_Stat(This,pstatstg,grfStatFlag)	\
    ( (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag) ) 

#define IStreamConcatenate_Clone(This,ppstm)	\
    ( (This)->lpVtbl -> Clone(This,ppstm) ) 


#define IStreamConcatenate_Initialize(This,stream1,stream2)	\
    ( (This)->lpVtbl -> Initialize(This,stream1,stream2) ) 

#define IStreamConcatenate_Initialize2(This,streams,streamCount)	\
    ( (This)->lpVtbl -> Initialize2(This,streams,streamCount) ) 

#define IStreamConcatenate_Append(This,stream)	\
    ( (This)->lpVtbl -> Append(This,stream) ) 

#define IStreamConcatenate_Append2(This,streams,streamCount)	\
    ( (This)->lpVtbl -> Append2(This,streams,streamCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamConcatenate_INTERFACE_DEFINED__ */


#ifndef __IStreamInterleave_INTERFACE_DEFINED__
#define __IStreamInterleave_INTERFACE_DEFINED__

/* interface IStreamInterleave */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IStreamInterleave;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("27354147-7F64-5B0F-8F00-5D77AFBE261E")
    IStreamInterleave : public IStream
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [size_is][in] */ __RPC__in_ecount_full(streamCount) IStream **streams,
            /* [size_is][in] */ __RPC__in_ecount_full(streamCount) ULONG *interleaveSizes,
            /* [range][in] */ __RPC__in_range(1,0x7fffffff) ULONG streamCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStreamInterleaveVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IStreamInterleave * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IStreamInterleave * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IStreamInterleave * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Read )( 
            IStreamInterleave * This,
            /* [annotation] */ 
            __out_bcount_part(cb, *pcbRead)  void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbRead);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Write )( 
            IStreamInterleave * This,
            /* [annotation] */ 
            __in_bcount(cb)  const void *pv,
            /* [in] */ ULONG cb,
            /* [annotation] */ 
            __out_opt  ULONG *pcbWritten);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Seek )( 
            IStreamInterleave * This,
            /* [in] */ LARGE_INTEGER dlibMove,
            /* [in] */ DWORD dwOrigin,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *plibNewPosition);
        
        HRESULT ( STDMETHODCALLTYPE *SetSize )( 
            __RPC__in IStreamInterleave * This,
            /* [in] */ ULARGE_INTEGER libNewSize);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CopyTo )( 
            IStreamInterleave * This,
            /* [unique][in] */ IStream *pstm,
            /* [in] */ ULARGE_INTEGER cb,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbRead,
            /* [annotation] */ 
            __out_opt  ULARGE_INTEGER *pcbWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            __RPC__in IStreamInterleave * This,
            /* [in] */ DWORD grfCommitFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Revert )( 
            __RPC__in IStreamInterleave * This);
        
        HRESULT ( STDMETHODCALLTYPE *LockRegion )( 
            __RPC__in IStreamInterleave * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *UnlockRegion )( 
            __RPC__in IStreamInterleave * This,
            /* [in] */ ULARGE_INTEGER libOffset,
            /* [in] */ ULARGE_INTEGER cb,
            /* [in] */ DWORD dwLockType);
        
        HRESULT ( STDMETHODCALLTYPE *Stat )( 
            __RPC__in IStreamInterleave * This,
            /* [out] */ __RPC__out STATSTG *pstatstg,
            /* [in] */ DWORD grfStatFlag);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IStreamInterleave * This,
            /* [out] */ __RPC__deref_out_opt IStream **ppstm);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            __RPC__in IStreamInterleave * This,
            /* [size_is][in] */ __RPC__in_ecount_full(streamCount) IStream **streams,
            /* [size_is][in] */ __RPC__in_ecount_full(streamCount) ULONG *interleaveSizes,
            /* [range][in] */ __RPC__in_range(1,0x7fffffff) ULONG streamCount);
        
        END_INTERFACE
    } IStreamInterleaveVtbl;

    interface IStreamInterleave
    {
        CONST_VTBL struct IStreamInterleaveVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStreamInterleave_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStreamInterleave_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStreamInterleave_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStreamInterleave_Read(This,pv,cb,pcbRead)	\
    ( (This)->lpVtbl -> Read(This,pv,cb,pcbRead) ) 

#define IStreamInterleave_Write(This,pv,cb,pcbWritten)	\
    ( (This)->lpVtbl -> Write(This,pv,cb,pcbWritten) ) 


#define IStreamInterleave_Seek(This,dlibMove,dwOrigin,plibNewPosition)	\
    ( (This)->lpVtbl -> Seek(This,dlibMove,dwOrigin,plibNewPosition) ) 

#define IStreamInterleave_SetSize(This,libNewSize)	\
    ( (This)->lpVtbl -> SetSize(This,libNewSize) ) 

#define IStreamInterleave_CopyTo(This,pstm,cb,pcbRead,pcbWritten)	\
    ( (This)->lpVtbl -> CopyTo(This,pstm,cb,pcbRead,pcbWritten) ) 

#define IStreamInterleave_Commit(This,grfCommitFlags)	\
    ( (This)->lpVtbl -> Commit(This,grfCommitFlags) ) 

#define IStreamInterleave_Revert(This)	\
    ( (This)->lpVtbl -> Revert(This) ) 

#define IStreamInterleave_LockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> LockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamInterleave_UnlockRegion(This,libOffset,cb,dwLockType)	\
    ( (This)->lpVtbl -> UnlockRegion(This,libOffset,cb,dwLockType) ) 

#define IStreamInterleave_Stat(This,pstatstg,grfStatFlag)	\
    ( (This)->lpVtbl -> Stat(This,pstatstg,grfStatFlag) ) 

#define IStreamInterleave_Clone(This,ppstm)	\
    ( (This)->lpVtbl -> Clone(This,ppstm) ) 


#define IStreamInterleave_Initialize(This,streams,interleaveSizes,streamCount)	\
    ( (This)->lpVtbl -> Initialize(This,streams,interleaveSizes,streamCount) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStreamInterleave_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0028 */
/* [local] */ 

#define DISPID_IRAWCDIMAGECREATOR_CREATERESULTIMAGE        0x200
#define DISPID_IRAWCDIMAGECREATOR_ADDTRACK                 0x201
#define DISPID_IRAWCDIMAGECREATOR_ADDSPECIALPREGAP         0x202
#define DISPID_IRAWCDIMAGECREATOR_ADDSUBCODERWGENERATOR    0x203
#define DISPID_IRAWCDIMAGECREATOR_RESULTINGIMAGETYPE       0x100
#define DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUT           0x101
#define DISPID_IRAWCDIMAGECREATOR_STARTOFLEADOUTLIMIT      0x102
#define DISPID_IRAWCDIMAGECREATOR_DISABLEGAPLESSAUDIO      0x103
#define DISPID_IRAWCDIMAGECREATOR_MEDIACATALOGNUMBER       0x104
#define DISPID_IRAWCDIMAGECREATOR_STARTINGTRACKNUMBER      0x105
#define DISPID_IRAWCDIMAGECREATOR_TRACKINFO                0x106
#define DISPID_IRAWCDIMAGECREATOR_NUMBEROFEXISTINGTRACKS   0x107
#define DISPID_IRAWCDIMAGECREATOR_USEDSECTORSONDISC        0x108
#define DISPID_IRAWCDIMAGECREATOR_EXPECTEDTABLEOFCONTENTS  0x109


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0028_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0028_v0_0_s_ifspec;

#ifndef __IRawCDImageCreator_INTERFACE_DEFINED__
#define __IRawCDImageCreator_INTERFACE_DEFINED__

/* interface IRawCDImageCreator */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IRawCDImageCreator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25983550-9D65-49CE-B335-40630D901227")
    IRawCDImageCreator : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateResultImage( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **resultStream) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddTrack( 
            /* [in] */ IMAPI_CD_SECTOR_TYPE dataType,
            /* [in] */ __RPC__in_opt IStream *data,
            /* [retval][out] */ __RPC__out LONG *trackIndex) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddSpecialPregap( 
            /* [in] */ __RPC__in_opt IStream *data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddSubcodeRWGenerator( 
            /* [in] */ __RPC__in_opt IStream *subcode) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ResultingImageType( 
            /* [in] */ IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ResultingImageType( 
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartOfLeadout( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartOfLeadoutLimit( 
            /* [in] */ LONG value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartOfLeadoutLimit( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DisableGaplessAudio( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisableGaplessAudio( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MediaCatalogNumber( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MediaCatalogNumber( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StartingTrackNumber( 
            /* [range][in] */ __RPC__in_range(1,99) LONG value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartingTrackNumber( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrackInfo( 
            /* [in] */ LONG trackIndex,
            /* [retval][ref][out] */ __RPC__deref_out_opt IRawCDImageTrackInfo **value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NumberOfExistingTracks( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastUsedUserSectorInImage( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ExpectedTableOfContents( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawCDImageCreatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRawCDImageCreator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRawCDImageCreator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRawCDImageCreator * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRawCDImageCreator * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateResultImage )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **resultStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddTrack )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ IMAPI_CD_SECTOR_TYPE dataType,
            /* [in] */ __RPC__in_opt IStream *data,
            /* [retval][out] */ __RPC__out LONG *trackIndex);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddSpecialPregap )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ __RPC__in_opt IStream *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddSubcodeRWGenerator )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ __RPC__in_opt IStream *subcode);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ResultingImageType )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ResultingImageType )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_FORMAT2_RAW_CD_DATA_SECTOR_TYPE *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartOfLeadout )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartOfLeadoutLimit )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ LONG value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartOfLeadoutLimit )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DisableGaplessAudio )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DisableGaplessAudio )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MediaCatalogNumber )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MediaCatalogNumber )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StartingTrackNumber )( 
            __RPC__in IRawCDImageCreator * This,
            /* [range][in] */ __RPC__in_range(1,99) LONG value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartingTrackNumber )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrackInfo )( 
            __RPC__in IRawCDImageCreator * This,
            /* [in] */ LONG trackIndex,
            /* [retval][ref][out] */ __RPC__deref_out_opt IRawCDImageTrackInfo **value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_NumberOfExistingTracks )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastUsedUserSectorInImage )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ExpectedTableOfContents )( 
            __RPC__in IRawCDImageCreator * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        END_INTERFACE
    } IRawCDImageCreatorVtbl;

    interface IRawCDImageCreator
    {
        CONST_VTBL struct IRawCDImageCreatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawCDImageCreator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawCDImageCreator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawCDImageCreator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawCDImageCreator_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRawCDImageCreator_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRawCDImageCreator_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRawCDImageCreator_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRawCDImageCreator_CreateResultImage(This,resultStream)	\
    ( (This)->lpVtbl -> CreateResultImage(This,resultStream) ) 

#define IRawCDImageCreator_AddTrack(This,dataType,data,trackIndex)	\
    ( (This)->lpVtbl -> AddTrack(This,dataType,data,trackIndex) ) 

#define IRawCDImageCreator_AddSpecialPregap(This,data)	\
    ( (This)->lpVtbl -> AddSpecialPregap(This,data) ) 

#define IRawCDImageCreator_AddSubcodeRWGenerator(This,subcode)	\
    ( (This)->lpVtbl -> AddSubcodeRWGenerator(This,subcode) ) 

#define IRawCDImageCreator_put_ResultingImageType(This,value)	\
    ( (This)->lpVtbl -> put_ResultingImageType(This,value) ) 

#define IRawCDImageCreator_get_ResultingImageType(This,value)	\
    ( (This)->lpVtbl -> get_ResultingImageType(This,value) ) 

#define IRawCDImageCreator_get_StartOfLeadout(This,value)	\
    ( (This)->lpVtbl -> get_StartOfLeadout(This,value) ) 

#define IRawCDImageCreator_put_StartOfLeadoutLimit(This,value)	\
    ( (This)->lpVtbl -> put_StartOfLeadoutLimit(This,value) ) 

#define IRawCDImageCreator_get_StartOfLeadoutLimit(This,value)	\
    ( (This)->lpVtbl -> get_StartOfLeadoutLimit(This,value) ) 

#define IRawCDImageCreator_put_DisableGaplessAudio(This,value)	\
    ( (This)->lpVtbl -> put_DisableGaplessAudio(This,value) ) 

#define IRawCDImageCreator_get_DisableGaplessAudio(This,value)	\
    ( (This)->lpVtbl -> get_DisableGaplessAudio(This,value) ) 

#define IRawCDImageCreator_put_MediaCatalogNumber(This,value)	\
    ( (This)->lpVtbl -> put_MediaCatalogNumber(This,value) ) 

#define IRawCDImageCreator_get_MediaCatalogNumber(This,value)	\
    ( (This)->lpVtbl -> get_MediaCatalogNumber(This,value) ) 

#define IRawCDImageCreator_put_StartingTrackNumber(This,value)	\
    ( (This)->lpVtbl -> put_StartingTrackNumber(This,value) ) 

#define IRawCDImageCreator_get_StartingTrackNumber(This,value)	\
    ( (This)->lpVtbl -> get_StartingTrackNumber(This,value) ) 

#define IRawCDImageCreator_get_TrackInfo(This,trackIndex,value)	\
    ( (This)->lpVtbl -> get_TrackInfo(This,trackIndex,value) ) 

#define IRawCDImageCreator_get_NumberOfExistingTracks(This,value)	\
    ( (This)->lpVtbl -> get_NumberOfExistingTracks(This,value) ) 

#define IRawCDImageCreator_get_LastUsedUserSectorInImage(This,value)	\
    ( (This)->lpVtbl -> get_LastUsedUserSectorInImage(This,value) ) 

#define IRawCDImageCreator_get_ExpectedTableOfContents(This,value)	\
    ( (This)->lpVtbl -> get_ExpectedTableOfContents(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawCDImageCreator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0029 */
/* [local] */ 

#define DISPID_IRAWCDTRACKINFO_STARTINGLBA              0x100
#define DISPID_IRAWCDTRACKINFO_SECTORCOUNT              0x101
#define DISPID_IRAWCDTRACKINFO_TRACKNUMBER              0x102
#define DISPID_IRAWCDTRACKINFO_SECTORTYPE               0x103
#define DISPID_IRAWCDTRACKINFO_ISRC                     0x104
#define DISPID_IRAWCDTRACKINFO_DIGITALAUDIOCOPYSETTING  0x105
#define DISPID_IRAWCDTRACKINFO_AUDIOHASPREEMPHASIS      0x106


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0029_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0029_v0_0_s_ifspec;

#ifndef __IRawCDImageTrackInfo_INTERFACE_DEFINED__
#define __IRawCDImageTrackInfo_INTERFACE_DEFINED__

/* interface IRawCDImageTrackInfo */
/* [helpstring][unique][uuid][dual][nonextensible][object] */ 


EXTERN_C const IID IID_IRawCDImageTrackInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("25983551-9D65-49CE-B335-40630D901227")
    IRawCDImageTrackInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartingLba( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SectorCount( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrackNumber( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SectorType( 
            /* [retval][ref][out] */ __RPC__out IMAPI_CD_SECTOR_TYPE *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISRC( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ISRC( 
            /* [in] */ __RPC__in BSTR value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DigitalAudioCopySetting( 
            /* [retval][ref][out] */ __RPC__out IMAPI_CD_TRACK_DIGITAL_COPY_SETTING *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DigitalAudioCopySetting( 
            /* [in] */ IMAPI_CD_TRACK_DIGITAL_COPY_SETTING value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AudioHasPreemphasis( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_AudioHasPreemphasis( 
            /* [in] */ VARIANT_BOOL value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TrackIndexes( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddTrackIndex( 
            /* [range][in] */ __RPC__in_range(0,0x7fffffff) LONG lbaOffset) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearTrackIndex( 
            /* [range][in] */ __RPC__in_range(0,0x7fffffff) LONG lbaOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRawCDImageTrackInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRawCDImageTrackInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRawCDImageTrackInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IRawCDImageTrackInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartingLba )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SectorCount )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrackNumber )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SectorType )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_CD_SECTOR_TYPE *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ISRC )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ISRC )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [in] */ __RPC__in BSTR value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DigitalAudioCopySetting )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [retval][ref][out] */ __RPC__out IMAPI_CD_TRACK_DIGITAL_COPY_SETTING *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DigitalAudioCopySetting )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [in] */ IMAPI_CD_TRACK_DIGITAL_COPY_SETTING value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AudioHasPreemphasis )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_AudioHasPreemphasis )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [in] */ VARIANT_BOOL value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TrackIndexes )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddTrackIndex )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [range][in] */ __RPC__in_range(0,0x7fffffff) LONG lbaOffset);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ClearTrackIndex )( 
            __RPC__in IRawCDImageTrackInfo * This,
            /* [range][in] */ __RPC__in_range(0,0x7fffffff) LONG lbaOffset);
        
        END_INTERFACE
    } IRawCDImageTrackInfoVtbl;

    interface IRawCDImageTrackInfo
    {
        CONST_VTBL struct IRawCDImageTrackInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRawCDImageTrackInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRawCDImageTrackInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRawCDImageTrackInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRawCDImageTrackInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IRawCDImageTrackInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IRawCDImageTrackInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IRawCDImageTrackInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IRawCDImageTrackInfo_get_StartingLba(This,value)	\
    ( (This)->lpVtbl -> get_StartingLba(This,value) ) 

#define IRawCDImageTrackInfo_get_SectorCount(This,value)	\
    ( (This)->lpVtbl -> get_SectorCount(This,value) ) 

#define IRawCDImageTrackInfo_get_TrackNumber(This,value)	\
    ( (This)->lpVtbl -> get_TrackNumber(This,value) ) 

#define IRawCDImageTrackInfo_get_SectorType(This,value)	\
    ( (This)->lpVtbl -> get_SectorType(This,value) ) 

#define IRawCDImageTrackInfo_get_ISRC(This,value)	\
    ( (This)->lpVtbl -> get_ISRC(This,value) ) 

#define IRawCDImageTrackInfo_put_ISRC(This,value)	\
    ( (This)->lpVtbl -> put_ISRC(This,value) ) 

#define IRawCDImageTrackInfo_get_DigitalAudioCopySetting(This,value)	\
    ( (This)->lpVtbl -> get_DigitalAudioCopySetting(This,value) ) 

#define IRawCDImageTrackInfo_put_DigitalAudioCopySetting(This,value)	\
    ( (This)->lpVtbl -> put_DigitalAudioCopySetting(This,value) ) 

#define IRawCDImageTrackInfo_get_AudioHasPreemphasis(This,value)	\
    ( (This)->lpVtbl -> get_AudioHasPreemphasis(This,value) ) 

#define IRawCDImageTrackInfo_put_AudioHasPreemphasis(This,value)	\
    ( (This)->lpVtbl -> put_AudioHasPreemphasis(This,value) ) 

#define IRawCDImageTrackInfo_get_TrackIndexes(This,value)	\
    ( (This)->lpVtbl -> get_TrackIndexes(This,value) ) 

#define IRawCDImageTrackInfo_AddTrackIndex(This,lbaOffset)	\
    ( (This)->lpVtbl -> AddTrackIndex(This,lbaOffset) ) 

#define IRawCDImageTrackInfo_ClearTrackIndex(This,lbaOffset)	\
    ( (This)->lpVtbl -> ClearTrackIndex(This,lbaOffset) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRawCDImageTrackInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0030 */
/* [local] */ 

#define DISPID_IBLOCKRANGE_STARTLBA                       0x100
#define DISPID_IBLOCKRANGE_ENDLBA                         0x101


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0030_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0030_v0_0_s_ifspec;

#ifndef __IBlockRange_INTERFACE_DEFINED__
#define __IBlockRange_INTERFACE_DEFINED__

/* interface IBlockRange */
/* [helpstring][unique][uuid][dual][object] */ 


EXTERN_C const IID IID_IBlockRange;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B507CA25-2204-11DD-966A-001AA01BBC58")
    IBlockRange : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StartLba( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EndLba( 
            /* [retval][ref][out] */ __RPC__out LONG *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBlockRangeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBlockRange * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBlockRange * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBlockRange * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IBlockRange * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IBlockRange * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IBlockRange * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBlockRange * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StartLba )( 
            __RPC__in IBlockRange * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EndLba )( 
            __RPC__in IBlockRange * This,
            /* [retval][ref][out] */ __RPC__out LONG *value);
        
        END_INTERFACE
    } IBlockRangeVtbl;

    interface IBlockRange
    {
        CONST_VTBL struct IBlockRangeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBlockRange_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBlockRange_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBlockRange_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBlockRange_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBlockRange_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBlockRange_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBlockRange_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBlockRange_get_StartLba(This,value)	\
    ( (This)->lpVtbl -> get_StartLba(This,value) ) 

#define IBlockRange_get_EndLba(This,value)	\
    ( (This)->lpVtbl -> get_EndLba(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBlockRange_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0031 */
/* [local] */ 

#define DISPID_IBLOCKRANGELIST_BLOCKRANGES                0x100


extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0031_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0031_v0_0_s_ifspec;

#ifndef __IBlockRangeList_INTERFACE_DEFINED__
#define __IBlockRangeList_INTERFACE_DEFINED__

/* interface IBlockRangeList */
/* [helpstring][unique][uuid][dual][object] */ 


EXTERN_C const IID IID_IBlockRangeList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B507CA26-2204-11DD-966A-001AA01BBC58")
    IBlockRangeList : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockRanges( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBlockRangeListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBlockRangeList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBlockRangeList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBlockRangeList * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IBlockRangeList * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IBlockRangeList * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IBlockRangeList * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBlockRangeList * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockRanges )( 
            __RPC__in IBlockRangeList * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *value);
        
        END_INTERFACE
    } IBlockRangeListVtbl;

    interface IBlockRangeList
    {
        CONST_VTBL struct IBlockRangeListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBlockRangeList_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBlockRangeList_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBlockRangeList_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBlockRangeList_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBlockRangeList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBlockRangeList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBlockRangeList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBlockRangeList_get_BlockRanges(This,value)	\
    ( (This)->lpVtbl -> get_BlockRanges(This,value) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBlockRangeList_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2_0000_0032 */
/* [local] */ 


//
// IMAPIv2 version information for TYPELib loading
//
#define IMAPILib2_MajorVersion 1
#define IMAPILib2_MinorVersion 0
#define LIBID_IMAPILib2 LIBID_IMAPI2



extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0032_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2_0000_0032_v0_0_s_ifspec;


#ifndef __IMAPI2_LIBRARY_DEFINED__
#define __IMAPI2_LIBRARY_DEFINED__

/* library IMAPI2 */
/* [helpstring][version][uuid] */ 

































EXTERN_C const IID LIBID_IMAPI2;

EXTERN_C const CLSID CLSID_MsftDiscMaster2;

#ifdef __cplusplus

class DECLSPEC_UUID("2735412E-7F64-5B0F-8F00-5D77AFBE261E")
MsftDiscMaster2;
#endif

EXTERN_C const CLSID CLSID_MsftDiscRecorder2;

#ifdef __cplusplus

class DECLSPEC_UUID("2735412D-7F64-5B0F-8F00-5D77AFBE261E")
MsftDiscRecorder2;
#endif

EXTERN_C const CLSID CLSID_MsftWriteEngine2;

#ifdef __cplusplus

class DECLSPEC_UUID("2735412C-7F64-5B0F-8F00-5D77AFBE261E")
MsftWriteEngine2;
#endif

EXTERN_C const CLSID CLSID_MsftDiscFormat2Erase;

#ifdef __cplusplus

class DECLSPEC_UUID("2735412B-7F64-5B0F-8F00-5D77AFBE261E")
MsftDiscFormat2Erase;
#endif

EXTERN_C const CLSID CLSID_MsftDiscFormat2Data;

#ifdef __cplusplus

class DECLSPEC_UUID("2735412A-7F64-5B0F-8F00-5D77AFBE261E")
MsftDiscFormat2Data;
#endif

EXTERN_C const CLSID CLSID_MsftDiscFormat2TrackAtOnce;

#ifdef __cplusplus

class DECLSPEC_UUID("27354129-7F64-5B0F-8F00-5D77AFBE261E")
MsftDiscFormat2TrackAtOnce;
#endif

EXTERN_C const CLSID CLSID_MsftDiscFormat2RawCD;

#ifdef __cplusplus

class DECLSPEC_UUID("27354128-7F64-5B0F-8F00-5D77AFBE261E")
MsftDiscFormat2RawCD;
#endif

EXTERN_C const CLSID CLSID_MsftStreamZero;

#ifdef __cplusplus

class DECLSPEC_UUID("27354127-7F64-5B0F-8F00-5D77AFBE261E")
MsftStreamZero;
#endif

EXTERN_C const CLSID CLSID_MsftStreamPrng001;

#ifdef __cplusplus

class DECLSPEC_UUID("27354126-7F64-5B0F-8F00-5D77AFBE261E")
MsftStreamPrng001;
#endif

EXTERN_C const CLSID CLSID_MsftStreamConcatenate;

#ifdef __cplusplus

class DECLSPEC_UUID("27354125-7F64-5B0F-8F00-5D77AFBE261E")
MsftStreamConcatenate;
#endif

EXTERN_C const CLSID CLSID_MsftStreamInterleave;

#ifdef __cplusplus

class DECLSPEC_UUID("27354124-7F64-5B0F-8F00-5D77AFBE261E")
MsftStreamInterleave;
#endif

EXTERN_C const CLSID CLSID_MsftWriteSpeedDescriptor;

#ifdef __cplusplus

class DECLSPEC_UUID("27354123-7F64-5B0F-8F00-5D77AFBE261E")
MsftWriteSpeedDescriptor;
#endif

EXTERN_C const CLSID CLSID_MsftMultisessionSequential;

#ifdef __cplusplus

class DECLSPEC_UUID("27354122-7F64-5B0F-8F00-5D77AFBE261E")
MsftMultisessionSequential;
#endif

EXTERN_C const CLSID CLSID_MsftMultisessionRandomWrite;

#ifdef __cplusplus

class DECLSPEC_UUID("B507CA24-2204-11DD-966A-001AA01BBC58")
MsftMultisessionRandomWrite;
#endif

EXTERN_C const CLSID CLSID_MsftRawCDImageCreator;

#ifdef __cplusplus

class DECLSPEC_UUID("25983561-9D65-49CE-B335-40630D901227")
MsftRawCDImageCreator;
#endif
#endif /* __IMAPI2_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\imapi2fserror.h ===
// FileSystemImageMsg.h

// Help for constructing this file was provided by
// ms-help://MS.MSDNQTR.2003FEB.1033/tools/tools/about_message_text_files.htm
// Refer to this documentation for message text syntax.
#pragma once
//Since the message codes are also included in the header file produced from the .idl, don't include them here
#ifndef _SKIP_FSI_ERROR_MESSAGE_CODES
// -----  Catch-all error(s) -- should not actually occur, indicative of internal state error  --------
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_IMAPI2                  0xAA


//
// Define the severity codes
//


//
// MessageId: IMAPI_E_FSI_INTERNAL_ERROR
//
// MessageText:
//
// Internal file system error occurred.
//
#define IMAPI_E_FSI_INTERNAL_ERROR       ((HRESULT)0xC0AAB100L)

// ----------------  Miscellenous interface errors   ------------------
//
// MessageId: IMAPI_E_INVALID_PARAM
//
// MessageText:
//
// The value specified for parameter '%1!ls!' is not valid.
//
#define IMAPI_E_INVALID_PARAM            ((HRESULT)0xC0AAB101L)

//  NOTE:  the quote characters delimiting the parameter name are used by the Managed Shim
//         to parse the parameter name from the message text for exception handling
//         Don't remove or change these quote-delimiters w/o also changing the exception mapping
//         in the managed shim.
//
// MessageId: IMAPI_E_READONLY
//
// MessageText:
//
// FileSystemImage object is in read only mode.
//
#define IMAPI_E_READONLY                 ((HRESULT)0xC0AAB102L)

//
// MessageId: IMAPI_E_NO_OUTPUT
//
// MessageText:
//
// No output file system specified.
//
#define IMAPI_E_NO_OUTPUT                ((HRESULT)0xC0AAB103L)

//
// MessageId: IMAPI_E_INVALID_VOLUME_NAME
//
// MessageText:
//
// The specified Volume Identifier is either too long or contains one or more invalid characters.
//
#define IMAPI_E_INVALID_VOLUME_NAME      ((HRESULT)0xC0AAB104L)

//
// MessageId: IMAPI_E_INVALID_DATE
//
// MessageText:
//
// Invalid file dates.  %1!ls! time is earlier than %2!ls! time.
//
#define IMAPI_E_INVALID_DATE             ((HRESULT)0xC0AAB105L)

//
// MessageId: IMAPI_E_FILE_SYSTEM_NOT_EMPTY
//
// MessageText:
//
// The file system must be empty for this function.
//
#define IMAPI_E_FILE_SYSTEM_NOT_EMPTY    ((HRESULT)0xC0AAB106L)

// ----------------  Errors associated with state of item   ------------------
//
// MessageId: IMAPI_E_NOT_FILE
//
// MessageText:
//
// Specified path '%1!ls!' does not identify a file.
//
#define IMAPI_E_NOT_FILE                 ((HRESULT)0xC0AAB108L)

//
// MessageId: IMAPI_E_NOT_DIR
//
// MessageText:
//
// Specified path '%1!ls!' does not identify a directory.
//
#define IMAPI_E_NOT_DIR                  ((HRESULT)0xC0AAB109L)

//
// MessageId: IMAPI_E_DIR_NOT_EMPTY
//
// MessageText:
//
// The directory '%1!s!' is not empty.
//
#define IMAPI_E_DIR_NOT_EMPTY            ((HRESULT)0xC0AAB10AL)

//
// MessageId: IMAPI_E_NOT_IN_FILE_SYSTEM
//
// MessageText:
//
// '%1!ls!' is not part of the file system.  It must be added to complete this operation.
//
#define IMAPI_E_NOT_IN_FILE_SYSTEM       ((HRESULT)0xC0AAB10BL)

// ----------------  Errors associated with file/directory naming problems   ------------------
//
// MessageId: IMAPI_E_INVALID_PATH
//
// MessageText:
//
// Path '%1!s!' is badly formed or contains invalid characters.
//
#define IMAPI_E_INVALID_PATH             ((HRESULT)0xC0AAB110L)

//
// MessageId: IMAPI_E_RESTRICTED_NAME_VIOLATION
//
// MessageText:
//
// The name '%1!ls!' specified is not legal:  Name of file or directory object created while the UseRestrictedCharacterSet property is set may only contain ANSI characters.
//
#define IMAPI_E_RESTRICTED_NAME_VIOLATION ((HRESULT)0xC0AAB111L)

//
// MessageId: IMAPI_E_DUP_NAME
//
// MessageText:
//
// '%1!ls!' name already exists.
//
#define IMAPI_E_DUP_NAME                 ((HRESULT)0xC0AAB112L)

//
// MessageId: IMAPI_E_NO_UNIQUE_NAME
//
// MessageText:
//
// Attempt to add '%1!ls!' failed:  cannot create a file-system-specific unique name for the %2!ls! file system.
//
#define IMAPI_E_NO_UNIQUE_NAME           ((HRESULT)0xC0AAB113L)

// --------------  Errors reported when specified item not found in hierarchy  ---------------
//
// MessageId: IMAPI_E_ITEM_NOT_FOUND
//
// MessageText:
//
// Cannot find item '%1!ls!' in FileSystemImage hierarchy.
//
#define IMAPI_E_ITEM_NOT_FOUND           ((HRESULT)0xC0AAB118L)

//
// MessageId: IMAPI_E_FILE_NOT_FOUND
//
// MessageText:
//
// The file '%1!s!' not found in FileSystemImage hierarchy.
//
#define IMAPI_E_FILE_NOT_FOUND           ((HRESULT)0xC0AAB119L)

//
// MessageId: IMAPI_E_DIR_NOT_FOUND
//
// MessageText:
//
// The directory '%1!s!' not found in FileSystemImage hierarchy.
//
#define IMAPI_E_DIR_NOT_FOUND            ((HRESULT)0xC0AAB11AL)

// ----------------  Image-size exceeds limit errors  ------------------
//
// MessageId: IMAPI_E_IMAGE_SIZE_LIMIT
//
// MessageText:
//
// Adding '%1!ls!' would result in a result image having a size larger than the current configured limit.
//
#define IMAPI_E_IMAGE_SIZE_LIMIT         ((HRESULT)0xC0AAB120L)

//
// MessageId: IMAPI_E_IMAGE_TOO_BIG
//
// MessageText:
//
// Value specified for FreeMediaBlocks property is too small for estimated image size based on current data.  
//
#define IMAPI_E_IMAGE_TOO_BIG            ((HRESULT)0xC0AAB121L)

// ----------------  User file-data stream errors  ------------------
//
// MessageId: IMAPI_E_DATA_STREAM_INCONSISTENCY
//
// MessageText:
//
// Data stream supplied for file '%1!ls!' is inconsistent:  expected %2!I64d! bytes, found %3!I64d!. 
//
#define IMAPI_E_DATA_STREAM_INCONSISTENCY ((HRESULT)0xC0AAB128L)

//
// MessageId: IMAPI_E_DATA_STREAM_READ_FAILURE
//
// MessageText:
//
// Cannot read data from stream supplied for file '%1!ls!'.
//
#define IMAPI_E_DATA_STREAM_READ_FAILURE ((HRESULT)0xC0AAB129L)

//
// MessageId: IMAPI_E_DATA_STREAM_CREATE_FAILURE
//
// MessageText:
//
// The following error was encountered when trying to create data stream for '%1!ls!':  
//
#define IMAPI_E_DATA_STREAM_CREATE_FAILURE ((HRESULT)0xC0AAB12AL)

//
// MessageId: IMAPI_E_DIRECTORY_READ_FAILURE
//
// MessageText:
//
// The following error was encountered when trying to enumerate files in directory '%1!ls!':  
//
#define IMAPI_E_DIRECTORY_READ_FAILURE   ((HRESULT)0xC0AAB12BL)

// ----------------  FileSystem-specific limitations  ------------------
//
// MessageId: IMAPI_E_TOO_MANY_DIRS
//
// MessageText:
//
// This file system image has too many directories for the %1!ls! file system.
//
#define IMAPI_E_TOO_MANY_DIRS            ((HRESULT)0xC0AAB130L)

//
// MessageId: IMAPI_E_ISO9660_LEVELS
//
// MessageText:
//
// ISO9660 is limited to 8 levels of directories.
//
#define IMAPI_E_ISO9660_LEVELS           ((HRESULT)0xC0AAB131L)

//
// MessageId: IMAPI_E_DATA_TOO_BIG
//
// MessageText:
//
// Data file is too large for '%1!ls!' file system.
//
#define IMAPI_E_DATA_TOO_BIG             ((HRESULT)0xC0AAB132L)

//
// MessageId: IMAPI_E_INCOMPATIBLE_PREVIOUS_SESSION
//
// MessageText:
//
// Operation failed because of incompatible layout of the previous session imported from the medium.
//
#define IMAPI_E_INCOMPATIBLE_PREVIOUS_SESSION ((HRESULT)0xC0AAB133L)

// ----------------  Errors associated with stash-file operations   ------------------
//
// MessageId: IMAPI_E_STASHFILE_OPEN_FAILURE
//
// MessageText:
//
// Cannot initialize %1!ls! stash file.
//
#define IMAPI_E_STASHFILE_OPEN_FAILURE   ((HRESULT)0xC0AAB138L)

//
// MessageId: IMAPI_E_STASHFILE_SEEK_FAILURE
//
// MessageText:
//
// Error seeking in '%1!ls!' stash file.
//
#define IMAPI_E_STASHFILE_SEEK_FAILURE   ((HRESULT)0xC0AAB139L)

//
// MessageId: IMAPI_E_STASHFILE_WRITE_FAILURE
//
// MessageText:
//
// Error encountered writing to '%1!ls!' stash file.
//
#define IMAPI_E_STASHFILE_WRITE_FAILURE  ((HRESULT)0xC0AAB13AL)

//
// MessageId: IMAPI_E_STASHFILE_READ_FAILURE
//
// MessageText:
//
// Error encountered reading from '%1!ls!' stash file.
//
#define IMAPI_E_STASHFILE_READ_FAILURE   ((HRESULT)0xC0AAB13BL)

// ----------------  Errors associated with attempt to set working directory  ------------------
//
// MessageId: IMAPI_E_INVALID_WORKING_DIRECTORY
//
// MessageText:
//
// The working directory '%1!ls!' is not valid.
//
#define IMAPI_E_INVALID_WORKING_DIRECTORY ((HRESULT)0xC0AAB140L)

//
// MessageId: IMAPI_E_WORKING_DIRECTORY_SPACE
//
// MessageText:
//
// Cannot set working directory to '%1!ls!'.  Space available is %2!I64d! bytes, approximately %3!I64d! bytes required. 
//
#define IMAPI_E_WORKING_DIRECTORY_SPACE  ((HRESULT)0xC0AAB141L)

//
// MessageId: IMAPI_E_STASHFILE_MOVE
//
// MessageText:
//
// Attempt to move the data stash file to directory '%1!ls!' was not successful.
//
#define IMAPI_E_STASHFILE_MOVE           ((HRESULT)0xC0AAB142L)

// ----------------  Errors associated with Boot Image object   ------------------
//
// MessageId: IMAPI_E_BOOT_IMAGE_DATA
//
// MessageText:
//
// The boot object could not be added to the image.
//
#define IMAPI_E_BOOT_IMAGE_DATA          ((HRESULT)0xC0AAB148L)

//
// MessageId: IMAPI_E_BOOT_OBJECT_CONFLICT
//
// MessageText:
//
// A boot object can only be included in an initial disc image.
//
#define IMAPI_E_BOOT_OBJECT_CONFLICT     ((HRESULT)0xC0AAB149L)

//
// MessageId: IMAPI_E_BOOT_EMULATION_IMAGE_SIZE_MISMATCH
//
// MessageText:
//
// The emulation type requested does not match the boot image size.
//
#define IMAPI_E_BOOT_EMULATION_IMAGE_SIZE_MISMATCH ((HRESULT)0xC0AAB14AL)

// ----------------  Errors associated with import operation   ------------------
//
// MessageId: IMAPI_E_EMPTY_DISC
//
// MessageText:
//
// Optical media is empty.
//
#define IMAPI_E_EMPTY_DISC               ((HRESULT)0xC0AAB150L)

//
// MessageId: IMAPI_E_NO_SUPPORTED_FILE_SYSTEM
//
// MessageText:
//
// The specified disc does not contain one of the supported file systems.
//
#define IMAPI_E_NO_SUPPORTED_FILE_SYSTEM ((HRESULT)0xC0AAB151L)

//
// MessageId: IMAPI_E_FILE_SYSTEM_NOT_FOUND
//
// MessageText:
//
// The specified disc does not contain a '%1!ls!' file system.
//
#define IMAPI_E_FILE_SYSTEM_NOT_FOUND    ((HRESULT)0xC0AAB152L)

//
// MessageId: IMAPI_E_FILE_SYSTEM_READ_CONSISTENCY_ERROR
//
// MessageText:
//
// Consistency error encountered while importing the '%1!ls!' file system.
//
#define IMAPI_E_FILE_SYSTEM_READ_CONSISTENCY_ERROR ((HRESULT)0xC0AAB153L)

//
// MessageId: IMAPI_E_FILE_SYSTEM_FEATURE_NOT_SUPPORTED
//
// MessageText:
//
// The '%1!ls!'file system on the selected disc contains a feature not supported for import.
//
#define IMAPI_E_FILE_SYSTEM_FEATURE_NOT_SUPPORTED ((HRESULT)0xC0AAB154L)

//
// MessageId: IMAPI_E_IMPORT_TYPE_COLLISION_FILE_EXISTS_AS_DIRECTORY
//
// MessageText:
//
// Could not import %2!ls! file system from disc.  The file '%1!ls!' already exists within the image hierarchy as a directory.
//
#define IMAPI_E_IMPORT_TYPE_COLLISION_FILE_EXISTS_AS_DIRECTORY ((HRESULT)0xC0AAB155L)

//
// MessageId: IMAPI_E_IMPORT_SEEK_FAILURE
//
// MessageText:
//
// Cannot seek to block %1!I64d! on source disc. 
//
#define IMAPI_E_IMPORT_SEEK_FAILURE      ((HRESULT)0xC0AAB156L)

//
// MessageId: IMAPI_E_IMPORT_READ_FAILURE
//
// MessageText:
//
// Import from previous session failed due to an error reading a block on the media (most likely block %1!u!).
//
#define IMAPI_E_IMPORT_READ_FAILURE      ((HRESULT)0xC0AAB157L)

//
// MessageId: IMAPI_E_DISC_MISMATCH
//
// MessageText:
//
// Current disc is not the same one from which file system was imported.
//
#define IMAPI_E_DISC_MISMATCH            ((HRESULT)0xC0AAB158L)

//
// MessageId: IMAPI_E_IMPORT_MEDIA_NOT_ALLOWED
//
// MessageText:
//
// IMAPI does not allow multi-session with the current media type.
//
#define IMAPI_E_IMPORT_MEDIA_NOT_ALLOWED ((HRESULT)0xC0AAB159L)

//
// MessageId: IMAPI_E_UDF_NOT_WRITE_COMPATIBLE
//
// MessageText:
//
// IMAPI can not do multi-session with the current media because it does not support a compatible UDF revision for write.
//
#define IMAPI_E_UDF_NOT_WRITE_COMPATIBLE ((HRESULT)0xC0AAB15AL)

//
// MessageId: IMAPI_E_INCOMPATIBLE_MULTISESSION_TYPE
//
// MessageText:
//
// IMAPI does not support the multisession type requested.
//
#define IMAPI_E_INCOMPATIBLE_MULTISESSION_TYPE ((HRESULT)0xC0AAB15BL)

//
// MessageId: IMAPI_E_NO_COMPATIBLE_MULTISESSION_TYPE
//
// MessageText:
//
// IMAPI supports none of the multisession type(s) provided on the current media.
//
#define IMAPI_E_NO_COMPATIBLE_MULTISESSION_TYPE ((HRESULT)0xC0AAB15CL)

//
// MessageId: IMAPI_E_MULTISESSION_NOT_SET
//
// MessageText:
//
// MultisessionInterfaces property must be set prior calling this method.
//
#define IMAPI_E_MULTISESSION_NOT_SET     ((HRESULT)0xC0AAB15DL)

//
// MessageId: IMAPI_E_IMPORT_TYPE_COLLISION_DIRECTORY_EXISTS_AS_FILE
//
// MessageText:
//
// Could not import %2!ls! file system from disc.  The directory '%1!ls!' already exists within the image hierarchy as a file.
//
#define IMAPI_E_IMPORT_TYPE_COLLISION_DIRECTORY_EXISTS_AS_FILE ((HRESULT)0xC0AAB15EL)

//
// MessageId: IMAPI_S_IMAGE_FEATURE_NOT_SUPPORTED
//
// MessageText:
//
// Feature is not supported for the current file system revision, image will be created without this feature.
//
#define IMAPI_S_IMAGE_FEATURE_NOT_SUPPORTED ((HRESULT)0x00AAB15FL)

//
// MessageId: IMAPI_E_PROPERTY_NOT_ACCESSIBLE
//
// MessageText:
//
// Property '%1!ls!' is not accessible
//
#define IMAPI_E_PROPERTY_NOT_ACCESSIBLE  ((HRESULT)0xC0AAB160L)

//
// MessageId: IMAPI_E_UDF_REVISION_CHANGE_NOT_ALLOWED
//
// MessageText:
//
// UDF revision cannot be changed because of the previously imported session
//
#define IMAPI_E_UDF_REVISION_CHANGE_NOT_ALLOWED ((HRESULT)0xC0AAB161L)

//
// MessageId: IMAPI_E_BAD_MULTISESSION_PARAMETER
//
// MessageText:
//
// One of the multisession parameters cannot be retrieved or has a wrong value.
//
#define IMAPI_E_BAD_MULTISESSION_PARAMETER ((HRESULT)0xC0AAB162L)

//
// MessageId: IMAPI_E_FILE_SYSTEM_CHANGE_NOT_ALLOWED
//
// MessageText:
//
// You cannot change the file system to be created, because the file system in the imported session and the one in the new session must match.
//
#define IMAPI_E_FILE_SYSTEM_CHANGE_NOT_ALLOWED ((HRESULT)0xC0AAB163L)

// ------ Error messages for IIsoImageManager (range: 0x80AAB200 - 0x80AAB2FF) ------
//
// MessageId: IMAPI_E_IMAGEMANAGER_IMAGE_NOT_ALIGNED
//
// MessageText:
//
// The image is not 2kb aligned. Only 2048 bytes aligned images are supported.
//
#define IMAPI_E_IMAGEMANAGER_IMAGE_NOT_ALIGNED ((HRESULT)0xC0AAB200L)

//
// MessageId: IMAPI_E_IMAGEMANAGER_NO_VALID_VD_FOUND
//
// MessageText:
//
// No valid file system Volume Descriptor was found in the iso image. This image format is not supported and the resulting disc might not be readable.
//
#define IMAPI_E_IMAGEMANAGER_NO_VALID_VD_FOUND ((HRESULT)0xC0AAB201L)

//
// MessageId: IMAPI_E_IMAGEMANAGER_NO_IMAGE
//
// MessageText:
//
// No image was set (neither path nor stream was given).
//
#define IMAPI_E_IMAGEMANAGER_NO_IMAGE    ((HRESULT)0xC0AAB202L)

//
// MessageId: IMAPI_E_IMAGEMANAGER_IMAGE_TOO_BIG
//
// MessageText:
//
// Image size exceeds MAXLONG sectors - too big.
//
#define IMAPI_E_IMAGEMANAGER_IMAGE_TOO_BIG ((HRESULT)0xC0AAB203L)

// ----------- Empty message, should not occur, used for internal purposes ------------------
//
// MessageId: 0x0000FFFFL (No symbolic name defined)
//
// MessageText:
//
// (empty message)
//


#endif		// #ifndef _SKIP_FSI_ERROR_MESSAGE_CODES
#define IMAPI_ERROR_FIRST	(unsigned int)0xB100
#define IMAPI_ERROR_LAST	(unsigned int)0xB2FF
#define IMAPIError(hr) ((HRESULT_FACILITY(hr) == FACILITY_IMAPI2) && (HRESULT_CODE(hr) <= IMAPI_ERROR_LAST) && (HRESULT_CODE(hr) >= IMAPI_ERROR_FIRST))
#define IMAPI_FSI_ERROR_FIRST	(unsigned int)0xB100
#define IMAPI_FSI_ERROR_LAST	(unsigned int)0xB2FF
#define IMAPIFsiError(hr) ((HRESULT_FACILITY(hr) == FACILITY_IMAPI2) && (HRESULT_CODE(hr) <= IMAPI_FSI_ERROR_LAST) && (HRESULT_CODE(hr) >= IMAPI_FSI_ERROR_FIRST))
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\imapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for imapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imapi_h__
#define __imapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDiscRecorder_FWD_DEFINED__
#define __IDiscRecorder_FWD_DEFINED__
typedef interface IDiscRecorder IDiscRecorder;
#endif 	/* __IDiscRecorder_FWD_DEFINED__ */


#ifndef __IEnumDiscRecorders_FWD_DEFINED__
#define __IEnumDiscRecorders_FWD_DEFINED__
typedef interface IEnumDiscRecorders IEnumDiscRecorders;
#endif 	/* __IEnumDiscRecorders_FWD_DEFINED__ */


#ifndef __IEnumDiscMasterFormats_FWD_DEFINED__
#define __IEnumDiscMasterFormats_FWD_DEFINED__
typedef interface IEnumDiscMasterFormats IEnumDiscMasterFormats;
#endif 	/* __IEnumDiscMasterFormats_FWD_DEFINED__ */


#ifndef __IRedbookDiscMaster_FWD_DEFINED__
#define __IRedbookDiscMaster_FWD_DEFINED__
typedef interface IRedbookDiscMaster IRedbookDiscMaster;
#endif 	/* __IRedbookDiscMaster_FWD_DEFINED__ */


#ifndef __IJolietDiscMaster_FWD_DEFINED__
#define __IJolietDiscMaster_FWD_DEFINED__
typedef interface IJolietDiscMaster IJolietDiscMaster;
#endif 	/* __IJolietDiscMaster_FWD_DEFINED__ */


#ifndef __IDiscMasterProgressEvents_FWD_DEFINED__
#define __IDiscMasterProgressEvents_FWD_DEFINED__
typedef interface IDiscMasterProgressEvents IDiscMasterProgressEvents;
#endif 	/* __IDiscMasterProgressEvents_FWD_DEFINED__ */


#ifndef __IDiscMaster_FWD_DEFINED__
#define __IDiscMaster_FWD_DEFINED__
typedef interface IDiscMaster IDiscMaster;
#endif 	/* __IDiscMaster_FWD_DEFINED__ */


#ifndef __MSDiscRecorderObj_FWD_DEFINED__
#define __MSDiscRecorderObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSDiscRecorderObj MSDiscRecorderObj;
#else
typedef struct MSDiscRecorderObj MSDiscRecorderObj;
#endif /* __cplusplus */

#endif 	/* __MSDiscRecorderObj_FWD_DEFINED__ */


#ifndef __MSDiscMasterObj_FWD_DEFINED__
#define __MSDiscMasterObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSDiscMasterObj MSDiscMasterObj;
#else
typedef struct MSDiscMasterObj MSDiscMasterObj;
#endif /* __cplusplus */

#endif 	/* __MSDiscMasterObj_FWD_DEFINED__ */


#ifndef __MSEnumDiscRecordersObj_FWD_DEFINED__
#define __MSEnumDiscRecordersObj_FWD_DEFINED__

#ifdef __cplusplus
typedef class MSEnumDiscRecordersObj MSEnumDiscRecordersObj;
#else
typedef struct MSEnumDiscRecordersObj MSEnumDiscRecordersObj;
#endif /* __cplusplus */

#endif 	/* __MSEnumDiscRecordersObj_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_imapi_0000_0000 */
/* [local] */ 

// this assert will cause compilation breaks in clients whose code would cause stack corruption
// when writing to our boolean pointer
C_ASSERT(sizeof(boolean) == 1);


extern RPC_IF_HANDLE __MIDL_itf_imapi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi_0000_0000_v0_0_s_ifspec;

#ifndef __IDiscRecorder_INTERFACE_DEFINED__
#define __IDiscRecorder_INTERFACE_DEFINED__

/* interface IDiscRecorder */
/* [unique][helpstring][uuid][object] */ 


enum MEDIA_TYPES
    {	MEDIA_CDDA_CDROM	= 1,
	MEDIA_CD_ROM_XA	= ( MEDIA_CDDA_CDROM + 1 ) ,
	MEDIA_CD_I	= ( MEDIA_CD_ROM_XA + 1 ) ,
	MEDIA_CD_EXTRA	= ( MEDIA_CD_I + 1 ) ,
	MEDIA_CD_OTHER	= ( MEDIA_CD_EXTRA + 1 ) ,
	MEDIA_SPECIAL	= ( MEDIA_CD_OTHER + 1 ) 
    } ;

enum MEDIA_FLAGS
    {	MEDIA_BLANK	= 0x1,
	MEDIA_RW	= 0x2,
	MEDIA_WRITABLE	= 0x4,
	MEDIA_FORMAT_UNUSABLE_BY_IMAPI	= 0x8
    } ;

enum RECORDER_TYPES
    {	RECORDER_CDR	= 0x1,
	RECORDER_CDRW	= 0x2
    } ;
#define	RECORDER_DOING_NOTHING	( 0 )

#define	RECORDER_OPENED	( 0x1 )

#define	RECORDER_BURNING	( 0x2 )


EXTERN_C const IID IID_IDiscRecorder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85AC9776-CA88-4cf2-894E-09598C078A41")
    IDiscRecorder : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Init( 
            /* [size_is][in] */ __RPC__in_ecount_full(nulIDSize) byte *pbyUniqueID,
            /* [in] */ ULONG nulIDSize,
            /* [in] */ ULONG nulDriveNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecorderGUID( 
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(ulBufferSize) byte *pbyUniqueID,
            /* [in] */ ULONG ulBufferSize,
            /* [out] */ __RPC__out ULONG *pulReturnSizeRequired) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecorderType( 
            /* [out] */ __RPC__out long *fTypeCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayNames( 
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BSTR *pbstrVendorID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BSTR *pbstrProductID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BSTR *pbstrRevision) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBasePnPID( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrBasePnPID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPath( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecorderProperties( 
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppPropStg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetRecorderProperties( 
            /* [in] */ __RPC__in_opt IPropertyStorage *pPropStg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetRecorderState( 
            /* [out] */ __RPC__out ULONG *pulDevStateFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OpenExclusive( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMediaType( 
            /* [out] */ __RPC__out long *fMediaType,
            /* [out] */ __RPC__out long *fMediaFlags) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryMediaInfo( 
            /* [out] */ __RPC__out byte *pbSessions,
            /* [out] */ __RPC__out byte *pbLastTrack,
            /* [out] */ __RPC__out ULONG *ulStartAddress,
            /* [out] */ __RPC__out ULONG *ulNextWritable,
            /* [out] */ __RPC__out ULONG *ulFreeBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Eject( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Erase( 
            /* [in] */ boolean bFullErase) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscRecorderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscRecorder * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscRecorder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscRecorder * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Init )( 
            __RPC__in IDiscRecorder * This,
            /* [size_is][in] */ __RPC__in_ecount_full(nulIDSize) byte *pbyUniqueID,
            /* [in] */ ULONG nulIDSize,
            /* [in] */ ULONG nulDriveNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecorderGUID )( 
            __RPC__in IDiscRecorder * This,
            /* [size_is][unique][out][in] */ __RPC__inout_ecount_full_opt(ulBufferSize) byte *pbyUniqueID,
            /* [in] */ ULONG ulBufferSize,
            /* [out] */ __RPC__out ULONG *pulReturnSizeRequired);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecorderType )( 
            __RPC__in IDiscRecorder * This,
            /* [out] */ __RPC__out long *fTypeCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDisplayNames )( 
            __RPC__in IDiscRecorder * This,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BSTR *pbstrVendorID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BSTR *pbstrProductID,
            /* [unique][out][in] */ __RPC__deref_opt_inout_opt BSTR *pbstrRevision);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetBasePnPID )( 
            __RPC__in IDiscRecorder * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrBasePnPID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPath )( 
            __RPC__in IDiscRecorder * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecorderProperties )( 
            __RPC__in IDiscRecorder * This,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppPropStg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetRecorderProperties )( 
            __RPC__in IDiscRecorder * This,
            /* [in] */ __RPC__in_opt IPropertyStorage *pPropStg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetRecorderState )( 
            __RPC__in IDiscRecorder * This,
            /* [out] */ __RPC__out ULONG *pulDevStateFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OpenExclusive )( 
            __RPC__in IDiscRecorder * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMediaType )( 
            __RPC__in IDiscRecorder * This,
            /* [out] */ __RPC__out long *fMediaType,
            /* [out] */ __RPC__out long *fMediaFlags);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryMediaInfo )( 
            __RPC__in IDiscRecorder * This,
            /* [out] */ __RPC__out byte *pbSessions,
            /* [out] */ __RPC__out byte *pbLastTrack,
            /* [out] */ __RPC__out ULONG *ulStartAddress,
            /* [out] */ __RPC__out ULONG *ulNextWritable,
            /* [out] */ __RPC__out ULONG *ulFreeBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Eject )( 
            __RPC__in IDiscRecorder * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Erase )( 
            __RPC__in IDiscRecorder * This,
            /* [in] */ boolean bFullErase);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IDiscRecorder * This);
        
        END_INTERFACE
    } IDiscRecorderVtbl;

    interface IDiscRecorder
    {
        CONST_VTBL struct IDiscRecorderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscRecorder_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscRecorder_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscRecorder_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscRecorder_Init(This,pbyUniqueID,nulIDSize,nulDriveNumber)	\
    ( (This)->lpVtbl -> Init(This,pbyUniqueID,nulIDSize,nulDriveNumber) ) 

#define IDiscRecorder_GetRecorderGUID(This,pbyUniqueID,ulBufferSize,pulReturnSizeRequired)	\
    ( (This)->lpVtbl -> GetRecorderGUID(This,pbyUniqueID,ulBufferSize,pulReturnSizeRequired) ) 

#define IDiscRecorder_GetRecorderType(This,fTypeCode)	\
    ( (This)->lpVtbl -> GetRecorderType(This,fTypeCode) ) 

#define IDiscRecorder_GetDisplayNames(This,pbstrVendorID,pbstrProductID,pbstrRevision)	\
    ( (This)->lpVtbl -> GetDisplayNames(This,pbstrVendorID,pbstrProductID,pbstrRevision) ) 

#define IDiscRecorder_GetBasePnPID(This,pbstrBasePnPID)	\
    ( (This)->lpVtbl -> GetBasePnPID(This,pbstrBasePnPID) ) 

#define IDiscRecorder_GetPath(This,pbstrPath)	\
    ( (This)->lpVtbl -> GetPath(This,pbstrPath) ) 

#define IDiscRecorder_GetRecorderProperties(This,ppPropStg)	\
    ( (This)->lpVtbl -> GetRecorderProperties(This,ppPropStg) ) 

#define IDiscRecorder_SetRecorderProperties(This,pPropStg)	\
    ( (This)->lpVtbl -> SetRecorderProperties(This,pPropStg) ) 

#define IDiscRecorder_GetRecorderState(This,pulDevStateFlags)	\
    ( (This)->lpVtbl -> GetRecorderState(This,pulDevStateFlags) ) 

#define IDiscRecorder_OpenExclusive(This)	\
    ( (This)->lpVtbl -> OpenExclusive(This) ) 

#define IDiscRecorder_QueryMediaType(This,fMediaType,fMediaFlags)	\
    ( (This)->lpVtbl -> QueryMediaType(This,fMediaType,fMediaFlags) ) 

#define IDiscRecorder_QueryMediaInfo(This,pbSessions,pbLastTrack,ulStartAddress,ulNextWritable,ulFreeBlocks)	\
    ( (This)->lpVtbl -> QueryMediaInfo(This,pbSessions,pbLastTrack,ulStartAddress,ulNextWritable,ulFreeBlocks) ) 

#define IDiscRecorder_Eject(This)	\
    ( (This)->lpVtbl -> Eject(This) ) 

#define IDiscRecorder_Erase(This,bFullErase)	\
    ( (This)->lpVtbl -> Erase(This,bFullErase) ) 

#define IDiscRecorder_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscRecorder_INTERFACE_DEFINED__ */


#ifndef __IEnumDiscRecorders_INTERFACE_DEFINED__
#define __IEnumDiscRecorders_INTERFACE_DEFINED__

/* interface IEnumDiscRecorders */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDiscRecorders;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B1921E1-54AC-11d3-9144-00104BA11C5E")
    IEnumDiscRecorders : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cRecorders,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cRecorders, *pcFetched) IDiscRecorder **ppRecorder,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cRecorders) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDiscRecorders **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDiscRecordersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDiscRecorders * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDiscRecorders * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDiscRecorders * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDiscRecorders * This,
            /* [in] */ ULONG cRecorders,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cRecorders, *pcFetched) IDiscRecorder **ppRecorder,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDiscRecorders * This,
            /* [in] */ ULONG cRecorders);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDiscRecorders * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDiscRecorders * This,
            /* [out] */ __RPC__deref_out_opt IEnumDiscRecorders **ppEnum);
        
        END_INTERFACE
    } IEnumDiscRecordersVtbl;

    interface IEnumDiscRecorders
    {
        CONST_VTBL struct IEnumDiscRecordersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDiscRecorders_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDiscRecorders_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDiscRecorders_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDiscRecorders_Next(This,cRecorders,ppRecorder,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cRecorders,ppRecorder,pcFetched) ) 

#define IEnumDiscRecorders_Skip(This,cRecorders)	\
    ( (This)->lpVtbl -> Skip(This,cRecorders) ) 

#define IEnumDiscRecorders_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDiscRecorders_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDiscRecorders_INTERFACE_DEFINED__ */


#ifndef __IEnumDiscMasterFormats_INTERFACE_DEFINED__
#define __IEnumDiscMasterFormats_INTERFACE_DEFINED__

/* interface IEnumDiscMasterFormats */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumDiscMasterFormats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DDF445E1-54BA-11d3-9144-00104BA11C5E")
    IEnumDiscMasterFormats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG cFormats,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cFormats, *pcFetched) LPIID lpiidFormatID,
            /* [out] */ __RPC__out ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG cFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumDiscMasterFormats **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDiscMasterFormatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumDiscMasterFormats * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumDiscMasterFormats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumDiscMasterFormats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            __RPC__in IEnumDiscMasterFormats * This,
            /* [in] */ ULONG cFormats,
            /* [length_is][size_is][out] */ __RPC__out_ecount_part(cFormats, *pcFetched) LPIID lpiidFormatID,
            /* [out] */ __RPC__out ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumDiscMasterFormats * This,
            /* [in] */ ULONG cFormats);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumDiscMasterFormats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumDiscMasterFormats * This,
            /* [out] */ __RPC__deref_out_opt IEnumDiscMasterFormats **ppEnum);
        
        END_INTERFACE
    } IEnumDiscMasterFormatsVtbl;

    interface IEnumDiscMasterFormats
    {
        CONST_VTBL struct IEnumDiscMasterFormatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDiscMasterFormats_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDiscMasterFormats_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDiscMasterFormats_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDiscMasterFormats_Next(This,cFormats,lpiidFormatID,pcFetched)	\
    ( (This)->lpVtbl -> Next(This,cFormats,lpiidFormatID,pcFetched) ) 

#define IEnumDiscMasterFormats_Skip(This,cFormats)	\
    ( (This)->lpVtbl -> Skip(This,cFormats) ) 

#define IEnumDiscMasterFormats_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDiscMasterFormats_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDiscMasterFormats_INTERFACE_DEFINED__ */


#ifndef __IRedbookDiscMaster_INTERFACE_DEFINED__
#define __IRedbookDiscMaster_INTERFACE_DEFINED__

/* interface IRedbookDiscMaster */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IRedbookDiscMaster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3BC42CD-4E5C-11D3-9144-00104BA11C5E")
    IRedbookDiscMaster : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTotalAudioTracks( 
            /* [retval][out] */ __RPC__out long *pnTracks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTotalAudioBlocks( 
            /* [retval][out] */ __RPC__out long *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUsedAudioBlocks( 
            /* [retval][out] */ __RPC__out long *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAvailableAudioTrackBlocks( 
            /* [retval][out] */ __RPC__out long *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAudioBlockSize( 
            /* [retval][out] */ __RPC__out long *pnBlockBytes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateAudioTrack( 
            /* [in] */ long nBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddAudioTrackBlocks( 
            /* [size_is][in] */ __RPC__in_ecount_full(cb) byte *pby,
            /* [in] */ long cb) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CloseAudioTrack( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRedbookDiscMasterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IRedbookDiscMaster * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IRedbookDiscMaster * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IRedbookDiscMaster * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTotalAudioTracks )( 
            __RPC__in IRedbookDiscMaster * This,
            /* [retval][out] */ __RPC__out long *pnTracks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTotalAudioBlocks )( 
            __RPC__in IRedbookDiscMaster * This,
            /* [retval][out] */ __RPC__out long *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUsedAudioBlocks )( 
            __RPC__in IRedbookDiscMaster * This,
            /* [retval][out] */ __RPC__out long *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAvailableAudioTrackBlocks )( 
            __RPC__in IRedbookDiscMaster * This,
            /* [retval][out] */ __RPC__out long *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAudioBlockSize )( 
            __RPC__in IRedbookDiscMaster * This,
            /* [retval][out] */ __RPC__out long *pnBlockBytes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateAudioTrack )( 
            __RPC__in IRedbookDiscMaster * This,
            /* [in] */ long nBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddAudioTrackBlocks )( 
            __RPC__in IRedbookDiscMaster * This,
            /* [size_is][in] */ __RPC__in_ecount_full(cb) byte *pby,
            /* [in] */ long cb);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CloseAudioTrack )( 
            __RPC__in IRedbookDiscMaster * This);
        
        END_INTERFACE
    } IRedbookDiscMasterVtbl;

    interface IRedbookDiscMaster
    {
        CONST_VTBL struct IRedbookDiscMasterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRedbookDiscMaster_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRedbookDiscMaster_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRedbookDiscMaster_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRedbookDiscMaster_GetTotalAudioTracks(This,pnTracks)	\
    ( (This)->lpVtbl -> GetTotalAudioTracks(This,pnTracks) ) 

#define IRedbookDiscMaster_GetTotalAudioBlocks(This,pnBlocks)	\
    ( (This)->lpVtbl -> GetTotalAudioBlocks(This,pnBlocks) ) 

#define IRedbookDiscMaster_GetUsedAudioBlocks(This,pnBlocks)	\
    ( (This)->lpVtbl -> GetUsedAudioBlocks(This,pnBlocks) ) 

#define IRedbookDiscMaster_GetAvailableAudioTrackBlocks(This,pnBlocks)	\
    ( (This)->lpVtbl -> GetAvailableAudioTrackBlocks(This,pnBlocks) ) 

#define IRedbookDiscMaster_GetAudioBlockSize(This,pnBlockBytes)	\
    ( (This)->lpVtbl -> GetAudioBlockSize(This,pnBlockBytes) ) 

#define IRedbookDiscMaster_CreateAudioTrack(This,nBlocks)	\
    ( (This)->lpVtbl -> CreateAudioTrack(This,nBlocks) ) 

#define IRedbookDiscMaster_AddAudioTrackBlocks(This,pby,cb)	\
    ( (This)->lpVtbl -> AddAudioTrackBlocks(This,pby,cb) ) 

#define IRedbookDiscMaster_CloseAudioTrack(This)	\
    ( (This)->lpVtbl -> CloseAudioTrack(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRedbookDiscMaster_INTERFACE_DEFINED__ */


#ifndef __IJolietDiscMaster_INTERFACE_DEFINED__
#define __IJolietDiscMaster_INTERFACE_DEFINED__

/* interface IJolietDiscMaster */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IJolietDiscMaster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3BC42CE-4E5C-11D3-9144-00104BA11C5E")
    IJolietDiscMaster : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTotalDataBlocks( 
            /* [retval][out] */ __RPC__out long *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetUsedDataBlocks( 
            /* [retval][out] */ __RPC__out long *pnBlocks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDataBlockSize( 
            /* [retval][out] */ __RPC__out long *pnBlockBytes) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddData( 
            /* [in] */ __RPC__in_opt IStorage *pStorage,
            long lFileOverwrite) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetJolietProperties( 
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppPropStg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetJolietProperties( 
            /* [in] */ __RPC__in_opt IPropertyStorage *pPropStg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJolietDiscMasterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IJolietDiscMaster * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IJolietDiscMaster * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IJolietDiscMaster * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTotalDataBlocks )( 
            __RPC__in IJolietDiscMaster * This,
            /* [retval][out] */ __RPC__out long *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetUsedDataBlocks )( 
            __RPC__in IJolietDiscMaster * This,
            /* [retval][out] */ __RPC__out long *pnBlocks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDataBlockSize )( 
            __RPC__in IJolietDiscMaster * This,
            /* [retval][out] */ __RPC__out long *pnBlockBytes);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddData )( 
            __RPC__in IJolietDiscMaster * This,
            /* [in] */ __RPC__in_opt IStorage *pStorage,
            long lFileOverwrite);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetJolietProperties )( 
            __RPC__in IJolietDiscMaster * This,
            /* [out] */ __RPC__deref_out_opt IPropertyStorage **ppPropStg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetJolietProperties )( 
            __RPC__in IJolietDiscMaster * This,
            /* [in] */ __RPC__in_opt IPropertyStorage *pPropStg);
        
        END_INTERFACE
    } IJolietDiscMasterVtbl;

    interface IJolietDiscMaster
    {
        CONST_VTBL struct IJolietDiscMasterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJolietDiscMaster_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IJolietDiscMaster_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IJolietDiscMaster_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IJolietDiscMaster_GetTotalDataBlocks(This,pnBlocks)	\
    ( (This)->lpVtbl -> GetTotalDataBlocks(This,pnBlocks) ) 

#define IJolietDiscMaster_GetUsedDataBlocks(This,pnBlocks)	\
    ( (This)->lpVtbl -> GetUsedDataBlocks(This,pnBlocks) ) 

#define IJolietDiscMaster_GetDataBlockSize(This,pnBlockBytes)	\
    ( (This)->lpVtbl -> GetDataBlockSize(This,pnBlockBytes) ) 

#define IJolietDiscMaster_AddData(This,pStorage,lFileOverwrite)	\
    ( (This)->lpVtbl -> AddData(This,pStorage,lFileOverwrite) ) 

#define IJolietDiscMaster_GetJolietProperties(This,ppPropStg)	\
    ( (This)->lpVtbl -> GetJolietProperties(This,ppPropStg) ) 

#define IJolietDiscMaster_SetJolietProperties(This,pPropStg)	\
    ( (This)->lpVtbl -> SetJolietProperties(This,pPropStg) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IJolietDiscMaster_INTERFACE_DEFINED__ */


#ifndef __IDiscMasterProgressEvents_INTERFACE_DEFINED__
#define __IDiscMasterProgressEvents_INTERFACE_DEFINED__

/* interface IDiscMasterProgressEvents */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDiscMasterProgressEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EC9E51C1-4E5D-11D3-9144-00104BA11C5E")
    IDiscMasterProgressEvents : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryCancel( 
            /* [retval][out] */ __RPC__out boolean *pbCancel) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyPnPActivity( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyAddProgress( 
            /* [in] */ long nCompletedSteps,
            /* [in] */ long nTotalSteps) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyBlockProgress( 
            /* [in] */ long nCompleted,
            /* [in] */ long nTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyTrackProgress( 
            /* [in] */ long nCurrentTrack,
            /* [in] */ long nTotalTracks) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyPreparingBurn( 
            /* [in] */ long nEstimatedSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyClosingDisc( 
            /* [in] */ long nEstimatedSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyBurnComplete( 
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE NotifyEraseComplete( 
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscMasterProgressEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscMasterProgressEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscMasterProgressEvents * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *QueryCancel )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [retval][out] */ __RPC__out boolean *pbCancel);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyPnPActivity )( 
            __RPC__in IDiscMasterProgressEvents * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyAddProgress )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [in] */ long nCompletedSteps,
            /* [in] */ long nTotalSteps);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyBlockProgress )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [in] */ long nCompleted,
            /* [in] */ long nTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyTrackProgress )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [in] */ long nCurrentTrack,
            /* [in] */ long nTotalTracks);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyPreparingBurn )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [in] */ long nEstimatedSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyClosingDisc )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [in] */ long nEstimatedSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyBurnComplete )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [in] */ HRESULT status);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *NotifyEraseComplete )( 
            __RPC__in IDiscMasterProgressEvents * This,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } IDiscMasterProgressEventsVtbl;

    interface IDiscMasterProgressEvents
    {
        CONST_VTBL struct IDiscMasterProgressEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscMasterProgressEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscMasterProgressEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscMasterProgressEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscMasterProgressEvents_QueryCancel(This,pbCancel)	\
    ( (This)->lpVtbl -> QueryCancel(This,pbCancel) ) 

#define IDiscMasterProgressEvents_NotifyPnPActivity(This)	\
    ( (This)->lpVtbl -> NotifyPnPActivity(This) ) 

#define IDiscMasterProgressEvents_NotifyAddProgress(This,nCompletedSteps,nTotalSteps)	\
    ( (This)->lpVtbl -> NotifyAddProgress(This,nCompletedSteps,nTotalSteps) ) 

#define IDiscMasterProgressEvents_NotifyBlockProgress(This,nCompleted,nTotal)	\
    ( (This)->lpVtbl -> NotifyBlockProgress(This,nCompleted,nTotal) ) 

#define IDiscMasterProgressEvents_NotifyTrackProgress(This,nCurrentTrack,nTotalTracks)	\
    ( (This)->lpVtbl -> NotifyTrackProgress(This,nCurrentTrack,nTotalTracks) ) 

#define IDiscMasterProgressEvents_NotifyPreparingBurn(This,nEstimatedSeconds)	\
    ( (This)->lpVtbl -> NotifyPreparingBurn(This,nEstimatedSeconds) ) 

#define IDiscMasterProgressEvents_NotifyClosingDisc(This,nEstimatedSeconds)	\
    ( (This)->lpVtbl -> NotifyClosingDisc(This,nEstimatedSeconds) ) 

#define IDiscMasterProgressEvents_NotifyBurnComplete(This,status)	\
    ( (This)->lpVtbl -> NotifyBurnComplete(This,status) ) 

#define IDiscMasterProgressEvents_NotifyEraseComplete(This,status)	\
    ( (This)->lpVtbl -> NotifyEraseComplete(This,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscMasterProgressEvents_INTERFACE_DEFINED__ */


#ifndef __IDiscMaster_INTERFACE_DEFINED__
#define __IDiscMaster_INTERFACE_DEFINED__

/* interface IDiscMaster */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDiscMaster;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("520CCA62-51A5-11D3-9144-00104BA11C5E")
    IDiscMaster : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Open( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDiscMasterFormats( 
            /* [out] */ __RPC__deref_out_opt IEnumDiscMasterFormats **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetActiveDiscMasterFormat( 
            /* [out] */ __RPC__out LPIID lpiid) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetActiveDiscMasterFormat( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppUnk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDiscRecorders( 
            /* [out] */ __RPC__deref_out_opt IEnumDiscRecorders **ppEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetActiveDiscRecorder( 
            /* [out] */ __RPC__deref_out_opt IDiscRecorder **ppRecorder) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetActiveDiscRecorder( 
            /* [in] */ __RPC__in_opt IDiscRecorder *pRecorder) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ClearFormatContent( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ProgressAdvise( 
            /* [in] */ __RPC__in_opt IDiscMasterProgressEvents *pEvents,
            /* [retval][out] */ __RPC__out UINT_PTR *pvCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ProgressUnadvise( 
            /* [in] */ UINT_PTR vCookie) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RecordDisc( 
            /* [in] */ boolean bSimulate,
            /* [in] */ boolean bEjectAfterBurn) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDiscMasterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDiscMaster * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDiscMaster * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDiscMaster * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Open )( 
            __RPC__in IDiscMaster * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDiscMasterFormats )( 
            __RPC__in IDiscMaster * This,
            /* [out] */ __RPC__deref_out_opt IEnumDiscMasterFormats **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetActiveDiscMasterFormat )( 
            __RPC__in IDiscMaster * This,
            /* [out] */ __RPC__out LPIID lpiid);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetActiveDiscMasterFormat )( 
            __RPC__in IDiscMaster * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppUnk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDiscRecorders )( 
            __RPC__in IDiscMaster * This,
            /* [out] */ __RPC__deref_out_opt IEnumDiscRecorders **ppEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetActiveDiscRecorder )( 
            __RPC__in IDiscMaster * This,
            /* [out] */ __RPC__deref_out_opt IDiscRecorder **ppRecorder);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetActiveDiscRecorder )( 
            __RPC__in IDiscMaster * This,
            /* [in] */ __RPC__in_opt IDiscRecorder *pRecorder);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ClearFormatContent )( 
            __RPC__in IDiscMaster * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ProgressAdvise )( 
            __RPC__in IDiscMaster * This,
            /* [in] */ __RPC__in_opt IDiscMasterProgressEvents *pEvents,
            /* [retval][out] */ __RPC__out UINT_PTR *pvCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ProgressUnadvise )( 
            __RPC__in IDiscMaster * This,
            /* [in] */ UINT_PTR vCookie);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RecordDisc )( 
            __RPC__in IDiscMaster * This,
            /* [in] */ boolean bSimulate,
            /* [in] */ boolean bEjectAfterBurn);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IDiscMaster * This);
        
        END_INTERFACE
    } IDiscMasterVtbl;

    interface IDiscMaster
    {
        CONST_VTBL struct IDiscMasterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDiscMaster_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDiscMaster_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDiscMaster_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDiscMaster_Open(This)	\
    ( (This)->lpVtbl -> Open(This) ) 

#define IDiscMaster_EnumDiscMasterFormats(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumDiscMasterFormats(This,ppEnum) ) 

#define IDiscMaster_GetActiveDiscMasterFormat(This,lpiid)	\
    ( (This)->lpVtbl -> GetActiveDiscMasterFormat(This,lpiid) ) 

#define IDiscMaster_SetActiveDiscMasterFormat(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> SetActiveDiscMasterFormat(This,riid,ppUnk) ) 

#define IDiscMaster_EnumDiscRecorders(This,ppEnum)	\
    ( (This)->lpVtbl -> EnumDiscRecorders(This,ppEnum) ) 

#define IDiscMaster_GetActiveDiscRecorder(This,ppRecorder)	\
    ( (This)->lpVtbl -> GetActiveDiscRecorder(This,ppRecorder) ) 

#define IDiscMaster_SetActiveDiscRecorder(This,pRecorder)	\
    ( (This)->lpVtbl -> SetActiveDiscRecorder(This,pRecorder) ) 

#define IDiscMaster_ClearFormatContent(This)	\
    ( (This)->lpVtbl -> ClearFormatContent(This) ) 

#define IDiscMaster_ProgressAdvise(This,pEvents,pvCookie)	\
    ( (This)->lpVtbl -> ProgressAdvise(This,pEvents,pvCookie) ) 

#define IDiscMaster_ProgressUnadvise(This,vCookie)	\
    ( (This)->lpVtbl -> ProgressUnadvise(This,vCookie) ) 

#define IDiscMaster_RecordDisc(This,bSimulate,bEjectAfterBurn)	\
    ( (This)->lpVtbl -> RecordDisc(This,bSimulate,bEjectAfterBurn) ) 

#define IDiscMaster_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDiscMaster_INTERFACE_DEFINED__ */



#ifndef __IMAPILib_LIBRARY_DEFINED__
#define __IMAPILib_LIBRARY_DEFINED__

/* library IMAPILib */
/* [helpstring][version][uuid] */ 





EXTERN_C const IID LIBID_IMAPILib;

EXTERN_C const CLSID CLSID_MSDiscRecorderObj;

#ifdef __cplusplus

class DECLSPEC_UUID("520CCA61-51A5-11D3-9144-00104BA11C5E")
MSDiscRecorderObj;
#endif

EXTERN_C const CLSID CLSID_MSDiscMasterObj;

#ifdef __cplusplus

class DECLSPEC_UUID("520CCA63-51A5-11D3-9144-00104BA11C5E")
MSDiscMasterObj;
#endif

EXTERN_C const CLSID CLSID_MSEnumDiscRecordersObj;

#ifdef __cplusplus

class DECLSPEC_UUID("8A03567A-63CB-4BA8-BAF6-52119816D1EF")
MSEnumDiscRecordersObj;
#endif
#endif /* __IMAPILib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\imapi2fs.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for imapi2fs.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imapi2fs_h__
#define __imapi2fs_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IBootOptions_FWD_DEFINED__
#define __IBootOptions_FWD_DEFINED__
typedef interface IBootOptions IBootOptions;
#endif 	/* __IBootOptions_FWD_DEFINED__ */


#ifndef __IProgressItem_FWD_DEFINED__
#define __IProgressItem_FWD_DEFINED__
typedef interface IProgressItem IProgressItem;
#endif 	/* __IProgressItem_FWD_DEFINED__ */


#ifndef __IEnumProgressItems_FWD_DEFINED__
#define __IEnumProgressItems_FWD_DEFINED__
typedef interface IEnumProgressItems IEnumProgressItems;
#endif 	/* __IEnumProgressItems_FWD_DEFINED__ */


#ifndef __IProgressItems_FWD_DEFINED__
#define __IProgressItems_FWD_DEFINED__
typedef interface IProgressItems IProgressItems;
#endif 	/* __IProgressItems_FWD_DEFINED__ */


#ifndef __IFileSystemImageResult_FWD_DEFINED__
#define __IFileSystemImageResult_FWD_DEFINED__
typedef interface IFileSystemImageResult IFileSystemImageResult;
#endif 	/* __IFileSystemImageResult_FWD_DEFINED__ */


#ifndef __IFileSystemImageResult2_FWD_DEFINED__
#define __IFileSystemImageResult2_FWD_DEFINED__
typedef interface IFileSystemImageResult2 IFileSystemImageResult2;
#endif 	/* __IFileSystemImageResult2_FWD_DEFINED__ */


#ifndef __IFsiItem_FWD_DEFINED__
#define __IFsiItem_FWD_DEFINED__
typedef interface IFsiItem IFsiItem;
#endif 	/* __IFsiItem_FWD_DEFINED__ */


#ifndef __IEnumFsiItems_FWD_DEFINED__
#define __IEnumFsiItems_FWD_DEFINED__
typedef interface IEnumFsiItems IEnumFsiItems;
#endif 	/* __IEnumFsiItems_FWD_DEFINED__ */


#ifndef __IFsiFileItem_FWD_DEFINED__
#define __IFsiFileItem_FWD_DEFINED__
typedef interface IFsiFileItem IFsiFileItem;
#endif 	/* __IFsiFileItem_FWD_DEFINED__ */


#ifndef __IFsiFileItem2_FWD_DEFINED__
#define __IFsiFileItem2_FWD_DEFINED__
typedef interface IFsiFileItem2 IFsiFileItem2;
#endif 	/* __IFsiFileItem2_FWD_DEFINED__ */


#ifndef __IFsiNamedStreams_FWD_DEFINED__
#define __IFsiNamedStreams_FWD_DEFINED__
typedef interface IFsiNamedStreams IFsiNamedStreams;
#endif 	/* __IFsiNamedStreams_FWD_DEFINED__ */


#ifndef __IFsiDirectoryItem_FWD_DEFINED__
#define __IFsiDirectoryItem_FWD_DEFINED__
typedef interface IFsiDirectoryItem IFsiDirectoryItem;
#endif 	/* __IFsiDirectoryItem_FWD_DEFINED__ */


#ifndef __IFsiDirectoryItem2_FWD_DEFINED__
#define __IFsiDirectoryItem2_FWD_DEFINED__
typedef interface IFsiDirectoryItem2 IFsiDirectoryItem2;
#endif 	/* __IFsiDirectoryItem2_FWD_DEFINED__ */


#ifndef __IFileSystemImage_FWD_DEFINED__
#define __IFileSystemImage_FWD_DEFINED__
typedef interface IFileSystemImage IFileSystemImage;
#endif 	/* __IFileSystemImage_FWD_DEFINED__ */


#ifndef __IFileSystemImage2_FWD_DEFINED__
#define __IFileSystemImage2_FWD_DEFINED__
typedef interface IFileSystemImage2 IFileSystemImage2;
#endif 	/* __IFileSystemImage2_FWD_DEFINED__ */


#ifndef __IFileSystemImage3_FWD_DEFINED__
#define __IFileSystemImage3_FWD_DEFINED__
typedef interface IFileSystemImage3 IFileSystemImage3;
#endif 	/* __IFileSystemImage3_FWD_DEFINED__ */


#ifndef __DFileSystemImageEvents_FWD_DEFINED__
#define __DFileSystemImageEvents_FWD_DEFINED__
typedef interface DFileSystemImageEvents DFileSystemImageEvents;
#endif 	/* __DFileSystemImageEvents_FWD_DEFINED__ */


#ifndef __DFileSystemImageImportEvents_FWD_DEFINED__
#define __DFileSystemImageImportEvents_FWD_DEFINED__
typedef interface DFileSystemImageImportEvents DFileSystemImageImportEvents;
#endif 	/* __DFileSystemImageImportEvents_FWD_DEFINED__ */


#ifndef __IIsoImageManager_FWD_DEFINED__
#define __IIsoImageManager_FWD_DEFINED__
typedef interface IIsoImageManager IIsoImageManager;
#endif 	/* __IIsoImageManager_FWD_DEFINED__ */


#ifndef __DFileSystemImageEvents_FWD_DEFINED__
#define __DFileSystemImageEvents_FWD_DEFINED__
typedef interface DFileSystemImageEvents DFileSystemImageEvents;
#endif 	/* __DFileSystemImageEvents_FWD_DEFINED__ */


#ifndef __DFileSystemImageImportEvents_FWD_DEFINED__
#define __DFileSystemImageImportEvents_FWD_DEFINED__
typedef interface DFileSystemImageImportEvents DFileSystemImageImportEvents;
#endif 	/* __DFileSystemImageImportEvents_FWD_DEFINED__ */


#ifndef __BootOptions_FWD_DEFINED__
#define __BootOptions_FWD_DEFINED__

#ifdef __cplusplus
typedef class BootOptions BootOptions;
#else
typedef struct BootOptions BootOptions;
#endif /* __cplusplus */

#endif 	/* __BootOptions_FWD_DEFINED__ */


#ifndef __FsiStream_FWD_DEFINED__
#define __FsiStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class FsiStream FsiStream;
#else
typedef struct FsiStream FsiStream;
#endif /* __cplusplus */

#endif 	/* __FsiStream_FWD_DEFINED__ */


#ifndef __FileSystemImageResult_FWD_DEFINED__
#define __FileSystemImageResult_FWD_DEFINED__

#ifdef __cplusplus
typedef class FileSystemImageResult FileSystemImageResult;
#else
typedef struct FileSystemImageResult FileSystemImageResult;
#endif /* __cplusplus */

#endif 	/* __FileSystemImageResult_FWD_DEFINED__ */


#ifndef __ProgressItem_FWD_DEFINED__
#define __ProgressItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProgressItem ProgressItem;
#else
typedef struct ProgressItem ProgressItem;
#endif /* __cplusplus */

#endif 	/* __ProgressItem_FWD_DEFINED__ */


#ifndef __EnumProgressItems_FWD_DEFINED__
#define __EnumProgressItems_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumProgressItems EnumProgressItems;
#else
typedef struct EnumProgressItems EnumProgressItems;
#endif /* __cplusplus */

#endif 	/* __EnumProgressItems_FWD_DEFINED__ */


#ifndef __ProgressItems_FWD_DEFINED__
#define __ProgressItems_FWD_DEFINED__

#ifdef __cplusplus
typedef class ProgressItems ProgressItems;
#else
typedef struct ProgressItems ProgressItems;
#endif /* __cplusplus */

#endif 	/* __ProgressItems_FWD_DEFINED__ */


#ifndef __FsiDirectoryItem_FWD_DEFINED__
#define __FsiDirectoryItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class FsiDirectoryItem FsiDirectoryItem;
#else
typedef struct FsiDirectoryItem FsiDirectoryItem;
#endif /* __cplusplus */

#endif 	/* __FsiDirectoryItem_FWD_DEFINED__ */


#ifndef __FsiFileItem_FWD_DEFINED__
#define __FsiFileItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class FsiFileItem FsiFileItem;
#else
typedef struct FsiFileItem FsiFileItem;
#endif /* __cplusplus */

#endif 	/* __FsiFileItem_FWD_DEFINED__ */


#ifndef __EnumFsiItems_FWD_DEFINED__
#define __EnumFsiItems_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumFsiItems EnumFsiItems;
#else
typedef struct EnumFsiItems EnumFsiItems;
#endif /* __cplusplus */

#endif 	/* __EnumFsiItems_FWD_DEFINED__ */


#ifndef __FsiNamedStreams_FWD_DEFINED__
#define __FsiNamedStreams_FWD_DEFINED__

#ifdef __cplusplus
typedef class FsiNamedStreams FsiNamedStreams;
#else
typedef struct FsiNamedStreams FsiNamedStreams;
#endif /* __cplusplus */

#endif 	/* __FsiNamedStreams_FWD_DEFINED__ */


#ifndef __MsftFileSystemImage_FWD_DEFINED__
#define __MsftFileSystemImage_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftFileSystemImage MsftFileSystemImage;
#else
typedef struct MsftFileSystemImage MsftFileSystemImage;
#endif /* __cplusplus */

#endif 	/* __MsftFileSystemImage_FWD_DEFINED__ */


#ifndef __MsftIsoImageManager_FWD_DEFINED__
#define __MsftIsoImageManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsftIsoImageManager MsftIsoImageManager;
#else
typedef struct MsftIsoImageManager MsftIsoImageManager;
#endif /* __cplusplus */

#endif 	/* __MsftIsoImageManager_FWD_DEFINED__ */


#ifndef __BlockRange_FWD_DEFINED__
#define __BlockRange_FWD_DEFINED__

#ifdef __cplusplus
typedef class BlockRange BlockRange;
#else
typedef struct BlockRange BlockRange;
#endif /* __cplusplus */

#endif 	/* __BlockRange_FWD_DEFINED__ */


#ifndef __BlockRangeList_FWD_DEFINED__
#define __BlockRangeList_FWD_DEFINED__

#ifdef __cplusplus
typedef class BlockRangeList BlockRangeList;
#else
typedef struct BlockRangeList BlockRangeList;
#endif /* __cplusplus */

#endif 	/* __BlockRangeList_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "imapi2.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_imapi2fs_0000_0000 */
/* [local] */ 

#define IMAPI2FS_BOOT_ENTRY_COUNT_MAX    32
typedef /* [helpstring][public][v1_enum] */ 
enum FsiItemType
    {	FsiItemNotFound	= 0,
	FsiItemDirectory	= 1,
	FsiItemFile	= 2
    } 	FsiItemType;

typedef /* [helpstring][public][v1_enum] */ 
enum FsiFileSystems
    {	FsiFileSystemNone	= 0,
	FsiFileSystemISO9660	= 1,
	FsiFileSystemJoliet	= 2,
	FsiFileSystemUDF	= 4,
	FsiFileSystemUnknown	= 0x40000000
    } 	FsiFileSystems;

typedef /* [helpstring][public][v1_enum] */ 
enum EmulationType
    {	EmulationNone	= 0,
	Emulation12MFloppy	= 1,
	Emulation144MFloppy	= 2,
	Emulation288MFloppy	= 3,
	EmulationHardDisk	= 4
    } 	EmulationType;

typedef /* [helpstring][public][v1_enum] */ 
enum PlatformId
    {	PlatformX86	= 0,
	PlatformPowerPC	= 1,
	PlatformMac	= 2,
	PlatformEFI	= 0xef
    } 	PlatformId;



extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0000_v0_0_s_ifspec;

#ifndef __IBootOptions_INTERFACE_DEFINED__
#define __IBootOptions_INTERFACE_DEFINED__

/* interface IBootOptions */
/* [helpstring][uuid][oleautomation][nonextensible][dual][unique][object] */ 


EXTERN_C const IID IID_IBootOptions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FD4-975B-59BE-A960-9A2A262853A5")
    IBootOptions : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BootImage( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Manufacturer( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Manufacturer( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PlatformId( 
            /* [retval][out] */ __RPC__out PlatformId *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_PlatformId( 
            /* [in] */ PlatformId newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Emulation( 
            /* [retval][out] */ __RPC__out EmulationType *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Emulation( 
            /* [in] */ EmulationType newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageSize( 
            /* [retval][out] */ __RPC__out ULONG *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AssignBootImage( 
            /* [in] */ __RPC__in_opt IStream *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IBootOptionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IBootOptions * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IBootOptions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IBootOptions * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IBootOptions * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IBootOptions * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IBootOptions * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IBootOptions * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BootImage )( 
            __RPC__in IBootOptions * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Manufacturer )( 
            __RPC__in IBootOptions * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Manufacturer )( 
            __RPC__in IBootOptions * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PlatformId )( 
            __RPC__in IBootOptions * This,
            /* [retval][out] */ __RPC__out PlatformId *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_PlatformId )( 
            __RPC__in IBootOptions * This,
            /* [in] */ PlatformId newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Emulation )( 
            __RPC__in IBootOptions * This,
            /* [retval][out] */ __RPC__out EmulationType *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Emulation )( 
            __RPC__in IBootOptions * This,
            /* [in] */ EmulationType newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageSize )( 
            __RPC__in IBootOptions * This,
            /* [retval][out] */ __RPC__out ULONG *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AssignBootImage )( 
            __RPC__in IBootOptions * This,
            /* [in] */ __RPC__in_opt IStream *newVal);
        
        END_INTERFACE
    } IBootOptionsVtbl;

    interface IBootOptions
    {
        CONST_VTBL struct IBootOptionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IBootOptions_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IBootOptions_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IBootOptions_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IBootOptions_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IBootOptions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IBootOptions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IBootOptions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IBootOptions_get_BootImage(This,pVal)	\
    ( (This)->lpVtbl -> get_BootImage(This,pVal) ) 

#define IBootOptions_get_Manufacturer(This,pVal)	\
    ( (This)->lpVtbl -> get_Manufacturer(This,pVal) ) 

#define IBootOptions_put_Manufacturer(This,newVal)	\
    ( (This)->lpVtbl -> put_Manufacturer(This,newVal) ) 

#define IBootOptions_get_PlatformId(This,pVal)	\
    ( (This)->lpVtbl -> get_PlatformId(This,pVal) ) 

#define IBootOptions_put_PlatformId(This,newVal)	\
    ( (This)->lpVtbl -> put_PlatformId(This,newVal) ) 

#define IBootOptions_get_Emulation(This,pVal)	\
    ( (This)->lpVtbl -> get_Emulation(This,pVal) ) 

#define IBootOptions_put_Emulation(This,newVal)	\
    ( (This)->lpVtbl -> put_Emulation(This,newVal) ) 

#define IBootOptions_get_ImageSize(This,pVal)	\
    ( (This)->lpVtbl -> get_ImageSize(This,pVal) ) 

#define IBootOptions_AssignBootImage(This,newVal)	\
    ( (This)->lpVtbl -> AssignBootImage(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IBootOptions_INTERFACE_DEFINED__ */


#ifndef __IProgressItem_INTERFACE_DEFINED__
#define __IProgressItem_INTERFACE_DEFINED__

/* interface IProgressItem */
/* [helpstring][uuid][oleautomation][nonextensible][dual][unique][object] */ 


EXTERN_C const IID IID_IProgressItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FD5-975B-59BE-A960-9A2A262853A5")
    IProgressItem : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *desc) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FirstBlock( 
            /* [retval][out] */ __RPC__out ULONG *block) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastBlock( 
            /* [retval][out] */ __RPC__out ULONG *block) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockCount( 
            /* [retval][out] */ __RPC__out ULONG *blocks) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProgressItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProgressItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProgressItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProgressItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IProgressItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IProgressItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IProgressItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IProgressItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            __RPC__in IProgressItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *desc);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FirstBlock )( 
            __RPC__in IProgressItem * This,
            /* [retval][out] */ __RPC__out ULONG *block);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastBlock )( 
            __RPC__in IProgressItem * This,
            /* [retval][out] */ __RPC__out ULONG *block);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockCount )( 
            __RPC__in IProgressItem * This,
            /* [retval][out] */ __RPC__out ULONG *blocks);
        
        END_INTERFACE
    } IProgressItemVtbl;

    interface IProgressItem
    {
        CONST_VTBL struct IProgressItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProgressItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProgressItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProgressItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProgressItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IProgressItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IProgressItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IProgressItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IProgressItem_get_Description(This,desc)	\
    ( (This)->lpVtbl -> get_Description(This,desc) ) 

#define IProgressItem_get_FirstBlock(This,block)	\
    ( (This)->lpVtbl -> get_FirstBlock(This,block) ) 

#define IProgressItem_get_LastBlock(This,block)	\
    ( (This)->lpVtbl -> get_LastBlock(This,block) ) 

#define IProgressItem_get_BlockCount(This,blocks)	\
    ( (This)->lpVtbl -> get_BlockCount(This,blocks) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProgressItem_INTERFACE_DEFINED__ */


#ifndef __IEnumProgressItems_INTERFACE_DEFINED__
#define __IEnumProgressItems_INTERFACE_DEFINED__

/* interface IEnumProgressItems */
/* [helpstring][uuid][unique][object] */ 


EXTERN_C const IID IID_IEnumProgressItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FD6-975B-59BE-A960-9A2A262853A5")
    IEnumProgressItems : public IUnknown
    {
    public:
        virtual /* [helpstring][local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ IProgressItem **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumProgressItems **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumProgressItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumProgressItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumProgressItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumProgressItems * This);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumProgressItems * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ IProgressItem **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumProgressItems * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumProgressItems * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumProgressItems * This,
            /* [out] */ __RPC__deref_out_opt IEnumProgressItems **ppEnum);
        
        END_INTERFACE
    } IEnumProgressItemsVtbl;

    interface IEnumProgressItems
    {
        CONST_VTBL struct IEnumProgressItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumProgressItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumProgressItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumProgressItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumProgressItems_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumProgressItems_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumProgressItems_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumProgressItems_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumProgressItems_RemoteNext_Proxy( 
    __RPC__in IEnumProgressItems * This,
    /* [range][in] */ __RPC__in_range(1,0x7fffffff) ULONG celt,
    /* [size_is][out] */ __RPC__out_ecount_full(celt) IProgressItem **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumProgressItems_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumProgressItems_INTERFACE_DEFINED__ */


#ifndef __IProgressItems_INTERFACE_DEFINED__
#define __IProgressItems_INTERFACE_DEFINED__

/* interface IProgressItems */
/* [helpstring][uuid][oleautomation][nonextensible][dual][unique][object] */ 


EXTERN_C const IID IID_IProgressItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FD7-975B-59BE-A960-9A2A262853A5")
    IProgressItems : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **NewEnum) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__deref_out_opt IProgressItem **item) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *Count) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProgressItemFromBlock( 
            /* [in] */ ULONG block,
            /* [retval][out] */ __RPC__deref_out_opt IProgressItem **item) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProgressItemFromDescription( 
            /* [in] */ __RPC__in BSTR description,
            /* [retval][out] */ __RPC__deref_out_opt IProgressItem **item) = 0;
        
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumProgressItems( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumProgressItems **NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProgressItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IProgressItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IProgressItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IProgressItems * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IProgressItems * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IProgressItems * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IProgressItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IProgressItems * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IProgressItems * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **NewEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IProgressItems * This,
            /* [in] */ long Index,
            /* [retval][out] */ __RPC__deref_out_opt IProgressItem **item);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IProgressItems * This,
            /* [retval][out] */ __RPC__out long *Count);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ProgressItemFromBlock )( 
            __RPC__in IProgressItems * This,
            /* [in] */ ULONG block,
            /* [retval][out] */ __RPC__deref_out_opt IProgressItem **item);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ProgressItemFromDescription )( 
            __RPC__in IProgressItems * This,
            /* [in] */ __RPC__in BSTR description,
            /* [retval][out] */ __RPC__deref_out_opt IProgressItem **item);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumProgressItems )( 
            __RPC__in IProgressItems * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumProgressItems **NewEnum);
        
        END_INTERFACE
    } IProgressItemsVtbl;

    interface IProgressItems
    {
        CONST_VTBL struct IProgressItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProgressItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProgressItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProgressItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProgressItems_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IProgressItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IProgressItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IProgressItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IProgressItems_get__NewEnum(This,NewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,NewEnum) ) 

#define IProgressItems_get_Item(This,Index,item)	\
    ( (This)->lpVtbl -> get_Item(This,Index,item) ) 

#define IProgressItems_get_Count(This,Count)	\
    ( (This)->lpVtbl -> get_Count(This,Count) ) 

#define IProgressItems_ProgressItemFromBlock(This,block,item)	\
    ( (This)->lpVtbl -> ProgressItemFromBlock(This,block,item) ) 

#define IProgressItems_ProgressItemFromDescription(This,description,item)	\
    ( (This)->lpVtbl -> ProgressItemFromDescription(This,description,item) ) 

#define IProgressItems_get_EnumProgressItems(This,NewEnum)	\
    ( (This)->lpVtbl -> get_EnumProgressItems(This,NewEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProgressItems_INTERFACE_DEFINED__ */


#ifndef __IFileSystemImageResult_INTERFACE_DEFINED__
#define __IFileSystemImageResult_INTERFACE_DEFINED__

/* interface IFileSystemImageResult */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFileSystemImageResult;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FD8-975B-59BE-A960-9A2A262853A5")
    IFileSystemImageResult : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImageStream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ProgressItems( 
            /* [retval][out] */ __RPC__deref_out_opt IProgressItems **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBlocks( 
            /* [retval][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BlockSize( 
            /* [retval][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DiscId( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemImageResultVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileSystemImageResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileSystemImageResult * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileSystemImageResult * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFileSystemImageResult * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFileSystemImageResult * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFileSystemImageResult * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFileSystemImageResult * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageStream )( 
            __RPC__in IFileSystemImageResult * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProgressItems )( 
            __RPC__in IFileSystemImageResult * This,
            /* [retval][out] */ __RPC__deref_out_opt IProgressItems **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalBlocks )( 
            __RPC__in IFileSystemImageResult * This,
            /* [retval][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockSize )( 
            __RPC__in IFileSystemImageResult * This,
            /* [retval][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscId )( 
            __RPC__in IFileSystemImageResult * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        END_INTERFACE
    } IFileSystemImageResultVtbl;

    interface IFileSystemImageResult
    {
        CONST_VTBL struct IFileSystemImageResultVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemImageResult_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemImageResult_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemImageResult_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemImageResult_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFileSystemImageResult_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFileSystemImageResult_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFileSystemImageResult_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFileSystemImageResult_get_ImageStream(This,pVal)	\
    ( (This)->lpVtbl -> get_ImageStream(This,pVal) ) 

#define IFileSystemImageResult_get_ProgressItems(This,pVal)	\
    ( (This)->lpVtbl -> get_ProgressItems(This,pVal) ) 

#define IFileSystemImageResult_get_TotalBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_TotalBlocks(This,pVal) ) 

#define IFileSystemImageResult_get_BlockSize(This,pVal)	\
    ( (This)->lpVtbl -> get_BlockSize(This,pVal) ) 

#define IFileSystemImageResult_get_DiscId(This,pVal)	\
    ( (This)->lpVtbl -> get_DiscId(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemImageResult_INTERFACE_DEFINED__ */


#ifndef __IFileSystemImageResult2_INTERFACE_DEFINED__
#define __IFileSystemImageResult2_INTERFACE_DEFINED__

/* interface IFileSystemImageResult2 */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFileSystemImageResult2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B507CA29-2204-11DD-966A-001AA01BBC58")
    IFileSystemImageResult2 : public IFileSystemImageResult
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModifiedBlocks( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IBlockRangeList **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemImageResult2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileSystemImageResult2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileSystemImageResult2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFileSystemImageResult2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImageStream )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ProgressItems )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IProgressItems **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TotalBlocks )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [retval][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BlockSize )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [retval][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DiscId )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModifiedBlocks )( 
            __RPC__in IFileSystemImageResult2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IBlockRangeList **pVal);
        
        END_INTERFACE
    } IFileSystemImageResult2Vtbl;

    interface IFileSystemImageResult2
    {
        CONST_VTBL struct IFileSystemImageResult2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemImageResult2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemImageResult2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemImageResult2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemImageResult2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFileSystemImageResult2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFileSystemImageResult2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFileSystemImageResult2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFileSystemImageResult2_get_ImageStream(This,pVal)	\
    ( (This)->lpVtbl -> get_ImageStream(This,pVal) ) 

#define IFileSystemImageResult2_get_ProgressItems(This,pVal)	\
    ( (This)->lpVtbl -> get_ProgressItems(This,pVal) ) 

#define IFileSystemImageResult2_get_TotalBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_TotalBlocks(This,pVal) ) 

#define IFileSystemImageResult2_get_BlockSize(This,pVal)	\
    ( (This)->lpVtbl -> get_BlockSize(This,pVal) ) 

#define IFileSystemImageResult2_get_DiscId(This,pVal)	\
    ( (This)->lpVtbl -> get_DiscId(This,pVal) ) 


#define IFileSystemImageResult2_get_ModifiedBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_ModifiedBlocks(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemImageResult2_INTERFACE_DEFINED__ */


#ifndef __IFsiItem_INTERFACE_DEFINED__
#define __IFsiItem_INTERFACE_DEFINED__

/* interface IFsiItem */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFsiItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FD9-975B-59BE-A960-9A2A262853A5")
    IFsiItem : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FullPath( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CreationTime( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CreationTime( 
            /* [in] */ DATE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastAccessedTime( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LastAccessedTime( 
            /* [in] */ DATE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LastModifiedTime( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LastModifiedTime( 
            /* [in] */ DATE newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsHidden( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsHidden( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FileSystemName( 
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FileSystemPath( 
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFsiItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFsiItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFsiItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFsiItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFsiItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFsiItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFsiItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFsiItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IFsiItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullPath )( 
            __RPC__in IFsiItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            __RPC__in IFsiItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CreationTime )( 
            __RPC__in IFsiItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastAccessedTime )( 
            __RPC__in IFsiItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastAccessedTime )( 
            __RPC__in IFsiItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastModifiedTime )( 
            __RPC__in IFsiItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastModifiedTime )( 
            __RPC__in IFsiItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            __RPC__in IFsiItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            __RPC__in IFsiItem * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemName )( 
            __RPC__in IFsiItem * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemPath )( 
            __RPC__in IFsiItem * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        END_INTERFACE
    } IFsiItemVtbl;

    interface IFsiItem
    {
        CONST_VTBL struct IFsiItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFsiItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFsiItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFsiItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFsiItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFsiItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFsiItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFsiItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFsiItem_get_Name(This,pVal)	\
    ( (This)->lpVtbl -> get_Name(This,pVal) ) 

#define IFsiItem_get_FullPath(This,pVal)	\
    ( (This)->lpVtbl -> get_FullPath(This,pVal) ) 

#define IFsiItem_get_CreationTime(This,pVal)	\
    ( (This)->lpVtbl -> get_CreationTime(This,pVal) ) 

#define IFsiItem_put_CreationTime(This,newVal)	\
    ( (This)->lpVtbl -> put_CreationTime(This,newVal) ) 

#define IFsiItem_get_LastAccessedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastAccessedTime(This,pVal) ) 

#define IFsiItem_put_LastAccessedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastAccessedTime(This,newVal) ) 

#define IFsiItem_get_LastModifiedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastModifiedTime(This,pVal) ) 

#define IFsiItem_put_LastModifiedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastModifiedTime(This,newVal) ) 

#define IFsiItem_get_IsHidden(This,pVal)	\
    ( (This)->lpVtbl -> get_IsHidden(This,pVal) ) 

#define IFsiItem_put_IsHidden(This,newVal)	\
    ( (This)->lpVtbl -> put_IsHidden(This,newVal) ) 

#define IFsiItem_FileSystemName(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemName(This,fileSystem,pVal) ) 

#define IFsiItem_FileSystemPath(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemPath(This,fileSystem,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFsiItem_INTERFACE_DEFINED__ */


#ifndef __IEnumFsiItems_INTERFACE_DEFINED__
#define __IEnumFsiItems_INTERFACE_DEFINED__

/* interface IEnumFsiItems */
/* [helpstring][uuid][unique][object] */ 


EXTERN_C const IID IID_IEnumFsiItems;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FDA-975B-59BE-A960-9A2A262853A5")
    IEnumFsiItems : public IUnknown
    {
    public:
        virtual /* [helpstring][local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [size_is][out] */ IFsiItem **rgelt,
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ __RPC__deref_out_opt IEnumFsiItems **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumFsiItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IEnumFsiItems * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IEnumFsiItems * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IEnumFsiItems * This);
        
        /* [helpstring][local] */ HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumFsiItems * This,
            /* [in] */ ULONG celt,
            /* [size_is][out] */ IFsiItem **rgelt,
            /* [out] */ ULONG *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Skip )( 
            __RPC__in IEnumFsiItems * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IEnumFsiItems * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Clone )( 
            __RPC__in IEnumFsiItems * This,
            /* [out] */ __RPC__deref_out_opt IEnumFsiItems **ppEnum);
        
        END_INTERFACE
    } IEnumFsiItemsVtbl;

    interface IEnumFsiItems
    {
        CONST_VTBL struct IEnumFsiItemsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumFsiItems_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumFsiItems_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumFsiItems_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumFsiItems_Next(This,celt,rgelt,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched) ) 

#define IEnumFsiItems_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumFsiItems_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumFsiItems_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumFsiItems_RemoteNext_Proxy( 
    __RPC__in IEnumFsiItems * This,
    /* [range][in] */ __RPC__in_range(0,0x7fffffff) ULONG celt,
    /* [size_is][out] */ __RPC__out_ecount_full(celt) IFsiItem **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);


void __RPC_STUB IEnumFsiItems_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumFsiItems_INTERFACE_DEFINED__ */


#ifndef __IFsiFileItem_INTERFACE_DEFINED__
#define __IFsiFileItem_INTERFACE_DEFINED__

/* interface IFsiFileItem */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFsiFileItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FDB-975B-59BE-A960-9A2A262853A5")
    IFsiFileItem : public IFsiItem
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataSize( 
            /* [retval][out] */ __RPC__out LONGLONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataSize32BitLow( 
            /* [retval][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DataSize32BitHigh( 
            /* [retval][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Data( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Data( 
            /* [in] */ __RPC__in_opt IStream *newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFsiFileItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFsiFileItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFsiFileItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFsiFileItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFsiFileItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullPath )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CreationTime )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastAccessedTime )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastAccessedTime )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastModifiedTime )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastModifiedTime )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemName )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemPath )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSize )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__out LONGLONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSize32BitLow )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSize32BitHigh )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            __RPC__in IFsiFileItem * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Data )( 
            __RPC__in IFsiFileItem * This,
            /* [in] */ __RPC__in_opt IStream *newVal);
        
        END_INTERFACE
    } IFsiFileItemVtbl;

    interface IFsiFileItem
    {
        CONST_VTBL struct IFsiFileItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFsiFileItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFsiFileItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFsiFileItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFsiFileItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFsiFileItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFsiFileItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFsiFileItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFsiFileItem_get_Name(This,pVal)	\
    ( (This)->lpVtbl -> get_Name(This,pVal) ) 

#define IFsiFileItem_get_FullPath(This,pVal)	\
    ( (This)->lpVtbl -> get_FullPath(This,pVal) ) 

#define IFsiFileItem_get_CreationTime(This,pVal)	\
    ( (This)->lpVtbl -> get_CreationTime(This,pVal) ) 

#define IFsiFileItem_put_CreationTime(This,newVal)	\
    ( (This)->lpVtbl -> put_CreationTime(This,newVal) ) 

#define IFsiFileItem_get_LastAccessedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastAccessedTime(This,pVal) ) 

#define IFsiFileItem_put_LastAccessedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastAccessedTime(This,newVal) ) 

#define IFsiFileItem_get_LastModifiedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastModifiedTime(This,pVal) ) 

#define IFsiFileItem_put_LastModifiedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastModifiedTime(This,newVal) ) 

#define IFsiFileItem_get_IsHidden(This,pVal)	\
    ( (This)->lpVtbl -> get_IsHidden(This,pVal) ) 

#define IFsiFileItem_put_IsHidden(This,newVal)	\
    ( (This)->lpVtbl -> put_IsHidden(This,newVal) ) 

#define IFsiFileItem_FileSystemName(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemName(This,fileSystem,pVal) ) 

#define IFsiFileItem_FileSystemPath(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemPath(This,fileSystem,pVal) ) 


#define IFsiFileItem_get_DataSize(This,pVal)	\
    ( (This)->lpVtbl -> get_DataSize(This,pVal) ) 

#define IFsiFileItem_get_DataSize32BitLow(This,pVal)	\
    ( (This)->lpVtbl -> get_DataSize32BitLow(This,pVal) ) 

#define IFsiFileItem_get_DataSize32BitHigh(This,pVal)	\
    ( (This)->lpVtbl -> get_DataSize32BitHigh(This,pVal) ) 

#define IFsiFileItem_get_Data(This,pVal)	\
    ( (This)->lpVtbl -> get_Data(This,pVal) ) 

#define IFsiFileItem_put_Data(This,newVal)	\
    ( (This)->lpVtbl -> put_Data(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFsiFileItem_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2fs_0000_0009 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0009_v0_0_s_ifspec;

#ifndef __IFsiFileItem2_INTERFACE_DEFINED__
#define __IFsiFileItem2_INTERFACE_DEFINED__

/* interface IFsiFileItem2 */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFsiFileItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("199D0C19-11E1-40eb-8EC2-C8C822A07792")
    IFsiFileItem2 : public IFsiFileItem
    {
    public:
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_FsiNamedStreams( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiNamedStreams **streams) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsNamedStream( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddStream( 
            /* [in] */ __RPC__in BSTR name,
            /* [in] */ __RPC__in_opt IStream *streamData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveStream( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_IsRealTime( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_IsRealTime( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFsiFileItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFsiFileItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFsiFileItem2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFsiFileItem2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFsiFileItem2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullPath )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CreationTime )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastAccessedTime )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastAccessedTime )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastModifiedTime )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastModifiedTime )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemName )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemPath )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSize )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__out LONGLONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSize32BitLow )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DataSize32BitHigh )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Data )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Data )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ __RPC__in_opt IStream *newVal);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FsiNamedStreams )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiNamedStreams **streams);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsNamedStream )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddStream )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [in] */ __RPC__in_opt IStream *streamData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveStream )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsRealTime )( 
            __RPC__in IFsiFileItem2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsRealTime )( 
            __RPC__in IFsiFileItem2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        END_INTERFACE
    } IFsiFileItem2Vtbl;

    interface IFsiFileItem2
    {
        CONST_VTBL struct IFsiFileItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFsiFileItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFsiFileItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFsiFileItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFsiFileItem2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFsiFileItem2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFsiFileItem2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFsiFileItem2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFsiFileItem2_get_Name(This,pVal)	\
    ( (This)->lpVtbl -> get_Name(This,pVal) ) 

#define IFsiFileItem2_get_FullPath(This,pVal)	\
    ( (This)->lpVtbl -> get_FullPath(This,pVal) ) 

#define IFsiFileItem2_get_CreationTime(This,pVal)	\
    ( (This)->lpVtbl -> get_CreationTime(This,pVal) ) 

#define IFsiFileItem2_put_CreationTime(This,newVal)	\
    ( (This)->lpVtbl -> put_CreationTime(This,newVal) ) 

#define IFsiFileItem2_get_LastAccessedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastAccessedTime(This,pVal) ) 

#define IFsiFileItem2_put_LastAccessedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastAccessedTime(This,newVal) ) 

#define IFsiFileItem2_get_LastModifiedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastModifiedTime(This,pVal) ) 

#define IFsiFileItem2_put_LastModifiedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastModifiedTime(This,newVal) ) 

#define IFsiFileItem2_get_IsHidden(This,pVal)	\
    ( (This)->lpVtbl -> get_IsHidden(This,pVal) ) 

#define IFsiFileItem2_put_IsHidden(This,newVal)	\
    ( (This)->lpVtbl -> put_IsHidden(This,newVal) ) 

#define IFsiFileItem2_FileSystemName(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemName(This,fileSystem,pVal) ) 

#define IFsiFileItem2_FileSystemPath(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemPath(This,fileSystem,pVal) ) 


#define IFsiFileItem2_get_DataSize(This,pVal)	\
    ( (This)->lpVtbl -> get_DataSize(This,pVal) ) 

#define IFsiFileItem2_get_DataSize32BitLow(This,pVal)	\
    ( (This)->lpVtbl -> get_DataSize32BitLow(This,pVal) ) 

#define IFsiFileItem2_get_DataSize32BitHigh(This,pVal)	\
    ( (This)->lpVtbl -> get_DataSize32BitHigh(This,pVal) ) 

#define IFsiFileItem2_get_Data(This,pVal)	\
    ( (This)->lpVtbl -> get_Data(This,pVal) ) 

#define IFsiFileItem2_put_Data(This,newVal)	\
    ( (This)->lpVtbl -> put_Data(This,newVal) ) 


#define IFsiFileItem2_get_FsiNamedStreams(This,streams)	\
    ( (This)->lpVtbl -> get_FsiNamedStreams(This,streams) ) 

#define IFsiFileItem2_get_IsNamedStream(This,pVal)	\
    ( (This)->lpVtbl -> get_IsNamedStream(This,pVal) ) 

#define IFsiFileItem2_AddStream(This,name,streamData)	\
    ( (This)->lpVtbl -> AddStream(This,name,streamData) ) 

#define IFsiFileItem2_RemoveStream(This,name)	\
    ( (This)->lpVtbl -> RemoveStream(This,name) ) 

#define IFsiFileItem2_get_IsRealTime(This,pVal)	\
    ( (This)->lpVtbl -> get_IsRealTime(This,pVal) ) 

#define IFsiFileItem2_put_IsRealTime(This,newVal)	\
    ( (This)->lpVtbl -> put_IsRealTime(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFsiFileItem2_INTERFACE_DEFINED__ */


#ifndef __IFsiNamedStreams_INTERFACE_DEFINED__
#define __IFsiNamedStreams_INTERFACE_DEFINED__

/* interface IFsiNamedStreams */
/* [helpstring][uuid][nonextensible][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFsiNamedStreams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED79BA56-5294-4250-8D46-F9AECEE23459")
    IFsiNamedStreams : public IDispatch
    {
    public:
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IEnumVARIANT **NewEnum) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ LONG index,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiFileItem2 **item) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][ref][out] */ __RPC__out LONG *count) = 0;
        
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumNamedStreams( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IEnumFsiItems **NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFsiNamedStreamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFsiNamedStreams * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFsiNamedStreams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFsiNamedStreams * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFsiNamedStreams * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFsiNamedStreams * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFsiNamedStreams * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFsiNamedStreams * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IFsiNamedStreams * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IEnumVARIANT **NewEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IFsiNamedStreams * This,
            /* [in] */ LONG index,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiFileItem2 **item);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IFsiNamedStreams * This,
            /* [retval][ref][out] */ __RPC__out LONG *count);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumNamedStreams )( 
            __RPC__in IFsiNamedStreams * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IEnumFsiItems **NewEnum);
        
        END_INTERFACE
    } IFsiNamedStreamsVtbl;

    interface IFsiNamedStreams
    {
        CONST_VTBL struct IFsiNamedStreamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFsiNamedStreams_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFsiNamedStreams_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFsiNamedStreams_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFsiNamedStreams_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFsiNamedStreams_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFsiNamedStreams_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFsiNamedStreams_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFsiNamedStreams_get__NewEnum(This,NewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,NewEnum) ) 

#define IFsiNamedStreams_get_Item(This,index,item)	\
    ( (This)->lpVtbl -> get_Item(This,index,item) ) 

#define IFsiNamedStreams_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define IFsiNamedStreams_get_EnumNamedStreams(This,NewEnum)	\
    ( (This)->lpVtbl -> get_EnumNamedStreams(This,NewEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFsiNamedStreams_INTERFACE_DEFINED__ */


#ifndef __IFsiDirectoryItem_INTERFACE_DEFINED__
#define __IFsiDirectoryItem_INTERFACE_DEFINED__

/* interface IFsiDirectoryItem */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFsiDirectoryItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FDC-975B-59BE-A960-9A2A262853A5")
    IFsiDirectoryItem : public IFsiItem
    {
    public:
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **NewEnum) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ __RPC__in BSTR path,
            /* [retval][out] */ __RPC__deref_out_opt IFsiItem **item) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out LONG *Count) = 0;
        
        virtual /* [helpstring][restricted][hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get_EnumFsiItems( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumFsiItems **NewEnum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddDirectory( 
            /* [in] */ __RPC__in BSTR path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddFile( 
            /* [in] */ __RPC__in BSTR path,
            /* [in] */ __RPC__in_opt IStream *fileData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddTree( 
            /* [in] */ __RPC__in BSTR sourceDirectory,
            /* [in] */ VARIANT_BOOL includeBaseDirectory) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt IFsiItem *item) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ __RPC__in BSTR path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RemoveTree( 
            /* [in] */ __RPC__in BSTR path) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFsiDirectoryItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFsiDirectoryItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFsiDirectoryItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFsiDirectoryItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullPath )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CreationTime )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastAccessedTime )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastAccessedTime )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastModifiedTime )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastModifiedTime )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemName )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemPath )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **NewEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in BSTR path,
            /* [retval][out] */ __RPC__deref_out_opt IFsiItem **item);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__out LONG *Count);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumFsiItems )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumFsiItems **NewEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddDirectory )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddFile )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in BSTR path,
            /* [in] */ __RPC__in_opt IStream *fileData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddTree )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in BSTR sourceDirectory,
            /* [in] */ VARIANT_BOOL includeBaseDirectory);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in_opt IFsiItem *item);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveTree )( 
            __RPC__in IFsiDirectoryItem * This,
            /* [in] */ __RPC__in BSTR path);
        
        END_INTERFACE
    } IFsiDirectoryItemVtbl;

    interface IFsiDirectoryItem
    {
        CONST_VTBL struct IFsiDirectoryItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFsiDirectoryItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFsiDirectoryItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFsiDirectoryItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFsiDirectoryItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFsiDirectoryItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFsiDirectoryItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFsiDirectoryItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFsiDirectoryItem_get_Name(This,pVal)	\
    ( (This)->lpVtbl -> get_Name(This,pVal) ) 

#define IFsiDirectoryItem_get_FullPath(This,pVal)	\
    ( (This)->lpVtbl -> get_FullPath(This,pVal) ) 

#define IFsiDirectoryItem_get_CreationTime(This,pVal)	\
    ( (This)->lpVtbl -> get_CreationTime(This,pVal) ) 

#define IFsiDirectoryItem_put_CreationTime(This,newVal)	\
    ( (This)->lpVtbl -> put_CreationTime(This,newVal) ) 

#define IFsiDirectoryItem_get_LastAccessedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastAccessedTime(This,pVal) ) 

#define IFsiDirectoryItem_put_LastAccessedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastAccessedTime(This,newVal) ) 

#define IFsiDirectoryItem_get_LastModifiedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastModifiedTime(This,pVal) ) 

#define IFsiDirectoryItem_put_LastModifiedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastModifiedTime(This,newVal) ) 

#define IFsiDirectoryItem_get_IsHidden(This,pVal)	\
    ( (This)->lpVtbl -> get_IsHidden(This,pVal) ) 

#define IFsiDirectoryItem_put_IsHidden(This,newVal)	\
    ( (This)->lpVtbl -> put_IsHidden(This,newVal) ) 

#define IFsiDirectoryItem_FileSystemName(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemName(This,fileSystem,pVal) ) 

#define IFsiDirectoryItem_FileSystemPath(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemPath(This,fileSystem,pVal) ) 


#define IFsiDirectoryItem_get__NewEnum(This,NewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,NewEnum) ) 

#define IFsiDirectoryItem_get_Item(This,path,item)	\
    ( (This)->lpVtbl -> get_Item(This,path,item) ) 

#define IFsiDirectoryItem_get_Count(This,Count)	\
    ( (This)->lpVtbl -> get_Count(This,Count) ) 

#define IFsiDirectoryItem_get_EnumFsiItems(This,NewEnum)	\
    ( (This)->lpVtbl -> get_EnumFsiItems(This,NewEnum) ) 

#define IFsiDirectoryItem_AddDirectory(This,path)	\
    ( (This)->lpVtbl -> AddDirectory(This,path) ) 

#define IFsiDirectoryItem_AddFile(This,path,fileData)	\
    ( (This)->lpVtbl -> AddFile(This,path,fileData) ) 

#define IFsiDirectoryItem_AddTree(This,sourceDirectory,includeBaseDirectory)	\
    ( (This)->lpVtbl -> AddTree(This,sourceDirectory,includeBaseDirectory) ) 

#define IFsiDirectoryItem_Add(This,item)	\
    ( (This)->lpVtbl -> Add(This,item) ) 

#define IFsiDirectoryItem_Remove(This,path)	\
    ( (This)->lpVtbl -> Remove(This,path) ) 

#define IFsiDirectoryItem_RemoveTree(This,path)	\
    ( (This)->lpVtbl -> RemoveTree(This,path) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFsiDirectoryItem_INTERFACE_DEFINED__ */


#ifndef __IFsiDirectoryItem2_INTERFACE_DEFINED__
#define __IFsiDirectoryItem2_INTERFACE_DEFINED__

/* interface IFsiDirectoryItem2 */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFsiDirectoryItem2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7FB4B9B-6D96-4d7b-9115-201B144811EF")
    IFsiDirectoryItem2 : public IFsiDirectoryItem
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AddTreeWithNamedStreams( 
            /* [in] */ __RPC__in BSTR sourceDirectory,
            /* [in] */ VARIANT_BOOL includeBaseDirectory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFsiDirectoryItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFsiDirectoryItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFsiDirectoryItem2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFsiDirectoryItem2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FullPath )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreationTime )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CreationTime )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastAccessedTime )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastAccessedTime )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LastModifiedTime )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LastModifiedTime )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ DATE newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_IsHidden )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_IsHidden )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemName )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *FileSystemPath )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ FsiFileSystems fileSystem,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumVARIANT **NewEnum);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in BSTR path,
            /* [retval][out] */ __RPC__deref_out_opt IFsiItem **item);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__out LONG *Count);
        
        /* [helpstring][restricted][hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EnumFsiItems )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumFsiItems **NewEnum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddDirectory )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddFile )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in BSTR path,
            /* [in] */ __RPC__in_opt IStream *fileData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddTree )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in BSTR sourceDirectory,
            /* [in] */ VARIANT_BOOL includeBaseDirectory);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in_opt IFsiItem *item);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RemoveTree )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in BSTR path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *AddTreeWithNamedStreams )( 
            __RPC__in IFsiDirectoryItem2 * This,
            /* [in] */ __RPC__in BSTR sourceDirectory,
            /* [in] */ VARIANT_BOOL includeBaseDirectory);
        
        END_INTERFACE
    } IFsiDirectoryItem2Vtbl;

    interface IFsiDirectoryItem2
    {
        CONST_VTBL struct IFsiDirectoryItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFsiDirectoryItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFsiDirectoryItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFsiDirectoryItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFsiDirectoryItem2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFsiDirectoryItem2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFsiDirectoryItem2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFsiDirectoryItem2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFsiDirectoryItem2_get_Name(This,pVal)	\
    ( (This)->lpVtbl -> get_Name(This,pVal) ) 

#define IFsiDirectoryItem2_get_FullPath(This,pVal)	\
    ( (This)->lpVtbl -> get_FullPath(This,pVal) ) 

#define IFsiDirectoryItem2_get_CreationTime(This,pVal)	\
    ( (This)->lpVtbl -> get_CreationTime(This,pVal) ) 

#define IFsiDirectoryItem2_put_CreationTime(This,newVal)	\
    ( (This)->lpVtbl -> put_CreationTime(This,newVal) ) 

#define IFsiDirectoryItem2_get_LastAccessedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastAccessedTime(This,pVal) ) 

#define IFsiDirectoryItem2_put_LastAccessedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastAccessedTime(This,newVal) ) 

#define IFsiDirectoryItem2_get_LastModifiedTime(This,pVal)	\
    ( (This)->lpVtbl -> get_LastModifiedTime(This,pVal) ) 

#define IFsiDirectoryItem2_put_LastModifiedTime(This,newVal)	\
    ( (This)->lpVtbl -> put_LastModifiedTime(This,newVal) ) 

#define IFsiDirectoryItem2_get_IsHidden(This,pVal)	\
    ( (This)->lpVtbl -> get_IsHidden(This,pVal) ) 

#define IFsiDirectoryItem2_put_IsHidden(This,newVal)	\
    ( (This)->lpVtbl -> put_IsHidden(This,newVal) ) 

#define IFsiDirectoryItem2_FileSystemName(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemName(This,fileSystem,pVal) ) 

#define IFsiDirectoryItem2_FileSystemPath(This,fileSystem,pVal)	\
    ( (This)->lpVtbl -> FileSystemPath(This,fileSystem,pVal) ) 


#define IFsiDirectoryItem2_get__NewEnum(This,NewEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,NewEnum) ) 

#define IFsiDirectoryItem2_get_Item(This,path,item)	\
    ( (This)->lpVtbl -> get_Item(This,path,item) ) 

#define IFsiDirectoryItem2_get_Count(This,Count)	\
    ( (This)->lpVtbl -> get_Count(This,Count) ) 

#define IFsiDirectoryItem2_get_EnumFsiItems(This,NewEnum)	\
    ( (This)->lpVtbl -> get_EnumFsiItems(This,NewEnum) ) 

#define IFsiDirectoryItem2_AddDirectory(This,path)	\
    ( (This)->lpVtbl -> AddDirectory(This,path) ) 

#define IFsiDirectoryItem2_AddFile(This,path,fileData)	\
    ( (This)->lpVtbl -> AddFile(This,path,fileData) ) 

#define IFsiDirectoryItem2_AddTree(This,sourceDirectory,includeBaseDirectory)	\
    ( (This)->lpVtbl -> AddTree(This,sourceDirectory,includeBaseDirectory) ) 

#define IFsiDirectoryItem2_Add(This,item)	\
    ( (This)->lpVtbl -> Add(This,item) ) 

#define IFsiDirectoryItem2_Remove(This,path)	\
    ( (This)->lpVtbl -> Remove(This,path) ) 

#define IFsiDirectoryItem2_RemoveTree(This,path)	\
    ( (This)->lpVtbl -> RemoveTree(This,path) ) 


#define IFsiDirectoryItem2_AddTreeWithNamedStreams(This,sourceDirectory,includeBaseDirectory)	\
    ( (This)->lpVtbl -> AddTreeWithNamedStreams(This,sourceDirectory,includeBaseDirectory) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFsiDirectoryItem2_INTERFACE_DEFINED__ */


#ifndef __IFileSystemImage_INTERFACE_DEFINED__
#define __IFileSystemImage_INTERFACE_DEFINED__

/* interface IFileSystemImage */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFileSystemImage;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FE1-975B-59BE-A960-9A2A262853A5")
    IFileSystemImage : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Root( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiDirectoryItem **pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SessionStartBlock( 
            /* [retval][ref][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SessionStartBlock( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FreeMediaBlocks( 
            /* [retval][ref][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FreeMediaBlocks( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetMaxMediaBlocksFromDevice( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UsedBlocks( 
            /* [retval][ref][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VolumeName( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_VolumeName( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ImportedVolumeName( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BootImageOptions( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IBootOptions **pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BootImageOptions( 
            /* [in] */ __RPC__in_opt IBootOptions *newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileCount( 
            /* [retval][ref][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DirectoryCount( 
            /* [retval][ref][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_WorkingDirectory( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_WorkingDirectory( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ChangePoint( 
            /* [retval][ref][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StrictFileSystemCompliance( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StrictFileSystemCompliance( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UseRestrictedCharacterSet( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UseRestrictedCharacterSet( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileSystemsToCreate( 
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_FileSystemsToCreate( 
            /* [in] */ FsiFileSystems newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_FileSystemsSupported( 
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_UDFRevision( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UDFRevision( 
            /* [retval][ref][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_UDFRevisionsSupported( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChooseImageDefaults( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ChooseImageDefaultsForMediaType( 
            /* [in] */ IMAPI_MEDIA_PHYSICAL_TYPE value) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ISO9660InterchangeLevel( 
            /* [in] */ LONG newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISO9660InterchangeLevel( 
            /* [retval][ref][out] */ __RPC__out LONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ISO9660InterchangeLevelsSupported( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateResultImage( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IFileSystemImageResult **resultStream) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Exists( 
            /* [in] */ __RPC__in BSTR fullPath,
            /* [retval][ref][out] */ __RPC__out FsiItemType *itemType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CalculateDiscIdentifier( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *discIdentifier) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IdentifyFileSystemsOnDisc( 
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *fileSystems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDefaultFileSystemForImport( 
            /* [in] */ FsiFileSystems fileSystems,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *importDefault) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportFileSystem( 
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *importedFileSystem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ImportSpecificFileSystem( 
            /* [in] */ FsiFileSystems fileSystemToUse) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RollbackToChangePoint( 
            /* [in] */ LONG changePoint) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LockInChangePoint( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateDirectoryItem( 
            /* [in] */ __RPC__in BSTR name,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiDirectoryItem **newItem) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateFileItem( 
            /* [in] */ __RPC__in BSTR name,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiFileItem **newItem) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VolumeNameUDF( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VolumeNameJoliet( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_VolumeNameISO9660( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StageFiles( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_StageFiles( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MultisessionInterfaces( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_MultisessionInterfaces( 
            /* [in] */ __RPC__in SAFEARRAY * newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemImageVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileSystemImage * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileSystemImage * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFileSystemImage * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFileSystemImage * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Root )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiDirectoryItem **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionStartBlock )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SessionStartBlock )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeMediaBlocks )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FreeMediaBlocks )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMaxMediaBlocksFromDevice )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedBlocks )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeName )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_VolumeName )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImportedVolumeName )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BootImageOptions )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IBootOptions **pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BootImageOptions )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in_opt IBootOptions *newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileCount )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryCount )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WorkingDirectory )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WorkingDirectory )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChangePoint )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StrictFileSystemCompliance )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StrictFileSystemCompliance )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseRestrictedCharacterSet )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseRestrictedCharacterSet )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileSystemsToCreate )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileSystemsToCreate )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ FsiFileSystems newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileSystemsSupported )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UDFRevision )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDFRevision )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDFRevisionsSupported )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChooseImageDefaults )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChooseImageDefaultsForMediaType )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ IMAPI_MEDIA_PHYSICAL_TYPE value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ISO9660InterchangeLevel )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ISO9660InterchangeLevel )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ISO9660InterchangeLevelsSupported )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateResultImage )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFileSystemImageResult **resultStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Exists )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in BSTR fullPath,
            /* [retval][ref][out] */ __RPC__out FsiItemType *itemType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CalculateDiscIdentifier )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *discIdentifier);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IdentifyFileSystemsOnDisc )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *fileSystems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultFileSystemForImport )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ FsiFileSystems fileSystems,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *importDefault);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportFileSystem )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *importedFileSystem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportSpecificFileSystem )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ FsiFileSystems fileSystemToUse);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RollbackToChangePoint )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ LONG changePoint);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LockInChangePoint )( 
            __RPC__in IFileSystemImage * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectoryItem )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiDirectoryItem **newItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateFileItem )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiFileItem **newItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameUDF )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameJoliet )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameISO9660 )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StageFiles )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StageFiles )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MultisessionInterfaces )( 
            __RPC__in IFileSystemImage * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MultisessionInterfaces )( 
            __RPC__in IFileSystemImage * This,
            /* [in] */ __RPC__in SAFEARRAY * newVal);
        
        END_INTERFACE
    } IFileSystemImageVtbl;

    interface IFileSystemImage
    {
        CONST_VTBL struct IFileSystemImageVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemImage_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemImage_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemImage_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemImage_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFileSystemImage_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFileSystemImage_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFileSystemImage_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFileSystemImage_get_Root(This,pVal)	\
    ( (This)->lpVtbl -> get_Root(This,pVal) ) 

#define IFileSystemImage_get_SessionStartBlock(This,pVal)	\
    ( (This)->lpVtbl -> get_SessionStartBlock(This,pVal) ) 

#define IFileSystemImage_put_SessionStartBlock(This,newVal)	\
    ( (This)->lpVtbl -> put_SessionStartBlock(This,newVal) ) 

#define IFileSystemImage_get_FreeMediaBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_FreeMediaBlocks(This,pVal) ) 

#define IFileSystemImage_put_FreeMediaBlocks(This,newVal)	\
    ( (This)->lpVtbl -> put_FreeMediaBlocks(This,newVal) ) 

#define IFileSystemImage_SetMaxMediaBlocksFromDevice(This,discRecorder)	\
    ( (This)->lpVtbl -> SetMaxMediaBlocksFromDevice(This,discRecorder) ) 

#define IFileSystemImage_get_UsedBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_UsedBlocks(This,pVal) ) 

#define IFileSystemImage_get_VolumeName(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeName(This,pVal) ) 

#define IFileSystemImage_put_VolumeName(This,newVal)	\
    ( (This)->lpVtbl -> put_VolumeName(This,newVal) ) 

#define IFileSystemImage_get_ImportedVolumeName(This,pVal)	\
    ( (This)->lpVtbl -> get_ImportedVolumeName(This,pVal) ) 

#define IFileSystemImage_get_BootImageOptions(This,pVal)	\
    ( (This)->lpVtbl -> get_BootImageOptions(This,pVal) ) 

#define IFileSystemImage_put_BootImageOptions(This,newVal)	\
    ( (This)->lpVtbl -> put_BootImageOptions(This,newVal) ) 

#define IFileSystemImage_get_FileCount(This,pVal)	\
    ( (This)->lpVtbl -> get_FileCount(This,pVal) ) 

#define IFileSystemImage_get_DirectoryCount(This,pVal)	\
    ( (This)->lpVtbl -> get_DirectoryCount(This,pVal) ) 

#define IFileSystemImage_get_WorkingDirectory(This,pVal)	\
    ( (This)->lpVtbl -> get_WorkingDirectory(This,pVal) ) 

#define IFileSystemImage_put_WorkingDirectory(This,newVal)	\
    ( (This)->lpVtbl -> put_WorkingDirectory(This,newVal) ) 

#define IFileSystemImage_get_ChangePoint(This,pVal)	\
    ( (This)->lpVtbl -> get_ChangePoint(This,pVal) ) 

#define IFileSystemImage_get_StrictFileSystemCompliance(This,pVal)	\
    ( (This)->lpVtbl -> get_StrictFileSystemCompliance(This,pVal) ) 

#define IFileSystemImage_put_StrictFileSystemCompliance(This,newVal)	\
    ( (This)->lpVtbl -> put_StrictFileSystemCompliance(This,newVal) ) 

#define IFileSystemImage_get_UseRestrictedCharacterSet(This,pVal)	\
    ( (This)->lpVtbl -> get_UseRestrictedCharacterSet(This,pVal) ) 

#define IFileSystemImage_put_UseRestrictedCharacterSet(This,newVal)	\
    ( (This)->lpVtbl -> put_UseRestrictedCharacterSet(This,newVal) ) 

#define IFileSystemImage_get_FileSystemsToCreate(This,pVal)	\
    ( (This)->lpVtbl -> get_FileSystemsToCreate(This,pVal) ) 

#define IFileSystemImage_put_FileSystemsToCreate(This,newVal)	\
    ( (This)->lpVtbl -> put_FileSystemsToCreate(This,newVal) ) 

#define IFileSystemImage_get_FileSystemsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_FileSystemsSupported(This,pVal) ) 

#define IFileSystemImage_put_UDFRevision(This,newVal)	\
    ( (This)->lpVtbl -> put_UDFRevision(This,newVal) ) 

#define IFileSystemImage_get_UDFRevision(This,pVal)	\
    ( (This)->lpVtbl -> get_UDFRevision(This,pVal) ) 

#define IFileSystemImage_get_UDFRevisionsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_UDFRevisionsSupported(This,pVal) ) 

#define IFileSystemImage_ChooseImageDefaults(This,discRecorder)	\
    ( (This)->lpVtbl -> ChooseImageDefaults(This,discRecorder) ) 

#define IFileSystemImage_ChooseImageDefaultsForMediaType(This,value)	\
    ( (This)->lpVtbl -> ChooseImageDefaultsForMediaType(This,value) ) 

#define IFileSystemImage_put_ISO9660InterchangeLevel(This,newVal)	\
    ( (This)->lpVtbl -> put_ISO9660InterchangeLevel(This,newVal) ) 

#define IFileSystemImage_get_ISO9660InterchangeLevel(This,pVal)	\
    ( (This)->lpVtbl -> get_ISO9660InterchangeLevel(This,pVal) ) 

#define IFileSystemImage_get_ISO9660InterchangeLevelsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_ISO9660InterchangeLevelsSupported(This,pVal) ) 

#define IFileSystemImage_CreateResultImage(This,resultStream)	\
    ( (This)->lpVtbl -> CreateResultImage(This,resultStream) ) 

#define IFileSystemImage_Exists(This,fullPath,itemType)	\
    ( (This)->lpVtbl -> Exists(This,fullPath,itemType) ) 

#define IFileSystemImage_CalculateDiscIdentifier(This,discIdentifier)	\
    ( (This)->lpVtbl -> CalculateDiscIdentifier(This,discIdentifier) ) 

#define IFileSystemImage_IdentifyFileSystemsOnDisc(This,discRecorder,fileSystems)	\
    ( (This)->lpVtbl -> IdentifyFileSystemsOnDisc(This,discRecorder,fileSystems) ) 

#define IFileSystemImage_GetDefaultFileSystemForImport(This,fileSystems,importDefault)	\
    ( (This)->lpVtbl -> GetDefaultFileSystemForImport(This,fileSystems,importDefault) ) 

#define IFileSystemImage_ImportFileSystem(This,importedFileSystem)	\
    ( (This)->lpVtbl -> ImportFileSystem(This,importedFileSystem) ) 

#define IFileSystemImage_ImportSpecificFileSystem(This,fileSystemToUse)	\
    ( (This)->lpVtbl -> ImportSpecificFileSystem(This,fileSystemToUse) ) 

#define IFileSystemImage_RollbackToChangePoint(This,changePoint)	\
    ( (This)->lpVtbl -> RollbackToChangePoint(This,changePoint) ) 

#define IFileSystemImage_LockInChangePoint(This)	\
    ( (This)->lpVtbl -> LockInChangePoint(This) ) 

#define IFileSystemImage_CreateDirectoryItem(This,name,newItem)	\
    ( (This)->lpVtbl -> CreateDirectoryItem(This,name,newItem) ) 

#define IFileSystemImage_CreateFileItem(This,name,newItem)	\
    ( (This)->lpVtbl -> CreateFileItem(This,name,newItem) ) 

#define IFileSystemImage_get_VolumeNameUDF(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameUDF(This,pVal) ) 

#define IFileSystemImage_get_VolumeNameJoliet(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameJoliet(This,pVal) ) 

#define IFileSystemImage_get_VolumeNameISO9660(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameISO9660(This,pVal) ) 

#define IFileSystemImage_get_StageFiles(This,pVal)	\
    ( (This)->lpVtbl -> get_StageFiles(This,pVal) ) 

#define IFileSystemImage_put_StageFiles(This,newVal)	\
    ( (This)->lpVtbl -> put_StageFiles(This,newVal) ) 

#define IFileSystemImage_get_MultisessionInterfaces(This,pVal)	\
    ( (This)->lpVtbl -> get_MultisessionInterfaces(This,pVal) ) 

#define IFileSystemImage_put_MultisessionInterfaces(This,newVal)	\
    ( (This)->lpVtbl -> put_MultisessionInterfaces(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemImage_INTERFACE_DEFINED__ */


#ifndef __IFileSystemImage2_INTERFACE_DEFINED__
#define __IFileSystemImage2_INTERFACE_DEFINED__

/* interface IFileSystemImage2 */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFileSystemImage2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7644B2C-1537-4767-B62F-F1387B02DDFD")
    IFileSystemImage2 : public IFileSystemImage
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_BootImageOptionsArray( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_BootImageOptionsArray( 
            /* [in] */ __RPC__in SAFEARRAY * newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemImage2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileSystemImage2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileSystemImage2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFileSystemImage2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFileSystemImage2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Root )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiDirectoryItem **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionStartBlock )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SessionStartBlock )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeMediaBlocks )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FreeMediaBlocks )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMaxMediaBlocksFromDevice )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedBlocks )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeName )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_VolumeName )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImportedVolumeName )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BootImageOptions )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IBootOptions **pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BootImageOptions )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in_opt IBootOptions *newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileCount )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryCount )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WorkingDirectory )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WorkingDirectory )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChangePoint )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StrictFileSystemCompliance )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StrictFileSystemCompliance )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseRestrictedCharacterSet )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseRestrictedCharacterSet )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileSystemsToCreate )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileSystemsToCreate )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ FsiFileSystems newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileSystemsSupported )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UDFRevision )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDFRevision )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDFRevisionsSupported )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChooseImageDefaults )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChooseImageDefaultsForMediaType )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ IMAPI_MEDIA_PHYSICAL_TYPE value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ISO9660InterchangeLevel )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ISO9660InterchangeLevel )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ISO9660InterchangeLevelsSupported )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateResultImage )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFileSystemImageResult **resultStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Exists )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in BSTR fullPath,
            /* [retval][ref][out] */ __RPC__out FsiItemType *itemType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CalculateDiscIdentifier )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *discIdentifier);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IdentifyFileSystemsOnDisc )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *fileSystems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultFileSystemForImport )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ FsiFileSystems fileSystems,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *importDefault);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportFileSystem )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *importedFileSystem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportSpecificFileSystem )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ FsiFileSystems fileSystemToUse);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RollbackToChangePoint )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ LONG changePoint);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LockInChangePoint )( 
            __RPC__in IFileSystemImage2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectoryItem )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiDirectoryItem **newItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateFileItem )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiFileItem **newItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameUDF )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameJoliet )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameISO9660 )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StageFiles )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StageFiles )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MultisessionInterfaces )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MultisessionInterfaces )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in SAFEARRAY * newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BootImageOptionsArray )( 
            __RPC__in IFileSystemImage2 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BootImageOptionsArray )( 
            __RPC__in IFileSystemImage2 * This,
            /* [in] */ __RPC__in SAFEARRAY * newVal);
        
        END_INTERFACE
    } IFileSystemImage2Vtbl;

    interface IFileSystemImage2
    {
        CONST_VTBL struct IFileSystemImage2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemImage2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemImage2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemImage2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemImage2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFileSystemImage2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFileSystemImage2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFileSystemImage2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFileSystemImage2_get_Root(This,pVal)	\
    ( (This)->lpVtbl -> get_Root(This,pVal) ) 

#define IFileSystemImage2_get_SessionStartBlock(This,pVal)	\
    ( (This)->lpVtbl -> get_SessionStartBlock(This,pVal) ) 

#define IFileSystemImage2_put_SessionStartBlock(This,newVal)	\
    ( (This)->lpVtbl -> put_SessionStartBlock(This,newVal) ) 

#define IFileSystemImage2_get_FreeMediaBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_FreeMediaBlocks(This,pVal) ) 

#define IFileSystemImage2_put_FreeMediaBlocks(This,newVal)	\
    ( (This)->lpVtbl -> put_FreeMediaBlocks(This,newVal) ) 

#define IFileSystemImage2_SetMaxMediaBlocksFromDevice(This,discRecorder)	\
    ( (This)->lpVtbl -> SetMaxMediaBlocksFromDevice(This,discRecorder) ) 

#define IFileSystemImage2_get_UsedBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_UsedBlocks(This,pVal) ) 

#define IFileSystemImage2_get_VolumeName(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeName(This,pVal) ) 

#define IFileSystemImage2_put_VolumeName(This,newVal)	\
    ( (This)->lpVtbl -> put_VolumeName(This,newVal) ) 

#define IFileSystemImage2_get_ImportedVolumeName(This,pVal)	\
    ( (This)->lpVtbl -> get_ImportedVolumeName(This,pVal) ) 

#define IFileSystemImage2_get_BootImageOptions(This,pVal)	\
    ( (This)->lpVtbl -> get_BootImageOptions(This,pVal) ) 

#define IFileSystemImage2_put_BootImageOptions(This,newVal)	\
    ( (This)->lpVtbl -> put_BootImageOptions(This,newVal) ) 

#define IFileSystemImage2_get_FileCount(This,pVal)	\
    ( (This)->lpVtbl -> get_FileCount(This,pVal) ) 

#define IFileSystemImage2_get_DirectoryCount(This,pVal)	\
    ( (This)->lpVtbl -> get_DirectoryCount(This,pVal) ) 

#define IFileSystemImage2_get_WorkingDirectory(This,pVal)	\
    ( (This)->lpVtbl -> get_WorkingDirectory(This,pVal) ) 

#define IFileSystemImage2_put_WorkingDirectory(This,newVal)	\
    ( (This)->lpVtbl -> put_WorkingDirectory(This,newVal) ) 

#define IFileSystemImage2_get_ChangePoint(This,pVal)	\
    ( (This)->lpVtbl -> get_ChangePoint(This,pVal) ) 

#define IFileSystemImage2_get_StrictFileSystemCompliance(This,pVal)	\
    ( (This)->lpVtbl -> get_StrictFileSystemCompliance(This,pVal) ) 

#define IFileSystemImage2_put_StrictFileSystemCompliance(This,newVal)	\
    ( (This)->lpVtbl -> put_StrictFileSystemCompliance(This,newVal) ) 

#define IFileSystemImage2_get_UseRestrictedCharacterSet(This,pVal)	\
    ( (This)->lpVtbl -> get_UseRestrictedCharacterSet(This,pVal) ) 

#define IFileSystemImage2_put_UseRestrictedCharacterSet(This,newVal)	\
    ( (This)->lpVtbl -> put_UseRestrictedCharacterSet(This,newVal) ) 

#define IFileSystemImage2_get_FileSystemsToCreate(This,pVal)	\
    ( (This)->lpVtbl -> get_FileSystemsToCreate(This,pVal) ) 

#define IFileSystemImage2_put_FileSystemsToCreate(This,newVal)	\
    ( (This)->lpVtbl -> put_FileSystemsToCreate(This,newVal) ) 

#define IFileSystemImage2_get_FileSystemsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_FileSystemsSupported(This,pVal) ) 

#define IFileSystemImage2_put_UDFRevision(This,newVal)	\
    ( (This)->lpVtbl -> put_UDFRevision(This,newVal) ) 

#define IFileSystemImage2_get_UDFRevision(This,pVal)	\
    ( (This)->lpVtbl -> get_UDFRevision(This,pVal) ) 

#define IFileSystemImage2_get_UDFRevisionsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_UDFRevisionsSupported(This,pVal) ) 

#define IFileSystemImage2_ChooseImageDefaults(This,discRecorder)	\
    ( (This)->lpVtbl -> ChooseImageDefaults(This,discRecorder) ) 

#define IFileSystemImage2_ChooseImageDefaultsForMediaType(This,value)	\
    ( (This)->lpVtbl -> ChooseImageDefaultsForMediaType(This,value) ) 

#define IFileSystemImage2_put_ISO9660InterchangeLevel(This,newVal)	\
    ( (This)->lpVtbl -> put_ISO9660InterchangeLevel(This,newVal) ) 

#define IFileSystemImage2_get_ISO9660InterchangeLevel(This,pVal)	\
    ( (This)->lpVtbl -> get_ISO9660InterchangeLevel(This,pVal) ) 

#define IFileSystemImage2_get_ISO9660InterchangeLevelsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_ISO9660InterchangeLevelsSupported(This,pVal) ) 

#define IFileSystemImage2_CreateResultImage(This,resultStream)	\
    ( (This)->lpVtbl -> CreateResultImage(This,resultStream) ) 

#define IFileSystemImage2_Exists(This,fullPath,itemType)	\
    ( (This)->lpVtbl -> Exists(This,fullPath,itemType) ) 

#define IFileSystemImage2_CalculateDiscIdentifier(This,discIdentifier)	\
    ( (This)->lpVtbl -> CalculateDiscIdentifier(This,discIdentifier) ) 

#define IFileSystemImage2_IdentifyFileSystemsOnDisc(This,discRecorder,fileSystems)	\
    ( (This)->lpVtbl -> IdentifyFileSystemsOnDisc(This,discRecorder,fileSystems) ) 

#define IFileSystemImage2_GetDefaultFileSystemForImport(This,fileSystems,importDefault)	\
    ( (This)->lpVtbl -> GetDefaultFileSystemForImport(This,fileSystems,importDefault) ) 

#define IFileSystemImage2_ImportFileSystem(This,importedFileSystem)	\
    ( (This)->lpVtbl -> ImportFileSystem(This,importedFileSystem) ) 

#define IFileSystemImage2_ImportSpecificFileSystem(This,fileSystemToUse)	\
    ( (This)->lpVtbl -> ImportSpecificFileSystem(This,fileSystemToUse) ) 

#define IFileSystemImage2_RollbackToChangePoint(This,changePoint)	\
    ( (This)->lpVtbl -> RollbackToChangePoint(This,changePoint) ) 

#define IFileSystemImage2_LockInChangePoint(This)	\
    ( (This)->lpVtbl -> LockInChangePoint(This) ) 

#define IFileSystemImage2_CreateDirectoryItem(This,name,newItem)	\
    ( (This)->lpVtbl -> CreateDirectoryItem(This,name,newItem) ) 

#define IFileSystemImage2_CreateFileItem(This,name,newItem)	\
    ( (This)->lpVtbl -> CreateFileItem(This,name,newItem) ) 

#define IFileSystemImage2_get_VolumeNameUDF(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameUDF(This,pVal) ) 

#define IFileSystemImage2_get_VolumeNameJoliet(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameJoliet(This,pVal) ) 

#define IFileSystemImage2_get_VolumeNameISO9660(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameISO9660(This,pVal) ) 

#define IFileSystemImage2_get_StageFiles(This,pVal)	\
    ( (This)->lpVtbl -> get_StageFiles(This,pVal) ) 

#define IFileSystemImage2_put_StageFiles(This,newVal)	\
    ( (This)->lpVtbl -> put_StageFiles(This,newVal) ) 

#define IFileSystemImage2_get_MultisessionInterfaces(This,pVal)	\
    ( (This)->lpVtbl -> get_MultisessionInterfaces(This,pVal) ) 

#define IFileSystemImage2_put_MultisessionInterfaces(This,newVal)	\
    ( (This)->lpVtbl -> put_MultisessionInterfaces(This,newVal) ) 


#define IFileSystemImage2_get_BootImageOptionsArray(This,pVal)	\
    ( (This)->lpVtbl -> get_BootImageOptionsArray(This,pVal) ) 

#define IFileSystemImage2_put_BootImageOptionsArray(This,newVal)	\
    ( (This)->lpVtbl -> put_BootImageOptionsArray(This,newVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemImage2_INTERFACE_DEFINED__ */


#ifndef __IFileSystemImage3_INTERFACE_DEFINED__
#define __IFileSystemImage3_INTERFACE_DEFINED__

/* interface IFileSystemImage3 */
/* [helpstring][uuid][oleautomation][dual][unique][object] */ 


EXTERN_C const IID IID_IFileSystemImage3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7CFF842C-7E97-4807-8304-910DD8F7C051")
    IFileSystemImage3 : public IFileSystemImage2
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CreateRedundantUdfMetadataFiles( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_CreateRedundantUdfMetadataFiles( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProbeSpecificFileSystem( 
            /* [in] */ FsiFileSystems fileSystemToProbe,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *isAppendable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IFileSystemImage3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IFileSystemImage3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IFileSystemImage3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IFileSystemImage3 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IFileSystemImage3 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Root )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiDirectoryItem **pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SessionStartBlock )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SessionStartBlock )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FreeMediaBlocks )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FreeMediaBlocks )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetMaxMediaBlocksFromDevice )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UsedBlocks )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeName )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_VolumeName )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ImportedVolumeName )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BootImageOptions )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IBootOptions **pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BootImageOptions )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in_opt IBootOptions *newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileCount )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DirectoryCount )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_WorkingDirectory )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_WorkingDirectory )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ChangePoint )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StrictFileSystemCompliance )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StrictFileSystemCompliance )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UseRestrictedCharacterSet )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UseRestrictedCharacterSet )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileSystemsToCreate )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_FileSystemsToCreate )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ FsiFileSystems newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_FileSystemsSupported )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_UDFRevision )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDFRevision )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_UDFRevisionsSupported )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChooseImageDefaults )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ChooseImageDefaultsForMediaType )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ IMAPI_MEDIA_PHYSICAL_TYPE value);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ISO9660InterchangeLevel )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ LONG newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ISO9660InterchangeLevel )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out LONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ISO9660InterchangeLevelsSupported )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateResultImage )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFileSystemImageResult **resultStream);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Exists )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in BSTR fullPath,
            /* [retval][ref][out] */ __RPC__out FsiItemType *itemType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CalculateDiscIdentifier )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *discIdentifier);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *IdentifyFileSystemsOnDisc )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in_opt IDiscRecorder2 *discRecorder,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *fileSystems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDefaultFileSystemForImport )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ FsiFileSystems fileSystems,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *importDefault);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportFileSystem )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out FsiFileSystems *importedFileSystem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ImportSpecificFileSystem )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ FsiFileSystems fileSystemToUse);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RollbackToChangePoint )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ LONG changePoint);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LockInChangePoint )( 
            __RPC__in IFileSystemImage3 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateDirectoryItem )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiDirectoryItem **newItem);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateFileItem )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][ref][out] */ __RPC__deref_out_opt IFsiFileItem **newItem);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameUDF )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameJoliet )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_VolumeNameISO9660 )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StageFiles )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_StageFiles )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MultisessionInterfaces )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_MultisessionInterfaces )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in SAFEARRAY * newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_BootImageOptionsArray )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_BootImageOptionsArray )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ __RPC__in SAFEARRAY * newVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CreateRedundantUdfMetadataFiles )( 
            __RPC__in IFileSystemImage3 * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_CreateRedundantUdfMetadataFiles )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ProbeSpecificFileSystem )( 
            __RPC__in IFileSystemImage3 * This,
            /* [in] */ FsiFileSystems fileSystemToProbe,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *isAppendable);
        
        END_INTERFACE
    } IFileSystemImage3Vtbl;

    interface IFileSystemImage3
    {
        CONST_VTBL struct IFileSystemImage3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IFileSystemImage3_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IFileSystemImage3_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IFileSystemImage3_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IFileSystemImage3_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IFileSystemImage3_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IFileSystemImage3_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IFileSystemImage3_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IFileSystemImage3_get_Root(This,pVal)	\
    ( (This)->lpVtbl -> get_Root(This,pVal) ) 

#define IFileSystemImage3_get_SessionStartBlock(This,pVal)	\
    ( (This)->lpVtbl -> get_SessionStartBlock(This,pVal) ) 

#define IFileSystemImage3_put_SessionStartBlock(This,newVal)	\
    ( (This)->lpVtbl -> put_SessionStartBlock(This,newVal) ) 

#define IFileSystemImage3_get_FreeMediaBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_FreeMediaBlocks(This,pVal) ) 

#define IFileSystemImage3_put_FreeMediaBlocks(This,newVal)	\
    ( (This)->lpVtbl -> put_FreeMediaBlocks(This,newVal) ) 

#define IFileSystemImage3_SetMaxMediaBlocksFromDevice(This,discRecorder)	\
    ( (This)->lpVtbl -> SetMaxMediaBlocksFromDevice(This,discRecorder) ) 

#define IFileSystemImage3_get_UsedBlocks(This,pVal)	\
    ( (This)->lpVtbl -> get_UsedBlocks(This,pVal) ) 

#define IFileSystemImage3_get_VolumeName(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeName(This,pVal) ) 

#define IFileSystemImage3_put_VolumeName(This,newVal)	\
    ( (This)->lpVtbl -> put_VolumeName(This,newVal) ) 

#define IFileSystemImage3_get_ImportedVolumeName(This,pVal)	\
    ( (This)->lpVtbl -> get_ImportedVolumeName(This,pVal) ) 

#define IFileSystemImage3_get_BootImageOptions(This,pVal)	\
    ( (This)->lpVtbl -> get_BootImageOptions(This,pVal) ) 

#define IFileSystemImage3_put_BootImageOptions(This,newVal)	\
    ( (This)->lpVtbl -> put_BootImageOptions(This,newVal) ) 

#define IFileSystemImage3_get_FileCount(This,pVal)	\
    ( (This)->lpVtbl -> get_FileCount(This,pVal) ) 

#define IFileSystemImage3_get_DirectoryCount(This,pVal)	\
    ( (This)->lpVtbl -> get_DirectoryCount(This,pVal) ) 

#define IFileSystemImage3_get_WorkingDirectory(This,pVal)	\
    ( (This)->lpVtbl -> get_WorkingDirectory(This,pVal) ) 

#define IFileSystemImage3_put_WorkingDirectory(This,newVal)	\
    ( (This)->lpVtbl -> put_WorkingDirectory(This,newVal) ) 

#define IFileSystemImage3_get_ChangePoint(This,pVal)	\
    ( (This)->lpVtbl -> get_ChangePoint(This,pVal) ) 

#define IFileSystemImage3_get_StrictFileSystemCompliance(This,pVal)	\
    ( (This)->lpVtbl -> get_StrictFileSystemCompliance(This,pVal) ) 

#define IFileSystemImage3_put_StrictFileSystemCompliance(This,newVal)	\
    ( (This)->lpVtbl -> put_StrictFileSystemCompliance(This,newVal) ) 

#define IFileSystemImage3_get_UseRestrictedCharacterSet(This,pVal)	\
    ( (This)->lpVtbl -> get_UseRestrictedCharacterSet(This,pVal) ) 

#define IFileSystemImage3_put_UseRestrictedCharacterSet(This,newVal)	\
    ( (This)->lpVtbl -> put_UseRestrictedCharacterSet(This,newVal) ) 

#define IFileSystemImage3_get_FileSystemsToCreate(This,pVal)	\
    ( (This)->lpVtbl -> get_FileSystemsToCreate(This,pVal) ) 

#define IFileSystemImage3_put_FileSystemsToCreate(This,newVal)	\
    ( (This)->lpVtbl -> put_FileSystemsToCreate(This,newVal) ) 

#define IFileSystemImage3_get_FileSystemsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_FileSystemsSupported(This,pVal) ) 

#define IFileSystemImage3_put_UDFRevision(This,newVal)	\
    ( (This)->lpVtbl -> put_UDFRevision(This,newVal) ) 

#define IFileSystemImage3_get_UDFRevision(This,pVal)	\
    ( (This)->lpVtbl -> get_UDFRevision(This,pVal) ) 

#define IFileSystemImage3_get_UDFRevisionsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_UDFRevisionsSupported(This,pVal) ) 

#define IFileSystemImage3_ChooseImageDefaults(This,discRecorder)	\
    ( (This)->lpVtbl -> ChooseImageDefaults(This,discRecorder) ) 

#define IFileSystemImage3_ChooseImageDefaultsForMediaType(This,value)	\
    ( (This)->lpVtbl -> ChooseImageDefaultsForMediaType(This,value) ) 

#define IFileSystemImage3_put_ISO9660InterchangeLevel(This,newVal)	\
    ( (This)->lpVtbl -> put_ISO9660InterchangeLevel(This,newVal) ) 

#define IFileSystemImage3_get_ISO9660InterchangeLevel(This,pVal)	\
    ( (This)->lpVtbl -> get_ISO9660InterchangeLevel(This,pVal) ) 

#define IFileSystemImage3_get_ISO9660InterchangeLevelsSupported(This,pVal)	\
    ( (This)->lpVtbl -> get_ISO9660InterchangeLevelsSupported(This,pVal) ) 

#define IFileSystemImage3_CreateResultImage(This,resultStream)	\
    ( (This)->lpVtbl -> CreateResultImage(This,resultStream) ) 

#define IFileSystemImage3_Exists(This,fullPath,itemType)	\
    ( (This)->lpVtbl -> Exists(This,fullPath,itemType) ) 

#define IFileSystemImage3_CalculateDiscIdentifier(This,discIdentifier)	\
    ( (This)->lpVtbl -> CalculateDiscIdentifier(This,discIdentifier) ) 

#define IFileSystemImage3_IdentifyFileSystemsOnDisc(This,discRecorder,fileSystems)	\
    ( (This)->lpVtbl -> IdentifyFileSystemsOnDisc(This,discRecorder,fileSystems) ) 

#define IFileSystemImage3_GetDefaultFileSystemForImport(This,fileSystems,importDefault)	\
    ( (This)->lpVtbl -> GetDefaultFileSystemForImport(This,fileSystems,importDefault) ) 

#define IFileSystemImage3_ImportFileSystem(This,importedFileSystem)	\
    ( (This)->lpVtbl -> ImportFileSystem(This,importedFileSystem) ) 

#define IFileSystemImage3_ImportSpecificFileSystem(This,fileSystemToUse)	\
    ( (This)->lpVtbl -> ImportSpecificFileSystem(This,fileSystemToUse) ) 

#define IFileSystemImage3_RollbackToChangePoint(This,changePoint)	\
    ( (This)->lpVtbl -> RollbackToChangePoint(This,changePoint) ) 

#define IFileSystemImage3_LockInChangePoint(This)	\
    ( (This)->lpVtbl -> LockInChangePoint(This) ) 

#define IFileSystemImage3_CreateDirectoryItem(This,name,newItem)	\
    ( (This)->lpVtbl -> CreateDirectoryItem(This,name,newItem) ) 

#define IFileSystemImage3_CreateFileItem(This,name,newItem)	\
    ( (This)->lpVtbl -> CreateFileItem(This,name,newItem) ) 

#define IFileSystemImage3_get_VolumeNameUDF(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameUDF(This,pVal) ) 

#define IFileSystemImage3_get_VolumeNameJoliet(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameJoliet(This,pVal) ) 

#define IFileSystemImage3_get_VolumeNameISO9660(This,pVal)	\
    ( (This)->lpVtbl -> get_VolumeNameISO9660(This,pVal) ) 

#define IFileSystemImage3_get_StageFiles(This,pVal)	\
    ( (This)->lpVtbl -> get_StageFiles(This,pVal) ) 

#define IFileSystemImage3_put_StageFiles(This,newVal)	\
    ( (This)->lpVtbl -> put_StageFiles(This,newVal) ) 

#define IFileSystemImage3_get_MultisessionInterfaces(This,pVal)	\
    ( (This)->lpVtbl -> get_MultisessionInterfaces(This,pVal) ) 

#define IFileSystemImage3_put_MultisessionInterfaces(This,newVal)	\
    ( (This)->lpVtbl -> put_MultisessionInterfaces(This,newVal) ) 


#define IFileSystemImage3_get_BootImageOptionsArray(This,pVal)	\
    ( (This)->lpVtbl -> get_BootImageOptionsArray(This,pVal) ) 

#define IFileSystemImage3_put_BootImageOptionsArray(This,newVal)	\
    ( (This)->lpVtbl -> put_BootImageOptionsArray(This,newVal) ) 


#define IFileSystemImage3_get_CreateRedundantUdfMetadataFiles(This,pVal)	\
    ( (This)->lpVtbl -> get_CreateRedundantUdfMetadataFiles(This,pVal) ) 

#define IFileSystemImage3_put_CreateRedundantUdfMetadataFiles(This,newVal)	\
    ( (This)->lpVtbl -> put_CreateRedundantUdfMetadataFiles(This,newVal) ) 

#define IFileSystemImage3_ProbeSpecificFileSystem(This,fileSystemToProbe,isAppendable)	\
    ( (This)->lpVtbl -> ProbeSpecificFileSystem(This,fileSystemToProbe,isAppendable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IFileSystemImage3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2fs_0000_0016 */
/* [local] */ 

#define DISPID_DFILESYSTEMIMAGEEVENTS_UPDATE 0x100


extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0016_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0016_v0_0_s_ifspec;

#ifndef __DFileSystemImageEvents_INTERFACE_DEFINED__
#define __DFileSystemImageEvents_INTERFACE_DEFINED__

/* interface DFileSystemImageEvents */
/* [helpstring][unique][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_DFileSystemImageEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C941FDF-975B-59BE-A960-9A2A262853A5")
    DFileSystemImageEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Update( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in BSTR currentFile,
            /* [in] */ LONG copiedSectors,
            /* [in] */ LONG totalSectors) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DFileSystemImageEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DFileSystemImageEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DFileSystemImageEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DFileSystemImageEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DFileSystemImageEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DFileSystemImageEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DFileSystemImageEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DFileSystemImageEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Update )( 
            __RPC__in DFileSystemImageEvents * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ __RPC__in BSTR currentFile,
            /* [in] */ LONG copiedSectors,
            /* [in] */ LONG totalSectors);
        
        END_INTERFACE
    } DFileSystemImageEventsVtbl;

    interface DFileSystemImageEvents
    {
        CONST_VTBL struct DFileSystemImageEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DFileSystemImageEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DFileSystemImageEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DFileSystemImageEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DFileSystemImageEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DFileSystemImageEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DFileSystemImageEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DFileSystemImageEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DFileSystemImageEvents_Update(This,object,currentFile,copiedSectors,totalSectors)	\
    ( (This)->lpVtbl -> Update(This,object,currentFile,copiedSectors,totalSectors) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DFileSystemImageEvents_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2fs_0000_0017 */
/* [local] */ 

#define DISPID_DFILESYSTEMIMAGEIMPORTEVENTS_UPDATEIMPORT 0x101


extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0017_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0017_v0_0_s_ifspec;

#ifndef __DFileSystemImageImportEvents_INTERFACE_DEFINED__
#define __DFileSystemImageImportEvents_INTERFACE_DEFINED__

/* interface DFileSystemImageImportEvents */
/* [helpstring][unique][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_DFileSystemImageImportEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D25C30F9-4087-4366-9E24-E55BE286424B")
    DFileSystemImageImportEvents : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateImport( 
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ FsiFileSystems fileSystem,
            /* [in] */ __RPC__in BSTR currentItem,
            /* [in] */ LONG importedDirectoryItems,
            /* [in] */ LONG totalDirectoryItems,
            /* [in] */ LONG importedFileItems,
            /* [in] */ LONG totalFileItems) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct DFileSystemImageImportEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DFileSystemImageImportEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DFileSystemImageImportEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DFileSystemImageImportEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DFileSystemImageImportEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DFileSystemImageImportEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DFileSystemImageImportEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DFileSystemImageImportEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateImport )( 
            __RPC__in DFileSystemImageImportEvents * This,
            /* [in] */ __RPC__in_opt IDispatch *object,
            /* [in] */ FsiFileSystems fileSystem,
            /* [in] */ __RPC__in BSTR currentItem,
            /* [in] */ LONG importedDirectoryItems,
            /* [in] */ LONG totalDirectoryItems,
            /* [in] */ LONG importedFileItems,
            /* [in] */ LONG totalFileItems);
        
        END_INTERFACE
    } DFileSystemImageImportEventsVtbl;

    interface DFileSystemImageImportEvents
    {
        CONST_VTBL struct DFileSystemImageImportEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DFileSystemImageImportEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DFileSystemImageImportEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DFileSystemImageImportEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DFileSystemImageImportEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DFileSystemImageImportEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DFileSystemImageImportEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DFileSystemImageImportEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define DFileSystemImageImportEvents_UpdateImport(This,object,fileSystem,currentItem,importedDirectoryItems,totalDirectoryItems,importedFileItems,totalFileItems)	\
    ( (This)->lpVtbl -> UpdateImport(This,object,fileSystem,currentItem,importedDirectoryItems,totalDirectoryItems,importedFileItems,totalFileItems) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __DFileSystemImageImportEvents_INTERFACE_DEFINED__ */


#ifndef __IIsoImageManager_INTERFACE_DEFINED__
#define __IIsoImageManager_INTERFACE_DEFINED__

/* interface IIsoImageManager */
/* [helpstring][unique][uuid][object] */ 


EXTERN_C const IID IID_IIsoImageManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6CA38BE5-FBBB-4800-95A1-A438865EB0D4")
    IIsoImageManager : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Stream( 
            /* [retval][out] */ __RPC__deref_out_opt IStream **data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ __RPC__in BSTR Val) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetStream( 
            /* [in] */ __RPC__in_opt IStream *data) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Validate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIsoImageManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IIsoImageManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IIsoImageManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IIsoImageManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IIsoImageManager * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IIsoImageManager * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IIsoImageManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IIsoImageManager * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in IIsoImageManager * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Stream )( 
            __RPC__in IIsoImageManager * This,
            /* [retval][out] */ __RPC__deref_out_opt IStream **data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            __RPC__in IIsoImageManager * This,
            /* [in] */ __RPC__in BSTR Val);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetStream )( 
            __RPC__in IIsoImageManager * This,
            /* [in] */ __RPC__in_opt IStream *data);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Validate )( 
            __RPC__in IIsoImageManager * This);
        
        END_INTERFACE
    } IIsoImageManagerVtbl;

    interface IIsoImageManager
    {
        CONST_VTBL struct IIsoImageManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIsoImageManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIsoImageManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIsoImageManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIsoImageManager_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IIsoImageManager_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IIsoImageManager_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IIsoImageManager_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IIsoImageManager_get_Path(This,pVal)	\
    ( (This)->lpVtbl -> get_Path(This,pVal) ) 

#define IIsoImageManager_get_Stream(This,data)	\
    ( (This)->lpVtbl -> get_Stream(This,data) ) 

#define IIsoImageManager_SetPath(This,Val)	\
    ( (This)->lpVtbl -> SetPath(This,Val) ) 

#define IIsoImageManager_SetStream(This,data)	\
    ( (This)->lpVtbl -> SetStream(This,data) ) 

#define IIsoImageManager_Validate(This)	\
    ( (This)->lpVtbl -> Validate(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIsoImageManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_imapi2fs_0000_0019 */
/* [local] */ 


//
// IMAPIv2 FileSystemImaging version information for TYPELib loading
//
#define IMAPI2FS_MajorVersion          1  
#define IMAPI2FS_MinorVersion          0  
#define IMAPI2FS_FullVersion_STR    "1.0"
#define IMAPI2FS_FullVersion_WSTR  L"1.0"


extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0019_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imapi2fs_0000_0019_v0_0_s_ifspec;


#ifndef __IMAPI2FS_LIBRARY_DEFINED__
#define __IMAPI2FS_LIBRARY_DEFINED__

/* library IMAPI2FS */
/* [helpstring][uuid][version] */ 




EXTERN_C const IID LIBID_IMAPI2FS;

EXTERN_C const CLSID CLSID_BootOptions;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FCE-975B-59BE-A960-9A2A262853A5")
BootOptions;
#endif

EXTERN_C const CLSID CLSID_FsiStream;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FCD-975B-59BE-A960-9A2A262853A5")
FsiStream;
#endif

EXTERN_C const CLSID CLSID_FileSystemImageResult;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FCC-975B-59BE-A960-9A2A262853A5")
FileSystemImageResult;
#endif

EXTERN_C const CLSID CLSID_ProgressItem;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FCB-975B-59BE-A960-9A2A262853A5")
ProgressItem;
#endif

EXTERN_C const CLSID CLSID_EnumProgressItems;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FCA-975B-59BE-A960-9A2A262853A5")
EnumProgressItems;
#endif

EXTERN_C const CLSID CLSID_ProgressItems;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FC9-975B-59BE-A960-9A2A262853A5")
ProgressItems;
#endif

EXTERN_C const CLSID CLSID_FsiDirectoryItem;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FC8-975B-59BE-A960-9A2A262853A5")
FsiDirectoryItem;
#endif

EXTERN_C const CLSID CLSID_FsiFileItem;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FC7-975B-59BE-A960-9A2A262853A5")
FsiFileItem;
#endif

EXTERN_C const CLSID CLSID_EnumFsiItems;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FC6-975B-59BE-A960-9A2A262853A5")
EnumFsiItems;
#endif

EXTERN_C const CLSID CLSID_FsiNamedStreams;

#ifdef __cplusplus

class DECLSPEC_UUID("C6B6F8ED-6D19-44b4-B539-B159B793A32D")
FsiNamedStreams;
#endif

EXTERN_C const CLSID CLSID_MsftFileSystemImage;

#ifdef __cplusplus

class DECLSPEC_UUID("2C941FC5-975B-59BE-A960-9A2A262853A5")
MsftFileSystemImage;
#endif

EXTERN_C const CLSID CLSID_MsftIsoImageManager;

#ifdef __cplusplus

class DECLSPEC_UUID("CEEE3B62-8F56-4056-869B-EF16917E3EFC")
MsftIsoImageManager;
#endif

EXTERN_C const CLSID CLSID_BlockRange;

#ifdef __cplusplus

class DECLSPEC_UUID("B507CA27-2204-11DD-966A-001AA01BBC58")
BlockRange;
#endif

EXTERN_C const CLSID CLSID_BlockRangeList;

#ifdef __cplusplus

class DECLSPEC_UUID("B507CA28-2204-11DD-966A-001AA01BBC58")
BlockRangeList;
#endif
#endif /* __IMAPI2FS_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

/* [helpstring][local] */ HRESULT STDMETHODCALLTYPE IEnumProgressItems_Next_Proxy( 
    IEnumProgressItems * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ IProgressItem **rgelt,
    /* [out] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumProgressItems_Next_Stub( 
    __RPC__in IEnumProgressItems * This,
    /* [range][in] */ __RPC__in_range(1,0x7fffffff) ULONG celt,
    /* [size_is][out] */ __RPC__out_ecount_full(celt) IProgressItem **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);

/* [helpstring][local] */ HRESULT STDMETHODCALLTYPE IEnumFsiItems_Next_Proxy( 
    IEnumFsiItems * This,
    /* [in] */ ULONG celt,
    /* [size_is][out] */ IFsiItem **rgelt,
    /* [out] */ ULONG *pceltFetched);


/* [helpstring][call_as] */ HRESULT STDMETHODCALLTYPE IEnumFsiItems_Next_Stub( 
    __RPC__in IEnumFsiItems * This,
    /* [range][in] */ __RPC__in_range(0,0x7fffffff) ULONG celt,
    /* [size_is][out] */ __RPC__out_ecount_full(celt) IFsiItem **rgelt,
    /* [out] */ __RPC__out ULONG *pceltFetched);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\imapierror.h ===
/* Copyright (c) Microsoft Corporation. All rights reserved. */

#ifndef __IMAPIERROR_H_
#define __IMAPIERROR_H_

#include <winerror.h>

const HRESULT IMAPI_S_PROPERTIESIGNORED     = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ITF, 0x200 + 0 );
const HRESULT IMAPI_S_BUFFER_TO_SMALL       = MAKE_HRESULT( SEVERITY_SUCCESS, FACILITY_ITF, 0x200 + 1 );
const HRESULT IMAPI_E_NOTOPENED             = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 11 );
const HRESULT IMAPI_E_NOTINITIALIZED        = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 12 );
const HRESULT IMAPI_E_USERABORT             = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 13 );
const HRESULT IMAPI_E_GENERIC               = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 14 );
const HRESULT IMAPI_E_MEDIUM_NOTPRESENT     = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 15 );
const HRESULT IMAPI_E_MEDIUM_INVALIDTYPE    = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 16 );
const HRESULT IMAPI_E_DEVICE_NOPROPERTIES   = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 17 );
const HRESULT IMAPI_E_DEVICE_NOTACCESSIBLE  = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 18 );
const HRESULT IMAPI_E_DEVICE_NOTPRESENT     = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 19 );
const HRESULT IMAPI_E_DEVICE_INVALIDTYPE    = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 20 );
const HRESULT IMAPI_E_INITIALIZE_WRITE      = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 21 );
const HRESULT IMAPI_E_INITIALIZE_ENDWRITE   = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 22 );
const HRESULT IMAPI_E_FILESYSTEM            = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 23 );
const HRESULT IMAPI_E_FILEACCESS            = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 24 );
const HRESULT IMAPI_E_DISCINFO              = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 25 );
const HRESULT IMAPI_E_TRACKNOTOPEN          = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 26 );
const HRESULT IMAPI_E_TRACKOPEN             = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 27 );
const HRESULT IMAPI_E_DISCFULL              = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 28 );
const HRESULT IMAPI_E_BADJOLIETNAME         = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 29 );
const HRESULT IMAPI_E_INVALIDIMAGE          = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 30 );
const HRESULT IMAPI_E_NOACTIVEFORMAT        = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 31 );
const HRESULT IMAPI_E_NOACTIVERECORDER      = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 32 );
const HRESULT IMAPI_E_WRONGFORMAT           = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 33 );
const HRESULT IMAPI_E_ALREADYOPEN           = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 34 );
const HRESULT IMAPI_E_WRONGDISC             = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 35 );
const HRESULT IMAPI_E_FILEEXISTS            = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 36 );
const HRESULT IMAPI_E_STASHINUSE            = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 37 );
const HRESULT IMAPI_E_DEVICE_STILL_IN_USE   = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 38 );
const HRESULT IMAPI_E_LOSS_OF_STREAMING     = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 39 );
const HRESULT IMAPI_E_COMPRESSEDSTASH       = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 40 );
const HRESULT IMAPI_E_ENCRYPTEDSTASH        = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 41 );
const HRESULT IMAPI_E_NOTENOUGHDISKFORSTASH = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 42 );
const HRESULT IMAPI_E_REMOVABLESTASH        = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 43 );
const HRESULT IMAPI_E_CANNOT_WRITE_TO_MEDIA = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 44 );
const HRESULT IMAPI_E_TRACK_NOT_BIG_ENOUGH  = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 45 );
const HRESULT IMAPI_E_BOOTIMAGE_AND_NONBLANK_DISC = MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 0x200 + 46 );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ime_cmodes.h ===
#pragma once

#ifndef _IME_CMODES_
#define _IME_CMODES_

// bit field for conversion mode
#define IME_CMODE_ALPHANUMERIC          0x0000
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_CHINESE               IME_CMODE_NATIVE
#define IME_CMODE_HANGUL                IME_CMODE_NATIVE
#define IME_CMODE_JAPANESE              IME_CMODE_NATIVE
#define IME_CMODE_KATAKANA              0x0002  // only effect under IME_CMODE_NATIVE
#define IME_CMODE_LANGUAGE              0x0003
#define IME_CMODE_FULLSHAPE             0x0008
#define IME_CMODE_ROMAN                 0x0010
#define IME_CMODE_CHARCODE              0x0020
#define IME_CMODE_HANJACONVERT          0x0040

#endif /* _IME_CMODES_*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\in6addr.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    in6addr.h

Environment:

    user mode or kernel mode

--*/

#ifndef s6_addr
#pragma once

//
// IPv6 Internet address (RFC 2553)
// This is an 'on-wire' format structure.
//
typedef struct in6_addr {
    union {
        UCHAR       Byte[16];
        USHORT      Word[8];
    } u;
} IN6_ADDR, *PIN6_ADDR, FAR *LPIN6_ADDR;

#define in_addr6 in6_addr

//
// Defines to match RFC 2553.
//
#define _S6_un      u
#define _S6_u8      Byte
#define s6_addr     _S6_un._S6_u8

//
// Defines for our implementation.
//
#define s6_bytes    u.Byte
#define s6_words    u.Word

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\inaddr.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    inaddr.h

Environment:

    user mode or kernel mode

--*/

#ifndef s_addr
#pragma once

//
// IPv4 Internet address
// This is an 'on-wire' format structure.
//
typedef struct in_addr {
        union {
                struct { UCHAR s_b1,s_b2,s_b3,s_b4; } S_un_b;
                struct { USHORT s_w1,s_w2; } S_un_w;
                ULONG S_addr;
        } S_un;
#define s_addr  S_un.S_addr /* can be used for most tcp & ip code */
#define s_host  S_un.S_un_b.s_b2    // host on imp
#define s_net   S_un.S_un_b.s_b1    // network
#define s_imp   S_un.S_un_w.s_w2    // imp
#define s_impno S_un.S_un_b.s_b4    // imp #
#define s_lh    S_un.S_un_b.s_b3    // logical host
} IN_ADDR, *PIN_ADDR, FAR *LPIN_ADDR;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ImgUtil.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for imgutil.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __imgutil_h__
#define __imgutil_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISniffStream_FWD_DEFINED__
#define __ISniffStream_FWD_DEFINED__
typedef interface ISniffStream ISniffStream;
#endif 	/* __ISniffStream_FWD_DEFINED__ */


#ifndef __IDithererImpl_FWD_DEFINED__
#define __IDithererImpl_FWD_DEFINED__
typedef interface IDithererImpl IDithererImpl;
#endif 	/* __IDithererImpl_FWD_DEFINED__ */


#ifndef __CoDitherToRGB8_FWD_DEFINED__
#define __CoDitherToRGB8_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoDitherToRGB8 CoDitherToRGB8;
#else
typedef struct CoDitherToRGB8 CoDitherToRGB8;
#endif /* __cplusplus */

#endif 	/* __CoDitherToRGB8_FWD_DEFINED__ */


#ifndef __CoSniffStream_FWD_DEFINED__
#define __CoSniffStream_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoSniffStream CoSniffStream;
#else
typedef struct CoSniffStream CoSniffStream;
#endif /* __cplusplus */

#endif 	/* __CoSniffStream_FWD_DEFINED__ */


#ifndef __CoMapMIMEToCLSID_FWD_DEFINED__
#define __CoMapMIMEToCLSID_FWD_DEFINED__

#ifdef __cplusplus
typedef class CoMapMIMEToCLSID CoMapMIMEToCLSID;
#else
typedef struct CoMapMIMEToCLSID CoMapMIMEToCLSID;
#endif /* __cplusplus */

#endif 	/* __CoMapMIMEToCLSID_FWD_DEFINED__ */


/* header files for imported files */
#include "ocmm.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_imgutil_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// imgutil.h
//=--------------------------------------------------------------------------=
// (C) Copyright Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#include <ddraw.h>

STDAPI CreateMIMEMap( IMapMIMEToCLSID** ppMap );
STDAPI DecodeImage( IStream* pStream, IMapMIMEToCLSID* pMap,
   IUnknown* pEventSink );
STDAPI SniffStream( IStream* pInStream, UINT* pnFormat,
   IStream** ppOutStream );
STDAPI GetMaxMIMEIDBytes( ULONG* pnMaxBytes );
STDAPI IdentifyMIMEType( const BYTE* pbBytes, ULONG nBytes,
   UINT* pnFormat );
STDAPI ComputeInvCMAP(const RGBQUAD *pRGBColors, ULONG nColors, BYTE *pInvTable,
   ULONG cbTable);
STDAPI DitherTo8( BYTE * pDestBits, LONG nDestPitch, BYTE * pSrcBits, LONG nSrcPitch,
   REFGUID bfidSrc, RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors, BYTE * pbDestInvMap,
   LONG x, LONG y, LONG cx, LONG cy, LONG lDestTrans, LONG lSrcTrans);
STDAPI CreateDDrawSurfaceOnDIB(HBITMAP hbmDib, IDirectDrawSurface **ppSurface);
STDAPI DecodeImageEx( IStream* pStream, IMapMIMEToCLSID* pMap,
   IUnknown* pEventSink, LPCWSTR pszMIMETypeParam );


extern RPC_IF_HANDLE __MIDL_itf_imgutil_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_imgutil_0000_0000_v0_0_s_ifspec;

#ifndef __ISniffStream_INTERFACE_DEFINED__
#define __ISniffStream_INTERFACE_DEFINED__

/* interface ISniffStream */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_ISniffStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4EF17940-30E0-11d0-B724-00AA006C1A01")
    ISniffStream : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            IStream *pStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Peek( 
            void *pBuffer,
            ULONG nBytes,
            ULONG *pnBytesRead) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISniffStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISniffStream * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISniffStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISniffStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISniffStream * This,
            IStream *pStream);
        
        HRESULT ( STDMETHODCALLTYPE *Peek )( 
            ISniffStream * This,
            void *pBuffer,
            ULONG nBytes,
            ULONG *pnBytesRead);
        
        END_INTERFACE
    } ISniffStreamVtbl;

    interface ISniffStream
    {
        CONST_VTBL struct ISniffStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISniffStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISniffStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISniffStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISniffStream_Init(This,pStream)	\
    ( (This)->lpVtbl -> Init(This,pStream) ) 

#define ISniffStream_Peek(This,pBuffer,nBytes,pnBytesRead)	\
    ( (This)->lpVtbl -> Peek(This,pBuffer,nBytes,pnBytesRead) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISniffStream_INTERFACE_DEFINED__ */


#ifndef __IDithererImpl_INTERFACE_DEFINED__
#define __IDithererImpl_INTERFACE_DEFINED__

/* interface IDithererImpl */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IDithererImpl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7C48E840-3910-11d0-86FC-00A0C913F750")
    IDithererImpl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDestColorTable( 
            ULONG nColors,
            const RGBQUAD *prgbColors) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventSink( 
            IImageDecodeEventSink *pEventSink) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDithererImplVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDithererImpl * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDithererImpl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDithererImpl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDestColorTable )( 
            IDithererImpl * This,
            ULONG nColors,
            const RGBQUAD *prgbColors);
        
        HRESULT ( STDMETHODCALLTYPE *SetEventSink )( 
            IDithererImpl * This,
            IImageDecodeEventSink *pEventSink);
        
        END_INTERFACE
    } IDithererImplVtbl;

    interface IDithererImpl
    {
        CONST_VTBL struct IDithererImplVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDithererImpl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDithererImpl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDithererImpl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDithererImpl_SetDestColorTable(This,nColors,prgbColors)	\
    ( (This)->lpVtbl -> SetDestColorTable(This,nColors,prgbColors) ) 

#define IDithererImpl_SetEventSink(This,pEventSink)	\
    ( (This)->lpVtbl -> SetEventSink(This,pEventSink) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDithererImpl_INTERFACE_DEFINED__ */



#ifndef __ImgUtilLib_LIBRARY_DEFINED__
#define __ImgUtilLib_LIBRARY_DEFINED__

/* library ImgUtilLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ImgUtilLib;

EXTERN_C const CLSID CLSID_CoDitherToRGB8;

#ifdef __cplusplus

class DECLSPEC_UUID("A860CE50-3910-11d0-86FC-00A0C913F750")
CoDitherToRGB8;
#endif

EXTERN_C const CLSID CLSID_CoSniffStream;

#ifdef __cplusplus

class DECLSPEC_UUID("6A01FDA0-30DF-11d0-B724-00AA006C1A01")
CoSniffStream;
#endif

EXTERN_C const CLSID CLSID_CoMapMIMEToCLSID;

#ifdef __cplusplus

class DECLSPEC_UUID("30C3B080-30FB-11d0-B724-00AA006C1A01")
CoMapMIMEToCLSID;
#endif
#endif /* __ImgUtilLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IMessage.h ===
/*
 *	I M E S S A G E . H
 *
 *	External definitions for MAPI's IMessage-on-IStorage facility
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _IMESSAGE_H_
#define _IMESSAGE_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"
{
#endif

typedef struct _MSGSESS		FAR * LPMSGSESS;

/*	Typedef of optional callback routine to be called on last release of
 *	top-level messages opened with OpenIMsgOnIStg
 */
typedef void (STDAPICALLTYPE MSGCALLRELEASE)(
	ULONG 		ulCallerData,
	LPMESSAGE	lpMessage );

/* DLL Entry Points (found in mapiu.dll) */

/* OpenIMsgSession
 * CloseIMsgSession
 *
 * These entry points allow the caller to "wrap" the creation of messages
 * inside a session, so that when the session is closed, all messages
 * created within that session are closed as well. Use of IMSG sessions
 * is optional. If OpenIMsgOnIStg is called with a NULL for the lpmsgsess
 * parameter, the message is created independent of any session, and has
 * no way to be shutdown. If the caller forgets to release the message, or
 * to release open tables within the message, the memory will be leaked until
 * the external application terminates.
 */

STDAPI_(SCODE) OpenIMsgSession(
	LPMALLOC		lpMalloc,			/* -> Co malloc object			*/
	ULONG			ulFlags,			/* reserved. Must be zero.		*/
	LPMSGSESS FAR	*lppMsgSess );		/* <- message session object	*/

STDAPI_(void) CloseIMsgSession(
	LPMSGSESS		lpMsgSess );		/* -> message session object	*/

/*	OpenIMsgOnIStg - Main entry point
 *
 *	NOTE 1:  The IStg must be opened with STGM_TRANSACTED if STGM_READWRITE
 *	is specified.  Since messages don't support a write only mode, IMessage
 *	doesn't allow a storage object opened in write only mode. If the storage
 *	is opened STGM_READ, then STGM_TRANSACTED is NOT required.
 *
 *	NOTE 2:  The lpMapiSup parameter is optional.  If supplied then IMessage
 *	will support the MAPI_DIALOG and ATTACH_DIALOG flags (by calling
 *	support method: DoMCDialog) on CopyTo and DeleteAttach methods.
 *	If lpMapiSup is not supplied (i.e. passed 0) then dialog flags will be
 *	ignored.  If supplied then ModifyRecipients will attempt to convert
 *	short term entryids to long term entryids (by calling support method
 *	OpenAddressBook and calls on the returned object).  If not supplied
 *	then short term entryid's will be stored without conversion.
 *
 *	NOTE 3:  The lpfMsgCallRelease parameter is optional.  If supplied then
 *	IMessage will call the routine when the last release on (the toplevel only)
 *	message is called.  It is intended to allow the callee to free the IStorage
 *	that contains the message.  IMessage will not use the IStorage object after
 *	making this call.
 *
 *	NOTE 4:  Behavior of multiple opens of sub-objects (Attachments, Streams,
 *	Storages, Messages, etc.) within a message is deliberately undefined in
 *	MAPI.  This implementation allows them, but will do it by AddRef'ing the
 *	existing open and returning it to the caller of OpenAttachment or
 *	OpenProperty.  This means that whatever access mode the first open on a
 *	specific Attachment or Property had is what all others will get regardless
 *	of what the subsequent opens asked for.
 *
 *	NOTE 5:  There is currently one flag defined for use with the ulFlags
 *	parameter. The IMSG_NO_ISTG_COMMIT flag controls whether the commit
 *	method of IStorage is called when the client calls SaveChanges on the
 *	IMessage object. Some clients of IMessage may wish to commit the IStorage
 *	themselves after writing additional data to the storage (beyond what
 *	IMessage itself writes). To aid in this, the IMessage implementation
 *	guarantees to name all sub-storages starting with "__". Therefore,
 *	if the client keeps its names out of that namespace, there will be no
 *	accidental collisions.
 *
 *	WARNING:	
 *
 *	This implementation of IMessage will support OpenProperty w/MAPI_CREATE
 *	where the source interface is IID_IStorage if the property id is
 *	'PR_ATTACH_DATA'.  Once this has been done, the caller has an IStorage
 *	interface on this property.  This is ok and should allow for
 *	easier implementation of OLE 2.0 Server functionality.  However, if you
 *	pass in the new IStorage ptr (to the attachment data) through the
 *	OpenIMsgOnIStg entry point and then proceed to release things in the
 *	wrong order we will make no attempt to behave in a predictable fashion.
 *	Keep in mind that the correct method for placing a message into an
 *	attachment is to call OpenProperty where the source interface is
 *	IID_IMessage.  The IStorage interface is supported to allow an easy way
 *	to stick a WWord doc. into an attachment w/o converting to/from IStream.
 *
 */
STDAPI_(SCODE) OpenIMsgOnIStg(
	LPMSGSESS		lpMsgSess,			/* -> message session obj (optional) */
	LPALLOCATEBUFFER lpAllocateBuffer,	/* -> AllocateBuffer memory routine  */
	LPALLOCATEMORE 	lpAllocateMore, 	/* -> AllocateMore memory routine    */
	LPFREEBUFFER	lpFreeBuffer, 		/* -> FreeBuffer memory routine      */
	LPMALLOC		lpMalloc,			/* -> Co malloc object				 */
	LPVOID			lpMapiSup,			/* -> MAPI Support Obj (optional)    */
	LPSTORAGE 		lpStg, 				/* -> open IStorage containing msg   */
	MSGCALLRELEASE FAR *lpfMsgCallRelease,	/* -> release callback rtn (opt) */
	ULONG			ulCallerData,		/* caller data returned in callback  */
	ULONG			ulFlags,			/* -> flags (controls istg commit)   */
	LPMESSAGE		FAR *lppMsg );		/* <- open message object			 */

#define IMSG_NO_ISTG_COMMIT		((ULONG) 0x00000001)


/* NOTE: Property Attributes are specific to this IMessage on IStorage 		*/
/* implementation and are not a part of standard MAPI 1.0 property methods 	*/

/* Property Attributes */

#define PROPATTR_MANDATORY		((ULONG) 0x00000001)
#define PROPATTR_READABLE		((ULONG) 0x00000002)
#define PROPATTR_WRITEABLE		((ULONG) 0x00000004)

#define PROPATTR_NOT_PRESENT	((ULONG) 0x00000008)

/* Attribute Array */

typedef struct _SPropAttrArray
{
	ULONG	cValues;							
	ULONG	aPropAttr[MAPI_DIM];
} SPropAttrArray, FAR * LPSPropAttrArray;

#define CbNewSPropAttrArray(_cattr) \
	(offsetof(SPropAttrArray,aPropAttr) + (_cattr)*sizeof(ULONG))
#define CbSPropAttrArray(_lparray) \
	(offsetof(SPropAttrArray,aPropAttr) + \
	(UINT)((_lparray)->cValues)*sizeof(ULONG))

#define SizedSPropAttrArray(_cattr, _name) \
struct _SPropAttrArray_ ## _name \
{ \
	ULONG	cValues; \
	ULONG	aPropAttr[_cattr]; \
} _name



/*	GetAttribIMsgOnIStg - To get attributes on properties
 *
 *	This call is provided because there is no method of IMAPIPropSet to allow
 *	getting attributes.
 */
STDAPI GetAttribIMsgOnIStg(
	LPVOID					lpObject,
	LPSPropTagArray			lpPropTagArray,
	LPSPropAttrArray FAR 	*lppPropAttrArray );

/*	SetAttribIMsgOnIStg - To set attributes on properties
 *
 *	This call is provided because there is no method of IMAPIPropSet to allow
 *	setting of attributes.
 */
STDAPI SetAttribIMsgOnIStg(
	LPVOID					lpObject,
	LPSPropTagArray			lpPropTags,
	LPSPropAttrArray		lpPropAttrs,
	LPSPropProblemArray FAR	*lppPropProblems );

/*	MapStorageSCode - To map an IStorage hResult to a MAPI sCode value
 *
 *	This call is provided for the internal use of PDK components that base
 *	their message implementations on IMessage.  Since these components must
 *	open the storage themselves, there is a common need to map OLE 2.0
 *	Storage error returns to MAPI sCodes.
 *
 *	WARNING:	There is no guarantee that this entry point will exist in
 *	shipped versions of mapiu.dll.
 */
STDAPI_(SCODE) MapStorageSCode( SCODE StgSCode );


#ifdef __cplusplus
}
#endif

#endif	/* _IMESSAGE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ime.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ime.h

Abstract:

    Procedure declarations, constant definitions and macros for the IME
    component.

--*/

#ifndef _IME_
#define _IME_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


#ifndef _WINDEF_
typedef unsigned int UINT;
#endif // _WINDEF_

#define IME_MAXPROCESS 32

LRESULT WINAPI SendIMEMessageExA( IN HWND, IN LPARAM);
LRESULT WINAPI SendIMEMessageExW( IN HWND, IN LPARAM);
#ifdef UNICODE
#define SendIMEMessageEx  SendIMEMessageExW
#else
#define SendIMEMessageEx  SendIMEMessageExA
#endif // !UNICODE

//
// IMESTRUCT structure for SendIMEMessageEx
//
typedef struct tagIMESTRUCT {
    UINT     fnc;        // function code
    WPARAM   wParam;     // word parameter
    UINT     wCount;     // word counter
    UINT     dchSource;  // offset to Source from top of memory object
    UINT     dchDest;    // offset to Desrination from top of memory object
    LPARAM   lParam1;
    LPARAM   lParam2;
    LPARAM   lParam3;
} IMESTRUCT,*PIMESTRUCT,NEAR *NPIMESTRUCT,FAR *LPIMESTRUCT;



#define CP_HWND                 0
#define CP_OPEN                 1
#define CP_DIRECT               2
#define CP_LEVEL                3


//
//      Virtual Keys
//

#if !defined(VK_DBE_ALPHANUMERIC)
#define VK_DBE_ALPHANUMERIC              0x0f0
#define VK_DBE_KATAKANA                  0x0f1
#define VK_DBE_HIRAGANA                  0x0f2
#define VK_DBE_SBCSCHAR                  0x0f3
#define VK_DBE_DBCSCHAR                  0x0f4
#define VK_DBE_ROMAN                     0x0f5
#define VK_DBE_NOROMAN                   0x0f6
#define VK_DBE_ENTERWORDREGISTERMODE     0x0f7
#define VK_DBE_ENTERIMECONFIGMODE        0x0f8
#define VK_DBE_FLUSHSTRING               0x0f9
#define VK_DBE_CODEINPUT                 0x0fa
#define VK_DBE_NOCODEINPUT               0x0fb
#define VK_DBE_DETERMINESTRING           0x0fc
#define VK_DBE_ENTERDLGCONVERSIONMODE    0x0fd
#endif


//
//     switch for wParam of IME_SETCONVERSIONWINDOW
//
#define MCW_DEFAULT             0x00
#define MCW_RECT                0x01
#define MCW_WINDOW              0x02
#define MCW_SCREEN              0x04
#define MCW_VERTICAL            0x08
#define MCW_HIDDEN              0x10

//
//    switch for wParam of IME_SETCONVERSIONMODE
//       and IME_GETCONVERSIONMODE
//
#define IME_MODE_ALPHANUMERIC   0x0001

#ifdef KOREA    // BeomOh - 9/29/92
#define IME_MODE_SBCSCHAR       0x0002
#else
#define IME_MODE_SBCSCHAR       0x0008
#endif

#define IME_MODE_KATAKANA       0x0002
#define IME_MODE_HIRAGANA       0x0004
#define IME_MODE_HANJACONVERT   0x0004
#define IME_MODE_DBCSCHAR       0x0010
#define IME_MODE_ROMAN          0x0020
#define IME_MODE_NOROMAN        0x0040
#define IME_MODE_CODEINPUT      0x0080
#define IME_MODE_NOCODEINPUT    0x0100
//
//

//
//     IME APIs
//
#define IME_GETIMECAPS            0x03
#define IME_SETOPEN               0x04
#define IME_GETOPEN               0x05
#define IME_GETVERSION            0x07
#define IME_SETCONVERSIONWINDOW   0x08
#define IME_MOVEIMEWINDOW         IME_SETCONVERSIONWINDOW       // KOREA only
#define IME_SETCONVERSIONMODE     0x10

#define IME_GETCONVERSIONMODE     0x11
#define IME_SET_MODE              0x12          // KOREA only
#define IME_SENDVKEY              0x13
#define IME_ENTERWORDREGISTERMODE 0x18
#define IME_SETCONVERSIONFONTEX   0x19

//
// IME_CODECONVERT subfunctions
//
#define IME_BANJAtoJUNJA        0x13            // KOREA only
#define IME_JUNJAtoBANJA        0x14            // KOREA only
#define IME_JOHABtoKS           0x15            // KOREA only
#define IME_KStoJOHAB           0x16            // KOREA only

//
// IME_AUTOMATA subfunctions
//
#define IMEA_INIT               0x01            // KOREA only
#define IMEA_NEXT               0x02            // KOREA only
#define IMEA_PREV               0x03            // KOREA only

//
// IME_HANJAMODE subfunctions
//
#define IME_REQUEST_CONVERT     0x01            // KOREA only
#define IME_ENABLE_CONVERT      0x02            // KOREA only

//
// IME_MOVEIMEWINDOW subfunctions
//
#define INTERIM_WINDOW          0x00            // KOREA only
#define MODE_WINDOW             0x01            // KOREA only
#define HANJA_WINDOW            0x02            // KOREA only

//
//    error code
//
#define IME_RS_ERROR            0x01    // genetal error
#define IME_RS_NOIME            0x02    // IME is not installed
#define IME_RS_TOOLONG          0x05    // given string is too long
#define IME_RS_ILLEGAL          0x06    // illegal charactor(s) is string
#define IME_RS_NOTFOUND         0x07    // no (more) candidate
#define IME_RS_NOROOM           0x0a    // no disk/memory space
#define IME_RS_DISKERROR        0x0e    // disk I/O error
#define IME_RS_INVALID          0x11    // Win3.1/NT
#define IME_RS_NEST             0x12    // called nested
#define IME_RS_SYSTEMMODAL      0x13    // called when system mode

//
//   report messge from IME to WinApps
//
#define WM_IME_REPORT       0x0280

//
//   report message parameter for WM_IME_REPORT
//
#define IR_STRINGSTART      0x100
#define IR_STRINGEND        0x101
#define IR_OPENCONVERT      0x120
#define IR_CHANGECONVERT    0x121
#define IR_CLOSECONVERT     0x122
#define IR_FULLCONVERT      0x123
#define IR_IMESELECT        0x130
#define IR_STRING       0x140
#define IR_DBCSCHAR             0x160
#define IR_UNDETERMINE          0x170
#define IR_STRINGEX             0x180   // New for 3.1
#define IR_MODEINFO             0x190

//#define WM_CONVERTREQUESTEX     0x0109
#define WM_WNT_CONVERTREQUESTEX 0x0109 /* WM_CONVERTREQUESTEX: 109 for NT, 108 for OT */
#define WM_CONVERTREQUEST       0x010A
#define WM_CONVERTRESULT        0x010B
#define WM_INTERIM              0x010C

#define WM_IMEKEYDOWN           0x290
#define WM_IMEKEYUP             0x291


//
// UNDETERMINESTRING structure for IR_UNDETERMINE
//
typedef struct tagUNDETERMINESTRUCT {
    DWORD    dwSize;
    UINT     uDefIMESize;
    UINT     uDefIMEPos;
    UINT     uUndetTextLen;
    UINT     uUndetTextPos;
    UINT     uUndetAttrPos;
    UINT     uCursorPos;
    UINT     uDeltaStart;
    UINT     uDetermineTextLen;
    UINT     uDetermineTextPos;
    UINT     uDetermineDelimPos;
    UINT     uYomiTextLen;
    UINT     uYomiTextPos;
    UINT     uYomiDelimPos;
} UNDETERMINESTRUCT,*PUNDETERMINESTRUCT,NEAR *NPUNDETERMINESTRUCT,FAR *LPUNDETERMINESTRUCT;


typedef struct tagSTRINGEXSTRUCT {
    DWORD    dwSize;
    UINT     uDeterminePos;
    UINT     uDetermineDelimPos;
    UINT     uYomiPos;
    UINT     uYomiDelimPos;
} STRINGEXSTRUCT,NEAR *NPSTRINGEXSTRUCT,FAR *LPSTRINGEXSTRUCT;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _IME_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\indexsrv.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for indexsrv.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __indexsrv_h__
#define __indexsrv_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IPhraseSink_FWD_DEFINED__
#define __IPhraseSink_FWD_DEFINED__
typedef interface IPhraseSink IPhraseSink;
#endif 	/* __IPhraseSink_FWD_DEFINED__ */


#ifndef __IWordSink_FWD_DEFINED__
#define __IWordSink_FWD_DEFINED__
typedef interface IWordSink IWordSink;
#endif 	/* __IWordSink_FWD_DEFINED__ */


#ifndef __IWordBreaker_FWD_DEFINED__
#define __IWordBreaker_FWD_DEFINED__
typedef interface IWordBreaker IWordBreaker;
#endif 	/* __IWordBreaker_FWD_DEFINED__ */


#ifndef __IWordFormSink_FWD_DEFINED__
#define __IWordFormSink_FWD_DEFINED__
typedef interface IWordFormSink IWordFormSink;
#endif 	/* __IWordFormSink_FWD_DEFINED__ */


#ifndef __IStemmer_FWD_DEFINED__
#define __IStemmer_FWD_DEFINED__
typedef interface IStemmer IStemmer;
#endif 	/* __IStemmer_FWD_DEFINED__ */


#ifndef __ISimpleCommandCreator_FWD_DEFINED__
#define __ISimpleCommandCreator_FWD_DEFINED__
typedef interface ISimpleCommandCreator ISimpleCommandCreator;
#endif 	/* __ISimpleCommandCreator_FWD_DEFINED__ */


#ifndef __IColumnMapper_FWD_DEFINED__
#define __IColumnMapper_FWD_DEFINED__
typedef interface IColumnMapper IColumnMapper;
#endif 	/* __IColumnMapper_FWD_DEFINED__ */


#ifndef __IColumnMapperCreator_FWD_DEFINED__
#define __IColumnMapperCreator_FWD_DEFINED__
typedef interface IColumnMapperCreator IColumnMapperCreator;
#endif 	/* __IColumnMapperCreator_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "filter.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IPhraseSink_INTERFACE_DEFINED__
#define __IPhraseSink_INTERFACE_DEFINED__

/* interface IPhraseSink */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IPhraseSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC906FF0-C058-101A-B554-08002B33B0E6")
    IPhraseSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutSmallPhrase( 
            /* [size_is][in] */ const WCHAR *pwcNoun,
            /* [in] */ ULONG cwcNoun,
            /* [size_is][in] */ const WCHAR *pwcModifier,
            /* [in] */ ULONG cwcModifier,
            /* [in] */ ULONG ulAttachmentType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutPhrase( 
            /* [size_is][in] */ const WCHAR *pwcPhrase,
            /* [in] */ ULONG cwcPhrase) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPhraseSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPhraseSink * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPhraseSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPhraseSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutSmallPhrase )( 
            IPhraseSink * This,
            /* [size_is][in] */ const WCHAR *pwcNoun,
            /* [in] */ ULONG cwcNoun,
            /* [size_is][in] */ const WCHAR *pwcModifier,
            /* [in] */ ULONG cwcModifier,
            /* [in] */ ULONG ulAttachmentType);
        
        HRESULT ( STDMETHODCALLTYPE *PutPhrase )( 
            IPhraseSink * This,
            /* [size_is][in] */ const WCHAR *pwcPhrase,
            /* [in] */ ULONG cwcPhrase);
        
        END_INTERFACE
    } IPhraseSinkVtbl;

    interface IPhraseSink
    {
        CONST_VTBL struct IPhraseSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPhraseSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IPhraseSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IPhraseSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IPhraseSink_PutSmallPhrase(This,pwcNoun,cwcNoun,pwcModifier,cwcModifier,ulAttachmentType)	\
    ( (This)->lpVtbl -> PutSmallPhrase(This,pwcNoun,cwcNoun,pwcModifier,cwcModifier,ulAttachmentType) ) 

#define IPhraseSink_PutPhrase(This,pwcPhrase,cwcPhrase)	\
    ( (This)->lpVtbl -> PutPhrase(This,pwcPhrase,cwcPhrase) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IPhraseSink_INTERFACE_DEFINED__ */


#ifndef __IWordSink_INTERFACE_DEFINED__
#define __IWordSink_INTERFACE_DEFINED__

/* interface IWordSink */
/* [unique][uuid][object][local] */ 

#ifndef _tagWORDREP_BREAK_TYPE_DEFINED
typedef 
enum tagWORDREP_BREAK_TYPE
    {	WORDREP_BREAK_EOW	= 0,
	WORDREP_BREAK_EOS	= 1,
	WORDREP_BREAK_EOP	= 2,
	WORDREP_BREAK_EOC	= 3
    } 	WORDREP_BREAK_TYPE;

#define _tagWORDREP_BREAK_TYPE_DEFINED
#define _WORDREP_BREAK_TYPE_DEFINED
#endif

EXTERN_C const IID IID_IWordSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC907054-C058-101A-B554-08002B33B0E6")
    IWordSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutWord( 
            /* [in] */ ULONG cwc,
            /* [size_is][in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwcSrcLen,
            /* [in] */ ULONG cwcSrcPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutAltWord( 
            /* [in] */ ULONG cwc,
            /* [size_is][in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwcSrcLen,
            /* [in] */ ULONG cwcSrcPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAltPhrase( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndAltPhrase( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutBreak( 
            /* [in] */ WORDREP_BREAK_TYPE breakType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWordSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWordSink * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWordSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWordSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutWord )( 
            IWordSink * This,
            /* [in] */ ULONG cwc,
            /* [size_is][in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwcSrcLen,
            /* [in] */ ULONG cwcSrcPos);
        
        HRESULT ( STDMETHODCALLTYPE *PutAltWord )( 
            IWordSink * This,
            /* [in] */ ULONG cwc,
            /* [size_is][in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwcSrcLen,
            /* [in] */ ULONG cwcSrcPos);
        
        HRESULT ( STDMETHODCALLTYPE *StartAltPhrase )( 
            IWordSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndAltPhrase )( 
            IWordSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutBreak )( 
            IWordSink * This,
            /* [in] */ WORDREP_BREAK_TYPE breakType);
        
        END_INTERFACE
    } IWordSinkVtbl;

    interface IWordSink
    {
        CONST_VTBL struct IWordSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWordSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWordSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWordSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWordSink_PutWord(This,cwc,pwcInBuf,cwcSrcLen,cwcSrcPos)	\
    ( (This)->lpVtbl -> PutWord(This,cwc,pwcInBuf,cwcSrcLen,cwcSrcPos) ) 

#define IWordSink_PutAltWord(This,cwc,pwcInBuf,cwcSrcLen,cwcSrcPos)	\
    ( (This)->lpVtbl -> PutAltWord(This,cwc,pwcInBuf,cwcSrcLen,cwcSrcPos) ) 

#define IWordSink_StartAltPhrase(This)	\
    ( (This)->lpVtbl -> StartAltPhrase(This) ) 

#define IWordSink_EndAltPhrase(This)	\
    ( (This)->lpVtbl -> EndAltPhrase(This) ) 

#define IWordSink_PutBreak(This,breakType)	\
    ( (This)->lpVtbl -> PutBreak(This,breakType) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWordSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_indexsrv_0000_0002 */
/* [local] */ 

#ifndef _tagTEXT_SOURCE_DEFINED

typedef HRESULT ( __stdcall *PFNFILLTEXTBUFFER )( 
    struct tagTEXT_SOURCE *pTextSource);

typedef struct tagTEXT_SOURCE
    {
    PFNFILLTEXTBUFFER pfnFillTextBuffer;
    const WCHAR *awcBuffer;
    ULONG iEnd;
    ULONG iCur;
    } 	TEXT_SOURCE;

#define _tagTEXT_SOURCE_DEFINED
#define _TEXT_SOURCE_DEFINED
#endif


extern RPC_IF_HANDLE __MIDL_itf_indexsrv_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_indexsrv_0000_0002_v0_0_s_ifspec;

#ifndef __IWordBreaker_INTERFACE_DEFINED__
#define __IWordBreaker_INTERFACE_DEFINED__

/* interface IWordBreaker */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IWordBreaker;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D53552C8-77E3-101A-B552-08002B33B0E6")
    IWordBreaker : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ BOOL fQuery,
            /* [in] */ ULONG ulMaxTokenSize,
            /* [out] */ BOOL *pfLicense) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BreakText( 
            /* [in] */ TEXT_SOURCE *pTextSource,
            /* [in] */ IWordSink *pWordSink,
            /* [in] */ IPhraseSink *pPhraseSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ComposePhrase( 
            /* [size_is][in] */ const WCHAR *pwcNoun,
            /* [in] */ ULONG cwcNoun,
            /* [size_is][in] */ const WCHAR *pwcModifier,
            /* [in] */ ULONG cwcModifier,
            /* [in] */ ULONG ulAttachmentType,
            /* [size_is][out] */ WCHAR *pwcPhrase,
            /* [out][in] */ ULONG *pcwcPhrase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLicenseToUse( 
            /* [string][out] */ const WCHAR **ppwcsLicense) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWordBreakerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWordBreaker * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWordBreaker * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWordBreaker * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IWordBreaker * This,
            /* [in] */ BOOL fQuery,
            /* [in] */ ULONG ulMaxTokenSize,
            /* [out] */ BOOL *pfLicense);
        
        HRESULT ( STDMETHODCALLTYPE *BreakText )( 
            IWordBreaker * This,
            /* [in] */ TEXT_SOURCE *pTextSource,
            /* [in] */ IWordSink *pWordSink,
            /* [in] */ IPhraseSink *pPhraseSink);
        
        HRESULT ( STDMETHODCALLTYPE *ComposePhrase )( 
            IWordBreaker * This,
            /* [size_is][in] */ const WCHAR *pwcNoun,
            /* [in] */ ULONG cwcNoun,
            /* [size_is][in] */ const WCHAR *pwcModifier,
            /* [in] */ ULONG cwcModifier,
            /* [in] */ ULONG ulAttachmentType,
            /* [size_is][out] */ WCHAR *pwcPhrase,
            /* [out][in] */ ULONG *pcwcPhrase);
        
        HRESULT ( STDMETHODCALLTYPE *GetLicenseToUse )( 
            IWordBreaker * This,
            /* [string][out] */ const WCHAR **ppwcsLicense);
        
        END_INTERFACE
    } IWordBreakerVtbl;

    interface IWordBreaker
    {
        CONST_VTBL struct IWordBreakerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWordBreaker_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWordBreaker_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWordBreaker_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWordBreaker_Init(This,fQuery,ulMaxTokenSize,pfLicense)	\
    ( (This)->lpVtbl -> Init(This,fQuery,ulMaxTokenSize,pfLicense) ) 

#define IWordBreaker_BreakText(This,pTextSource,pWordSink,pPhraseSink)	\
    ( (This)->lpVtbl -> BreakText(This,pTextSource,pWordSink,pPhraseSink) ) 

#define IWordBreaker_ComposePhrase(This,pwcNoun,cwcNoun,pwcModifier,cwcModifier,ulAttachmentType,pwcPhrase,pcwcPhrase)	\
    ( (This)->lpVtbl -> ComposePhrase(This,pwcNoun,cwcNoun,pwcModifier,cwcModifier,ulAttachmentType,pwcPhrase,pcwcPhrase) ) 

#define IWordBreaker_GetLicenseToUse(This,ppwcsLicense)	\
    ( (This)->lpVtbl -> GetLicenseToUse(This,ppwcsLicense) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWordBreaker_INTERFACE_DEFINED__ */


#ifndef __IWordFormSink_INTERFACE_DEFINED__
#define __IWordFormSink_INTERFACE_DEFINED__

/* interface IWordFormSink */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IWordFormSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fe77c330-7f42-11ce-be57-00aa0051fe20")
    IWordFormSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE PutAltWord( 
            /* [size_is][in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutWord( 
            /* [size_is][in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwc) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWordFormSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWordFormSink * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWordFormSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWordFormSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *PutAltWord )( 
            IWordFormSink * This,
            /* [size_is][in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwc);
        
        HRESULT ( STDMETHODCALLTYPE *PutWord )( 
            IWordFormSink * This,
            /* [size_is][in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwc);
        
        END_INTERFACE
    } IWordFormSinkVtbl;

    interface IWordFormSink
    {
        CONST_VTBL struct IWordFormSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWordFormSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWordFormSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWordFormSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWordFormSink_PutAltWord(This,pwcInBuf,cwc)	\
    ( (This)->lpVtbl -> PutAltWord(This,pwcInBuf,cwc) ) 

#define IWordFormSink_PutWord(This,pwcInBuf,cwc)	\
    ( (This)->lpVtbl -> PutWord(This,pwcInBuf,cwc) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWordFormSink_INTERFACE_DEFINED__ */


#ifndef __IStemmer_INTERFACE_DEFINED__
#define __IStemmer_INTERFACE_DEFINED__

/* interface IStemmer */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IStemmer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("efbaf140-7f42-11ce-be57-00aa0051fe20")
    IStemmer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ ULONG ulMaxTokenSize,
            /* [out] */ BOOL *pfLicense) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateWordForms( 
            /* [in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwc,
            /* [in] */ IWordFormSink *pStemSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLicenseToUse( 
            /* [string][out] */ const WCHAR **ppwcsLicense) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStemmerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStemmer * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStemmer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStemmer * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            IStemmer * This,
            /* [in] */ ULONG ulMaxTokenSize,
            /* [out] */ BOOL *pfLicense);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateWordForms )( 
            IStemmer * This,
            /* [in] */ const WCHAR *pwcInBuf,
            /* [in] */ ULONG cwc,
            /* [in] */ IWordFormSink *pStemSink);
        
        HRESULT ( STDMETHODCALLTYPE *GetLicenseToUse )( 
            IStemmer * This,
            /* [string][out] */ const WCHAR **ppwcsLicense);
        
        END_INTERFACE
    } IStemmerVtbl;

    interface IStemmer
    {
        CONST_VTBL struct IStemmerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStemmer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStemmer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStemmer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStemmer_Init(This,ulMaxTokenSize,pfLicense)	\
    ( (This)->lpVtbl -> Init(This,ulMaxTokenSize,pfLicense) ) 

#define IStemmer_GenerateWordForms(This,pwcInBuf,cwc,pStemSink)	\
    ( (This)->lpVtbl -> GenerateWordForms(This,pwcInBuf,cwc,pStemSink) ) 

#define IStemmer_GetLicenseToUse(This,ppwcsLicense)	\
    ( (This)->lpVtbl -> GetLicenseToUse(This,ppwcsLicense) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStemmer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_indexsrv_0000_0005 */
/* [local] */ 




extern RPC_IF_HANDLE __MIDL_itf_indexsrv_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_indexsrv_0000_0005_v0_0_s_ifspec;

#ifndef __ISimpleCommandCreator_INTERFACE_DEFINED__
#define __ISimpleCommandCreator_INTERFACE_DEFINED__

/* interface ISimpleCommandCreator */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_ISimpleCommandCreator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5e341ab7-02d0-11d1-900c-00a0c9063796")
    ISimpleCommandCreator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateICommand( 
            IUnknown **ppIUnknown,
            IUnknown *pOuterUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VerifyCatalog( 
            const WCHAR *pwszMachine,
            const WCHAR *pwszCatalogName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultCatalog( 
            WCHAR *pwszCatalogName,
            ULONG cwcIn,
            ULONG *pcwcOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISimpleCommandCreatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISimpleCommandCreator * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISimpleCommandCreator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISimpleCommandCreator * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateICommand )( 
            ISimpleCommandCreator * This,
            IUnknown **ppIUnknown,
            IUnknown *pOuterUnk);
        
        HRESULT ( STDMETHODCALLTYPE *VerifyCatalog )( 
            ISimpleCommandCreator * This,
            const WCHAR *pwszMachine,
            const WCHAR *pwszCatalogName);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultCatalog )( 
            ISimpleCommandCreator * This,
            WCHAR *pwszCatalogName,
            ULONG cwcIn,
            ULONG *pcwcOut);
        
        END_INTERFACE
    } ISimpleCommandCreatorVtbl;

    interface ISimpleCommandCreator
    {
        CONST_VTBL struct ISimpleCommandCreatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISimpleCommandCreator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISimpleCommandCreator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISimpleCommandCreator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISimpleCommandCreator_CreateICommand(This,ppIUnknown,pOuterUnk)	\
    ( (This)->lpVtbl -> CreateICommand(This,ppIUnknown,pOuterUnk) ) 

#define ISimpleCommandCreator_VerifyCatalog(This,pwszMachine,pwszCatalogName)	\
    ( (This)->lpVtbl -> VerifyCatalog(This,pwszMachine,pwszCatalogName) ) 

#define ISimpleCommandCreator_GetDefaultCatalog(This,pwszCatalogName,cwcIn,pcwcOut)	\
    ( (This)->lpVtbl -> GetDefaultCatalog(This,pwszCatalogName,cwcIn,pcwcOut) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISimpleCommandCreator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_indexsrv_0000_0006 */
/* [local] */ 

#define CLSID_CISimpleCommandCreator {0xc7b6c04a, 0xcbb5, 0x11d0, {0xbb, 0x4c, 0x0, 0xc0, 0x4f, 0xc2, 0xf4, 0x10 } }
typedef struct tagDBID DBID;

typedef WORD DBTYPE;



extern RPC_IF_HANDLE __MIDL_itf_indexsrv_0000_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_indexsrv_0000_0006_v0_0_s_ifspec;

#ifndef __IColumnMapper_INTERFACE_DEFINED__
#define __IColumnMapper_INTERFACE_DEFINED__

/* interface IColumnMapper */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IColumnMapper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0b63e37a-9ccc-11d0-bcdb-00805fccce04")
    IColumnMapper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetPropInfoFromName( 
            /* [string][in] */ const WCHAR *wcsPropName,
            /* [out] */ DBID **ppPropId,
            /* [out] */ DBTYPE *pPropType,
            /* [out] */ unsigned int *puiWidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPropInfoFromId( 
            /* [in] */ const DBID *pPropId,
            /* [out] */ WCHAR **pwcsName,
            /* [out] */ DBTYPE *pPropType,
            /* [out] */ unsigned int *puiWidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumPropInfo( 
            /* [in] */ ULONG iEntry,
            /* [out] */ const WCHAR **pwcsName,
            /* [out] */ DBID **ppPropId,
            /* [out] */ DBTYPE *pPropType,
            /* [out] */ unsigned int *puiWidth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsMapUpToDate( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnMapperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IColumnMapper * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IColumnMapper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IColumnMapper * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropInfoFromName )( 
            IColumnMapper * This,
            /* [string][in] */ const WCHAR *wcsPropName,
            /* [out] */ DBID **ppPropId,
            /* [out] */ DBTYPE *pPropType,
            /* [out] */ unsigned int *puiWidth);
        
        HRESULT ( STDMETHODCALLTYPE *GetPropInfoFromId )( 
            IColumnMapper * This,
            /* [in] */ const DBID *pPropId,
            /* [out] */ WCHAR **pwcsName,
            /* [out] */ DBTYPE *pPropType,
            /* [out] */ unsigned int *puiWidth);
        
        HRESULT ( STDMETHODCALLTYPE *EnumPropInfo )( 
            IColumnMapper * This,
            /* [in] */ ULONG iEntry,
            /* [out] */ const WCHAR **pwcsName,
            /* [out] */ DBID **ppPropId,
            /* [out] */ DBTYPE *pPropType,
            /* [out] */ unsigned int *puiWidth);
        
        HRESULT ( STDMETHODCALLTYPE *IsMapUpToDate )( 
            IColumnMapper * This);
        
        END_INTERFACE
    } IColumnMapperVtbl;

    interface IColumnMapper
    {
        CONST_VTBL struct IColumnMapperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnMapper_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IColumnMapper_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IColumnMapper_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IColumnMapper_GetPropInfoFromName(This,wcsPropName,ppPropId,pPropType,puiWidth)	\
    ( (This)->lpVtbl -> GetPropInfoFromName(This,wcsPropName,ppPropId,pPropType,puiWidth) ) 

#define IColumnMapper_GetPropInfoFromId(This,pPropId,pwcsName,pPropType,puiWidth)	\
    ( (This)->lpVtbl -> GetPropInfoFromId(This,pPropId,pwcsName,pPropType,puiWidth) ) 

#define IColumnMapper_EnumPropInfo(This,iEntry,pwcsName,ppPropId,pPropType,puiWidth)	\
    ( (This)->lpVtbl -> EnumPropInfo(This,iEntry,pwcsName,ppPropId,pPropType,puiWidth) ) 

#define IColumnMapper_IsMapUpToDate(This)	\
    ( (This)->lpVtbl -> IsMapUpToDate(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IColumnMapper_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_indexsrv_0000_0007 */
/* [local] */ 

#define	LOCAL_MACHINE	( L"." )

#define	SYSTEM_DEFAULT_CAT	( L"__SystemDefault__" )

#define	INDEX_SERVER_DEFAULT_CAT	( L"__IndexServerDefault__" )



extern RPC_IF_HANDLE __MIDL_itf_indexsrv_0000_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_indexsrv_0000_0007_v0_0_s_ifspec;

#ifndef __IColumnMapperCreator_INTERFACE_DEFINED__
#define __IColumnMapperCreator_INTERFACE_DEFINED__

/* interface IColumnMapperCreator */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IColumnMapperCreator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0b63e37b-9ccc-11d0-bcdb-00805fccce04")
    IColumnMapperCreator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetColumnMapper( 
            /* [string][in] */ const WCHAR *wcsMachineName,
            /* [string][in] */ const WCHAR *wcsCatalogName,
            /* [out] */ IColumnMapper **ppColumnMapper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IColumnMapperCreatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IColumnMapperCreator * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IColumnMapperCreator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IColumnMapperCreator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetColumnMapper )( 
            IColumnMapperCreator * This,
            /* [string][in] */ const WCHAR *wcsMachineName,
            /* [string][in] */ const WCHAR *wcsCatalogName,
            /* [out] */ IColumnMapper **ppColumnMapper);
        
        END_INTERFACE
    } IColumnMapperCreatorVtbl;

    interface IColumnMapperCreator
    {
        CONST_VTBL struct IColumnMapperCreatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IColumnMapperCreator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IColumnMapperCreator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IColumnMapperCreator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IColumnMapperCreator_GetColumnMapper(This,wcsMachineName,wcsCatalogName,ppColumnMapper)	\
    ( (This)->lpVtbl -> GetColumnMapper(This,wcsMachineName,wcsCatalogName,ppColumnMapper) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IColumnMapperCreator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Imm.h ===
/**********************************************************************/
/*      imm.h - Input Method Manager definitions                      */
/*                                                                    */
/*      Copyright (c) Microsoft Corporation. All rights reserved.     */
/**********************************************************************/

#ifndef _IMM_
#define _IMM_


#ifdef __cplusplus
extern "C" {
#endif


#ifndef _IMM_SDK_DEFINED_
#define _IMM_SDK_DEFINED_

#if (WINVER >= 0x040A)
DECLARE_HANDLE(HIMC);
DECLARE_HANDLE(HIMCC);
#else
typedef DWORD   HIMC;
typedef DWORD   HIMCC;
#endif /* WINVER >= 0x040A */

typedef HKL FAR  *LPHKL;
typedef UINT FAR *LPUINT;

typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM, NEAR *NPCOMPOSITIONFORM, FAR *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM, NEAR *NPCANDIDATEFORM, FAR *LPCANDIDATEFORM;


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST, NEAR *NPCANDIDATELIST, FAR *LPCANDIDATELIST;

typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA, NEAR *NPREGISTERWORDA, FAR *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW, NEAR *NPREGISTERWORDW, FAR *LPREGISTERWORDW;
#ifdef UNICODE
typedef REGISTERWORDW REGISTERWORD;
typedef PREGISTERWORDW PREGISTERWORD;
typedef NPREGISTERWORDW NPREGISTERWORD;
typedef LPREGISTERWORDW LPREGISTERWORD;
#else
typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#endif // UNICODE

#if (WINVER >= 0x040A)

typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING, NEAR *NPRECONVERTSTRING, FAR *LPRECONVERTSTRING;

#endif /* WINVER >= 0x040A */

#define STYLE_DESCRIPTION_SIZE  32

typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFA, *PSTYLEBUFA, NEAR *NPSTYLEBUFA, FAR *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[STYLE_DESCRIPTION_SIZE];
} STYLEBUFW, *PSTYLEBUFW, NEAR *NPSTYLEBUFW, FAR *LPSTYLEBUFW;
#ifdef UNICODE
typedef STYLEBUFW STYLEBUF;
typedef PSTYLEBUFW PSTYLEBUF;
typedef NPSTYLEBUFW NPSTYLEBUF;
typedef LPSTYLEBUFW LPSTYLEBUF;
#else
typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#endif // UNICODE


#if (WINVER >= 0x040A)

#define IMEMENUITEM_STRING_SIZE 80

typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, NEAR *NPIMEMENUITEMINFOA, FAR *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[IMEMENUITEM_STRING_SIZE];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, NEAR *NPIMEMENUITEMINFOW, FAR *LPIMEMENUITEMINFOW;
#ifdef UNICODE
typedef IMEMENUITEMINFOW IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOW PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOW NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOW LPIMEMENUITEMINFO;
#else
typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#endif // UNICODE

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION, NEAR *NPIMECHARPOSITION, FAR *LPIMECHARPOSITION;

typedef BOOL    (CALLBACK* IMCENUMPROC)(HIMC, LPARAM);

#endif /* WINVER >= 0x040A */



// prototype of IMM API

HKL  WINAPI ImmInstallIMEA(__in LPCSTR lpszIMEFileName, __in LPCSTR lpszLayoutText);
HKL  WINAPI ImmInstallIMEW(__in LPCWSTR lpszIMEFileName, __in LPCWSTR lpszLayoutText);
#ifdef UNICODE
#define ImmInstallIME  ImmInstallIMEW
#else
#define ImmInstallIME  ImmInstallIMEA
#endif // !UNICODE

HWND WINAPI ImmGetDefaultIMEWnd(IN HWND);

UINT WINAPI ImmGetDescriptionA(IN HKL, __out_ecount_opt(uBufLen) LPSTR lpszDescription, IN UINT uBufLen);
UINT WINAPI ImmGetDescriptionW(IN HKL, __out_ecount_opt(uBufLen) LPWSTR lpszDescription, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetDescription  ImmGetDescriptionW
#else
#define ImmGetDescription  ImmGetDescriptionA
#endif // !UNICODE

UINT WINAPI ImmGetIMEFileNameA(IN HKL, __out_ecount_opt(uBufLen) LPSTR lpszFileName, IN UINT uBufLen);
UINT WINAPI ImmGetIMEFileNameW(IN HKL, __out_ecount_opt(uBufLen) LPWSTR lpszFileName, IN UINT uBufLen);
#ifdef UNICODE
#define ImmGetIMEFileName  ImmGetIMEFileNameW
#else
#define ImmGetIMEFileName  ImmGetIMEFileNameA
#endif // !UNICODE

DWORD WINAPI ImmGetProperty(IN HKL, IN DWORD);

BOOL WINAPI ImmIsIME(IN HKL);

BOOL WINAPI ImmSimulateHotKey(IN HWND, IN DWORD);

HIMC WINAPI ImmCreateContext(void);
BOOL WINAPI ImmDestroyContext(IN HIMC);
HIMC WINAPI ImmGetContext(IN HWND);
BOOL WINAPI ImmReleaseContext(IN HWND, IN HIMC);
HIMC WINAPI ImmAssociateContext(IN HWND, IN HIMC);
#if (WINVER >= 0x040A)
BOOL WINAPI ImmAssociateContextEx(IN HWND, IN HIMC, IN DWORD);
#endif /* WINVER >= 0x040A */

LONG  WINAPI ImmGetCompositionStringA(IN HIMC, IN DWORD, __out_bcount_opt(dwBufLen) LPVOID lpBuf, IN DWORD dwBufLen);
LONG  WINAPI ImmGetCompositionStringW(IN HIMC, IN DWORD, __out_bcount_opt(dwBufLen) LPVOID lpBuf, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCompositionString  ImmGetCompositionStringW
#else
#define ImmGetCompositionString  ImmGetCompositionStringA
#endif // !UNICODE

BOOL  WINAPI ImmSetCompositionStringA(IN HIMC, IN DWORD dwIndex, __in_bcount_opt(dwCompLen) LPVOID lpComp, IN DWORD dwCompLen, __in_bcount_opt(dwReadLen) LPVOID lpRead, IN DWORD dwReadLen);
BOOL  WINAPI ImmSetCompositionStringW(IN HIMC, IN DWORD dwIndex, __in_bcount_opt(dwCompLen) LPVOID lpComp, IN DWORD dwCompLen, __in_bcount_opt(dwReadLen) LPVOID lpRead, IN DWORD dwReadLen);
#ifdef UNICODE
#define ImmSetCompositionString  ImmSetCompositionStringW
#else
#define ImmSetCompositionString  ImmSetCompositionStringA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListCountA(IN HIMC, __out LPDWORD lpdwListCount);
DWORD WINAPI ImmGetCandidateListCountW(IN HIMC, __out LPDWORD lpdwListCount);
#ifdef UNICODE
#define ImmGetCandidateListCount  ImmGetCandidateListCountW
#else
#define ImmGetCandidateListCount  ImmGetCandidateListCountA
#endif // !UNICODE

DWORD WINAPI ImmGetCandidateListA(IN HIMC, IN DWORD deIndex, __out_bcount_opt(dwBufLen) LPCANDIDATELIST lpCandList, IN DWORD dwBufLen);
DWORD WINAPI ImmGetCandidateListW(IN HIMC, IN DWORD deIndex, __out_bcount_opt(dwBufLen) LPCANDIDATELIST lpCandList, IN DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetCandidateList  ImmGetCandidateListW
#else
#define ImmGetCandidateList  ImmGetCandidateListA
#endif // !UNICODE

DWORD WINAPI ImmGetGuideLineA(__in HIMC, __in DWORD dwIndex, __out_bcount_opt(dwBufLen) LPSTR lpBuf, __in DWORD dwBufLen);
DWORD WINAPI ImmGetGuideLineW(__in HIMC, __in DWORD dwIndex, __out_bcount_opt(dwBufLen) LPWSTR lpBuf, __in DWORD dwBufLen);
#ifdef UNICODE
#define ImmGetGuideLine  ImmGetGuideLineW
#else
#define ImmGetGuideLine  ImmGetGuideLineA
#endif // !UNICODE

BOOL WINAPI ImmGetConversionStatus(IN HIMC, __out_opt LPDWORD lpfdwConversion, __out_opt LPDWORD lpfdwSentence);
BOOL WINAPI ImmSetConversionStatus(IN HIMC, IN DWORD, IN DWORD);
BOOL WINAPI ImmGetOpenStatus(IN HIMC);
BOOL WINAPI ImmSetOpenStatus(IN HIMC, IN BOOL);

#if defined(_WINGDI_) && !defined(NOGDI)
BOOL WINAPI ImmGetCompositionFontA(IN HIMC, __out LPLOGFONTA lplf);
BOOL WINAPI ImmGetCompositionFontW(IN HIMC, __out LPLOGFONTW lplf);
#ifdef UNICODE
#define ImmGetCompositionFont  ImmGetCompositionFontW
#else
#define ImmGetCompositionFont  ImmGetCompositionFontA
#endif // !UNICODE

BOOL WINAPI ImmSetCompositionFontA(IN HIMC, __in LPLOGFONTA lplf);
BOOL WINAPI ImmSetCompositionFontW(IN HIMC, __in LPLOGFONTW lplf);
#ifdef UNICODE
#define ImmSetCompositionFont  ImmSetCompositionFontW
#else
#define ImmSetCompositionFont  ImmSetCompositionFontA
#endif // !UNICODE
#endif  // defined(_WINGDI_) && !defined(NOGDI)

BOOL    WINAPI ImmConfigureIMEA(IN HKL, IN HWND, IN DWORD, IN LPVOID);
BOOL    WINAPI ImmConfigureIMEW(IN HKL, IN HWND, IN DWORD, IN LPVOID);
#ifdef UNICODE
#define ImmConfigureIME  ImmConfigureIMEW
#else
#define ImmConfigureIME  ImmConfigureIMEA
#endif // !UNICODE

LRESULT WINAPI ImmEscapeA(IN HKL, IN HIMC, IN UINT, IN LPVOID);
LRESULT WINAPI ImmEscapeW(IN HKL, IN HIMC, IN UINT, IN LPVOID);
#ifdef UNICODE
#define ImmEscape  ImmEscapeW
#else
#define ImmEscape  ImmEscapeA
#endif // !UNICODE

DWORD   WINAPI ImmGetConversionListA(IN HKL, IN HIMC, __in LPCSTR lpSrc, __out_bcount(dwBufLen) LPCANDIDATELIST lpDst, IN DWORD dwBufLen, IN UINT uFlag);
DWORD   WINAPI ImmGetConversionListW(IN HKL, IN HIMC, __in LPCWSTR lpSrc, __out_bcount(dwBufLen) LPCANDIDATELIST lpDst, IN DWORD dwBufLen, IN UINT uFlag);
#ifdef UNICODE
#define ImmGetConversionList  ImmGetConversionListW
#else
#define ImmGetConversionList  ImmGetConversionListA
#endif // !UNICODE

BOOL    WINAPI ImmNotifyIME(IN HIMC, IN DWORD dwAction, IN DWORD dwIndex, IN DWORD dwValue);

BOOL WINAPI ImmGetStatusWindowPos(IN HIMC, __out LPPOINT lpptPos);
BOOL WINAPI ImmSetStatusWindowPos(IN HIMC, __in LPPOINT lpptPos);
BOOL WINAPI ImmGetCompositionWindow(IN HIMC, __out LPCOMPOSITIONFORM lpCompForm);
BOOL WINAPI ImmSetCompositionWindow(IN HIMC, __in LPCOMPOSITIONFORM lpCompForm);
BOOL WINAPI ImmGetCandidateWindow(IN HIMC, IN DWORD, __out LPCANDIDATEFORM lpCandidate);
BOOL WINAPI ImmSetCandidateWindow(IN HIMC, __in LPCANDIDATEFORM lpCandidate);

BOOL WINAPI ImmIsUIMessageA(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
BOOL WINAPI ImmIsUIMessageW(IN HWND, IN UINT, IN WPARAM, IN LPARAM);
#ifdef UNICODE
#define ImmIsUIMessage  ImmIsUIMessageW
#else
#define ImmIsUIMessage  ImmIsUIMessageA
#endif // !UNICODE


UINT WINAPI ImmGetVirtualKey(IN HWND);

typedef int (CALLBACK *REGISTERWORDENUMPROCA)(__in LPCSTR lpszReading, DWORD, __in LPCSTR lpszString, LPVOID);
typedef int (CALLBACK *REGISTERWORDENUMPROCW)(__in LPCWSTR lpszReading, DWORD, __in LPCWSTR lpszString, LPVOID);
#ifdef UNICODE
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCW
#else
#define REGISTERWORDENUMPROC  REGISTERWORDENUMPROCA
#endif // !UNICODE

BOOL WINAPI ImmRegisterWordA(IN HKL, __in LPCSTR lpszReading, IN DWORD, __in LPCSTR lpszRegister);
BOOL WINAPI ImmRegisterWordW(IN HKL, __in LPCWSTR lpszReading, IN DWORD, __in LPCWSTR lpszRegister);
#ifdef UNICODE
#define ImmRegisterWord  ImmRegisterWordW
#else
#define ImmRegisterWord  ImmRegisterWordA
#endif // !UNICODE

BOOL WINAPI ImmUnregisterWordA(IN HKL, __in LPCSTR lpszReading, IN DWORD, __in LPCSTR lpszUnregister);
BOOL WINAPI ImmUnregisterWordW(IN HKL, __in LPCWSTR lpszReading, IN DWORD, __in LPCWSTR lpszUnregister);
#ifdef UNICODE
#define ImmUnregisterWord  ImmUnregisterWordW
#else
#define ImmUnregisterWord  ImmUnregisterWordA
#endif // !UNICODE

UINT WINAPI ImmGetRegisterWordStyleA(IN HKL, IN UINT nItem, __out_ecount(nItem) LPSTYLEBUFA lpStyleBuf);
UINT WINAPI ImmGetRegisterWordStyleW(IN HKL, IN UINT nItem, __out_ecount(nItem) LPSTYLEBUFW lpStyleBuf);
#ifdef UNICODE
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleW
#else
#define ImmGetRegisterWordStyle  ImmGetRegisterWordStyleA
#endif // !UNICODE

UINT WINAPI ImmEnumRegisterWordA(IN HKL, IN REGISTERWORDENUMPROCA, __in_opt LPCSTR lpszReading, IN DWORD, __in_opt LPCSTR lpszRegister, IN LPVOID);
UINT WINAPI ImmEnumRegisterWordW(IN HKL, IN REGISTERWORDENUMPROCW, __in_opt LPCWSTR lpszReading, IN DWORD, __in_opt LPCWSTR lpszRegister, IN LPVOID);
#ifdef UNICODE
#define ImmEnumRegisterWord  ImmEnumRegisterWordW
#else
#define ImmEnumRegisterWord  ImmEnumRegisterWordA
#endif // !UNICODE

#if (WINVER >= 0x040A)
BOOL WINAPI ImmDisableIME(IN DWORD);
BOOL WINAPI ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD WINAPI ImmGetImeMenuItemsA(IN HIMC, IN DWORD, IN DWORD, __out_opt LPIMEMENUITEMINFOA lpImeParentMenu, __out_bcount_opt(dwSize) LPIMEMENUITEMINFOA lpImeMenu, IN DWORD dwSize);
DWORD WINAPI ImmGetImeMenuItemsW(IN HIMC, IN DWORD, IN DWORD, __out_opt LPIMEMENUITEMINFOW lpImeParentMenu, __out_bcount_opt(dwSize) LPIMEMENUITEMINFOW lpImeMenu, IN DWORD dwSize);
#ifdef UNICODE
#define ImmGetImeMenuItems  ImmGetImeMenuItemsW
#else
#define ImmGetImeMenuItems  ImmGetImeMenuItemsA
#endif // !UNICODE

BOOL WINAPI ImmDisableTextFrameService(DWORD idThread);
#endif /* WINVER >= 0x040A */

// wParam for WM_IME_CONTROL
#define IMC_GETCANDIDATEPOS             0x0007
#define IMC_SETCANDIDATEPOS             0x0008
#define IMC_GETCOMPOSITIONFONT          0x0009
#define IMC_SETCOMPOSITIONFONT          0x000A
#define IMC_GETCOMPOSITIONWINDOW        0x000B
#define IMC_SETCOMPOSITIONWINDOW        0x000C
#define IMC_GETSTATUSWINDOWPOS          0x000F
#define IMC_SETSTATUSWINDOWPOS          0x0010
#define IMC_CLOSESTATUSWINDOW           0x0021
#define IMC_OPENSTATUSWINDOW            0x0022


// dwAction for ImmNotifyIME
#define NI_OPENCANDIDATE                0x0010
#define NI_CLOSECANDIDATE               0x0011
#define NI_SELECTCANDIDATESTR           0x0012
#define NI_CHANGECANDIDATELIST          0x0013
#define NI_FINALIZECONVERSIONRESULT     0x0014
#define NI_COMPOSITIONSTR               0x0015
#define NI_SETCANDIDATE_PAGESTART       0x0016
#define NI_SETCANDIDATE_PAGESIZE        0x0017
#define NI_IMEMENUSELECTED              0x0018

// lParam for WM_IME_SETCONTEXT
#define ISC_SHOWUICANDIDATEWINDOW       0x00000001
#define ISC_SHOWUICOMPOSITIONWINDOW     0x80000000
#define ISC_SHOWUIGUIDELINE             0x40000000
#define ISC_SHOWUIALLCANDIDATEWINDOW    0x0000000F
#define ISC_SHOWUIALL                   0xC000000F


// dwIndex for ImmNotifyIME/NI_COMPOSITIONSTR
#define CPS_COMPLETE                    0x0001
#define CPS_CONVERT                     0x0002
#define CPS_REVERT                      0x0003
#define CPS_CANCEL                      0x0004

// the modifiers of hot key
#define MOD_ALT                         0x0001
#define MOD_CONTROL                     0x0002
#define MOD_SHIFT                       0x0004

#define MOD_LEFT                        0x8000
#define MOD_RIGHT                       0x4000

#define MOD_ON_KEYUP                    0x0800
#define MOD_IGNORE_ALL_MODIFIER         0x0400


// Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
#define IME_CHOTKEY_IME_NONIME_TOGGLE           0x10
#define IME_CHOTKEY_SHAPE_TOGGLE                0x11
#define IME_CHOTKEY_SYMBOL_TOGGLE               0x12

// Windows for Japanese Edition hot key ID from 0x30 - 0x4F
#define IME_JHOTKEY_CLOSE_OPEN                  0x30

// Windows for Korean Edition hot key ID from 0x50 - 0x6F
#define IME_KHOTKEY_SHAPE_TOGGLE                0x50
#define IME_KHOTKEY_HANJACONVERT                0x51
#define IME_KHOTKEY_ENGLISH                     0x52

// Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
#define IME_THOTKEY_IME_NONIME_TOGGLE           0x70
#define IME_THOTKEY_SHAPE_TOGGLE                0x71
#define IME_THOTKEY_SYMBOL_TOGGLE               0x72

// direct switch hot key ID from 0x100 - 0x11F
#define IME_HOTKEY_DSWITCH_FIRST                0x100
#define IME_HOTKEY_DSWITCH_LAST                 0x11F

// IME private hot key from 0x200 - 0x21F
#define IME_HOTKEY_PRIVATE_FIRST                0x200
#define IME_ITHOTKEY_RESEND_RESULTSTR           0x200
#define IME_ITHOTKEY_PREVIOUS_COMPOSITION       0x201
#define IME_ITHOTKEY_UISTYLE_TOGGLE             0x202
#define IME_ITHOTKEY_RECONVERTSTRING            0x203
#define IME_HOTKEY_PRIVATE_LAST                 0x21F


// parameter of ImmGetCompositionString
#define GCS_COMPREADSTR                 0x0001
#define GCS_COMPREADATTR                0x0002
#define GCS_COMPREADCLAUSE              0x0004
#define GCS_COMPSTR                     0x0008
#define GCS_COMPATTR                    0x0010
#define GCS_COMPCLAUSE                  0x0020
#define GCS_CURSORPOS                   0x0080
#define GCS_DELTASTART                  0x0100
#define GCS_RESULTREADSTR               0x0200
#define GCS_RESULTREADCLAUSE            0x0400
#define GCS_RESULTSTR                   0x0800
#define GCS_RESULTCLAUSE                0x1000

// style bit flags for WM_IME_COMPOSITION
#define CS_INSERTCHAR                   0x2000
#define CS_NOMOVECARET                  0x4000

// IME version constants
#define IMEVER_0310                     0x0003000A
#define IMEVER_0400                     0x00040000


// IME property bits
#define IME_PROP_AT_CARET               0x00010000
#define IME_PROP_SPECIAL_UI             0x00020000
#define IME_PROP_CANDLIST_START_FROM_1  0x00040000
#define IME_PROP_UNICODE                0x00080000
#define IME_PROP_COMPLETE_ON_UNSELECT   0x00100000


// IME UICapability bits
#define UI_CAP_2700                     0x00000001
#define UI_CAP_ROT90                    0x00000002
#define UI_CAP_ROTANY                   0x00000004

// ImmSetCompositionString Capability bits
#define SCS_CAP_COMPSTR                 0x00000001
#define SCS_CAP_MAKEREAD                0x00000002
#define SCS_CAP_SETRECONVERTSTRING      0x00000004


// IME WM_IME_SELECT inheritance Capability bits
#define SELECT_CAP_CONVERSION           0x00000001
#define SELECT_CAP_SENTENCE             0x00000002


// ID for deIndex of ImmGetGuideLine
#define GGL_LEVEL                       0x00000001
#define GGL_INDEX                       0x00000002
#define GGL_STRING                      0x00000003
#define GGL_PRIVATE                     0x00000004


// ID for dwLevel of GUIDELINE Structure
#define GL_LEVEL_NOGUIDELINE            0x00000000
#define GL_LEVEL_FATAL                  0x00000001
#define GL_LEVEL_ERROR                  0x00000002
#define GL_LEVEL_WARNING                0x00000003
#define GL_LEVEL_INFORMATION            0x00000004


// ID for dwIndex of GUIDELINE Structure
#define GL_ID_UNKNOWN                   0x00000000
#define GL_ID_NOMODULE                  0x00000001
#define GL_ID_NODICTIONARY              0x00000010
#define GL_ID_CANNOTSAVE                0x00000011
#define GL_ID_NOCONVERT                 0x00000020
#define GL_ID_TYPINGERROR               0x00000021
#define GL_ID_TOOMANYSTROKE             0x00000022
#define GL_ID_READINGCONFLICT           0x00000023
#define GL_ID_INPUTREADING              0x00000024
#define GL_ID_INPUTRADICAL              0x00000025
#define GL_ID_INPUTCODE                 0x00000026
#define GL_ID_INPUTSYMBOL               0x00000027
#define GL_ID_CHOOSECANDIDATE           0x00000028
#define GL_ID_REVERSECONVERSION         0x00000029
#define GL_ID_PRIVATE_FIRST             0x00008000
#define GL_ID_PRIVATE_LAST              0x0000FFFF


// ID for dwIndex of ImmGetProperty
#define IGP_GETIMEVERSION               (DWORD)(-4)
#define IGP_PROPERTY                    0x00000004
#define IGP_CONVERSION                  0x00000008
#define IGP_SENTENCE                    0x0000000c
#define IGP_UI                          0x00000010
#define IGP_SETCOMPSTR                  0x00000014
#define IGP_SELECT                      0x00000018

// dwIndex for ImmSetCompositionString API
#define SCS_SETSTR                      (GCS_COMPREADSTR|GCS_COMPSTR)
#define SCS_CHANGEATTR                  (GCS_COMPREADATTR|GCS_COMPATTR)
#define SCS_CHANGECLAUSE                (GCS_COMPREADCLAUSE|GCS_COMPCLAUSE)
#define SCS_SETRECONVERTSTRING          0x00010000
#define SCS_QUERYRECONVERTSTRING        0x00020000

// attribute for COMPOSITIONSTRING Structure
#define ATTR_INPUT                      0x00
#define ATTR_TARGET_CONVERTED           0x01
#define ATTR_CONVERTED                  0x02
#define ATTR_TARGET_NOTCONVERTED        0x03
#define ATTR_INPUT_ERROR                0x04
#define ATTR_FIXEDCONVERTED             0x05

// bit field for IMC_SETCOMPOSITIONWINDOW, IMC_SETCANDIDATEWINDOW
#define CFS_DEFAULT                     0x0000
#define CFS_RECT                        0x0001
#define CFS_POINT                       0x0002
#define CFS_FORCE_POSITION              0x0020
#define CFS_CANDIDATEPOS                0x0040
#define CFS_EXCLUDE                     0x0080

// conversion direction for ImmGetConversionList
#define GCL_CONVERSION                  0x0001
#define GCL_REVERSECONVERSION           0x0002
#define GCL_REVERSE_LENGTH              0x0003


#include <ime_cmodes.h>

// bit field for conversion mode
// IME_CMODE_HANGEUL is old name of IME_CMODE_HANGUL. It will be gone eventually.
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_CMODE_SOFTKBD               0x0080
#define IME_CMODE_NOCONVERSION          0x0100
#define IME_CMODE_EUDC                  0x0200
#define IME_CMODE_SYMBOL                0x0400
#define IME_CMODE_FIXED                 0x0800
#define IME_CMODE_RESERVED          0xF0000000

// bit field for sentence mode
#define IME_SMODE_NONE                  0x0000
#define IME_SMODE_PLAURALCLAUSE         0x0001
#define IME_SMODE_SINGLECONVERT         0x0002
#define IME_SMODE_AUTOMATIC             0x0004
#define IME_SMODE_PHRASEPREDICT         0x0008
#define IME_SMODE_CONVERSATION          0x0010
#define IME_SMODE_RESERVED          0x0000F000


// style of candidate
#define IME_CAND_UNKNOWN                0x0000
#define IME_CAND_READ                   0x0001
#define IME_CAND_CODE                   0x0002
#define IME_CAND_MEANING                0x0003
#define IME_CAND_RADICAL                0x0004
#define IME_CAND_STROKE                 0x0005

// wParam of report message WM_IME_NOTIFY
#define IMN_CLOSESTATUSWINDOW           0x0001
#define IMN_OPENSTATUSWINDOW            0x0002
#define IMN_CHANGECANDIDATE             0x0003
#define IMN_CLOSECANDIDATE              0x0004
#define IMN_OPENCANDIDATE               0x0005
#define IMN_SETCONVERSIONMODE           0x0006
#define IMN_SETSENTENCEMODE             0x0007
#define IMN_SETOPENSTATUS               0x0008
#define IMN_SETCANDIDATEPOS             0x0009
#define IMN_SETCOMPOSITIONFONT          0x000A
#define IMN_SETCOMPOSITIONWINDOW        0x000B
#define IMN_SETSTATUSWINDOWPOS          0x000C
#define IMN_GUIDELINE                   0x000D
#define IMN_PRIVATE                     0x000E

#if (WINVER >= 0x040A)
// wParam of report message WM_IME_REQUEST
#define IMR_COMPOSITIONWINDOW           0x0001
#define IMR_CANDIDATEWINDOW             0x0002
#define IMR_COMPOSITIONFONT             0x0003
#define IMR_RECONVERTSTRING             0x0004
#define IMR_CONFIRMRECONVERTSTRING      0x0005
#define IMR_QUERYCHARPOSITION           0x0006
#define IMR_DOCUMENTFEED                0x0007
#endif /* WINVER >= 0x040A */

// error code of ImmGetCompositionString
#define IMM_ERROR_NODATA                (-1)
#define IMM_ERROR_GENERAL               (-2)


// dialog mode of ImmConfigureIME
#define IME_CONFIG_GENERAL              1
#define IME_CONFIG_REGISTERWORD         2
#define IME_CONFIG_SELECTDICTIONARY     3


// flags for ImmEscape
#define IME_ESC_QUERY_SUPPORT           0x0003
#define IME_ESC_RESERVED_FIRST          0x0004
#define IME_ESC_RESERVED_LAST           0x07FF
#define IME_ESC_PRIVATE_FIRST           0x0800
#define IME_ESC_PRIVATE_LAST            0x0FFF

#define IME_ESC_SEQUENCE_TO_INTERNAL    0x1001
#define IME_ESC_GET_EUDC_DICTIONARY     0x1003
#define IME_ESC_SET_EUDC_DICTIONARY     0x1004
#define IME_ESC_MAX_KEY                 0x1005
#define IME_ESC_IME_NAME                0x1006
#define IME_ESC_SYNC_HOTKEY             0x1007
#define IME_ESC_HANJA_MODE              0x1008
#define IME_ESC_AUTOMATA                0x1009
#define IME_ESC_PRIVATE_HOTKEY          0x100a
#define IME_ESC_GETHELPFILENAME         0x100b

// style of word registration
#define IME_REGWORD_STYLE_EUDC          0x00000001
#define IME_REGWORD_STYLE_USER_FIRST    0x80000000
#define IME_REGWORD_STYLE_USER_LAST     0xFFFFFFFF


#if (WINVER >= 0x040A)

// dwFlags for ImmAssociateContextEx
#define IACE_CHILDREN                   0x0001
#define IACE_DEFAULT                    0x0010
#define IACE_IGNORENOCONTEXT            0x0020

// dwFlags for ImmGetImeMenuItems
#define IGIMIF_RIGHTMENU                0x0001

// dwType for ImmGetImeMenuItems
#define IGIMII_CMODE                    0x0001
#define IGIMII_SMODE                    0x0002
#define IGIMII_CONFIGURE                0x0004
#define IGIMII_TOOLS                    0x0008
#define IGIMII_HELP                     0x0010
#define IGIMII_OTHER                    0x0020
#define IGIMII_INPUTTOOLS               0x0040

// fType of IMEMENUITEMINFO structure
#define IMFT_RADIOCHECK 0x00001
#define IMFT_SEPARATOR  0x00002
#define IMFT_SUBMENU    0x00004

// fState of IMEMENUITEMINFO structure
#define IMFS_GRAYED          MFS_GRAYED
#define IMFS_DISABLED        MFS_DISABLED
#define IMFS_CHECKED         MFS_CHECKED
#define IMFS_HILITE          MFS_HILITE
#define IMFS_ENABLED         MFS_ENABLED
#define IMFS_UNCHECKED       MFS_UNCHECKED
#define IMFS_UNHILITE        MFS_UNHILITE
#define IMFS_DEFAULT         MFS_DEFAULT

#endif /* WINVER >= 0x040A */

// type of soft keyboard
// for Windows Tranditional Chinese Edition
#define SOFTKEYBOARD_TYPE_T1            0x0001
// for Windows Simplified Chinese Edition
#define SOFTKEYBOARD_TYPE_C1            0x0002


#endif  // _IMM_SDK_DEFINED_

#ifdef __cplusplus
}
#endif

#endif  // _IMM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\InetSDK.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for inetsdk.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __inetsdk_h__
#define __inetsdk_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "comcat.h"
#include "ocidl.h"
#include "docobj.h"
#include "hlink.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_inetsdk_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// INetSDK.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// ActiveX SDK Merged IDL.



extern RPC_IF_HANDLE __MIDL_itf_inetsdk_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_inetsdk_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\infocard.h ===
//-----------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation.  All rights reserved.
//-----------------------------------------------------------------------------
#pragma once

#include <assert.h>
#include <stdlib.h>
#include <windows.h>
#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

#define CARDSPACECALL __stdcall

typedef enum _HandleType
{
    Asymmetric = 1,
    Symmetric  = 2,
    Transform  = 3,
    Hash       = 4
} HandleType;


// This enum represents the padding method to use for filling out short blocks.
// "None" means no padding (whole blocks required).
// "PKCS7" is the padding mode defined in RFC 2898, Section 6.1.1, Step 4, generalized
// to whatever block size is required.
// "Zeros" means pad with zero bytes to fill out the last block.
// "ISO 10126" is the same as PKCS5 except that it fills the bytes before the last one with
// random bytes. "ANSI X.923" fills the bytes with zeros and puts the number of padding
// bytes in the last byte.

typedef enum _PaddingMode
{
    None     = 1,
    PKCS7    = 2,
    Zeros    = 3,
    ANSIX923 = 4,
    ISO10126 = 5
} PaddingMode;

typedef enum _Direction
{
    DirectionEncrypt = 1,
    DirectionDecrypt = 2
} Direction;

//
// Parameter structs.
//
typedef struct _INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS
{
    int    keySize;
    LPWSTR keyExchangeAlgorithm;
    LPWSTR signatureAlgorithm;
} INFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS, *PINFORMATIONCARD_ASYMMETRIC_CRYPTO_PARAMETERS;

typedef struct _INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS
{
    int    keySize;
    int    blockSize;
    int    feedbackSize;
} INFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS, *PINFORMATIONCARD_SYMMETRIC_CRYPTO_PARAMETERS;

typedef struct _INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS
{
    int  inputBlockSize;
    int  outputBlockSize;
    BOOL canTransformMultipleBlocks;
    BOOL canReuseTransform;
} INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS, *PINFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS;

typedef struct _INFORMATIONCARD_HASH_CRYPTO_PARAMETERS
{
    int hashSize;
    INFORMATIONCARD_TRANSFORM_CRYPTO_PARAMETERS transform;
} INFORMATIONCARD_HASH_CRYPTO_PARAMETERS, *PINFORMATIONCARD_HASH_CRYPTO_PARAMETERS;


typedef struct _INFORMATIONCARD_CRYPTO_HANDLE
{
    HandleType type;
    LONGLONG   expiration;
    //
    // points to the appropriate parameter struct above depending on the type.
    //
    PVOID      cryptoParameters;
} INFORMATIONCARD_CRYPTO_HANDLE, *PINFORMATIONCARD_CRYPTO_HANDLE;

//
// Infomation associated with a request for a security token
//
#pragma pack(1)
typedef struct _GENERIC_XML_TOKEN
{

    FILETIME createDate;
    FILETIME expiryDate;
    LPWSTR xmlToken;
    LPWSTR internalTokenReference;
    LPWSTR externalTokenReference;


} GENERIC_XML_TOKEN,*PGENERIC_XML_TOKEN;

#pragma pack()

typedef struct _POLICY_ELEMENT
{
    LPCWSTR     targetEndpointAddress;
    LPCWSTR     issuerEndpointAddress;
    LPCWSTR     issuedTokenParameters;
    LPCWSTR     privacyNoticeLink;
    DWORD       privacyNoticeVersion;
    BOOL        useManagedPresentation;
} POLICY_ELEMENT, *PPOLICY_ELEMENT;

typedef struct _ENDPOINTADDRESS
{
    LPCWSTR     serviceUrl;
    LPCWSTR     policyUrl;
    DATA_BLOB    rawCertificate;
}ENDPOINTADDRESS, *PENDPOINTADDRESS;

typedef struct _ENDPOINTADDRESS2
{
    LPCWSTR     serviceUrl;
    LPCWSTR     policyUrl;
    DWORD       identityType;
    PVOID       identityBytes;
}ENDPOINTADDRESS2, *PENDPOINTADDRESS2;

typedef struct _CERTIFICATE_CHAIN_BLOB
{
    DWORD        certCount;  
    DATA_BLOB*   rawCertificates;
}CERTIFICATE_CHAIN_BLOB, *PCERTIFICATE_CHAIN_BLOB;

typedef struct _CLAIMLIST
{
    DWORD       count;
    LPCWSTR*    claims;
}CLAIMLIST, *PCLAIMLIST;

typedef struct _RECIPIENTPOLICY
{
    ENDPOINTADDRESS recipient;
    ENDPOINTADDRESS issuer;
    LPCWSTR         tokenType;
    CLAIMLIST       requiredClaims;
    CLAIMLIST       optionalClaims;
    LPCWSTR         privacyUrl;
    UINT            privacyVersion;
}RECIPIENTPOLICY, *PRECIPIENTPOLICY;

typedef struct _RECIPIENTPOLICY2
{
    ENDPOINTADDRESS2 recipient;
    ENDPOINTADDRESS2 issuer;
    LPCWSTR         tokenType;
    CLAIMLIST       requiredClaims;
    CLAIMLIST       optionalClaims;
    LPCWSTR         privacyUrl;
    UINT            privacyVersion;
}RECIPIENTPOLICY2, *PRECIPIENTPOLICY2;

#define RECIPIENTPOLICYV1 1
#define RECIPIENTPOLICYV2 2

HRESULT
CARDSPACECALL GetToken(
        __in        DWORD                    cPolicyChain,
        __in_ecount( cPolicyChain ) PPOLICY_ELEMENT pPolicyChain,
        __deref_out PGENERIC_XML_TOKEN*      securityToken,
        __deref_out PINFORMATIONCARD_CRYPTO_HANDLE* phProofTokenCrypto );

HRESULT
CARDSPACECALL
ManageCardSpace();

HRESULT
CARDSPACECALL
ImportInformationCard(  __in LPCWSTR fileName );

HRESULT
CARDSPACECALL Encrypt(
                      __in PINFORMATIONCARD_CRYPTO_HANDLE hCrypto,
                      __in BOOL fOAEP,
                      __in DWORD cbInData,
                      __in_bcount( cbInData ) PBYTE pInData,
                      __out DWORD *pcbOutData,
                      __out_bcount( *pcbOutData ) PBYTE* ppOutData );

HRESULT
CARDSPACECALL Decrypt(
                      __in PINFORMATIONCARD_CRYPTO_HANDLE hCrypto,
                      __in BOOL                         fOAEP,
                      __in DWORD                        cbInData,
                      __in_bcount( cbInData )PBYTE      pInData,
                      __out DWORD*                 pcbOutData,
                      __out_bcount( *pcbOutData ) PBYTE* ppOutData );

HRESULT
CARDSPACECALL SignHash(
                       __in PINFORMATIONCARD_CRYPTO_HANDLE  hCrypto,
                       __in DWORD                    cbHash,
                       __in_bcount( cbHash ) PBYTE   pHash,
                       __in LPCWSTR                  hashAlgOid,
                       __out DWORD*                  pcbSig,
                       __out_bcount( *pcbSig ) PBYTE* ppSig );

HRESULT
CARDSPACECALL VerifyHash(
                         __in PINFORMATIONCARD_CRYPTO_HANDLE hCrypto,
                         __in DWORD                cbHash,
                         __in_bcount( cbHash ) BYTE*  pHash,
                         __in LPCWSTR                 hashAlgOid,
                         __in DWORD                   cbSig,
                         __in_bcount( cbSig ) BYTE*   pSig,
                         __out BOOL*                  pfVerified );

HRESULT
CARDSPACECALL GetCryptoTransform(
                         __in PINFORMATIONCARD_CRYPTO_HANDLE hSymmetricCrypto,
                         __in DWORD                   mode,
                         __in PaddingMode             padding,
                         __in DWORD                   feedbackSize,
                         __in Direction               direction,
                         __in DWORD                   cbIV,
                         __in_bcount( cbIV ) BYTE*    pIV,
                         __deref_out PINFORMATIONCARD_CRYPTO_HANDLE* pphTransform );

HRESULT
CARDSPACECALL GetKeyedHash(
                         __in PINFORMATIONCARD_CRYPTO_HANDLE hSymmetricCrypto,
                         __deref_out PINFORMATIONCARD_CRYPTO_HANDLE* pphHash );

HRESULT
CARDSPACECALL TransformBlock(
                       __in PINFORMATIONCARD_CRYPTO_HANDLE  hCrypto,
                       __in DWORD                    cbInData,
                       __in_bcount( cbInData ) PBYTE   pInData,
                       __out DWORD*                  pcbOutData,
                       __out_bcount( *pcbOutData ) PBYTE* ppOutData );

HRESULT
CARDSPACECALL TransformFinalBlock(
                       __in PINFORMATIONCARD_CRYPTO_HANDLE  hCrypto,
                       __in DWORD                    cbInData,
                       __in_bcount( cbInData ) PBYTE   pInData,
                       __out DWORD*                  pcbOutData,
                       __out_bcount( *pcbOutData ) PBYTE* ppOutData );

HRESULT
CARDSPACECALL HashCore(
                       __in PINFORMATIONCARD_CRYPTO_HANDLE  hCrypto,
                       __in DWORD                    cbInData,
                       __in_bcount( cbInData ) PBYTE   pInData );

HRESULT
CARDSPACECALL HashFinal(
                       __in PINFORMATIONCARD_CRYPTO_HANDLE  hCrypto,
                       __in DWORD                    cbInData,
                       __in_bcount( cbInData ) PBYTE   pInData,
                       __out DWORD*                  pcbOutData,
                       __out_bcount( *pcbOutData ) PBYTE* ppOutData );

BOOL
CARDSPACECALL FreeToken( __in PGENERIC_XML_TOKEN pAllocMemory );

HRESULT
CARDSPACECALL CloseCryptoHandle( __in PINFORMATIONCARD_CRYPTO_HANDLE hCrypto );

HRESULT
CARDSPACECALL GenerateDerivedKey(
                       __in PINFORMATIONCARD_CRYPTO_HANDLE  hCrypto,
                       __in DWORD                    cbLabel,
                       __in_bcount( cbLabel ) PBYTE  pLabel,
                       __in DWORD                    cbNonce,
                       __in_bcount( cbNonce ) PBYTE  pNonce,
                       __in DWORD                    derivedKeyLength,
                       __in DWORD                    offset,
                       __in LPCWSTR                  algId,
                       __out DWORD*                  pcbKey,
                       __out_bcount( *pcbKey ) PBYTE* ppKey );

HRESULT
CARDSPACECALL GetBrowserToken(
                    __in    DWORD   dwParamType,
                    __in    PVOID   pParam,
                    __out_opt    DWORD*  pcbToken,
                    __out_bcount_opt(*pcbToken)    PBYTE*  ppToken );

#ifdef __cplusplus
}
#endif


#ifndef E_ICARD_COMMUNICATION
#define E_ICARD_COMMUNICATION            ((HRESULT)0xC0050100L)
#endif


#ifndef E_ICARD_DATA_ACCESS
#define E_ICARD_DATA_ACCESS              ((HRESULT)0xC0050101L)
#endif


#ifndef E_ICARD_EXPORT
#define E_ICARD_EXPORT                   ((HRESULT)0xC0050102L)
#endif


#ifndef E_ICARD_IDENTITY
#define E_ICARD_IDENTITY                 ((HRESULT)0xC0050103L)
#endif


#ifndef E_ICARD_IMPORT
#define E_ICARD_IMPORT                   ((HRESULT)0xC0050104L)
#endif


#ifndef E_ICARD_ARGUMENT
#define E_ICARD_ARGUMENT                 ((HRESULT)0xC0050105L)
#endif


#ifndef E_ICARD_REQUEST
#define E_ICARD_REQUEST                  ((HRESULT)0xC0050106L)
#endif


#ifndef E_ICARD_INFORMATIONCARD
#define E_ICARD_INFORMATIONCARD          ((HRESULT)0xC0050107L)
#endif


#ifndef E_ICARD_STOREKEY
#define E_ICARD_STOREKEY                 ((HRESULT)0xC0050108L)
#endif


#ifndef E_ICARD_LOGOVALIDATION
#define E_ICARD_LOGOVALIDATION           ((HRESULT)0xC0050109L)
#endif


#ifndef E_ICARD_PASSWORDVALIDATION
#define E_ICARD_PASSWORDVALIDATION       ((HRESULT)0xC005010AL)
#endif


#ifndef E_ICARD_POLICY
#define E_ICARD_POLICY                   ((HRESULT)0xC005010BL)
#endif


#ifndef E_ICARD_PROCESSDIED
#define E_ICARD_PROCESSDIED              ((HRESULT)0xC005010CL)
#endif


#ifndef E_ICARD_SERVICEBUSY
#define E_ICARD_SERVICEBUSY              ((HRESULT)0xC005010DL)
#endif


#ifndef E_ICARD_SERVICE
#define E_ICARD_SERVICE                  ((HRESULT)0xC005010EL)
#endif


#ifndef E_ICARD_SHUTTINGDOWN
#define E_ICARD_SHUTTINGDOWN             ((HRESULT)0xC005010FL)
#endif


#ifndef E_ICARD_TOKENCREATION
#define E_ICARD_TOKENCREATION            ((HRESULT)0xC0050110L)
#endif


#ifndef E_ICARD_TRUSTEXCHANGE
#define E_ICARD_TRUSTEXCHANGE            ((HRESULT)0xC0050111L)
#endif


#ifndef E_ICARD_UNTRUSTED
#define E_ICARD_UNTRUSTED                ((HRESULT)0xC0050112L)
#endif


#ifndef E_ICARD_USERCANCELLED
#define E_ICARD_USERCANCELLED            ((HRESULT)0xC0050113L)
#endif


#ifndef E_ICARD_STORE_IMPORT
#define E_ICARD_STORE_IMPORT             ((HRESULT)0xC0050114L)
#endif


#ifndef E_ICARD_FAIL
#define E_ICARD_FAIL                     ((HRESULT)0xC0050115L)
#endif


#ifndef E_ICARD_UI_INITIALIZATION
#define E_ICARD_UI_INITIALIZATION        ((HRESULT)0xC005011AL)
#endif

#ifndef E_ICARD_REFRESH_REQUIRED
#define E_ICARD_REFRESH_REQUIRED         ((HRESULT)0xC0050180L)
#endif


#ifndef E_ICARD_MISSING_APPLIESTO
#define E_ICARD_MISSING_APPLIESTO        ((HRESULT)0xC0050181L)
#endif


#ifndef E_ICARD_INVALID_PROOF_KEY
#define E_ICARD_INVALID_PROOF_KEY        ((HRESULT)0xC0050182L)
#endif


#ifndef E_ICARD_UNKNOWN_REFERENCE
#define E_ICARD_UNKNOWN_REFERENCE        ((HRESULT)0xC0050183L)
#endif


#ifndef E_ICARD_FAILED_REQUIRED_CLAIMS
#define E_ICARD_FAILED_REQUIRED_CLAIMS   ((HRESULT)0xC0050184L)
#endif


#ifndef AUDIT_CARD_WRITTEN
#define AUDIT_CARD_WRITTEN               ((HRESULT)0x40050200L)
#endif


#ifndef AUDIT_CARD_DELETE
#define AUDIT_CARD_DELETE                ((HRESULT)0x40050201L)
#endif


#ifndef AUDIT_CARD_IMPORT
#define AUDIT_CARD_IMPORT                ((HRESULT)0x40050202L)
#endif


#ifndef AUDIT_STORE_IMPORT
#define AUDIT_STORE_IMPORT               ((HRESULT)0x40050203L)
#endif


#ifndef AUDIT_STORE_EXPORT
#define AUDIT_STORE_EXPORT               ((HRESULT)0x40050204L)
#endif


#ifndef AUDIT_STORE_DELETE
#define AUDIT_STORE_DELETE               ((HRESULT)0x40050205L)
#endif

#ifndef AUDIT_SERVICE_IDLE_STOP
#define AUDIT_SERVICE_IDLE_STOP          ((HRESULT)0x40050206L)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\InetReg.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1998               **
//*********************************************************************

//
//      INETREG.H - String literals for HKEYs in registry
//

#ifndef _INETREGSTRS_H_
#define _INETREGSTRS_H_


//
// HKEY: HKEY_CURRENT_USER
//

//
// Top level defines
//
#define TSZMICROSOFTPATH                  TEXT("Software\\Microsoft")
#define TSZIEPATH        TSZMICROSOFTPATH TEXT("\\Internet Explorer")
#define TSZWINCURVERPATH TSZMICROSOFTPATH TEXT("\\windows\\CurrentVersion")
#define TSZWININETPATH   TSZWINCURVERPATH TEXT("\\Internet Settings")

// Windows : HKLM
#define REGSTR_PATH_RUNONCE_KEY TSZWINCURVERPATH TEXT("\\RunOnce")

// INETCPL : HKLM
#define REGSTR_PATH_INETCPL_PS_EXTENTIONS TSZWINCURVERPATH TEXT("\\Controls Folder\\Internet")

//
// Explorer : HKCU
//
#define REGSTR_PATH_IEXPLORER           TSZIEPATH

// Main
#define SZ_IE_MAIN                      "Main"
#define REGSTR_PATH_MAIN                TSZIEPATH TEXT( "\\") TEXT(SZ_IE_MAIN)
#define REGSTR_KEY_MAIN                 TEXT(SZ_IE_MAIN)

#define REGSTR_VAL_SMOOTHSCROLL         TEXT("SmoothScroll")
#define REGSTR_VAL_SMOOTHSCROLL_DEF     TRUE

#define REGSTR_VAL_SHOWTOOLBAR          TEXT("Show_ToolBar")
#define REGSTR_VAL_SHOWADDRESSBAR       TEXT("Show_URLToolBar")
#define REGSTR_VAL_STARTPAGE            TEXT("Start Page")
#define REGSTRA_VAL_STARTPAGE           "Start Page"
#define REGSTR_VAL_SEARCHPAGE           TEXT("Search Page")
#define REGSTR_VAL_LOCALPAGE            TEXT("Local Page")

#define REGSTR_VAL_USESTYLESHEETS       TEXT("Use Stylesheets")
#define REGSTR_VAL_USESTYLESHEETS_TYPE  REG_SZ  // "yes" or "no"
#define REGSTR_VAL_USESTYLESHEETS_DEF   TEXT("yes")

#define REGSTR_VAL_USEICM               TEXT("UseICM")
#define REGSTR_VAL_USEICM_DEF           FALSE

#define REGSTR_VAL_SHOWFOCUS            TEXT("Tabstop - MouseDown")
#define REGSTR_VAL_SHOWFOCUS_TYPE       REG_SZ  // "yes" or "no"
#define REGSTR_VAL_SHOWFOCUS_DEF        TEXT("no")

#define REGSTR_VAL_LOADIMAGES           TEXT("Display Inline Images")
#define REGSTR_VAL_PLAYSOUNDS           TEXT("Play_Background_Sounds")
#define REGSTR_VAL_PLAYVIDEOS           TEXT("Display Inline Videos")
#define REGSTR_VAL_ANCHORUNDERLINE      TEXT("Anchor Underline")
#define REGSTR_VAL_USEDLGCOLORS         TEXT("Use_DlgBox_Colors")
#define REGSTR_VAL_CHECKASSOC           TEXT("Check_Associations")
#define REGSTR_VAL_SHOWFULLURLS         TEXT("Show_FullURL")
#define REGSTR_VAL_AUTOSEARCH           TEXT("Do404Search")
#define REGSTR_VAL_AUTONAVIGATE         TEXT("SearchForExtensions")
#define REGSTR_VAL_HTTP_ERRORS          TEXT("Friendly http errors")

#define REGSTR_VAL_PAGETRANSITIONS      TEXT("Page_Transitions")
#define REGSTR_VAL_PAGETRANSITIONS_DEF  TRUE

#define REGSTR_VAL_USEIBAR              TEXT("UseBar")

// Settings
#define SZ_IE_SETTINGS  "Settings"
#define REGSTR_PATH_IE_SETTINGS         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SETTINGS)
#define REGSTR_KEY_IE_SETTINGS          TEXT(SZ_IE_SETTINGS)

#define REGSTR_VAL_IE_CUSTOMCOLORS      TEXT("Custom Colors")
#define REGSTR_VAL_IE_CUSTOMCOLORS_TYPE REG_BINARY

#define REGSTR_VAL_ANCHORCOLOR          TEXT("Anchor Color")
#define REGSTR_VAL_ANCHORCOLORVISITED   TEXT("Anchor Color Visited")
#define REGSTR_VAL_BACKGROUNDCOLOR      TEXT("Background Color")
#define REGSTR_VAL_TEXTCOLOR            TEXT("Text Color")
#define REGSTR_VAL_ANCHORCOLORHOVER     TEXT("Anchor Color Hover")
#define REGSTR_VAL_USEHOVERCOLOR        TEXT("Use Anchor Hover Color")

// Security
#define SZ_IE_SECURITY  "Security"
#define REGSTR_PATH_IE_SECURITY         TSZIEPATH TEXT("\\") TEXT(SZ_IE_SECURITY)
#define REGSTR_KEY_IE_SECURITY          TEXT(SZ_IE_SECURITY)

#define REGSTR_VAL_SAFETYWARNINGLEVEL   TEXT("Safety Warning Level")

// HTML Editing
#define SZ_IE_DEFAULT_HTML_EDITOR       "Default HTML Editor"
#define REGSTR_PATH_DEFAULT_HTML_EDITOR TSZIEPATH TEXT("\\") TEXT(SZ_IE_DEFAULT_HTML_EDITOR)
#define REGSTR_KEY_DEFAULT_HTML_EDITOR  TEXT(SZ_IE_DEFAULT_HTML_EDITOR)

// Autocomplete
#define REGSTR_PATH_AUTOCOMPLETE        TSZWINCURVERPATH TEXT("\\Explorer\\AutoComplete")
#define REGSTR_VAL_USEAUTOAPPEND        TEXT("Append Completion")
#define REGSTR_VAL_USEAUTOSUGGEST       TEXT("AutoSuggest")

// Old IE4 autocomplete key
#define REGSTR_VAL_USEAUTOCOMPLETE      TEXT("Use AutoComplete")

// iBar
#define SZ_IE_IBAR                      "Bar"
#define TSZIBARPATH                     TSZIEPATH TEXT( "\\") TEXT(SZ_IE_IBAR)
#define REGSTR_PATH_IBAR                TSZIBARPATH
#define REGSTR_KEY_IBAR                 TEXT(SZ_IE_IBAR)

#define SZ_IE_IBAR_BANDS                "Bands"
#define REGSTR_PATH_IBAR_BANDS          TSZIBARPATH TEXT("\\") TEXT(SZ_IE_IBAR_BANDS)
#define REGSTR_KEY_IBAR_BANDS           TEXT(SZ_IE_IBAR_BANDS)


//
// Internet : HKCU
//
// path to global internet settings (also under HKEY_CURRENT_USER)
#define REGSTR_PATH_INTERNETSETTINGS    TSZWININETPATH
#define REGSTR_PATH_INTERNET_SETTINGS   REGSTR_PATH_INTERNETSETTINGS

#define REGSTR_VAL_USERAGENT            TEXT("User Agent")

// path to lan-specific settings
#define REGSTR_PATH_INTERNET_LAN_SETTINGS REGSTR_PATH_INTERNETSETTINGS TEXT("\\LAN")

// string value under HKCU\REGSTR_PATH_REMOTEACCESS that contains name of
// connectoid used to connect to internet
#define REGSTR_VAL_INTERNETENTRY        TEXT("InternetProfile")
#define REGSTR_VAL_INTERNETPROFILE      REGSTR_VAL_INTERNETENTRY

#define REGSTR_VAL_INTERNETENTRYBKUP    TEXT("BackupInternetProfile")

#define REGSTR_VAL_CODEDOWNLOAD         TEXT("Code Download")
#define REGSTR_VAL_CODEDOWNLOAD_DEF     TEXT("yes")
#define REGSTR_VAL_CODEDOWNLOAD_TYPE    REG_SZ // "yes" or "no"

// policy key for inetcpl restrictions

#define REGSTR_PATH_INETCPL_RESTRICTIONS  TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")

// reg valuenames to restrict whether a tab should be shown or not;
// a value of non-zero means don't show that tab.
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_GENERALTAB     TEXT("GeneralTab")
#define REGSTR_VAL_INETCPL_SECURITYTAB    TEXT("SecurityTab")
#define REGSTR_VAL_INETCPL_CONTENTTAB     TEXT("ContentTab")
#define REGSTR_VAL_INETCPL_CONNECTIONSTAB TEXT("ConnectionsTab")
#define REGSTR_VAL_INETCPL_PROGRAMSTAB    TEXT("ProgramsTab")
#define REGSTR_VAL_INETCPL_ADVANCEDTAB    TEXT("AdvancedTab")
#define REGSTR_VAL_INETCPL_PRIVACYTAB     TEXT("PrivacyTab")

// setting to indicate whether or not IEAK launched this instance of inetcpl so extra
// info can be exposed
// reg key: HKCU\Software\Policies\Microsoft\Internet Explorer\Control Panel
#define REGSTR_VAL_INETCPL_IEAK           TEXT("IEAKContext")

//
//  Cache
//
#define REGSTR_PATH_CACHE  \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Cache")

#define REGSTR_PATH_CACHE_PATHS \
    REGSTR_PATH_CACHE TEXT("\\Paths")

#define REGSTR_PATH_EXTENSIBLE_CACHE \
    REGSTR_PATH_CACHE TEXT("\\Extensible Cache")

#define REGSTR_PATH_TRACKING \
    REGSTR_PATH_EXTENSIBLE_CACHE TEXT("\\Log")

#define REGSTR_PATH_CACHE_SPECIAL_PATHS \
    REGSTR_PATH_CACHE TEXT("Special Paths")

#define REGSTR_VAL_DIRECTORY           TEXT("Directory")
#define REGSTR_VAL_DIRECTORY_TYPE            REG_EXPAND_SZ

#define REGSTR_VAL_NEWDIRECTORY         TEXT("NewDirectory")
#define REGSTR_VAL_NEWDIRECTORY_TYPE    REG_EXPAND_SZ

#define REGSTR_VAL_CACHEPREFIX              TEXT("CachePrefix")
#define REGSTR_VAL_CACHEPREFIX_TYPE     REG_SZ

#define REGSTR_PATH_URLHISTORY \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Url History")

#define REGSTR_PATH_SUBSCRIPTION \
    REGSTR_PATH_INTERNETSETTINGS TEXT("\\Subscription Folder")

//
// Search Format Strings
//
#define SZ_IE_SEARCHSTRINGS             "UrlTemplate"
#define REGSTR_PATH_SEARCHSTRINGS       REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_SEARCHSTRINGS)
#define REGSTR_KEY_SEARCHSTRINGS        TEXT(SZ_IE_SEARCHSTRINGS)

#define MAX_SEARCH_FORMAT_STRING        255

//
// Server error page dispaly/don't display length thresholds.
//
#define SZ_IE_THRESHOLDS                "ErrorThresholds"
#define REGSTR_PATH_THRESHOLDS          REGSTR_PATH_MAIN TEXT( "\\") TEXT(SZ_IE_THRESHOLDS)


//
// Access Medium
//
#define REGSTR_VAL_ACCESSMEDIUM         TEXT("AccessMedium")
// access type (MSN, other)
#define REGSTR_VAL_ACCESSTYPE           TEXT("AccessType")

//
// AutoDial
//
// name of connectoid-specific autodial handler dll and function
#define REGSTR_VAL_AUTODIALDLLNAME      TEXT("AutodialDllName")
#define REGSTR_VAL_AUTODIALFCNNAME      TEXT("AutodialFcnName")
// class name for window to receive Winsock activity messages
#define REGSTR_VAL_AUTODIAL_MONITORCLASSNAME    TEXT("MS_AutodialMonitor")
#define REGSTR_VAL_AUTODIAL_TRYONLYONCE         TEXT("TryAutodialOnce")

//
// Remote Access
//
// path to RNA values (under HKEY_CURRENT_USER)
#define REGSTR_PATH_REMOTEACCESS        TEXT("RemoteAccess")
#define REGSTR_PATH_REMOTEACESS         REGSTR_PATH_REMOTEACCESS
// this is under HKLM... we are using this to determine if RNA is installed
// or not. We can't rely on finding the DLL since removing this component
// with the control panel's "Add/Remove Software" does not remove the RNAdll.
#define REGSTR_PATH_RNACOMPONENT    TSZWINCURVERPATH    TEXT("\\Setup\\OptionalComponents\\RNA")
#define REGSTR_VAL_RNAINSTALLED     TEXT("Installed")

// values under HKCU\REGSTR_PATH_INTERNET_SETTINGS

// 4-byte REG_BINARY, autodialing is enabled if this value is present and
// non-zero, disabled otherwise
// If ForceAutodial is true, will always dial similar to IE4 behavior.
// If it's false, will only dial if network is not available.
#define REGSTR_VAL_ENABLEAUTODIAL               TEXT("EnableAutodial")
#define REGSTR_VAL_ENABLEUNATTENDED             TEXT("EnableUnattended")
#define REGSTR_VAL_NONETAUTODIAL                TEXT("NoNetAutodial")

#define REGSTR_VAL_REDIALATTEMPTS               TEXT("RedialAttempts")
#define REGSTR_VAL_REDIALINTERVAL               TEXT("RedialWait")

#define REGSTR_VAL_ENABLEAUTODIALDISCONNECT     TEXT("EnableAutodisconnect")
#define REGSTR_VAL_ENABLEAUTODISCONNECT         REGSTR_VAL_ENABLEAUTODIALDISCONNECT
#define REGSTR_VAL_ENABLEEXITDISCONNECT         TEXT("EnableExitDisconnect")

#define REGSTR_VAL_ENABLESECURITYCHECK          TEXT("EnableSecurityCheck")

#define REGSTR_VAL_COVEREXCLUDE                 TEXT("CoverExclude")
// 4-byte REG_BINARY containing number of minutes of idle time to allow
// before autodisconnect.  Autodisconnect is disabled if this value is zero
// or not present.
#define REGSTR_VAL_DISCONNECTIDLETIME   TEXT("DisconnectIdleTime")

//
// MOS
//
#define REGSTR_PATH_MOSDISCONNECT       TSZMICROSOFTPATH TEXT("\\MOS\\Preferences")
#define REGSTR_VAL_MOSDISCONNECT        TEXT("DisconnectTimeout")

//
// Proxy : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_PROXYENABLE          TEXT("ProxyEnable")
#define REGSTR_VAL_PROXYSERVER          TEXT("ProxyServer")
#define REGSTR_VAL_PROXYOVERRIDE        TEXT("ProxyOverride")
#define REGSTR_VAL_BYPASSAUTOCONFIG     TEXT("BypassAutoconfig")



//
// Security : HKCU\\WININETPATH
//
#define SZTRUSTWARNLEVEL                    "Trust Warning Level"
#define REGSTR_KEY_TRUSTWARNINGLEVEL        TSZWININETPATH  TEXT(SZTRUSTWARNLEVEL)
#define REGSTR_VAL_TRUSTWARNINGLEVEL        TEXT(SZTRUSTWARNLEVEL) //"none" will turn off WinVerifyTrust warnings.
#define REGSTR_VAL_TRUSTWARNINGLEVEL_TYPE   REG_SZ
#define REGSTR_VAL_TRUSTWARNINGLEVEL_HIGH   TEXT("High")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_MED    TEXT("Medium")
#define REGSTR_VAL_TRUSTWARNINGLEVEL_LOW    TEXT("No Security")
// default depends on MSHTML's prefs nSafetyWarningLevel

#define REGSTR_VAL_SECURITYWARNONSEND       TEXT("WarnOnPost")
#define REGSTR_VAL_SECURITYWARNONSEND_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONSEND_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONSENDALWAYS         TEXT("WarnAlwaysOnPost")
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_TYPE    REG_BINARY // FALSE-Only if... TRUE-Always
#define REGSTR_VAL_SECURITYWARNONSENDALWAYS_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONVIEW       TEXT("WarnOnView")
#define REGSTR_VAL_SECURITYWARNONVIEW_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONVIEW_DEF   TRUE

#define REGSTR_VAL_SECURITYALLOWCOOKIES         TEXT("AllowCookies")
#define REGSTR_VAL_SECURITYALLOWCOOKIES_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYALLOWCOOKIES_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONZONECROSSING       TEXT("WarnOnZoneCrossing")
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_TYPE  REG_BINARY
#define REGSTR_VAL_SECURITYWARNONZONECROSSING_DEF   TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING         TEXT("WarnOnBadCertRecving")
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTVIEWING_DEF     TRUE

#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING         TEXT("WarnOnBadCertSending")
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_TYPE    REG_BINARY
#define REGSTR_VAL_SECURITYWARNONBADCERTSENDING_DEF     TRUE

#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES       TEXT("DisableCachingOfSSLPages")
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_TYPE  REG_DWORD
#define REGSTR_VAL_SECURITYDISABLECACHINGOFSSLPAGES_DEF   FALSE


//
// Run/Show ActiveX / Java : These are under REGSTR_PATH_INTERNETSETTINGS
//
#define REGSTR_VAL_SECURITYACTIVEX              TEXT("Security_RunActiveXControls")
#define REGSTR_VAL_SECURITYACTIVEX_TYPE         REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTIVEX_DEF          TRUE

#define REGSTR_VAL_SECURITYACTICEXSCRIPTS       TEXT("Security_RunScripts")
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_TYPE  REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYACTICEXSCRIPTS_DEF   TRUE

#define REGSTR_VAL_SECURITYJAVA                 TEXT("Security_RunJavaApplets")
#define REGSTR_VAL_SECURITYJAVA_TYPE            REG_BINARY  // TRUE or FALSE
#define REGSTR_VAL_SECURITYJAVA_DEF             TRUE

//
// Java VM exclusively : HKCU
//
#define SZJAVAVMPATH                            "\\Java VM"
#define REGSTR_PATH_JAVAVM                      TSZMICROSOFTPATH TEXT(SZJAVAVMPATH)

#define REGSTR_VAL_JAVAJIT                      TEXT("EnableJIT")
#define REGSTR_VAL_JAVAJIT_TYPE                 REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVAJIT_DEF                  FALSE

#define REGSTR_VAL_JAVALOGGING                   TEXT("EnableLogging")
#define REGSTR_VAL_JAVALOGGING_TYPE              REG_DWORD   // TRUE or FALSE
#define REGSTR_VAL_JAVALOGGING_DEF               FALSE


//
// QuickLinks
//
// this is where custom quicklinks are stored
#define SZTOOLBAR               "\\Toolbar"
#define TSZTOOLBAR              TEXT(SZTOOLBAR)
#define REGSTR_PATH_TOOLBAR     TSZIEPATH TEXT(SZTOOLBAR)
#define REGSTR_KEY_QUICKLINKS   TSZIEPATH TSZTOOLBAR TEXT("\\Links")
#define REGSTR_VAL_DAYSTOKEEP   TEXT("DaysToKeep")

#define SZNOTEXT                "NoText"
#define REGSTR_VAL_NOTEXT       TEXT(SZNOTEXT)
#define REGSTR_KEY_NOTEXT       TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZNOTEXT)
#define SZVISIBLE               "VisibleBands"
#define REGSTR_VAL_VISIBLE      TEXT(SZVISIBLE)
#define REGSTR_KEY_VISIBLE      TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZVISIBLE)


#define REGSTR_VAL_VISIBLEBANDS         TEXT("VisibleBands")
#define REGSTR_VAL_VISIBLEBANDS_TYPE    REG_DWORD   // 3 bits (see below)
#define REGSTR_VAL_VISIBLEBANDS_DEF     0x7         // all three bands
#define TOOLSBAND                       0x1
#define ADDRESSBAND                     0x2
#define LINKSBAND                       0x4

#define SZBACKBITMAP          "BackBitmap"
#define REGSTR_VAL_BACKBITMAP       TEXT("BackBitmap")
#define REGSTR_VAL_BACKBITMAP_TYPE  REG_SZ
// "" = no bitmap or fillin with valid path, delete for default

#define REGSTR_KEY_BACKBITMAP   TSZIEPATH TSZTOOLBAR TEXT("\\") TEXT(SZBACKBITMAP)

#define REGSTR_PATH_QUICKCOMPLETE REGSTR_PATH_TOOLBAR TEXT("\\") TEXT("QuickComplete")
#define REGSTR_SHIFTQUICKSUFFIX TEXT("ShiftQuickCompleteSuffix")

//
// Schannel Settings: HKLM
//

#define TSZSCHANNELPATH             TEXT("SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL")
#define TSZSCHANNELPROTOCOLSPATH    TSZSCHANNELPATH TEXT("\\Protocols")

#define REGSTR_PATH_PCT1            TSZSCHANNELPROTOCOLSPATH TEXT("\\PCT 1.0\\Client")
#define REGSTR_PATH_SSL2            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 2.0\\Client")
#define REGSTR_PATH_SSL3            TSZSCHANNELPROTOCOLSPATH TEXT("\\SSL 3.0\\Client")
#define REGSTR_PATH_UNIHELLO        TSZSCHANNELPROTOCOLSPATH TEXT("\\Multi-Protocol Unified Hello\\Client")

#define REGSTR_VAL_SCHANNELENABLEPROTOCOL         TEXT("Enabled")
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_TYPE    REG_DWORD
#define REGSTR_VAL_SCHANNELENABLEPROTOCOL_DEF     TRUE


//
// Mail and News: HKLM
//
#ifdef UNIX

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Microsoft\\Internet Explorer\\Unix")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\MailCommand")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\NewsCommand")
#define REGSTR_PATH_VSOURCECLIENTS  TSZINTERNETCLIENTSPATH  TEXT("\\VSourceCommand")
#define REGSTR_PATH_EDITORS         TSZINTERNETCLIENTSPATH  TEXT("\\Editors")
#define REGSTR_PATH_DEFAULT         TEXT("default")
#define REGSTR_PATH_CURRENT         TEXT("current")

#else

#define TSZINTERNETCLIENTSPATH      TEXT("Software\\Clients")
#define REGSTR_PATH_MAILCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Mail")
#define REGSTR_PATH_NEWSCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\News")
#define REGSTR_PATH_CALENDARCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Calendar")
#define REGSTR_PATH_CONTACTCLIENTS TSZINTERNETCLIENTSPATH  TEXT("\\Contacts")
#define REGSTR_PATH_CALLCLIENTS     TSZINTERNETCLIENTSPATH  TEXT("\\Internet Call")

#endif // !UNIX

#ifdef UNIX
// Registry item containing the exe name to check for disabling OE
#define IE_USE_OE_PRESENT_HKEY HKEY_LOCAL_MACHINE
#define IE_USE_OE_PRESENT_KEY  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\app.paths\\msimn.exe")
#define IE_USE_OE_PRESENT_VALUE NULL

// locations for new OE control variables for unix
#define IE_USE_OE_MAIL_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_MAIL_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Mail")
#define IE_USE_OE_MAIL_VALUE TEXT("Use Outlook Express")

#define IE_USE_OE_NEWS_HKEY  HKEY_CURRENT_USER
#define IE_USE_OE_NEWS_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\News")
#define IE_USE_OE_NEWS_VALUE TEXT("Use Outlook Express")
#endif // UNIX

// this is under the mail and news paths
#define TSZPROTOCOLSPATH            TEXT("Protocols\\")
// and one these is under the protocols path
#define TSZMAILTOPROTOCOL           TEXT("mailto")
#define TSZNEWSPROTOCOL             TEXT("news")
#define TSZCALLTOPROTOCOL           TEXT("callto")
#define TSZLDAPPROTOCOL             TEXT("ldap")
#define TSZCALENDARPROTOCOL         TEXT("unk")

#ifdef UNIX
#define TSZVSOURCEPROTOCOL          TEXT("view source")
#endif

//
// International and Fonts: HKCU\\TSZIEPATH
//
#define REGSTR_PATH_INTERNATIONAL   TSZIEPATH   TEXT("\\International")

#define REGSTR_PATH_INTERNATIONAL_SCRIPTS  TSZIEPATH   TEXT("\\International\\Scripts")

#define REGSTR_VAL_DEFAULT_CODEPAGE         TEXT("Default_CodePage")
#define REGSTR_VAL_DEFAULT_CODEPAGE_TYPE    REG_SZ  // code page
                   // will grab default from system if not found

#define REGSTR_VAL_DEFAULT_SCRIPT         TEXT("Default_Script")
#define REGSTR_VAL_DEFAULT_SCRIPT_TYPE    REG_SZ  
                   // will grab default from system if not found


#define REGSTR_VAL_ACCEPT_LANGUAGE          TEXT("AcceptLanguage")
#define REGSTR_VAL_ACCETP_LANGUAGE_TYPE     REG_SZ


// each CHARSET has a unique key under REGSTR_PATH_INTERNATIONAL
// which has the following values defined
#define REGSTR_VAL_FONT_SCRIPTS          TEXT("Scripts")
#define REGSTR_VAL_FONT_SCRIPT           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_TYPE      REG_SZ  // friendly name of font if other than system
                                                 // no default

#define REGSTR_VAL_FONT_SCRIPT_NAME           TEXT("Script")
#define REGSTR_VAL_FONT_SCRIPT_NAME_TYPE      REG_SZ                                                        


#define REGSTR_VAL_DEF_ENCODING         TEXT("Default_Encoding")
#define REGSTR_VAL_DEF_ENCODING_TYPE    REG_SZ  // internal MIME table name
                                                // no default

#define REGSTR_VAL_DEF_INETENCODING         TEXT("Default_InternetEncoding")
#define REGSTR_VAL_DEF_INETENCODING_TYPE    REG_DWORD
                                                // no default

#define REGSTR_VAL_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_FIXED_FONT       TEXT("IEFixedFontName")
#define REGSTR_VAL_SCRIPT_FIXED_FONT_TYPE  REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                            // no default

#define REGSTR_VAL_SCRIPT_PROP_FONT        TEXT("IEPropFontName")
#define REGSTR_VAL_SCRIPT_PROP_FONT_TYPE   REG_SZ  // must match a registered font name
                                                   // no default

#define REGSTR_VAL_FONT_SIZE        TEXT("IEFontSize")
#define REGSTR_VAL_FONT_SIZE_TYPE   REG_BINARY
#define REGSTR_VAL_FONT_SIZE_DEF    2       // default size : Medium

#define REGSTR_VAL_AUTODETECT         TEXT("AutoDetect")
#define REGSTR_VAL_AUTODETECT_TYPE    REG_SZ

// MIME database charset extension
#define REGSTR_PATH_MIME_DATABASE           TEXT("MIME\\Database")
#define REGSTR_KEY_MIME_DATABASE_CHARSET    REGSTR_PATH_MIME_DATABASE TEXT("\\Charset")
#define REGSTR_KEY_MIME_DATABASE_CODEPAGE   REGSTR_PATH_MIME_DATABASE TEXT("\\CodePage")
#define REGSTR_KEY_MIME_DATABASE_RFC1766    REGSTR_PATH_MIME_DATABASE TEXT("\\Rfc1766")

#define REGSTR_VAL_CODEPAGE                 TEXT("CodePage")
#define REGSTR_VAL_CODEPAGE_TYPE            REG_DWORD

#define REGSTR_VAL_INETENCODING             TEXT("InternetEncoding")
#define REGSTR_VAL_INETENCODING_TYPE        REG_DWORD

#define REGSTR_VAL_FAMILY                   TEXT("Family")
#define REGSTR_VAL_FAMILY_TYPE              REG_DWORD

#define REGSTR_VAL_LEVEL                    TEXT("Level")
#define REGSTR_VAL_LEVEL_TYPE               REG_DWORD

#define REGSTR_VAL_ALIASTO                  TEXT("AliasForCharset")
#define REGSTR_VAL_ALIASTO_TYPE             REG_SZ

#define REGSTR_VAL_ENCODENAME               TEXT("EncodingName")
#define REGSTR_VAL_ENCODENAME_TYPE          REG_SZ

#define REGSTR_VAL_DESCRIPTION              TEXT("Description")
#define REGSTR_VAL_DESCRIPTION_TYPE         REG_SZ

#define REGSTR_VAL_WEBCHARSET               TEXT("WebCharset")
#define REGSTR_VAL_WEBCHARSET_TYPE          REG_SZ

#define REGSTR_VAL_BODYCHARSET              TEXT("BodyCharset")
#define REGSTR_VAL_BODYCHARSET_TYPE         REG_SZ

#define REGSTR_VAL_HEADERCHARSET            TEXT("HeaderCharset")
#define REGSTR_VAL_HEADERCHARSET_TYPE       REG_SZ

#define REGSTR_VAL_FIXEDWIDTHFONT           TEXT("FixedWidthFont")
#define REGSTR_VAL_FIXEDWIDTHFONT_TYPE      REG_SZ

#define REGSTR_VAL_PROPORTIONALFONT         TEXT("ProportionalFont")
#define REGSTR_VAL_PROPOPRTIONALFONT_TYPE   REG_SZ

#define REGSTR_VAL_PRIVCONVERTER            TEXT("PrivConverter")
#define REGSTR_VAL_PRIVCONVERTER_TYPE       REG_SZ

#define REGSTR_PATH_DEFAULT_FEEDS REGSTR_PATH_MAIN L"\\Default Feeds"

#endif // _INETREGSTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\InitGuid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -  Definitions for controlling GUID initialization               *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) Microsoft Corporation. All rights reserved.     *
*                                                                             *
\*****************************************************************************/

#if _MSC_VER > 1000
#pragma once
#endif

#define INITGUID
#include <guiddef.h>
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\inked_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for inked.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_INKEDLib,0x8405D0DF,0x9FDD,0x4829,0xAE,0xAD,0x8E,0x2B,0x0A,0x18,0xFE,0xA4);


MIDL_DEFINE_GUID(IID, IID_IInkEdit,0xF2127A19,0xFBFB,0x4AED,0x84,0x64,0x3F,0x36,0xD7,0x8C,0xFE,0xFB);


MIDL_DEFINE_GUID(IID, DIID__IInkEditEvents,0xE3B0B797,0xA72E,0x46DB,0xA0,0xD7,0x6C,0x9E,0xBA,0x8E,0x9B,0xBC);


MIDL_DEFINE_GUID(CLSID, CLSID_InkEdit,0xE5CA59F5,0x57C4,0x4DD8,0x9B,0xD6,0x1D,0xEE,0xED,0xD2,0x7A,0xF4);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\InitOID.h ===
/*
 *  I N I T O I D . H
 *
 *  Define macros to be used for initializing MAPI OID's
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#define MAPI_PREFIX         0x2A,0x86,0x48,0x86,0xf7,0x14,0x03

#ifdef _MAC
#undef  DEFINE_OID_1
#define DEFINE_OID_1(name, b0, b1) \
    EXTERN_C const BYTE name[] = { MAPI_PREFIX, b0, b1 }

#undef  DEFINE_OID_2
#define DEFINE_OID_2(name, b0, b1, b2) \
    EXTERN_C const BYTE name[] = { MAPI_PREFIX, b0, b1, b2 }

#undef  DEFINE_OID_3
#define DEFINE_OID_3(name, b0, b1, b2, b3) \
    EXTERN_C const BYTE name[] = { MAPI_PREFIX, b0, b1, b2, b3 }

#undef  DEFINE_OID_4
#define DEFINE_OID_4(name, b0, b1, b2, b3, b4) \
    EXTERN_C const BYTE name[] = { MAPI_PREFIX, b0, b1, b2, b3, b4 }
#else
#undef  DEFINE_OID_1
#define DEFINE_OID_1(name, b0, b1) \
    EXTERN_C const BYTE __based(__segname("_CODE")) name[] =\
        { MAPI_PREFIX, b0, b1 }

#undef  DEFINE_OID_2
#define DEFINE_OID_2(name, b0, b1, b2) \
    EXTERN_C const BYTE __based(__segname("_CODE")) name[] =\
        { MAPI_PREFIX, b0, b1, b2 }

#undef  DEFINE_OID_3
#define DEFINE_OID_3(name, b0, b1, b2, b3) \
    EXTERN_C const BYTE __based(__segname("_CODE")) name[] =\
        { MAPI_PREFIX, b0, b1, b2, b3 }

#undef  DEFINE_OID_4
#define DEFINE_OID_4(name, b0, b1, b2, b3, b4) \
    EXTERN_C const BYTE __based(__segname("_CODE")) name[] =\
        { MAPI_PREFIX, b0, b1, b2, b3, b4 }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\infotech.h ===
#ifndef __INFOTECH_H__
#define __INFOTECH_H__

#include <comdef.h>
#include <ocidl.h>


// {1F403BB1-9997-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITPropList, 
0x1f403bb1, 0x9997, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daae-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_IITPropList, 
0x4662daae, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

typedef DWORD PROPID;

// Operations you can do on a property
#define PROP_ADD    0x00000000
#define PROP_DELETE 0x00000001
#define PROP_UPDATE 0x00000002

// Type of data
#define TYPE_VALUE   0x00000000
#define TYPE_POINTER 0x00000001
#define TYPE_STRING  0x00000002

// Class definition of CProperty
class CProperty
{
public:
    PROPID dwPropID;        // property ID
    DWORD cbData;           // Amount of data
    DWORD dwType;           // What type this is
    union
    {
        LPWSTR      lpszwData;   // String
        LPVOID      lpvData;     // Any kind of data
        DWORD       dwValue;     // Numerical data
    };
    BOOL fPersist;          // TRUE to persist this property

};

typedef CProperty* LPPROP;


// Interface def. for IITPropList
DECLARE_INTERFACE_(IITPropList, IPersistStreamInit)
{

    // dwOperation = operation (add, delete, update, etc.) to perform on property list
    STDMETHOD(Set)(PROPID PropID, DWORD dwData, DWORD dwOperation) PURE;
    STDMETHOD(Set)(PROPID PropID, LPVOID lpvData, DWORD cbData, DWORD dwOperation) PURE;
    STDMETHOD(Set)(PROPID PropID, LPCWSTR lpszwString, DWORD dwOperation) PURE;
    STDMETHOD(Add)(CProperty& Prop) PURE;

    STDMETHOD(Get)(PROPID PropID, CProperty& Property) PURE;
    STDMETHOD(Clear)() PURE;

    // set persistence state on property
    STDMETHOD(SetPersist)(PROPID PropID, BOOL fPersist) PURE;   // single property
    STDMETHOD(SetPersist)(BOOL fPersist) PURE;          // all properties in list

    // for enumerating properties
    STDMETHOD(GetFirst)(CProperty& Property) PURE;
    STDMETHOD(GetNext)(CProperty& Property) PURE;
    STDMETHOD(GetPropCount)(LONG &cProp) PURE;

    // persist header and data separately
    STDMETHOD(SaveHeader)(LPVOID lpvData, DWORD dwHdrSize) PURE;
    STDMETHOD(SaveData)(LPVOID lpvHeader, DWORD dwHdrSize, LPVOID lpvData, DWORD dwBufSize) PURE;
    STDMETHOD(GetHeaderSize)(DWORD& dwHdrSize) PURE;
    STDMETHOD(GetDataSize)(LPVOID lpvHeader, DWORD dwHdrSize, DWORD& dwDataSize) PURE;
    STDMETHOD(SaveDataToStream)(LPVOID lpvHeader, DWORD dwHdrSize, IStream* pStream) PURE;

    // persist to a memory buffer
    STDMETHOD(LoadFromMem)(LPVOID lpvData, DWORD dwBufSize) PURE;
    STDMETHOD(SaveToMem)(LPVOID lpvData, DWORD dwBufSize) PURE;

};

typedef IITPropList* LPITPROPLIST;


// {8fa0d5a2-dedf-11d0-9a61-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(IID_IITDatabase, 
0x8fa0d5a2, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {66673452-8C23-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITDatabase, 
0x66673452, 0x8c23, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa9-d393-11d0-9a56-00c04fb68bf7} (changed from IT 3.0)
DEFINE_GUID(CLSID_IITDatabaseLocal, 
0x4662daa9, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY


// This value is invalid for dwObjInstance params in IITDatabase methods.
#define	IITDB_OBJINST_NULL	((DWORD) 0xFFFFFFFF)


DECLARE_INTERFACE_(IITDatabase, IUnknown)
{
	STDMETHOD(Open)(LPCWSTR lpszHost, LPCWSTR lpszMoniker, DWORD dwFlags) PURE;
	STDMETHOD(Close)(void) PURE;

	// Creates an unnamed object that can be referenced in the future
	// by *pdwObjInstance.  Note that the value in *pdwObjInstance will be
	// persisted by the database when it is asked to save

	STDMETHOD(CreateObject)(REFCLSID rclsid, DWORD *pdwObjInstance) PURE;

	// Retrieves a specified IUnknown-based interface on the object identified
	// by dwObjInstance.
	STDMETHOD(GetObject)(DWORD dwObjInstance, REFIID riid, LPVOID *ppvObj) PURE;

	// To obtain a pointer to a named object's persistence the object's full
	// name (including any object-specific type prefix) should be passed in
	// lpswszObject.  If *lpwszObject is NULL, then the database's own storage
	// will be returned.  If lpwszObject is NULL, then dwObjInstance will be
	// used to identify the object and locate its persistence.  On exit,
	// *ppvPersistence will be either an IStorage* or an IStream*, depending
	// on what the caller specified with the fStream param.  The caller should
	// assume that only read operations can be performed on *ppvPersistence.
	// If the specified object's persistence doesn't exist, or if it exists
	// but is of the wrong type, then STG_E_FILENOTFOUND will be returned. 
	STDMETHOD(GetObjectPersistence)(LPCWSTR lpwszObject, DWORD dwObjInstance,
                                        LPVOID *ppvPersistence, BOOL fStream) PURE;
};

typedef IITDatabase* LPITDB;

// Document property macros
#define STDPROP_UID         1
#define STDPROP_TITLE       2
#define STDPROP_USERDATA    3
#define STDPROP_KEY         4

#define STDPROP_SORTKEY		100
#define STDPROP_DISPLAYKEY	101
#define STDPROP_SORTORDINAL 102

#define STDPROP_INDEX_TEXT    200
#define STDPROP_INDEX_VFLD    201
#define STDPROP_INDEX_DTYPE   202
#define STDPROP_INDEX_LENGTH  203
#define STDPROP_INDEX_BREAK   204

#define STDPROP_INDEX_TERM              210
#define STDPROP_INDEX_TERM_RAW_LENGTH   211

#define STDPROP_USERPROP_BASE   0x00010000
#define STDPROP_USERPROP_MAX    0x7FFFFFFF

// Property destinations for word wheels
#define SZ_WWDEST_GLOBAL    L"GLOBAL"
#define SZ_WWDEST_KEY       L"KEY"
#define SZ_WWDEST_OCC       L"OCC"


// {4662daa2-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_IITCmdInt,
0x4662daa2, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa3-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_IITSvMgr,
0x4662daa3, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4CF34C30-9BF9-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITCmdInt,
0x4cf34c30, 0x9bf9, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4E7DA031-9C11-11d0-8764-00A0C913F764}
DEFINE_GUID(IID_IITSvMgr,
0x4e7da031, 0x9c11, 0x11d0, 0x87, 0x64, 0x0, 0xa0, 0xc9, 0x13, 0xf7, 0x64);

// {4662daa5-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWordWheelUpdate,
0x4662daa5, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);
    
// {8fa0d5a5-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITBuildCollect,
0x8fa0d5a5, 0xdedf, 0x11d0, 0x9a, 0x61, 0x0, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daa4-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_IITGroupUpdate,
0x4662daa4, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5aa-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITIndexBuild,
0x8fa0d5aa, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5ab-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWWFilterBuild,
0x8fa0d5ab, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


// Word Breaker Defines:

// {8fa0d5a4-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITWordWheel, 
0x8fa0d5a4, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#ifdef ITPROXY

// {D73725C2-8C12-11d0-A84E-00AA006C7D01}
DEFINE_GUID(CLSID_IITWordWheel, 
0xd73725c2, 0x8c12, 0x11d0, 0xa8, 0x4e, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

#else

// {4662daa8-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_IITWordWheelLocal, 
0x4662daa8, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif	// ITPROXY

// Word-wheel open flags
#define ITWW_OPEN_CONNECT	0x00000000    // connect to server on open (the default)
#define ITWW_OPEN_NOCONNECT	0x00000001    // don't connect to server on open

// Constants for IITWordWheel::Lookup.
#define ITWW_CBKEY_MAX		1024		// Max size of keys allowed in Word Wheels.

// Forward declarations
interface IITDatabase;
interface IITResultSet;
interface IITGroup;
interface IITPropList;
interface IITQuery;

DECLARE_INTERFACE_(IITWordWheel, IUnknown)
{

	STDMETHOD(Open)(IITDatabase* lpITDB, LPCWSTR lpszMoniker, DWORD dwFlags=0) PURE;
	STDMETHOD(Close)(void) PURE;

	// Returns the code page ID and locale ID that the word wheel was built and
	// sorted with.
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Returns in *pdwObjInstance the ID of the external sort instance being used by
	// this word wheel.  The instance ID can be passed to IITDatabase::GetObject to
	// to obtain an interface pointer on the instantiated instance.  If the word
	// wheel doesn't use external sorting, then IITDB_OBJINST_NULL.
	STDMETHOD(GetSorterInstance)(DWORD *pdwObjInstance) PURE;

	STDMETHOD(Count)(LONG *pcEntries) PURE;

	// To be safe, the length of lpvKeyBuf should always be at least ITWW_CBKEY_MAX. 
	STDMETHOD(Lookup)(LONG lEntry, LPVOID lpvKeyBuf, DWORD cbKeyBuf) PURE;
	STDMETHOD(Lookup)(LONG lEntry, IITResultSet* lpITResult, LONG cEntries) PURE;
	STDMETHOD(Lookup)(LPCVOID lpcvPrefix, BOOL fExactMatch, LONG *plEntry) PURE;

	STDMETHOD(SetGroup)(IITGroup* piitGroup) PURE;
	STDMETHOD(GetGroup)(IITGroup** ppiitGroup) PURE;

	STDMETHOD(GetDataCount)(LONG lEntry, DWORD *pdwCount) PURE;
	STDMETHOD(GetData)(LONG lEntry, IITResultSet* lpITResult) PURE;
	STDMETHOD(GetDataColumns)(IITResultSet* pRS) PURE;
};

typedef IITWordWheel* LPITWORDWHEEL;


// IWordBreaker, IWordSink, IPhraseSink, IStem

#ifndef __IStemSink_FWD_DEFINED__
#define __IStemSink_FWD_DEFINED__
typedef interface IStemSink IStemSink;
#endif 	/* __IStemSink_FWD_DEFINED__ */


#ifndef __IStemmer_FWD_DEFINED__
#define __IStemmer_FWD_DEFINED__
typedef interface IStemmer IStemmer;
#endif 	/* __IStemmer_FWD_DEFINED__ */


#ifndef __IStemmerConfig_FWD_DEFINED__
#define __IStemmerConfig_FWD_DEFINED__
typedef interface IStemmerConfig IStemmerConfig;
#endif 	/* __IStemmerConfig_FWD_DEFINED__ */


DECLARE_INTERFACE_(IStemmer, IUnknown)
{
    STDMETHOD(Init)(ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
    STDMETHOD(StemWord)(WCHAR const *pwcInBuf, ULONG cwc,
									IStemSink *pStemSink) PURE;   
};

typedef IStemmer *PISTEM;


DECLARE_INTERFACE_(IStemSink, IUnknown)
{
    STDMETHOD(PutAltWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
    STDMETHOD(PutWord)(WCHAR const *pwcInBuf, ULONG cwc) PURE;
};

typedef IStemSink *PISTEMSNK;


DECLARE_INTERFACE_(IStemmerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the stemming
	// behavior of IStemmer::StemWord.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets info that controls certain aspects of stemming.
	// This method currently accepts only the following set of flags
	// in grfStemFlags:
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfStemFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfStemFlags, DWORD *pdwReserved) PURE;

	// Will load external stemmer data, such as word part lists, etc.
	// The format of the data in the stream is entirely
	// implementation-specific.
	STDMETHOD(LoadExternalStemmerData)(IStream *pStream,
                                           DWORD dwExtDataType) PURE;
};

typedef IStemmerConfig *PISTEMC;


#ifndef __IPhraseSink_FWD_DEFINED__
#define __IPhraseSink_FWD_DEFINED__
typedef interface IPhraseSink IPhraseSink;
#endif 	/* __IPhraseSink_FWD_DEFINED__ */


#ifndef __IWordSink_FWD_DEFINED__
#define __IWordSink_FWD_DEFINED__
typedef interface IWordSink IWordSink;
#endif 	/* __IWordSink_FWD_DEFINED__ */


#ifndef __IWordBreaker_FWD_DEFINED__
#define __IWordBreaker_FWD_DEFINED__
typedef interface IWordBreaker IWordBreaker;
#endif 	/* __IWordBreaker_FWD_DEFINED__ */


#ifndef __IWordBreakerConfig_FWD_DEFINED__
#define __IWordBreakerConfig_FWD_DEFINED__
typedef interface IWordBreakerConfig IWordBreakerConfig;
#endif 	/* __IWordBreakerConfig_FWD_DEFINED__ */


#ifndef __IITStopWordList_FWD_DEFINED__
#define __IITStopWordList_FWD_DEFINED__
typedef interface IITStopWordList IITStopWordList;
#endif 	/* __IITStopWordList_FWD_DEFINED__ */


// Supporting definitions for IWordBreaker.
typedef struct tagTEXT_SOURCE TEXT_SOURCE;
typedef SCODE (__stdcall *PFNFILLTEXTBUFFER)(TEXT_SOURCE *pTextSource);

typedef struct tagTEXT_SOURCE
{
    PFNFILLTEXTBUFFER pfnFillTextBuffer;
    WCHAR *awcBuffer;
    ULONG iEnd;
    ULONG iCur;
} TEXT_SOURCE;


DECLARE_INTERFACE_(IWordBreaker, IUnknown)
{
    STDMETHOD(Init)(BOOL fQuery, ULONG ulMaxTokenSize, BOOL *pfLicense) PURE;
    STDMETHOD(BreakText)(TEXT_SOURCE *pTextSource, IWordSink *pWordSink,
                         IPhraseSink *pPhraseSink) PURE;
    STDMETHOD(ComposePhrase)(WCHAR const *pwcNoun, ULONG cwcNoun,
                             WCHAR const *pwcModifier, ULONG cwcModifier,
                             ULONG ulAttachmentType, WCHAR *pwcPhrase,
                             ULONG *pcwcPhrase) PURE;
    STDMETHOD(GetLicenseToUse)(WCHAR const **ppwcsLicense) PURE;
};

typedef IWordBreaker *PIWBRK;


// Break word types that can be passed to
// IWordBreakerConfig::SetBreakWordType.
#define IITWBC_BREAKTYPE_TEXT		((DWORD) 0)
#define IITWBC_BREAKTYPE_NUMBER		((DWORD) 1)
#define IITWBC_BREAKTYPE_DATE		((DWORD) 2)
#define IITWBC_BREAKTYPE_TIME		((DWORD) 3)
#define IITWBC_BREAKTYPE_EPOCH		((DWORD) 4)


// Breaker control flags that can be passed to
// IWordBreakerConfig::SetControlInfo.
#define IITWBC_BREAK_ACCEPT_WILDCARDS	0x00000001  // Interpret wildcard chars as such.
#define IITWBC_BREAK_AND_STEM           0x00000002  // Stem words after breaking them.

// External data types that can be passed to
// IWordBreakerConfig::LoadExternalBreakerData.
#define IITWBC_EXTDATA_CHARTABLE		((DWORD) 0)		
#define IITWBC_EXTDATA_STOPWORDLIST		((DWORD) 1)


DECLARE_INTERFACE_(IWordBreakerConfig, IUnknown)
{
	// Sets/gets locale info that will affect the word breaking
	// behavior of IWordBreaker::BreakText.
	// Returns S_OK if locale described by params is supported
	// by the breaker object; E_INVALIDARG otherwise.
	STDMETHOD(SetLocaleInfo)(DWORD dwCodePageID, LCID lcid) PURE;
	STDMETHOD(GetLocaleInfo)(DWORD *pdwCodePageID, LCID *plcid) PURE;

	// Sets/gets the type of words the breaker should expect
	// to see in all subsequent calls to IWordBreaker::BreakText.
	// Returns S_OK if the type is understood by the breaker
	//  object; E_INVALIDARG otherwise.
	STDMETHOD(SetBreakWordType)(DWORD dwBreakWordType) PURE;
	STDMETHOD(GetBreakWordType)(DWORD *pdwBreakWordType) PURE;

	// Sets/gets info that controls certain aspects of word breaking.
	// This method currently accepts only the following set of flags
	// in grfBreakFlags:
	//		IITWBC_BREAK_ACCEPT_WILDCARDS
	//		IITWBC_BREAK_AND_STEM
	// In the future, additional information may be passed in through
	// dwReserved.
	STDMETHOD(SetControlInfo)(DWORD grfBreakFlags, DWORD dwReserved) PURE;
	STDMETHOD(GetControlInfo)(DWORD *pgrfBreakFlags, DWORD *pdwReserved) PURE;

	// Will load external breaker data, such as a table containing
	// char-by-char break information or a list of stop words.
	// Although the format of the data in the stream is entirely
	// implementation-specific, this interface does define a couple
	// of general types for that data which can be passed in
	// dwStreamDataType:
	//		IITWBC_EXTDATA_CHARTABLE
	//		IITWBC_EXTDATA_STOPWORDLIST
	STDMETHOD(LoadExternalBreakerData)(IStream *pStream,
                                           DWORD dwExtDataType) PURE;

	// These methods allow a stemmer to be associated with the breaker.  The
	// breaker will take responsibility for calling
	// IPersistStreamInit::Load/Save when it is loaded/saved if the stemmer
	// supports that interface.
	STDMETHOD(SetWordStemmer)(REFCLSID rclsid, IStemmer *pStemmer) PURE;
	STDMETHOD(GetWordStemmer)(IStemmer **ppStemmer) PURE;
};

//
// The InfoTech error codes
//
#define E_NOTEXIST          _HRESULT_TYPEDEF_(0x80001000L)
#define E_DUPLICATE         _HRESULT_TYPEDEF_(0x80001001L)
#define E_BADVERSION        _HRESULT_TYPEDEF_(0x80001002L)
#define E_BADFILE           _HRESULT_TYPEDEF_(0x80001003L)
#define E_BADFORMAT         _HRESULT_TYPEDEF_(0x80001004L)
#define E_NOPERMISSION      _HRESULT_TYPEDEF_(0x80001005L)
#define E_ASSERT            _HRESULT_TYPEDEF_(0x80001006L)
#define E_INTERRUPT         _HRESULT_TYPEDEF_(0x80001007L)
#define E_NOTSUPPORTED      _HRESULT_TYPEDEF_(0x80001008L)
#define E_OUTOFRANGE        _HRESULT_TYPEDEF_(0x80001009L)                  
#define E_GROUPIDTOOBIG     _HRESULT_TYPEDEF_(0x8000100AL)
#define E_TOOMANYTITLES     _HRESULT_TYPEDEF_(0x8000100BL)
#define E_NOMERGEDDATA      _HRESULT_TYPEDEF_(0x8000100CL)
#define E_NOTFOUND          _HRESULT_TYPEDEF_(0x8000100DL)
#define E_CANTFINDDLL       _HRESULT_TYPEDEF_(0x8000100EL)
#define E_NOHANDLE          _HRESULT_TYPEDEF_(0x8000100FL) 
#define E_GETLASTERROR      _HRESULT_TYPEDEF_(0x80001010L)
#define E_BADPARAM          _HRESULT_TYPEDEF_(0x80001011L)
#define E_INVALIDSTATE      _HRESULT_TYPEDEF_(0x80001012L)
#define E_NOTOPEN           _HRESULT_TYPEDEF_(0x80001013L)
#define E_ALREADYOPEN       _HRESULT_TYPEDEF_(0x80001013L)
#define E_UNKNOWN_TRANSPORT _HRESULT_TYPEDEF_(0x80001016L)
#define E_UNSUPPORTED_TRANSPORT _HRESULT_TYPEDEF_(0x80001017L)
#define E_BADFILTERSIZE     _HRESULT_TYPEDEF_(0x80001018L)
#define E_TOOMANYOBJECTS    _HRESULT_TYPEDEF_(0x80001019L)
#define E_NAMETOOLONG       _HRESULT_TYPEDEF_(0x80001020L)

#define E_FILECREATE        _HRESULT_TYPEDEF_(0x80001030L) 
#define E_FILECLOSE         _HRESULT_TYPEDEF_(0x80001031L)
#define E_FILEREAD          _HRESULT_TYPEDEF_(0x80001032L)
#define E_FILESEEK          _HRESULT_TYPEDEF_(0x80001033L)
#define E_FILEWRITE         _HRESULT_TYPEDEF_(0x80001034L)
#define E_FILEDELETE        _HRESULT_TYPEDEF_(0x80001035L)
#define E_FILEINVALID       _HRESULT_TYPEDEF_(0x80001036L)
#define E_FILENOTFOUND      _HRESULT_TYPEDEF_(0x80001037L)
#define E_DISKFULL          _HRESULT_TYPEDEF_(0x80001038L)

#define E_TOOMANYTOPICS     _HRESULT_TYPEDEF_(0x80001050L)
#define E_TOOMANYDUPS       _HRESULT_TYPEDEF_(0x80001051L)
#define E_TREETOOBIG        _HRESULT_TYPEDEF_(0x80001052L)
#define E_BADBREAKER        _HRESULT_TYPEDEF_(0x80001053L)
#define E_BADVALUE          _HRESULT_TYPEDEF_(0x80001054L)
#define E_ALL_WILD          _HRESULT_TYPEDEF_(0x80001055L)
#define E_TOODEEP           _HRESULT_TYPEDEF_(0x80001056L)
#define E_EXPECTEDTERM      _HRESULT_TYPEDEF_(0x80001057L)
#define E_MISSLPAREN        _HRESULT_TYPEDEF_(0x80001058L)
#define E_MISSRPAREN        _HRESULT_TYPEDEF_(0x80001059L)
#define E_MISSQUOTE         _HRESULT_TYPEDEF_(0x8000105AL)
#define E_NULLQUERY         _HRESULT_TYPEDEF_(0x8000105BL)
#define E_STOPWORD          _HRESULT_TYPEDEF_(0x8000105CL)
#define E_BADRANGEOP        _HRESULT_TYPEDEF_(0x8000105DL)
#define E_UNMATCHEDTYPE     _HRESULT_TYPEDEF_(0x8000105EL)
#define E_WORDTOOLONG       _HRESULT_TYPEDEF_(0x8000105FL)
#define E_BADINDEXFLAGS     _HRESULT_TYPEDEF_(0x80001060L)
#define E_WILD_IN_DTYPE     _HRESULT_TYPEDEF_(0x80001061L)   
#define E_NOSTEMMER         _HRESULT_TYPEDEF_(0x80001062L)

// Property list and result set errors
#define E_MISSINGPROP       _HRESULT_TYPEDEF_(0x80001080L)
#define E_PROPLISTNOTEMPTY  _HRESULT_TYPEDEF_(0x80001081L)
#define E_PROPLISTEMPTY     _HRESULT_TYPEDEF_(0x80001082L)
#define E_ALREADYINIT       _HRESULT_TYPEDEF_(0x80001083L)
#define E_NOTINIT           _HRESULT_TYPEDEF_(0x80001084L)
#define E_RESULTSETEMPTY    _HRESULT_TYPEDEF_(0x80001085L)
#define E_TOOMANYCOLUMNS    _HRESULT_TYPEDEF_(0x80001086L)
#define E_NOKEYPROP         _HRESULT_TYPEDEF_(0x80001087L)



// ITResultSet interface declaration

// {3BB91D41-998B-11d0-A850-00AA006C7D01}
DEFINE_GUID(IID_IITResultSet, 
0x3bb91d41, 0x998b, 0x11d0, 0xa8, 0x50, 0x0, 0xaa, 0x0, 0x6c, 0x7d, 0x1);

// {4662daa7-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_IITResultSet, 
0x4662daa7, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// maximum number of columns in a row set
#define MAX_COLUMNS  256

// Column priorities
typedef enum
{
    PRIORITY_LOW = 0,
    PRIORITY_NORMAL = 1,
    PRIORITY_HIGH = 2,

} PRIORITY;


// Forward declarations
class CProperty;

typedef struct tagROWSTATUS
{
    LONG lRowFirst;
    LONG cRows;
    LONG cProperties;
    LONG cRowsTotal;

} ROWSTATUS, *LPROWSTATUS;


typedef struct tagCOLUMNSTATUS
{
    LONG cPropCount;
    LONG cPropsLoaded;

} COLUMNSTATUS, *LPCOLUMNSTATUS;


// Used by IITResultSet::SetColumnHeap.
typedef SCODE (__stdcall *PFNCOLHEAPFREE)(LPVOID);


DECLARE_INTERFACE_(IITResultSet, IUnknown)
{
    // Initialization
    STDMETHOD(SetColumnPriority)(LONG lColumnIndex, PRIORITY ColumnPriority) PURE;
    STDMETHOD(SetColumnHeap)(LONG lColumnIndex, LPVOID lpvHeap,
                             PFNCOLHEAPFREE pfnColHeapFree) PURE;
    STDMETHOD(SetKeyProp)(PROPID PropID) PURE;
    STDMETHOD(Add)(LPVOID lpvHdr) PURE;
    STDMETHOD(Add)(PROPID PropID, LPVOID lpvDefaultData, DWORD cbData, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, LPCWSTR lpszwDefault, PRIORITY Priority) PURE;
    STDMETHOD(Add)(PROPID PropID, DWORD dwDefaultData, PRIORITY Priority) PURE;

    // Build result set
    STDMETHOD(Append)(LPVOID lpvHdr, LPVOID lpvData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LPVOID lpvHdr, LPVOID lpvData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, DWORD_PTR dwData) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPCWSTR lpwStr) PURE;
    STDMETHOD(Set)(LONG lRowIndex, LONG lColumnIndex, LPVOID lpvData, DWORD cbData) PURE;
    STDMETHOD(Copy)(IITResultSet* pRSCopy) PURE;
    STDMETHOD(AppendRows)(IITResultSet* pResSrc, LONG lRowSrcFirst, LONG cSrcRows, 
                          LONG& lRowFirstDest) PURE;

    // Obtain info about result set
    STDMETHOD(Get)(LONG lRowIndex, LONG lColumnIndex, CProperty& Prop) PURE;
    STDMETHOD(GetKeyProp)(PROPID& KeyPropID) PURE;
    STDMETHOD(GetColumnPriority)(LONG lColumnIndex, PRIORITY& ColumnPriority) PURE;
    STDMETHOD(GetRowCount)(LONG& lNumberOfRows) PURE;
    STDMETHOD(GetColumnCount)(LONG& lNumberOfColumns) PURE;
    STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID) PURE;
    STDMETHOD(GetColumn)(LONG lColumnIndex, PROPID& PropID, DWORD& dwType, LPVOID& lpvDefaultValue,
                         DWORD& cbSize, PRIORITY& ColumnPriority) PURE;

    STDMETHOD(GetColumnFromPropID)(PROPID PropID, LONG& lColumnIndex) PURE;

    // Clear result set
    STDMETHOD(Clear)() PURE;
    STDMETHOD(ClearRows)() PURE;
    STDMETHOD(Free)() PURE;

    // Asynchronous support
    STDMETHOD(IsCompleted)() PURE;      // returns S_OK or S_FALSE
    STDMETHOD(Cancel)() PURE;
    STDMETHOD(Pause)(BOOL fPause) PURE;

    STDMETHOD(GetRowStatus)(LONG lRowFirst, LONG cRows, LPROWSTATUS lpRowStatus) PURE;
    STDMETHOD(GetColumnStatus)(LPCOLUMNSTATUS lpColStatus) PURE;
};

typedef IITResultSet* LPITRS;


//----------------------------------------------------------------------
//------			Word Breaking Definitions				------------
//----------------------------------------------------------------------

// {D53552C8-77E3-101A-B552-08002B33B0E6}
DEFINE_GUID(IID_IWordBreaker, 
0xD53552C8, 0x77E3, 0x101A, 0xB5, 0x52, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC907054-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IWordSink, 
0xCC907054, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {CC906FF0-C058-101A-B554-08002B33B0E6}
DEFINE_GUID(IID_IPhraseSink, 
0xCC906FF0, 0xC058, 0x101A, 0xB5, 0x54, 0x08, 0x00, 0x2B, 0x33, 0xB0, 0xE6);

// {8fa0d5a6-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IWordBreakerConfig, 
0x8fa0d5a6, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {4662daaf-d393-11d0-9a56-00c04fb68bf7}
DEFINE_GUID(CLSID_ITStdBreaker, 
0x4662daaf, 0xd393, 0x11d0, 0x9a, 0x56, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------			Stop Word List Definitions				------------
//----------------------------------------------------------------------

// {8fa0d5ad-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IITStopWordList, 
0x8fa0d5ad, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);


//----------------------------------------------------------------------
//------				Stemming Definitions				------------
//----------------------------------------------------------------------

// {efbaf140-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemmer, 
0xefbaf140, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {fe77c330-7f42-11ce-be57-00aa0051fe20}
DEFINE_GUID(IID_IStemSink, 
0xfe77c330, 0x7f42, 0x11ce, 0xbe, 0x57, 0x00, 0xaa, 0x00, 0x51, 0xfe, 0x20);

// {8fa0d5a7-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(IID_IStemmerConfig, 
0x8fa0d5a7, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

// {8fa0d5a8-dedf-11d0-9a61-00c04fb68bf7}
DEFINE_GUID(CLSID_ITEngStemmer, 
0x8fa0d5a8, 0xdedf, 0x11d0, 0x9a, 0x61, 0x00, 0xc0, 0x4f, 0xb6, 0x8b, 0xf7);

#endif  // __INFOTECH_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\inked.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for inked.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __inked_h__
#define __inked_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IInkEdit_FWD_DEFINED__
#define __IInkEdit_FWD_DEFINED__
typedef interface IInkEdit IInkEdit;
#endif 	/* __IInkEdit_FWD_DEFINED__ */


#ifndef ___IInkEditEvents_FWD_DEFINED__
#define ___IInkEditEvents_FWD_DEFINED__
typedef interface _IInkEditEvents _IInkEditEvents;
#endif 	/* ___IInkEditEvents_FWD_DEFINED__ */


#ifndef __InkEdit_FWD_DEFINED__
#define __InkEdit_FWD_DEFINED__

#ifdef __cplusplus
typedef class InkEdit InkEdit;
#else
typedef struct InkEdit InkEdit;
#endif /* __cplusplus */

#endif 	/* __InkEdit_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "msinkaut.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_inked_0000_0000 */
/* [local] */ 


///////////////////////////////////////////////////////////////////////////////
//
// InkEdit Win32 API
//
///////////////////////////////////////////////////////////////////////////////

#define INKEDIT_CLASSW  L"INKEDIT"

#ifdef UNICODE
#define INKEDIT_CLASS   INKEDIT_CLASSW
#else
#define INKEDIT_CLASS   "INKEDIT"
#endif

// InkEdit Constants

// InkEdit Structures

struct IEC_STROKEINFO
{
     NMHDR nmhdr; 
     IInkCursor * Cursor;
     IInkStrokeDisp * Stroke;
};

struct IEC_GESTUREINFO
{
     NMHDR nmhdr; 
     IInkCursor * Cursor;
     IInkStrokes * Strokes;
     VARIANT Gestures;
};

struct IEC_RECOGNITIONRESULTINFO
{
     NMHDR nmhdr; 
     IInkRecognitionResult * RecognitionResult;
};

// InkEdit messages

#define IEC__BASE           (WM_USER + 0x0200)
#define EM_GETINKMODE       (IEC__BASE + 1)
#define EM_SETINKMODE       (IEC__BASE + 2)
#define EM_GETINKINSERTMODE (IEC__BASE + 3)
#define EM_SETINKINSERTMODE (IEC__BASE + 4)
#define EM_GETDRAWATTR      (IEC__BASE + 5)
#define EM_SETDRAWATTR      (IEC__BASE + 6)
#define EM_GETRECOTIMEOUT   (IEC__BASE + 7)
#define EM_SETRECOTIMEOUT   (IEC__BASE + 8)
#define EM_GETGESTURESTATUS (IEC__BASE + 9)
#define EM_SETGESTURESTATUS (IEC__BASE + 10)
#define EM_GETRECOGNIZER    (IEC__BASE + 11)
#define EM_SETRECOGNIZER    (IEC__BASE + 12)
#define EM_GETFACTOID       (IEC__BASE + 13)
#define EM_SETFACTOID       (IEC__BASE + 14)
#define EM_GETSELINK        (IEC__BASE + 15)
#define EM_SETSELINK        (IEC__BASE + 16)
#define EM_GETMOUSEICON     (IEC__BASE + 17)
#define EM_SETMOUSEICON     (IEC__BASE + 18)
#define EM_GETMOUSEPOINTER  (IEC__BASE + 19)
#define EM_SETMOUSEPOINTER  (IEC__BASE + 20)
#define EM_GETSTATUS        (IEC__BASE + 21)
#define EM_RECOGNIZE        (IEC__BASE + 22)
#define EM_GETUSEMOUSEFORINPUT   (IEC__BASE + 23)
#define EM_SETUSEMOUSEFORINPUT   (IEC__BASE + 24)
#define EM_SETSELINKDISPLAYMODE  (IEC__BASE + 25)
#define EM_GETSELINKDISPLAYMODE  (IEC__BASE + 26)

///////////////////////////////////////////////////////////////////////////////

// InkEdit notifications

#define IECN__BASE             (0x0800)
#define IECN_STROKE            (IECN__BASE + 1)
#define IECN_GESTURE           (IECN__BASE + 2)
#define IECN_RECOGNITIONRESULT (IECN__BASE + 3)




extern RPC_IF_HANDLE __MIDL_itf_inked_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_inked_0000_0000_v0_0_s_ifspec;


#ifndef __INKEDLib_LIBRARY_DEFINED__
#define __INKEDLib_LIBRARY_DEFINED__

/* library INKEDLib */
/* [helpcontext][helpstring][helpfile][version][uuid] */ 

typedef /* [helpcontext][helpstring] */ 
enum MouseButton
    {	NO_BUTTON	= 0,
	LEFT_BUTTON	= 0x1,
	RIGHT_BUTTON	= 0x2,
	MIDDLE_BUTTON	= 0x4
    } 	MouseButton;

typedef /* [helpcontext][helpstring] */ 
enum SelAlignmentConstants
    {	rtfLeft	= 0,
	rtfRight	= 1,
	rtfCenter	= 2
    } 	SelAlignmentConstants;

typedef /* [hidden] */ 
enum DISPID_InkEdit
    {	DISPID_Text	= DISPID_VALUE,
	DISPID_TextRTF	= ( DISPID_Text + 1 ) ,
	DISPID_Hwnd	= ( DISPID_TextRTF + 1 ) ,
	DISPID_DisableNoScroll	= ( DISPID_Hwnd + 1 ) ,
	DISPID_Locked	= ( DISPID_DisableNoScroll + 1 ) ,
	DISPID_Enabled	= ( DISPID_Locked + 1 ) ,
	DISPID_MaxLength	= ( DISPID_Enabled + 1 ) ,
	DISPID_MultiLine	= ( DISPID_MaxLength + 1 ) ,
	DISPID_ScrollBars	= ( DISPID_MultiLine + 1 ) ,
	DISPID_RTSelStart	= ( DISPID_ScrollBars + 1 ) ,
	DISPID_RTSelLength	= ( DISPID_RTSelStart + 1 ) ,
	DISPID_RTSelText	= ( DISPID_RTSelLength + 1 ) ,
	DISPID_SelAlignment	= ( DISPID_RTSelText + 1 ) ,
	DISPID_SelBold	= ( DISPID_SelAlignment + 1 ) ,
	DISPID_SelCharOffset	= ( DISPID_SelBold + 1 ) ,
	DISPID_SelColor	= ( DISPID_SelCharOffset + 1 ) ,
	DISPID_SelFontName	= ( DISPID_SelColor + 1 ) ,
	DISPID_SelFontSize	= ( DISPID_SelFontName + 1 ) ,
	DISPID_SelItalic	= ( DISPID_SelFontSize + 1 ) ,
	DISPID_SelRTF	= ( DISPID_SelItalic + 1 ) ,
	DISPID_SelUnderline	= ( DISPID_SelRTF + 1 ) ,
	DISPID_DragIcon	= ( DISPID_SelUnderline + 1 ) ,
	DISPID_Status	= ( DISPID_DragIcon + 1 ) ,
	DISPID_UseMouseForInput	= ( DISPID_Status + 1 ) ,
	DISPID_InkMode	= ( DISPID_UseMouseForInput + 1 ) ,
	DISPID_InkInsertMode	= ( DISPID_InkMode + 1 ) ,
	DISPID_RecoTimeout	= ( DISPID_InkInsertMode + 1 ) ,
	DISPID_DrawAttr	= ( DISPID_RecoTimeout + 1 ) ,
	DISPID_Recognizer	= ( DISPID_DrawAttr + 1 ) ,
	DISPID_Factoid	= ( DISPID_Recognizer + 1 ) ,
	DISPID_SelInk	= ( DISPID_Factoid + 1 ) ,
	DISPID_SelInksDisplayMode	= ( DISPID_SelInk + 1 ) ,
	DISPID_Recognize	= ( DISPID_SelInksDisplayMode + 1 ) ,
	DISPID_GetGestStatus	= ( DISPID_Recognize + 1 ) ,
	DISPID_SetGestStatus	= ( DISPID_GetGestStatus + 1 ) ,
	DISPID_Refresh	= ( DISPID_SetGestStatus + 1 ) 
    } 	DISPID_InkEdit;

typedef /* [hidden] */ 
enum DISPID_InkEditEvents
    {	DISPID_IeeChange	= 1,
	DISPID_IeeSelChange	= 2,
	DISPID_IeeKeyDown	= 3,
	DISPID_IeeKeyUp	= 4,
	DISPID_IeeMouseUp	= 5,
	DISPID_IeeMouseDown	= 6,
	DISPID_IeeKeyPress	= 7,
	DISPID_IeeDblClick	= 8,
	DISPID_IeeClick	= 9,
	DISPID_IeeMouseMove	= 10,
	DISPID_IeeCursorDown	= 21,
	DISPID_IeeStroke	= 22,
	DISPID_IeeGesture	= 23,
	DISPID_IeeRecognitionResult	= 24
    } 	DISPID_InkEditEvents;


EXTERN_C const IID LIBID_INKEDLib;

#ifndef __IInkEdit_INTERFACE_DEFINED__
#define __IInkEdit_INTERFACE_DEFINED__

/* interface IInkEdit */
/* [unique][helpcontext][helpstring][dual][uuid][object] */ 

typedef /* [helpcontext][helpstring] */ 
enum InkMode
    {	IEM_Disabled	= 0,
	IEM_Ink	= 1,
	IEM_InkAndGesture	= 2
    } 	InkMode;

typedef /* [helpcontext][helpstring] */ 
enum InkInsertMode
    {	IEM_InsertText	= 0,
	IEM_InsertInk	= 1
    } 	InkInsertMode;

typedef /* [helpcontext][helpstring] */ 
enum InkEditStatus
    {	IES_Idle	= 0,
	IES_Collecting	= 1,
	IES_Recognizing	= 2
    } 	InkEditStatus;

typedef /* [helpcontext][helpstring] */ 
enum InkDisplayMode
    {	IDM_Ink	= 0,
	IDM_Text	= 1
    } 	InkDisplayMode;

typedef /* [helpcontext][helpstring] */ 
enum AppearanceConstants
    {	rtfFlat	= 0,
	rtfThreeD	= 1
    } 	AppearanceConstants;

typedef /* [helpcontext][helpstring] */ 
enum BorderStyleConstants
    {	rtfNoBorder	= 0,
	rtfFixedSingle	= 1
    } 	BorderStyleConstants;

typedef /* [helpcontext][helpstring] */ 
enum ScrollBarsConstants
    {	rtfNone	= 0,
	rtfHorizontal	= 1,
	rtfVertical	= 2,
	rtfBoth	= 3
    } 	ScrollBarsConstants;


EXTERN_C const IID IID_IInkEdit;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F2127A19-FBFB-4AED-8464-3F36D78CFEFB")
    IInkEdit : public IDispatch
    {
    public:
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out InkEditStatus *pStatus) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_UseMouseForInput( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UseMouseForInput( 
            /* [defaultvalue][in] */ VARIANT_BOOL newVal = ( VARIANT_BOOL  )-1) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_InkMode( 
            /* [retval][out] */ __RPC__out InkMode *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_InkMode( 
            /* [defaultvalue][in] */ InkMode newVal = IEM_InkAndGesture) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_InkInsertMode( 
            /* [retval][out] */ __RPC__out InkInsertMode *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_InkInsertMode( 
            /* [defaultvalue][in] */ InkInsertMode newVal = IEM_InsertText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DrawingAttributes( 
            /* [retval][out] */ __RPC__deref_out_opt IInkDrawingAttributes **pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_DrawingAttributes( 
            /* [in] */ __RPC__in_opt IInkDrawingAttributes *newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecognitionTimeout( 
            /* [retval][out] */ __RPC__out long *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_RecognitionTimeout( 
            /* [in] */ long newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Recognizer( 
            /* [retval][out] */ __RPC__deref_out_opt IInkRecognizer **pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Recognizer( 
            /* [in] */ __RPC__in_opt IInkRecognizer *newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Factoid( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Factoid( 
            /* [in] */ __RPC__in BSTR newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelInks( 
            /* [retval][out] */ __RPC__out VARIANT *pSelInk) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelInks( 
            /* [in] */ VARIANT SelInk) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelInksDisplayMode( 
            /* [retval][out] */ __RPC__out InkDisplayMode *pInkDisplayMode) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelInksDisplayMode( 
            /* [in] */ InkDisplayMode InkDisplayMode) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Recognize( void) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGestureStatus( 
            /* [in] */ InkApplicationGesture Gesture,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pListen) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE SetGestureStatus( 
            /* [in] */ InkApplicationGesture Gesture,
            /* [in] */ VARIANT_BOOL Listen) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR clr) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pclr) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ __RPC__out AppearanceConstants *pAppearance) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ AppearanceConstants pAppearance) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ __RPC__out BorderStyleConstants *pBorderStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ BorderStyleConstants pBorderStyle) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Hwnd( 
            /* [retval][out] */ __RPC__out OLE_HANDLE *pohHwnd) = 0;
        
        virtual /* [helpcontext][helpstring][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][bindable][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ __RPC__in_opt IFontDisp *ppFont) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Text( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Text( 
            /* [in] */ __RPC__in BSTR pbstrText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MouseIcon( 
            /* [retval][out] */ __RPC__deref_out_opt IPictureDisp **MouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MouseIcon( 
            /* [in] */ __RPC__in_opt IPictureDisp *MouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propputref][id] */ HRESULT STDMETHODCALLTYPE putref_MouseIcon( 
            /* [in] */ __RPC__in_opt IPictureDisp *MouseIcon) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MousePointer( 
            /* [retval][out] */ __RPC__out InkMousePointer *MousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MousePointer( 
            /* [in] */ InkMousePointer MousePointer) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Locked( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Locked( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MaxLength( 
            /* [retval][out] */ __RPC__out long *plMaxLength) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MaxLength( 
            /* [in] */ long lMaxLength) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MultiLine( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MultiLine( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ScrollBars( 
            /* [retval][out] */ __RPC__out ScrollBarsConstants *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ScrollBars( 
            /* [in] */ ScrollBarsConstants newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisableNoScroll( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisableNoScroll( 
            /* [in] */ VARIANT_BOOL newVal) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelAlignment( 
            /* [retval][out] */ __RPC__out VARIANT *pvarSelAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelAlignment( 
            /* [in] */ VARIANT pvarSelAlignment) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelBold( 
            /* [retval][out] */ __RPC__out VARIANT *pvarSelBold) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelBold( 
            /* [in] */ VARIANT pvarSelBold) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelItalic( 
            /* [retval][out] */ __RPC__out VARIANT *pvarSelItalic) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelItalic( 
            /* [in] */ VARIANT pvarSelItalic) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelUnderline( 
            /* [retval][out] */ __RPC__out VARIANT *pvarSelUnderline) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelUnderline( 
            /* [in] */ VARIANT pvarSelUnderline) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelColor( 
            /* [retval][out] */ __RPC__out VARIANT *pvarSelColor) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelColor( 
            /* [in] */ VARIANT pvarSelColor) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelFontName( 
            /* [retval][out] */ __RPC__out VARIANT *pvarSelFontName) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelFontName( 
            /* [in] */ VARIANT pvarSelFontName) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelFontSize( 
            /* [retval][out] */ __RPC__out VARIANT *pvarSelFontSize) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelFontSize( 
            /* [in] */ VARIANT pvarSelFontSize) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelCharOffset( 
            /* [retval][out] */ __RPC__out VARIANT *pvarSelCharOffset) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelCharOffset( 
            /* [in] */ VARIANT pvarSelCharOffset) = 0;
        
        virtual /* [helpcontext][helpstring][defaultbind][displaybind][bindable][propget][id] */ HRESULT STDMETHODCALLTYPE get_TextRTF( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTextRTF) = 0;
        
        virtual /* [helpcontext][helpstring][displaybind][bindable][propput][id] */ HRESULT STDMETHODCALLTYPE put_TextRTF( 
            /* [in] */ __RPC__in BSTR pbstrTextRTF) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelStart( 
            /* [retval][out] */ __RPC__out long *plSelStart) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelStart( 
            /* [in] */ long plSelStart) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelLength( 
            /* [retval][out] */ __RPC__out long *plSelLength) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelLength( 
            /* [in] */ long plSelLength) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelText( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSelText) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelText( 
            /* [in] */ __RPC__in BSTR pbstrSelText) = 0;
        
        virtual /* [helpcontext][helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelRTF( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSelRTF) = 0;
        
        virtual /* [helpcontext][helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SelRTF( 
            /* [in] */ __RPC__in BSTR pbstrSelRTF) = 0;
        
        virtual /* [helpcontext][helpstring][id] */ HRESULT STDMETHODCALLTYPE Refresh( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInkEditVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInkEdit * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInkEdit * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IInkEdit * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IInkEdit * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IInkEdit * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out InkEditStatus *pStatus);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UseMouseForInput )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UseMouseForInput )( 
            __RPC__in IInkEdit * This,
            /* [defaultvalue][in] */ VARIANT_BOOL newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InkMode )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out InkMode *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InkMode )( 
            __RPC__in IInkEdit * This,
            /* [defaultvalue][in] */ InkMode newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InkInsertMode )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out InkInsertMode *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InkInsertMode )( 
            __RPC__in IInkEdit * This,
            /* [defaultvalue][in] */ InkInsertMode newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DrawingAttributes )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt IInkDrawingAttributes **pVal);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_DrawingAttributes )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in_opt IInkDrawingAttributes *newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RecognitionTimeout )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out long *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RecognitionTimeout )( 
            __RPC__in IInkEdit * This,
            /* [in] */ long newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Recognizer )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt IInkRecognizer **pVal);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Recognizer )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in_opt IInkRecognizer *newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Factoid )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Factoid )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in BSTR newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelInks )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pSelInk);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelInks )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT SelInk);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelInksDisplayMode )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out InkDisplayMode *pInkDisplayMode);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelInksDisplayMode )( 
            __RPC__in IInkEdit * This,
            /* [in] */ InkDisplayMode InkDisplayMode);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Recognize )( 
            __RPC__in IInkEdit * This);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGestureStatus )( 
            __RPC__in IInkEdit * This,
            /* [in] */ InkApplicationGesture Gesture,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pListen);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetGestureStatus )( 
            __RPC__in IInkEdit * This,
            /* [in] */ InkApplicationGesture Gesture,
            /* [in] */ VARIANT_BOOL Listen);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            __RPC__in IInkEdit * This,
            /* [in] */ OLE_COLOR clr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pclr);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out AppearanceConstants *pAppearance);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            __RPC__in IInkEdit * This,
            /* [in] */ AppearanceConstants pAppearance);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out BorderStyleConstants *pBorderStyle);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            __RPC__in IInkEdit * This,
            /* [in] */ BorderStyleConstants pBorderStyle);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Hwnd )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out OLE_HANDLE *pohHwnd);
        
        /* [helpcontext][helpstring][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont);
        
        /* [helpcontext][helpstring][bindable][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in_opt IFontDisp *ppFont);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Text )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Text )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in BSTR pbstrText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MouseIcon )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt IPictureDisp **MouseIcon);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MouseIcon )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in_opt IPictureDisp *MouseIcon);
        
        /* [helpcontext][helpstring][propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_MouseIcon )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in_opt IPictureDisp *MouseIcon);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MousePointer )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out InkMousePointer *MousePointer);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MousePointer )( 
            __RPC__in IInkEdit * This,
            /* [in] */ InkMousePointer MousePointer);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Locked )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Locked )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaxLength )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out long *plMaxLength);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MaxLength )( 
            __RPC__in IInkEdit * This,
            /* [in] */ long lMaxLength);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MultiLine )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MultiLine )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScrollBars )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out ScrollBarsConstants *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScrollBars )( 
            __RPC__in IInkEdit * This,
            /* [in] */ ScrollBarsConstants newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisableNoScroll )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pVal);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisableNoScroll )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT_BOOL newVal);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelAlignment )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarSelAlignment);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelAlignment )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT pvarSelAlignment);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelBold )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarSelBold);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelBold )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT pvarSelBold);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelItalic )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarSelItalic);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelItalic )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT pvarSelItalic);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelUnderline )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarSelUnderline);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelUnderline )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT pvarSelUnderline);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelColor )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarSelColor);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelColor )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT pvarSelColor);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelFontName )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarSelFontName);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelFontName )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT pvarSelFontName);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelFontSize )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarSelFontSize);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelFontSize )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT pvarSelFontSize);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelCharOffset )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out VARIANT *pvarSelCharOffset);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelCharOffset )( 
            __RPC__in IInkEdit * This,
            /* [in] */ VARIANT pvarSelCharOffset);
        
        /* [helpcontext][helpstring][defaultbind][displaybind][bindable][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TextRTF )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrTextRTF);
        
        /* [helpcontext][helpstring][displaybind][bindable][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TextRTF )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in BSTR pbstrTextRTF);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelStart )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out long *plSelStart);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelStart )( 
            __RPC__in IInkEdit * This,
            /* [in] */ long plSelStart);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelLength )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__out long *plSelLength);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelLength )( 
            __RPC__in IInkEdit * This,
            /* [in] */ long plSelLength);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelText )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSelText);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelText )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in BSTR pbstrSelText);
        
        /* [helpcontext][helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SelRTF )( 
            __RPC__in IInkEdit * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrSelRTF);
        
        /* [helpcontext][helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SelRTF )( 
            __RPC__in IInkEdit * This,
            /* [in] */ __RPC__in BSTR pbstrSelRTF);
        
        /* [helpcontext][helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Refresh )( 
            __RPC__in IInkEdit * This);
        
        END_INTERFACE
    } IInkEditVtbl;

    interface IInkEdit
    {
        CONST_VTBL struct IInkEditVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInkEdit_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInkEdit_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInkEdit_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInkEdit_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IInkEdit_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IInkEdit_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IInkEdit_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IInkEdit_get_Status(This,pStatus)	\
    ( (This)->lpVtbl -> get_Status(This,pStatus) ) 

#define IInkEdit_get_UseMouseForInput(This,pVal)	\
    ( (This)->lpVtbl -> get_UseMouseForInput(This,pVal) ) 

#define IInkEdit_put_UseMouseForInput(This,newVal)	\
    ( (This)->lpVtbl -> put_UseMouseForInput(This,newVal) ) 

#define IInkEdit_get_InkMode(This,pVal)	\
    ( (This)->lpVtbl -> get_InkMode(This,pVal) ) 

#define IInkEdit_put_InkMode(This,newVal)	\
    ( (This)->lpVtbl -> put_InkMode(This,newVal) ) 

#define IInkEdit_get_InkInsertMode(This,pVal)	\
    ( (This)->lpVtbl -> get_InkInsertMode(This,pVal) ) 

#define IInkEdit_put_InkInsertMode(This,newVal)	\
    ( (This)->lpVtbl -> put_InkInsertMode(This,newVal) ) 

#define IInkEdit_get_DrawingAttributes(This,pVal)	\
    ( (This)->lpVtbl -> get_DrawingAttributes(This,pVal) ) 

#define IInkEdit_putref_DrawingAttributes(This,newVal)	\
    ( (This)->lpVtbl -> putref_DrawingAttributes(This,newVal) ) 

#define IInkEdit_get_RecognitionTimeout(This,pVal)	\
    ( (This)->lpVtbl -> get_RecognitionTimeout(This,pVal) ) 

#define IInkEdit_put_RecognitionTimeout(This,newVal)	\
    ( (This)->lpVtbl -> put_RecognitionTimeout(This,newVal) ) 

#define IInkEdit_get_Recognizer(This,pVal)	\
    ( (This)->lpVtbl -> get_Recognizer(This,pVal) ) 

#define IInkEdit_putref_Recognizer(This,newVal)	\
    ( (This)->lpVtbl -> putref_Recognizer(This,newVal) ) 

#define IInkEdit_get_Factoid(This,pVal)	\
    ( (This)->lpVtbl -> get_Factoid(This,pVal) ) 

#define IInkEdit_put_Factoid(This,newVal)	\
    ( (This)->lpVtbl -> put_Factoid(This,newVal) ) 

#define IInkEdit_get_SelInks(This,pSelInk)	\
    ( (This)->lpVtbl -> get_SelInks(This,pSelInk) ) 

#define IInkEdit_put_SelInks(This,SelInk)	\
    ( (This)->lpVtbl -> put_SelInks(This,SelInk) ) 

#define IInkEdit_get_SelInksDisplayMode(This,pInkDisplayMode)	\
    ( (This)->lpVtbl -> get_SelInksDisplayMode(This,pInkDisplayMode) ) 

#define IInkEdit_put_SelInksDisplayMode(This,InkDisplayMode)	\
    ( (This)->lpVtbl -> put_SelInksDisplayMode(This,InkDisplayMode) ) 

#define IInkEdit_Recognize(This)	\
    ( (This)->lpVtbl -> Recognize(This) ) 

#define IInkEdit_GetGestureStatus(This,Gesture,pListen)	\
    ( (This)->lpVtbl -> GetGestureStatus(This,Gesture,pListen) ) 

#define IInkEdit_SetGestureStatus(This,Gesture,Listen)	\
    ( (This)->lpVtbl -> SetGestureStatus(This,Gesture,Listen) ) 

#define IInkEdit_put_BackColor(This,clr)	\
    ( (This)->lpVtbl -> put_BackColor(This,clr) ) 

#define IInkEdit_get_BackColor(This,pclr)	\
    ( (This)->lpVtbl -> get_BackColor(This,pclr) ) 

#define IInkEdit_get_Appearance(This,pAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,pAppearance) ) 

#define IInkEdit_put_Appearance(This,pAppearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,pAppearance) ) 

#define IInkEdit_get_BorderStyle(This,pBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,pBorderStyle) ) 

#define IInkEdit_put_BorderStyle(This,pBorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,pBorderStyle) ) 

#define IInkEdit_get_Hwnd(This,pohHwnd)	\
    ( (This)->lpVtbl -> get_Hwnd(This,pohHwnd) ) 

#define IInkEdit_get_Font(This,ppFont)	\
    ( (This)->lpVtbl -> get_Font(This,ppFont) ) 

#define IInkEdit_putref_Font(This,ppFont)	\
    ( (This)->lpVtbl -> putref_Font(This,ppFont) ) 

#define IInkEdit_get_Text(This,pbstrText)	\
    ( (This)->lpVtbl -> get_Text(This,pbstrText) ) 

#define IInkEdit_put_Text(This,pbstrText)	\
    ( (This)->lpVtbl -> put_Text(This,pbstrText) ) 

#define IInkEdit_get_MouseIcon(This,MouseIcon)	\
    ( (This)->lpVtbl -> get_MouseIcon(This,MouseIcon) ) 

#define IInkEdit_put_MouseIcon(This,MouseIcon)	\
    ( (This)->lpVtbl -> put_MouseIcon(This,MouseIcon) ) 

#define IInkEdit_putref_MouseIcon(This,MouseIcon)	\
    ( (This)->lpVtbl -> putref_MouseIcon(This,MouseIcon) ) 

#define IInkEdit_get_MousePointer(This,MousePointer)	\
    ( (This)->lpVtbl -> get_MousePointer(This,MousePointer) ) 

#define IInkEdit_put_MousePointer(This,MousePointer)	\
    ( (This)->lpVtbl -> put_MousePointer(This,MousePointer) ) 

#define IInkEdit_get_Locked(This,pVal)	\
    ( (This)->lpVtbl -> get_Locked(This,pVal) ) 

#define IInkEdit_put_Locked(This,newVal)	\
    ( (This)->lpVtbl -> put_Locked(This,newVal) ) 

#define IInkEdit_get_Enabled(This,pVal)	\
    ( (This)->lpVtbl -> get_Enabled(This,pVal) ) 

#define IInkEdit_put_Enabled(This,newVal)	\
    ( (This)->lpVtbl -> put_Enabled(This,newVal) ) 

#define IInkEdit_get_MaxLength(This,plMaxLength)	\
    ( (This)->lpVtbl -> get_MaxLength(This,plMaxLength) ) 

#define IInkEdit_put_MaxLength(This,lMaxLength)	\
    ( (This)->lpVtbl -> put_MaxLength(This,lMaxLength) ) 

#define IInkEdit_get_MultiLine(This,pVal)	\
    ( (This)->lpVtbl -> get_MultiLine(This,pVal) ) 

#define IInkEdit_put_MultiLine(This,newVal)	\
    ( (This)->lpVtbl -> put_MultiLine(This,newVal) ) 

#define IInkEdit_get_ScrollBars(This,pVal)	\
    ( (This)->lpVtbl -> get_ScrollBars(This,pVal) ) 

#define IInkEdit_put_ScrollBars(This,newVal)	\
    ( (This)->lpVtbl -> put_ScrollBars(This,newVal) ) 

#define IInkEdit_get_DisableNoScroll(This,pVal)	\
    ( (This)->lpVtbl -> get_DisableNoScroll(This,pVal) ) 

#define IInkEdit_put_DisableNoScroll(This,newVal)	\
    ( (This)->lpVtbl -> put_DisableNoScroll(This,newVal) ) 

#define IInkEdit_get_SelAlignment(This,pvarSelAlignment)	\
    ( (This)->lpVtbl -> get_SelAlignment(This,pvarSelAlignment) ) 

#define IInkEdit_put_SelAlignment(This,pvarSelAlignment)	\
    ( (This)->lpVtbl -> put_SelAlignment(This,pvarSelAlignment) ) 

#define IInkEdit_get_SelBold(This,pvarSelBold)	\
    ( (This)->lpVtbl -> get_SelBold(This,pvarSelBold) ) 

#define IInkEdit_put_SelBold(This,pvarSelBold)	\
    ( (This)->lpVtbl -> put_SelBold(This,pvarSelBold) ) 

#define IInkEdit_get_SelItalic(This,pvarSelItalic)	\
    ( (This)->lpVtbl -> get_SelItalic(This,pvarSelItalic) ) 

#define IInkEdit_put_SelItalic(This,pvarSelItalic)	\
    ( (This)->lpVtbl -> put_SelItalic(This,pvarSelItalic) ) 

#define IInkEdit_get_SelUnderline(This,pvarSelUnderline)	\
    ( (This)->lpVtbl -> get_SelUnderline(This,pvarSelUnderline) ) 

#define IInkEdit_put_SelUnderline(This,pvarSelUnderline)	\
    ( (This)->lpVtbl -> put_SelUnderline(This,pvarSelUnderline) ) 

#define IInkEdit_get_SelColor(This,pvarSelColor)	\
    ( (This)->lpVtbl -> get_SelColor(This,pvarSelColor) ) 

#define IInkEdit_put_SelColor(This,pvarSelColor)	\
    ( (This)->lpVtbl -> put_SelColor(This,pvarSelColor) ) 

#define IInkEdit_get_SelFontName(This,pvarSelFontName)	\
    ( (This)->lpVtbl -> get_SelFontName(This,pvarSelFontName) ) 

#define IInkEdit_put_SelFontName(This,pvarSelFontName)	\
    ( (This)->lpVtbl -> put_SelFontName(This,pvarSelFontName) ) 

#define IInkEdit_get_SelFontSize(This,pvarSelFontSize)	\
    ( (This)->lpVtbl -> get_SelFontSize(This,pvarSelFontSize) ) 

#define IInkEdit_put_SelFontSize(This,pvarSelFontSize)	\
    ( (This)->lpVtbl -> put_SelFontSize(This,pvarSelFontSize) ) 

#define IInkEdit_get_SelCharOffset(This,pvarSelCharOffset)	\
    ( (This)->lpVtbl -> get_SelCharOffset(This,pvarSelCharOffset) ) 

#define IInkEdit_put_SelCharOffset(This,pvarSelCharOffset)	\
    ( (This)->lpVtbl -> put_SelCharOffset(This,pvarSelCharOffset) ) 

#define IInkEdit_get_TextRTF(This,pbstrTextRTF)	\
    ( (This)->lpVtbl -> get_TextRTF(This,pbstrTextRTF) ) 

#define IInkEdit_put_TextRTF(This,pbstrTextRTF)	\
    ( (This)->lpVtbl -> put_TextRTF(This,pbstrTextRTF) ) 

#define IInkEdit_get_SelStart(This,plSelStart)	\
    ( (This)->lpVtbl -> get_SelStart(This,plSelStart) ) 

#define IInkEdit_put_SelStart(This,plSelStart)	\
    ( (This)->lpVtbl -> put_SelStart(This,plSelStart) ) 

#define IInkEdit_get_SelLength(This,plSelLength)	\
    ( (This)->lpVtbl -> get_SelLength(This,plSelLength) ) 

#define IInkEdit_put_SelLength(This,plSelLength)	\
    ( (This)->lpVtbl -> put_SelLength(This,plSelLength) ) 

#define IInkEdit_get_SelText(This,pbstrSelText)	\
    ( (This)->lpVtbl -> get_SelText(This,pbstrSelText) ) 

#define IInkEdit_put_SelText(This,pbstrSelText)	\
    ( (This)->lpVtbl -> put_SelText(This,pbstrSelText) ) 

#define IInkEdit_get_SelRTF(This,pbstrSelRTF)	\
    ( (This)->lpVtbl -> get_SelRTF(This,pbstrSelRTF) ) 

#define IInkEdit_put_SelRTF(This,pbstrSelRTF)	\
    ( (This)->lpVtbl -> put_SelRTF(This,pbstrSelRTF) ) 

#define IInkEdit_Refresh(This)	\
    ( (This)->lpVtbl -> Refresh(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInkEdit_INTERFACE_DEFINED__ */


#ifndef ___IInkEditEvents_DISPINTERFACE_DEFINED__
#define ___IInkEditEvents_DISPINTERFACE_DEFINED__

/* dispinterface _IInkEditEvents */
/* [helpcontext][helpstring][uuid] */ 


EXTERN_C const IID DIID__IInkEditEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("E3B0B797-A72E-46DB-A0D7-6C9EBA8E9BBC")
    _IInkEditEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _IInkEditEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _IInkEditEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _IInkEditEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _IInkEditEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in _IInkEditEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in _IInkEditEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in _IInkEditEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _IInkEditEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _IInkEditEventsVtbl;

    interface _IInkEditEvents
    {
        CONST_VTBL struct _IInkEditEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IInkEditEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _IInkEditEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _IInkEditEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _IInkEditEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _IInkEditEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _IInkEditEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _IInkEditEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___IInkEditEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_InkEdit;

#ifdef __cplusplus

class DECLSPEC_UUID("E5CA59F5-57C4-4DD8-9BD6-1DEEEDD27AF4")
InkEdit;
#endif
#endif /* __INKEDLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\InputScope.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for inputscope.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __inputscope_h__
#define __inputscope_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ITfInputScope_FWD_DEFINED__
#define __ITfInputScope_FWD_DEFINED__
typedef interface ITfInputScope ITfInputScope;
#endif 	/* __ITfInputScope_FWD_DEFINED__ */


#ifndef __ITfInputScope2_FWD_DEFINED__
#define __ITfInputScope2_FWD_DEFINED__
typedef interface ITfInputScope2 ITfInputScope2;
#endif 	/* __ITfInputScope2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_inputscope_0000_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// InputScope.h


// InputScope declarations.

//=--------------------------------------------------------------------------=
// (C) Copyright 1995-2003 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR TFPLIED, INCLUDING BUT NOT LIMITED TO
// THE TFPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#ifndef INPUTSCOPE_DEFINED
#define INPUTSCOPE_DEFINED

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_inputscope_0000_0000_0001
    {	IS_DEFAULT	= 0,
	IS_URL	= 1,
	IS_FILE_FULLFILEPATH	= 2,
	IS_FILE_FILENAME	= 3,
	IS_EMAIL_USERNAME	= 4,
	IS_EMAIL_SMTPEMAILADDRESS	= 5,
	IS_LOGINNAME	= 6,
	IS_PERSONALNAME_FULLNAME	= 7,
	IS_PERSONALNAME_PREFIX	= 8,
	IS_PERSONALNAME_GIVENNAME	= 9,
	IS_PERSONALNAME_MIDDLENAME	= 10,
	IS_PERSONALNAME_SURNAME	= 11,
	IS_PERSONALNAME_SUFFIX	= 12,
	IS_ADDRESS_FULLPOSTALADDRESS	= 13,
	IS_ADDRESS_POSTALCODE	= 14,
	IS_ADDRESS_STREET	= 15,
	IS_ADDRESS_STATEORPROVINCE	= 16,
	IS_ADDRESS_CITY	= 17,
	IS_ADDRESS_COUNTRYNAME	= 18,
	IS_ADDRESS_COUNTRYSHORTNAME	= 19,
	IS_CURRENCY_AMOUNTANDSYMBOL	= 20,
	IS_CURRENCY_AMOUNT	= 21,
	IS_DATE_FULLDATE	= 22,
	IS_DATE_MONTH	= 23,
	IS_DATE_DAY	= 24,
	IS_DATE_YEAR	= 25,
	IS_DATE_MONTHNAME	= 26,
	IS_DATE_DAYNAME	= 27,
	IS_DIGITS	= 28,
	IS_NUMBER	= 29,
	IS_ONECHAR	= 30,
	IS_PASSWORD	= 31,
	IS_TELEPHONE_FULLTELEPHONENUMBER	= 32,
	IS_TELEPHONE_COUNTRYCODE	= 33,
	IS_TELEPHONE_AREACODE	= 34,
	IS_TELEPHONE_LOCALNUMBER	= 35,
	IS_TIME_FULLTIME	= 36,
	IS_TIME_HOUR	= 37,
	IS_TIME_MINORSEC	= 38,
	IS_NUMBER_FULLWIDTH	= 39,
	IS_ALPHANUMERIC_HALFWIDTH	= 40,
	IS_ALPHANUMERIC_FULLWIDTH	= 41,
	IS_CURRENCY_CHINESE	= 42,
	IS_BOPOMOFO	= 43,
	IS_HIRAGANA	= 44,
	IS_KATAKANA_HALFWIDTH	= 45,
	IS_KATAKANA_FULLWIDTH	= 46,
	IS_HANJA	= 47,
	IS_HANGUL_HALFWIDTH	= 48,
	IS_HANGUL_FULLWIDTH	= 49,
	IS_PHRASELIST	= -1,
	IS_REGULAREXPRESSION	= -2,
	IS_SRGS	= -3,
	IS_XML	= -4,
	IS_ENUMSTRING	= -5
    } 	InputScope;

HRESULT WINAPI SetInputScope(HWND hwnd, InputScope inputscope);
HRESULT WINAPI SetInputScopes(HWND hwnd, const InputScope *pInputScopes, UINT cInputScopes, __in_ecount(cPhrases) WCHAR **ppszPhraseList, UINT cPhrases, __in_opt WCHAR *pszRegExp, __in_opt WCHAR *pszSRGS);
HRESULT WINAPI SetInputScopeXML(HWND hwnd, __in_opt WCHAR *pszXML);
HRESULT WINAPI SetInputScopes2(HWND hwnd, const InputScope *pInputScopes, UINT cInputScopes, IEnumString *pEnumString, __in_opt WCHAR *pszRegExp, __in_opt WCHAR *pszSRGS);
DEFINE_GUID(IID_ITfInputScope, 0xfde1eaee, 0x6924, 0x4cdf, 0x91, 0xe7, 0xda, 0x38, 0xcf, 0xf5, 0x55, 0x9d);
DEFINE_GUID(IID_ITfInputScope2, 0x5731eaa0, 0x6bc2, 0x4681, 0xa5, 0x32, 0x92, 0xfb, 0xb7, 0x4d, 0x7c, 0x41);
DEFINE_GUID(GUID_PROP_INPUTSCOPE, 0x1713dd5a, 0x68e7, 0x4a5b, 0x9a, 0xf6, 0x59, 0x2a, 0x59, 0x5c, 0x77, 0x8d);
#ifdef __cplusplus
}
#endif  /* __cplusplus */


extern RPC_IF_HANDLE __MIDL_itf_inputscope_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_inputscope_0000_0000_v0_0_s_ifspec;

#ifndef __ITfInputScope_INTERFACE_DEFINED__
#define __ITfInputScope_INTERFACE_DEFINED__

/* interface ITfInputScope */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfInputScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("fde1eaee-6924-4cdf-91e7-da38cff5559d")
    ITfInputScope : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetInputScopes( 
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) InputScope **pprgInputScopes,
            /* [out] */ __RPC__out UINT *pcCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPhrase( 
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BSTR **ppbstrPhrases,
            /* [out] */ __RPC__out UINT *pcCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegularExpression( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrRegExp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSRGS( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSRGS) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXML( 
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrXML) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfInputScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITfInputScope * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITfInputScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITfInputScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputScopes )( 
            __RPC__in ITfInputScope * This,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) InputScope **pprgInputScopes,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhrase )( 
            __RPC__in ITfInputScope * This,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BSTR **ppbstrPhrases,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegularExpression )( 
            __RPC__in ITfInputScope * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrRegExp);
        
        HRESULT ( STDMETHODCALLTYPE *GetSRGS )( 
            __RPC__in ITfInputScope * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSRGS);
        
        HRESULT ( STDMETHODCALLTYPE *GetXML )( 
            __RPC__in ITfInputScope * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrXML);
        
        END_INTERFACE
    } ITfInputScopeVtbl;

    interface ITfInputScope
    {
        CONST_VTBL struct ITfInputScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfInputScope_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITfInputScope_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITfInputScope_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITfInputScope_GetInputScopes(This,pprgInputScopes,pcCount)	\
    ( (This)->lpVtbl -> GetInputScopes(This,pprgInputScopes,pcCount) ) 

#define ITfInputScope_GetPhrase(This,ppbstrPhrases,pcCount)	\
    ( (This)->lpVtbl -> GetPhrase(This,ppbstrPhrases,pcCount) ) 

#define ITfInputScope_GetRegularExpression(This,pbstrRegExp)	\
    ( (This)->lpVtbl -> GetRegularExpression(This,pbstrRegExp) ) 

#define ITfInputScope_GetSRGS(This,pbstrSRGS)	\
    ( (This)->lpVtbl -> GetSRGS(This,pbstrSRGS) ) 

#define ITfInputScope_GetXML(This,pbstrXML)	\
    ( (This)->lpVtbl -> GetXML(This,pbstrXML) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITfInputScope_INTERFACE_DEFINED__ */


#ifndef __ITfInputScope2_INTERFACE_DEFINED__
#define __ITfInputScope2_INTERFACE_DEFINED__

/* interface ITfInputScope2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ITfInputScope2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5731eaa0-6bc2-4681-a532-92fbb74d7c41")
    ITfInputScope2 : public ITfInputScope
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumWordList( 
            /* [out] */ __RPC__deref_out_opt IEnumString **ppEnumString) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITfInputScope2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ITfInputScope2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ITfInputScope2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ITfInputScope2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputScopes )( 
            __RPC__in ITfInputScope2 * This,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) InputScope **pprgInputScopes,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetPhrase )( 
            __RPC__in ITfInputScope2 * This,
            /* [size_is][size_is][out] */ __RPC__out_ecount_full(1) BSTR **ppbstrPhrases,
            /* [out] */ __RPC__out UINT *pcCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegularExpression )( 
            __RPC__in ITfInputScope2 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrRegExp);
        
        HRESULT ( STDMETHODCALLTYPE *GetSRGS )( 
            __RPC__in ITfInputScope2 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrSRGS);
        
        HRESULT ( STDMETHODCALLTYPE *GetXML )( 
            __RPC__in ITfInputScope2 * This,
            /* [out] */ __RPC__deref_out_opt BSTR *pbstrXML);
        
        HRESULT ( STDMETHODCALLTYPE *EnumWordList )( 
            __RPC__in ITfInputScope2 * This,
            /* [out] */ __RPC__deref_out_opt IEnumString **ppEnumString);
        
        END_INTERFACE
    } ITfInputScope2Vtbl;

    interface ITfInputScope2
    {
        CONST_VTBL struct ITfInputScope2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITfInputScope2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ITfInputScope2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ITfInputScope2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ITfInputScope2_GetInputScopes(This,pprgInputScopes,pcCount)	\
    ( (This)->lpVtbl -> GetInputScopes(This,pprgInputScopes,pcCount) ) 

#define ITfInputScope2_GetPhrase(This,ppbstrPhrases,pcCount)	\
    ( (This)->lpVtbl -> GetPhrase(This,ppbstrPhrases,pcCount) ) 

#define ITfInputScope2_GetRegularExpression(This,pbstrRegExp)	\
    ( (This)->lpVtbl -> GetRegularExpression(This,pbstrRegExp) ) 

#define ITfInputScope2_GetSRGS(This,pbstrSRGS)	\
    ( (This)->lpVtbl -> GetSRGS(This,pbstrSRGS) ) 

#define ITfInputScope2_GetXML(This,pbstrXML)	\
    ( (This)->lpVtbl -> GetXML(This,pbstrXML) ) 


#define ITfInputScope2_EnumWordList(This,ppEnumString)	\
    ( (This)->lpVtbl -> EnumWordList(This,ppEnumString) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ITfInputScope2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_inputscope_0000_0002 */
/* [local] */ 

#endif // INPUTSCOPE_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_inputscope_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_inputscope_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Instance.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  Instance.h
//
//  Purpose: Definition of CInstance class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _INSTANCE_H_
#define _INSTANCE_H_

#define WBEMINT64 CHString
#define WBEMINT16 short

///////////////////////////////////////////
//
// CLASS CInstance
//
// base instance class
// encapsulation of IWbemClassObject
///////////////////////////////////////////
class
    __declspec(uuid("3402945E-D19A-11d2-B35E-00104BC97924"))
    POLARITY CInstance
{
public:
    CInstance(__in IWbemClassObject *piClassObject, __in MethodContext *pMethodContext);
    virtual ~CInstance();

    // AddRef/Release
    LONG   AddRef( void );
    LONG   Release( void );

    // Get and Set for various data types
    bool SetNull(LPCWSTR name );
    bool SetStringArray(LPCWSTR name, const SAFEARRAY &strArray);
    bool SetWORD(LPCWSTR name,  WORD w);
    bool SetDWORD(LPCWSTR name,  DWORD d);
    bool Setbool(LPCWSTR name,  bool  b);
    bool SetVariant(LPCWSTR name,  const VARIANT& variant );
#ifdef FRAMEWORK_ALLOW_DEPRECATED
    bool SetCharSplat(LPCWSTR name,  DWORD dwResID);
#endif
    bool SetCharSplat(LPCWSTR name,  LPCWSTR pStr);
    bool SetCharSplat( LPCWSTR name,  LPCSTR pStr);
    bool SetWCHARSplat(LPCWSTR name,  LPCWSTR pStr);
    bool SetDateTime(LPCWSTR name,  const WBEMTime& wbemtime );
    bool SetTimeSpan(LPCWSTR name,  const WBEMTimeSpan& wbemtimespan );
    bool SetWBEMINT64(LPCWSTR name, const WBEMINT64& wbemint64 );
    bool SetWBEMINT64(LPCWSTR name, const LONGLONG i64Value );
    bool SetWBEMINT64( LPCWSTR name, const ULONGLONG i64Value );
    bool SetWBEMINT16(LPCWSTR name, const WBEMINT16& wbemint16 );
    bool SetByte(LPCWSTR name, BYTE b );
    bool SetEmbeddedObject (LPCWSTR name, __inout CInstance& cInstance ) ;
    bool SetDOUBLE(LPCWSTR name, DOUBLE dub );
    bool SetCHString(LPCWSTR name, LPCWSTR str);
    bool SetCHString(LPCWSTR name,  const CHString& str);
    bool SetCHString(LPCWSTR name, LPCSTR str);

    bool GetStringArray(LPCWSTR name,  SAFEARRAY *& strArray)     const;
    bool GetCHString(LPCWSTR name, CHString& str) const;
    bool GetWCHAR(LPCWSTR name,  __deref_out LPWSTR *pW) const;
    bool GetWORD(LPCWSTR name,  WORD& w) const;
    bool GetDWORD(LPCWSTR name,  DWORD& d) const;
    bool Getbool(LPCWSTR name,  bool&  b) const;
    bool GetVariant(LPCWSTR name, VARIANT& variant ) const;
    bool GetDateTime(LPCWSTR name,  WBEMTime& wbemtime ) const;
    bool GetTimeSpan(LPCWSTR name,  WBEMTimeSpan& wbemtimespan ) const;
    bool GetWBEMINT64(LPCWSTR name, WBEMINT64& wbemint64 ) const;
    bool GetWBEMINT64(LPCWSTR name, LONGLONG& i64Value ) const;
    bool GetWBEMINT64( LPCWSTR name, ULONGLONG& i64Value) const;
    bool GetWBEMINT16(LPCWSTR name, WBEMINT16& wbemint16 ) const;
    bool GetByte(LPCWSTR name, BYTE& b ) const;
    bool GetEmbeddedObject(LPCWSTR name, CInstance** pInstance,  MethodContext *pMethodContext) const;
    bool GetDOUBLE(LPCWSTR name, DOUBLE& dub) const;
    bool IsNull(LPCWSTR name) const;
    bool GetStatus(LPCWSTR name, bool &a_Exists , VARTYPE &a_VarType ) const ;

    HRESULT Commit(void);
    IWbemClassObject *GetClassObjectInterface();
    MethodContext *GetMethodContext() const;

protected:
    // All items in this section intended for Microsoft internal use only
    // use by third parties is unsupported and unrecommended
    void LogError(LPCWSTR errorStr, LPCWSTR pFunctionName, LPCWSTR pArgs = NULL, HRESULT hError = -1) const;

    IWbemClassObject *m_piClassObject;
    MethodContext*   m_pMethodContext;
    LONG             m_nRefCount;

    friend class CWbemProviderGlue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\intsafe.h ===
/******************************************************************
*                                                                 *
*  intsafe.h -- This module defines helper functions to prevent   *
*               integer overflow bugs.                            *
*                                                                 *
*  Copyright (c) Microsoft Corp.  All rights reserved.            *
*                                                                 *
******************************************************************/
#ifndef _INTSAFE_H_INCLUDED_
#define _INTSAFE_H_INCLUDED_

#if (_MSC_VER > 1000)
#pragma once
#endif

#include <specstrings.h>    // for __in, etc.

#if !defined(_W64)
#if !defined(__midl) && (defined(_X86_) || defined(_M_IX86)) && (_MSC_VER >= 1300)
#define _W64 __w64
#else
#define _W64
#endif
#endif

//
// typedefs
//
typedef char                CHAR;
typedef signed char         INT8;
typedef unsigned char       UCHAR;
typedef unsigned char       UINT8;
typedef unsigned char       BYTE;
typedef short               SHORT;
typedef signed short        INT16;
typedef unsigned short      USHORT;
typedef unsigned short      UINT16;
typedef unsigned short      WORD;
typedef int                 INT;
typedef signed int          INT32;
typedef unsigned int        UINT;
typedef unsigned int        UINT32;
typedef long                LONG;
typedef unsigned long       ULONG;
typedef unsigned long       DWORD;
typedef __int64             LONGLONG;
typedef __int64             LONG64;
typedef signed __int64      INT64;
typedef unsigned __int64    ULONGLONG;
typedef unsigned __int64    DWORDLONG;
typedef unsigned __int64    ULONG64;
typedef unsigned __int64    DWORD64;
typedef unsigned __int64    UINT64;

#if (__midl > 501)
typedef [public]          __int3264 INT_PTR;
typedef [public] unsigned __int3264 UINT_PTR;
typedef [public]          __int3264 LONG_PTR;
typedef [public] unsigned __int3264 ULONG_PTR;
#else
#ifdef _WIN64
typedef __int64             INT_PTR;
typedef unsigned __int64    UINT_PTR;
typedef __int64             LONG_PTR;
typedef unsigned __int64    ULONG_PTR;
#else
typedef _W64 int            INT_PTR;
typedef _W64 unsigned int   UINT_PTR;
typedef _W64 long           LONG_PTR;
typedef _W64 unsigned long  ULONG_PTR;
#endif // WIN64
#endif // (__midl > 501)

#ifdef _WIN64
typedef __int64             ptrdiff_t;
typedef unsigned __int64    size_t;
#else
typedef _W64 int            ptrdiff_t;
typedef _W64 unsigned int   size_t;
#endif

typedef ULONG_PTR   DWORD_PTR;
typedef LONG_PTR    SSIZE_T;
typedef ULONG_PTR   SIZE_T;

#undef _USE_INTRINSIC_MULTIPLY128

#if !defined(_M_CEE) && (defined(_AMD64_) || (defined(_IA64_) && (_MSC_VER >= 1400)))
#define _USE_INTRINSIC_MULTIPLY128
#endif

#if defined(_USE_INTRINSIC_MULTIPLY128)
#ifdef __cplusplus
extern "C" {
#endif

#define UnsignedMultiply128 _umul128

ULONG64
UnsignedMultiply128(
    __in ULONGLONG ullMultiplicand,
    __in ULONGLONG ullMultiplier,
    __out __deref_out_range(==, ullMultiplicand * ullMultiplier) ULONGLONG* pullResultHigh);
#pragma intrinsic(_umul128)

#ifdef __cplusplus
}
#endif
#endif // _USE_INTRINSIC_MULTIPLY128



typedef __success(return >= 0) long HRESULT;

#define SUCCEEDED(hr)   (((HRESULT)(hr)) >= 0)
#define FAILED(hr)      (((HRESULT)(hr)) < 0)

#define S_OK    ((HRESULT)0L)

#define INTSAFE_E_ARITHMETIC_OVERFLOW   ((HRESULT)0x80070216L)  // 0x216 = 534 = ERROR_ARITHMETIC_OVERFLOW
#ifndef SORTPP_PASS 
// compiletime asserts (failure results in error C2118: negative subscript)
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#else
#define C_ASSERT(e)
#endif

//
// UInt32x32To64 macro
//
#if defined(MIDL_PASS) || defined(RC_INVOKED) || defined(_M_CEE_PURE) \
    || defined(_68K_) || defined(_MPPC_) \
    || defined(_M_IA64) || defined(_M_AMD64)
#define UInt32x32To64(a, b) (((unsigned __int64)((unsigned int)(a))) * ((unsigned __int64)((unsigned int)(b))))
#elif defined(_M_IX86)
#define UInt32x32To64(a, b) ((unsigned __int64)(((unsigned __int64)((unsigned int)(a))) * ((unsigned int)(b))))
#else
#error Must define a target architecture.
#endif

//
// Min/Max type values
//
#define INT8_MIN        (-127i8 - 1)
#define SHORT_MIN       (-32768)
#define INT16_MIN       (-32767i16 - 1)
#define INT_MIN         (-2147483647 - 1)
#define INT32_MIN       (-2147483647i32 - 1)
#define LONG_MIN        (-2147483647L - 1)
#define LONGLONG_MIN    (-9223372036854775807i64 - 1)
#define LONG64_MIN      (-9223372036854775807i64 - 1)
#define INT64_MIN       (-9223372036854775807i64 - 1)
#define INT128_MIN      (-170141183460469231731687303715884105727i128 - 1)

#ifdef _WIN64
#define INT_PTR_MIN     (-9223372036854775807i64 - 1)
#define LONG_PTR_MIN    (-9223372036854775807i64 - 1)
#define PTRDIFF_T_MIN   (-9223372036854775807i64 - 1)
#define SSIZE_T_MIN     (-9223372036854775807i64 - 1)
#else
#define INT_PTR_MIN     (-2147483647 - 1)
#define LONG_PTR_MIN    (-2147483647L - 1)
#define PTRDIFF_T_MIN   (-2147483647 - 1)
#define SSIZE_T_MIN     (-2147483647L - 1)
#endif

#define INT8_MAX        127i8
#define UINT8_MAX       0xffui8
#define BYTE_MAX        0xff
#define SHORT_MAX       32767
#define INT16_MAX       32767i16
#define USHORT_MAX      0xffff
#define UINT16_MAX      0xffffui16
#define WORD_MAX        0xffff
#define INT_MAX         2147483647
#define INT32_MAX       2147483647i32
#define UINT_MAX        0xffffffff
#define UINT32_MAX      0xffffffffui32
#define LONG_MAX        2147483647L
#define ULONG_MAX       0xffffffffUL
#define DWORD_MAX       0xffffffffUL
#define LONGLONG_MAX    9223372036854775807i64
#define LONG64_MAX      9223372036854775807i64
#define INT64_MAX       9223372036854775807i64
#define ULONGLONG_MAX   0xffffffffffffffffui64
#define DWORDLONG_MAX   0xffffffffffffffffui64
#define ULONG64_MAX     0xffffffffffffffffui64
#define DWORD64_MAX     0xffffffffffffffffui64
#define UINT64_MAX      0xffffffffffffffffui64
#define INT128_MAX      170141183460469231731687303715884105727i128
#define UINT128_MAX     0xffffffffffffffffffffffffffffffffui128

#undef SIZE_T_MAX

#ifdef _WIN64
#define INT_PTR_MAX     9223372036854775807i64
#define UINT_PTR_MAX    0xffffffffffffffffui64
#define LONG_PTR_MAX    9223372036854775807i64
#define ULONG_PTR_MAX   0xffffffffffffffffui64
#define DWORD_PTR_MAX   0xffffffffffffffffui64
#define PTRDIFF_T_MAX   9223372036854775807i64
#define SIZE_T_MAX      0xffffffffffffffffui64
#define SSIZE_T_MAX     9223372036854775807i64
#define _SIZE_T_MAX     0xffffffffffffffffui64
#else
#define INT_PTR_MAX     2147483647 
#define UINT_PTR_MAX    0xffffffff
#define LONG_PTR_MAX    2147483647L
#define ULONG_PTR_MAX   0xffffffffUL
#define DWORD_PTR_MAX   0xffffffffUL
#define PTRDIFF_T_MAX   2147483647
#define SIZE_T_MAX      0xffffffff
#define SSIZE_T_MAX     2147483647L
#define _SIZE_T_MAX     0xffffffffUL
#endif


//
// It is common for -1 to be used as an error value
//
#define INT8_ERROR      (-1i8)
#define UINT8_ERROR     0xffui8
#define BYTE_ERROR      0xff
#define SHORT_ERROR     (-1)
#define INT16_ERROR     (-1i16)
#define USHORT_ERROR    0xffff
#define UINT16_ERROR    0xffffui16
#define WORD_ERROR      0xffff
#define INT_ERROR       (-1)
#define INT32_ERROR     (-1i32)
#define UINT_ERROR      0xffffffff
#define UINT32_ERROR    0xffffffffui32
#define LONG_ERROR      (-1L)
#define ULONG_ERROR     0xffffffffUL
#define DWORD_ERROR     0xffffffffUL
#define LONGLONG_ERROR  (-1i64)
#define LONG64_ERROR    (-1i64)
#define INT64_ERROR     (-1i64)
#define ULONGLONG_ERROR 0xffffffffffffffffui64
#define DWORDLONG_ERROR 0xffffffffffffffffui64
#define ULONG64_ERROR   0xffffffffffffffffui64
#define UINT64_ERROR    0xffffffffffffffffui64

#ifdef _WIN64
#define INT_PTR_ERROR   (-1i64)
#define UINT_PTR_ERROR  0xffffffffffffffffui64
#define LONG_PTR_ERROR  (-1i64)
#define ULONG_PTR_ERROR 0xffffffffffffffffui64
#define DWORD_PTR_ERROR 0xffffffffffffffffui64
#define PTRDIFF_T_ERROR (-1i64)
#define SIZE_T_ERROR    0xffffffffffffffffui64
#define SSIZE_T_ERROR   (-1i64)
#define _SIZE_T_ERROR   0xffffffffffffffffui64
#else
#define INT_PTR_ERROR   (-1) 
#define UINT_PTR_ERROR  0xffffffff
#define LONG_PTR_ERROR  (-1L)
#define ULONG_PTR_ERROR 0xffffffffUL
#define DWORD_PTR_ERROR 0xffffffffUL
#define PTRDIFF_T_ERROR (-1)
#define SIZE_T_ERROR    0xffffffff
#define SSIZE_T_ERROR   (-1L)
#define _SIZE_T_ERROR   0xffffffffUL
#endif


//
// We make some assumptions about the sizes of various types. Let's be
// explicit about those assumptions and check them.
//
C_ASSERT(sizeof(USHORT) == 2);
C_ASSERT(sizeof(INT) == 4);
C_ASSERT(sizeof(UINT) == 4);
C_ASSERT(sizeof(LONG) == 4);
C_ASSERT(sizeof(ULONG) == 4);
C_ASSERT(sizeof(UINT_PTR) == sizeof(ULONG_PTR));


//=============================================================================
// Conversion functions
//
// There are three reasons for having conversion functions:
//
// 1. We are converting from a signed type to an unsigned type of the same
//    size, or vice-versa.
//
//    Since we default to only having unsigned math functions,
//    (see ENABLE_INTSAFE_SIGNED_FUNCTIONS below) we prefer people to convert
//    to unsigned, do the math, and then convert back to signed.
//
// 2. We are converting to a smaller type, and we could therefore possibly
//    overflow.
//
// 3. We are converting to a bigger type, and we are signed and the type we are
//    converting to is unsigned.
//
//=============================================================================


//
// INT8 -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
Int8ToUChar(
    __in INT8 i8Operand,
    __out __deref_out_range(==, i8Operand) UCHAR* pch)
{
    HRESULT hr;

    if (i8Operand >= 0)
    {
        *pch = (UCHAR)i8Operand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT8 -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
Int8ToUInt8(
    __in INT8 i8Operand,
    __out __deref_out_range(==, i8Operand) UINT8* pu8Result)
{
    HRESULT hr;
    
    if (i8Operand >= 0)
    {
        *pu8Result = (UINT8)i8Operand;
        hr = S_OK;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT8 -> BYTE conversion
//
#define Int8ToByte  Int8ToUInt8

//
// INT8 -> USHORT conversion
//
__checkReturn
__inline
HRESULT
Int8ToUShort(
    __in INT8 i8Operand,
    __out __deref_out_range(==, i8Operand) USHORT* pusResult)
{
    HRESULT hr;
    
    if (i8Operand >= 0)
    {
        *pusResult = (USHORT)i8Operand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT8 -> UINT16 conversion
//
#define Int8ToUInt16    Int8ToUShort

//
// INT8 -> WORD conversion
//
#define Int8ToWord  Int8ToUShort

//
// INT8 -> UINT conversion
//
__checkReturn
__inline
HRESULT
Int8ToUInt(
    __in INT8 i8Operand,
    __out __deref_out_range(==, i8Operand) UINT* puResult)
{
    HRESULT hr;
    
    if (i8Operand >= 0)
    {
        *puResult = (UINT)i8Operand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT8 -> UINT32 conversion
//
#define Int8ToUInt32    Int8ToUInt

//
// INT8 -> UINT_PTR conversion
//
__checkReturn
__inline
HRESULT
Int8ToUIntPtr(
    __in INT8 i8Operand,
    __out __deref_out_range(==, i8Operand) UINT_PTR* puResult)
{
    HRESULT hr;
    
    if (i8Operand >= 0)
    {
        *puResult = (UINT_PTR)i8Operand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT8 -> ULONG conversion
//
__checkReturn
__inline
HRESULT
Int8ToULong(
    __in INT8 i8Operand,
    __out __deref_out_range(==, i8Operand) ULONG* pulResult)
{
    HRESULT hr;
    
    if (i8Operand >= 0)
    {
        *pulResult = (ULONG)i8Operand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT8 -> ULONG_PTR conversion
//
__checkReturn
__inline
HRESULT
Int8ToULongPtr(
    __in INT8 i8Operand,
    __out __deref_out_range(==, i8Operand) ULONG_PTR* pulResult)
{
    HRESULT hr;
    
    if (i8Operand >= 0)
    {
        *pulResult = (ULONG_PTR)i8Operand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT8 -> DWORD conversion
//
#define Int8ToDWord Int8ToULong

//
// INT8 -> DWORD_PTR conversion
//
#define Int8ToDWordPtr  Int8ToULongPtr

//
// INT8 -> ULONGLONG conversion
//
__checkReturn
__inline
HRESULT
Int8ToULongLong(
    __in INT8 i8Operand,
    __out __deref_out_range(==, i8Operand) ULONGLONG* pullResult)
{
    HRESULT hr;
    
    if (i8Operand >= 0)
    {
        *pullResult = (ULONGLONG)i8Operand;
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT8 -> DWORDLONG conversion
//
#define Int8ToDWordLong Int8ToULongLong

//
// INT8 -> ULONG64 conversion
//
#define Int8ToULong64   Int8ToULongLong

//
// INT8 -> DWORD64 conversion
//
#define Int8ToDWord64   Int8ToULongLong

//
// INT8 -> UINT64 conversion
//
#define Int8ToUInt64    Int8ToULongLong

//
// INT8 -> size_t conversion
//
#define Int8ToSizeT Int8ToUIntPtr

//
// INT8 -> SIZE_T conversion
//
#define Int8ToSIZET Int8ToULongPtr

//
// UINT8 -> INT8 conversion
//
__checkReturn
__inline
HRESULT
UInt8ToInt8(
    __in UINT8 u8Operand,
    __out __deref_out_range(==, u8Operand) INT8* pi8Result)
{
    HRESULT hr;
    
    if (u8Operand <= INT8_MAX)
    {
        *pi8Result = (INT8)u8Operand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT8 -> CHAR conversion
//
__forceinline
HRESULT
UInt8ToChar(
    __in UINT8 u8Operand,
    __out __deref_out_range(==, u8Operand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    *pch = (CHAR)u8Operand;
    return S_OK;
#else
    return UInt8ToInt8(u8Operand, (INT8*)pch);
#endif
}

//
// BYTE -> INT8 conversion
//
__checkReturn
__inline
HRESULT
ByteToInt8(
    __in BYTE bOperand,
    __out __deref_out_range(==, bOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if (bOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)bOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// BYTE -> CHAR conversion
//
__forceinline
HRESULT
ByteToChar(
    __in BYTE bOperand,
    __out __deref_out_range(==, bOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    *pch = (CHAR)bOperand;
    return S_OK;
#else
    return ByteToInt8(bOperand, (INT8*)pch);
#endif
}

//
// SHORT -> INT8 conversion
//
__checkReturn
__inline
HRESULT
ShortToInt8(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) INT8* pi8Result)
{
    HRESULT hr;

    if ((sOperand >= INT8_MIN) && (sOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)sOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// SHORT -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
ShortToUChar(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) UCHAR* pch)
{
    HRESULT hr;

    if ((sOperand >= 0) && (sOperand <= 255))
    {
        *pch = (UCHAR)sOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// SHORT -> CHAR conversion
//
__forceinline
HRESULT
ShortToChar(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return ShortToUChar(sOperand, (UCHAR*)pch);
#else
    return ShortToInt8(sOperand, (INT8*)pch);
#endif // _CHAR_UNSIGNED
}

//
// SHORT -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
ShortToUInt8(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) UINT8* pui8Result)
{
    HRESULT hr;

    if ((sOperand >= 0) && (sOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)sOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// SHORT -> BYTE conversion
//
#define ShortToByte  ShortToUInt8

//
// SHORT -> USHORT conversion
//
__checkReturn
__inline
HRESULT
ShortToUShort(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) USHORT* pusResult)
{
    HRESULT hr;

    if (sOperand >= 0)
    {
        *pusResult = (USHORT)sOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// SHORT -> UINT16 conversion
//
#define ShortToUInt16   ShortToUShort

//
// SHORT -> WORD conversion
//
#define ShortToWord ShortToUShort

//
// SHORT -> UINT conversion
//
__checkReturn
__inline
HRESULT
ShortToUInt(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) UINT* puResult)
{
    HRESULT hr;

    if (sOperand >= 0)
    {
        *puResult = (UINT)sOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// SHORT -> UINT32 conversion
//
#define ShortToUInt32   ShortToUInt

//
// SHORT -> UINT_PTR conversion
//
__checkReturn
__inline
HRESULT
ShortToUIntPtr(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) UINT_PTR* puResult)
{
    HRESULT hr;

    if (sOperand >= 0)
    {
        *puResult = (UINT_PTR)sOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// SHORT -> ULONG conversion
//
__checkReturn
__inline
HRESULT
ShortToULong(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) ULONG* pulResult)
{
    HRESULT hr;
    
    if (sOperand >= 0)
    {
        *pulResult = (ULONG)sOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// SHORT -> ULONG_PTR conversion
//
__checkReturn
__inline
HRESULT
ShortToULongPtr(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) ULONG_PTR* pulResult)
{
    HRESULT hr;
    
    if (sOperand >= 0)
    {
        *pulResult = (ULONG_PTR)sOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// SHORT -> DWORD conversion
//
#define ShortToDWord    ShortToULong

//
// SHORT -> DWORD_PTR conversion
//
__checkReturn
__inline
HRESULT
ShortToDWordPtr(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) DWORD_PTR* pdwResult)
{
    HRESULT hr;
    
    if (sOperand >= 0)
    {
        *pdwResult = (DWORD_PTR)sOperand;
        hr = S_OK;
    }
    else
    {
        *pdwResult = DWORD_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// SHORT -> ULONGLONG conversion
//
__checkReturn
__inline
HRESULT
ShortToULongLong(
    __in SHORT sOperand,
    __out __deref_out_range(==, sOperand) ULONGLONG* pullResult)
{
    HRESULT hr;

    if (sOperand >= 0)
    {
        *pullResult = (ULONGLONG)sOperand;
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// SHORT -> DWORDLONG conversion
//
#define ShortToDWordLong    ShortToULongLong

//
// SHORT -> ULONG64 conversion
//
#define ShortToULong64  ShortToULongLong

//
// SHORT -> DWORD64 conversion
//
#define ShortToDWord64  ShortToULongLong

//
// SHORT -> UINT64 conversion
//
#define ShortToUInt64   ShortToULongLong

//
// SHORT -> size_t conversion
//
#define ShortToSizeT    ShortToUIntPtr

//
// SHORT -> SIZE_T conversion
//
#define ShortToSIZET    ShortToULongPtr

//
// INT16 -> CHAR conversion
//
#define Int16ToChar ShortToChar

//
// INT16 -> INT8 conversion
//
#define Int16ToInt8 ShortToInt8

//
// INT16 -> UCHAR conversion
//
#define Int16ToUChar    ShortToUChar

//
// INT16 -> UINT8 conversion
//
#define Int16ToUInt8    ShortToUInt8

//
// INT16 -> BYTE conversion
//
#define Int16ToByte ShortToUInt8

//
// INT16 -> USHORT conversion
//
#define Int16ToUShort   ShortToUShort

//
// INT16 -> UINT16 conversion
//
#define Int16ToUInt16   ShortToUShort

//
// INT16 -> WORD conversion
//
#define Int16ToWord ShortToUShort

//
// INT16 -> UINT conversion
//
#define Int16ToUInt ShortToUInt

//
// INT16 -> UINT32 conversion
//
#define Int16ToUInt32   ShortToUInt

//
// INT16 -> UINT_PTR conversion
//
#define Int16ToUIntPtr  ShortToUIntPtr

//
// INT16 -> ULONG conversion
//
#define Int16ToULong    ShortToULong

//
// INT16 -> ULONG_PTR conversion
//
#define Int16ToULongPtr ShortToULongPtr

//
// INT16 -> DWORD conversion
//
#define Int16ToDWord    ShortToULong

//
// INT16 -> DWORD_PTR conversion
//
#define Int16ToDWordPtr ShortToULongPtr

//
// INT16 -> ULONGLONG conversion
//
#define Int16ToULongLong    ShortToULongLong

//
// INT16 -> DWORDLONG conversion
//
#define Int16ToDWordLong    ShortToULongLong

//
// INT16 -> ULONG64 conversion
//
#define Int16ToULong64  ShortToULongLong

//
// INT16 -> DWORD64 conversion
//
#define Int16ToDWord64  ShortToULongLong

//
// INT16 -> UINT64 conversion
//
#define Int16ToUInt64   ShortToULongLong

//
// INT16 -> size_t conversion
//
#define Int16ToSizeT    ShortToUIntPtr

//
// INT16 -> SIZE_T conversion
//
#define Int16ToSIZET    ShortToULongPtr

//
// USHORT -> INT8 conversion
//
__checkReturn
__inline
HRESULT
UShortToInt8(
    __in USHORT usOperand,
    __out __deref_out_range(==, usOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if (usOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)usOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// USHORT -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
UShortToUChar(
    __in USHORT usOperand,
    __out __deref_out_range(==, usOperand) UCHAR* pch)
{
    HRESULT hr;

    if (usOperand <= 255)
    {
        *pch = (UCHAR)usOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// USHORT -> CHAR conversion
//
__forceinline
HRESULT
UShortToChar(
    __in USHORT usOperand,
    __out __deref_out_range(==, usOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return UShortToUChar(usOperand, (UCHAR*)pch);
#else
    return UShortToInt8(usOperand, (INT8*)pch);
#endif // _CHAR_UNSIGNED
}

//
// USHORT -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
UShortToUInt8(
    __in USHORT usOperand,
    __out __deref_out_range(==, usOperand) UINT8* pui8Result)
{
    HRESULT hr;
    
    if (usOperand <= UINT8_MAX)
    {
        *pui8Result = (UINT8)usOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// USHORT -> BYTE conversion
//
#define UShortToByte    UShortToUInt8

//
// USHORT -> SHORT conversion
//
__checkReturn
__inline
HRESULT
UShortToShort(
    __in USHORT usOperand,
    __out __deref_out_range(==, usOperand) SHORT* psResult)
{
    HRESULT hr;

    if (usOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)usOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// USHORT -> INT16 conversion
//
#define UShortToInt16   UShortToShort

//
// UINT16 -> CHAR conversion
//
#define UInt16ToChar    UShortToChar

//
// UINT16 -> INT8 conversion
//
#define UInt16ToInt8    UShortToInt8

//
// UINT16 -> UCHAR conversion
//
#define UInt16ToUChar   UShortToUChar

//
// UINT16 -> UINT8 conversion
//
#define UInt16ToUInt8   UShortToUInt8

//
// UINT16 -> BYTE conversion
//
#define UInt16ToByte    UShortToUInt8

//
// UINT16 -> SHORT conversion
//
#define UInt16ToShort   UShortToShort

//
// UINT16 -> INT16 conversion
//
#define UInt16ToInt16   UShortToShort

//
// WORD -> INT8 conversion
//
#define WordToInt8  UShortToInt8

//
// WORD -> CHAR conversion
//
#define WordToChar  UShortToChar

//
// WORD -> UCHAR conversion
//
#define WordToUChar UShortToUChar

//
// WORD -> UINT8 conversion
//
#define WordToUInt8 UShortToUInt8

//
// WORD -> BYTE conversion
//
#define WordToByte  UShortToUInt8

//
// WORD -> SHORT conversion
//
#define WordToShort UShortToShort

//
// WORD -> INT16 conversion
//
#define WordToInt16 UShortToShort

//
// INT -> INT8 conversion
//
__checkReturn
__inline
HRESULT
IntToInt8(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if ((iOperand >= INT8_MIN) && (iOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)iOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
IntToUChar(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) UCHAR* pch)
{
    HRESULT hr;

    if ((iOperand >= 0) && (iOperand <= 255))
    {
        *pch = (UCHAR)iOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT -> CHAR conversion
//
__forceinline
HRESULT
IntToChar(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return IntToUChar(iOperand, (UCHAR*)pch);
#else
    return IntToInt8(iOperand, (INT8*)pch);
#endif // _CHAR_UNSIGNED
}

//
// INT -> BYTE conversion
//
#define IntToByte   IntToUInt8

//
// INT -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
IntToUInt8(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) UINT8* pui8Result)
{
    HRESULT hr;
    
    if ((iOperand >= 0) && (iOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)iOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT -> SHORT conversion
//
__checkReturn
__inline
HRESULT
IntToShort(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) SHORT* psResult)
{
    HRESULT hr;

    if ((iOperand >= SHORT_MIN) && (iOperand <= SHORT_MAX))
    {
        *psResult = (SHORT)iOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT -> INT16 conversion
//
#define IntToInt16  IntToShort

//
// INT -> USHORT conversion
//
__checkReturn
__inline
HRESULT
IntToUShort(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) USHORT* pusResult)
{
    HRESULT hr;

    if ((iOperand >= 0) && (iOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)iOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT -> UINT16 conversion
//
#define IntToUInt16  IntToUShort

//
// INT -> WORD conversion
//
#define IntToWord   IntToUShort

//
// INT -> UINT conversion
//
__checkReturn
__inline
HRESULT
IntToUInt(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) UINT* puResult)
{
    HRESULT hr;

    if (iOperand >= 0)
    {
        *puResult = (UINT)iOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT -> UINT_PTR conversion
//
#ifdef _WIN64
#define IntToUIntPtr    IntToULongLong
#else
#define IntToUIntPtr    IntToUInt
#endif

//
// INT -> ULONG conversion
//
__checkReturn
__inline
HRESULT
IntToULong(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) ULONG* pulResult)
{
    HRESULT hr;

    if (iOperand >= 0)
    {
        *pulResult = (ULONG)iOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT -> ULONG_PTR conversion
//
#ifdef _WIN64
#define IntToULongPtr   IntToULongLong
#else
#define IntToULongPtr   IntToULong
#endif

//
// INT -> DWORD conversion
//
#define IntToDWord  IntToULong

//
// INT -> DWORD_PTR conversion
//
#define IntToDWordPtr   IntToULongPtr

//
// INT -> ULONGLONG conversion
//
__checkReturn
__inline
HRESULT
IntToULongLong(
    __in INT iOperand,
    __out __deref_out_range(==, iOperand) ULONGLONG* pullResult)
{
    HRESULT hr;

    if (iOperand >= 0)
    {
        *pullResult = (ULONGLONG)iOperand;
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT -> DWORDLONG conversion
//
#define IntToDWordLong  IntToULongLong

//
// INT -> ULONG64 conversion
//
#define IntToULong64    IntToULongLong

//
// INT -> DWORD64 conversion
//
#define IntToDWord64    IntToULongLong

//
// INT -> UINT64 conversion
//
#define IntToUInt64 IntToULongLong

//
// INT -> size_t conversion
//
#define IntToSizeT  IntToUIntPtr

//
// INT -> SIZE_T conversion
//
#define IntToSIZET  IntToULongPtr

//
// INT32 -> CHAR conversion
//
#define Int32ToChar IntToChar

//
// INT32 -> INT328 conversion
//
#define Int32ToInt8 IntToInt8

//
// INT32 -> UCHAR conversion
//
#define Int32ToUChar    IntToUChar

//
// INT32 -> BYTE conversion
//
#define Int32ToByte IntToUInt8

//
// INT32 -> UINT8 conversion
//
#define Int32ToUInt8    IntToUInt8

//
// INT32 -> SHORT conversion
//
#define Int32ToShort    IntToShort

//
// INT32 -> INT16 conversion
//
#define Int32ToInt16    IntToShort

//
// INT32 -> USHORT conversion
//
#define Int32ToUShort   IntToUShort

//
// INT32 -> UINT16 conversion
//
#define Int32ToUInt16   IntToUShort

//
// INT32 -> WORD conversion
//
#define Int32ToWord IntToUShort

//
// INT32 -> UINT conversion
//
#define Int32ToUInt IntToUInt

//
// INT32 -> UINT32 conversion
//
#define Int32ToUInt32   IntToUInt

//
// INT32 -> UINT_PTR conversion
//
#define Int32ToUIntPtr  IntToUIntPtr

//
// INT32 -> ULONG conversion
//
#define Int32ToULong    IntToULong

//
// INT32 -> ULONG_PTR conversion
//
#define Int32ToULongPtr IntToULongPtr

//
// INT32 -> DWORD conversion
//
#define Int32ToDWord    IntToULong

//
// INT32 -> DWORD_PTR conversion
//
#define Int32ToDWordPtr IntToULongPtr

//
// INT32 -> ULONGLONG conversion
//
#define Int32ToULongLong    IntToULongLong

//
// INT32 -> DWORDLONG conversion
//
#define Int32ToDWordLong    IntToULongLong

//
// INT32 -> ULONG64 conversion
//
#define Int32ToULong64  IntToULongLong

//
// INT32 -> DWORD64 conversion
//
#define Int32ToDWord64  IntToULongLong

//
// INT32 -> UINT64 conversion
//
#define Int32ToUInt64   IntToULongLong

//
// INT32 -> size_t conversion
//
#define Int32ToSizeT    IntToUIntPtr

//
// INT32 -> SIZE_T conversion
//
#define Int32ToSIZET    IntToULongPtr

//
// INT_PTR -> INT8 conversion
//
__checkReturn
__inline
HRESULT
IntPtrToInt8(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if ((iOperand >= INT8_MIN) && (iOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)iOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT_PTR -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
IntPtrToUChar(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) UCHAR* pch)
{
    HRESULT hr;

    if ((iOperand >= 0) && (iOperand <= 255))
    {
        *pch = (UCHAR)iOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT_PTR -> CHAR conversion
//
__forceinline
HRESULT
IntPtrToChar(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return IntPtrToUChar(iOperand, (UCHAR*)pch);
#else
    return IntPtrToInt8(iOperand, (INT8*)pch);
#endif // _CHAR_UNSIGNED
}

//
// INT_PTR -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
IntPtrToUInt8(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) UINT8* pui8Result)
{
    HRESULT hr;
    
    if ((iOperand >= 0) && (iOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)iOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// INT_PTR -> BYTE conversion
//
#define IntPtrToByte    IntPtrToUInt8

//
// INT_PTR -> SHORT conversion
//
__checkReturn
__inline
HRESULT
IntPtrToShort(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) SHORT* psResult)
{
    HRESULT hr;

    if ((iOperand >= SHORT_MIN) && (iOperand <= SHORT_MAX))
    {
        *psResult = (SHORT)iOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT_PTR -> INT16 conversion
//
#define IntPtrToInt16   IntPtrToShort

//
// INT_PTR -> USHORT conversion
//
__checkReturn
__inline
HRESULT
IntPtrToUShort(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) USHORT* pusResult)
{
    HRESULT hr;

    if ((iOperand >= 0) && (iOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)iOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// INT_PTR -> UINT16 conversion
//
#define IntPtrToUInt16  IntPtrToUShort

//
// INT_PTR -> WORD conversion
//
#define IntPtrToWord    IntPtrToUShort

//
// INT_PTR -> INT conversion
//
#ifdef _WIN64
#define IntPtrToInt LongLongToInt
#else
__checkReturn
__inline
HRESULT
IntPtrToInt(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) INT* piResult)
{
    *piResult = (INT)iOperand;
    return S_OK;
}
#endif

//
// INT_PTR -> INT32 conversion
//
#define IntPtrToInt32   IntPtrToInt

//
// INT_PTR -> UINT conversion
//
#ifdef _WIN64
#define IntPtrToUInt    LongLongToUInt
#else
__checkReturn
__inline
HRESULT
IntPtrToUInt(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) UINT* puResult)
{
    HRESULT hr;

    if (iOperand >= 0)
    {
        *puResult = (UINT)iOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}
#endif

//
// INT_PTR -> UINT32 conversion
//
#define IntPtrToUInt32  IntPtrToUInt

//
// INT_PTR -> UINT_PTR conversion
//
#ifdef _WIN64
#define IntPtrToUIntPtr LongLongToULongLong
#else
__checkReturn
__inline
HRESULT
IntPtrToUIntPtr(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) UINT_PTR* puResult)
{
    HRESULT hr;

    if (iOperand >= 0)
    {
        *puResult = (UINT_PTR)iOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}
#endif

//
// INT_PTR -> LONG conversion
//
#ifdef _WIN64
#define IntPtrToLong    LongLongToLong
#else
__checkReturn
__inline
HRESULT
IntPtrToLong(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) LONG* plResult)
{
    *plResult = (LONG)iOperand;
    return S_OK;
}
#endif

//
// INT_PTR -> LONG_PTR conversion
//
__checkReturn
__inline
HRESULT
IntPtrToLongPtr(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) LONG_PTR* plResult)
{
    *plResult = (LONG_PTR)iOperand;
    return S_OK;
}

//
// INT_PTR -> ULONG conversion
//
#ifdef _WIN64
#define IntPtrToULong   LongLongToULong
#else
__checkReturn
__inline
HRESULT
IntPtrToULong(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) ULONG* pulResult)
{
    HRESULT hr;

    if (iOperand >= 0)
    {
        *pulResult = (ULONG)iOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}
#endif

//
// INT_PTR -> ULONG_PTR conversion
//
#ifdef _WIN64
#define IntPtrToULongPtr    LongLongToULongLong
#else
__checkReturn
__inline
HRESULT
IntPtrToULongPtr(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) ULONG_PTR* pulResult)
{
    HRESULT hr;

    if (iOperand >= 0)
    {
        *pulResult = (ULONG_PTR)iOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}
#endif

//
// INT_PTR -> DWORD conversion
//
#define IntPtrToDWord   IntPtrToULong

//    
// INT_PTR -> DWORD_PTR conversion
//
#define IntPtrToDWordPtr    IntPtrToULongPtr

//
// INT_PTR -> ULONGLONG conversion
//
#ifdef _WIN64
#define IntPtrToULongLong   LongLongToULongLong
#else
__checkReturn
__inline
HRESULT
IntPtrToULongLong(
    __in INT_PTR iOperand,
    __out __deref_out_range(==, iOperand) ULONGLONG* pullResult)
{
    HRESULT hr;

    if (iOperand >= 0)
    {
        *pullResult = (ULONGLONG)iOperand;
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}   
#endif

//
// INT_PTR -> DWORDLONG conversion
//
#define IntPtrToDWordLong   IntPtrToULongLong

//
// INT_PTR -> ULONG64 conversion
//
#define IntPtrToULong64 IntPtrToULongLong

//
// INT_PTR -> DWORD64 conversion
//
#define IntPtrToDWord64 IntPtrToULongLong

//
// INT_PTR -> UINT64 conversion
//
#define IntPtrToUInt64  IntPtrToULongLong

//
// INT_PTR -> size_t conversion
//
#define IntPtrToSizeT   IntPtrToUIntPtr

//
// INT_PTR -> SIZE_T conversion
//
#define IntPtrToSIZET   IntPtrToULongPtr

//
// UINT -> INT8 conversion
//
__checkReturn
__inline
HRESULT
UIntToInt8(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if (uOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)uOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}    

//
// UINT -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
UIntToUChar(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) UCHAR* pch)
{
    HRESULT hr;

    if (uOperand <= 255)
    {
        *pch = (UCHAR)uOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// UINT -> CHAR conversion
//
__forceinline
HRESULT
UIntToChar(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return UIntToUChar(uOperand, (UCHAR*)pch);
#else
    return UIntToInt8(uOperand, (INT8*)pch);
#endif
}

//
// UINT -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
UIntToUInt8(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) UINT8* pui8Result)
{
    HRESULT hr;
    
    if (uOperand <= UINT8_MAX)
    {
        *pui8Result = (UINT8)uOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}    
    
//
// UINT -> BYTE conversion
//
#define UIntToByte   UIntToUInt8

//
// UINT -> SHORT conversion
//
__checkReturn
__inline
HRESULT
UIntToShort(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) SHORT* psResult)
{
    HRESULT hr;

    if (uOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)uOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// UINT -> INT16 conversion
//
#define UIntToInt16 UIntToShort

//
// UINT -> USHORT conversion
//
__checkReturn
__inline
HRESULT
UIntToUShort(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) USHORT* pusResult)
{
    HRESULT hr;

    if (uOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)uOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// UINT -> UINT16 conversion
//
#define UIntToUInt16    UIntToUShort

//
// UINT -> WORD conversion
//
#define UIntToWord  UIntToUShort

//
// UINT -> INT conversion
//
__checkReturn
__inline
HRESULT
UIntToInt(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) INT* piResult)
{
    HRESULT hr;

    if (uOperand <= INT_MAX)
    {
        *piResult = (INT)uOperand;
        hr = S_OK;
    }
    else
    {
        *piResult = INT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// UINT -> INT32 conversion
//
#define UIntToInt32 UIntToInt

//
// UINT -> INT_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
UIntToIntPtr(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) INT_PTR* piResult)
{
    *piResult = uOperand;
    return S_OK;
}
#else
#define UIntToIntPtr    UIntToInt
#endif

//
// UINT -> LONG conversion
//
__checkReturn
__inline
HRESULT
UIntToLong(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) LONG* plResult)
{
    HRESULT hr;

    if (uOperand <= LONG_MAX)
    {
        *plResult = (LONG)uOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT -> LONG_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
UIntToLongPtr(
    __in UINT uOperand,
    __out __deref_out_range(==, uOperand) LONG_PTR* plResult)
{
    *plResult = uOperand;
    return S_OK;
}
#else
#define UIntToLongPtr   UIntToLong
#endif

//
// UINT -> ptrdiff_t conversion
//
#define UIntToPtrdiffT  UIntToIntPtr

//
// UINT -> SSIZE_T conversion
//
#define UIntToSSIZET    UIntToLongPtr

//
// UINT32 -> CHAR conversion
//
#define UInt32ToChar    UIntToChar

//
// UINT32 -> INT8 conversion
//
#define UInt32ToInt8    UIntToInt8

//
// UINT32 -> UCHAR conversion
//
#define UInt32ToUChar   UIntToUChar

//
// UINT32 -> UINT8 conversion
//
#define UInt32ToUInt8   UIntToUInt8

//
// UINT32 -> BYTE conversion
//
#define UInt32ToByte    UInt32ToUInt8

//
// UINT32 -> SHORT conversion
//
#define UInt32ToShort   UIntToShort

//
// UINT32 -> INT16 conversion
//
#define UInt32ToInt16   UIntToShort

//
// UINT32 -> USHORT conversion
//
#define UInt32ToUShort  UIntToUShort

//
// UINT32 -> UINT16 conversion
//
#define UInt32ToUInt16  UIntToUShort

//
// UINT32 -> WORD conversion
//
#define UInt32ToWord    UIntToUShort

//
// UINT32 -> INT conversion
//
#define UInt32ToInt UIntToInt

//
// UINT32 -> INT_PTR conversion
//
#define UInt32ToIntPtr  UIntToIntPtr

//
// UINT32 -> INT32 conversion
//
#define UInt32ToInt32   UIntToInt

//
// UINT32 -> LONG conversion
//
#define UInt32ToLong    UIntToLong

//
// UINT32 -> LONG_PTR conversion
//
#define UInt32ToLongPtr UIntToLongPtr

//
// UINT32 -> ptrdiff_t conversion
//
#define UInt32ToPtrdiffT    UIntToPtrdiffT

//
// UINT32 -> SSIZE_T conversion
//
#define UInt32ToSSIZET  UIntToSSIZET

//
// UINT_PTR -> INT8 conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToInt8(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if (uOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)uOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT_PTR -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToUChar(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) UCHAR* pch)
{
    HRESULT hr;

    if (uOperand <= 255)
    {
        *pch = (UCHAR)uOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// UINT_PTR -> CHAR conversion
//
__forceinline
HRESULT
UIntPtrToChar(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return UIntPtrToUChar(uOperand, (UCHAR*)pch);
#else
    return UIntPtrToInt8(uOperand, (INT8*)pch);
#endif
}

//
// UINT_PTR -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToUInt8(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==,uOperand) UINT8* pu8Result)
{
    HRESULT hr;
    
    if (uOperand <= UINT8_MAX)
    {
        *pu8Result = (UINT8)uOperand;
        hr = S_OK;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT_PTR -> BYTE conversion
//
#define UIntPtrToByte   UIntPtrToUInt8

//
// UINT_PTR -> SHORT conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToShort(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) SHORT* psResult)
{
    HRESULT hr;

    if (uOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)uOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr; 
}

//
// UINT_PTR -> INT16 conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToInt16(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) INT16* pi16Result)
{
    HRESULT hr;
    
    if (uOperand <= INT16_MAX)
    {
        *pi16Result = (INT16)uOperand;
        hr = S_OK;
    }
    else
    {
        *pi16Result = INT16_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT_PTR -> USHORT conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToUShort(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) USHORT* pusResult)
{
    HRESULT hr;

    if (uOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)uOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// UINT_PTR -> UINT16 conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToUInt16(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) UINT16* pu16Result)
{
    HRESULT hr;
    
    if (uOperand <= UINT16_MAX)
    {
        *pu16Result = (UINT16)uOperand;
        hr = S_OK;
    }
    else
    {
        *pu16Result = UINT16_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT_PTR -> WORD conversion
//
#define UIntPtrToWord   UIntPtrToUShort

//
// UINT_PTR -> INT conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToInt(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) INT* piResult)
{
    HRESULT hr;

    if (uOperand <= INT_MAX)
    {
        *piResult = (INT)uOperand;
        hr = S_OK;
    }
    else
    {
        *piResult = INT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// UINT_PTR -> INT32 conversion
//
#define UIntPtrToInt32  UIntPtrToInt

//
// UINT_PTR -> INT_PTR conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToIntPtr(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) INT_PTR* piResult)
{
    HRESULT hr;

    if (uOperand <= INT_PTR_MAX)
    {
        *piResult = (INT_PTR)uOperand;
        hr = S_OK;
    }
    else
    {
        *piResult = INT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// UINT_PTR -> UINT conversion
//
#ifdef _WIN64
#define UIntPtrToUInt   ULongLongToUInt
#else
__checkReturn
__inline
HRESULT
UIntPtrToUInt(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) UINT* puResult)
{
    *puResult = (UINT)uOperand;
    return S_OK;
}
#endif

//
// UINT_PTR -> UINT32 conversion
//
#define UIntPtrToUInt32 UIntPtrToUInt

//
// UINT_PTR -> LONG conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToLong(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) LONG* plResult)
{
    HRESULT hr;

    if (uOperand <= LONG_MAX)
    {
        *plResult = (LONG)uOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT_PTR -> LONG_PTR conversion
//
__checkReturn
__inline
HRESULT
UIntPtrToLongPtr(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) LONG_PTR* plResult)
{
    HRESULT hr;

    if (uOperand <= LONG_PTR_MAX)
    {
        *plResult = (LONG_PTR)uOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT_PTR -> ULONG conversion
//
#ifdef _WIN64
#define UIntPtrToULong  ULongLongToULong
#else
__checkReturn
__inline
HRESULT
UIntPtrToULong(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) ULONG* pulResult)
{
    *pulResult = (ULONG)uOperand;
    return S_OK;
}
#endif

//
// UINT_PTR -> DWORD conversion
//
#define UIntPtrToDWord  UIntPtrToULong

//
// UINT_PTR -> LONGLONG conversion
//
#ifdef _WIN64
#define UIntPtrToLongLong   ULongLongToLongLong
#else
__checkReturn
__inline
HRESULT
UIntPtrToLongLong(
    __in UINT_PTR uOperand,
    __out __deref_out_range(==, uOperand) LONGLONG* pllResult)
{
    *pllResult = (LONGLONG)uOperand;
    return S_OK;
}
#endif

//
// UINT_PTR -> LONG64 conversion
//
#define UIntPtrToLong64 UIntPtrToLongLong

//
// UINT_PTR -> INT64 conversion
//
#define UIntPtrToInt64  UIntPtrToLongLong

//
// UINT_PTR -> ptrdiff_t conversion
//
#define UIntPtrToPtrdiffT   UIntPtrToIntPtr

//
// UINT_PTR -> SSIZE_T conversion
//
#define UIntPtrToSSIZET UIntPtrToLongPtr

//
// LONG -> INT8 conversion
//
__checkReturn
__inline
HRESULT
LongToInt8(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if ((lOperand >= INT8_MIN) && (lOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)lOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
LongToUChar(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) UCHAR* pch)
{
    HRESULT hr;

    if ((lOperand >= 0) && (lOperand <= 255))
    {
        *pch = (UCHAR)lOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// LONG -> CHAR conversion
//
__forceinline
HRESULT
LongToChar(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return LongToUChar(lOperand, (UCHAR*)pch);
#else
    return LongToInt8(lOperand, (INT8*)pch);
#endif
}

//
// LONG -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
LongToUInt8(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) UINT8* pui8Result)
{
    HRESULT hr;
    
    if ((lOperand >= 0) && (lOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)lOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG -> BYTE conversion
//
#define LongToByte  LongToUInt8

//
// LONG -> SHORT conversion
//
__checkReturn
__inline
HRESULT
LongToShort(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) SHORT* psResult)
{
    HRESULT hr;
     
    if ((lOperand >= SHORT_MIN) && (lOperand <= SHORT_MAX))
    {
       *psResult = (SHORT)lOperand;
       hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
     
    return hr;
}

//
// LONG -> INT16 conversion
//
#define LongToInt16 LongToShort

//
// LONG -> USHORT conversion
//
__checkReturn
__inline
HRESULT
LongToUShort(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) USHORT* pusResult)
{
    HRESULT hr;
    
    if ((lOperand >= 0) && (lOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)lOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG -> UINT16 conversion
//
#define LongToUInt16    LongToUShort

//   
// LONG -> WORD conversion
//
#define LongToWord  LongToUShort

//
// LONG -> INT conversion
//
__checkReturn
__inline
HRESULT
LongToInt(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) INT* piResult)
{
    C_ASSERT(sizeof(INT) == sizeof(LONG));
    *piResult = (INT)lOperand;
    return S_OK;
}

//
// LONG -> INT32 conversion
//
#define LongToInt32 LongToInt

//
// LONG -> INT_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
LongToIntPtr(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) INT_PTR* piResult)
{
    *piResult = lOperand;
    return S_OK;
}
#else
#define LongToIntPtr    LongToInt
#endif

//
// LONG -> UINT conversion
//
__checkReturn
__inline
HRESULT
LongToUInt(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) UINT* puResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT)lOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG -> UINT32 conversion
//
#define LongToUInt32    LongToUInt

//
// LONG -> UINT_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
LongToUIntPtr(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) UINT_PTR* puResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT_PTR)lOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#else
#define LongToUIntPtr   LongToUInt
#endif

//
// LONG -> ULONG conversion
//
__checkReturn
__inline
HRESULT
LongToULong(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) ULONG* pulResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG)lOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG -> ULONG_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
LongToULongPtr(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) ULONG_PTR* pulResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG_PTR)lOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#else
#define LongToULongPtr  LongToULong
#endif

//
// LONG -> DWORD conversion
//
#define LongToDWord LongToULong

//
// LONG -> DWORD_PTR conversion
//
#define LongToDWordPtr  LongToULongPtr

//
// LONG -> ULONGLONG conversion
//
__checkReturn
__inline
HRESULT
LongToULongLong(
    __in LONG lOperand,
    __out __deref_out_range(==, lOperand) ULONGLONG* pullResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *pullResult = (ULONGLONG)lOperand;
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG -> DWORDLONG conversion
//
#define LongToDWordLong LongToULongLong

//
// LONG -> ULONG64 conversion
//
#define LongToULong64   LongToULongLong

//
// LONG -> DWORD64 conversion
//
#define LongToDWord64   LongToULongLong

//
// LONG -> UINT64 conversion
//
#define LongToUInt64    LongToULongLong

//
// LONG -> ptrdiff_t conversion
//
#define LongToPtrdiffT  LongToIntPtr

//
// LONG -> size_t conversion
//
#define LongToSizeT LongToUIntPtr

//
// LONG -> SIZE_T conversion
//
#define LongToSIZET LongToULongPtr

//
// LONG_PTR -> INT8 conversion
//
__checkReturn
__inline
HRESULT
LongPtrToInt8(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if ((lOperand >= INT8_MIN) && (lOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)lOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG_PTR -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
LongPtrToUChar(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) UCHAR* pch)
{
    HRESULT hr;
    
    if ((lOperand >= 0) && (lOperand <= 255))
    {
        *pch = (UCHAR)lOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG_PTR -> CHAR conversion
//
__forceinline
HRESULT
LongPtrToChar(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return LongPtrToUChar(lOperand, (UCHAR*)pch);
#else
    return LongPtrToInt8(lOperand, (INT8*)pch);
#endif
}

//
// LONG_PTR -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
LongPtrToUInt8(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) UINT8* pui8Result)
{
    HRESULT hr;
    
    if ((lOperand >= 0) && (lOperand <= UINT8_MAX))
    {
        *pui8Result = (UINT8)lOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG_PTR -> BYTE conversion
//
#define LongPtrToByte   LongPtrToUInt8

//
// LONG_PTR -> SHORT conversion
//
__checkReturn
__inline
HRESULT
LongPtrToShort(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) SHORT* psResult)
{
    HRESULT hr;
    
    if ((lOperand >= SHORT_MIN) && (lOperand <= SHORT_MAX))
    {
        *psResult = (SHORT)lOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}    

//
// LONG_PTR -> INT16 conversion
//
#define LongPtrToInt16  LongPtrToShort

//
// LONG_PTR -> USHORT conversion
//
__checkReturn
__inline
HRESULT
LongPtrToUShort(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) USHORT* pusResult)
{
    HRESULT hr;
    
    if ((lOperand >= 0) && (lOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)lOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG_PTR -> UINT16 conversion
//
#define LongPtrToUInt16 LongPtrToUShort

//
// LONG_PTR -> WORD conversion
//
#define LongPtrToWord   LongPtrToUShort

//
// LONG_PTR -> INT conversion
//
#ifdef _WIN64
#define LongPtrToInt    LongLongToInt
#else
__checkReturn
__inline
HRESULT
LongPtrToInt(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) INT* piResult)
{
    C_ASSERT(sizeof(INT) == sizeof(LONG_PTR));
    *piResult = (INT)lOperand;
    return S_OK;
}   
#endif

//
// LONG_PTR -> INT32 conversion
//
#define LongPtrToInt32  LongPtrToInt

//
// LONG_PTR -> INT_PTR conversion
//
__checkReturn
__inline
HRESULT
LongPtrToIntPtr(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) INT_PTR* piResult)
{
    C_ASSERT(sizeof(LONG_PTR) == sizeof(INT_PTR));
    *piResult = (INT_PTR)lOperand;
    return S_OK;
}

//
// LONG_PTR -> UINT conversion
//
#ifdef _WIN64
#define LongPtrToUInt   LongLongToUInt
#else
__checkReturn
__inline
HRESULT
LongPtrToUInt(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) UINT* puResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT)lOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif

//
// LONG_PTR -> UINT32 conversion
//
#define LongPtrToUInt32 LongPtrToUInt

//
// LONG_PTR -> UINT_PTR conversion
//
__checkReturn
__inline
HRESULT
LongPtrToUIntPtr(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) UINT_PTR* puResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *puResult = (UINT_PTR)lOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG_PTR -> LONG conversion
//
#ifdef _WIN64
#define LongPtrToLong   LongLongToLong
#else
__checkReturn
__inline
HRESULT
LongPtrToLong(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) LONG* plResult)
{
    *plResult = (LONG)lOperand;
    return S_OK;
}
#endif

//    
// LONG_PTR -> ULONG conversion
//
#ifdef _WIN64
#define LongPtrToULong  LongLongToULong
#else
__checkReturn
__inline
HRESULT
LongPtrToULong(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) ULONG* pulResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG)lOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif

//
// LONG_PTR -> ULONG_PTR conversion
//
__checkReturn
__inline
HRESULT
LongPtrToULongPtr(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) ULONG_PTR* pulResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *pulResult = (ULONG_PTR)lOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG_PTR -> DWORD conversion
//
#define LongPtrToDWord  LongPtrToULong

//
// LONG_PTR -> DWORD_PTR conversion
//
#define LongPtrToDWordPtr   LongPtrToULongPtr 

//
// LONG_PTR -> ULONGLONG conversion
//
__checkReturn
__inline
HRESULT
LongPtrToULongLong(
    __in LONG_PTR lOperand,
    __out __deref_out_range(==, lOperand) ULONGLONG* pullResult)
{
    HRESULT hr;
    
    if (lOperand >= 0)
    {
        *pullResult = (ULONGLONG)lOperand;
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONG_PTR -> DWORDLONG conversion
//
#define LongPtrToDWordLong  LongPtrToULongLong

//
// LONG_PTR -> ULONG64 conversion
//
#define LongPtrToULong64    LongPtrToULongLong

//
// LONG_PTR -> DWORD64 conversion
//
#define LongPtrToDWord64    LongPtrToULongLong

//
// LONG_PTR -> UINT64 conversion
//
#define LongPtrToUInt64 LongPtrToULongLong

//
// LONG_PTR -> size_t conversion
//
#define LongPtrToSizeT  LongPtrToUIntPtr

//
// LONG_PTR -> SIZE_T conversion
//
#define LongPtrToSIZET  LongPtrToULongPtr

//
// ULONG -> INT8 conversion
//
__checkReturn
__inline
HRESULT
ULongToInt8(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if (ulOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)ulOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
ULongToUChar(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) UCHAR* pch)
{
    HRESULT hr;

    if (ulOperand <= 255)
    {
        *pch = (UCHAR)ulOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// ULONG -> CHAR conversion
//
__forceinline
HRESULT
ULongToChar(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return ULongToUChar(ulOperand, (UCHAR*)pch);
#else
    return ULongToInt8(ulOperand, (INT8*)pch);
#endif
}

//
// ULONG -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
ULongToUInt8(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) UINT8* pui8Result)
{
    HRESULT hr;
    
    if (ulOperand <= UINT8_MAX)
    {
        *pui8Result = (UINT8)ulOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}    

//
// ULONG -> BYTE conversion
//
#define ULongToByte ULongToUInt8

//
// ULONG -> SHORT conversion
//
__checkReturn
__inline
HRESULT
ULongToShort(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) SHORT* psResult)
{
    HRESULT hr;

    if (ulOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)ulOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// ULONG -> INT16 conversion
//
#define ULongToInt16    ULongToShort

//
// ULONG -> USHORT conversion
//
__checkReturn
__inline
HRESULT
ULongToUShort(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) USHORT* pusResult)
{
    HRESULT hr;

    if (ulOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)ulOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// ULONG -> UINT16 conversion
//
#define ULongToUInt16   ULongToUShort

//
// ULONG -> WORD conversion
//
#define ULongToWord ULongToUShort

//
// ULONG -> INT conversion
//
__checkReturn
__inline
HRESULT
ULongToInt(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) INT* piResult)
{
    HRESULT hr;
    
    if (ulOperand <= INT_MAX)
    {
        *piResult = (INT)ulOperand;
        hr = S_OK;
    }
    else
    {
        *piResult = INT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG -> INT32 conversion
//
#define ULongToInt32    ULongToInt

//
// ULONG -> INT_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
ULongToIntPtr(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) INT_PTR* piResult)
{
    *piResult = (INT_PTR)ulOperand;
    return S_OK;
}
#else
#define ULongToIntPtr   ULongToInt
#endif

//
// ULONG -> UINT conversion
//
__checkReturn
__inline
HRESULT
ULongToUInt(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) UINT* puResult)
{
    C_ASSERT(sizeof(ULONG) == sizeof(UINT));
    *puResult = (UINT)ulOperand;    
    return S_OK;
}

//
// ULONG -> UINT32 conversion
//
#define ULongToUInt32   ULongToUInt

//
// ULONG -> UINT_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
ULongToUIntPtr(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) UINT_PTR* puiResult)
{
    C_ASSERT(sizeof(UINT_PTR) > sizeof(ULONG));
    *puiResult = (UINT_PTR)ulOperand;
    return S_OK;
}
#else
#define ULongToUIntPtr  ULongToUInt
#endif

//
// ULONG -> LONG conversion
//
__checkReturn
__inline
HRESULT
ULongToLong(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) LONG* plResult)
{
    HRESULT hr;
    
    if (ulOperand <= LONG_MAX)
    {
        *plResult = (LONG)ulOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG -> LONG_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
ULongToLongPtr(
    __in ULONG ulOperand,
    __out __deref_out_range(==, ulOperand) LONG_PTR* plResult)
{
    C_ASSERT(sizeof(LONG_PTR) > sizeof(ULONG));
    *plResult = (LONG_PTR)ulOperand;
    return S_OK;
}
#else
#define ULongToLongPtr  ULongToLong
#endif

//
// ULONG -> ptrdiff_t conversion
//
#define ULongToPtrdiffT ULongToIntPtr

//
// ULONG -> SSIZE_T conversion
//
#define ULongToSSIZET   ULongToLongPtr

//
// ULONG_PTR -> INT8 conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToInt8(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if (ulOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)ulOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG_PTR -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToUChar(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) UCHAR* pch)
{
    HRESULT hr;

    if (ulOperand <= 255)
    {
        *pch = (UCHAR)ulOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// ULONG_PTR -> CHAR conversion
//
__forceinline
HRESULT
ULongPtrToChar(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return ULongPtrToUChar(ulOperand, (UCHAR*)pch);
#else
    return ULongPtrToInt8(ulOperand, (INT8*)pch);
#endif
}

//
// ULONG_PTR -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToUInt8(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) UINT8* pui8Result)
{
    HRESULT hr;
    
    if (ulOperand <= UINT8_MAX)
    {
        *pui8Result = (UINT8)ulOperand;
        hr = S_OK;
    }
    else
    {
        *pui8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//    
// ULONG_PTR -> BYTE conversion
//
#define ULongPtrToByte  ULongPtrToUInt8

//
// ULONG_PTR -> SHORT conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToShort(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) SHORT* psResult)
{
    HRESULT hr;

    if (ulOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)ulOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr; 
}

//
// ULONG_PTR -> INT16 conversion
//
#define ULongPtrToInt16 ULongPtrToShort

//
// ULONG_PTR -> USHORT conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToUShort(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) USHORT* pusResult)
{
    HRESULT hr;

    if (ulOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)ulOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// ULONG_PTR -> UINT16 conversion
//
#define ULongPtrToUInt16    ULongPtrToUShort

//
// ULONG_PTR -> WORD conversion
//
#define ULongPtrToWord  ULongPtrToUShort

//
// ULONG_PTR -> INT conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToInt(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) INT* piResult)
{
    HRESULT hr;
    
    if (ulOperand <= INT_MAX)
    {
        *piResult = (INT)ulOperand;
        hr = S_OK;
    }
    else
    {
        *piResult = INT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG_PTR -> INT32 conversion
//
#define ULongPtrToInt32 ULongPtrToInt

//
// ULONG_PTR -> INT_PTR conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToIntPtr(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) INT_PTR* piResult)
{
    HRESULT hr;
    
    if (ulOperand <= INT_PTR_MAX)
    {
        *piResult = (INT_PTR)ulOperand;
        hr = S_OK;
    }
    else
    {
        *piResult = INT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG_PTR -> UINT conversion
//
#ifdef _WIN64
#define ULongPtrToUInt  ULongLongToUInt
#else
__checkReturn
__inline
HRESULT
ULongPtrToUInt(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) UINT* puResult)
{
    C_ASSERT(sizeof(ULONG_PTR) == sizeof(UINT));
    *puResult = (UINT)ulOperand;    
    return S_OK;
}
#endif

//
// ULONG_PTR -> UINT32 conversion
//
#define ULongPtrToUInt32    ULongPtrToUInt

//
// ULONG_PTR -> UINT_PTR conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToUIntPtr(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) UINT_PTR* puResult)
{
    *puResult = (UINT_PTR)ulOperand;
    return S_OK;
}

//
// ULONG_PTR -> LONG conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToLong(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) LONG* plResult)
{
    HRESULT hr;
    
    if (ulOperand <= LONG_MAX)
    {
        *plResult = (LONG)ulOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//        
// ULONG_PTR -> LONG_PTR conversion
//
__checkReturn
__inline
HRESULT
ULongPtrToLongPtr(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) LONG_PTR* plResult)
{
    HRESULT hr;
    
    if (ulOperand <= LONG_PTR_MAX)
    {
        *plResult = (LONG_PTR)ulOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG_PTR -> ULONG conversion
//
#ifdef _WIN64
#define ULongPtrToULong ULongLongToULong
#else
__checkReturn
__inline
HRESULT
ULongPtrToULong(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) ULONG* pulResult)
{
    *pulResult = (ULONG)ulOperand;
    return S_OK;
}
#endif    

//
// ULONG_PTR -> DWORD conversion
//
#define ULongPtrToDWord ULongPtrToULong

//
// ULONG_PTR -> LONGLONG conversion
//
#ifdef _WIN64
#define ULongPtrToLongLong  ULongLongToLongLong
#else
__checkReturn
__inline
HRESULT
ULongPtrToLongLong(
    __in ULONG_PTR ulOperand,
    __out __deref_out_range(==, ulOperand) LONGLONG* pllResult)
{
    *pllResult = (LONGLONG)ulOperand;
    return S_OK;
}
#endif

//
// ULONG_PTR -> LONG64 conversion
//
#define ULongPtrToLong64    ULongPtrToLongLong

//
// ULONG_PTR -> INT64
//
#define ULongPtrToInt64 ULongPtrToLongLong

//
// ULONG_PTR -> ptrdiff_t conversion
//
#define ULongPtrToPtrdiffT  ULongPtrToIntPtr

//
// ULONG_PTR -> SSIZE_T conversion
//
#define ULongPtrToSSIZET    ULongPtrToLongPtr

//
// DWORD -> INT8 conversion
//
#define DWordToInt8 ULongToInt8

//
// DWORD -> CHAR conversion
//
#define DWordToChar ULongToChar

//
// DWORD -> UCHAR conversion
//
#define DWordToUChar    ULongToUChar

//
// DWORD -> UINT8 conversion
//
#define DWordToUInt8    ULongToUInt8

//
// DWORD -> BYTE conversion
//
#define DWordToByte ULongToUInt8

//
// DWORD -> SHORT conversion
//
#define DWordToShort    ULongToShort

//
// DWORD -> INT16 conversion
//
#define DWordToInt16    ULongToShort

//
// DWORD -> USHORT conversion
//
#define DWordToUShort   ULongToUShort

//
// DWORD -> UINT16 conversion
//
#define DWordToUInt16   ULongToUShort

//
// DWORD -> WORD conversion
//
#define DWordToWord ULongToUShort

//
// DWORD -> INT conversion
//
#define DWordToInt  ULongToInt

//
// DWORD -> INT32 conversion
//
#define DWordToInt32    ULongToInt

//
// DWORD -> INT_PTR conversion
//
#define DWordToIntPtr   ULongToIntPtr

//
// DWORD -> UINT conversion
//
#define DWordToUInt ULongToUInt

//
// DWORD -> UINT32 conversion
//
#define DWordToUInt32   ULongToUInt

//
// DWORD -> UINT_PTR conversion
//
#define DWordToUIntPtr  ULongToUIntPtr

//
// DWORD -> LONG conversion
//
#define DWordToLong ULongToLong

//
// DWORD -> LONG_PTR conversion
//
#define DWordToLongPtr  ULongToLongPtr

//
// DWORD -> ptrdiff_t conversion
//
#define DWordToPtrdiffT ULongToIntPtr

//
// DWORD -> SSIZE_T conversion
//
#define DWordToSSIZET   ULongToLongPtr

//
// DWORD_PTR -> INT8 conversion
//
#define DWordPtrToInt8  ULongPtrToInt8

//
// DWORD_PTR -> UCHAR conversion
//
#define DWordPtrToUChar ULongPtrToUChar

//
// DWORD_PTR -> CHAR conversion
//
#define DWordPtrToChar  ULongPtrToChar

//
// DWORD_PTR -> UINT8 conversion
//
#define DWordPtrToUInt8 ULongPtrToUInt8

//
// DWORD_PTR -> BYTE conversion
//
#define DWordPtrToByte  ULongPtrToUInt8

//
// DWORD_PTR -> SHORT conversion
//
#define DWordPtrToShort ULongPtrToShort

//
// DWORD_PTR -> INT16 conversion
//
#define DWordPtrToInt16 ULongPtrToShort

//
// DWORD_PTR -> USHORT conversion
//
#define DWordPtrToUShort    ULongPtrToUShort

//
// DWORD_PTR -> UINT16 conversion
//
#define DWordPtrToUInt16    ULongPtrToUShort

//
// DWORD_PTR -> WORD conversion
//
#define DWordPtrToWord  ULongPtrToUShort

//
// DWORD_PTR -> INT conversion
//
#define DWordPtrToInt   ULongPtrToInt

//
// DWORD_PTR -> INT32 conversion
//
#define DWordPtrToInt32 ULongPtrToInt

//
// DWORD_PTR -> INT_PTR conversion
//
#define DWordPtrToIntPtr    ULongPtrToIntPtr

//
// DWORD_PTR -> UINT conversion
//
#define DWordPtrToUInt  ULongPtrToUInt

//
// DWORD_PTR -> UINT32 conversion
//
#define DWordPtrToUInt32    ULongPtrToUInt

//
// DWODR_PTR -> UINT_PTR conversion
//
#define DWordPtrToUIntPtr   ULongPtrToUIntPtr

//
// DWORD_PTR -> LONG conversion
//
#define DWordPtrToLong  ULongPtrToLong

//
// DWORD_PTR -> LONG_PTR conversion
//
#define DWordPtrToLongPtr   ULongPtrToLongPtr

//
// DWORD_PTR -> ULONG conversion
//
#define DWordPtrToULong ULongPtrToULong

//
// DWORD_PTR -> DWORD conversion
//
#define DWordPtrToDWord ULongPtrToULong

//
// DWORD_PTR -> LONGLONG conversion
//
#define DWordPtrToLongLong  ULongPtrToLongLong

//
// DWORD_PTR -> LONG64 conversion
//
#define DWordPtrToLong64    ULongPtrToLongLong

//
// DWORD_PTR -> INT64 conversion
//
#define DWordPtrToInt64 ULongPtrToLongLong

//
// DWORD_PTR -> ptrdiff_t conversion
//
#define DWordPtrToPtrdiffT  ULongPtrToIntPtr

//
// DWORD_PTR -> SSIZE_T conversion
//
#define DWordPtrToSSIZET    ULongPtrToLongPtr

//
// LONGLONG -> INT8 conversion
//
__checkReturn
__inline
HRESULT
LongLongToInt8(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if ((llOperand >= INT8_MIN) && (llOperand <= INT8_MAX))
    {
        *pi8Result = (INT8)llOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }

    return hr;
}

//
// LONGLONG -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
LongLongToUChar(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) UCHAR* pch)
{
    HRESULT hr;

    if ((llOperand >= 0) && (llOperand <= 255))
    {
        *pch = (UCHAR)llOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONGLONG -> CHAR conversion
//
__forceinline
HRESULT
LongLongToChar(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return LongLongToUChar(llOperand, (UCHAR*)pch);
#else
    return LongLongToInt8(llOperand, (INT8*)pch);
#endif
}

//
// LONGLONG -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
LongLongToUInt8(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) UINT8* pu8Result)
{
    HRESULT hr;
    
    if ((llOperand >= 0) && (llOperand <= UINT8_MAX))
    {
        *pu8Result = (UINT8)llOperand;
        hr = S_OK;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONGLONG -> BYTE conversion
//
#define LongLongToByte  LongLongToUInt8

//
// LONGLONG -> SHORT conversion
//
__checkReturn
__inline
HRESULT
LongLongToShort(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) SHORT* psResult)
{
    HRESULT hr;
    
    if ((llOperand >= SHORT_MIN) && (llOperand <= SHORT_MAX))
    {
        *psResult = (SHORT)llOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONGLONG -> INT16 conversion
//
#define LongLongToInt16 LongLongToShort

//
// LONGLONG -> USHORT conversion
//
__checkReturn
__inline
HRESULT
LongLongToUShort(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) USHORT* pusResult)
{
    HRESULT hr;
    
    if ((llOperand >= 0) && (llOperand <= USHORT_MAX))
    {
        *pusResult = (USHORT)llOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONGLONG -> UINT16 conversion
//
#define LongLongToUInt16    LongLongToUShort

//
// LONGLONG -> WORD conversion
//
#define LongLongToWord  LongLongToUShort

//
// LONGLONG -> INT conversion
//
__checkReturn
__inline
HRESULT
LongLongToInt(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) INT* piResult)
{
    HRESULT hr;
    
    if ((llOperand >= INT_MIN) && (llOperand <= INT_MAX))
    {
        *piResult = (INT)llOperand;
        hr = S_OK;
    }
    else
    {
        *piResult = INT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// LONGLONG -> INT32 conversion
//
#define LongLongToInt32 LongLongToInt

//
// LONGLONG -> INT_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
LongLongToIntPtr(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) INT_PTR* piResult)
{
    *piResult = llOperand;
    return S_OK;
}
#else
#define LongLongToIntPtr   LongLongToInt
#endif

//
// LONGLONG -> UINT conversion
//
__checkReturn
__inline
HRESULT
LongLongToUInt(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) UINT* puResult)
{
    HRESULT hr;
    
    if ((llOperand >= 0) && (llOperand <= UINT_MAX))
    {
        *puResult = (UINT)llOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;    
}

//
// LONGLONG -> UINT32 conversion
//
#define LongLongToUInt32    LongLongToUInt

//
// LONGLONG -> UINT_PTR conversion
//
#ifdef _WIN64
#define LongLongToUIntPtr  LongLongToULongLong
#else
#define LongLongToUIntPtr  LongLongToUInt
#endif

//
// LONGLONG -> LONG conversion
//
__checkReturn
__inline
HRESULT
LongLongToLong(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) LONG* plResult)
{
    HRESULT hr;
    
    if ((llOperand >= LONG_MIN) && (llOperand <= LONG_MAX))
    {
        *plResult = (LONG)llOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;    
}

//
// LONGLONG -> LONG_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
LongLongToLongPtr(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) LONG_PTR* plResult)
{
    *plResult = (LONG_PTR)llOperand;
    return S_OK;
}    
#else
#define LongLongToLongPtr  LongLongToLong
#endif

//
// LONGLONG -> ULONG conversion
//
__checkReturn
__inline
HRESULT
LongLongToULong(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) ULONG* pulResult)
{
    HRESULT hr;
    
    if ((llOperand >= 0) && (llOperand <= ULONG_MAX))
    {
        *pulResult = (ULONG)llOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;    
}

//
// LONGLONG -> ULONG_PTR conversion
//
#ifdef _WIN64
#define LongLongToULongPtr LongLongToULongLong
#else
#define LongLongToULongPtr LongLongToULong
#endif

//
// LONGLONG -> DWORD conversion
//
#define LongLongToDWord    LongLongToULong

//
// LONGLONG -> DWORD_PTR conversion
//
#define LongLongToDWordPtr LongLongToULongPtr

//
// LONGLONG -> ULONGLONG conversion
//
__checkReturn
__inline
HRESULT
LongLongToULongLong(
    __in LONGLONG llOperand,
    __out __deref_out_range(==, llOperand) ULONGLONG* pullResult)
{
    HRESULT hr;
    
    if (llOperand >= 0)
    {
        *pullResult = (ULONGLONG)llOperand;
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr; 
}

//
// LONGLONG -> DWORDLONG conversion
//
#define LongLongToDWordLong LongLongToULongLong

//
// LONGLONG -> ULONG64 conversion
//
#define LongLongToULong64   LongLongToULongLong

//
// LONGLONG -> DWORD64 conversion
//
#define LongLongToDWord64   LongLongToULongLong

//
// LONGLONG -> UINT64 conversion
//
#define LongLongToUInt64    LongLongToULongLong

//
// LONGLONG -> ptrdiff_t conversion
//
#define LongLongToPtrdiffT LongLongToIntPtr

//
// LONGLONG -> size_t conversion
//
#define LongLongToSizeT    LongLongToUIntPtr

//
// LONGLONG -> SSIZE_T conversion
//
#define LongLongToSSIZET   LongLongToLongPtr

//
// LONGLONG -> SIZE_T conversion
//
#define LongLongToSIZET    LongLongToULongPtr

//
// LONG64 -> CHAR conversion
//
#define Long64ToChar    LongLongToChar

//
// LONG64 -> INT8 conversion
//
#define Long64ToInt8    LongLongToInt8

//
// LONG64 -> UCHAR conversion
//
#define Long64ToUChar   LongLongToUChar

//
// LONG64 -> UINT8 conversion
//
#define Long64ToUInt8   LongLongToUInt8

//
// LONG64 -> BYTE conversion
//
#define Long64ToByte    LongLongToUInt8

//
// LONG64 -> SHORT conversion
//
#define Long64ToShort   LongLongToShort

//
// LONG64 -> INT16 conversion
//
#define Long64ToInt16   LongLongToShort

//
// LONG64 -> USHORT conversion
//
#define Long64ToUShort  LongLongToUShort

//
// LONG64 -> UINT16 conversion
//
#define Long64ToUInt16  LongLongToUShort

//
// LONG64 -> WORD conversion
//
#define Long64ToWord    LongLongToUShort

//
// LONG64 -> INT conversion
//
#define Long64ToInt LongLongToInt

//
// LONG64 -> INT32 conversion
//
#define Long64ToInt32   LongLongToInt

//
// LONG64 -> INT_PTR conversion
//
#define Long64ToIntPtr  LongLongToIntPtr

//
// LONG64 -> UINT conversion
//
#define Long64ToUInt    LongLongToUInt

//
// LONG64 -> UINT32 conversion
//
#define Long64ToUInt32  LongLongToUInt

//
// LONG64 -> UINT_PTR conversion
//
#define Long64ToUIntPtr LongLongToUIntPtr

//
// LONG64 -> LONG conversion
//
#define Long64ToLong    LongLongToLong

//
// LONG64 -> LONG_PTR conversion
//
#define Long64ToLongPtr LongLongToLongPtr

//
// LONG64 -> ULONG conversion
//
#define Long64ToULong   LongLongToULong

//
// LONG64 -> ULONG_PTR conversion
//
#define Long64ToULongPtr    LongLongToULongPtr

//
// LONG64 -> DWORD conversion
//
#define Long64ToDWord   LongLongToULong

//
// LONG64 -> DWORD_PTR conversion
//
#define Long64ToDWordPtr    LongLongToULongPtr  

//
// LONG64 -> ULONGLONG conversion
//
#define Long64ToULongLong   LongLongToULongLong

//
// LONG64 -> ptrdiff_t conversion
//
#define Long64ToPtrdiffT    LongLongToIntPtr

//
// LONG64 -> size_t conversion
//
#define Long64ToSizeT   LongLongToUIntPtr

//
// LONG64 -> SSIZE_T conversion
//
#define Long64ToSSIZET  LongLongToLongPtr

//
// LONG64 -> SIZE_T conversion
//
#define Long64ToSIZET   LongLongToULongPtr

//
// INT64 -> CHAR conversion
//
#define Int64ToChar LongLongToChar

//
// INT64 -> INT8 conversion
//
#define Int64ToInt8 LongLongToInt8

//
// INT64 -> UCHAR conversion
//
#define Int64ToUChar    LongLongToUChar

//
// INT64 -> UINT8 conversion
//
#define Int64ToUInt8    LongLongToUInt8

//
// INT64 -> BYTE conversion
//
#define Int64ToByte LongLongToUInt8

//
// INT64 -> SHORT conversion
//
#define Int64ToShort    LongLongToShort

//
// INT64 -> INT16 conversion
//
#define Int64ToInt16    LongLongToShort

//
// INT64 -> USHORT conversion
//
#define Int64ToUShort   LongLongToUShort

//
// INT64 -> UINT16 conversion
//
#define Int64ToUInt16   LongLongToUShort

//
// INT64 -> WORD conversion
//
#define Int64ToWord LongLongToUShort

//
// INT64 -> INT conversion
//
#define Int64ToInt  LongLongToInt

//
// INT64 -> INT32 conversion
//
#define Int64ToInt32    LongLongToInt

//
// INT64 -> INT_PTR conversion
//
#define Int64ToIntPtr   LongLongToIntPtr

//
// INT64 -> UINT conversion
//
#define Int64ToUInt LongLongToUInt

//
// INT64 -> UINT32 conversion
//
#define Int64ToUInt32   LongLongToUInt

//
// INT64 -> UINT_PTR conversion
//
#define Int64ToUIntPtr  LongLongToUIntPtr

//
// INT64 -> LONG conversion
//
#define Int64ToLong LongLongToLong

//
// INT64 -> LONG_PTR conversion
//
#define Int64ToLongPtr  LongLongToLongPtr

//
// INT64 -> ULONG conversion
//
#define Int64ToULong    LongLongToULong

//
// INT64 -> ULONG_PTR conversion
//
#define Int64ToULongPtr LongLongToULongPtr

//
// INT64 -> DWORD conversion
//
#define Int64ToDWord    LongLongToULong

//
// INT64 -> DWORD_PTR conversion
//
#define Int64ToDWordPtr LongLongToULongPtr

//
// INT64 -> ULONGLONG conversion
//
#define Int64ToULongLong    LongLongToULongLong

//
// INT64 -> DWORDLONG conversion
//
#define Int64ToDWordLong    LongLongToULongLong

//
// INT64 -> ULONG64 conversion
//
#define Int64ToULong64  LongLongToULongLong

//
// INT64 -> DWORD64 conversion
//
#define Int64ToDWord64  LongLongToULongLong

//
// INT64 -> UINT64 conversion
//
#define Int64ToUInt64   LongLongToULongLong

//
// INT64 -> ptrdiff_t conversion
//
#define Int64ToPtrdiffT LongLongToIntPtr

//
// INT64 -> size_t conversion
//
#define Int64ToSizeT    LongLongToUIntPtr

//
// INT64 -> SSIZE_T conversion
//
#define Int64ToSSIZET   LongLongToLongPtr

//
// INT64 -> SIZE_T conversion
//
#define Int64ToSIZET    LongLongToULongPtr

//
// ULONGLONG -> INT8 conversion
//
__checkReturn
__inline
HRESULT
ULongLongToInt8(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) INT8* pi8Result)
{
    HRESULT hr;
    
    if (ullOperand <= INT8_MAX)
    {
        *pi8Result = (INT8)ullOperand;
        hr = S_OK;
    }
    else
    {
        *pi8Result = INT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> UCHAR conversion
//
__checkReturn
__inline
HRESULT
ULongLongToUChar(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) UCHAR* pch)
{
    HRESULT hr;
    
    if (ullOperand <= 255)
    {
        *pch = (UCHAR)ullOperand;
        hr = S_OK;
    }
    else
    {
        *pch = '\0';
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> CHAR conversion
//
__forceinline
HRESULT
ULongLongToChar(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) CHAR* pch)
{
#ifdef _CHAR_UNSIGNED
    return ULongLongToUChar(ullOperand, (UCHAR*)pch);
#else
    return ULongLongToInt8(ullOperand, (INT8*)pch);
#endif
}

//
// ULONGLONG -> UINT8 conversion
//
__checkReturn
__inline
HRESULT
ULongLongToUInt8(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) UINT8* pu8Result)
{
    HRESULT hr;
    
    if (ullOperand <= UINT8_MAX)
    {
        *pu8Result = (UINT8)ullOperand;
        hr = S_OK;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> BYTE conversion
//
#define ULongLongToByte ULongLongToUInt8

//
// ULONGLONG -> SHORT conversion
//
__checkReturn
__inline
HRESULT
ULongLongToShort(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) SHORT* psResult)
{
    HRESULT hr;
    
    if (ullOperand <= SHORT_MAX)
    {
        *psResult = (SHORT)ullOperand;
        hr = S_OK;
    }
    else
    {
        *psResult = SHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> INT16 conversion
//
#define ULongLongToInt16    ULongLongToShort

//
// ULONGLONG -> USHORT conversion
//
__checkReturn
__inline
HRESULT
ULongLongToUShort(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) USHORT* pusResult)
{
    HRESULT hr;
    
    if (ullOperand <= USHORT_MAX)
    {
        *pusResult = (USHORT)ullOperand;
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> UINT16 conversion
//
#define ULongLongToUInt16   ULongLongToUShort

//
// ULONGLONG -> WORD conversion
//
#define ULongLongToWord ULongLongToUShort

//
// ULONGLONG -> INT conversion
//
__checkReturn
__inline
HRESULT
ULongLongToInt(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) INT* piResult)
{
    HRESULT hr;
    
    if (ullOperand <= INT_MAX)
    {
        *piResult = (INT)ullOperand;
        hr = S_OK;
    }
    else
    {
        *piResult = INT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> INT32 conversion
//
#define ULongLongToInt32    ULongLongToInt

//
// ULONGLONG -> INT_PTR conversion
//
#ifdef _WIN64
#define ULongLongToIntPtr   ULongLongToLongLong
#else
#define ULongLongToIntPtr   ULongLongToInt
#endif

//
// ULONGLONG -> UINT conversion
//
__checkReturn
__inline
HRESULT
ULongLongToUInt(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) UINT* puResult)
{
    HRESULT hr;
    
    if (ullOperand <= UINT_MAX)
    {
        *puResult = (UINT)ullOperand;
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> UINT32 conversion
//
#define ULongLongToUInt32   ULongLongToUInt

//
// ULONGLONG -> UINT_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
ULongLongToUIntPtr(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) UINT_PTR* puResult)
{
    *puResult = ullOperand;
    return S_OK;
}
#else    
#define ULongLongToUIntPtr  ULongLongToUInt
#endif

//
// ULONGLONG -> LONG conversion
//
__checkReturn
__inline
HRESULT
ULongLongToLong(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) LONG* plResult)
{
    HRESULT hr;
    
    if (ullOperand <= LONG_MAX)
    {
        *plResult = (LONG)ullOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> LONG_PTR conversion
//
__checkReturn
__inline
HRESULT
ULongLongToLongPtr(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) LONG_PTR* plResult)
{
    HRESULT hr;
    
    if (ullOperand <= LONG_PTR_MAX)
    {
        *plResult = (LONG_PTR)ullOperand;
        hr = S_OK;
    }
    else
    {
        *plResult = LONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> ULONG conversion
//
__checkReturn
__inline
HRESULT
ULongLongToULong(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) ULONG* pulResult)
{
    HRESULT hr;
    
    if (ullOperand <= ULONG_MAX)
    {
        *pulResult = (ULONG)ullOperand;
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> ULONG_PTR conversion
//
#ifdef _WIN64
__checkReturn
__inline
HRESULT
ULongLongToULongPtr(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) ULONG_PTR* pulResult)
{
    *pulResult = ullOperand;
    return S_OK;
}
#else
#define ULongLongToULongPtr ULongLongToULong
#endif

//
// ULONGLONG -> DWORD conversion
//
#define ULongLongToDWord    ULongLongToULong

//
// ULONGLONG -> DWORD_PTR conversion
//
#define ULongLongToDWordPtr ULongLongToULongPtr

//
// ULONGLONG -> LONGLONG conversion
//
__checkReturn
__inline
HRESULT
ULongLongToLongLong(
    __in ULONGLONG ullOperand,
    __out __deref_out_range(==, ullOperand) LONGLONG* pllResult)
{
    HRESULT hr;
    
    if (ullOperand <= LONGLONG_MAX)
    {
        *pllResult = (LONGLONG)ullOperand;
        hr = S_OK;
    }
    else
    {
        *pllResult = LONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONGLONG -> INT64 conversion
//
#define ULongLongToInt64    ULongLongToLongLong

//
// ULONGLONG -> LONG64 conversion
//
#define ULongLongToLong64   ULongLongToLongLong

//
// ULONGLONG -> ptrdiff_t conversion
//
#define ULongLongToPtrdiffT ULongLongToIntPtr

//
// ULONGLONG -> size_t conversion
//
#define ULongLongToSizeT    ULongLongToUIntPtr

//
// ULONGLONG -> SSIZE_T conversion
//
#define ULongLongToSSIZET   ULongLongToLongPtr

//
// ULONGLONG -> SIZE_T conversion
//
#define ULongLongToSIZET    ULongLongToULongPtr

//
// DWORDLONG -> CHAR conversion
//
#define DWordLongToChar ULongLongToChar

//
// DWORDLONG -> INT8 conversion
//
#define DWordLongToInt8 ULongLongToInt8

//
// DWORDLONG -> UCHAR conversion
//
#define DWordLongToUChar    ULongLongToUChar

//
// DWORDLONG -> UINT8 conversion
//
#define DWordLongToUInt8    ULongLongToUInt8

//
// DWORDLONG -> BYTE conversion
//
#define DWordLongToByte ULongLongToUInt8

//
// DWORDLONG -> SHORT conversion
//
#define DWordLongToShort    ULongLongToShort

//
// DWORDLONG -> INT16 conversion
//
#define DWordLongToInt16    ULongLongToShort

//
// DWORDLONG -> USHORT conversion
//
#define DWordLongToUShort   ULongLongToUShort

//
// DWORDLONG -> UINT16 conversion
//
#define DWordLongToUInt16   ULongLongToUShort

//
// DWORDLONG -> WORD conversion
//
#define DWordLongToWord ULongLongToUShort

//
// DWORDLONG -> INT conversion
//
#define DWordLongToInt  ULongLongToInt

//
// DWORDLONG -> INT32 conversion
//
#define DWordLongToInt32    ULongLongToInt

//
// DWORDLONG -> INT_PTR conversion
//
#define DWordLongToIntPtr   ULongLongToIntPtr

//
// DWORDLONG -> UINT conversion
//
#define DWordLongToUInt ULongLongToUInt

//
// DWORDLONG -> UINT32 conversion
//
#define DWordLongToUInt32   ULongLongToUInt

//
// DWORDLONG -> UINT_PTR conversion
//
#define DWordLongToUIntPtr  ULongLongToUIntPtr

//
// DWORDLONG -> LONG conversion
//
#define DWordLongToLong ULongLongToLong

//
// DWORDLONG -> LONG_PTR conversion
//
#define DWordLongToLongPtr  ULongLongToLongPtr

//
// DWORDLONG -> ULONG conversion
//
#define DWordLongToULong    ULongLongToULong

//
// DWORDLONG -> ULONG_PTR conversion
//
#define DWordLongToULongPtr ULongLongToULongPtr

//
// DWORDLONG -> DWORD conversion
//
#define DWordLongToDWord    ULongLongToULong

//
// DWORDLONG -> DWORD_PTR conversion
//
#define DWordLongToDWordPtr ULongLongToULongPtr

//
// DWORDLONG -> LONGLONG conversion
//
#define DWordLongToLongLong ULongLongToLongLong

//
// DWORDLONG -> LONG64 conversion
//
#define DWordLongToLong64   ULongLongToLongLong

//
// DWORDLONG -> INT64 conversion
//
#define DWordLongToInt64    ULongLongToLongLong

//
// DWORDLONG -> ptrdiff_t conversion
//
#define DWordLongToPtrdiffT ULongLongToIntPtr

//
// DWORDLONG -> size_t conversion
//
#define DWordLongToSizeT    ULongLongToUIntPtr

//
// DWORDLONG -> SSIZE_T conversion
//
#define DWordLongToSSIZET   ULongLongToLongPtr

//
// DWORDLONG -> SIZE_T conversion
//
#define DWordLongToSIZET    ULongLongToULongPtr

//
// ULONG64 -> CHAR conversion
//
#define ULong64ToChar   ULongLongToChar

//
// ULONG64 -> INT8 conversion
//
#define ULong64ToInt8   ULongLongToInt8

//
// ULONG64 -> UCHAR conversion
//
#define ULong64ToUChar  ULongLongToUChar

//
// ULONG64 -> UINT8 conversion
//
#define ULong64ToUInt8  ULongLongToUInt8

//
// ULONG64 -> BYTE conversion
//
#define ULong64ToByte   ULongLongToUInt8

//
// ULONG64 -> SHORT conversion
//
#define ULong64ToShort  ULongLongToShort

//
// ULONG64 -> INT16 conversion
//
#define ULong64ToInt16  ULongLongToShort

//
// ULONG64 -> USHORT conversion
//
#define ULong64ToUShort ULongLongToUShort

//
// ULONG64 -> UINT16 conversion
//
#define ULong64ToUInt16 ULongLongToUShort

//
// ULONG64 -> WORD conversion
//
#define ULong64ToWord   ULongLongToUShort

//
// ULONG64 -> INT conversion
//
#define ULong64ToInt    ULongLongToInt

//
// ULONG64 -> INT32 conversion
//
#define ULong64ToInt32  ULongLongToInt

//
// ULONG64 -> INT_PTR conversion
//
#define ULong64ToIntPtr ULongLongToIntPtr

//
// ULONG64 -> UINT conversion
//
#define ULong64ToUInt   ULongLongToUInt

//
// ULONG64 -> UINT32 conversion
//
#define ULong64ToUInt32 ULongLongToUInt

//
// ULONG64 -> UINT_PTR conversion
//
#define ULong64ToUIntPtr    ULongLongToUIntPtr

//
// ULONG64 -> LONG conversion
//
#define ULong64ToLong   ULongLongToLong

//
// ULONG64 -> LONG_PTR conversion
//
#define ULong64ToLongPtr    ULongLongToLongPtr

//
// ULONG64 -> ULONG conversion
//
#define ULong64ToULong  ULongLongToULong

//
// ULONG64 -> ULONG_PTR conversion
//
#define ULong64ToULongPtr   ULongLongToULongPtr

//
// ULONG64 -> DWORD conversion
//
#define ULong64ToDWord  ULongLongToULong

//
// ULONG64 -> DWORD_PTR conversion
//
#define ULong64ToDWordPtr   ULongLongToULongPtr

//
// ULONG64 -> LONGLONG conversion
//
#define ULong64ToLongLong   ULongLongToLongLong

//
// ULONG64 -> LONG64 conversion
//
#define ULong64ToLong64 ULongLongToLongLong

//
// ULONG64 -> INT64 conversion
//
#define ULong64ToInt64  ULongLongToLongLong

//
// ULONG64 -> ptrdiff_t conversion
//
#define ULong64ToPtrdiffT   ULongLongToIntPtr

//
// ULONG64 -> size_t conversion
//
#define ULong64ToSizeT  ULongLongToUIntPtr

//
// ULONG64 -> SSIZE_T conversion
//
#define ULong64ToSSIZET ULongLongToLongPtr

//
// ULONG64 -> SIZE_T conversion
//
#define ULong64ToSIZET  ULongLongToULongPtr

//
// DWORD64 -> CHAR conversion
//
#define DWord64ToChar   ULongLongToChar

//
// DWORD64 -> INT8 conversion
//
#define DWord64ToInt8   ULongLongToInt8

//
// DWORD64 -> UCHAR conversion
//
#define DWord64ToUChar  ULongLongToUChar

//
// DWORD64 -> UINT8 conversion
//
#define DWord64ToUInt8  ULongLongToUInt8

//
// DWORD64 -> BYTE conversion
//
#define DWord64ToByte   ULongLongToUInt8

//
// DWORD64 -> SHORT conversion
//
#define DWord64ToShort  ULongLongToShort

//
// DWORD64 -> INT16 conversion
//
#define DWord64ToInt16  ULongLongToShort

//
// DWORD64 -> USHORT conversion
//
#define DWord64ToUShort ULongLongToUShort

//
// DWORD64 -> UINT16 conversion
//
#define DWord64ToUInt16 ULongLongToUShort

//
// DWORD64 -> WORD conversion
//
#define DWord64ToWord   ULongLongToUShort

//
// DWORD64 -> INT conversion
//
#define DWord64ToInt    ULongLongToInt

//
// DWORD64 -> INT32 conversion
//
#define DWord64ToInt32  ULongLongToInt

//
// DWORD64 -> INT_PTR conversion
//
#define DWord64ToIntPtr ULongLongToIntPtr

//
// DWORD64 -> UINT conversion
//
#define DWord64ToUInt   ULongLongToUInt

//
// DWORD64 -> UINT32 conversion
//
#define DWord64ToUInt32 ULongLongToUInt

//
// DWORD64 -> UINT_PTR conversion
//
#define DWord64ToUIntPtr    ULongLongToUIntPtr

//
// DWORD64 -> LONG conversion
//
#define DWord64ToLong   ULongLongToLong

//
// DWORD64 -> LONG_PTR conversion
//
#define DWord64ToLongPtr    ULongLongToLongPtr

//
// DWORD64 -> ULONG conversion
//
#define DWord64ToULong  ULongLongToULong

//
// DWORD64 -> ULONG_PTR conversion
//
#define DWord64ToULongPtr   ULongLongToULongPtr

//
// DWORD64 -> DWORD conversion
//
#define DWord64ToDWord  ULongLongToULong

//
// DWORD64 -> DWORD_PTR conversion
//
#define DWord64ToDWordPtr   ULongLongToULongPtr

//
// DWORD64 -> LONGLONG conversion
//
#define DWord64ToLongLong   ULongLongToLongLong

//
// DWORD64 -> LONG64 conversion
//
#define DWord64ToLong64 ULongLongToLongLong

//
// DWORD64 -> INT64 conversion
//
#define DWord64ToInt64  ULongLongToLongLong

//
// DWORD64 -> ptrdiff_t conversion
//
#define DWord64ToPtrdiffT   ULongLongToIntPtr

//
// DWORD64 -> size_t conversion
//
#define DWord64ToSizeT  ULongLongToUIntPtr

//
// DWORD64 -> SSIZE_T conversion
//
#define DWord64ToSSIZET ULongLongToLongPtr

//
// DWORD64 -> SIZE_T conversion
//
#define DWord64ToSIZET  ULongLongToULongPtr

//
// UINT64 -> CHAR conversion
//
#define UInt64ToChar    ULongLongToChar

//
// UINT64 -> INT8 conversion
//
#define UInt64ToInt8    ULongLongToInt8

//
// UINT64 -> UCHAR conversion
//
#define UInt64ToUChar   ULongLongToUChar

//
// UINT64 -> UINT8 conversion
//
#define UInt64ToUInt8   ULongLongToUInt8

//
// UINT64 -> BYTE conversion
//
#define UInt64ToByte    ULongLongToUInt8

//
// UINT64 -> SHORT conversion
//
#define UInt64ToShort   ULongLongToShort

//
// UINT64 -> INT16 conversion
//
//
#define UInt64ToInt16   ULongLongToShort

//
// UINT64 -> USHORT conversion
//
#define UInt64ToUShort  ULongLongToUShort

//
// UINT64 -> UINT16 conversion
//
#define UInt64ToUInt16  ULongLongToUShort

//
// UINT64 -> WORD conversion
//
#define UInt64ToWord    ULongLongToUShort

//
// UINT64 -> INT conversion
//
#define UInt64ToInt ULongLongToInt

//
// UINT64 -> INT32 conversion
//
#define UInt64ToInt32   ULongLongToInt

//
// UINT64 -> INT_PTR conversion
//
#define UInt64ToIntPtr  ULongLongToIntPtr

//
// UINT64 -> UINT conversion
//
#define UInt64ToUInt    ULongLongToUInt

//
// UINT64 -> UINT32 conversion
//
#define UInt64ToUInt32  ULongLongToUInt

//
// UINT64 -> UINT_PTR conversion
//
#define UInt64ToUIntPtr ULongLongToUIntPtr

//
// UINT64 -> LONG conversion
//
#define UInt64ToLong    ULongLongToLong

//
// UINT64 -> LONG_PTR conversion
//
#define UInt64ToLongPtr ULongLongToLongPtr

//
// UINT64 -> ULONG conversion
//
#define UInt64ToULong   ULongLongToULong

//
// UINT64 -> ULONG_PTR conversion
//
#define UInt64ToULongPtr    ULongLongToULongPtr

//
// UINT64 -> DWORD conversion
//
#define UInt64ToDWord   ULongLongToULong

//
// UINT64 -> DWORD_PTR conversion
//
#define UInt64ToDWordPtr    ULongLongToULongPtr

//
// UINT64 -> LONGLONG conversion
//
#define UInt64ToLongLong    ULongLongToLongLong

//
// UINT64 -> LONG64 conversion
//
#define UInt64ToLong64  ULongLongToLongLong

//
// UINT64 -> INT64 conversion
//
#define UInt64ToInt64   ULongLongToLongLong

//
// UINT64 -> ptrdiff_t conversion
//
#define UInt64ToPtrdiffT    ULongLongToIntPtr

//
// UINT64 -> size_t conversion
//
#define UInt64ToSizeT   ULongLongToUIntPtr

//
// UINT64 -> SSIZE_T conversion
//
#define UInt64ToSSIZET  ULongLongToLongPtr

//
// UINT64 -> SIZE_T conversion
//
#define UInt64ToSIZET  ULongLongToULongPtr

//
// ptrdiff_t -> CHAR conversion
//
#define PtrdiffTToChar  IntPtrToChar

//
// ptrdiff_t -> INT8 conversion
//
#define PtrdiffTToInt8  IntPtrToInt8

//
// ptrdiff_t -> UCHAR conversion
//
#define PtrdiffTToUChar IntPtrToUChar

//
// ptrdiff_t -> UINT8 conversion
//
#define PtrdiffTToUInt8 IntPtrToUInt8

//
// ptrdiff_t -> BYTE conversion
//
#define PtrdiffTToByte  IntPtrToUInt8

//
// ptrdiff_t -> SHORT conversion
//
#define PtrdiffTToShort IntPtrToShort

//
// ptrdiff_t -> INT16 conversion
//
#define PtrdiffTToInt16 IntPtrToShort

//
// ptrdiff_t -> USHORT conversion
//
#define PtrdiffTToUShort    IntPtrToUShort

//
// ptrdiff_t -> UINT16 conversion
//
#define PtrdiffTToUInt16    IntPtrToUShort

//
// ptrdiff_t -> WORD conversion
//
#define PtrdiffTToWord  IntPtrToUShort

//
// ptrdiff_t -> INT conversion
//
#define PtrdiffTToInt   IntPtrToInt

//
// ptrdiff_t -> INT32 conversion
//
#define PtrdiffTToInt32 IntPtrToInt

//
// ptrdiff_t -> UINT conversion
//
#define PtrdiffTToUInt  IntPtrToUInt

//
// ptrdiff_t -> UINT32 conversion
//
#define PtrdiffTToUInt32    IntPtrToUInt

//
// ptrdiff_t -> UINT_PTR conversion
//
#define PtrdiffTToUIntPtr   IntPtrToUIntPtr

//
// ptrdiff_t -> LONG conversion
//
#define PtrdiffTToLong  IntPtrToLong

//
// ptrdiff_t -> LONG_PTR conversion
//
#define PtrdiffTToLongPtr   IntPtrToLongPtr

//
// ptrdiff_t -> ULONG conversion
//
#define PtrdiffTToULong IntPtrToULong

//
// ptrdiff_t -> ULONG_PTR conversion
//
#define PtrdiffTToULongPtr  IntPtrToULongPtr

//
// ptrdiff_t -> DWORD conversion
//
#define PtrdiffTToDWord IntPtrToULong

//
// ptrdiff_t -> DWORD_PTR conversion
//
#define PtrdiffTToDWordPtr  IntPtrToULongPtr

//
// ptrdiff_t -> ULONGLONG conversion
//
#define PtrdiffTToULongLong IntPtrToULongLong

//
// ptrdiff_t -> DWORDLONG conversion
//
#define PtrdiffTToDWordLong IntPtrToULongLong

//
// ptrdiff_t -> ULONG64 conversion
//
#define PtrdiffTToULong64   IntPtrToULongLong

//
// ptrdiff_t -> DWORD64 conversion
//
#define PtrdiffTToDWord64   IntPtrToULongLong

//
// ptrdiff_t -> UINT64 conversion
//
#define PtrdiffTToUInt64    IntPtrToULongLong

//
// ptrdiff_t -> size_t conversion
//
#define PtrdiffTToSizeT IntPtrToUIntPtr

//
// ptrdiff_t -> SIZE_T conversion
//
#define PtrdiffTToSIZET IntPtrToULongPtr

//
// size_t -> INT8 conversion
//
#define SizeTToInt8 UIntPtrToInt8

//
// size_t -> UCHAR conversion
//
#define SizeTToUChar    UIntPtrToUChar

//
// size_t -> CHAR conversion
//
#define SizeTToChar UIntPtrToChar

//
// size_t -> UINT8 conversion
//
#define SizeTToUInt8    UIntPtrToUInt8

//
// size_t -> BYTE conversion
//
#define SizeTToByte UIntPtrToUInt8

//
// size_t -> SHORT conversion
//
#define SizeTToShort    UIntPtrToShort

//
// size_t -> INT16 conversion
//
#define SizeTToInt16    UIntPtrToShort

//
// size_t -> USHORT conversion
//
#define SizeTToUShort   UIntPtrToUShort

//
// size_t -> UINT16 conversion
//
#define SizeTToUInt16   UIntPtrToUShort

//
// size_t -> WORD
//
#define SizeTToWord UIntPtrToUShort

//
// size_t -> INT conversion
//
#define SizeTToInt  UIntPtrToInt

//
// size_t -> INT32 conversion
//
#define SizeTToInt32    UIntPtrToInt

//
// size_t -> INT_PTR conversion
//
#define SizeTToIntPtr   UIntPtrToIntPtr

//
// size_t -> UINT conversion
//
#define SizeTToUInt UIntPtrToUInt

//
// size_t -> UINT32 conversion
//
#define SizeTToUInt32   UIntPtrToUInt

//
// size_t -> LONG conversion
//
#define SizeTToLong UIntPtrToLong

//
// size_t -> LONG_PTR conversion
//
#define SizeTToLongPtr  UIntPtrToLongPtr

//
// size_t -> ULONG conversion
//
#define SizeTToULong    UIntPtrToULong

//
// size_t -> DWORD conversion
//
#define SizeTToDWord    UIntPtrToULong

//
// size_t -> LONGLONG conversion
//
#define SizeTToLongLong UIntPtrToLongLong

//
// size_t -> LONG64 conversion
//
#define SizeTToLong64   UIntPtrToLongLong

//
// size_t -> INT64
//
#define SizeTToInt64    UIntPtrToLongLong

//   
// size_t -> ptrdiff_t conversion
//
#define SizeTToPtrdiffT UIntPtrToIntPtr

//
// size_t -> SSIZE_T conversion
//
#define SizeTToSSIZET   UIntPtrToLongPtr

//
// SSIZE_T -> INT8 conversion
//
#define SSIZETToInt8    LongPtrToInt8

//
// SSIZE_T -> UCHAR conversion
//
#define SSIZETToUChar   LongPtrToUChar

//
// SSIZE_T -> CHAR conversion
//
#define SSIZETToChar    LongPtrToChar

//
// SSIZE_T -> UINT8 conversion
//
#define SSIZETToUInt8   LongPtrToUInt8

//
// SSIZE_T -> BYTE conversion
//
#define SSIZETToByte    LongPtrToUInt8

//
// SSIZE_T -> SHORT conversion
//
#define SSIZETToShort   LongPtrToShort

//
// SSIZE_T -> INT16 conversion
//
#define SSIZETToInt16   LongPtrToShort

//
// SSIZE_T -> USHORT conversion
//
#define SSIZETToUShort  LongPtrToUShort

//
// SSIZE_T -> UINT16 conversion
//
#define SSIZETToUInt16  LongPtrToUShort

//
// SSIZE_T -> WORD conversion
//
#define SSIZETToWord    LongPtrToUShort

//
// SSIZE_T -> INT conversion
//
#define SSIZETToInt LongPtrToInt

//
// SSIZE_T -> INT32 conversion
//
#define SSIZETToInt32   LongPtrToInt

//
// SSIZE_T -> INT_PTR conversion
//
#define SSIZETToIntPtr  LongPtrToIntPtr

//
// SSIZE_T -> UINT conversion
//
#define SSIZETToUInt    LongPtrToUInt

//
// SSIZE_T -> UINT32 conversion
//
#define SSIZETToUInt32  LongPtrToUInt

//
// SSIZE_T -> UINT_PTR conversion
//
#define SSIZETToUIntPtr LongPtrToUIntPtr

//
// SSIZE_T -> LONG conversion
//
#define SSIZETToLong    LongPtrToLong

//
// SSIZE_T -> ULONG conversion
//
#define SSIZETToULong   LongPtrToULong

//
// SSIZE_T -> ULONG_PTR conversion
//
#define SSIZETToULongPtr    LongPtrToULongPtr

//
// SSIZE_T -> DWORD conversion
//
#define SSIZETToDWord   LongPtrToULong

//
// SSIZE_T -> DWORD_PTR conversion
//
#define SSIZETToDWordPtr    LongPtrToULongPtr

//
// SSIZE_T -> ULONGLONG conversion
//
#define SSIZETToULongLong   LongPtrToULongLong

//
// SSIZE_T -> DWORDLONG conversion
//
#define SSIZETToDWordLong   LongPtrToULongLong

//
// SSIZE_T -> ULONG64 conversion
//
#define SSIZETToULong64 LongPtrToULongLong

//
// SSIZE_T -> DWORD64 conversion
//
#define SSIZETToDWord64 LongPtrToULongLong

//
// SSIZE_T -> UINT64 conversion
//
#define SSIZETToUInt64  LongPtrToULongLong

//
// SSIZE_T -> size_t conversion
//
#define SSIZETToSizeT   LongPtrToUIntPtr

//
// SSIZE_T -> SIZE_T conversion
//
#define SSIZETToSIZET   LongPtrToULongPtr

//
// SIZE_T -> INT8 conversion
//
#define SIZETToInt8 ULongPtrToInt8

//
// SIZE_T -> UCHAR conversion
//
#define SIZETToUChar    ULongPtrToUChar

//
// SIZE_T -> CHAR conversion
//
#define SIZETToChar ULongPtrToChar

//
// SIZE_T -> UINT8 conversion
//
#define SIZETToUInt8    ULongPtrToUInt8

//
// SIZE_T -> BYTE conversion
//
#define SIZETToByte ULongPtrToUInt8

//
// SIZE_T -> SHORT conversion
//
#define SIZETToShort    ULongPtrToShort

//
// SIZE_T -> INT16 conversion
//
#define SIZETToInt16    ULongPtrToShort

//
// SIZE_T -> USHORT conversion
//
#define SIZETToUShort   ULongPtrToUShort

//
// SIZE_T -> UINT16 conversion
//
#define SIZETToUInt16   ULongPtrToUShort

//
// SIZE_T -> WORD
//
#define SIZETToWord ULongPtrToUShort

//
// SIZE_T -> INT conversion
//
#define SIZETToInt  ULongPtrToInt

//
// SIZE_T -> INT32 conversion
//
#define SIZETToInt32    ULongPtrToInt

//
// SIZE_T -> INT_PTR conversion
//
#define SIZETToIntPtr   ULongPtrToIntPtr

//
// SIZE_T -> UINT conversion
//
#define SIZETToUInt ULongPtrToUInt

//
// SIZE_T -> UINT32 conversion
//
#define SIZETToUInt32   ULongPtrToUInt

//
// SIZE_T -> UINT_PTR conversion
//
#define SIZETToUIntPtr  ULongPtrToUIntPtr

//
// SIZE_T -> LONG conversion
//
#define SIZETToLong ULongPtrToLong

//
// SIZE_T -> LONG_PTR conversion
//
#define SIZETToLongPtr  ULongPtrToLongPtr

//
// SIZE_T -> ULONG conversion
//
#define SIZETToULong    ULongPtrToULong

//
// SIZE_T -> DWORD conversion
//
#define SIZETToDWord    ULongPtrToULong

//
// SIZE_T -> LONGLONG conversion
//
#define SIZETToLongLong ULongPtrToLongLong

//
// SIZE_T -> LONG64 conversion
//
#define SIZETToLong64   ULongPtrToLongLong

//
// SIZE_T -> INT64
//
#define SIZETToInt64    ULongPtrToLongLong

//
// SIZE_T -> ptrdiff_t conversion
//
#define SIZETToPtrdiffT ULongPtrToIntPtr

//
// SIZE_T -> SSIZE_T conversion
//
#define SIZETToSSIZET   ULongPtrToLongPtr


//=============================================================================
// Addition functions
//=============================================================================

//
// UINT8 addition
//
__checkReturn
__inline
HRESULT
UInt8Add(
    __in UINT8 u8Augend,
    __in UINT8 u8Addend,
    __out __deref_out_range(==, u8Augend + u8Addend) UINT8* pu8Result)
{
    HRESULT hr;

    if (((UINT8)(u8Augend + u8Addend)) >= u8Augend)
    {
        *pu8Result = (UINT8)(u8Augend + u8Addend);
        hr = S_OK;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// USHORT addition
//
__checkReturn
__inline
HRESULT
UShortAdd(
    __in USHORT usAugend,
    __in USHORT usAddend,
    __out __deref_out_range(==, usAugend + usAddend) USHORT* pusResult)
{
    HRESULT hr;

    if (((USHORT)(usAugend + usAddend)) >= usAugend)
    {
        *pusResult = (USHORT)(usAugend + usAddend);
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT16 addition
//
#define UInt16Add   UShortAdd

//
// WORD addtition
//
#define WordAdd     UShortAdd

//
// UINT addition
//
__checkReturn
__inline
HRESULT
UIntAdd(
    __in UINT uAugend,
    __in UINT uAddend,
    __out __deref_out_range(==, uAugend + uAddend) UINT* puResult)
{
    HRESULT hr;

    if ((uAugend + uAddend) >= uAugend)
    {
        *puResult = (uAugend + uAddend);
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT32 addition
//
#define UInt32Add   UIntAdd

//
// UINT_PTR addition
//
#ifdef _WIN64
#define UIntPtrAdd      ULongLongAdd
#else
__checkReturn
__inline
HRESULT
UIntPtrAdd(
    __in UINT_PTR uAugend,
    __in UINT_PTR uAddend,
    __out __deref_out_range(==, uAugend + uAddend) UINT_PTR* puResult)
{
    HRESULT hr;

    if ((uAugend + uAddend) >= uAugend)
    {
        *puResult = (uAugend + uAddend);
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif // _WIN64

//
// ULONG addition
//
__checkReturn
__inline
HRESULT
ULongAdd(
    __in ULONG ulAugend,
    __in ULONG ulAddend,
    __out __deref_out_range(==, ulAugend + ulAddend) ULONG* pulResult)
{
    HRESULT hr;

    if ((ulAugend + ulAddend) >= ulAugend)
    {
        *pulResult = (ulAugend + ulAddend);
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG_PTR addition
//
#ifdef _WIN64
#define ULongPtrAdd     ULongLongAdd
#else
__checkReturn
__inline
HRESULT
ULongPtrAdd(
    __in ULONG_PTR ulAugend,
    __in ULONG_PTR ulAddend,
    __out __deref_out_range(==, ulAugend + ulAddend) ULONG_PTR* pulResult)
{
    HRESULT hr;

    if ((ulAugend + ulAddend) >= ulAugend)
    {
        *pulResult = (ulAugend + ulAddend);
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif // _WIN64

//
// DWORD addition
//
#define DWordAdd        ULongAdd

//
// DWORD_PTR addition
//
#ifdef _WIN64
#define DWordPtrAdd     ULongLongAdd
#else
__checkReturn
__inline
HRESULT
DWordPtrAdd(
    __in DWORD_PTR dwAugend,
    __in DWORD_PTR dwAddend,
    __out __deref_out_range(==, dwAugend + dwAddend) DWORD_PTR* pdwResult)
{
    HRESULT hr;

    if ((dwAugend + dwAddend) >= dwAugend)
    {
        *pdwResult = (dwAugend + dwAddend);
        hr = S_OK;
    }
    else
    {
        *pdwResult = DWORD_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif // _WIN64

//
// size_t addition
//
__checkReturn
__inline
HRESULT
SizeTAdd(
    __in size_t Augend,
    __in size_t Addend,
    __out __deref_out_range(==, Augend + Addend) size_t* pResult)
{
    HRESULT hr;

    if ((Augend + Addend) >= Augend)
    {
        *pResult = (Augend + Addend);
        hr = S_OK;
    }
    else
    {
        *pResult = SIZE_T_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// SIZE_T addition
//
#ifdef _WIN64
#define SIZETAdd      ULongLongAdd
#else
__checkReturn
__inline
HRESULT
SIZETAdd(
    __in SIZE_T Augend,
    __in SIZE_T Addend,
    __out __deref_out_range(==, Augend + Addend) SIZE_T* pResult)
{
    HRESULT hr;

    if ((Augend + Addend) >= Augend)
    {
        *pResult = (Augend + Addend);
        hr = S_OK;
    }
    else
    {
        *pResult = _SIZE_T_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif // _WIN64

//
// ULONGLONG addition
//
__checkReturn
__inline
HRESULT
ULongLongAdd(
    __in ULONGLONG ullAugend,
    __in ULONGLONG ullAddend,
    __out __deref_out_range(==, ullAugend + ullAddend) ULONGLONG* pullResult)
{
    HRESULT hr;

    if ((ullAugend + ullAddend) >= ullAugend)
    {
        *pullResult = (ullAugend + ullAddend);
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// DWORDLONG addition
//
#define DWordLongAdd    ULongLongAdd

//
// ULONG64 addition
//
#define ULong64Add  ULongLongAdd

//
// DWORD64 addition
//
#define DWord64Add  ULongLongAdd

//
// UINT64 addition
//
#define UInt64Add   ULongLongAdd


//=============================================================================
// Subtraction functions
//=============================================================================

//
// UINT8 subtraction
//
__checkReturn
__inline
HRESULT
UInt8Sub(
    __in UINT8 u8Minuend,
    __in UINT8 u8Subtrahend,
    __out __deref_out_range(==, u8Minuend - u8Subtrahend) UINT8* pu8Result)
{
    HRESULT hr;
    
    if (u8Minuend >= u8Subtrahend)
    {
        *pu8Result = (UINT8)(u8Minuend - u8Subtrahend);
        hr = S_OK;
    }
    else
    {
        *pu8Result = UINT8_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// USHORT subtraction
//
__checkReturn
__inline
HRESULT
UShortSub(
    __in USHORT usMinuend,
    __in USHORT usSubtrahend,
    __out __deref_out_range(==, usMinuend - usSubtrahend) USHORT* pusResult)
{
    HRESULT hr;

    if (usMinuend >= usSubtrahend)
    {
        *pusResult = (USHORT)(usMinuend - usSubtrahend);
        hr = S_OK;
    }
    else
    {
        *pusResult = USHORT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT16 subtraction
//
#define UInt16Sub  UShortSub

//
// WORD subtraction
//
#define WordSub    UShortSub


//
// UINT subtraction
//
__checkReturn
__inline
HRESULT
UIntSub(
    __in UINT uMinuend,
    __in UINT uSubtrahend,
    __out __deref_out_range(==, uMinuend - uSubtrahend) UINT* puResult)
{
    HRESULT hr;

    if (uMinuend >= uSubtrahend)
    {
        *puResult = (uMinuend - uSubtrahend);
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// UINT32 subtraction
//
#define UInt32Sub  UIntSub

//
// UINT_PTR subtraction
//
#ifdef _WIN64
#define UIntPtrSub ULongLongSub
#else
__checkReturn
__inline
HRESULT
UIntPtrSub(
    __in UINT_PTR uMinuend,
    __in UINT_PTR uSubtrahend,
    __out __deref_out_range(==, uMinuend - uSubtrahend) UINT_PTR* puResult)
{
    HRESULT hr;

    if (uMinuend >= uSubtrahend)
    {
        *puResult = (uMinuend - uSubtrahend);
        hr = S_OK;
    }
    else
    {
        *puResult = UINT_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif // _WIN64

//
// ULONG subtraction
//
__checkReturn
__inline
HRESULT
ULongSub(
    __in ULONG ulMinuend,
    __in ULONG ulSubtrahend,
    __out __deref_out_range(==, ulMinuend - ulSubtrahend) ULONG* pulResult)
{
    HRESULT hr;

    if (ulMinuend >= ulSubtrahend)
    {
        *pulResult = (ulMinuend - ulSubtrahend);
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// ULONG_PTR subtraction
//
#ifdef _WIN64
#define ULongPtrSub ULongLongSub
#else
__checkReturn
__inline
HRESULT
ULongPtrSub(
    __in ULONG_PTR ulMinuend,
    __in ULONG_PTR ulSubtrahend,
    __out __deref_out_range(==, ulMinuend - ulSubtrahend) ULONG_PTR* pulResult)
{
    HRESULT hr;

    if (ulMinuend >= ulSubtrahend)
    {
        *pulResult = (ulMinuend - ulSubtrahend);
        hr = S_OK;
    }
    else
    {
        *pulResult = ULONG_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif // _WIN64


//
// DWORD subtraction
//
#define DWordSub       ULongSub

//
// DWORD_PTR subtraction
//
#ifdef _WIN64
#define DWordPtrSub    ULongLongSub
#else
__checkReturn
__inline
HRESULT
DWordPtrSub(
    __in DWORD_PTR dwMinuend,
    __in DWORD_PTR dwSubtrahend,
    __out __deref_out_range(==, dwMinuend - dwSubtrahend) DWORD_PTR* pdwResult)
{
    HRESULT hr;

    if (dwMinuend >= dwSubtrahend)
    {
        *pdwResult = (dwMinuend - dwSubtrahend);
        hr = S_OK;
    }
    else
    {
        *pdwResult = DWORD_PTR_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
} 
#endif // _WIN64

//
// size_t subtraction
//
__checkReturn
__inline
HRESULT
SizeTSub(
    __in size_t Minuend,
    __in size_t Subtrahend,
    __out __deref_out_range(==, Minuend - Subtrahend) size_t* pResult)
{
    HRESULT hr;

    if (Minuend >= Subtrahend)
    {
        *pResult = (Minuend - Subtrahend);
        hr = S_OK;
    }
    else
    {
        *pResult = SIZE_T_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// SIZE_T subtraction
//
#ifdef _WIN64
#define SIZETSub   ULongLongSub
#else
__checkReturn
__inline
HRESULT
SIZETSub(
    __in SIZE_T Minuend,
    __in SIZE_T Subtrahend,
    __out __deref_out_range(==, Minuend - Subtrahend) SIZE_T* pResult)
{
    HRESULT hr;

    if (Minuend >= Subtrahend)
    {
        *pResult = (Minuend - Subtrahend);
        hr = S_OK;
    }
    else
    {
        *pResult = _SIZE_T_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}
#endif // _WIN64

//
// ULONGLONG subtraction
//
__checkReturn
__inline
HRESULT
ULongLongSub(
    __in ULONGLONG ullMinuend,
    __in ULONGLONG ullSubtrahend,
    __out __deref_out_range(==, ullMinuend - ullSubtrahend) ULONGLONG* pullResult)
{
    HRESULT hr;

    if (ullMinuend >= ullSubtrahend)
    {
        *pullResult = (ullMinuend - ullSubtrahend);
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    
    return hr;
}

//
// DWORDLONG subtraction
//
#define DWordLongSub   ULongLongSub

//
// ULONG64 subtraction
//
#define ULong64Sub ULongLongSub

//
// DWORD64 subtraction
//
#define DWord64Sub ULongLongSub

//
// UINT64 subtraction
//
#define UInt64Sub  ULongLongSub


//=============================================================================
// Multiplication functions
//=============================================================================

//
// UINT8 multiplication
//
__checkReturn
__inline
HRESULT
UInt8Mult(
    __in UINT8 u8Multiplicand,
    __in UINT8 u8Multiplier,
    __out __deref_out_range(==, u8Multiplicand * u8Multiplier) UINT8* pu8Result)
{
    UINT uResult = ((UINT)u8Multiplicand) * ((UINT)u8Multiplier);
    
    return UIntToUInt8(uResult, pu8Result);
}    

//
// USHORT multiplication
//
__checkReturn
__inline
HRESULT
UShortMult(
    __in USHORT usMultiplicand,
    __in USHORT usMultiplier,
    __out __deref_out_range(==, usMultiplicand * usMultiplier) USHORT* pusResult)
{
    ULONG ulResult = ((ULONG)usMultiplicand) * ((ULONG)usMultiplier);
    
    return ULongToUShort(ulResult, pusResult);
}

//
// UINT16 multiplication
//
#define UInt16Mult  UShortMult

//
// WORD multiplication
//
#define WordMult    UShortMult

//
// UINT multiplication
//
__checkReturn
__inline
HRESULT
UIntMult(
    __in UINT uMultiplicand,
    __in UINT uMultiplier,
    __out __deref_out_range(==, uMultiplicand * uMultiplier) UINT* puResult)
{
    ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

    return ULongLongToUInt(ull64Result, puResult);
}

//
// UINT32 multiplication
//
#define UInt32Mult  UIntMult

//
// UINT_PTR multiplication
//
#ifdef _WIN64
#define UIntPtrMult     ULongLongMult
#else
__checkReturn
__inline
HRESULT
UIntPtrMult(
    __in UINT_PTR uMultiplicand,
    __in UINT_PTR uMultiplier,
    __out __deref_out_range(==, uMultiplicand * uMultiplier) UINT_PTR* puResult)
{
    ULONGLONG ull64Result = UInt32x32To64(uMultiplicand, uMultiplier);

    return ULongLongToUIntPtr(ull64Result, puResult);
}
#endif // _WIN64

//
// ULONG multiplication
//
__checkReturn
__inline
HRESULT
ULongMult(
    __in ULONG ulMultiplicand,
    __in ULONG ulMultiplier,
    __out __deref_out_range(==, ulMultiplicand * ulMultiplier) ULONG* pulResult)
{
    ULONGLONG ull64Result = UInt32x32To64(ulMultiplicand, ulMultiplier);
    
    return ULongLongToULong(ull64Result, pulResult);
}

//
// ULONG_PTR multiplication
//
#ifdef _WIN64
#define ULongPtrMult    ULongLongMult
#else
__checkReturn
__inline
HRESULT
ULongPtrMult(
    __in ULONG_PTR ulMultiplicand,
    __in ULONG_PTR ulMultiplier,
    __out __deref_out_range(==, ulMultiplicand * ulMultiplier) ULONG_PTR* pulResult)
{
    ULONGLONG ull64Result = UInt32x32To64(ulMultiplicand, ulMultiplier);
    
    return ULongLongToULongPtr(ull64Result, pulResult);
}
#endif // _WIN64

//
// DWORD multiplication
//
#define DWordMult       ULongMult

//
// DWORD_PTR multiplication
//
#ifdef _WIN64
#define DWordPtrMult    ULongLongMult
#else
__checkReturn
__inline
HRESULT
DWordPtrMult(
    __in DWORD_PTR dwMultiplicand,
    __in DWORD_PTR dwMultiplier,
    __out __deref_out_range(==, dwMultiplicand * dwMultiplier) DWORD_PTR* pdwResult)
{
    ULONGLONG ull64Result = UInt32x32To64(dwMultiplicand, dwMultiplier);
    
    return ULongLongToDWordPtr(ull64Result, pdwResult);
}
#endif // _WIN64

//
// size_t multiplication
//

#ifdef _WIN64
#define SizeTMult       ULongLongMult
#else
__checkReturn
__inline
HRESULT
SizeTMult(
    __in size_t Multiplicand,
    __in size_t Multiplier,
    __out __deref_out_range(==, Multiplicand * Multiplier) size_t* pResult)
{
    ULONGLONG ull64Result = UInt32x32To64(Multiplicand, Multiplier);

    return ULongLongToSizeT(ull64Result, pResult);
}
#endif // _WIN64

//
// SIZE_T multiplication
//
#ifdef _WIN64
#define SIZETMult       ULongLongMult
#else
__checkReturn
__inline
HRESULT
SIZETMult(
    __in SIZE_T Multiplicand,
    __in SIZE_T Multiplier,
    __out __deref_out_range(==, Multiplicand * Multiplier) SIZE_T* pResult)
{
    ULONGLONG ull64Result = UInt32x32To64(Multiplicand, Multiplier);
    
    return ULongLongToSIZET(ull64Result, pResult);
}
#endif // _WIN64

//
// ULONGLONG multiplication
//
__checkReturn
__inline
HRESULT
ULongLongMult(
    __in ULONGLONG ullMultiplicand,
    __in ULONGLONG ullMultiplier,
    __out __deref_out_range(==, ullMultiplicand * ullMultiplier) ULONGLONG* pullResult)
{
    HRESULT hr;
#if defined(_USE_INTRINSIC_MULTIPLY128)
    ULONGLONG ullResultHigh;
    ULONGLONG ullResultLow;
    
    ullResultLow = UnsignedMultiply128(ullMultiplicand, ullMultiplier, &ullResultHigh);
    if (ullResultHigh == 0)
    {
        *pullResult = ullResultLow;
        hr = S_OK;
    }
    else
    {
        *pullResult = ULONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
#else
    // 64x64 into 128 is like 32.32 x 32.32.
    //
    // a.b * c.d = a*(c.d) + .b*(c.d) = a*c + a*.d + .b*c + .b*.d
    // back in non-decimal notation where A=a*2^32 and C=c*2^32:  
    // A*C + A*d + b*C + b*d
    // So there are four components to add together.
    //   result = (a*c*2^64) + (a*d*2^32) + (b*c*2^32) + (b*d)
    //
    // a * c must be 0 or there would be bits in the high 64-bits
    // a * d must be less than 2^32 or there would be bits in the high 64-bits
    // b * c must be less than 2^32 or there would be bits in the high 64-bits
    // then there must be no overflow of the resulting values summed up.
    
    ULONG dw_a;
    ULONG dw_b;
    ULONG dw_c;
    ULONG dw_d;
    ULONGLONG ad = 0;
    ULONGLONG bc = 0;
    ULONGLONG bd = 0;
    ULONGLONG ullResult = 0;

    hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    
    dw_a = (ULONG)(ullMultiplicand >> 32);
    dw_c = (ULONG)(ullMultiplier >> 32);

    // common case -- if high dwords are both zero, no chance for overflow
    if ((dw_a == 0) && (dw_c == 0))
    {
        dw_b = (DWORD)ullMultiplicand;
        dw_d = (DWORD)ullMultiplier;

        *pullResult = (((ULONGLONG)dw_b) * (ULONGLONG)dw_d);
        hr = S_OK;
    }
    else
    {
        // a * c must be 0 or there would be bits set in the high 64-bits
        if ((dw_a == 0) ||
            (dw_c == 0))
        {
            dw_d = (DWORD)ullMultiplier;

            // a * d must be less than 2^32 or there would be bits set in the high 64-bits
            ad = (((ULONGLONG)dw_a) * (ULONGLONG)dw_d);
            if ((ad & 0xffffffff00000000) == 0)
            {
                dw_b = (DWORD)ullMultiplicand;

                // b * c must be less than 2^32 or there would be bits set in the high 64-bits
                bc = (((ULONGLONG)dw_b) * (ULONGLONG)dw_c);
                if ((bc & 0xffffffff00000000) == 0)
                {
                    // now sum them all up checking for overflow.
                    // shifting is safe because we already checked for overflow above
                    if (SUCCEEDED(ULongLongAdd(bc << 32, ad << 32, &ullResult)))                        
                    {
                        // b * d
                        bd = (((ULONGLONG)dw_b) * (ULONGLONG)dw_d);
                    
                        if (SUCCEEDED(ULongLongAdd(ullResult, bd, &ullResult)))
                        {
                            *pullResult = ullResult;
                            hr = S_OK;
                        }
                    }
                }
            }
        }
    }

    if (FAILED(hr))
    {
        *pullResult = ULONGLONG_ERROR;
    }
#endif // _USE_INTRINSIC_MULTIPLY128
    
    return hr;
}

//
// DWORDLONG multiplication
//
#define DWordLongMult   ULongLongMult

//
// ULONG64 multiplication
//
#define ULong64Mult ULongLongMult

//
// DWORD64 multiplication
//
#define DWord64Mult ULongLongMult

//
// UINT64 multiplication
//
#define UInt64Mult  ULongLongMult


/////////////////////////////////////////////////////////////////////////
//
// signed operations
//
// Strongly consider using unsigned numbers.
//
// Signed numbers are often used where unsigned numbers should be used.
// For example file sizes and array indices should always be unsigned.
// (File sizes should be 64bit integers; array indices should be size_t.)
// Subtracting a larger positive signed number from a smaller positive
// signed number with IntSubwill succeed, producing a negative number,
// that then must not be used as an array index (but can occasionally be
// used as a pointer index.) Similarly for adding a larger magnitude
// negative number to a smaller magnitude positive number.
//
// intsafe.h does not protect you from such errors. It tells you if your
// integer operations overflowed, not if you are doing the right thing
// with your non-overflowed integers.
//
// Likewise you can overflow a buffer with a non-overflowed unsigned index.
//
#if defined(ENABLE_INTSAFE_SIGNED_FUNCTIONS)

#if defined(_USE_INTRINSIC_MULTIPLY128)
#ifdef __cplusplus
extern "C" {
#endif

#define Multiply128 _mul128

LONG64
Multiply128(
    __in LONG64 Multiplier,
    __in LONG64  Multiplicand,
    __out LONG64 *HighProduct
    );
#pragma intrinsic(_mul128)

#ifdef __cplusplus
}
#endif
#endif // _USE_INTRINSIC_MULTIPLY128


//=============================================================================
// Signed addition functions
//=============================================================================

//
// INT8 Addition
//
__checkReturn
__inline
HRESULT
Int8Add(
    __in INT8 i8Augend,
    __in INT8 i8Addend,
    __out __deref_out_range(==, i8Augend + i8Addend) INT8* pi8Result
    )
{
    C_ASSERT(sizeof(LONG) > sizeof(INT8));
    return LongToInt8(((LONG)i8Augend) + ((LONG)i8Addend), pi8Result);
}

//
// SHORT Addition
//
__checkReturn
__inline
HRESULT
ShortAdd(
    __in SHORT sAugend,
    __in SHORT sAddend,
    __out __deref_out_range(==, sAugend + sAddend) SHORT* psResult
    )
{
    C_ASSERT(sizeof(LONG) > sizeof(SHORT));
    return LongToShort(((LONG)sAugend) + ((LONG)sAddend), psResult);
}

//
// INT16 Addition
//
#define Int16Add    ShortAdd

//
// INT Addition
//
__checkReturn
__inline
HRESULT
IntAdd(
    __in INT iAugend,
    __in INT iAddend,
    __out __deref_out_range(==, iAugend + iAddend) INT* piResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(INT));
    return LongLongToInt(((LONGLONG)iAugend) + ((LONGLONG)iAddend), piResult);
}

//
// INT32 Addition
//
#define Int32Add    IntAdd

//
// INT_PTR addition
//
#ifdef _WIN64
#define IntPtrAdd   LongLongAdd
#else
__checkReturn
__inline
HRESULT
IntPtrAdd(
    __in INT_PTR iAugend,
    __in INT_PTR iAddend,
    __out __deref_out_range(==, iAugend + iAddend) INT_PTR* piResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(INT_PTR));
    return LongLongToIntPtr(((LONGLONG)iAugend) + ((LONGLONG)iAddend), piResult);
}
#endif

//
// LONG Addition
//
__checkReturn
__inline
HRESULT
LongAdd(
    __in LONG lAugend,
    __in LONG lAddend,
    __out __deref_out_range(==, lAugend + lAddend) LONG* plResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(LONG));
    return LongLongToLong(((LONGLONG)lAugend) + ((LONGLONG)lAddend), plResult);
}

//
// LONG32 Addition
//
#define Long32Add   IntAdd

//
// LONG_PTR Addition
//
#ifdef _WIN64
#define LongPtrAdd   LongLongAdd
#else
__checkReturn
__inline
HRESULT
LongPtrAdd(
    __in LONG_PTR lAugend,
    __in LONG_PTR lAddend,
    __out __deref_out_range(==, lAugend + lAddend) LONG_PTR* plResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(LONG_PTR));
    return LongLongToLongPtr(((LONGLONG)lAugend) + ((LONGLONG)lAddend), plResult);
}
#endif

//
// LONGLONG Addition
//
__checkReturn
__inline
HRESULT
LongLongAdd(
    __in LONGLONG llAugend,
    __in LONGLONG llAddend,
    __out __deref_out_range(==, llAugend + llAddend) LONGLONG* pllResult
    )
{
    HRESULT hr;
    LONGLONG llResult = llAugend + llAddend;
    
    //
    // Adding positive to negative never overflows.
    // If you add two positive numbers, you expect a positive result.
    // If you add two negative numbers, you expect a negative result.
    // Overflow if inputs are the same sign and output is not that sign.
    //
    if (((llAugend < 0) == (llAddend < 0))  &&
        ((llAugend < 0) != (llResult < 0)))
    {
        *pllResult = LONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    else
    {
        *pllResult = llResult;
        hr = S_OK;
    }

    return hr;
}

//
// LONG64 Addition
//
#define Long64Add   LongLongAdd

//
// INT64 Addition
//
#define Int64Add    LongLongAdd

//
// ptrdiff_t Addition
//
#ifdef _WIN64
#define PtrdiffTAdd LongLongAdd
#else
__checkReturn
__inline
HRESULT
PtrdiffTAdd(
    __in ptrdiff_t Augend,
    __in ptrdiff_t Addend,
    __out __deref_out_range(==, Augend + Addend) ptrdiff_t* pResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(ptrdiff_t));
    return LongLongToPtrdiffT(((LONGLONG)Augend) + ((LONGLONG)Addend), pResult);
}
#endif

//
// SSIZE_T Addition
//
#ifdef _WIN64
#define SSIZETAdd   LongLongAdd
#else
__checkReturn
__inline
HRESULT
SSIZETAdd(
    __in SSIZE_T Augend,
    __in SSIZE_T Addend,
    __out __deref_out_range(==, Augend + Addend) SSIZE_T* pResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(SSIZE_T));
    return LongLongToSSIZET(((LONGLONG)Augend) + ((LONGLONG)Addend), pResult);
}
#endif


//=============================================================================
// Signed subtraction functions
//=============================================================================

//
// INT8 Subtraction
//
__checkReturn
__inline
HRESULT
Int8Sub(
    __in INT8 i8Minuend,
    __in INT8 i8Subtrahend,
    __out __deref_out_range(==, i8Minuend - i8Subtrahend) INT8* pi8Result
    )
{
    C_ASSERT(sizeof(LONG) > sizeof(INT8));
    return LongToInt8(((LONG)i8Minuend) - ((LONG)i8Subtrahend), pi8Result);
}

//
// SHORT Subtraction
//
__checkReturn
__inline
HRESULT
ShortSub(
    __in SHORT sMinuend,
    __in SHORT sSubtrahend,
    __out __deref_out_range(==, sMinuend - sSubtrahend) SHORT* psResult
    )
{
    C_ASSERT(sizeof(LONG) > sizeof(SHORT));
    return LongToShort(((LONG)sMinuend) - ((LONG)sSubtrahend), psResult);
}

//
// INT16 Subtraction
//
#define Int16Sub   ShortSub

//
// INT Subtraction
//
__checkReturn
__inline
HRESULT
IntSub(
    __in INT iMinuend,
    __in INT iSubtrahend,
    __out __deref_out_range(==, iMinuend - iSubtrahend) INT* piResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(INT));
    return LongLongToInt(((LONGLONG)iMinuend) - ((LONGLONG)iSubtrahend), piResult);
}

//
// INT32 Subtraction
//
#define Int32Sub   IntSub

//
// INT_PTR Subtraction
//
#ifdef _WIN64
#define IntPtrSub  LongLongSub
#else
__checkReturn
__inline
HRESULT
IntPtrSub(
    __in INT_PTR iMinuend,
    __in INT_PTR iSubtrahend,
    __out __deref_out_range(==, iMinuend - iSubtrahend) INT_PTR* piResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(INT_PTR));
    return LongLongToIntPtr(((LONGLONG)iMinuend) - ((LONGLONG)iSubtrahend), piResult);
}
#endif

//
// LONG Subtraction
//
__checkReturn
__inline
HRESULT
LongSub(
    __in LONG lMinuend,
    __in LONG lSubtrahend,
    __out __deref_out_range(==, lMinuend - lSubtrahend) LONG* plResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(LONG));
    return LongLongToLong(((LONGLONG)lMinuend) - ((LONGLONG)lSubtrahend), plResult);
}

//
// LONG32 Subtraction
//
#define Long32Sub  IntSub

//
// LONG_PTR Subtraction
//
#ifdef _WIN64
#define LongPtrSub  LongLongSub
#else
__checkReturn
__inline
HRESULT
LongPtrSub(
    __in LONG_PTR lMinuend,
    __in LONG_PTR lSubtrahend,
    __out __deref_out_range(==, lMinuend - lSubtrahend) LONG_PTR* plResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(LONG_PTR));
    return LongLongToLongPtr(((LONGLONG)lMinuend) - ((LONGLONG)lSubtrahend), plResult);
}
#endif

//
// LongLongSub
//
__checkReturn
__inline
HRESULT
LongLongSub(
    __in LONGLONG llMinuend,
    __in LONGLONG llSubtrahend,
    __out __deref_out_range(==, llMinuend - llSubtrahend) LONGLONG* pllResult
    )
{
    HRESULT hr;
    LONGLONG llResult = llMinuend - llSubtrahend;

    //
    // Subtracting a positive number from a positive number never overflows.
    // Subtracting a negative number from a negative number never overflows.
    // If you subtract a negative number from a positive number, you expect a positive result.
    // If you subtract a positive number from a negative number, you expect a negative result.
    // Overflow if inputs vary in sign and the output does not have the same sign as the first input.
    //
    if (((llMinuend < 0) != (llSubtrahend < 0)) &&
        ((llMinuend < 0) != (llResult < 0)))
    {
        *pllResult = LONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    else
    {
        *pllResult = llResult;
        hr = S_OK;
    }
    
    return hr;
}

//
// LONG64 Subtraction
//
#define Long64Sub  LongLongSub

//
// INT64 Subtraction
//
#define Int64Sub   LongLongSub

//
// ptrdiff_t Subtraction
//
#ifdef _WIN64
#define PtrdiffTSub LongLongSub
#else
__checkReturn
__inline
HRESULT
PtrdiffTSub(
    __in ptrdiff_t Minuend,
    __in ptrdiff_t Subtrahend,
    __out __deref_out_range(==, Minuend - Subtrahend) ptrdiff_t* pResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(ptrdiff_t));
    return LongLongToPtrdiffT(((LONGLONG)Minuend) - ((LONGLONG)Subtrahend), pResult);
}
#endif

//
// SSIZE_T Subtraction
//
#ifdef _WIN64
#define SSIZETSub  LongLongSub
#else
__checkReturn
__inline
HRESULT
SSIZETSub(
    __in SSIZE_T Minuend,
    __in SSIZE_T Subtrahend,
    __out __deref_out_range(==, Minuend - Subtrahend) SSIZE_T* pResult)
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(SSIZE_T));
    return LongLongToSSIZET(((LONGLONG)Minuend) - ((LONGLONG)Subtrahend), pResult);
}
#endif


//=============================================================================
// Signed multiplication functions
//=============================================================================

//
// INT8 multiplication
//
__checkReturn
__inline
HRESULT
Int8Mult(
    __in INT8 i8Multiplicand,
    __in INT8 i8Multiplier,
    __out __deref_out_range(==, i8Multiplicand * i8Multiplier) INT8* pi8Result
    )
{
    C_ASSERT(sizeof(LONG) > sizeof(INT8));
    return LongToInt8(((LONG)i8Multiplier) * ((LONG)i8Multiplicand), pi8Result);
}

//
// SHORT multiplication
//
__checkReturn
__inline
HRESULT
ShortMult(
    __in SHORT sMultiplicand,
    __in SHORT sMultiplier,
    __out __deref_out_range(==, sMultiplicand * sMultiplier) SHORT* psResult
    )
{
    C_ASSERT(sizeof(LONG) > sizeof(SHORT));
    return LongToShort(((LONG)sMultiplicand) * ((LONG)sMultiplier), psResult);
}

//
// INT16 multiplication
//
#define Int16Mult   ShortMult

//
// INT multiplication
//
__checkReturn
__inline
HRESULT
IntMult(
    __in INT iMultiplicand,
    __in INT iMultiplier,
    __out __deref_out_range(==, iMultiplicand * iMultiplier) INT* piResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(INT));
    return LongLongToInt(((LONGLONG)iMultiplicand) * ((LONGLONG)iMultiplier), piResult);
}

//
// INT32 multiplication
//
#define Int32Mult   IntMult

//
// INT_PTR multiplication
//
#ifdef _WIN64
#define IntPtrMult   LongLongMult
#else
__checkReturn
__inline
HRESULT
IntPtrMult(
    __in INT_PTR iMultiplicand,
    __in INT_PTR iMultiplier,
    __out __deref_out_range(==, iMultiplicand * iMultiplier) INT_PTR* piResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(INT_PTR));
    return LongLongToIntPtr(((LONGLONG)iMultiplicand) * ((LONGLONG)iMultiplier), piResult);
}
#endif

//
// LONG multiplication
//
__checkReturn
__inline
HRESULT
LongMult(
    __in LONG lMultiplicand,
    __in LONG lMultiplier,
    __out __deref_out_range(==, lMultiplicand * lMultiplier) LONG* plResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(LONG));
    return LongLongToLong(((LONGLONG)lMultiplicand) * ((LONGLONG)lMultiplier), plResult);
}

//
// LONG32 multiplication
//
#define Long32Mult  IntMult

//
// LONG_PTR multiplication
//
#ifdef _WIN64
#define LongPtrMult LongLongMult
#else
__checkReturn
__inline
HRESULT
LongPtrMult(
    __in LONG_PTR lMultiplicand,
    __in LONG_PTR lMultiplier,
    __out __deref_out_range(==, lMultiplicand * lMultiplier) LONG_PTR* plResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(LONG_PTR));
    return LongLongToLongPtr(((LONGLONG)lMultiplicand) * ((LONGLONG)lMultiplier), plResult);
}
#endif

//
// LONGLONG multiplication
//
__checkReturn
__inline
HRESULT
LongLongMult(
    __in LONGLONG llMultiplicand,
    __in LONGLONG llMultiplier,
    __out __deref_out_range(==, llMultiplicand * llMultiplier) LONGLONG* pllResult
    )
{
    HRESULT hr;

#if defined(_USE_INTRINSIC_MULTIPLY128)
    LONGLONG llResultHigh;
    LONGLONG llResultLow;
    
    llResultLow = Multiply128(llMultiplicand, llMultiplier, &llResultHigh);
    
    if (((llResultLow < 0) && (llResultHigh != -1))    || 
        ((llResultLow >= 0) && (llResultHigh != 0)))
    {
        *pllResult = LONGLONG_ERROR;
        hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
    }
    else
    {
        *pllResult = llResultLow;
        hr = S_OK;
    }
#else // _USE_INTRINSIC_MULTIPLY128
    //
    // Split into sign and magnitude, do unsigned operation, apply sign.
    //
    
    ULONGLONG ullMultiplicand;
    ULONGLONG ullMultiplier;
    ULONGLONG ullResult;
    const ULONGLONG LONGLONG_MIN_MAGNITUDE = ((((ULONGLONG) - (LONGLONG_MIN + 1))) + 1);

    if (llMultiplicand < 0)
    {
        //
        // Avoid negating the most negative number.
        //
        ullMultiplicand = ((ULONGLONG)(- (llMultiplicand + 1))) + 1;
    }
    else
    {
        ullMultiplicand = (ULONGLONG)llMultiplicand;
    }

    if (llMultiplier < 0)
    {
        //
        // Avoid negating the most negative number.
        //
        ullMultiplier = ((ULONGLONG)(- (llMultiplier + 1))) + 1;
    }
    else
    {
        ullMultiplier = (ULONGLONG)llMultiplier;
    }

    hr = ULongLongMult(ullMultiplicand, ullMultiplier, &ullResult);
    if (SUCCEEDED(hr))
    {
        if ((llMultiplicand < 0) != (llMultiplier < 0))
        {
            if (ullResult > LONGLONG_MIN_MAGNITUDE)
            {
                *pllResult = LONGLONG_ERROR;
                hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
            }
            else
            {
                *pllResult = - ((LONGLONG)ullResult);
            }
        }
        else
        {
            if (ullResult > LONGLONG_MAX)
            {
                *pllResult = LONGLONG_ERROR;
                hr = INTSAFE_E_ARITHMETIC_OVERFLOW;
            }
            else
            {
                *pllResult = (LONGLONG)ullResult;
            }
        }
    }
    else
    {
        *pllResult = LONGLONG_ERROR;
    }
#endif // _USE_INTRINSIC_MULTIPLY128

    return hr;
}

//
// LONG64 multiplication
//
#define Long64Mult  LongLongMult

//
// INT64 multiplication
//
#define Int64Mult   LongLongMult

//
// ptrdiff_t multiplication
//
#ifdef _WIN64
#define PtrdiffTMult    LongLongMult
#else
__checkReturn
__inline
HRESULT
PtrdiffTMult(
    __in ptrdiff_t Multiplicand,
    __in ptrdiff_t Multiplier,
    __out __deref_out_range(==, Multiplicand * Multiplier) ptrdiff_t* pResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(ptrdiff_t));
    return LongLongToPtrdiffT(((LONGLONG)Multiplicand) * ((LONGLONG)Multiplier), pResult);
}
#endif

//
// SSIZE_T multiplication
//
#ifdef _WIN64
#define SSIZETMult  LongLongMult
#else
__checkReturn
__inline
HRESULT
SSIZETMult(
    __in SSIZE_T Multiplicand,
    __in SSIZE_T Multiplier,
    __out __deref_out_range(==, Multiplicand * Multiplier) SSIZE_T* pResult
    )
{
    C_ASSERT(sizeof(LONGLONG) > sizeof(SSIZE_T));
    return LongLongToSSIZET(((LONGLONG)Multiplicand) * ((LONGLONG)Multiplier), pResult);
}
#endif

#endif // ENABLE_INTSAFE_SIGNED_FUNCTIONS

//
// Macros that are no longer used in this header but which clients may
// depend on being defined here.
//
#define LOWORD(_dw)     ((WORD)(((DWORD_PTR)(_dw)) & 0xffff))
#define HIWORD(_dw)     ((WORD)((((DWORD_PTR)(_dw)) >> 16) & 0xffff))
#define LODWORD(_qw)    ((DWORD)(_qw))
#define HIDWORD(_qw)    ((DWORD)(((_qw) >> 32) & 0xffffffff))

#endif // _INTSAFE_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IPExport.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**     Copyright (c) Microsoft Corporation. All rights reserved.  **/
/********************************************************************/
/* :ts=4 */

//** IPEXPORT.H - IP public definitions.
//
//  This file contains public definitions exported to transport layer and
//  application software.
//

#ifndef IP_EXPORT_INCLUDED
#define IP_EXPORT_INCLUDED  1

#if _MSC_VER > 1000
#pragma once
#endif

//
// IP type definitions.
//
typedef ULONG IPAddr;       // An IP address.
typedef ULONG IPMask;       // An IP subnet mask.
typedef ULONG IP_STATUS;    // Status code returned from IP APIs.

#include <in6addr.h>

typedef struct in6_addr IPv6Addr;

#include <inaddr.h>

/*INC*/

//
// The ip_option_information structure describes the options to be
// included in the header of an IP packet. The TTL, TOS, and Flags
// values are carried in specific fields in the header. The OptionsData
// bytes are carried in the options area following the standard IP header.
// With the exception of source route options, this data must be in the
// format to be transmitted on the wire as specified in RFC 791. A source
// route option should contain the full route - first hop thru final
// destination - in the route data. The first hop will be pulled out of the
// data and the option will be reformatted accordingly. Otherwise, the route
// option should be formatted as specified in RFC 791.
//

typedef struct ip_option_information {
    UCHAR   Ttl;                // Time To Live
    UCHAR   Tos;                // Type Of Service
    UCHAR   Flags;              // IP header flags
    UCHAR   OptionsSize;        // Size in bytes of options data
    PUCHAR  OptionsData;        // Pointer to options data
} IP_OPTION_INFORMATION, *PIP_OPTION_INFORMATION;

#if defined(_WIN64)

typedef struct ip_option_information32 {
    UCHAR   Ttl;
    UCHAR   Tos;
    UCHAR   Flags;
    UCHAR   OptionsSize;
    UCHAR * POINTER_32 OptionsData;
} IP_OPTION_INFORMATION32, *PIP_OPTION_INFORMATION32;

#endif // _WIN64

//
// The icmp_echo_reply structure describes the data returned in response
// to an echo request.
//

typedef struct icmp_echo_reply {
    IPAddr  Address;            // Replying address
    ULONG   Status;             // Reply IP_STATUS
    ULONG   RoundTripTime;      // RTT in milliseconds
    USHORT  DataSize;           // Reply data size in bytes
    USHORT  Reserved;           // Reserved for system use
    PVOID   Data;               // Pointer to the reply data
    struct ip_option_information Options; // Reply options
} ICMP_ECHO_REPLY, *PICMP_ECHO_REPLY;

#if defined(_WIN64)

typedef struct icmp_echo_reply32 {
    IPAddr  Address;
    ULONG   Status;
    ULONG   RoundTripTime;
    USHORT  DataSize;
    USHORT  Reserved;
    VOID * POINTER_32 Data;
    struct ip_option_information32 Options;
} ICMP_ECHO_REPLY32, *PICMP_ECHO_REPLY32;

#endif // _WIN64

#if (NTDDI_VERSION >= NTDDI_XP)
#include <packon.h>
typedef struct _IPV6_ADDRESS_EX {
    USHORT sin6_port;
    ULONG  sin6_flowinfo;
    USHORT sin6_addr[8];
    ULONG  sin6_scope_id;
} IPV6_ADDRESS_EX, *PIPV6_ADDRESS_EX;
#include <packoff.h>

typedef struct icmpv6_echo_reply_lh {
    IPV6_ADDRESS_EX Address;    // Replying address.
    ULONG Status;               // Reply IP_STATUS.
    unsigned int RoundTripTime; // RTT in milliseconds.
    // Reply data follows this structure in memory.
} ICMPV6_ECHO_REPLY_LH, *PICMPV6_ECHO_REPLY_LH;

typedef ICMPV6_ECHO_REPLY_LH ICMPV6_ECHO_REPLY;
typedef ICMPV6_ECHO_REPLY_LH *PICMPV6_ECHO_REPLY;

#endif

typedef struct arp_send_reply {
    IPAddr  DestAddress;
    IPAddr  SrcAddress;
} ARP_SEND_REPLY, *PARP_SEND_REPLY;

typedef struct tcp_reserve_port_range {
    USHORT  UpperRange;
    USHORT  LowerRange;
} TCP_RESERVE_PORT_RANGE, *PTCP_RESERVE_PORT_RANGE;

#define MAX_ADAPTER_NAME 128

typedef struct _IP_ADAPTER_INDEX_MAP {
    ULONG   Index;
    WCHAR   Name[MAX_ADAPTER_NAME];
} IP_ADAPTER_INDEX_MAP, *PIP_ADAPTER_INDEX_MAP;

typedef struct _IP_INTERFACE_INFO {
    LONG    NumAdapters;
    IP_ADAPTER_INDEX_MAP Adapter[1];
} IP_INTERFACE_INFO,*PIP_INTERFACE_INFO;

typedef struct _IP_UNIDIRECTIONAL_ADAPTER_ADDRESS {
    ULONG   NumAdapters;
    IPAddr  Address[1];
} IP_UNIDIRECTIONAL_ADAPTER_ADDRESS, *PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS;

typedef struct _IP_ADAPTER_ORDER_MAP {
    ULONG   NumAdapters;
    ULONG   AdapterOrder[1];
} IP_ADAPTER_ORDER_MAP, *PIP_ADAPTER_ORDER_MAP;

typedef struct _IP_MCAST_COUNTER_INFO {
    ULONG64 InMcastOctets;
    ULONG64 OutMcastOctets;
    ULONG64 InMcastPkts;
    ULONG64 OutMcastPkts;
} IP_MCAST_COUNTER_INFO, *PIP_MCAST_COUNTER_INFO;

//
// IP_STATUS codes returned from IP APIs
//

#define IP_STATUS_BASE              11000

#define IP_SUCCESS                  0
#define IP_BUF_TOO_SMALL            (IP_STATUS_BASE + 1)
#define IP_DEST_NET_UNREACHABLE     (IP_STATUS_BASE + 2)
#define IP_DEST_HOST_UNREACHABLE    (IP_STATUS_BASE + 3)
#define IP_DEST_PROT_UNREACHABLE    (IP_STATUS_BASE + 4)
#define IP_DEST_PORT_UNREACHABLE    (IP_STATUS_BASE + 5)
#define IP_NO_RESOURCES             (IP_STATUS_BASE + 6)
#define IP_BAD_OPTION               (IP_STATUS_BASE + 7)
#define IP_HW_ERROR                 (IP_STATUS_BASE + 8)
#define IP_PACKET_TOO_BIG           (IP_STATUS_BASE + 9)
#define IP_REQ_TIMED_OUT            (IP_STATUS_BASE + 10)
#define IP_BAD_REQ                  (IP_STATUS_BASE + 11)
#define IP_BAD_ROUTE                (IP_STATUS_BASE + 12)
#define IP_TTL_EXPIRED_TRANSIT      (IP_STATUS_BASE + 13)
#define IP_TTL_EXPIRED_REASSEM      (IP_STATUS_BASE + 14)
#define IP_PARAM_PROBLEM            (IP_STATUS_BASE + 15)
#define IP_SOURCE_QUENCH            (IP_STATUS_BASE + 16)
#define IP_OPTION_TOO_BIG           (IP_STATUS_BASE + 17)
#define IP_BAD_DESTINATION          (IP_STATUS_BASE + 18)

//
// Variants of the above using IPv6 terminology, where different
//

#define IP_DEST_NO_ROUTE            (IP_STATUS_BASE + 2)
#define IP_DEST_ADDR_UNREACHABLE    (IP_STATUS_BASE + 3)
#define IP_DEST_PROHIBITED          (IP_STATUS_BASE + 4)
#define IP_DEST_PORT_UNREACHABLE    (IP_STATUS_BASE + 5)
#define IP_HOP_LIMIT_EXCEEDED       (IP_STATUS_BASE + 13)
#define IP_REASSEMBLY_TIME_EXCEEDED (IP_STATUS_BASE + 14)
#define IP_PARAMETER_PROBLEM        (IP_STATUS_BASE + 15)

//
// IPv6-only status codes
//

#define IP_DEST_UNREACHABLE         (IP_STATUS_BASE + 40)
#define IP_TIME_EXCEEDED            (IP_STATUS_BASE + 41)
#define IP_BAD_HEADER               (IP_STATUS_BASE + 42)
#define IP_UNRECOGNIZED_NEXT_HEADER (IP_STATUS_BASE + 43)
#define IP_ICMP_ERROR               (IP_STATUS_BASE + 44)
#define IP_DEST_SCOPE_MISMATCH      (IP_STATUS_BASE + 45)

//
// The next group are status codes passed up on status indications to
// transport layer protocols.
//
#define IP_ADDR_DELETED             (IP_STATUS_BASE + 19)
#define IP_SPEC_MTU_CHANGE          (IP_STATUS_BASE + 20)
#define IP_MTU_CHANGE               (IP_STATUS_BASE + 21)
#define IP_UNLOAD                   (IP_STATUS_BASE + 22)
#define IP_ADDR_ADDED               (IP_STATUS_BASE + 23)
#define IP_MEDIA_CONNECT            (IP_STATUS_BASE + 24)
#define IP_MEDIA_DISCONNECT         (IP_STATUS_BASE + 25)
#define IP_BIND_ADAPTER             (IP_STATUS_BASE + 26)
#define IP_UNBIND_ADAPTER           (IP_STATUS_BASE + 27)
#define IP_DEVICE_DOES_NOT_EXIST    (IP_STATUS_BASE + 28)
#define IP_DUPLICATE_ADDRESS        (IP_STATUS_BASE + 29)
#define IP_INTERFACE_METRIC_CHANGE  (IP_STATUS_BASE + 30)
#define IP_RECONFIG_SECFLTR         (IP_STATUS_BASE + 31)
#define IP_NEGOTIATING_IPSEC        (IP_STATUS_BASE + 32)
#define IP_INTERFACE_WOL_CAPABILITY_CHANGE  (IP_STATUS_BASE + 33)
#define IP_DUPLICATE_IPADD          (IP_STATUS_BASE + 34)

#define IP_GENERAL_FAILURE          (IP_STATUS_BASE + 50)
#define MAX_IP_STATUS               IP_GENERAL_FAILURE
#define IP_PENDING                  (IP_STATUS_BASE + 255)


//
// Values used in the Flags field of IP_OPTION_INFORMATION.
//
#define IP_FLAG_REVERSE 0x1         // Do a round-trip echo request.
#define IP_FLAG_DF      0x2         // Don't fragment this packet.

//
// Supported IP Option Types.
//
// These types define the options which may be used in the OptionsData field
// of the ip_option_information structure.  See RFC 791 for a complete
// description of each.
//
#define IP_OPT_EOL      0          // End of list option
#define IP_OPT_NOP      1          // No operation
#define IP_OPT_SECURITY 0x82       // Security option
#define IP_OPT_LSRR     0x83       // Loose source route
#define IP_OPT_SSRR     0x89       // Strict source route
#define IP_OPT_RR       0x7        // Record route
#define IP_OPT_TS       0x44       // Timestamp
#define IP_OPT_SID      0x88       // Stream ID (obsolete)
#define IP_OPT_ROUTER_ALERT 0x94  // Router Alert Option

#define MAX_OPT_SIZE    40         // Maximum length of IP options in bytes

#ifdef CHICAGO

// Ioctls code exposed by Memphis tcpip stack.
// For NT these ioctls are define in ntddip.h  (private\inc)

#define IOCTL_IP_RTCHANGE_NOTIFY_REQUEST   101
#define IOCTL_IP_ADDCHANGE_NOTIFY_REQUEST  102
#define IOCTL_ARP_SEND_REQUEST             103
#define IOCTL_IP_INTERFACE_INFO            104
#define IOCTL_IP_GET_BEST_INTERFACE        105
#define IOCTL_IP_UNIDIRECTIONAL_ADAPTER_ADDRESS        106

#endif


#endif // IP_EXPORT_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IPHlpApi.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    iphlpapi.h

Abstract:
    Header file for functions to interact with the IP Stack for MIB-II and
    related functionality

--*/

#ifndef __IPHLPAPI_H__
#define __IPHLPAPI_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// IPRTRMIB.H has the definitions of the structures used to set and get     //
// information                                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <iprtrmib.h>
#include <ipexport.h>
#include <iptypes.h>
#include <tcpestats.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The GetXXXTable APIs take a buffer and a size of buffer.  If the buffer  //
// is not large enough, the APIs return ERROR_INSUFFICIENT_BUFFER  and      //
// *pdwSize is the required buffer size                                     //
// The bOrder is a BOOLEAN, which if TRUE sorts the table according to      //
// MIB-II (RFC XXXX)                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Retrieves the number of interfaces in the system. These include LAN and  //
// WAN interfaces                                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


DWORD
WINAPI
GetNumberOfInterfaces(
    __out PDWORD  pdwNumIf
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the MIB-II ifEntry                                                  //
// The dwIndex field of the MIB_IFROW should be set to the index of the     //
// interface being queried                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIfEntry(
    __inout PMIB_IFROW   pIfRow
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the MIB-II IfTable                                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIfTable(
    __out_bcount_opt(*pdwSize) PMIB_IFTABLE pIfTable,
    __inout                    PULONG       pdwSize,
    __in                       BOOL         bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the Interface to IP Address mapping                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpAddrTable(
    __out_bcount_opt(*pdwSize)    PMIB_IPADDRTABLE pIpAddrTable,
    __inout                       PULONG           pdwSize,
    __in                          BOOL             bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the current IP Address to Physical Address (ARP) mapping            //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

ULONG
WINAPI
GetIpNetTable(
    __out_bcount_opt(*SizePointer) PMIB_IPNETTABLE IpNetTable,
    __inout                        PULONG          SizePointer,
    __in                           BOOL            Order
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the IP Routing Table  (RFX XXXX)                                    //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetIpForwardTable(
    __out_bcount_opt(*pdwSize)    PMIB_IPFORWARDTABLE pIpForwardTable,
    __inout                       PULONG              pdwSize,
    __in                          BOOL                bOrder
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets TCP Connection/UDP Listener Table                                   //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

ULONG
WINAPI
GetTcpTable(
    __out_bcount_opt(*SizePointer)   PMIB_TCPTABLE TcpTable,
    __inout                          PULONG        SizePointer,
    __in                             BOOL          Order
    );

DWORD
WINAPI
GetExtendedTcpTable(
    __out_bcount_opt(*pdwSize)    PVOID           pTcpTable,
    __inout                       PDWORD          pdwSize,
    __in                          BOOL            bOrder,
    __in                          ULONG           ulAf,
    __in                          TCP_TABLE_CLASS TableClass,
    __in                          ULONG           Reserved
    );    

DWORD
WINAPI
GetOwnerModuleFromTcpEntry(
    __in                   PMIB_TCPROW_OWNER_MODULE      pTcpEntry,
    __in                   TCPIP_OWNER_MODULE_INFO_CLASS Class,
    __out_bcount(*pdwSize) PVOID                         pBuffer,
    __inout                PDWORD                        pdwSize
    );

ULONG
WINAPI
GetUdpTable(
    __out_bcount_opt(*SizePointer)   PMIB_UDPTABLE UdpTable,
    __inout                          PULONG        SizePointer,
    __in                             BOOL          Order
    );

DWORD
WINAPI
GetExtendedUdpTable(
    __out_bcount_opt(*pdwSize)    PVOID           pUdpTable,
    __inout                       PDWORD          pdwSize,
    __in                          BOOL            bOrder,
    __in                          ULONG           ulAf,
    __in                          UDP_TABLE_CLASS TableClass,
    __in                          ULONG           Reserved
    );

DWORD
WINAPI
GetOwnerModuleFromUdpEntry(
    __in                      PMIB_UDPROW_OWNER_MODULE      pUdpEntry,
    __in                      TCPIP_OWNER_MODULE_INFO_CLASS Class,
    __out_bcount(*pdwSize)    PVOID                         pBuffer,
    __inout                   PDWORD                        pdwSize
    );
    
#if (NTDDI_VERSION >= NTDDI_VISTA)
ULONG
WINAPI
GetTcpTable2(
    __out_bcount_opt(*SizePointer)   PMIB_TCPTABLE2 TcpTable,
    __inout                          PULONG         SizePointer,
    __in                             BOOL           Order
    );
#endif // (NTDDI_VERSION >= NTDDI_VISTA)  

#if (NTDDI_VERSION < NTDDI_VISTA)
//
// Deprecated APIs, Added for documentation.
//

DWORD
AllocateAndGetTcpExTableFromStack(
    __deref_out PVOID         *ppTcpTable,
    __in        BOOL          bOrder,
    __in        HANDLE        hHeap,
    __in        DWORD         dwFlags,
    __in        DWORD         dwFamily
    );

DWORD
AllocateAndGetUdpExTableFromStack(
    __deref_out PVOID         *ppUdpTable,
    __in        BOOL          bOrder,
    __in        HANDLE        hHeap,
    __in        DWORD         dwFlags,
    __in        DWORD         dwFamily
    );

#endif // (NTDDI_VERSION < NTDDI_VISTA) 

#ifdef _WS2IPDEF_
//
// The following definitions require Winsock2.
//

#if (NTDDI_VERSION >= NTDDI_VISTA)
ULONG
WINAPI
GetTcp6Table(
    __out_bcount(*SizePointer)   PMIB_TCP6TABLE TcpTable,
    __inout                      PULONG         SizePointer,
    __in                         BOOL           Order
    );

ULONG
WINAPI
GetTcp6Table2(
    __out_bcount(*SizePointer)   PMIB_TCP6TABLE2 TcpTable,
    __inout                      PULONG          SizePointer,
    __in                         BOOL            Order
    );

#endif // (NTDDI_VERSION >= NTDDI_VISTA)  

#ifdef WINAPI

ULONG
WINAPI
GetPerTcpConnectionEStats(
    __in PMIB_TCPROW Row,
    __in TCP_ESTATS_TYPE EstatsType,
    __out_bcount_opt(RwSize) PUCHAR Rw,
    __in ULONG RwVersion,
    __in ULONG RwSize,
    __out_bcount_opt(RosSize) PUCHAR Ros,
    __in ULONG RosVersion,
    __in ULONG RosSize,
    __out_bcount_opt(RodSize) PUCHAR Rod,
    __in ULONG RodVersion,
    __in ULONG RodSize
    );

ULONG
WINAPI
SetPerTcpConnectionEStats(
    __in PMIB_TCPROW Row,
    __in TCP_ESTATS_TYPE EstatsType,
    __in_bcount(RwSize) PUCHAR Rw,
    __in ULONG RwVersion,
    __in ULONG RwSize,
    __in ULONG Offset
    );

#ifdef _WS2IPDEF_

ULONG
WINAPI
GetPerTcp6ConnectionEStats(
    __in PMIB_TCP6ROW Row,
    __in TCP_ESTATS_TYPE EstatsType,
    __out_bcount_opt(RwSize) PUCHAR Rw,
    __in  ULONG RwVersion,
    __in  ULONG RwSize,
    __out_bcount_opt(RosSize) PUCHAR Ros,
    __in  ULONG RosVersion,
    __in  ULONG RosSize,
    __out_bcount_opt(RodSize) PUCHAR Rod,
    __in  ULONG RodVersion,
    __in  ULONG RodSize
    );

ULONG
WINAPI
SetPerTcp6ConnectionEStats(
    __in PMIB_TCP6ROW Row,
    __in TCP_ESTATS_TYPE EstatsType,
    __in_bcount(RwSize) PUCHAR Rw,
    __in ULONG RwVersion,
    __in ULONG RwSize,
    __in ULONG Offset
    );	

#endif // _WS2IPDEF_

#endif // WINAPI    

DWORD
WINAPI
GetOwnerModuleFromTcp6Entry(
    __in                      PMIB_TCP6ROW_OWNER_MODULE     pTcpEntry,
    __in                      TCPIP_OWNER_MODULE_INFO_CLASS Class,
    __out_bcount(*pdwSize)    PVOID                         pBuffer,
    __inout                   PDWORD                        pdwSize
    );    

ULONG
WINAPI
GetUdp6Table(
    __out_bcount(*SizePointer)   PMIB_UDP6TABLE Udp6Table,
    __inout                      PULONG         SizePointer,
    __in                         BOOL           Order
    );

DWORD
WINAPI
GetOwnerModuleFromUdp6Entry(
    __in                      PMIB_UDP6ROW_OWNER_MODULE     pUdpEntry,
    __in                      TCPIP_OWNER_MODULE_INFO_CLASS Class,
    __out_bcount(*pdwSize)    PVOID                         pBuffer,
    __inout                   PDWORD                        pdwSize
    );    

#endif // _WS2IPDEF_

DWORD
GetOwnerModuleFromPidAndInfo(
    __in                     ULONG                         ulPid,
    __in                     ULONGLONG                     *pInfo,
    __in                     TCPIP_OWNER_MODULE_INFO_CLASS Class,
    __out_bcount(*pdwSize)   PVOID                         pBuffer,
    __inout                  PDWORD                        pdwSize
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets IP/ICMP/TCP/UDP Statistics                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#if (NTDDI_VERSION >= NTDDI_WIN2K)
ULONG
WINAPI
GetIpStatistics(
    __out PMIB_IPSTATS Statistics
    );

ULONG
WINAPI
GetIcmpStatistics(
    __out PMIB_ICMP Statistics
    );


ULONG
WINAPI
GetTcpStatistics(
    __out PMIB_TCPSTATS Statistics
    );

ULONG
WINAPI
GetUdpStatistics(
    __out PMIB_UDPSTATS Stats
    );
#endif 

#if (NTDDI_VERSION >= NTDDI_XP)
ULONG
WINAPI
GetIpStatisticsEx(
    __out PMIB_IPSTATS Statistics,
    __in  ULONG Family
    );

ULONG
WINAPI
SetIpStatisticsEx(
    __in PMIB_IPSTATS Statistics,
    __in ULONG Family
    );

ULONG
WINAPI
GetIcmpStatisticsEx(
    __out PMIB_ICMP_EX Statistics,
    __in  ULONG Family
    );

ULONG
WINAPI
GetTcpStatisticsEx(
    __out PMIB_TCPSTATS Statistics,
    __in  ULONG Family
    );

ULONG
WINAPI
GetUdpStatisticsEx(
    __out PMIB_UDPSTATS Statistics,
    __in  ULONG Family
    );
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the ifAdminStatus on an interface.  The only fields of the   //
// MIB_IFROW that are relevant are the dwIndex (index of the interface      //
// whose status needs to be set) and the dwAdminStatus which can be either  //
// MIB_IF_ADMIN_STATUS_UP or MIB_IF_ADMIN_STATUS_DOWN                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetIfEntry(
    __in PMIB_IFROW pIfRow
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create, modify or delete a route.  In all cases the              //
// dwForwardIfIndex, dwForwardDest, dwForwardMask, dwForwardNextHop and     //
// dwForwardPolicy MUST BE SPECIFIED. Currently dwForwardPolicy is unused   //
// and MUST BE 0.                                                           //
// For a set, the complete MIB_IPFORWARDROW structure must be specified     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateIpForwardEntry(
    __in PMIB_IPFORWARDROW pRoute
    );

DWORD
WINAPI
SetIpForwardEntry(
    __in PMIB_IPFORWARDROW pRoute
    );

DWORD
WINAPI
DeleteIpForwardEntry(
    __in PMIB_IPFORWARDROW pRoute
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the ipForwarding to ON or OFF (currently only ON->OFF is     //
// allowed) and to set the defaultTTL.  If only one of the fields needs to  //
// be modified and the other needs to be the same as before the other field //
// needs to be set to MIB_USE_CURRENT_TTL or MIB_USE_CURRENT_FORWARDING as  //
// the case may be                                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#if (NTDDI_VERSION >= NTDDI_WIN2K)
DWORD
WINAPI
SetIpStatistics(
    __in PMIB_IPSTATS pIpStats
    );
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the defaultTTL.                                              //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetIpTTL(
    __in UINT nTTL
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create, modify or delete an ARP entry.  In all cases the dwIndex //
// dwAddr field MUST BE SPECIFIED.                                          //
// For a set, the complete MIB_IPNETROW structure must be specified         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateIpNetEntry(
    __in PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
SetIpNetEntry(
    __in PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
DeleteIpNetEntry(
    __in PMIB_IPNETROW    pArpEntry
    );

DWORD
WINAPI
FlushIpNetTable(
    __in DWORD   dwIfIndex
    );


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to create or delete a Proxy ARP entry. The dwIndex is the index of  //
// the interface on which to PARP for the dwAddress.  If the interface is   //
// of a type that doesnt support ARP, e.g. PPP, then the call will fail     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
CreateProxyArpEntry(
    __in  DWORD   dwAddress,
    __in  DWORD   dwMask,
    __in  DWORD   dwIfIndex
    );

DWORD
WINAPI
DeleteProxyArpEntry(
    __in  DWORD   dwAddress,
    __in  DWORD   dwMask,
    __in  DWORD   dwIfIndex
    );

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Used to set the state of a TCP Connection. The only state that it can be //
// set to is MIB_TCP_STATE_DELETE_TCB.  The complete MIB_TCPROW structure   //
// MUST BE SPECIFIED                                                        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
SetTcpEntry(
    __in PMIB_TCPROW pTcpRow
    );


DWORD
WINAPI
GetInterfaceInfo(
    __out_bcount_opt(*dwOutBufLen) PIP_INTERFACE_INFO  pIfTable,
    __inout                        PULONG              dwOutBufLen
    );

DWORD
WINAPI
GetUniDirectionalAdapterInfo(
    __out_bcount_opt(*dwOutBufLen) PIP_UNIDIRECTIONAL_ADAPTER_ADDRESS pIPIfInfo,
    __inout                        PULONG                             dwOutBufLen
    );

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
#ifndef NHPALLOCATEANDGETINTERFACEINFOFROMSTACK_DEFINED
#define NHPALLOCATEANDGETINTERFACEINFOFROMSTACK_DEFINED

DWORD
WINAPI
NhpAllocateAndGetInterfaceInfoFromStack(
    __deref_out IP_INTERFACE_NAME_INFO  **ppTable,
    __out       PDWORD                  pdwCount,
    __in        BOOL                    bOrder,
    __in        HANDLE                  hHeap,
    __in        DWORD                   dwFlags
    );

#endif
#endif // (NTDDI_VERSION >= NTDDI_WIN2KSP1)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the "best" outgoing interface for the specified destination address //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetBestInterface(
    __in  IPAddr  dwDestAddr,
    __out PDWORD  pdwBestIfIndex
    );

#pragma warning(push)
#pragma warning(disable:4115)
DWORD
WINAPI
GetBestInterfaceEx(
    __in  struct sockaddr *pDestAddr,
    __out PDWORD           pdwBestIfIndex
    );
#pragma warning(pop)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Gets the best (longest matching prefix) route for the given destination  //
// If the source address is also specified (i.e. is not 0x00000000), and    //
// there are multiple "best" routes to the given destination, the returned  //
// route will be one that goes out over the interface which has an address  //
// that matches the source address                                          //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

DWORD
WINAPI
GetBestRoute(
    __in      DWORD               dwDestAddr,
    __in_opt  DWORD               dwSourceAddr,
    __out     PMIB_IPFORWARDROW   pBestRoute
    );

DWORD
WINAPI
NotifyAddrChange(
    __out PHANDLE      Handle,
    __in  LPOVERLAPPED overlapped
    );


DWORD
WINAPI
NotifyRouteChange(
    __out PHANDLE      Handle,
    __in  LPOVERLAPPED overlapped
    );

BOOL
WINAPI
CancelIPChangeNotify(
    __in  LPOVERLAPPED notifyOverlapped
    );

DWORD
WINAPI
GetAdapterIndex(
    __in    LPWSTR  AdapterName,
    __inout PULONG IfIndex
    );

DWORD
WINAPI
AddIPAddress(
    __in IPAddr  Address,
    __in IPMask  IpMask,
    __in DWORD   IfIndex,
    __out PULONG  NTEContext,
    __out PULONG  NTEInstance
    );

DWORD
WINAPI
DeleteIPAddress(
    __in ULONG NTEContext
    );

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
DWORD
WINAPI
GetNetworkParams(
    __out_bcount_opt(*pOutBufLen)   PFIXED_INFO pFixedInfo, 
    __inout                         PULONG      pOutBufLen
    );
#endif

ULONG
WINAPI
GetAdaptersInfo(
    __out_bcount_opt(*SizePointer)  PIP_ADAPTER_INFO AdapterInfo, 
    __inout                         PULONG           SizePointer
    );

PIP_ADAPTER_ORDER_MAP 
WINAPI
GetAdapterOrderMap(
    VOID
    );

#ifdef _WINSOCK2API_

//
// The following functions require Winsock2.
//

ULONG
WINAPI
GetAdaptersAddresses(
    __in ULONG Family,
    __in ULONG Flags,
    __reserved PVOID Reserved,
    __out_bcount_opt(*SizePointer) PIP_ADAPTER_ADDRESSES AdapterAddresses, 
    __inout PULONG SizePointer
    );

#endif

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
DWORD
WINAPI
GetPerAdapterInfo(
    __in                            ULONG                IfIndex, 
    __out_bcount_opt(*pOutBufLen)   PIP_PER_ADAPTER_INFO pPerAdapterInfo, 
    __inout                         PULONG               pOutBufLen
    );
#endif

DWORD
WINAPI
IpReleaseAddress(
    __in PIP_ADAPTER_INDEX_MAP  AdapterInfo
    );


DWORD
WINAPI
IpRenewAddress(
    __in PIP_ADAPTER_INDEX_MAP  AdapterInfo
    );

DWORD
WINAPI
SendARP(
    __in IPAddr DestIP,
    __in IPAddr SrcIP,
    __out_bcount(*PhyAddrLen) PVOID pMacAddr,
    __inout PULONG  PhyAddrLen
    );

BOOL
WINAPI
GetRTTAndHopCount(
    __in  IPAddr DestIpAddress,
    __out PULONG HopCount,
    __in  ULONG  MaxHops,
    __out PULONG RTT
    );

DWORD
WINAPI
GetFriendlyIfIndex(
    __in DWORD IfIndex
    );

DWORD
WINAPI
EnableRouter(
    __out HANDLE* pHandle,
    __out OVERLAPPED* pOverlapped
    );

DWORD
WINAPI
UnenableRouter(
    __in      OVERLAPPED* pOverlapped,
    __out_opt LPDWORD lpdwEnableCount
    );
DWORD
WINAPI
DisableMediaSense(
    __out HANDLE *pHandle,
    __in  OVERLAPPED *pOverLapped
    );

DWORD
WINAPI
RestoreMediaSense(
    __in      OVERLAPPED* pOverlapped,
    __out_opt LPDWORD lpdwEnableCount
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)

DWORD
WINAPI
GetIpErrorString(
    __in    IP_STATUS ErrorCode,
    __out_ecount_opt(*Size + 1) PWSTR Buffer,
    __inout PDWORD Size
    );

#if (NTDDI_VERSION >= NTDDI_VISTA)
#ifdef _WS2DEF_
ULONG
WINAPI
ResolveNeighbor(
    __in    SOCKADDR *NetworkAddress,
    __out_bcount(*PhysicalAddressLength) PVOID PhysicalAddress,
    __inout PULONG PhysicalAddressLength
    );
#endif
#endif  
//
// Port reservation API routines.
//

ULONG
WINAPI
CreatePersistentTcpPortReservation(
    __in  USHORT StartPort,
    __in  USHORT NumberOfPorts,
    __out PULONG64 Token
    );

ULONG
WINAPI
CreatePersistentUdpPortReservation(
    __in  USHORT StartPort,
    __in  USHORT NumberOfPorts,
    __out PULONG64 Token
    );

ULONG
WINAPI
DeletePersistentTcpPortReservation(
    __in USHORT StartPort,
    __in USHORT NumberOfPorts
    );

ULONG
WINAPI
DeletePersistentUdpPortReservation(
    __in USHORT StartPort,
    __in USHORT NumberOfPorts
    );

ULONG
WINAPI
LookupPersistentTcpPortReservation(
    __in  USHORT StartPort,
    __in  USHORT NumberOfPorts,
    __out PULONG64 Token
    );

ULONG
WINAPI
LookupPersistentUdpPortReservation(
    __in  USHORT StartPort,
    __in  USHORT NumberOfPorts,
    __out PULONG64 Token
    );


//
// Network String parsing API
//

#define NET_STRING_IPV4_ADDRESS           0x00000001
   // The string identifies an IPv4 Host/router using literal address.
   // (port or prefix not allowed) 
#define NET_STRING_IPV4_SERVICE           0x00000002
   // The string identifies an IPv4 service using literal address.
   // (port required; prefix not allowed) 
#define NET_STRING_IPV4_NETWORK           0x00000004
   // The string identifies an IPv4 network.
   // (prefix required; port not allowed) 
#define NET_STRING_IPV6_ADDRESS           0x00000008
   // The string identifies an IPv6 Host/router using literal address.
   // (port or prefix not allowed; scope-id allowed) 
#define NET_STRING_IPV6_ADDRESS_NO_SCOPE  0x00000010
   // The string identifies an IPv6 Host/router using literal address
   // where the interface context is already known.
   // (port or prefix not allowed; scope-id not allowed) 
#define NET_STRING_IPV6_SERVICE           0x00000020
   // The string identifies an IPv6 service using literal address.
   // (port required; prefix not allowed; scope-id allowed) 
#define NET_STRING_IPV6_SERVICE_NO_SCOPE  0x00000040
   // The string identifies an IPv6 service using literal address
   // where the interface context is already known.
   // (port required; prefix not allowed; scope-id not allowed) 
#define NET_STRING_IPV6_NETWORK           0x00000080
   // The string identifies an IPv6 network.
   // (prefix required; port or scope-id not allowed) 
#define NET_STRING_NAMED_ADDRESS          0x00000100
   // The string identifies an Internet Host using DNS.
   // (port or prefix or scope-id not allowed) 
#define NET_STRING_NAMED_SERVICE          0x00000200
   // The string identifies an Internet service using DNS.
   // (port required; prefix or scope-id not allowed)

#define NET_STRING_IP_ADDRESS             (NET_STRING_IPV4_ADDRESS   | \
                                           NET_STRING_IPV6_ADDRESS)

#define NET_STRING_IP_ADDRESS_NO_SCOPE    (NET_STRING_IPV4_ADDRESS   | \
                                           NET_STRING_IPV6_ADDRESS_NO_SCOPE)

#define NET_STRING_IP_SERVICE             (NET_STRING_IPV4_SERVICE   | \
                                           NET_STRING_IPV6_SERVICE)

#define NET_STRING_IP_SERVICE_NO_SCOPE    (NET_STRING_IPV4_SERVICE   | \
                                           NET_STRING_IPV6_SERVICE_NO_SCOPE)

#define NET_STRING_IP_NETWORK             (NET_STRING_IPV4_NETWORK   | \
                                           NET_STRING_IPV6_NETWORK)

#define NET_STRING_ANY_ADDRESS            (NET_STRING_NAMED_ADDRESS  | \
                                           NET_STRING_IP_ADDRESS)

#define NET_STRING_ANY_ADDRESS_NO_SCOPE   (NET_STRING_NAMED_ADDRESS  | \
                                           NET_STRING_IP_ADDRESS_NO_SCOPE)

#define NET_STRING_ANY_SERVICE            (NET_STRING_NAMED_SERVICE  | \
                                           NET_STRING_IP_SERVICE)

#define NET_STRING_ANY_SERVICE_NO_SCOPE   (NET_STRING_NAMED_SERVICE  | \
                                           NET_STRING_IP_SERVICE_NO_SCOPE)

typedef enum NET_ADDRESS_FORMAT_
{
   NET_ADDRESS_FORMAT_UNSPECIFIED = 0,

   NET_ADDRESS_DNS_NAME,
   NET_ADDRESS_IPV4,
   NET_ADDRESS_IPV6

} NET_ADDRESS_FORMAT;

#if defined (_WS2DEF_) && defined (_WS2IPDEF_) && defined(_WINDNS_INCLUDED_)
	// app must include winsock2.h, ws2ipdef.h, and windns.h to use this API

typedef struct NET_ADDRESS_INFO_
{
   NET_ADDRESS_FORMAT Format;

   union
   {
      struct {
         WCHAR Address[DNS_MAX_NAME_BUFFER_LENGTH];   
         WCHAR Port[6];
      } NamedAddress;

      SOCKADDR_IN Ipv4Address;
      SOCKADDR_IN6 Ipv6Address;
      SOCKADDR IpAddress;
   };

} NET_ADDRESS_INFO, *PNET_ADDRESS_INFO;

DWORD
WINAPI
ParseNetworkString(
   __in      CONST WCHAR* NetworkString,
   __in      DWORD Types,
   __out_opt PNET_ADDRESS_INFO AddressInfo,
   __out_opt USHORT* PortNumber,
   __out_opt BYTE* PrefixLength
   );

#endif


#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_VISTA)

#include <netioapi.h>

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#ifdef __cplusplus
}
#endif

#endif //__IPHLPAPI_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IntShCut.h ===
/*
 * intshcut.h - Internet Shortcut interface definitions.
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */


#ifndef __INTSHCUT_H__
#define __INTSHCUT_H__

/* Headers
 **********/

#include <isguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* Define API decoration for direct import of DLL functions. */

#ifdef _INTSHCUT_
#define INTSHCUTAPI
#else
#define INTSHCUTAPI                 DECLSPEC_IMPORT
#endif

/* HRESULTs */

//
// MessageId: E_FLAGS
//
// MessageText:
//
//  The flag combination is invalid.
//
#define E_FLAGS                     MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1000)

//
// MessageId: IS_E_EXEC_FAILED
//
// MessageText:
//
//  The URL's protocol handler failed to run.
//
#define IS_E_EXEC_FAILED            MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x2002)

//
// MessageId: URL_E_INVALID_SYNTAX
//
// MessageText:
//
//  The URL's syntax is invalid.
//
#define URL_E_INVALID_SYNTAX        MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1001)

//
// MessageId: URL_E_UNREGISTERED_PROTOCOL
//
// MessageText:
//
//  The URL's protocol does not have a registered protocol handler.
//
#define URL_E_UNREGISTERED_PROTOCOL MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x1002)


/* Interfaces
 *************/

//
// Input flags for IUniformResourceLocator::SetURL().
//
typedef enum iurl_seturl_flags
{
   IURL_SETURL_FL_GUESS_PROTOCOL        = 0x0001,     // Guess protocol if missing
   IURL_SETURL_FL_USE_DEFAULT_PROTOCOL  = 0x0002,     // Use default protocol if missing
}
IURL_SETURL_FLAGS;


//
// Input flags for IUniformResourceLocator()::InvokeCommand().
//
typedef enum iurl_invokecommand_flags
{
   IURL_INVOKECOMMAND_FL_ALLOW_UI                  = 0x0001,
   IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB          = 0x0002,    // Ignore pcszVerb
   IURL_INVOKECOMMAND_FL_DDEWAIT                   = 0x0004,    // pass DDEWAIT to ShellExec
   IURL_INVOKECOMMAND_FL_ASYNCOK                   = 0x0008,    // pass SEE_MASK_ASYNCOK to ShellExec
}
IURL_INVOKECOMMAND_FLAGS;


//
// Command info for IUniformResourceLocator::InvokeCommand().
//

typedef struct urlinvokecommandinfoA
{
   DWORD  dwcbSize;          // Size of structure
   DWORD  dwFlags;           // Bit field of IURL_INVOKECOMMAND_FLAGS
   HWND   hwndParent;        // Parent window.  Valid only if IURL_INVOKECOMMAND_FL_ALLOW_UI is set.
   LPCSTR pcszVerb;          // Verb to invoke.  Ignored if IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB is set.
}
URLINVOKECOMMANDINFOA;
typedef URLINVOKECOMMANDINFOA *PURLINVOKECOMMANDINFOA;
typedef const URLINVOKECOMMANDINFOA CURLINVOKECOMMANDINFOA;
typedef const URLINVOKECOMMANDINFOA *PCURLINVOKECOMMANDINFOA;

typedef struct urlinvokecommandinfoW
{
   DWORD   dwcbSize;          // Size of structure
   DWORD   dwFlags;           // Bit field of IURL_INVOKECOMMAND_FLAGS
   HWND    hwndParent;        // Parent window.  Valid only if IURL_INVOKECOMMAND_FL_ALLOW_UI is set.
   LPCWSTR pcszVerb;          // Verb to invoke.  Ignored if IURL_INVOKECOMMAND_FL_USE_DEFAULT_VERB is set.
}
URLINVOKECOMMANDINFOW;
typedef URLINVOKECOMMANDINFOW *PURLINVOKECOMMANDINFOW;
typedef const URLINVOKECOMMANDINFOW CURLINVOKECOMMANDINFOW;
typedef const URLINVOKECOMMANDINFOW *PCURLINVOKECOMMANDINFOW;

#ifdef UNICODE
#define URLINVOKECOMMANDINFO            URLINVOKECOMMANDINFOW
#define PURLINVOKECOMMANDINFO           PURLINVOKECOMMANDINFOW
#define CURLINVOKECOMMANDINFO           CURLINVOKECOMMANDINFOW
#define PCURLINVOKECOMMANDINFO          PCURLINVOKECOMMANDINFOW
#else
#define URLINVOKECOMMANDINFO            URLINVOKECOMMANDINFOA
#define PURLINVOKECOMMANDINFO           PURLINVOKECOMMANDINFOA
#define CURLINVOKECOMMANDINFO           CURLINVOKECOMMANDINFOA
#define PCURLINVOKECOMMANDINFO          PCURLINVOKECOMMANDINFOA
#endif


//===========================================================================
//
// IUniformResourceLocator interface
//
// [OverView]
//
//  Provides access to Internet Shortcuts.
//
// [Member functions]
//
// IUniformResourceLocator::SetURL
//
//   This member function sets an object's URL.
//
//   The dwInFlags parameter specifies the behavior:
//
//  IURL_SETURL_FL_GUESS_PROTOCOL: The protocol scheme is guessed and added
//   to the URL, if it is not specified in pcszURL.
//
//  IURL_SETURL_FL_USE_DEFAULT_PROTOCOL: The default protocol scheme is added
//   to the URL, if it is not specified in pcszURL.
//
//   The function returns S_OK if the object's URL is set successfully.
//  Otherwise, an error code is returned:
//
//  E_OUTOFMEMORY:  There is not enough memory to complete the operation.
//
//  IS_E_EXEC_FAILED:  The URL's protocol handler failed to run.
//
//  URL_E_INVALID_SYNTAX:  The URL's syntax is invalid.
//
//  URL_E_UNREGISTERED_PROTOCOL:  The URL's protocol does not have a
//   registered protocol handler.
//
//
// IUniformResourceLocator::GetURL
//
//   This member function retrieves an object's URL.  The ppszURL is a
//  pointer to a PSTR to be filled in which a pointer to the object's
//  URL.  When finished, this string should be freed using IMalloc::Free().
//
//   The function returns S_OK if the object's URL was retrieved
//  successfully.  If the object does not have a URL associated with it,
//  then S_FALSE is returned and *ppszURL is set to NULL.  Otherwise, an
//  error code is returned:
//
//  E_OUTOFMEMORY:  There is not enough memory to complete the operation.
//
//  IS_E_EXEC_FAILED:  The URL's protocol handler failed to run.
//
//  URL_E_INVALID_SYNTAX:  The URL's syntax is invalid.
//
//  URL_E_UNREGISTERED_PROTOCOL:  The URL's protocol does not have a
//   registered protocol handler.
//
//
// IUniformResourceLocator::InvokeCommand
//
//   This member function invokes a command on an object's URL.  The purlici
//  parameter is a pointer to a URLINVOKECOMMANDINFO structure which
//  describes the command to be invoked.
//
//   The function returns S_OK if the object's URL was opened successfully.
//  If the object does not have a URL associated with it, the function
//  returns S_FALSE.  Otherwise, an error code is returned:
//
//  E_OUTOFMEMORY:  There is not enough memory to complete the operation.
//
//  IS_E_EXEC_FAILED:  The URL's protocol handler failed to run.
//
//  URL_E_INVALID_SYNTAX:  The URL's syntax is invalid.
//
//  URL_E_UNREGISTERED_PROTOCOL:  The URL's protocol does not have a
//   registered protocol handler.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE IUniformResourceLocatorA

DECLARE_INTERFACE_IID_(IUniformResourceLocatorA, IUnknown, "fbf23b80-e3f0-101b-8488-00aa003e56f8")
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;
   STDMETHOD_(ULONG, AddRef)(THIS) PURE;
   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IUniformResourceLocator methods */

   STDMETHOD(SetURL)(THIS_
                     LPCSTR pcszURL,
                     DWORD dwInFlags) PURE;

   STDMETHOD(GetURL)(THIS_
                     __deref_out LPSTR *ppszURL) PURE;

   STDMETHOD(InvokeCommand)(THIS_
                            PURLINVOKECOMMANDINFOA purlici) PURE;
};

#undef  INTERFACE
#define INTERFACE IUniformResourceLocatorW

DECLARE_INTERFACE_IID_(IUniformResourceLocatorW, IUnknown, "cabb0da0-da57-11cf-9974-0020afd79762")
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;
   STDMETHOD_(ULONG, AddRef)(THIS) PURE;
   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IUniformResourceLocator methods */

   STDMETHOD(SetURL)(THIS_
                     LPCWSTR pcszURL,
                     DWORD dwInFlags) PURE;

   STDMETHOD(GetURL)(THIS_
                     __deref_out LPWSTR *ppszURL) PURE;

   STDMETHOD(InvokeCommand)(THIS_
                            PURLINVOKECOMMANDINFOW purlici) PURE;
};

#ifdef UNICODE
#define IUniformResourceLocator         IUniformResourceLocatorW
#define IUniformResourceLocatorVtbl     IUniformResourceLocatorWVtbl
#else
#define IUniformResourceLocator         IUniformResourceLocatorA
#define IUniformResourceLocatorVtbl     IUniformResourceLocatorAVtbl
#endif

typedef IUniformResourceLocator *PIUniformResourceLocator;
typedef const IUniformResourceLocator CIUniformResourceLocator;
typedef const IUniformResourceLocator *PCIUniformResourceLocator;


/* Prototypes
 *************/

//
// Input flags for TranslateURL().
//
typedef enum translateurl_in_flags
{
   TRANSLATEURL_FL_GUESS_PROTOCOL         = 0x0001,     // Guess protocol if missing
   TRANSLATEURL_FL_USE_DEFAULT_PROTOCOL   = 0x0002,     // Use default protocol if missing
}
TRANSLATEURL_IN_FLAGS;


//
//   TranslateURL().  This function applies common translations to a URL
//  string, creating a new URL string.
//
//   This function does not perform any validation on the syntax of the input
//  URL string.  A successful return value does not indicate that the input
//  or output URL strings are valid URLS.
//
//   The function returns S_OK if the URL string is translated successfully
//  and *ppszTranslatedURL points to the translated URL string.  S_FALSE
//  is returned if the URL string did not require translation.  An error
//  code is returned if an error occurs.
//
//  Parameters:
//   pcszURL -- A pointer to the URL string to be translated.
//   dwInFlags -- A bit field of TRANSLATEURL_IN_FLAGS.
//   ppszTranslatedURL -- A pointer to the newly created, translated URL
//     string, if any.  *ppszTranslatedURL is only valid if S_OK is returned.
//     If valid, *ppszTranslatedURL should be freed by calling LocalFree().
//     *ppszTranslatedURL is NULL on error.
//

INTSHCUTAPI HRESULT WINAPI TranslateURLA(PCSTR pcszURL,
                                         DWORD dwInFlags,
                                         __out PSTR *ppszTranslatedURL);
INTSHCUTAPI HRESULT WINAPI TranslateURLW(PCWSTR pcszURL,
                                         DWORD dwInFlags,
                                         __out PWSTR UNALIGNED *ppszTranslatedURL);
#ifdef UNICODE
#define TranslateURL             TranslateURLW
#else
#define TranslateURL             TranslateURLA
#endif   /* UNICODE */


//
// Input flags for URLAssociationDialog().
//
typedef enum urlassociationdialog_in_flags
{
   URLASSOCDLG_FL_USE_DEFAULT_NAME        = 0x0001,
   URLASSOCDLG_FL_REGISTER_ASSOC          = 0x0002
}
URLASSOCIATIONDIALOG_IN_FLAGS;


//
//   URLAssociationDialog().  This function invokes the unregistered URL
//  protocol dialog box, providing a standard ui for choosing the handler for
//  an unregistered URL protocol.
//
//  The functions returns S_OK if the application is registered with the
//  URL protocol.  S_FALSE is returned if nothing is registered (a one-time
//  execution via the selected application is requested).
//
//  Parameters:
//   hwndParent -- A handle to the window to be used as the parent
//   dwInFlags -- A bit field of URLASSOCIATIONDIALOG_IN_FLAGS.  The
//                flags are:
//
//                  URLASSOCDLG_FL_USE_DEFAULT_NAME: Use the default Internet
//                   Shortcut file name.  Ignore pcszFile.
//
//                  URLASSOCDLG_FL_REGISTER_ASSOC: The application
//                   selected is to be registered as the handler for URLs
//                   of pcszURL's protocol.  An application is only
//                   registered if this flag is set, and the user indicates
//                   that a persistent association is to be made.
//
//   pcszFile -- The name of the Internet Shortcut file whose URL's protocol
//               requires a protocol handler.  Before a verb, like "open", can
//               be invoked on an Internet Shortcut, a protocol handler must be
//               registered for its URL protocol.  If
//               URLASSOCDLG_FL_USE_DEFAULT_NAME is set in dwInFlags, pcszFile
//               is ignored, and a default Internet Shortcut file name is used.
//               pcszFile is only used for ui.
//   pcszURL -- The URL whose unregistered protocol requires a handler.
//   pszAppBuf -- A buffer to be filled in on success with the path
//                of the application selected by the user.  pszAppBuf's
//                buffer is filled in with the empty string on failure.
//   ucAppBufLen -- The length of pszAppBuf's buffer in characters.
//

INTSHCUTAPI HRESULT WINAPI URLAssociationDialogA(HWND hwndParent,
                                                 DWORD dwInFlags,
                                                 PCSTR pcszFile,
                                                 PCSTR pcszURL,
                                                 __out_ecount(ucAppBufLen) PSTR pszAppBuf,
                                                 UINT ucAppBufLen);
INTSHCUTAPI HRESULT WINAPI URLAssociationDialogW(HWND hwndParent,
                                                 DWORD dwInFlags,
                                                 PCWSTR pcszFile,
                                                 PCWSTR pcszURL,
                                                 __out_ecount(ucAppBufLen) PWSTR pszAppBuf,
                                                 UINT ucAppBufLen);
#ifdef UNICODE
#define URLAssociationDialog     URLAssociationDialogW
#else
#define URLAssociationDialog     URLAssociationDialogA
#endif  /* UNICODE */


//
// Input flags for MIMEAssociationDialog().
//
typedef enum mimeassociationdialog_in_flags
{
   MIMEASSOCDLG_FL_REGISTER_ASSOC         = 0x0001
}
MIMEASSOCIATIONDIALOG_IN_FLAGS;


//
//   MIMEAssociationDialog().  Invokes the unregistered MIME content
//  type dialog box.
//
//   This function does not perform any validation on the syntax of the
//  input content type string.  A successful return value does not indicate
//  that the input MIME content type string is a valid content type.
//
//   The function returns S_OK if the MIME content type is associated
//  with the extension.  The extension is associated as the default
//  extension for the content type.  S_FALSE is returned if nothing is
//  registered.  Otherwise, the function returns one of the following
//  errors:
//
//  E_ABORT -- The user cancelled the operation.
//  E_FLAGS -- The flag combination passed in dwFlags is invalid.
//  E_OUTOFMEMORY -- Not enough memory to complete the operation.
//  E_POINTER -- One of the input pointers is invalid.
//
//  Parameters:
//   hwndParent -- A handle to the window to be used as the parent
//                 window of any posted child windows.
//   dwInFlags -- A bit field of MIMEASSOCIATIONDIALOG_IN_FLAGS.  The
//                flags are:
//
//              MIMEASSOCDLG_FL_REGISTER_ASSOC: If set, the application
//               selected is to be registered as the handler for files of
//               the given MIME type.  If clear, no association is to be
//               registered.  An application is only registered if this
//               flag is set, and the user indicates that a persistent
//               association is to be made.  Registration is only possible
//               if pcszFile contains an extension.
//
//   pcszFile -- A pointer to a string indicating the name of the file
//               containing data of pcszMIMEContentType's content type.
//   pcszMIMEContentType -- A pointer to a string indicating the content
//                          type for which an application is sought.
//   pszAppBuf -- A buffer to be filled in on success with the path of
//                the application selected by the user.  pszAppBuf's buffer
//                is filled in with the empty string on failure.
//   ucAppBufLen -- The length of pszAppBuf's buffer in characters.
//

INTSHCUTAPI HRESULT WINAPI MIMEAssociationDialogA(HWND hwndParent,
                                                  DWORD dwInFlags,
                                                  PCSTR pcszFile,
                                                  PCSTR pcszMIMEContentType,
                                                  __out_ecount(ucAppBufLen) PSTR pszAppBuf,
                                                  UINT ucAppBufLen);
INTSHCUTAPI HRESULT WINAPI MIMEAssociationDialogW(HWND hwndParent,
                                                  DWORD dwInFlags,
                                                  PCWSTR pcszFile,
                                                  PCWSTR pcszMIMEContentType,
                                                  __out_ecount(ucAppBufLen) PWSTR pszAppBuf,
                                                  UINT ucAppBufLen);
#ifdef UNICODE
#define MIMEAssociationDialog    MIMEAssociationDialogW
#else
#define MIMEAssociationDialog    MIMEAssociationDialogA
#endif  /* UNICODE */


//
//   InetIsOffline().  This function determines if the user wants to be
//  "offline" (get all information from the cache).  The dwFlags must be
//  0.
//
//   The function returns TRUE to indicate that the local system is not
//  currently connected to the Internet.  The function returns FALSE to
//  indicate that either the local system is connected to the Internet,
//  or no attempt has yet been made to connect the local system to the
//  Internet.  Applications that wish to support an off-line mode should
//  do so if InetIsOffline() returns TRUE.
//
//   Off-line mode begins when the user has been prompted to dial-in to
//  an Internet providor, but canceled the attempt.
//
INTSHCUTAPI
BOOL
WINAPI
InetIsOffline(
    DWORD dwFlags);


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __INTSHCUT_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ioevent.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ioevent.h

Abstract:

    This module contains the GUIDS and event structures for io system
    initiated events.  These events are reported in kernel mode and are
    available to both user mode and kernel mode clients.


--*/

//
//  Label change event.  This event is signalled upon successful completion
//  of a label change.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_CHANGE, 0x7373654aL, 0x812a, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f );

//
//  Volume dismount event.  This event is signalled when an attempt is made to
//  dismount a volume.  There is no additional data.  Note that this will not
//  necessarily be preceded by a GUID_IO_VOLUME_LOCK notification.
//

DEFINE_GUID( GUID_IO_VOLUME_DISMOUNT, 0xd16a55e8L, 0x1059, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume dismount failed event.  This event is signalled when a volume dismount fails.
//  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_DISMOUNT_FAILED, 0xe3c5b178L, 0x105d, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume mount event.  This event is signalled when a volume mount occurs.
//  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_MOUNT, 0xb5804878L, 0x1a96, 0x11d2, 0x8f, 0xfd, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

typedef struct _DEVICE_EVENT_MOUNT {
    ULONG Version;
    ULONG Flags;
    ULONG FileSystemNameLength;
    ULONG FileSystemNameOffset;
} DEVICE_EVENT_MOUNT, *PDEVICE_EVENT_MOUNT;

//
//  Volume lock event.  This event is signalled when an attempt is made to
//  lock a volume.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_LOCK, 0x50708874L, 0xc9af, 0x11d1, 0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );

//
//  Volume lock failed event.  This event is signalled when an attempt is made to
//  lock a volume, but it fails.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_LOCK_FAILED, 0xae2eed10L, 0x0ba8, 0x11d2, 0x8f, 0xfb, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );


//
//  Volume unlock event.  This event is signalled when an attempt is made to
//  unlock a volume.  There is no additional data.
//

DEFINE_GUID( GUID_IO_VOLUME_UNLOCK, 0x9a8c3d68L, 0xd0cb, 0x11d1, 0x8f, 0xef, 0x00, 0xa0, 0xc9, 0xa0, 0x6d, 0x32 );


//
//  Volume name change.  This event is signalled when the list of persistent
//  names (like drive letters) for a volume changes.  There is no additional
//  data.
//

DEFINE_GUID( GUID_IO_VOLUME_NAME_CHANGE, 0x2de97f83, 0x4c06, 0x11d2, 0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a);


//
//      Volume needs chkdsk event. Sent when a file system detects corruption.
//

DEFINE_GUID( GUID_IO_VOLUME_NEED_CHKDSK, 0x799a0960, 0x0a0b, 0x4e03, 0xad, 0x88, 0x2f, 0xa7, 0xc6, 0xce, 0x74, 0x8a);


//
//  WORK near full event. Send when a wolume with write-once-read-many characteristics
//  (e.g. CD-R) is becoming full (on these media modifying existing file data
//  consumes space) so that the user can be notified.
//

DEFINE_GUID( GUID_IO_VOLUME_WORM_NEAR_FULL, 0xf3bfff82, 0xf3de, 0x48d2, 0xaf, 0x95, 0x45, 0x7f, 0x80, 0xb7, 0x63, 0xf2);


//
//  Media wearing out. Sent when a file sytem determines that the error rate
//  on a volume is too high, or sparing (defect replacement) space is almost
//  exhausted.
//

DEFINE_GUID( GUID_IO_VOLUME_WEARING_OUT, 0x873113ca, 0x1486, 0x4508, 0x82, 0xac, 0xc3, 0xb2, 0xe5, 0x29, 0x7a, 0xaa);


//
//  Volume force closed event. Sent when a volume has been finalised and made
//  read-only by the filesystem due to (e,g.) WORM type volume full, or sparing
//  (defect replacement) space has been exhausted.
//

DEFINE_GUID( GUID_IO_VOLUME_FORCE_CLOSED, 0x411ad84f, 0x433e, 0x4dc2, 0xa5, 0xae, 0x4a, 0x2d, 0x1a, 0x2d, 0xe6, 0x54);


//
//  Notify make compatible function available. Sent after the user removes a disc
//  which may not be readable in all drives in it's current state (e.g. CD-R with
//  open session).
//

DEFINE_GUID( GUID_IO_VOLUME_INFO_MAKE_COMPAT, 0x3ab9a0d2, 0xef80, 0x45cf, 0x8c, 0xdc, 0xcb, 0xe0, 0x2a, 0x21, 0x29, 0x06);


//
//  Notify that the drive is preparing the disc for eject (e.g. stopping a background format).
//

DEFINE_GUID( GUID_IO_VOLUME_PREPARING_EJECT, 0xc79eb16e, 0x0dac, 0x4e7a, 0xa8, 0x6c, 0xb2, 0x5c, 0xee, 0xaa, 0x88, 0xf6);


//
//  Notify that a background format has been initiated on the disc.
//

DEFINE_GUID( GUID_IO_VOLUME_BACKGROUND_FORMAT, 0xa2e5fc86, 0xd5cd, 0x4038, 0xb2, 0xe3, 0x44, 0x45, 0x6, 0x5c, 0x23, 0x77);

//
//  Volume physical configuration change.  This event is signalled when the
//  physical makeup or current physical state of the volume changes.
//

DEFINE_GUID( GUID_IO_VOLUME_PHYSICAL_CONFIGURATION_CHANGE, 0x2de97f84, 0x4c06, 0x11d2, 0xa5, 0x32, 0x0, 0x60, 0x97, 0x13, 0x5, 0x5a);

//
//  Volume unique ID change.  This event is signalled when the
//  unique ID of the volume changes.
//

DEFINE_GUID( GUID_IO_VOLUME_UNIQUE_ID_CHANGE, 0xaf39da42, 0x6622, 0x41f5, 0x97, 0xb, 0x13, 0x9d, 0x9, 0x2f, 0xa3, 0xd9);

//
//  Volume BitLocker Drive Encryption status change.
//  This event is signalled when BDE is enabled / disabled, or when encryption
//  begins, ends, pauses or resumes.
//

DEFINE_GUID( GUID_IO_VOLUME_FVE_STATUS_CHANGE, 0x062998b2, 0xee1f, 0x4b6a, 0xb8, 0x57, 0xe7, 0x6c, 0xbb, 0xe9, 0xa6, 0xda);


//
//  Volume device interface.  This is a device interface GUID that appears
//  when the device object associated with a volume is created and disappears
//  when the device object associated with the volume is destroyed.
//

DEFINE_GUID( GUID_IO_VOLUME_DEVICE_INTERFACE, 0x53f5630d, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

//
// The size of the filesystem on the volume has changed.
//

DEFINE_GUID( GUID_IO_VOLUME_CHANGE_SIZE, 0x3a1625be, 0xad03, 0x49f1, 0x8e, 0xf8, 0x6b, 0xba, 0xc1, 0x82, 0xd1, 0xfd);

//
//  Sent when the removable media is changed (added, removed) from a device
//  (such as a CDROM, tape, changer, etc).
//
//  The additional data is a DWORD representing the data event.
//

DEFINE_GUID( GUID_IO_MEDIA_ARRIVAL,         0xd07433c0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);
DEFINE_GUID( GUID_IO_MEDIA_REMOVAL,         0xd07433c1, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

//
// Sent when the CDROM device locked/unlocked for exclusive access
//

DEFINE_GUID(GUID_IO_CDROM_EXCLUSIVE_LOCK,   0xbc56c139, 0x7a10, 0x47ee, 0xa2, 0x94, 0x4c, 0x6a, 0x38, 0xf0, 0x14, 0x9a);
DEFINE_GUID(GUID_IO_CDROM_EXCLUSIVE_UNLOCK, 0xa3b6d27d, 0x5e35, 0x4885, 0x81, 0xe5, 0xee, 0x18, 0xc0, 0xe, 0xd7, 0x79);

//
// Sent when the media is returning that it is not ready right now, but will
// be ready soon. This can be because the drive has spun down to save power
// or because new media has been inserted but is not ready for access yet.
//

DEFINE_GUID( GUID_IO_DEVICE_BECOMING_READY, 0xd07433f0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_BECOMING_READY {
    ULONG Version;
    ULONG Reason;
    ULONG Estimated100msToReady;
} DEVICE_EVENT_BECOMING_READY, *PDEVICE_EVENT_BECOMING_READY;

//
// Sent when the user presses the eject button on the front of the drive,
// or when other buttons on the front are pressed via GESN command polling
// (GESN support to be added)
//

DEFINE_GUID( GUID_IO_DEVICE_EXTERNAL_REQUEST, 0xd07433d0, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);
DEFINE_GUID( GUID_IO_MEDIA_EJECT_REQUEST,     0xd07433d1, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_EXTERNAL_REQUEST {
    ULONG  Version;
    ULONG  DeviceClass;       // 0 == MMC Storage Devices
    USHORT ButtonStatus;      // 1 == down, 2 == up
    USHORT Request;
    LARGE_INTEGER SystemTime; // for time-related info
} DEVICE_EVENT_EXTERNAL_REQUEST, *PDEVICE_EVENT_EXTERNAL_REQUEST;

//
// Sent when a tape drive requires cleaning
//
DEFINE_GUID(GUID_IO_DRIVE_REQUIRES_CLEANING, 0x7207877c, 0x90ed, 0x44e5, 0xa0, 0x0, 0x81, 0x42, 0x8d, 0x4c, 0x79, 0xbb);

//
// Sent when a tape is erased
//
DEFINE_GUID(GUID_IO_TAPE_ERASE, 0x852d11eb, 0x4bb8, 0x4507, 0x9d, 0x9b, 0x41, 0x7c, 0xc2, 0xb1, 0xb4, 0x38);

typedef struct _DEVICE_EVENT_GENERIC_DATA {
    ULONG EventNumber;
} DEVICE_EVENT_GENERIC_DATA, *PDEVICE_EVENT_GENERIC_DATA;


//
//  Represents any asynchronous notification coming from a device driver whose
//  notification protocol is RBC
//  Additional data is provided

DEFINE_GUID( GUID_DEVICE_EVENT_RBC, 0xd0744792, 0xa98e, 0x11d2, 0x91, 0x7a, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

typedef struct _DEVICE_EVENT_RBC_DATA {
    ULONG EventNumber;
    UCHAR SenseQualifier;
    UCHAR SenseCode;
    UCHAR SenseKey;
    UCHAR Reserved;
    ULONG Information;
} DEVICE_EVENT_RBC_DATA, *PDEVICE_EVENT_RBC_DATA;

//
//  A clone of this disk has just arrived in the system.
//

DEFINE_GUID( GUID_IO_DISK_CLONE_ARRIVAL, 0x6a61885b, 0x7c39, 0x43dd, 0x9b, 0x56, 0xb8, 0xac, 0x22, 0xa5, 0x49, 0xaa);

typedef struct _GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION {
    ULONG DiskNumber;   // The disk number of the new disk arriving in the system.
} GUID_IO_DISK_CLONE_ARRIVAL_INFORMATION, *PGUID_IO_DISK_CLONE_ARRIVAL_INFORMATION;

//
// The disk layout has changed
//

DEFINE_GUID( GUID_IO_DISK_LAYOUT_CHANGE, 0x11dff54c, 0x8469, 0x41f9, 0xb3, 0xde, 0xef, 0x83, 0x64, 0x87, 0xc5, 0x4a);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ipifcons.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ipifcons.h

Abstract:
    Constants needed for the Interface Object

--*/

#ifndef __IPIFCONS_H__
#define __IPIFCONS_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Media types                                                              //
//                                                                          //  
// These are enumerated values of the ifType object defined in MIB-II's     //
// ifTable.  They are registered with IANA which publishes this list        //
// periodically, in either the Assigned Numbers RFC, or some derivative     //
// of it specific to Internet Network Management number assignments.        //
// See ftp://ftp.isi.edu/mib/ianaiftype.mib                                 //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define MIN_IF_TYPE                     1

#define IF_TYPE_OTHER                   1   // None of the below
#define IF_TYPE_REGULAR_1822            2
#define IF_TYPE_HDH_1822                3
#define IF_TYPE_DDN_X25                 4
#define IF_TYPE_RFC877_X25              5
#define IF_TYPE_ETHERNET_CSMACD         6
#define IF_TYPE_IS088023_CSMACD         7
#define IF_TYPE_ISO88024_TOKENBUS       8
#define IF_TYPE_ISO88025_TOKENRING      9
#define IF_TYPE_ISO88026_MAN            10
#define IF_TYPE_STARLAN                 11
#define IF_TYPE_PROTEON_10MBIT          12
#define IF_TYPE_PROTEON_80MBIT          13
#define IF_TYPE_HYPERCHANNEL            14
#define IF_TYPE_FDDI                    15
#define IF_TYPE_LAP_B                   16
#define IF_TYPE_SDLC                    17
#define IF_TYPE_DS1                     18  // DS1-MIB
#define IF_TYPE_E1                      19  // Obsolete; see DS1-MIB
#define IF_TYPE_BASIC_ISDN              20
#define IF_TYPE_PRIMARY_ISDN            21
#define IF_TYPE_PROP_POINT2POINT_SERIAL 22  // proprietary serial
#define IF_TYPE_PPP                     23
#define IF_TYPE_SOFTWARE_LOOPBACK       24
#define IF_TYPE_EON                     25  // CLNP over IP
#define IF_TYPE_ETHERNET_3MBIT          26
#define IF_TYPE_NSIP                    27  // XNS over IP
#define IF_TYPE_SLIP                    28  // Generic Slip
#define IF_TYPE_ULTRA                   29  // ULTRA Technologies
#define IF_TYPE_DS3                     30  // DS3-MIB
#define IF_TYPE_SIP                     31  // SMDS, coffee
#define IF_TYPE_FRAMERELAY              32  // DTE only
#define IF_TYPE_RS232                   33
#define IF_TYPE_PARA                    34  // Parallel port
#define IF_TYPE_ARCNET                  35
#define IF_TYPE_ARCNET_PLUS             36
#define IF_TYPE_ATM                     37  // ATM cells
#define IF_TYPE_MIO_X25                 38
#define IF_TYPE_SONET                   39  // SONET or SDH
#define IF_TYPE_X25_PLE                 40
#define IF_TYPE_ISO88022_LLC            41
#define IF_TYPE_LOCALTALK               42
#define IF_TYPE_SMDS_DXI                43
#define IF_TYPE_FRAMERELAY_SERVICE      44  // FRNETSERV-MIB
#define IF_TYPE_V35                     45
#define IF_TYPE_HSSI                    46
#define IF_TYPE_HIPPI                   47
#define IF_TYPE_MODEM                   48  // Generic Modem
#define IF_TYPE_AAL5                    49  // AAL5 over ATM
#define IF_TYPE_SONET_PATH              50
#define IF_TYPE_SONET_VT                51
#define IF_TYPE_SMDS_ICIP               52  // SMDS InterCarrier Interface
#define IF_TYPE_PROP_VIRTUAL            53  // Proprietary virtual/internal
#define IF_TYPE_PROP_MULTIPLEXOR        54  // Proprietary multiplexing
#define IF_TYPE_IEEE80212               55  // 100BaseVG
#define IF_TYPE_FIBRECHANNEL            56
#define IF_TYPE_HIPPIINTERFACE          57
#define IF_TYPE_FRAMERELAY_INTERCONNECT 58  // Obsolete, use 32 or 44
#define IF_TYPE_AFLANE_8023             59  // ATM Emulated LAN for 802.3
#define IF_TYPE_AFLANE_8025             60  // ATM Emulated LAN for 802.5
#define IF_TYPE_CCTEMUL                 61  // ATM Emulated circuit
#define IF_TYPE_FASTETHER               62  // Fast Ethernet (100BaseT)
#define IF_TYPE_ISDN                    63  // ISDN and X.25
#define IF_TYPE_V11                     64  // CCITT V.11/X.21
#define IF_TYPE_V36                     65  // CCITT V.36
#define IF_TYPE_G703_64K                66  // CCITT G703 at 64Kbps
#define IF_TYPE_G703_2MB                67  // Obsolete; see DS1-MIB
#define IF_TYPE_QLLC                    68  // SNA QLLC
#define IF_TYPE_FASTETHER_FX            69  // Fast Ethernet (100BaseFX)
#define IF_TYPE_CHANNEL                 70
#define IF_TYPE_IEEE80211               71  // Radio spread spectrum
#define IF_TYPE_IBM370PARCHAN           72  // IBM System 360/370 OEMI Channel
#define IF_TYPE_ESCON                   73  // IBM Enterprise Systems Connection
#define IF_TYPE_DLSW                    74  // Data Link Switching
#define IF_TYPE_ISDN_S                  75  // ISDN S/T interface
#define IF_TYPE_ISDN_U                  76  // ISDN U interface
#define IF_TYPE_LAP_D                   77  // Link Access Protocol D
#define IF_TYPE_IPSWITCH                78  // IP Switching Objects
#define IF_TYPE_RSRB                    79  // Remote Source Route Bridging
#define IF_TYPE_ATM_LOGICAL             80  // ATM Logical Port
#define IF_TYPE_DS0                     81  // Digital Signal Level 0
#define IF_TYPE_DS0_BUNDLE              82  // Group of ds0s on the same ds1
#define IF_TYPE_BSC                     83  // Bisynchronous Protocol
#define IF_TYPE_ASYNC                   84  // Asynchronous Protocol
#define IF_TYPE_CNR                     85  // Combat Net Radio
#define IF_TYPE_ISO88025R_DTR           86  // ISO 802.5r DTR
#define IF_TYPE_EPLRS                   87  // Ext Pos Loc Report Sys
#define IF_TYPE_ARAP                    88  // Appletalk Remote Access Protocol
#define IF_TYPE_PROP_CNLS               89  // Proprietary Connectionless Proto
#define IF_TYPE_HOSTPAD                 90  // CCITT-ITU X.29 PAD Protocol
#define IF_TYPE_TERMPAD                 91  // CCITT-ITU X.3 PAD Facility
#define IF_TYPE_FRAMERELAY_MPI          92  // Multiproto Interconnect over FR
#define IF_TYPE_X213                    93  // CCITT-ITU X213
#define IF_TYPE_ADSL                    94  // Asymmetric Digital Subscrbr Loop
#define IF_TYPE_RADSL                   95  // Rate-Adapt Digital Subscrbr Loop
#define IF_TYPE_SDSL                    96  // Symmetric Digital Subscriber Loop
#define IF_TYPE_VDSL                    97  // Very H-Speed Digital Subscrb Loop
#define IF_TYPE_ISO88025_CRFPRINT       98  // ISO 802.5 CRFP
#define IF_TYPE_MYRINET                 99  // Myricom Myrinet
#define IF_TYPE_VOICE_EM                100 // Voice recEive and transMit
#define IF_TYPE_VOICE_FXO               101 // Voice Foreign Exchange Office
#define IF_TYPE_VOICE_FXS               102 // Voice Foreign Exchange Station
#define IF_TYPE_VOICE_ENCAP             103 // Voice encapsulation
#define IF_TYPE_VOICE_OVERIP            104 // Voice over IP encapsulation
#define IF_TYPE_ATM_DXI                 105 // ATM DXI
#define IF_TYPE_ATM_FUNI                106 // ATM FUNI
#define IF_TYPE_ATM_IMA                 107 // ATM IMA
#define IF_TYPE_PPPMULTILINKBUNDLE      108 // PPP Multilink Bundle
#define IF_TYPE_IPOVER_CDLC             109 // IBM ipOverCdlc
#define IF_TYPE_IPOVER_CLAW             110 // IBM Common Link Access to Workstn
#define IF_TYPE_STACKTOSTACK            111 // IBM stackToStack
#define IF_TYPE_VIRTUALIPADDRESS        112 // IBM VIPA
#define IF_TYPE_MPC                     113 // IBM multi-proto channel support
#define IF_TYPE_IPOVER_ATM              114 // IBM ipOverAtm
#define IF_TYPE_ISO88025_FIBER          115 // ISO 802.5j Fiber Token Ring
#define IF_TYPE_TDLC                    116 // IBM twinaxial data link control
#define IF_TYPE_GIGABITETHERNET         117
#define IF_TYPE_HDLC                    118
#define IF_TYPE_LAP_F                   119
#define IF_TYPE_V37                     120
#define IF_TYPE_X25_MLP                 121 // Multi-Link Protocol
#define IF_TYPE_X25_HUNTGROUP           122 // X.25 Hunt Group
#define IF_TYPE_TRANSPHDLC              123
#define IF_TYPE_INTERLEAVE              124 // Interleave channel
#define IF_TYPE_FAST                    125 // Fast channel
#define IF_TYPE_IP                      126 // IP (for APPN HPR in IP networks)
#define IF_TYPE_DOCSCABLE_MACLAYER      127 // CATV Mac Layer
#define IF_TYPE_DOCSCABLE_DOWNSTREAM    128 // CATV Downstream interface
#define IF_TYPE_DOCSCABLE_UPSTREAM      129 // CATV Upstream interface
#define IF_TYPE_A12MPPSWITCH            130 // Avalon Parallel Processor
#define IF_TYPE_TUNNEL                  131 // Encapsulation interface
#define IF_TYPE_COFFEE                  132 // Coffee pot
#define IF_TYPE_CES                     133 // Circuit Emulation Service
#define IF_TYPE_ATM_SUBINTERFACE        134 // ATM Sub Interface
#define IF_TYPE_L2_VLAN                 135 // Layer 2 Virtual LAN using 802.1Q
#define IF_TYPE_L3_IPVLAN               136 // Layer 3 Virtual LAN using IP
#define IF_TYPE_L3_IPXVLAN              137 // Layer 3 Virtual LAN using IPX
#define IF_TYPE_DIGITALPOWERLINE        138 // IP over Power Lines
#define IF_TYPE_MEDIAMAILOVERIP         139 // Multimedia Mail over IP
#define IF_TYPE_DTM                     140 // Dynamic syncronous Transfer Mode
#define IF_TYPE_DCN                     141 // Data Communications Network
#define IF_TYPE_IPFORWARD               142 // IP Forwarding Interface
#define IF_TYPE_MSDSL                   143 // Multi-rate Symmetric DSL
#define IF_TYPE_IEEE1394                144 // IEEE1394 High Perf Serial Bus
#define IF_TYPE_IF_GSN                  145
#define IF_TYPE_DVBRCC_MACLAYER         146
#define IF_TYPE_DVBRCC_DOWNSTREAM       147
#define IF_TYPE_DVBRCC_UPSTREAM         148
#define IF_TYPE_ATM_VIRTUAL             149
#define IF_TYPE_MPLS_TUNNEL             150
#define IF_TYPE_SRP                     151
#define IF_TYPE_VOICEOVERATM            152
#define IF_TYPE_VOICEOVERFRAMERELAY     153
#define IF_TYPE_IDSL                    154
#define IF_TYPE_COMPOSITELINK           155
#define IF_TYPE_SS7_SIGLINK             156
#define IF_TYPE_PROP_WIRELESS_P2P       157
#define IF_TYPE_FR_FORWARD              158
#define IF_TYPE_RFC1483                 159
#define IF_TYPE_USB                     160
#define IF_TYPE_IEEE8023AD_LAG          161
#define IF_TYPE_BGP_POLICY_ACCOUNTING   162
#define IF_TYPE_FRF16_MFR_BUNDLE        163
#define IF_TYPE_H323_GATEKEEPER         164
#define IF_TYPE_H323_PROXY              165
#define IF_TYPE_MPLS                    166
#define IF_TYPE_MF_SIGLINK              167
#define IF_TYPE_HDSL2                   168
#define IF_TYPE_SHDSL                   169
#define IF_TYPE_DS1_FDL                 170
#define IF_TYPE_POS                     171
#define IF_TYPE_DVB_ASI_IN              172
#define IF_TYPE_DVB_ASI_OUT             173
#define IF_TYPE_PLC                     174
#define IF_TYPE_NFAS                    175
#define IF_TYPE_TR008                   176
#define IF_TYPE_GR303_RDT               177
#define IF_TYPE_GR303_IDT               178
#define IF_TYPE_ISUP                    179
#define IF_TYPE_PROP_DOCS_WIRELESS_MACLAYER      180
#define IF_TYPE_PROP_DOCS_WIRELESS_DOWNSTREAM    181
#define IF_TYPE_PROP_DOCS_WIRELESS_UPSTREAM      182
#define IF_TYPE_HIPERLAN2                        183
#define IF_TYPE_PROP_BWA_P2MP                    184
#define IF_TYPE_SONET_OVERHEAD_CHANNEL           185
#define IF_TYPE_DIGITAL_WRAPPER_OVERHEAD_CHANNEL 186
#define IF_TYPE_AAL2                             187
#define IF_TYPE_RADIO_MAC                        188
#define IF_TYPE_ATM_RADIO                        189
#define IF_TYPE_IMT                              190
#define IF_TYPE_MVL                              191
#define IF_TYPE_REACH_DSL                        192
#define IF_TYPE_FR_DLCI_ENDPT                    193
#define IF_TYPE_ATM_VCI_ENDPT                    194
#define IF_TYPE_OPTICAL_CHANNEL                  195
#define IF_TYPE_OPTICAL_TRANSPORT                196
#define IF_TYPE_IEEE80216_WMAN                   237
#define IF_TYPE_WWANPP                  243 // WWAN devices based on GSM technology
#define IF_TYPE_WWANPP2                 244 // WWAN devices based on CDMA technology

#define MAX_IF_TYPE                     244

typedef ULONG IFTYPE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Access types                                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef enum _IF_ACCESS_TYPE {
    IF_ACCESS_LOOPBACK             = 1,
    IF_ACCESS_BROADCAST            = 2,
    IF_ACCESS_POINT_TO_POINT       = 3, // New definition.
    IF_ACCESS_POINTTOPOINT         = 3, // Old definition.
    IF_ACCESS_POINT_TO_MULTI_POINT = 4, // New definition.
    IF_ACCESS_POINTTOMULTIPOINT    = 4, // Old definition.
} IF_ACCESS_TYPE;


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Interface Capabilities (bit flags)                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IF_CHECK_NONE                   0x00
#define IF_CHECK_MCAST                  0x01
#define IF_CHECK_SEND                   0x02


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Connection Types                                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IF_CONNECTION_DEDICATED         1
#define IF_CONNECTION_PASSIVE           2
#define IF_CONNECTION_DEMAND            3


#define IF_ADMIN_STATUS_UP              1
#define IF_ADMIN_STATUS_DOWN            2
#define IF_ADMIN_STATUS_TESTING         3

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following are the the operational states for WAN and LAN interfaces. //
// The order of the states seems weird, but is done for a purpose. All      //
// states >= CONNECTED can transmit data right away. States >= DISCONNECTED //
// can tx data but some set up might be needed. States < DISCONNECTED can   //
// not transmit data.                                                       //
// A card is marked UNREACHABLE if DIM calls InterfaceUnreachable for       //
// reasons other than failure to connect.                                   //
//                                                                          //
// NON_OPERATIONAL -- Valid for LAN Interfaces. Means the card is not       //
//                      working or not plugged in or has no address.        //
// UNREACHABLE     -- Valid for WAN Interfaces. Means the remote site is    //
//                      not reachable at this time.                         //
// DISCONNECTED    -- Valid for WAN Interfaces. Means the remote site is    //
//                      not connected at this time.                         //
// CONNECTING      -- Valid for WAN Interfaces. Means a connection attempt  //
//                      has been initiated to the remote site.              //
// CONNECTED       -- Valid for WAN Interfaces. Means the remote site is    //
//                      connected.                                          //
// OPERATIONAL     -- Valid for LAN Interfaces. Means the card is plugged   //
//                      in and working.                                     //
//                                                                          //
// It is the users duty to convert these values to MIB-II values if they    //
// are to be used by a subagent                                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef enum _INTERNAL_IF_OPER_STATUS {
    IF_OPER_STATUS_NON_OPERATIONAL = 0,
    IF_OPER_STATUS_UNREACHABLE     = 1,
    IF_OPER_STATUS_DISCONNECTED    = 2,
    IF_OPER_STATUS_CONNECTING      = 3,
    IF_OPER_STATUS_CONNECTED       = 4,
    IF_OPER_STATUS_OPERATIONAL     = 5,
} INTERNAL_IF_OPER_STATUS;

#define MIB_IF_TYPE_OTHER               1
#define MIB_IF_TYPE_ETHERNET            6
#define MIB_IF_TYPE_TOKENRING           9
#define MIB_IF_TYPE_FDDI                15
#define MIB_IF_TYPE_PPP                 23
#define MIB_IF_TYPE_LOOPBACK            24
#define MIB_IF_TYPE_SLIP                28

#define MIB_IF_ADMIN_STATUS_UP          1
#define MIB_IF_ADMIN_STATUS_DOWN        2
#define MIB_IF_ADMIN_STATUS_TESTING     3

//
// N.B. The name is a misnomer.  These are NOT the values used by MIB-II.
//
#define MIB_IF_OPER_STATUS_NON_OPERATIONAL      IF_OPER_STATUS_NON_OPERATIONAL
#define MIB_IF_OPER_STATUS_UNREACHABLE          IF_OPER_STATUS_UNREACHABLE
#define MIB_IF_OPER_STATUS_DISCONNECTED         IF_OPER_STATUS_DISCONNECTED
#define MIB_IF_OPER_STATUS_CONNECTING           IF_OPER_STATUS_CONNECTING
#define MIB_IF_OPER_STATUS_CONNECTED            IF_OPER_STATUS_CONNECTED
#define MIB_IF_OPER_STATUS_OPERATIONAL          IF_OPER_STATUS_OPERATIONAL

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_IPIFCONS_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ipsectypes.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for ipsectypes.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __ipsectypes_h__
#define __ipsectypes_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "fwptypes.h"
#include "iketypes.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ipsectypes_0000_0000 */
/* [local] */ 

#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)
#endif
typedef struct FWPM_FILTER0_ FWPM_FILTER0;

typedef struct IPSEC_SA_LIFETIME0_
    {
    UINT32 lifetimeSeconds;
    UINT32 lifetimeKilobytes;
    UINT32 lifetimePackets;
    } 	IPSEC_SA_LIFETIME0;

typedef /* [v1_enum] */ 
enum IPSEC_TRANSFORM_TYPE_
    {	IPSEC_TRANSFORM_AH	= 1,
	IPSEC_TRANSFORM_ESP_AUTH	= ( IPSEC_TRANSFORM_AH + 1 ) ,
	IPSEC_TRANSFORM_ESP_CIPHER	= ( IPSEC_TRANSFORM_ESP_AUTH + 1 ) ,
	IPSEC_TRANSFORM_ESP_AUTH_AND_CIPHER	= ( IPSEC_TRANSFORM_ESP_CIPHER + 1 ) ,
	IPSEC_TRANSFORM_ESP_AUTH_FW	= ( IPSEC_TRANSFORM_ESP_AUTH_AND_CIPHER + 1 ) ,
	IPSEC_TRANSFORM_TYPE_MAX	= ( IPSEC_TRANSFORM_ESP_AUTH_FW + 1 ) 
    } 	IPSEC_TRANSFORM_TYPE;

typedef /* [v1_enum] */ 
enum IPSEC_AUTH_TYPE_
    {	IPSEC_AUTH_MD5	= 0,
	IPSEC_AUTH_SHA_1	= ( IPSEC_AUTH_MD5 + 1 ) ,
	IPSEC_AUTH_SHA_256	= ( IPSEC_AUTH_SHA_1 + 1 ) ,
	IPSEC_AUTH_AES_128	= ( IPSEC_AUTH_SHA_256 + 1 ) ,
	IPSEC_AUTH_AES_192	= ( IPSEC_AUTH_AES_128 + 1 ) ,
	IPSEC_AUTH_AES_256	= ( IPSEC_AUTH_AES_192 + 1 ) ,
	IPSEC_AUTH_MAX	= ( IPSEC_AUTH_AES_256 + 1 ) 
    } 	IPSEC_AUTH_TYPE;

typedef UINT8 IPSEC_AUTH_CONFIG;

#define IPSEC_AUTH_CONFIG_HMAC_MD5_96         (0)
#define IPSEC_AUTH_CONFIG_HMAC_SHA_1_96       (1)
#define IPSEC_AUTH_CONFIG_HMAC_SHA_256_128    (2)
#define IPSEC_AUTH_CONFIG_GCM_AES_128         (3)
#define IPSEC_AUTH_CONFIG_GCM_AES_192         (4)
#define IPSEC_AUTH_CONFIG_GCM_AES_256         (5)
#define IPSEC_AUTH_CONFIG_MAX                 (6)
typedef struct IPSEC_AUTH_TRANSFORM_ID0_
    {
    IPSEC_AUTH_TYPE authType;
    IPSEC_AUTH_CONFIG authConfig;
    } 	IPSEC_AUTH_TRANSFORM_ID0;

typedef GUID IPSEC_CRYPTO_MODULE_ID;

typedef struct IPSEC_AUTH_TRANSFORM0_
    {
    IPSEC_AUTH_TRANSFORM_ID0 authTransformId;
    IPSEC_CRYPTO_MODULE_ID *cryptoModuleId;
    } 	IPSEC_AUTH_TRANSFORM0;

typedef /* [v1_enum] */ 
enum IPSEC_CIPHER_TYPE_
    {	IPSEC_CIPHER_TYPE_DES	= 1,
	IPSEC_CIPHER_TYPE_3DES	= ( IPSEC_CIPHER_TYPE_DES + 1 ) ,
	IPSEC_CIPHER_TYPE_AES_128	= ( IPSEC_CIPHER_TYPE_3DES + 1 ) ,
	IPSEC_CIPHER_TYPE_AES_192	= ( IPSEC_CIPHER_TYPE_AES_128 + 1 ) ,
	IPSEC_CIPHER_TYPE_AES_256	= ( IPSEC_CIPHER_TYPE_AES_192 + 1 ) ,
	IPSEC_CIPHER_TYPE_MAX	= ( IPSEC_CIPHER_TYPE_AES_256 + 1 ) 
    } 	IPSEC_CIPHER_TYPE;

typedef UINT8 IPSEC_CIPHER_CONFIG;

#define IPSEC_CIPHER_CONFIG_CBC_DES      (1)
#define IPSEC_CIPHER_CONFIG_CBC_3DES     (2)
#define IPSEC_CIPHER_CONFIG_CBC_AES_128  (3)
#define IPSEC_CIPHER_CONFIG_CBC_AES_192  (4)
#define IPSEC_CIPHER_CONFIG_CBC_AES_256  (5)
#define IPSEC_CIPHER_CONFIG_GCM_AES_128  (6)
#define IPSEC_CIPHER_CONFIG_GCM_AES_192  (7)
#define IPSEC_CIPHER_CONFIG_GCM_AES_256  (8)
#define IPSEC_CIPHER_CONFIG_MAX          (9)
typedef struct IPSEC_CIPHER_TRANSFORM_ID0_
    {
    IPSEC_CIPHER_TYPE cipherType;
    IPSEC_CIPHER_CONFIG cipherConfig;
    } 	IPSEC_CIPHER_TRANSFORM_ID0;

typedef struct IPSEC_CIPHER_TRANSFORM0_
    {
    IPSEC_CIPHER_TRANSFORM_ID0 cipherTransformId;
    IPSEC_CRYPTO_MODULE_ID *cryptoModuleId;
    } 	IPSEC_CIPHER_TRANSFORM0;

typedef struct IPSEC_AUTH_AND_CIPHER_TRANSFORM0_
    {
    IPSEC_AUTH_TRANSFORM0 authTransform;
    IPSEC_CIPHER_TRANSFORM0 cipherTransform;
    } 	IPSEC_AUTH_AND_CIPHER_TRANSFORM0;

typedef struct IPSEC_SA_TRANSFORM0_
    {
    IPSEC_TRANSFORM_TYPE ipsecTransformType;
    union 
        {
        IPSEC_AUTH_TRANSFORM0 *ahTransform;
        IPSEC_AUTH_TRANSFORM0 *espAuthTransform;
        IPSEC_CIPHER_TRANSFORM0 *espCipherTransform;
        IPSEC_AUTH_AND_CIPHER_TRANSFORM0 *espAuthAndCipherTransform;
        IPSEC_AUTH_TRANSFORM0 *espAuthFwTransform;
        } 	;
    } 	IPSEC_SA_TRANSFORM0;

#define espAuthTranform espAuthTransform
typedef /* [v1_enum] */ 
enum IPSEC_PFS_GROUP_
    {	IPSEC_PFS_NONE	= 0,
	IPSEC_PFS_1	= ( IPSEC_PFS_NONE + 1 ) ,
	IPSEC_PFS_2	= ( IPSEC_PFS_1 + 1 ) ,
	IPSEC_PFS_2048	= ( IPSEC_PFS_2 + 1 ) ,
	IPSEC_PFS_ECP_256	= ( IPSEC_PFS_2048 + 1 ) ,
	IPSEC_PFS_ECP_384	= ( IPSEC_PFS_ECP_256 + 1 ) ,
	IPSEC_PFS_MM	= ( IPSEC_PFS_ECP_384 + 1 ) ,
	IPSEC_PFS_MAX	= ( IPSEC_PFS_MM + 1 ) 
    } 	IPSEC_PFS_GROUP;

typedef struct IPSEC_PROPOSAL0_
    {
    IPSEC_SA_LIFETIME0 lifetime;
    UINT32 numSaTransforms;
    IPSEC_SA_TRANSFORM0 *saTransforms;
    IPSEC_PFS_GROUP pfsGroup;
    } 	IPSEC_PROPOSAL0;

typedef struct IPSEC_SA_IDLE_TIMEOUT0_
    {
    UINT32 idleTimeoutSeconds;
    UINT32 idleTimeoutSecondsFailOver;
    } 	IPSEC_SA_IDLE_TIMEOUT0;

#define IPSEC_POLICY_FLAG_ND_SECURE     (0x00000002)
#define IPSEC_POLICY_FLAG_ND_BOUNDARY   (0x00000004)
#define IPSEC_POLICY_FLAG_CLEAR_DF_ON_TUNNEL   (0x00000008)
#define IPSEC_POLICY_FLAG_NAT_ENCAP_ALLOW_PEER_BEHIND_NAT   (0x00000010)
#define IPSEC_POLICY_FLAG_NAT_ENCAP_ALLOW_GENERAL_NAT_TRAVERSAL   (0x00000020)
#define IPSEC_POLICY_FLAG_DONT_NEGOTIATE_SECOND_LIFETIME   (0x00000040)
#define IPSEC_POLICY_FLAG_DONT_NEGOTIATE_BYTE_LIFETIME   (0x00000080)
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define IPSEC_POLICY_FLAG_ENABLE_V6_IN_V4_TUNNELING  (0x00000100)
#define IPSEC_POLICY_FLAG_ENABLE_SERVER_ADDR_ASSIGNMENT  (0x00000200)
#define IPSEC_POLICY_FLAG_TUNNEL_ALLOW_OUTBOUND_CLEAR_CONNECTION  (0x00000400)
#define IPSEC_POLICY_FLAG_TUNNEL_BYPASS_ALREADY_SECURE_CONNECTION (0x00000800)
#define IPSEC_POLICY_FLAG_TUNNEL_BYPASS_ICMPV6 (0x00001000)
#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TRANSPORT_POLICY0_
    {
    UINT32 numIpsecProposals;
    IPSEC_PROPOSAL0 *ipsecProposals;
    UINT32 flags;
    UINT32 ndAllowClearTimeoutSeconds;
    IPSEC_SA_IDLE_TIMEOUT0 saIdleTimeout;
    IKEEXT_EM_POLICY0 *emPolicy;
    } 	IPSEC_TRANSPORT_POLICY0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TRANSPORT_POLICY1_
    {
    UINT32 numIpsecProposals;
    IPSEC_PROPOSAL0 *ipsecProposals;
    UINT32 flags;
    UINT32 ndAllowClearTimeoutSeconds;
    IPSEC_SA_IDLE_TIMEOUT0 saIdleTimeout;
    IKEEXT_EM_POLICY1 *emPolicy;
    } 	IPSEC_TRANSPORT_POLICY1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TUNNEL_ENDPOINTS0_
    {
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 localV4Address;
        UINT8 localV6Address[ 16 ];
        } 	;
    union 
        {
        UINT32 remoteV4Address;
        UINT8 remoteV6Address[ 16 ];
        } 	;
    } 	IPSEC_TUNNEL_ENDPOINTS0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TUNNEL_ENDPOINTS1_
    {
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 localV4Address;
        UINT8 localV6Address[ 16 ];
        } 	;
    union 
        {
        UINT32 remoteV4Address;
        UINT8 remoteV6Address[ 16 ];
        } 	;
    UINT64 localIfLuid;
    } 	IPSEC_TUNNEL_ENDPOINTS1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TUNNEL_POLICY0_
    {
    UINT32 flags;
    UINT32 numIpsecProposals;
    IPSEC_PROPOSAL0 *ipsecProposals;
    IPSEC_TUNNEL_ENDPOINTS0 tunnelEndpoints;
    IPSEC_SA_IDLE_TIMEOUT0 saIdleTimeout;
    IKEEXT_EM_POLICY0 *emPolicy;
    } 	IPSEC_TUNNEL_POLICY0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TUNNEL_POLICY1_
    {
    UINT32 flags;
    UINT32 numIpsecProposals;
    IPSEC_PROPOSAL0 *ipsecProposals;
    IPSEC_TUNNEL_ENDPOINTS1 tunnelEndpoints;
    IPSEC_SA_IDLE_TIMEOUT0 saIdleTimeout;
    IKEEXT_EM_POLICY1 *emPolicy;
    } 	IPSEC_TUNNEL_POLICY1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_KEYING_POLICY0_
    {
    UINT32 numKeyMods;
    GUID *keyModKeys;
    } 	IPSEC_KEYING_POLICY0;

typedef struct IPSEC_AGGREGATE_SA_STATISTICS0_
    {
    UINT32 activeSas;
    UINT32 pendingSaNegotiations;
    UINT32 totalSasAdded;
    UINT32 totalSasDeleted;
    UINT32 successfulRekeys;
    UINT32 activeTunnels;
    UINT32 offloadedSas;
    } 	IPSEC_AGGREGATE_SA_STATISTICS0;

typedef struct IPSEC_ESP_DROP_PACKET_STATISTICS0_
    {
    UINT32 invalidSpisOnInbound;
    UINT32 decryptionFailuresOnInbound;
    UINT32 authenticationFailuresOnInbound;
    UINT32 replayCheckFailuresOnInbound;
    UINT32 saNotInitializedOnInbound;
    } 	IPSEC_ESP_DROP_PACKET_STATISTICS0;

typedef struct IPSEC_AH_DROP_PACKET_STATISTICS0_
    {
    UINT32 invalidSpisOnInbound;
    UINT32 authenticationFailuresOnInbound;
    UINT32 replayCheckFailuresOnInbound;
    UINT32 saNotInitializedOnInbound;
    } 	IPSEC_AH_DROP_PACKET_STATISTICS0;

typedef struct IPSEC_AGGREGATE_DROP_PACKET_STATISTICS0_
    {
    UINT32 invalidSpisOnInbound;
    UINT32 decryptionFailuresOnInbound;
    UINT32 authenticationFailuresOnInbound;
    UINT32 udpEspValidationFailuresOnInbound;
    UINT32 replayCheckFailuresOnInbound;
    UINT32 invalidClearTextInbound;
    UINT32 saNotInitializedOnInbound;
    UINT32 receiveOverIncorrectSaInbound;
    UINT32 secureReceivesNotMatchingFilters;
    } 	IPSEC_AGGREGATE_DROP_PACKET_STATISTICS0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_AGGREGATE_DROP_PACKET_STATISTICS1_
    {
    UINT32 invalidSpisOnInbound;
    UINT32 decryptionFailuresOnInbound;
    UINT32 authenticationFailuresOnInbound;
    UINT32 udpEspValidationFailuresOnInbound;
    UINT32 replayCheckFailuresOnInbound;
    UINT32 invalidClearTextInbound;
    UINT32 saNotInitializedOnInbound;
    UINT32 receiveOverIncorrectSaInbound;
    UINT32 secureReceivesNotMatchingFilters;
    UINT32 totalDropPacketsInbound;
    } 	IPSEC_AGGREGATE_DROP_PACKET_STATISTICS1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TRAFFIC_STATISTICS0_
    {
    UINT64 encryptedByteCount;
    UINT64 authenticatedAHByteCount;
    UINT64 authenticatedESPByteCount;
    UINT64 transportByteCount;
    UINT64 tunnelByteCount;
    UINT64 offloadByteCount;
    } 	IPSEC_TRAFFIC_STATISTICS0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TRAFFIC_STATISTICS1_
    {
    UINT64 encryptedByteCount;
    UINT64 authenticatedAHByteCount;
    UINT64 authenticatedESPByteCount;
    UINT64 transportByteCount;
    UINT64 tunnelByteCount;
    UINT64 offloadByteCount;
    UINT64 totalSuccessfulPackets;
    } 	IPSEC_TRAFFIC_STATISTICS1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_STATISTICS0_
    {
    IPSEC_AGGREGATE_SA_STATISTICS0 aggregateSaStatistics;
    IPSEC_ESP_DROP_PACKET_STATISTICS0 espDropPacketStatistics;
    IPSEC_AH_DROP_PACKET_STATISTICS0 ahDropPacketStatistics;
    IPSEC_AGGREGATE_DROP_PACKET_STATISTICS0 aggregateDropPacketStatistics;
    IPSEC_TRAFFIC_STATISTICS0 inboundTrafficStatistics;
    IPSEC_TRAFFIC_STATISTICS0 outboundTrafficStatistics;
    } 	IPSEC_STATISTICS0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_STATISTICS1_
    {
    IPSEC_AGGREGATE_SA_STATISTICS0 aggregateSaStatistics;
    IPSEC_ESP_DROP_PACKET_STATISTICS0 espDropPacketStatistics;
    IPSEC_AH_DROP_PACKET_STATISTICS0 ahDropPacketStatistics;
    IPSEC_AGGREGATE_DROP_PACKET_STATISTICS1 aggregateDropPacketStatistics;
    IPSEC_TRAFFIC_STATISTICS1 inboundTrafficStatistics;
    IPSEC_TRAFFIC_STATISTICS1 outboundTrafficStatistics;
    } 	IPSEC_STATISTICS1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef UINT32 IPSEC_SA_SPI;

typedef struct IPSEC_SA_AUTH_INFORMATION0_
    {
    IPSEC_AUTH_TRANSFORM0 authTransform;
    FWP_BYTE_BLOB authKey;
    } 	IPSEC_SA_AUTH_INFORMATION0;

typedef struct IPSEC_SA_CIPHER_INFORMATION0_
    {
    IPSEC_CIPHER_TRANSFORM0 cipherTransform;
    FWP_BYTE_BLOB cipherKey;
    } 	IPSEC_SA_CIPHER_INFORMATION0;

typedef struct IPSEC_SA_AUTH_AND_CIPHER_INFORMATION0_
    {
    IPSEC_SA_CIPHER_INFORMATION0 saCipherInformation;
    IPSEC_SA_AUTH_INFORMATION0 saAuthInformation;
    } 	IPSEC_SA_AUTH_AND_CIPHER_INFORMATION0;

typedef struct IPSEC_SA0_
    {
    IPSEC_SA_SPI spi;
    IPSEC_TRANSFORM_TYPE saTransformType;
    union 
        {
        IPSEC_SA_AUTH_INFORMATION0 *ahInformation;
        IPSEC_SA_AUTH_INFORMATION0 *espAuthInformation;
        IPSEC_SA_CIPHER_INFORMATION0 *espCipherInformation;
        IPSEC_SA_AUTH_AND_CIPHER_INFORMATION0 *espAuthAndCipherInformation;
        IPSEC_SA_AUTH_INFORMATION0 *espAuthFwInformation;
        } 	;
    } 	IPSEC_SA0;

typedef struct IPSEC_KEYMODULE_STATE0_
    {
    GUID keyModuleKey;
    FWP_BYTE_BLOB stateBlob;
    } 	IPSEC_KEYMODULE_STATE0;

typedef UINT64 IPSEC_TOKEN_HANDLE;

typedef /* [v1_enum] */ 
enum IPSEC_TOKEN_TYPE_
    {	IPSEC_TOKEN_TYPE_MACHINE	= 0,
	IPSEC_TOKEN_TYPE_IMPERSONATION	= ( IPSEC_TOKEN_TYPE_MACHINE + 1 ) ,
	IPSEC_TOKEN_TYPE_MAX	= ( IPSEC_TOKEN_TYPE_IMPERSONATION + 1 ) 
    } 	IPSEC_TOKEN_TYPE;

typedef /* [v1_enum] */ 
enum IPSEC_TOKEN_PRINCIPAL_
    {	IPSEC_TOKEN_PRINCIPAL_LOCAL	= 0,
	IPSEC_TOKEN_PRINCIPAL_PEER	= ( IPSEC_TOKEN_PRINCIPAL_LOCAL + 1 ) ,
	IPSEC_TOKEN_PRINCIPAL_MAX	= ( IPSEC_TOKEN_PRINCIPAL_PEER + 1 ) 
    } 	IPSEC_TOKEN_PRINCIPAL;

typedef /* [v1_enum] */ 
enum IPSEC_TOKEN_MODE_
    {	IPSEC_TOKEN_MODE_MAIN	= 0,
	IPSEC_TOKEN_MODE_EXTENDED	= ( IPSEC_TOKEN_MODE_MAIN + 1 ) ,
	IPSEC_TOKEN_MODE_MAX	= ( IPSEC_TOKEN_MODE_EXTENDED + 1 ) 
    } 	IPSEC_TOKEN_MODE;

typedef struct IPSEC_TOKEN0_
    {
    IPSEC_TOKEN_TYPE type;
    IPSEC_TOKEN_PRINCIPAL principal;
    IPSEC_TOKEN_MODE mode;
    IPSEC_TOKEN_HANDLE token;
    } 	IPSEC_TOKEN0;

typedef struct IPSEC_ID0_
    {
    wchar_t *mmTargetName;
    wchar_t *emTargetName;
    UINT32 numTokens;
    IPSEC_TOKEN0 *tokens;
    UINT64 explicitCredentials;
    UINT64 logonId;
    } 	IPSEC_ID0;

#define IPSEC_SA_BUNDLE_FLAG_ND_SECURE (0x00000001)
#define IPSEC_SA_BUNDLE_FLAG_ND_BOUNDARY (0x00000002)
#define IPSEC_SA_BUNDLE_FLAG_ND_PEER_NAT_BOUNDARY (0x00000004)
#define IPSEC_SA_BUNDLE_FLAG_GUARANTEE_ENCRYPTION (0x00000008)
#define IPSEC_SA_BUNDLE_FLAG_NLB (0x00000010)
#define IPSEC_SA_BUNDLE_FLAG_NO_MACHINE_LUID_VERIFY (0x00000020)
#define IPSEC_SA_BUNDLE_FLAG_NO_IMPERSONATION_LUID_VERIFY (0x00000040)
#define IPSEC_SA_BUNDLE_FLAG_NO_EXPLICIT_CRED_MATCH (0x00000080)
#define IPSEC_SA_BUNDLE_FLAG_ALLOW_NULL_TARGET_NAME_MATCH (0x00000200)
#define IPSEC_SA_BUNDLE_FLAG_CLEAR_DF_ON_TUNNEL   (0x00000400)
#define IPSEC_SA_BUNDLE_FLAG_ASSUME_UDP_CONTEXT_OUTBOUND (0x00000800)
#if (NTDDI_VERSION >= NTDDI_WIN6SP1)
#define IPSEC_SA_BUNDLE_FLAG_ND_PEER_BOUNDARY (0x00001000)
#endif
#if (NTDDI_VERSION >= NTDDI_WIN7)
#define IPSEC_SA_BUNDLE_FLAG_SUPPRESS_DUPLICATE_DELETION (0x00002000)
#define IPSEC_SA_BUNDLE_FLAG_PEER_SUPPORTS_GUARANTEE_ENCRYPTION (0x00004000)
#define IPSEC_SA_BUNDLE_FLAG_FORCE_INBOUND_CONNECTIONS (0x00008000)
#define IPSEC_SA_BUNDLE_FLAG_FORCE_OUTBOUND_CONNECTIONS (0x00010000)
#define IPSEC_SA_BUNDLE_FLAG_FORWARD_PATH_INITIATOR (0x00020000)
#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_SA_BUNDLE0_
    {
    UINT32 flags;
    IPSEC_SA_LIFETIME0 lifetime;
    UINT32 idleTimeoutSeconds;
    UINT32 ndAllowClearTimeoutSeconds;
    IPSEC_ID0 *ipsecId;
    UINT32 napContext;
    UINT32 qmSaId;
    UINT32 numSAs;
    IPSEC_SA0 *saList;
    IPSEC_KEYMODULE_STATE0 *keyModuleState;
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 peerV4PrivateAddress;
         /* Empty union arm */ 
        } 	;
    UINT64 mmSaId;
    IPSEC_PFS_GROUP pfsGroup;
    } 	IPSEC_SA_BUNDLE0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_SA_BUNDLE1_
    {
    UINT32 flags;
    IPSEC_SA_LIFETIME0 lifetime;
    UINT32 idleTimeoutSeconds;
    UINT32 ndAllowClearTimeoutSeconds;
    IPSEC_ID0 *ipsecId;
    UINT32 napContext;
    UINT32 qmSaId;
    UINT32 numSAs;
    IPSEC_SA0 *saList;
    IPSEC_KEYMODULE_STATE0 *keyModuleState;
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 peerV4PrivateAddress;
         /* Empty union arm */ 
        } 	;
    UINT64 mmSaId;
    IPSEC_PFS_GROUP pfsGroup;
    GUID saLookupContext;
    UINT64 qmFilterId;
    } 	IPSEC_SA_BUNDLE1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef /* [v1_enum] */ 
enum IPSEC_TRAFFIC_TYPE_
    {	IPSEC_TRAFFIC_TYPE_TRANSPORT	= 0,
	IPSEC_TRAFFIC_TYPE_TUNNEL	= ( IPSEC_TRAFFIC_TYPE_TRANSPORT + 1 ) ,
	IPSEC_TRAFFIC_TYPE_MAX	= ( IPSEC_TRAFFIC_TYPE_TUNNEL + 1 ) 
    } 	IPSEC_TRAFFIC_TYPE;

typedef struct IPSEC_TRAFFIC0_
    {
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 localV4Address;
        UINT8 localV6Address[ 16 ];
        } 	;
    union 
        {
        UINT32 remoteV4Address;
        UINT8 remoteV6Address[ 16 ];
        } 	;
    IPSEC_TRAFFIC_TYPE trafficType;
    union 
        {
        UINT64 ipsecFilterId;
        UINT64 tunnelPolicyId;
        } 	;
    UINT16 remotePort;
    } 	IPSEC_TRAFFIC0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_TRAFFIC1_
    {
    FWP_IP_VERSION ipVersion;
    union 
        {
        UINT32 localV4Address;
        UINT8 localV6Address[ 16 ];
        } 	;
    union 
        {
        UINT32 remoteV4Address;
        UINT8 remoteV6Address[ 16 ];
        } 	;
    IPSEC_TRAFFIC_TYPE trafficType;
    union 
        {
        UINT64 ipsecFilterId;
        UINT64 tunnelPolicyId;
        } 	;
    UINT16 remotePort;
    UINT16 localPort;
    UINT8 ipProtocol;
    UINT64 localIfLuid;
    UINT32 realIfProfileId;
    } 	IPSEC_TRAFFIC1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_V4_UDP_ENCAPSULATION0_
    {
    UINT16 localUdpEncapPort;
    UINT16 remoteUdpEncapPort;
    } 	IPSEC_V4_UDP_ENCAPSULATION0;

typedef struct IPSEC_GETSPI0_
    {
    IPSEC_TRAFFIC0 inboundIpsecTraffic;
    FWP_IP_VERSION ipVersion;
    union 
        {
        IPSEC_V4_UDP_ENCAPSULATION0 *inboundUdpEncapsulation;
         /* Empty union arm */ 
        } 	;
    IPSEC_CRYPTO_MODULE_ID *rngCryptoModuleID;
    } 	IPSEC_GETSPI0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_GETSPI1_
    {
    IPSEC_TRAFFIC1 inboundIpsecTraffic;
    FWP_IP_VERSION ipVersion;
    union 
        {
        IPSEC_V4_UDP_ENCAPSULATION0 *inboundUdpEncapsulation;
         /* Empty union arm */ 
        } 	;
    IPSEC_CRYPTO_MODULE_ID *rngCryptoModuleID;
    } 	IPSEC_GETSPI1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_VIRTUAL_IF_TUNNEL_INFO0_
    {
    UINT64 virtualIfTunnelId;
    UINT64 trafficSelectorId;
    } 	IPSEC_VIRTUAL_IF_TUNNEL_INFO0;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_SA_DETAILS0_
    {
    FWP_IP_VERSION ipVersion;
    FWP_DIRECTION saDirection;
    IPSEC_TRAFFIC0 traffic;
    IPSEC_SA_BUNDLE0 saBundle;
    union 
        {
        IPSEC_V4_UDP_ENCAPSULATION0 *udpEncapsulation;
         /* Empty union arm */ 
        } 	;
    FWPM_FILTER0 *transportFilter;
    } 	IPSEC_SA_DETAILS0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_SA_DETAILS1_
    {
    FWP_IP_VERSION ipVersion;
    FWP_DIRECTION saDirection;
    IPSEC_TRAFFIC1 traffic;
    IPSEC_SA_BUNDLE1 saBundle;
    union 
        {
        IPSEC_V4_UDP_ENCAPSULATION0 *udpEncapsulation;
         /* Empty union arm */ 
        } 	;
    FWPM_FILTER0 *transportFilter;
    IPSEC_VIRTUAL_IF_TUNNEL_INFO0 virtualIfTunnelInfo;
    } 	IPSEC_SA_DETAILS1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_SA_CONTEXT0_
    {
    UINT64 saContextId;
    IPSEC_SA_DETAILS0 *inboundSa;
    IPSEC_SA_DETAILS0 *outboundSa;
    } 	IPSEC_SA_CONTEXT0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_SA_CONTEXT1_
    {
    UINT64 saContextId;
    IPSEC_SA_DETAILS1 *inboundSa;
    IPSEC_SA_DETAILS1 *outboundSa;
    } 	IPSEC_SA_CONTEXT1;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
typedef struct IPSEC_SA_CONTEXT_ENUM_TEMPLATE0_
    {
    FWP_CONDITION_VALUE0 localSubNet;
    FWP_CONDITION_VALUE0 remoteSubNet;
    } 	IPSEC_SA_CONTEXT_ENUM_TEMPLATE0;

typedef struct IPSEC_SA_ENUM_TEMPLATE0_
    {
    FWP_DIRECTION saDirection;
    } 	IPSEC_SA_ENUM_TEMPLATE0;

typedef /* [v1_enum] */ 
enum IPSEC_FAILURE_POINT_
    {	IPSEC_FAILURE_NONE	= 0,
	IPSEC_FAILURE_ME	= ( IPSEC_FAILURE_NONE + 1 ) ,
	IPSEC_FAILURE_PEER	= ( IPSEC_FAILURE_ME + 1 ) ,
	IPSEC_FAILURE_POINT_MAX	= ( IPSEC_FAILURE_PEER + 1 ) 
    } 	IPSEC_FAILURE_POINT;

typedef struct IPSEC_ADDRESS_INFO0_
    {
    UINT32 numV4Addresses;
    UINT32 *v4Addresses;
    UINT32 numV6Addresses;
    FWP_BYTE_ARRAY16 *v6Addresses;
    } 	IPSEC_ADDRESS_INFO0;

#if (NTDDI_VERSION >= NTDDI_WIN7)
#define IPSEC_DOSP_FLAG_ENABLE_IKEV1  (0x00000001)
#define IPSEC_DOSP_FLAG_ENABLE_IKEV2  (0x00000002)
#define IPSEC_DOSP_FLAG_DISABLE_AUTHIP  (0x00000004)
#define IPSEC_DOSP_FLAG_DISABLE_DEFAULT_BLOCK  (0x00000008)
#define IPSEC_DOSP_FLAG_FILTER_BLOCK  (0x00000010)
#define IPSEC_DOSP_FLAG_FILTER_EXEMPT  (0x00000020)
#define IPSEC_DOSP_DSCP_DISABLE_VALUE  (0xff)
#define IPSEC_DOSP_RATE_LIMIT_DISABLE_VALUE  (0)
typedef struct IPSEC_DOSP_OPTIONS0_
    {
    UINT32 stateIdleTimeoutSeconds;
    UINT32 perIPRateLimitQueueIdleTimeoutSeconds;
    UINT8 ipV6IPsecUnauthDscp;
    UINT32 ipV6IPsecUnauthRateLimitBytesPerSec;
    UINT32 ipV6IPsecUnauthPerIPRateLimitBytesPerSec;
    UINT8 ipV6IPsecAuthDscp;
    UINT32 ipV6IPsecAuthRateLimitBytesPerSec;
    UINT8 icmpV6Dscp;
    UINT32 icmpV6RateLimitBytesPerSec;
    UINT8 ipV6FilterExemptDscp;
    UINT32 ipV6FilterExemptRateLimitBytesPerSec;
    UINT8 defBlockExemptDscp;
    UINT32 defBlockExemptRateLimitBytesPerSec;
    UINT32 maxStateEntries;
    UINT32 maxPerIPRateLimitQueues;
    UINT32 flags;
    UINT32 numPublicIFLuids;
    UINT64 *publicIFLuids;
    UINT32 numInternalIFLuids;
    UINT64 *internalIFLuids;
    FWP_V6_ADDR_AND_MASK publicV6AddrMask;
    FWP_V6_ADDR_AND_MASK internalV6AddrMask;
    } 	IPSEC_DOSP_OPTIONS0;

typedef struct IPSEC_DOSP_STATISTICS0_
    {
    UINT64 totalStateEntriesCreated;
    UINT64 currentStateEntries;
    UINT64 totalInboundAllowedIPv6IPsecUnauthPkts;
    UINT64 totalInboundRatelimitDiscardedIPv6IPsecUnauthPkts;
    UINT64 totalInboundPerIPRatelimitDiscardedIPv6IPsecUnauthPkts;
    UINT64 totalInboundOtherDiscardedIPv6IPsecUnauthPkts;
    UINT64 totalInboundAllowedIPv6IPsecAuthPkts;
    UINT64 totalInboundRatelimitDiscardedIPv6IPsecAuthPkts;
    UINT64 totalInboundOtherDiscardedIPv6IPsecAuthPkts;
    UINT64 totalInboundAllowedICMPv6Pkts;
    UINT64 totalInboundRatelimitDiscardedICMPv6Pkts;
    UINT64 totalInboundAllowedIPv6FilterExemptPkts;
    UINT64 totalInboundRatelimitDiscardedIPv6FilterExemptPkts;
    UINT64 totalInboundDiscardedIPv6FilterBlockPkts;
    UINT64 totalInboundAllowedDefBlockExemptPkts;
    UINT64 totalInboundRatelimitDiscardedDefBlockExemptPkts;
    UINT64 totalInboundDiscardedDefBlockPkts;
    UINT64 currentInboundIPv6IPsecUnauthPerIPRateLimitQueues;
    } 	IPSEC_DOSP_STATISTICS0;

typedef struct IPSEC_DOSP_STATE0_
    {
    UINT8 publicHostV6Addr[ 16 ];
    UINT8 internalHostV6Addr[ 16 ];
    UINT64 totalInboundIPv6IPsecAuthPackets;
    UINT64 totalOutboundIPv6IPsecAuthPackets;
    UINT32 durationSecs;
    } 	IPSEC_DOSP_STATE0;

typedef struct IPSEC_DOSP_STATE_ENUM_TEMPLATE0_
    {
    FWP_V6_ADDR_AND_MASK publicV6AddrMask;
    FWP_V6_ADDR_AND_MASK internalV6AddrMask;
    } 	IPSEC_DOSP_STATE_ENUM_TEMPLATE0;

#endif // (NTDDI_VERSION >= NTDDI_WIN7)
#if _MSC_VER >=  800
#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif
#endif


extern RPC_IF_HANDLE __MIDL_itf_ipsectypes_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ipsectypes_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ipmib.h ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    ipmib.h

Abstract:

    This module contains the public definitions and structures for the
    IP-specific parts of MIB-II.  These definitions were previously
    in iprtrmib.h, which now includes this file.

--*/

#ifndef _IPMIB_
#define _IPMIB_
#pragma once

#ifndef ANY_SIZE
#define ANY_SIZE 1
#endif

//
// Pick up definitions of MAXLEN_PHYSADDR, etc.
//
#include <ifmib.h>

#include <nldef.h>

#define MIB_IPADDR_PRIMARY      0x0001 // Primary ipaddr
#define MIB_IPADDR_DYNAMIC      0x0004 // Dynamic ipaddr
#define MIB_IPADDR_DISCONNECTED 0x0008 // Address is on disconnected interface
#define MIB_IPADDR_DELETED      0x0040 // Address being deleted
#define MIB_IPADDR_TRANSIENT    0x0080 // Transient address
#define MIB_IPADDR_DNS_ELIGIBLE 0X0100 // Address is published in DNS.

typedef struct _MIB_IPADDRROW_XP {
    DWORD dwAddr;
    IF_INDEX dwIndex;
    DWORD dwMask;
    DWORD dwBCastAddr;
    DWORD dwReasmSize;
    unsigned short unused1;
    unsigned short wType;
} MIB_IPADDRROW_XP, *PMIB_IPADDRROW_XP;

typedef struct _MIB_IPADDRROW_W2K {
    DWORD dwAddr;
    DWORD dwIndex;
    DWORD dwMask;
    DWORD dwBCastAddr;
    DWORD dwReasmSize;
    unsigned short unused1;
    unsigned short unused2;
} MIB_IPADDRROW_W2K, *PMIB_IPADDRROW_W2K;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef MIB_IPADDRROW_XP MIB_IPADDRROW;
typedef MIB_IPADDRROW_XP *PMIB_IPADDRROW;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_IPADDRROW_W2K MIB_IPADDRROW;
typedef MIB_IPADDRROW_W2K *PMIB_IPADDRROW;
#else
typedef MIB_IPADDRROW_XP MIB_IPADDRROW;
typedef MIB_IPADDRROW_XP *PMIB_IPADDRROW;
#endif

typedef struct _MIB_IPADDRTABLE {
    DWORD dwNumEntries;
    MIB_IPADDRROW table[ANY_SIZE];
} MIB_IPADDRTABLE, *PMIB_IPADDRTABLE;


#define SIZEOF_IPADDRTABLE(X) (FIELD_OFFSET(MIB_IPADDRTABLE,table[0]) + \
                               ((X) * sizeof(MIB_IPADDRROW)) + ALIGN_SIZE)

typedef struct _MIB_IPFORWARDNUMBER {
    DWORD dwValue;
} MIB_IPFORWARDNUMBER,*PMIB_IPFORWARDNUMBER;

typedef NL_ROUTE_PROTOCOL MIB_IPFORWARD_PROTO;

typedef enum {
    MIB_IPROUTE_TYPE_OTHER    = 1,
    MIB_IPROUTE_TYPE_INVALID  = 2,
    MIB_IPROUTE_TYPE_DIRECT   = 3,
    MIB_IPROUTE_TYPE_INDIRECT = 4,
} MIB_IPFORWARD_TYPE;

typedef struct _MIB_IPFORWARDROW {
    DWORD dwForwardDest;
    DWORD dwForwardMask;
    DWORD dwForwardPolicy;
    DWORD dwForwardNextHop;
    IF_INDEX dwForwardIfIndex;
    union {
        DWORD dwForwardType;              // Old field name uses DWORD type.
        MIB_IPFORWARD_TYPE ForwardType;   // New field name uses enum type.
    };
    union {
        DWORD dwForwardProto;             // Old field name uses DWORD type.
        MIB_IPFORWARD_PROTO ForwardProto; // New field name uses enum type.
    };
    DWORD dwForwardAge;
    DWORD dwForwardNextHopAS;
    DWORD dwForwardMetric1;
    DWORD dwForwardMetric2;
    DWORD dwForwardMetric3;
    DWORD dwForwardMetric4;
    DWORD dwForwardMetric5;
} MIB_IPFORWARDROW, *PMIB_IPFORWARDROW;

#define MIB_IPROUTE_TYPE_OTHER    1
#define MIB_IPROUTE_TYPE_INVALID  2
#define MIB_IPROUTE_TYPE_DIRECT   3
#define MIB_IPROUTE_TYPE_INDIRECT 4

#define MIB_IPROUTE_METRIC_UNUSED    (DWORD)-1


typedef struct _MIB_IPFORWARDTABLE {
    DWORD dwNumEntries;
    MIB_IPFORWARDROW table[ANY_SIZE];
} MIB_IPFORWARDTABLE, *PMIB_IPFORWARDTABLE;

#define SIZEOF_IPFORWARDTABLE(X) \
            (FIELD_OFFSET(MIB_IPFORWARDTABLE,table[0]) + \
             ((X) * sizeof(MIB_IPFORWARDROW)) + ALIGN_SIZE)


typedef enum {
    MIB_IPNET_TYPE_OTHER   = 1,
    MIB_IPNET_TYPE_INVALID = 2,
    MIB_IPNET_TYPE_DYNAMIC = 3,
    MIB_IPNET_TYPE_STATIC  = 4,
} MIB_IPNET_TYPE;

typedef struct _MIB_IPNETROW_LH {
    IF_INDEX dwIndex;
    DWORD dwPhysAddrLen;
    UCHAR bPhysAddr[MAXLEN_PHYSADDR];
    DWORD dwAddr;
    union {
        DWORD dwType;           // Old field name was just a DWORD.
        MIB_IPNET_TYPE Type;    // New field name uses the enum type.
    };
} MIB_IPNETROW_LH, *PMIB_IPNETROW_LH;

typedef struct _MIB_IPNETROW_W2K {
    IF_INDEX dwIndex;
    DWORD dwPhysAddrLen;
    UCHAR bPhysAddr[MAXLEN_PHYSADDR];
    DWORD dwAddr;
    DWORD dwType;
} MIB_IPNETROW_W2K, *PMIB_IPNETROW_W2K;


#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef MIB_IPNETROW_LH MIB_IPNETROW;
typedef MIB_IPNETROW_LH *PMIB_IPNETROW;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_IPNETROW_W2K MIB_IPNETROW;
typedef MIB_IPNETROW_W2K *PMIB_IPNETROW;
#else
typedef MIB_IPNETROW_LH MIB_IPNETROW;
typedef MIB_IPNETROW_LH *PMIB_IPNETROW;
#endif

typedef struct _MIB_IPNETTABLE {
    DWORD dwNumEntries;
    MIB_IPNETROW table[ANY_SIZE];
} MIB_IPNETTABLE, *PMIB_IPNETTABLE;

#define SIZEOF_IPNETTABLE(X) (FIELD_OFFSET(MIB_IPNETTABLE, table[0]) + \
                              ((X) * sizeof(MIB_IPNETROW)) + ALIGN_SIZE)

typedef enum {
    MIB_IP_FORWARDING     = 1,
    MIB_IP_NOT_FORWARDING = 2,
} MIB_IPSTATS_FORWARDING, *PMIB_IPSTATS_FORWARDING;

#define MIB_USE_CURRENT_TTL         ((DWORD)-1)
#define MIB_USE_CURRENT_FORWARDING  ((DWORD)-1)

typedef struct _MIB_IPSTATS_LH {
    union {
        DWORD dwForwarding;
        MIB_IPSTATS_FORWARDING Forwarding;
    };
    DWORD dwDefaultTTL;
    DWORD dwInReceives;
    DWORD dwInHdrErrors;
    DWORD dwInAddrErrors;
    DWORD dwForwDatagrams;
    DWORD dwInUnknownProtos;
    DWORD dwInDiscards;
    DWORD dwInDelivers;
    DWORD dwOutRequests;
    DWORD dwRoutingDiscards;
    DWORD dwOutDiscards;
    DWORD dwOutNoRoutes;
    DWORD dwReasmTimeout;
    DWORD dwReasmReqds;
    DWORD dwReasmOks;
    DWORD dwReasmFails;
    DWORD dwFragOks;
    DWORD dwFragFails;
    DWORD dwFragCreates;
    DWORD dwNumIf;
    DWORD dwNumAddr;
    DWORD dwNumRoutes;
} MIB_IPSTATS_LH, *PMIB_IPSTATS_LH;

typedef struct _MIB_IPSTATS_W2K {
    DWORD dwForwarding;
    DWORD dwDefaultTTL;
    DWORD dwInReceives;
    DWORD dwInHdrErrors;
    DWORD dwInAddrErrors;
    DWORD dwForwDatagrams;
    DWORD dwInUnknownProtos;
    DWORD dwInDiscards;
    DWORD dwInDelivers;
    DWORD dwOutRequests;
    DWORD dwRoutingDiscards;
    DWORD dwOutDiscards;
    DWORD dwOutNoRoutes;
    DWORD dwReasmTimeout;
    DWORD dwReasmReqds;
    DWORD dwReasmOks;
    DWORD dwReasmFails;
    DWORD dwFragOks;
    DWORD dwFragFails;
    DWORD dwFragCreates;
    DWORD dwNumIf;
    DWORD dwNumAddr;
    DWORD dwNumRoutes;
} MIB_IPSTATS_W2K, *PMIB_IPSTATS_W2K;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef MIB_IPSTATS_LH MIB_IPSTATS;
typedef MIB_IPSTATS_LH *PMIB_IPSTATS;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_IPSTATS_W2K MIB_IPSTATS;
typedef MIB_IPSTATS_W2K *PMIB_IPSTATS;
#endif

typedef struct _MIBICMPSTATS {
    DWORD dwMsgs;
    DWORD dwErrors;
    DWORD dwDestUnreachs;
    DWORD dwTimeExcds;
    DWORD dwParmProbs;
    DWORD dwSrcQuenchs;
    DWORD dwRedirects;
    DWORD dwEchos;
    DWORD dwEchoReps;
    DWORD dwTimestamps;
    DWORD dwTimestampReps;
    DWORD dwAddrMasks;
    DWORD dwAddrMaskReps;
} MIBICMPSTATS, *PMIBICMPSTATS;

typedef struct _MIBICMPINFO {
    MIBICMPSTATS icmpInStats;
    MIBICMPSTATS icmpOutStats;
} MIBICMPINFO;

typedef struct _MIB_ICMP {
    MIBICMPINFO stats;
} MIB_ICMP,*PMIB_ICMP;

typedef struct _MIBICMPSTATS_EX_XPSP1 {
    DWORD dwMsgs;
    DWORD dwErrors;
    DWORD rgdwTypeCount[256];
} MIBICMPSTATS_EX_XPSP1, *PMIBICMPSTATS_EX_XPSP1;
#if (NTDDI_VERSION >= NTDDI_XPSP1)
typedef  MIBICMPSTATS_EX_XPSP1 MIBICMPSTATS_EX;
typedef  MIBICMPSTATS_EX_XPSP1 *PMIBICMPSTATS_EX;
#endif

typedef struct _MIB_ICMP_EX_XPSP1 {
    MIBICMPSTATS_EX icmpInStats;
    MIBICMPSTATS_EX icmpOutStats;
} MIB_ICMP_EX_XPSP1,*PMIB_ICMP_EX_XPSP1;
#if (NTDDI_VERSION >= NTDDI_XPSP1)
typedef  MIB_ICMP_EX_XPSP1 MIB_ICMP_EX;
typedef  MIB_ICMP_EX_XPSP1 *PMIB_ICMP_EX;
#else
//
// Still need these in case application does not set
// NTDDI_VERSION to one of the above.
//
typedef  MIB_ICMP_EX_XPSP1 MIB_ICMP_EX;
typedef  MIB_ICMP_EX_XPSP1 *PMIB_ICMP_EX;
#endif

//
// ICMP6_TYPE
//
// ICMPv6 Type Values from RFC 2292, 2461 (ND), and 3810 (MLDv2)
//
typedef enum {
    ICMP6_DST_UNREACH          =   1,
    ICMP6_PACKET_TOO_BIG       =   2,
    ICMP6_TIME_EXCEEDED        =   3,
    ICMP6_PARAM_PROB           =   4,
    ICMP6_ECHO_REQUEST         = 128,
    ICMP6_ECHO_REPLY           = 129,
    ICMP6_MEMBERSHIP_QUERY     = 130,
    ICMP6_MEMBERSHIP_REPORT    = 131,
    ICMP6_MEMBERSHIP_REDUCTION = 132,
    ND_ROUTER_SOLICIT          = 133,
    ND_ROUTER_ADVERT           = 134,
    ND_NEIGHBOR_SOLICIT        = 135,
    ND_NEIGHBOR_ADVERT         = 136,
    ND_REDIRECT                = 137,
    ICMP6_V2_MEMBERSHIP_REPORT = 143,
} ICMP6_TYPE, *PICMP6_TYPE;


//
// Used to identify informational/error messages.
//
#define ICMP6_INFOMSG_MASK 0x80
#define ICMP6_ISTYPEINFORMATIONAL(Type) (((Type) & ICMP6_INFOMSG_MASK) != 0)
#define ICMP6_ISTYPEERROR(Type) (!ICMP6_ISTYPEINFORMATIONAL(Type))

//
// ICMP4_TYPE
//
// There are no RFC-specified defines for ICMPv4 message types, so we try to
// use the ICMP6 values from RFC 2292 modified to be prefixed with ICMP4.
//
typedef enum {
    ICMP4_ECHO_REPLY        =  0, // Echo Reply.
    ICMP4_DST_UNREACH       =  3, // Destination Unreachable.
    ICMP4_SOURCE_QUENCH     =  4, // Source Quench.
    ICMP4_REDIRECT          =  5, // Redirect.
    ICMP4_ECHO_REQUEST      =  8, // Echo Request.
    ICMP4_ROUTER_ADVERT     =  9, // Router Advertisement.
    ICMP4_ROUTER_SOLICIT    = 10, // Router Solicitation.
    ICMP4_TIME_EXCEEDED     = 11, // Time Exceeded.
    ICMP4_PARAM_PROB        = 12, // Parameter Problem.
    ICMP4_TIMESTAMP_REQUEST = 13, // Timestamp Request.
    ICMP4_TIMESTAMP_REPLY   = 14, // Timestamp Reply.
    ICMP4_MASK_REQUEST      = 17, // Address Mask Request.
    ICMP4_MASK_REPLY        = 18, // Address Mask Reply.
} ICMP4_TYPE, *PICMP4_TYPE;

//
// See RFC 1812, section 4.3.1.
//
#define ICMP4_ISTYPEERROR(Type) \
    (((Type) == ICMP4_DST_UNREACH) || \
     ((Type) == ICMP4_SOURCE_QUENCH) || \
     ((Type) == ICMP4_REDIRECT) || \
     ((Type) == ICMP4_PARAM_PROB) || \
     ((Type) == ICMP4_TIME_EXCEEDED)) \

typedef struct _MIB_IPMCAST_OIF_XP {
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    DWORD   dwReserved;
    DWORD   dwReserved1;
} MIB_IPMCAST_OIF_XP, *PMIB_IPMCAST_OIF_XP ;

typedef struct _MIB_IPMCAST_OIF_W2K {
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    PVOID   pvReserved;
    DWORD   dwReserved;
} MIB_IPMCAST_OIF_W2K, *PMIB_IPMCAST_OIF_W2K;

#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef MIB_IPMCAST_OIF_XP MIB_IPMCAST_OIF;
typedef MIB_IPMCAST_OIF_XP *PMIB_IPMCAST_OIF;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef MIB_IPMCAST_OIF_W2K MIB_IPMCAST_OIF;
typedef MIB_IPMCAST_OIF_W2K *PMIB_IPMCAST_OIF;
#else
typedef MIB_IPMCAST_OIF_XP MIB_IPMCAST_OIF;
typedef MIB_IPMCAST_OIF_XP *PMIB_IPMCAST_OIF;
#endif

typedef struct _MIB_IPMCAST_MFE {
    DWORD   dwGroup;
    DWORD   dwSource;
    DWORD   dwSrcMask;
    DWORD   dwUpStrmNgbr;
    DWORD   dwInIfIndex;
    DWORD   dwInIfProtocol;
    DWORD   dwRouteProtocol;
    DWORD   dwRouteNetwork;
    DWORD   dwRouteMask;
    ULONG   ulUpTime;
    ULONG   ulExpiryTime;
    ULONG   ulTimeOut;
    ULONG   ulNumOutIf;
    DWORD   fFlags;
    DWORD   dwReserved;
    MIB_IPMCAST_OIF rgmioOutInfo[ANY_SIZE];
} MIB_IPMCAST_MFE, *PMIB_IPMCAST_MFE;

typedef struct _MIB_MFE_TABLE {
    DWORD           dwNumEntries;
    MIB_IPMCAST_MFE table[ANY_SIZE];
} MIB_MFE_TABLE, *PMIB_MFE_TABLE;


#define SIZEOF_BASIC_MIB_MFE          \
    (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE, rgmioOutInfo[0]))

#define SIZEOF_MIB_MFE(X)             \
    (SIZEOF_BASIC_MIB_MFE + ((X) * sizeof(MIB_IPMCAST_OIF)))


typedef struct _MIB_IPMCAST_OIF_STATS_LH {
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    DWORD   dwDialContext;
    ULONG   ulTtlTooLow;
    ULONG   ulFragNeeded;
    ULONG   ulOutPackets;
    ULONG   ulOutDiscards;
} MIB_IPMCAST_OIF_STATS_LH, *PMIB_IPMCAST_OIF_STATS_LH;

typedef struct _MIB_IPMCAST_OIF_STATS_W2K {
    DWORD   dwOutIfIndex;
    DWORD   dwNextHopAddr;
    PVOID   pvDialContext;
    ULONG   ulTtlTooLow;
    ULONG   ulFragNeeded;
    ULONG   ulOutPackets;
    ULONG   ulOutDiscards;
} MIB_IPMCAST_OIF_STATS_W2K, *PMIB_IPMCAST_OIF_STATS_W2K;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef  MIB_IPMCAST_OIF_STATS_LH MIB_IPMCAST_OIF_STATS;
typedef  MIB_IPMCAST_OIF_STATS_LH *PMIB_IPMCAST_OIF_STATS;
#elif (NTDDI_VERSION >= NTDDI_WIN2K)
typedef  MIB_IPMCAST_OIF_STATS_W2K MIB_IPMCAST_OIF_STATS;
typedef  MIB_IPMCAST_OIF_STATS_W2K *PMIB_IPMCAST_OIF_STATS;
#else
typedef  MIB_IPMCAST_OIF_STATS_LH MIB_IPMCAST_OIF_STATS;
typedef  MIB_IPMCAST_OIF_STATS_LH *PMIB_IPMCAST_OIF_STATS;
#endif

typedef struct _MIB_IPMCAST_MFE_STATS {
    DWORD   dwGroup;
    DWORD   dwSource;
    DWORD   dwSrcMask;
    DWORD   dwUpStrmNgbr;
    DWORD   dwInIfIndex;
    DWORD   dwInIfProtocol;
    DWORD   dwRouteProtocol;
    DWORD   dwRouteNetwork;
    DWORD   dwRouteMask;
    ULONG   ulUpTime;
    ULONG   ulExpiryTime;
    ULONG   ulNumOutIf;
    ULONG   ulInPkts;
    ULONG   ulInOctets;
    ULONG   ulPktsDifferentIf;
    ULONG   ulQueueOverflow;

    MIB_IPMCAST_OIF_STATS   rgmiosOutStats[ANY_SIZE];
} MIB_IPMCAST_MFE_STATS, *PMIB_IPMCAST_MFE_STATS;

typedef struct _MIB_MFE_STATS_TABLE {
    DWORD       dwNumEntries;
    MIB_IPMCAST_MFE_STATS   table[ANY_SIZE];
} MIB_MFE_STATS_TABLE, *PMIB_MFE_STATS_TABLE;

#define SIZEOF_BASIC_MIB_MFE_STATS    \
    (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE_STATS, rgmiosOutStats[0]))

#define SIZEOF_MIB_MFE_STATS(X)       \
    (SIZEOF_BASIC_MIB_MFE_STATS + ((X) * sizeof(MIB_IPMCAST_OIF_STATS)))


typedef struct _MIB_IPMCAST_MFE_STATS_EX_XP {
    DWORD   dwGroup;
    DWORD   dwSource;
    DWORD   dwSrcMask;
    DWORD   dwUpStrmNgbr;
    DWORD   dwInIfIndex;
    DWORD   dwInIfProtocol;
    DWORD   dwRouteProtocol;
    DWORD   dwRouteNetwork;
    DWORD   dwRouteMask;
    ULONG   ulUpTime;
    ULONG   ulExpiryTime;
    ULONG   ulNumOutIf;
    ULONG   ulInPkts;
    ULONG   ulInOctets;
    ULONG   ulPktsDifferentIf;
    ULONG   ulQueueOverflow;
    ULONG   ulUninitMfe;
    ULONG   ulNegativeMfe;
    ULONG   ulInDiscards;
    ULONG   ulInHdrErrors;
    ULONG   ulTotalOutPackets;

    MIB_IPMCAST_OIF_STATS   rgmiosOutStats[ANY_SIZE];
} MIB_IPMCAST_MFE_STATS_EX_XP,
 *PMIB_IPMCAST_MFE_STATS_EX_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef MIB_IPMCAST_MFE_STATS_EX_XP MIB_IPMCAST_MFE_STATS_EX;
typedef MIB_IPMCAST_MFE_STATS_EX_XP *PMIB_IPMCAST_MFE_STATS_EX;
#endif

typedef struct _MIB_MFE_STATS_TABLE_EX_XP {
    DWORD       dwNumEntries;
    PMIB_IPMCAST_MFE_STATS_EX_XP   table[ANY_SIZE];
} MIB_MFE_STATS_TABLE_EX_XP, *PMIB_MFE_STATS_TABLE_EX_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef MIB_MFE_STATS_TABLE_EX_XP MIB_MFE_STATS_TABLE_EX;
typedef MIB_MFE_STATS_TABLE_EX_XP *PMIB_MFE_STATS_TABLE_EX;

#define SIZEOF_BASIC_MIB_MFE_STATS_EX    \
    (ULONG)(FIELD_OFFSET(MIB_IPMCAST_MFE_STATS_EX, rgmiosOutStats[0]))

#define SIZEOF_MIB_MFE_STATS_EX(X)       \
    (SIZEOF_BASIC_MIB_MFE_STATS_EX + ((X) * sizeof(MIB_IPMCAST_OIF_STATS)))
#endif

typedef struct _MIB_IPMCAST_GLOBAL {
    DWORD   dwEnable;
} MIB_IPMCAST_GLOBAL, *PMIB_IPMCAST_GLOBAL;

typedef struct _MIB_IPMCAST_IF_ENTRY {
    DWORD   dwIfIndex;
    DWORD   dwTtl;
    DWORD   dwProtocol;
    DWORD   dwRateLimit;
    ULONG   ulInMcastOctets;
    ULONG   ulOutMcastOctets;
} MIB_IPMCAST_IF_ENTRY, *PMIB_IPMCAST_IF_ENTRY;

typedef struct _MIB_IPMCAST_IF_TABLE {
    DWORD       dwNumEntries;
    MIB_IPMCAST_IF_ENTRY   table[ANY_SIZE];
} MIB_IPMCAST_IF_TABLE, *PMIB_IPMCAST_IF_TABLE;

#define SIZEOF_MCAST_IF_TABLE(X) \
    (FIELD_OFFSET(MIB_IPMCAST_IF_TABLE, table[0]) +  \
     ((X) * sizeof(MIB_IPMCAST_IF_ENTRY)) +  \
     ALIGN_SIZE)

#endif // _IPMIB_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ipinfoid.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ipinfoid.h

Abstract:
    Defines the IDs needed for specifying various types of information
    to the router manager. Protocols use their ProtocolId for tagging
    information

--*/

#ifndef __ROUTING_IPINFOID_H__
#define __ROUTING_IPINFOID_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define IP_ROUTER_MANAGER_VERSION 1

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// These are the ids used for different information types supported by      //
// IP Router Manager. These ids live in the same space as the IP Routing    //
// Protocol IDs, so any addition to them must be done with care             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define IP_GENERAL_INFO_BASE            0xffff0000

#define IP_IN_FILTER_INFO               IP_GENERAL_INFO_BASE + 1
#define IP_OUT_FILTER_INFO              IP_GENERAL_INFO_BASE + 2
#define IP_GLOBAL_INFO                  IP_GENERAL_INFO_BASE + 3
#define IP_INTERFACE_STATUS_INFO        IP_GENERAL_INFO_BASE + 4
#define IP_ROUTE_INFO                   IP_GENERAL_INFO_BASE + 5
#define IP_PROT_PRIORITY_INFO           IP_GENERAL_INFO_BASE + 6
#define IP_ROUTER_DISC_INFO             IP_GENERAL_INFO_BASE + 7
// N.B. Unused ID available at IP_GENERAL_INFO_BASE + 8.
#define IP_DEMAND_DIAL_FILTER_INFO      IP_GENERAL_INFO_BASE + 9
#define IP_MCAST_HEARBEAT_INFO          IP_GENERAL_INFO_BASE + 10
#define IP_MCAST_BOUNDARY_INFO          IP_GENERAL_INFO_BASE + 11
#define IP_IPINIP_CFG_INFO              IP_GENERAL_INFO_BASE + 12
#define IP_IFFILTER_INFO                IP_GENERAL_INFO_BASE + 13
#define IP_MCAST_LIMIT_INFO             IP_GENERAL_INFO_BASE + 14
#define IPV6_GLOBAL_INFO                IP_GENERAL_INFO_BASE + 15
#define IPV6_ROUTE_INFO  		IP_GENERAL_INFO_BASE + 16

#define IP_IN_FILTER_INFO_V6             IP_GENERAL_INFO_BASE + 17
#define IP_OUT_FILTER_INFO_V6            IP_GENERAL_INFO_BASE + 18
#define IP_DEMAND_DIAL_FILTER_INFO_V6    IP_GENERAL_INFO_BASE + 19
#define IP_IFFILTER_INFO_V6		 IP_GENERAL_INFO_BASE + 20

#define IP_FILTER_ENABLE_INFO		IP_GENERAL_INFO_BASE + 21
#define IP_FILTER_ENABLE_INFO_V6	IP_GENERAL_INFO_BASE + 22

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following IDS are defined in routprot.h and given here for           //
// informational purposes only                                              //
//                                                                          //
// #define IP_OTHER         1                                               //
// #define IP_LOCAL         2                                               //
// #define IP_NETMGMT       3                                               //
// #define IP_ICMP          4                                               //
// #define IP_EGP           5                                               //
// #define IP_GGP           6                                               //
// #define IP_HELLO         7                                               //
// #define IP_RIP           8                                               //
// #define IP_IS_IS         9                                               //
// #define IP_ES_IS         10                                              //
// #define IP_CISCO         11                                              //
// #define IP_BBN           12                                              //
// #define IP_OSPF          13                                              //
// #define IP_BGP           14                                              //
//                                                                          //
// #define IP_BOOTP         9999                                            //
// #define IPRTRMGR_PID     10000                                           //
// #define IP_NT_AUTOSTATIC 10002                                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
}
#endif

#endif //__ROUTING_IPINFOID_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Iprtrmib.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    iprtrmib.h

Abstract:
    This file contains:
        o Definitions of the MIB_XX structures passed to and from the IP Router Manager
            to query and set MIB variables handled by the IP Router Manager
        o The #defines for the MIB variables IDs  handled by the IP Router Manager
            and made accessible by the MprAdminMIBXXX APIs
        o The Routing PID of the IP Router Manager (as mentioned in ipinfoid.h)

--*/

#ifndef __ROUTING_IPRTRMIB_H__
#define __ROUTING_IPRTRMIB_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4201)

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Included to get the value of MAX_INTERFACE_NAME_LEN                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <mprapi.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Included to get the necessary constants                                  //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <ipifcons.h>

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// This is the Id for IP Router Manager.  The Router Manager handles        //
// MIB-II, Forwarding MIB and some enterprise specific information.         //
// Calls made with any other ID are passed on to the corresponding protocol //
// For example, an MprAdminMIBXXX call with a protocol ID of PID_IP and    //
// a routing Id of 0xD will be sent to the IP Router Manager and then       //
// forwarded to OSPF                                                        //
// This lives in the same number space as the protocol Ids of RIP, OSPF     //
// etc, so any change made to it should be done keeping this in mind        //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IPRTRMGR_PID 10000

#ifndef ANY_SIZE

#define ANY_SIZE 1

#endif

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following #defines are the Ids of the MIB variables made accessible  //
// to the user via MprAdminMIBXXX Apis.  It will be noticed that these are  //
// not the same as RFC 1213, since the MprAdminMIBXXX APIs work on rows and //
// groups instead of scalar variables                                       //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


#define IF_NUMBER           0
#define IF_TABLE            (IF_NUMBER          + 1)
#define IF_ROW              (IF_TABLE           + 1)
#define IP_STATS            (IF_ROW             + 1)
#define IP_ADDRTABLE        (IP_STATS           + 1)
#define IP_ADDRROW          (IP_ADDRTABLE       + 1)
#define IP_FORWARDNUMBER    (IP_ADDRROW         + 1)
#define IP_FORWARDTABLE     (IP_FORWARDNUMBER   + 1)
#define IP_FORWARDROW       (IP_FORWARDTABLE    + 1)
#define IP_NETTABLE         (IP_FORWARDROW      + 1)
#define IP_NETROW           (IP_NETTABLE        + 1)
#define ICMP_STATS          (IP_NETROW          + 1)
#define TCP_STATS           (ICMP_STATS         + 1)
#define TCP_TABLE           (TCP_STATS          + 1)
#define TCP_ROW             (TCP_TABLE          + 1)
#define UDP_STATS           (TCP_ROW            + 1)
#define UDP_TABLE           (UDP_STATS          + 1)
#define UDP_ROW             (UDP_TABLE          + 1)
#define MCAST_MFE           (UDP_ROW            + 1)
#define MCAST_MFE_STATS     (MCAST_MFE          + 1)
#define BEST_IF             (MCAST_MFE_STATS    + 1)
#define BEST_ROUTE          (BEST_IF            + 1)
#define PROXY_ARP           (BEST_ROUTE         + 1)
#define MCAST_IF_ENTRY      (PROXY_ARP          + 1)
#define MCAST_GLOBAL        (MCAST_IF_ENTRY     + 1)
#define IF_STATUS           (MCAST_GLOBAL       + 1)
#define MCAST_BOUNDARY      (IF_STATUS          + 1)
#define MCAST_SCOPE         (MCAST_BOUNDARY     + 1)
#define DEST_MATCHING       (MCAST_SCOPE        + 1)
#define DEST_LONGER         (DEST_MATCHING      + 1)
#define DEST_SHORTER        (DEST_LONGER        + 1)
#define ROUTE_MATCHING      (DEST_SHORTER       + 1)
#define ROUTE_LONGER        (ROUTE_MATCHING     + 1)
#define ROUTE_SHORTER       (ROUTE_LONGER       + 1)
#define ROUTE_STATE         (ROUTE_SHORTER      + 1)
#define MCAST_MFE_STATS_EX  (ROUTE_STATE        + 1)
#define IP6_STATS           (MCAST_MFE_STATS_EX + 1)
#define UDP6_STATS          (IP6_STATS          + 1)
#define TCP6_STATS          (UDP6_STATS         + 1)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define NUMBER_OF_EXPORTED_VARIABLES    (TCP6_STATS + 1)
#else
#define NUMBER_OF_EXPORTED_VARIABLES    (ROUTE_STATE + 1)
#endif


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// MIB_OPAQUE_QUERY is the structure filled in by the user to identify a    //
// MIB variable                                                             //
//                                                                          //
//  dwVarId     ID of MIB Variable (One of the Ids #defined above)          //
//  dwVarIndex  Variable sized array containing the indices needed to       //
//              identify a variable. NOTE: Unlike SNMP we dont require that //
//              a scalar variable be indexed by 0                           //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

typedef struct _MIB_OPAQUE_QUERY
{
    DWORD  dwVarId;
    DWORD  rgdwVarIndex[ANY_SIZE];
}MIB_OPAQUE_QUERY, *PMIB_OPAQUE_QUERY;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// The following are the structures which are filled in and returned to the //
// user when a query is made, OR  are filled in BY THE USER when a set is   //
// done                                                                     //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#include <ipmib.h>
#include <tcpmib.h>
#include <udpmib.h>

typedef enum _TCP_TABLE_CLASS {
    TCP_TABLE_BASIC_LISTENER,
    TCP_TABLE_BASIC_CONNECTIONS,
    TCP_TABLE_BASIC_ALL,
    TCP_TABLE_OWNER_PID_LISTENER,
    TCP_TABLE_OWNER_PID_CONNECTIONS,
    TCP_TABLE_OWNER_PID_ALL,
    TCP_TABLE_OWNER_MODULE_LISTENER,
    TCP_TABLE_OWNER_MODULE_CONNECTIONS,
    TCP_TABLE_OWNER_MODULE_ALL
} TCP_TABLE_CLASS, *PTCP_TABLE_CLASS;

typedef enum _UDP_TABLE_CLASS {
    UDP_TABLE_BASIC,
    UDP_TABLE_OWNER_PID,
    UDP_TABLE_OWNER_MODULE
} UDP_TABLE_CLASS, *PUDP_TABLE_CLASS;

typedef enum _TCPIP_OWNER_MODULE_INFO_CLASS {
    TCPIP_OWNER_MODULE_INFO_BASIC
} TCPIP_OWNER_MODULE_INFO_CLASS, *PTCPIP_OWNER_MODULE_INFO_CLASS;

typedef struct _TCPIP_OWNER_MODULE_BASIC_INFO {
    PWCHAR pModuleName;
    PWCHAR pModulePath;
} TCPIP_OWNER_MODULE_BASIC_INFO, *PTCPIP_OWNER_MODULE_BASIC_INFO;

typedef struct _MIB_IPMCAST_BOUNDARY
{
    DWORD   dwIfIndex;
    DWORD   dwGroupAddress;
    DWORD   dwGroupMask;
    DWORD   dwStatus;
}MIB_IPMCAST_BOUNDARY, *PMIB_IPMCAST_BOUNDARY;

typedef struct _MIB_IPMCAST_BOUNDARY_TABLE
{
    DWORD       dwNumEntries;
    MIB_IPMCAST_BOUNDARY   table[ANY_SIZE];
}MIB_IPMCAST_BOUNDARY_TABLE, *PMIB_IPMCAST_BOUNDARY_TABLE;

#define SIZEOF_BOUNDARY_TABLE(X) (FIELD_OFFSET(MIB_IPMCAST_BOUNDARY_TABLE,table[0]) + ((X) * sizeof(MIB_IPMCAST_BOUNDARY)) + ALIGN_SIZE)

typedef struct {
    DWORD    dwGroupAddress;
    DWORD    dwGroupMask;
} MIB_BOUNDARYROW, *PMIB_BOUNDARYROW;

// Structure matching what goes in the registry in a block of type
// IP_MCAST_LIMIT_INFO.  This contains the fields of
// MIB_IPMCAST_IF_ENTRY which are configurable.

typedef struct {
    DWORD    dwTtl;
    DWORD    dwRateLimit;
} MIB_MCAST_LIMIT_ROW, *PMIB_MCAST_LIMIT_ROW;

#define MAX_SCOPE_NAME_LEN 255

//
// Scope names are unicode.  SNMP and MZAP use UTF-8 encoding.
//

#define SN_UNICODE
typedef WCHAR   SN_CHAR;
typedef SN_CHAR SCOPE_NAME_BUFFER[MAX_SCOPE_NAME_LEN+1], *SCOPE_NAME;

typedef struct _MIB_IPMCAST_SCOPE
{
    DWORD             dwGroupAddress;
    DWORD             dwGroupMask;
    SCOPE_NAME_BUFFER snNameBuffer;
    DWORD             dwStatus;
}MIB_IPMCAST_SCOPE, *PMIB_IPMCAST_SCOPE;

typedef struct _MIB_IPDESTROW
{
#ifdef __cplusplus
    MIB_IPFORWARDROW  ForwardRow;
#else
    MIB_IPFORWARDROW;
#endif

    DWORD             dwForwardPreference;
    DWORD             dwForwardViewSet;
}MIB_IPDESTROW, *PMIB_IPDESTROW;

typedef struct _MIB_IPDESTTABLE
{
    DWORD             dwNumEntries;
    MIB_IPDESTROW     table[ANY_SIZE];
}MIB_IPDESTTABLE, *PMIB_IPDESTTABLE;

typedef struct _MIB_BEST_IF
{
    DWORD       dwDestAddr;
    DWORD       dwIfIndex;
}MIB_BEST_IF, *PMIB_BEST_IF;

typedef struct _MIB_PROXYARP
{
    DWORD       dwAddress;
    DWORD       dwMask;
    DWORD       dwIfIndex;
}MIB_PROXYARP, *PMIB_PROXYARP;

typedef struct _MIB_IFSTATUS
{
    DWORD       dwIfIndex;
    DWORD       dwAdminStatus;
    DWORD       dwOperationalStatus;
    BOOL        bMHbeatActive;
    BOOL        bMHbeatAlive;
}MIB_IFSTATUS, *PMIB_IFSTATUS;

typedef struct _MIB_ROUTESTATE
{
    BOOL        bRoutesSetToStack;

}MIB_ROUTESTATE, *PMIB_ROUTESTATE;

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// All the info passed to (SET/CREATE) and from (GET/GETNEXT/GETFIRST)      //
// IP Router Manager is encapsulated in the following "discriminated"       //
// union.  To pass, say MIB_IFROW, use the following code                   //
//                                                                          //
//  PMIB_OPAQUE_INFO    pInfo;                                              //
//  PMIB_IFROW          pIfRow;                                             //
//  DWORD rgdwBuff[(MAX_MIB_OFFSET + sizeof(MIB_IFROW))/sizeof(DWORD) + 1]; //
//                                                                          //
//  pInfo   = (PMIB_OPAQUE_INFO)rgdwBuffer;                                 //
//  pIfRow  = (MIB_IFROW *)(pInfo->rgbyData);                               //
//                                                                          //
//  This can also be accomplished by using the following macro              //
//                                                                          //
//  DEFINE_MIB_BUFFER(pInfo,MIB_IFROW, pIfRow);                             //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


typedef struct _MIB_OPAQUE_INFO
{
    DWORD  dwId;

    union
    {
        ULONGLONG   ullAlign;
        BYTE        rgbyData[1];
    };

}MIB_OPAQUE_INFO, *PMIB_OPAQUE_INFO;

#define MAX_MIB_OFFSET      8

#define MIB_INFO_SIZE(S)                \
    (MAX_MIB_OFFSET + sizeof(S))

#define MIB_INFO_SIZE_IN_DWORDS(S)      \
    ((MIB_INFO_SIZE(S))/sizeof(DWORD) + 1)

#define DEFINE_MIB_BUFFER(X,Y,Z)                                        \
    DWORD        __rgdwBuff[MIB_INFO_SIZE_IN_DWORDS(Y)]; \
    PMIB_OPAQUE_INFO    X = (PMIB_OPAQUE_INFO)__rgdwBuff;               \
    Y *                 Z = (Y *)(X->rgbyData)


#define CAST_MIB_INFO(X,Y,Z)    Z = (Y)(X->rgbyData)

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4201)
#endif

#endif //__ROUTING_IPRTRMIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IpxConst.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxconst.h

Abstract:

    This module contains the common constants and macros used
    by the IPX Routing Protocols

Author:

    Stefan Solomon  07/10/1995

Revision History:


--*/

#ifndef _IPXCONST_
#define _IPXCONST_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Administrative States Definitions
//
// Note: these states correspond to the MIB admin states of ENABLED and DISABLED

#define ADMIN_STATE_DISABLED		    1
#define ADMIN_STATE_ENABLED		    2

// additional admin states used for netbios delivery.
//
// Note: these states correspond to the MIB states of:
//
// ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING and
// ENABLED_ONLY_FOR_OPER_STATE_UP

#define ADMIN_STATE_ENABLED_ONLY_FOR_NETBIOS_STATIC_ROUTING	3
#define ADMIN_STATE_ENABLED_ONLY_FOR_OPER_STATE_UP		4

//
// Interface Operational States Definitions
//
// Note 1: applies to the IPX, RIP and SAP operational states
// Note 2: these states correspond to the MIB operational states of
//	   UP, DOWN and SLEEPING
//

#define OPER_STATE_DOWN			   1 // not operational
#define OPER_STATE_UP			   2 // operational & can pass packets
#define OPER_STATE_SLEEPING		   3 // operational but has to connect to pass packets

//
// Additional operational states in starting/stopping the router
//

#define OPER_STATE_STARTING		    4
#define OPER_STATE_STOPPING		    5

//
// Definitions and default values for the RIP and SAP Interface Info
//

// UpdateMode definitions
//

#define IPX_STANDARD_UPDATE		1 // Periodic update, every UpdateInterval
#define IPX_NO_UPDATE			2 // No update, used for static routes config
#define IPX_AUTO_STATIC_UPDATE		3 // AutoStatic triggered update

// PacketType definitions
//

#define IPX_STANDARD_PACKET_TYPE		1
#define IPX_RELIABLE_DELIVERY_PACKET_TYPE	2

// Pace definitions

#define IPX_PACE_DEFVAL 	18 // This corresponds to a 55 ms interpacketgap

// UpdateInterval definitions

#define IPX_UPDATE_INTERVAL_DEFVAL  60

//*********************************************************
//							  *
//		 IPX Route Entry Definitions		  *
//							  *
//*********************************************************

//
// IPX route entry defs for RTM mapping
//

#define   R_Interface		       RR_InterfaceID
#define   R_Protocol		       RR_RoutingProtocol

#define   R_Network		       RR_Network.N_NetNumber
#define   R_TickCount		       RR_FamilySpecificData.FSD_TickCount
#define   R_HopCount		       RR_FamilySpecificData.FSD_HopCount
#define   R_NextHopMacAddress	       RR_NextHopAddress.NHA_Mac

#define   R_Flags		       RR_FamilySpecificData.FSD_Flags

//
// Some particular interface indices values
//

#define MAX_INTERFACE_INDEX		0xFFFFFFFE
#define GLOBAL_INTERFACE_INDEX		0xFFFFFFFF

//
// Flags definitions
//

#define GLOBAL_WAN_ROUTE		0x00000001
#define DO_NOT_ADVERTISE_ROUTE		0x00000002

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IPTypes.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    iptypes.h

--*/

#ifndef IP_TYPES_INCLUDED
#define IP_TYPES_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#pragma warning(push)
#pragma warning(disable:4201)
#pragma warning(disable:4214) // bit field types other than int

#include <time.h>
#include <ifdef.h>
#include <nldef.h>

// Definitions and structures used by getnetworkparams and getadaptersinfo apis

#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arb.
#define MAX_ADAPTER_NAME_LENGTH         256 // arb.
#define MAX_ADAPTER_ADDRESS_LENGTH      8   // arb.
#define DEFAULT_MINIMUM_ENTITIES        32  // arb.
#define MAX_HOSTNAME_LEN                128 // arb.
#define MAX_DOMAIN_NAME_LEN             128 // arb.
#define MAX_SCOPE_ID_LEN                256 // arb.
#define MAX_DHCPV6_DUID_LENGTH          130 // RFC 3315.
#define MAX_DNS_SUFFIX_STRING_LENGTH    256

//
// types
//

// Node Type

#define BROADCAST_NODETYPE              1
#define PEER_TO_PEER_NODETYPE           2
#define MIXED_NODETYPE                  4
#define HYBRID_NODETYPE                 8

//
// IP_ADDRESS_STRING - store an IP address as a dotted decimal string
//

typedef struct {
    char String[4 * 4];
} IP_ADDRESS_STRING, *PIP_ADDRESS_STRING, IP_MASK_STRING, *PIP_MASK_STRING;

//
// IP_ADDR_STRING - store an IP address with its corresponding subnet mask,
// both as dotted decimal strings
//

typedef struct _IP_ADDR_STRING {
    struct _IP_ADDR_STRING* Next;
    IP_ADDRESS_STRING IpAddress;
    IP_MASK_STRING IpMask;
    DWORD Context;
} IP_ADDR_STRING, *PIP_ADDR_STRING;

//
// ADAPTER_INFO - per-adapter information. All IP addresses are stored as
// strings
//

typedef struct _IP_ADAPTER_INFO {
    struct _IP_ADAPTER_INFO* Next;
    DWORD ComboIndex;
    char AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];
    char Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
    UINT AddressLength;
    BYTE Address[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD Index;
    UINT Type;
    UINT DhcpEnabled;
    PIP_ADDR_STRING CurrentIpAddress;
    IP_ADDR_STRING IpAddressList;
    IP_ADDR_STRING GatewayList;
    IP_ADDR_STRING DhcpServer;
    BOOL HaveWins;
    IP_ADDR_STRING PrimaryWinsServer;
    IP_ADDR_STRING SecondaryWinsServer;
    time_t LeaseObtained;
    time_t LeaseExpires;
} IP_ADAPTER_INFO, *PIP_ADAPTER_INFO;

#ifdef _WINSOCK2API_

//
// The following types require Winsock2.
//

typedef NL_PREFIX_ORIGIN IP_PREFIX_ORIGIN;
typedef NL_SUFFIX_ORIGIN IP_SUFFIX_ORIGIN;
typedef NL_DAD_STATE IP_DAD_STATE;

typedef struct _IP_ADAPTER_UNICAST_ADDRESS_LH {
    union {
        ULONGLONG Alignment;
        struct { 
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_UNICAST_ADDRESS_LH *Next;
    SOCKET_ADDRESS Address;

    IP_PREFIX_ORIGIN PrefixOrigin;
    IP_SUFFIX_ORIGIN SuffixOrigin;
    IP_DAD_STATE DadState;

    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    ULONG LeaseLifetime;
    UINT8 OnLinkPrefixLength;
} IP_ADAPTER_UNICAST_ADDRESS_LH,
 *PIP_ADAPTER_UNICAST_ADDRESS_LH;

typedef struct _IP_ADAPTER_UNICAST_ADDRESS_XP {
    union {
        ULONGLONG Alignment;
        struct { 
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_UNICAST_ADDRESS_XP *Next;
    SOCKET_ADDRESS Address;

    IP_PREFIX_ORIGIN PrefixOrigin;
    IP_SUFFIX_ORIGIN SuffixOrigin;
    IP_DAD_STATE DadState;

    ULONG ValidLifetime;
    ULONG PreferredLifetime;
    ULONG LeaseLifetime;
} IP_ADAPTER_UNICAST_ADDRESS_XP, *PIP_ADAPTER_UNICAST_ADDRESS_XP;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef  IP_ADAPTER_UNICAST_ADDRESS_LH IP_ADAPTER_UNICAST_ADDRESS;
typedef  IP_ADAPTER_UNICAST_ADDRESS_LH *PIP_ADAPTER_UNICAST_ADDRESS;
#elif (NTDDI_VERSION >= NTDDI_WINXP)
typedef  IP_ADAPTER_UNICAST_ADDRESS_XP IP_ADAPTER_UNICAST_ADDRESS;
typedef  IP_ADAPTER_UNICAST_ADDRESS_XP *PIP_ADAPTER_UNICAST_ADDRESS;
#endif

//
// Bit values of IP_ADAPTER_UNICAST_ADDRESS Flags field.
//
#define IP_ADAPTER_ADDRESS_DNS_ELIGIBLE 0x01
#define IP_ADAPTER_ADDRESS_TRANSIENT    0x02

typedef struct _IP_ADAPTER_ANYCAST_ADDRESS_XP {
    union {
        ULONGLONG Alignment;
        struct { 
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_ANYCAST_ADDRESS_XP *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_ANYCAST_ADDRESS_XP, *PIP_ADAPTER_ANYCAST_ADDRESS_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef IP_ADAPTER_ANYCAST_ADDRESS_XP IP_ADAPTER_ANYCAST_ADDRESS;
typedef IP_ADAPTER_ANYCAST_ADDRESS_XP *PIP_ADAPTER_ANYCAST_ADDRESS;
#endif

typedef struct _IP_ADAPTER_MULTICAST_ADDRESS_XP {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_MULTICAST_ADDRESS_XP *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_MULTICAST_ADDRESS_XP, *PIP_ADAPTER_MULTICAST_ADDRESS_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef IP_ADAPTER_MULTICAST_ADDRESS_XP IP_ADAPTER_MULTICAST_ADDRESS;
typedef IP_ADAPTER_MULTICAST_ADDRESS_XP *PIP_ADAPTER_MULTICAST_ADDRESS;
#endif

typedef struct _IP_ADAPTER_DNS_SERVER_ADDRESS_XP {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Reserved;
        };
    };
    struct _IP_ADAPTER_DNS_SERVER_ADDRESS_XP *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_DNS_SERVER_ADDRESS_XP, *PIP_ADAPTER_DNS_SERVER_ADDRESS_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef IP_ADAPTER_DNS_SERVER_ADDRESS_XP IP_ADAPTER_DNS_SERVER_ADDRESS;
typedef IP_ADAPTER_DNS_SERVER_ADDRESS_XP *PIP_ADAPTER_DNS_SERVER_ADDRESS;
#endif

typedef struct _IP_ADAPTER_WINS_SERVER_ADDRESS_LH {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Reserved;
        };
    };
    struct _IP_ADAPTER_WINS_SERVER_ADDRESS_LH *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_WINS_SERVER_ADDRESS_LH, *PIP_ADAPTER_WINS_SERVER_ADDRESS_LH;
#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef IP_ADAPTER_WINS_SERVER_ADDRESS_LH IP_ADAPTER_WINS_SERVER_ADDRESS;
typedef IP_ADAPTER_WINS_SERVER_ADDRESS_LH *PIP_ADAPTER_WINS_SERVER_ADDRESS;
#endif


typedef struct _IP_ADAPTER_GATEWAY_ADDRESS_LH {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Reserved;
        };
    };
    struct _IP_ADAPTER_GATEWAY_ADDRESS_LH *Next;
    SOCKET_ADDRESS Address;
} IP_ADAPTER_GATEWAY_ADDRESS_LH, *PIP_ADAPTER_GATEWAY_ADDRESS_LH;
#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef IP_ADAPTER_GATEWAY_ADDRESS_LH IP_ADAPTER_GATEWAY_ADDRESS;
typedef IP_ADAPTER_GATEWAY_ADDRESS_LH *PIP_ADAPTER_GATEWAY_ADDRESS;
#endif

typedef struct _IP_ADAPTER_PREFIX_XP {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD Flags;
        };
    };
    struct _IP_ADAPTER_PREFIX_XP *Next;
    SOCKET_ADDRESS Address;
    ULONG PrefixLength;
} IP_ADAPTER_PREFIX_XP, *PIP_ADAPTER_PREFIX_XP;
#if (NTDDI_VERSION >= NTDDI_WINXP)
typedef IP_ADAPTER_PREFIX_XP IP_ADAPTER_PREFIX;
typedef IP_ADAPTER_PREFIX_XP *PIP_ADAPTER_PREFIX;
#endif

typedef struct _IP_ADAPTER_DNS_SUFFIX {
    struct _IP_ADAPTER_DNS_SUFFIX *Next;
    WCHAR String[MAX_DNS_SUFFIX_STRING_LENGTH];
}IP_ADAPTER_DNS_SUFFIX, *PIP_ADAPTER_DNS_SUFFIX;

//
// Bit values of IP_ADAPTER_ADDRESSES Flags field.
//
#define IP_ADAPTER_DDNS_ENABLED               0x00000001
#define IP_ADAPTER_REGISTER_ADAPTER_SUFFIX    0x00000002
#define IP_ADAPTER_DHCP_ENABLED               0x00000004
#define IP_ADAPTER_RECEIVE_ONLY               0x00000008
#define IP_ADAPTER_NO_MULTICAST               0x00000010
#define IP_ADAPTER_IPV6_OTHER_STATEFUL_CONFIG 0x00000020
#define IP_ADAPTER_NETBIOS_OVER_TCPIP_ENABLED 0x00000040
#define IP_ADAPTER_IPV4_ENABLED               0x00000080
#define IP_ADAPTER_IPV6_ENABLED               0x00000100
#define IP_ADAPTER_IPV6_MANAGE_ADDRESS_CONFIG 0x00000200

typedef struct _IP_ADAPTER_ADDRESSES_LH {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            IF_INDEX IfIndex;
        };
    };
    struct _IP_ADAPTER_ADDRESSES_LH *Next;
    PCHAR AdapterName;
    PIP_ADAPTER_UNICAST_ADDRESS_LH FirstUnicastAddress;
    PIP_ADAPTER_ANYCAST_ADDRESS_XP FirstAnycastAddress;
    PIP_ADAPTER_MULTICAST_ADDRESS_XP FirstMulticastAddress;
    PIP_ADAPTER_DNS_SERVER_ADDRESS_XP FirstDnsServerAddress;
    PWCHAR DnsSuffix;
    PWCHAR Description;
    PWCHAR FriendlyName;
    BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];
    ULONG PhysicalAddressLength;
    union {
        ULONG Flags;
        struct {
            ULONG DdnsEnabled : 1;
            ULONG RegisterAdapterSuffix : 1;
            ULONG Dhcpv4Enabled : 1;
            ULONG ReceiveOnly : 1;
            ULONG NoMulticast : 1;
            ULONG Ipv6OtherStatefulConfig : 1;
            ULONG NetbiosOverTcpipEnabled : 1;
            ULONG Ipv4Enabled : 1;
            ULONG Ipv6Enabled : 1;
            ULONG Ipv6ManagedAddressConfigurationSupported : 1;
        };
    };
    ULONG Mtu;
    IFTYPE IfType;
    IF_OPER_STATUS OperStatus;
    IF_INDEX Ipv6IfIndex;
    ULONG ZoneIndices[16];
    PIP_ADAPTER_PREFIX_XP FirstPrefix;

    ULONG64 TransmitLinkSpeed;
    ULONG64 ReceiveLinkSpeed;
    PIP_ADAPTER_WINS_SERVER_ADDRESS_LH FirstWinsServerAddress;
    PIP_ADAPTER_GATEWAY_ADDRESS_LH FirstGatewayAddress;
    ULONG Ipv4Metric;
    ULONG Ipv6Metric;
    IF_LUID Luid;
    SOCKET_ADDRESS Dhcpv4Server;
    NET_IF_COMPARTMENT_ID CompartmentId;
    NET_IF_NETWORK_GUID NetworkGuid;
    NET_IF_CONNECTION_TYPE ConnectionType;    
    TUNNEL_TYPE TunnelType;
    //
    // DHCP v6 Info.
    //
    SOCKET_ADDRESS Dhcpv6Server;
    BYTE Dhcpv6ClientDuid[MAX_DHCPV6_DUID_LENGTH];
    ULONG Dhcpv6ClientDuidLength;
    ULONG Dhcpv6Iaid;
#if (NTDDI_VERSION >= NTDDI_VISTASP1)
    PIP_ADAPTER_DNS_SUFFIX FirstDnsSuffix;
#endif
} IP_ADAPTER_ADDRESSES_LH, 
 *PIP_ADAPTER_ADDRESSES_LH;

typedef struct _IP_ADAPTER_ADDRESSES_XP {
    union {
        ULONGLONG Alignment;
        struct {
            ULONG Length;
            DWORD IfIndex;
        };
    };
    struct _IP_ADAPTER_ADDRESSES_XP *Next;
    PCHAR AdapterName;
    PIP_ADAPTER_UNICAST_ADDRESS_XP FirstUnicastAddress;
    PIP_ADAPTER_ANYCAST_ADDRESS_XP FirstAnycastAddress;
    PIP_ADAPTER_MULTICAST_ADDRESS_XP FirstMulticastAddress;
    PIP_ADAPTER_DNS_SERVER_ADDRESS_XP FirstDnsServerAddress;
    PWCHAR DnsSuffix;
    PWCHAR Description;
    PWCHAR FriendlyName;
    BYTE PhysicalAddress[MAX_ADAPTER_ADDRESS_LENGTH];
    DWORD PhysicalAddressLength;
    DWORD Flags;
    DWORD Mtu;
    DWORD IfType;
    IF_OPER_STATUS OperStatus;
    DWORD Ipv6IfIndex;
    DWORD ZoneIndices[16];
    PIP_ADAPTER_PREFIX_XP FirstPrefix;
} IP_ADAPTER_ADDRESSES_XP,
 *PIP_ADAPTER_ADDRESSES_XP;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef  IP_ADAPTER_ADDRESSES_LH IP_ADAPTER_ADDRESSES;
typedef  IP_ADAPTER_ADDRESSES_LH *PIP_ADAPTER_ADDRESSES;
#elif (NTDDI_VERSION >= NTDDI_WINXP)
typedef  IP_ADAPTER_ADDRESSES_XP IP_ADAPTER_ADDRESSES;
typedef  IP_ADAPTER_ADDRESSES_XP *PIP_ADAPTER_ADDRESSES;
#else
//
// For platforms other platforms that are including
// the file but not using the types.
//
typedef  IP_ADAPTER_ADDRESSES_XP IP_ADAPTER_ADDRESSES;
typedef  IP_ADAPTER_ADDRESSES_XP *PIP_ADAPTER_ADDRESSES;
#endif


//
// Flags used as argument to GetAdaptersAddresses().
// "SKIP" flags are added when the default is to include the information.
// "INCLUDE" flags are added when the default is to skip the information.
//
#define GAA_FLAG_SKIP_UNICAST                   0x0001
#define GAA_FLAG_SKIP_ANYCAST                   0x0002
#define GAA_FLAG_SKIP_MULTICAST                 0x0004
#define GAA_FLAG_SKIP_DNS_SERVER                0x0008
#define GAA_FLAG_INCLUDE_PREFIX                 0x0010
#define GAA_FLAG_SKIP_FRIENDLY_NAME             0x0020
#define GAA_FLAG_INCLUDE_WINS_INFO              0x0040
#define GAA_FLAG_INCLUDE_GATEWAYS               0x0080
#define GAA_FLAG_INCLUDE_ALL_INTERFACES         0x0100
#define GAA_FLAG_INCLUDE_ALL_COMPARTMENTS       0x0200
#define GAA_FLAG_INCLUDE_TUNNEL_BINDINGORDER    0x0400

#endif /* _WINSOCK2API_ */

//
// IP_PER_ADAPTER_INFO - per-adapter IP information such as DNS server list.
//

typedef struct _IP_PER_ADAPTER_INFO_W2KSP1 {
    UINT AutoconfigEnabled;
    UINT AutoconfigActive;
    PIP_ADDR_STRING CurrentDnsServer;
    IP_ADDR_STRING DnsServerList;
} IP_PER_ADAPTER_INFO_W2KSP1, *PIP_PER_ADAPTER_INFO_W2KSP1;
#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
typedef  IP_PER_ADAPTER_INFO_W2KSP1 IP_PER_ADAPTER_INFO;
typedef  IP_PER_ADAPTER_INFO_W2KSP1 *PIP_PER_ADAPTER_INFO;
#endif


//
// FIXED_INFO - the set of IP-related information which does not depend on DHCP
//

typedef struct {
    char HostName[MAX_HOSTNAME_LEN + 4] ;
    char DomainName[MAX_DOMAIN_NAME_LEN + 4];
    PIP_ADDR_STRING CurrentDnsServer;
    IP_ADDR_STRING DnsServerList;
    UINT NodeType;
    char ScopeId[MAX_SCOPE_ID_LEN + 4];
    UINT EnableRouting;
    UINT EnableProxy;
    UINT EnableDns;
} FIXED_INFO_W2KSP1, *PFIXED_INFO_W2KSP1;
#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
typedef  FIXED_INFO_W2KSP1 FIXED_INFO;
typedef  FIXED_INFO_W2KSP1 *PFIXED_INFO;
#endif


#ifndef IP_INTERFACE_NAME_INFO_DEFINED
#define IP_INTERFACE_NAME_INFO_DEFINED

typedef struct ip_interface_name_info_w2ksp1 {
    ULONG           Index;      // Interface Index
    ULONG           MediaType;  // Interface Types - see ipifcons.h
    UCHAR           ConnectionType;
    UCHAR           AccessType;
    GUID            DeviceGuid; // Device GUID is the guid of the device
                                // that IP exposes
    GUID            InterfaceGuid; // Interface GUID, if not GUID_NULL is the
                                // GUID for the interface mapped to the device.
} IP_INTERFACE_NAME_INFO_W2KSP1, *PIP_INTERFACE_NAME_INFO_W2KSP1;

#if (NTDDI_VERSION >= NTDDI_WIN2KSP1)
typedef IP_INTERFACE_NAME_INFO_W2KSP1 IP_INTERFACE_NAME_INFO;
typedef IP_INTERFACE_NAME_INFO_W2KSP1 *PIP_INTERFACE_NAME_INFO;
#endif

#endif

#pragma warning(pop)

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ipxrip.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxrip.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    rip MIB management APIs structures

Author:

    Stefan Solomon  06/30/1995

Revision History:


--*/

#ifndef _IPXRIP_
#define _IPXRIP_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>

typedef struct _RIP_GLOBAL_INFO {
    DWORD       EventLogMask;
} RIP_GLOBAL_INFO, *PRIP_GLOBAL_INFO;

//********************************************************************
//								     *
//		    RIP Configuration Information		     *
//								     *
//********************************************************************


//*** RIP Interface Only Information ***

typedef struct _RIP_IF_INFO {

    ULONG	    AdminState;  // The desired state of the interface
    ULONG	    UpdateMode;	// RIP update mechanism used on this interface
    ULONG	    PacketType;  // The RIP packet type used on this interface
    ULONG	    Supply; // Send RIP updates on this interface
    ULONG	    Listen; // Listen to RIP updates on this interface
    ULONG	    PeriodicUpdateInterval; // in seconds - default 60
    ULONG	    AgeIntervalMultiplier; // default - 3

    } RIP_IF_INFO, *PRIP_IF_INFO;

// UpdateMode Values:
//
// This parameter controls the RIP	database update on this interface.
//
// If this is a LAN interface, use IPX_PERIODIC_UPDATE as default.
// If this is a WAN router interface with static routes, use IPX_NO_UPDATE as default.
// If you want to trigger an update on this interface and to keep the data
// as static data, use IPX_AUTO_STATIC value.
// IPX_AUTO_STATIC update can be set only on a WAN interface
//
// PacketType Default Values:
//
// If UpdateMode is set to IPX_NO_UPDATE, this field is meaningless.
// If this is a LAN interface, use IPX_STANDARD_PACKET_TYPE as default.
// If you want reliable delivery of the update data in a triggered update,
// use IPX_RELIABLE_DELIVERY_PACKET_TYPE (this can be set only in combination with
// IPX_AUTO_STATIC_UPDATE in the UpdateMode).

// RIP Route Filter Info
//
// These filters apply to routes accepted or advertised by RIP on each interface.

typedef struct _RIP_ROUTE_FILTER_INFO {

    UCHAR	    Network[4];
    UCHAR	    Mask[4];

    } RIP_ROUTE_FILTER_INFO, *PRIP_ROUTE_FILTER_INFO;

//*** RIP Filters Only Information ***
//
//  This header is followed by RIP_ROUTE_FILTER_STRUCTURES in order:
//  First Supply filters
//  Next Listen filters

typedef struct _RIP_IF_FILTERS {

    ULONG		    SupplyFilterAction;
    ULONG		    SupplyFilterCount;
    ULONG		    ListenFilterAction;
    ULONG		    ListenFilterCount;
    RIP_ROUTE_FILTER_INFO   RouteFilter[1];

    } RIP_IF_FILTERS, *PRIP_IF_FILTERS;

// FilterAction -

#define IPX_ROUTE_FILTER_PERMIT	    1
#define IPX_ROUTE_FILTER_DENY	    2

//
//*** RIP Interface Configuration Information ***
//
// This structure is passed in AddInterface and SetInterface Entry Points
//

typedef struct _RIP_IF_CONFIG {

    RIP_IF_INFO     RipIfInfo;
    RIP_IF_FILTERS  RipIfFilters;

    } RIP_IF_CONFIG, *PRIP_IF_CONFIG;

// ***********************************************************
// ***							   ***
// ***		RIP MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define RIP_BASE_ENTRY			    0
#define RIP_INTERFACE_TABLE		    1

//************************************************************
//							     *
//		RIP MIB Basic Structures		     *
//							     *
//************************************************************

//
// RIP MIB Base Entry
//

typedef struct _RIPMIB_BASE {

    ULONG	    RIPOperState;

    } RIPMIB_BASE, *PRIPMIB_BASE;


//
// RIP MIB Interface Table Entry
//

typedef struct _RIP_IF_STATS {

    ULONG		    RipIfOperState;   // up, down or sleeping
    ULONG		    RipIfInputPackets;
    ULONG		    RipIfOutputPackets;

    } RIP_IF_STATS, *PRIP_IF_STATS;



typedef struct _RIP_INTERFACE {

    ULONG	    InterfaceIndex;
    RIP_IF_INFO	    RipIfInfo;
    RIP_IF_STATS    RipIfStats;

    } RIP_INTERFACE, *PRIP_INTERFACE;

//***************************************************************
//								*
//	     INPUT DATA For: Get, GetFirst, GetNext		*
//								*
//***************************************************************

typedef struct _RIP_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    ULONG		InterfaceIndex;

    } RIP_MIB_GET_INPUT_DATA, *PRIP_MIB_GET_INPUT_DATA;

//***************************************************************
//								*
//	     INPUT DATA For: Create, Delete, Set		*
//								*
//***************************************************************

typedef struct _RIP_MIB_SET_INPUT_DATA {

    ULONG		 TableId;
    RIP_INTERFACE	 RipInterface;

    } RIP_MIB_SET_INPUT_DATA, *PRIP_MIB_SET_INPUT_DATA;

//
// ***			RIP Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: RIP_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA: RIP_INTERFACE

//
// ***			RIP Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: RIP_MIB_GET_INPUT_DATA for Get, GetFirst and GetNext
//	       RIP_MIB_SET_INPUT_DATA for Set

//
// OUTPUT DATA: RIP_INTERFACE
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ipxtfflt.h ===
/*
Copyright (c) 1995-1999 Microsoft Corporation
    File  ipxfltdf.h

    Defines structures used with the ipx filter driver.
*/

#ifndef __ipxfltdf_h
#define __ipxfltdf_h

#if _MSC_VER > 1000
#pragma once
#endif

//*** IPX Traffic Filters ***
typedef struct _IPX_TRAFFIC_FILTER_GLOBAL_INFO {
	ULONG	FilterAction;	// Action if there is a match with
					// any filter on the interface
} IPX_TRAFFIC_FILTER_GLOBAL_INFO, *PIPX_TRAFFIC_FILTER_GLOBAL_INFO;

// FilterAction

#define IPX_TRAFFIC_FILTER_ACTION_PERMIT	1
#define IPX_TRAFFIC_FILTER_ACTION_DENY	    2

// general traffic filter info structure

typedef struct _IPX_TRAFFIC_FILTER_INFO {

    ULONG	FilterDefinition;
    UCHAR	DestinationNetwork[4];
    UCHAR	DestinationNetworkMask[4];
    UCHAR	DestinationNode[6];
    UCHAR	DestinationSocket[2];
    UCHAR	SourceNetwork[4];
    UCHAR	SourceNetworkMask[4];
    UCHAR	SourceNode[6];
    UCHAR	SourceSocket[2];
	UCHAR	PacketType;
    } IPX_TRAFFIC_FILTER_INFO, *PIPX_TRAFFIC_FILTER_INFO;

// FilterDefinition - Flags to specify relevant IPX address fields to filter on
#define IPX_TRAFFIC_FILTER_ON_SRCNET	0x00000001
#define IPX_TRAFFIC_FILTER_ON_SRCNODE	0x00000002
#define IPX_TRAFFIC_FILTER_ON_SRCSOCKET	0x00000004

#define IPX_TRAFFIC_FILTER_ON_DSTNET	0x00000010
#define IPX_TRAFFIC_FILTER_ON_DSTNODE	0x00000020
#define IPX_TRAFFIC_FILTER_ON_DSTSOCKET	0x00000040

#define IPX_TRAFFIC_FILTER_ON_PKTTYPE	0x00000100
#define IPX_TRAFFIC_FILTER_LOG_MATCHES	0x80000000

typedef struct _FLT_IF_SET_PARAMS {
	ULONG			InterfaceIndex;	// Index of the interface
	ULONG			FilterAction;	// Filter action
	ULONG			FilterSize;	// sizeof (IPX_TRAFFIC_FILTER_INFO)
} FLT_IF_SET_PARAMS, *PFLT_IF_SET_PARAMS;

typedef struct _FLT_IF_GET_PARAMS {
	ULONG			FilterAction;	// Filter action
	ULONG			FilterSize;	// sizeof (IPX_TRAFFIC_FILTER_INFO)
	ULONG			TotalSize;	// Total size of filter description
						// array
} FLT_IF_GET_PARAMS, *PFLT_IF_GET_PARAMS;

typedef struct _FLT_PACKET_LOG {
	ULONG			SrcIfIdx;	// Index of source if (-1 - unknown)
	ULONG			DstIfIdx;	// Index of dest if (-1 - unknown)
	USHORT			DataSize;	// Total size of the data (at least 30)
	USHORT			SeqNum;		// Sequence number to account for
						// packets lost to lack of buffer space
	UCHAR			Header[30];	// IPX packet header followed by the
						// data if any
} FLT_PACKET_LOG, *PFLT_PACKET_LOG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ipxrtdef.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxrtdef.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    ipx global router management APIs structures
    ipx router MIB management APIs structures

Author:

    Stefan Solomon  03/03/1995

Revision History:


--*/

#ifndef _IPXRTDEF_
#define _IPXRTDEF_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>
#include <ipxsap.h>
#include <ipxrip.h>
#include <stm.h>
#include <ipxtfflt.h>

//****************************************************************
//***							       ***
//***			Global Definitions		       ***
//***							       ***
//****************************************************************

//
//  Version of this router
//

#define IPX_ROUTER_VERSION_1		    RTR_INFO_BLOCK_VERSION

//
//  IPX Protocols
//

#define IPX_PROTOCOL_LOCAL		    1
#define IPX_PROTOCOL_STATIC		    2

//
// Interface Type Definitions for MIB reporting - these are mapped from the
// DDM interface type
//

#define IF_TYPE_OTHER				1
#define IF_TYPE_LAN				2
#define IF_TYPE_WAN_ROUTER			3
#define IF_TYPE_WAN_WORKSTATION			4  // remote workstation dialing in
#define IF_TYPE_INTERNAL			5  // the internal (virtual) interface
#define IF_TYPE_PERSONAL_WAN_ROUTER		6
#define IF_TYPE_ROUTER_WORKSTATION_DIALOUT	7  // local workstation dialing out
#define IF_TYPE_STANDALONE_WORKSTATION_DIALOUT	8

//
// Definitions for Table of Contents Entries Info Types
//

#define IPX_INTERFACE_INFO_TYPE			1
#define IPX_STATIC_ROUTE_INFO_TYPE		2
#define IPX_STATIC_SERVICE_INFO_TYPE		3
#define IPX_SERVICE_FILTER_INFO_TYPE		4
#define IPX_ROUTE_FILTER_INFO_TYPE		5
#define IPX_IN_TRAFFIC_FILTER_INFO_TYPE		6
#define IPX_ADAPTER_INFO_TYPE			7
#define IPXWAN_INTERFACE_INFO_TYPE		8
#define IPX_GLOBAL_INFO_TYPE			9
#define IPX_STATIC_NETBIOS_NAME_INFO_TYPE	10
#define IPX_IN_TRAFFIC_FILTER_GLOBAL_INFO_TYPE	11
#define IPX_OUT_TRAFFIC_FILTER_INFO_TYPE		12
#define IPX_OUT_TRAFFIC_FILTER_GLOBAL_INFO_TYPE	13

//****************************************************************
//***							       ***
//***	Specific Info Structures In The Information Block      ***
//***							       ***
//****************************************************************

//*** IPX Router Manager Global Info ***

#define     IPX_SMALL_ROUTING_TABLE_HASH_SIZE	    31
#define     IPX_MEDIUM_ROUTING_TABLE_HASH_SIZE	    257
#define     IPX_LARGE_ROUTING_TABLE_HASH_SIZE	    2047

typedef struct _IPX_GLOBAL_INFO {

    ULONG	    RoutingTableHashSize;
    ULONG       EventLogMask;
    } IPX_GLOBAL_INFO, *PIPX_GLOBAL_INFO;


//*** IPX Interface Info ***

typedef struct _IPX_IF_INFO {

    ULONG	    AdminState;        // The desired state of the interface
    ULONG	    NetbiosAccept;     // Accept Netbios broadcast packets
    ULONG	    NetbiosDeliver;    // Deliver Netbios broadcast packets

    } IPX_IF_INFO, *PIPX_IF_INFO;


// Interface Device Type Definitions

#define IPX_DEDICATED_LINK	    1	// includes LAN, leased lines, frame-relay
#define IPX_DIALED_LINK 	    2	// dial on demand links

// Default values:
//
// AdminState: enabled - disabling it disables also RIP, SAP and anything else
// NetbiosAccept: enabled
// NetbiosDeliver: enabled on LAN interface, disabled on WAN interface
// IpxWanNegotiation: disabled.

// The interface name corresponds to the local adapter name in the case the
// interface is the local LAN. If the adapter is multiplexed with different
// packet types, there is a unique net number assigned to each pseudo-adapter.
// In this case the NetNumber is used to differentiate which pseudo-adapter gets
// this interface info.

//*** IPXWAN Interface Info ***

typedef struct _IPXWAN_IF_INFO {

    ULONG	    AdminState;  // Enable/Disable IPXWAN negotiation

    } IPXWAN_IF_INFO, *PIPXWAN_IF_INFO;

//*** Static Route Entry ***

typedef struct _IPX_STATIC_ROUTE_INFO {

    union {

    ULONG	DwordAlign;
    UCHAR	Network[4];  };
    USHORT	TickCount;
    USHORT	HopCount;
    UCHAR	NextHopMacAddress[6];

    } IPX_STATIC_ROUTE_INFO, *PIPX_STATIC_ROUTE_INFO;


//*** Static Service Entry ***

typedef IPX_SERVER_ENTRY IPX_STATIC_SERVICE_INFO, *PIPX_STATIC_SERVICE_INFO;


//*** Static Netbios Name Entry ***

typedef struct	_IPX_STATIC_NETBIOS_NAME_INFO {

    union {

    ULONG	DwordAlign;
    UCHAR	Name[16];     };

    } IPX_STATIC_NETBIOS_NAME_INFO, *PIPX_STATIC_NETBIOS_NAME_INFO;


//
// *** IPX LAN ADAPTER INFO ***
//

#define MAX_ADAPTER_NAME_LEN		    48

typedef struct _IPX_ADAPTER_INFO {

    ULONG	PacketType;
    WCHAR	AdapterName[MAX_ADAPTER_NAME_LEN];

    } IPX_ADAPTER_INFO, *PIPX_ADAPTER_INFO;

#define AUTO_DETECT_PACKET_TYPE 	    0xFFFFFFFF



// ***********************************************************
// ***							   ***
// ***		IPX MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define IPX_BASE_ENTRY			    0
#define IPX_INTERFACE_TABLE		    1
#define IPX_DEST_TABLE			    2	 // IPX Best Routes Table
#define IPX_STATIC_ROUTE_TABLE		    3	 // IPX Static Routes Table
#define IPX_SERV_TABLE			    4	 // IPX Services Table
#define IPX_STATIC_SERV_TABLE		    5	 // IPX Static Services Table

#define MAX_IPX_MIB_TABLES		    6


//
// Some Global MIB Constants
//

// max size of the interface readable name

#define IPX_INTERFACE_ANSI_NAME_LEN	    48

// ***************************************************************************
//
// ***	     IPX MIB APIs Input/Output Structures For Each Table	   ***
//
//****************************************************************************

// Global definition of the MIB Identifier (locates the table and the row index)

typedef struct	_IF_TABLE_INDEX {

    ULONG	InterfaceIndex;

    } IF_TABLE_INDEX, *PIF_TABLE_INDEX;

typedef struct _ROUTING_TABLE_INDEX {

    UCHAR	Network[4];

    } ROUTING_TABLE_INDEX, *PROUTING_TABLE_INDEX;

typedef struct _STATIC_ROUTES_TABLE_INDEX {

    ULONG	InterfaceIndex;
    UCHAR	Network[4];

    } STATIC_ROUTES_TABLE_INDEX, *PSTATIC_ROUTES_TABLE_INDEX;

typedef struct _SERVICES_TABLE_INDEX {

    USHORT	ServiceType;
    UCHAR	ServiceName[48];

    } SERVICES_TABLE_INDEX, *PSERVICES_TABLE_INDEX;

typedef struct _STATIC_SERVICES_TABLE_INDEX {

    ULONG	InterfaceIndex;
    USHORT	ServiceType;
    UCHAR	ServiceName[48];

    } STATIC_SERVICES_TABLE_INDEX, *PSTATIC_SERVICES_TABLE_INDEX;

typedef union _IPX_MIB_INDEX {

    IF_TABLE_INDEX		InterfaceTableIndex;
    ROUTING_TABLE_INDEX		RoutingTableIndex;
    STATIC_ROUTES_TABLE_INDEX	StaticRoutesTableIndex;
    SERVICES_TABLE_INDEX	ServicesTableIndex;
    STATIC_SERVICES_TABLE_INDEX StaticServicesTableIndex;

    } IPX_MIB_INDEX, *PIPX_MIB_INDEX;

//**********************************************************************
//								       *
//	     INPUT DATA For: Get, GetFirst, GetNext		       *
//								       *
//**********************************************************************

typedef struct _IPX_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    IPX_MIB_INDEX	MibIndex;

    } IPX_MIB_GET_INPUT_DATA, *PIPX_MIB_GET_INPUT_DATA;

typedef struct _IPXMIB_BASE {

    ULONG	    OperState;
    UCHAR	    PrimaryNetNumber[4];
    UCHAR	    Node[6];
    UCHAR	    SysName[IPX_INTERFACE_ANSI_NAME_LEN];
    ULONG	    MaxPathSplits;
    ULONG	    IfCount;
    ULONG	    DestCount;
    ULONG	    ServCount;

    } IPXMIB_BASE, *PIPXMIB_BASE;

// structure used to gather interface statistics

typedef struct _IPX_IF_STATS {

	ULONG		IfOperState;
	ULONG		MaxPacketSize;
	ULONG		InHdrErrors;
	ULONG		InFiltered;
	ULONG		InNoRoutes;
	ULONG		InDiscards;
	ULONG		InDelivers;
	ULONG		OutFiltered;
	ULONG		OutDiscards;
	ULONG		OutDelivers;
	ULONG		NetbiosReceived;
	ULONG		NetbiosSent;

	} IPX_IF_STATS, *PIPX_IF_STATS;

// structure describing the MIB Row for the IPX_INTERFACE_TABLE in the
// IPX_INTERFACE_GROUP

typedef struct _IPX_INTERFACE {

    ULONG	    InterfaceIndex;
    ULONG	    AdminState;
    ULONG	    AdapterIndex;
    UCHAR	    InterfaceName[IPX_INTERFACE_ANSI_NAME_LEN];
    ULONG	    InterfaceType;
    ULONG	    MediaType;
    UCHAR	    NetNumber[4];
    UCHAR	    MacAddress[6];
    ULONG	    Delay;
    ULONG	    Throughput;
    ULONG	    NetbiosAccept;
    ULONG	    NetbiosDeliver;
    ULONG	    EnableIpxWanNegotiation;
    IPX_IF_STATS    IfStats;

    } IPX_INTERFACE, *PIPX_INTERFACE;


typedef struct _IPX_ROUTE {

    ULONG	InterfaceIndex; // see ipxconst.h for specific indices definitions
    ULONG	Protocol;
    UCHAR	Network[4];
    USHORT	TickCount;
    USHORT	HopCount;
    UCHAR	NextHopMacAddress[6];
    ULONG	Flags;

    }  IPX_ROUTE, *PIPX_ROUTE;

//
// INPUT DATA For: Create, Delete, Set
//

typedef	union _IPX_MIB_ROW {

	IPX_INTERFACE	 Interface;
	IPX_ROUTE	 Route;
	IPX_SERVICE	 Service;

	} IPX_MIB_ROW, *PIPX_MIB_ROW;


typedef struct _IPX_MIB_SET_INPUT_DATA {

    ULONG		 TableId;
    IPX_MIB_ROW 	 MibRow;

    } IPX_MIB_SET_INPUT_DATA, *PIPX_MIB_SET_INPUT_DATA;

//
// ***			IPX Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: IPX_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA:

//
// ***			IPX Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: IPX_MIB_GET_INPUT_DATA and Index is IF_TABLE_INDEX for Get, GetFirst and GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_INTERFACE for Set

//
// OUTPUT DATA: described by the IPX_INTERFACE structure below
//

//
// ***			IPX Routes Table				   ***
//

// MIB Functions:  Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_INPUT_DATA with Index ROUTES_TABLE_INDEX

// OUTPUT DATA: IPX_ROUTE
//


//
// ***			IPX Static Routes Table				   ***
//

// MIB Functions:  Create, Delete, Get, GetFirst, GetNext, Set

// INPUT DATA: IPX_MIB_GET_INPUT_DATA with Index STATIC_ROUTES_TABLE_INDEX for Get, GetFirst, GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_ROUTE for Create, Delete, Set

// OUTPUT DATA: IPX_ROUTE
//

//
// ***			 IPX Services Table				   ***
//

// MIB Functions: Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_INPUT_DATA with Index SERVICES_TABLE_INDEX

// OUTPUT DATA: The output data is the structure IPX_SERVICE

//
// ***			 IPX Static Services Table			   ***
//

// MIB Functions: Create, Delete, Get, GetFirst, GetNext

// INPUT DATA: IPX_MIB_GET_INPUT_DATA with Index STATIC_SERVICES_TABLE_INDEX for Get, GetFirst, GetNext
//	       IPX_MIB_SET_INPUT_DATA and MibRow is IPX_SERVICE for Create, Delete and Set.

// OUTPUT DATA: IPX_SERVICE

#endif	 // _IPXRTDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\iscsidsc.h ===
//***************************************************************************
//
//  iscsidsc.h
// 
//  Module: Public iScsi Discovery header
//
//  Purpose: 
//
//  Copyright (c) 2002 Microsoft Corporation
//
//***************************************************************************

#ifndef _ISCSI_ISCSIDSC_
#define _ISCSI_ISCSIDSC_

#ifndef MIDL_PASS
#ifndef MOFCOMP_PASS
#include <ntddscsi.h>
#include <winioctl.h>
#endif
#endif

#ifdef __cplusplus
extern "C" {
#endif
    
//
// Maxiumum length of a Initiator Name
//
#define MAX_ISCSI_HBANAME_LEN 256


//
// Maximum length of an iscsi name
//
#define MAX_ISCSI_NAME_LEN  223
#define MAX_ISCSI_ALIAS_LEN  255


//
// Maxiumum length of a portal names
//
#define MAX_ISCSI_PORTAL_NAME_LEN 256
#define MAX_ISCSI_PORTAL_ALIAS_LEN 256

//
// Maximum length of a text address
//
#define MAX_ISCSI_TEXT_ADDRESS_LEN 256

//
// Maxiumum length of a text port address. It can be a DNS name or a .
// name
//
#define MAX_ISCSI_PORTAL_ADDRESS_LEN MAX_ISCSI_TEXT_ADDRESS_LEN

//
// Maximum length of a discovery domain name
//
#define MAX_ISCSI_DISCOVERY_DOMAIN_LEN 256


//
// For apis that take a port number, this specifies that any port can
// be used
//
#define ISCSI_ANY_INITIATOR_PORT         ((ULONG)-1)

//
// For apis that take a port number this specifies that all ports
// should be used
//
#define ISCSI_ALL_INITIATOR_PORTS        ((ULONG)-1)

//
// Maximum length of a RADIUS server address +
// two terminating characters
//
#define MAX_RADIUS_ADDRESS_LEN 41


#ifdef MOFCOMP_PASS
//
// Definitions for iscsi security flags. These flags provide
// information about the security expectations of a target portal and
// are needed to insure a successful IKE/IPSEC negotiation. Note that
// the flags and values are taken directly from the iSNS spec
//
#define ISCSI_SECURITY_FLAGS uint64

    // 1 = Tunnel Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED    "0x00000040"

    // 1 = Transport Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED "0x00000020"
                
    // 1 = PFS Enabled; 0 = PFS Disabled
#define ISCSI_SECURITY_FLAG_PFS_ENABLED              "0x00000010"
                
    // 1 = Aggressive Mode Enabled; 0 = Disabled
#define ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED  "0x00000008"
                
    // 1 = Main Mode Enabled; 0 = MM Disabled
#define ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED        "0x00000004"
                
    // 1 = IKE/IPSec Enabled; 0 = IKE/IPSec Disabled
#define ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED        "0x00000002"

    // If set then all other ISCSI_SECURITY_FLAGS are valid             
#define ISCSI_SECURITY_FLAG_VALID                    "0x00000001"

#define SECURITY_FLAG_QUALIFIERS \
     description("Security flags") : amended, \
     BitMap{ \
            ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED, \
            ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED, \
            ISCSI_SECURITY_FLAG_PFS_ENABLED, \
            ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED, \
            ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED, \
            ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED, \
            ISCSI_SECURITY_FLAG_VALID \
           }, \
     BitValues{ \
            "Tunnel mode preferred", \
            "Transport mode preferred", \
            "PFS Enabled", \
            "Aggressive mode enabled", \
            "Main Mode Enabled", \
            "IKE/IPSec Enabled", \
            "ISCSI_SECURITY_FLAGS are valid" \
              } : amended
                                

#define ISCSI_SECURITY_FLAGS_CPPQUOTE \
"//\n" \
"// Definitions for iscsi security flags. These flags provide\n" \
"// information about the security expectations of a target portal and\n" \
"// are needed to insure a successful IKE/IPSEC negotiation. Note that\n" \
"// the flags and values are taken directly from the iSNS spec\n" \
"//\n" \
"\n" \
"    // 1 = Tunnel Mode Preferred; 0 = No Preference\n" \
"#define ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED    0x00000040\n" \
"\n" \
"    // 1 = Transport Mode Preferred; 0 = No Preference\n" \
"#define ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED 0x00000020\n" \
"               \n" \
"    // 1 = PFS Enabled; 0 = PFS Disabled\n" \
"#define ISCSI_SECURITY_FLAG_PFS_ENABLED              0x00000010\n" \
"               \n" \
"    // 1 = Aggressive Mode Enabled; 0 = Disabled\n" \
"#define ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED  0x00000008\n" \
"               \n" \
"    // 1 = Main Mode Enabled; 0 = MM Disabled\n" \
"#define ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED        0x00000004\n" \
"               \n" \
"    // 1 = IKE/IPSec Enabled; 0 = IKE/IPSec Disabled\n" \
"#define ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED        0x00000002\n" \
"\n" \
"    // If set then all other ISCSI_SECURITY_FLAGS are valid                \n" \
"#define ISCSI_SECURITY_FLAG_VALID                    0x00000001                \n" \
"\n"

//
// definitions for ISCSI_LOGIN_OPTIONS. This structure is used to pass
// information that affects the login negotiation of session
//

#define ISCSI_DIGEST_TYPE_NONE    "0"
#define ISCSI_DIGEST_TYPE_CRC32C  "1"

#define ISCSI_DIGEST_CPPQUOTE \
"#ifndef _ISCSI_ISCSIDSC_\n" \
"typedef enum\n" \
"{\n" \
"   ISCSI_DIGEST_TYPE_NONE = 0,\n" \
"   ISCSI_DIGEST_TYPE_CRC32C = 1\n" \
"} ISCSI_DIGEST_TYPES, *PISCSI_DIGEST_TYPES;\n" \
"\n" \
"typedef enum\n" \
"{\n" \
"   ISCSI_NO_AUTH_TYPE = 0,\n" \
"   ISCSI_CHAP_AUTH_TYPE = 1,\n" \
"   ISCSI_MUTUAL_CHAP_AUTH_TYPE = 2 \n" \
"} ISCSI_AUTH_TYPES, *PISCSI_AUTH_TYPES;\n" \
"#endif\n"   

#define ISCSI_LOGIN_FLAGS_CPPQUOTE \
"//\n" \
"// bit flags for ISCSI_LOGIN_FLAGS\n" \
"//\n" \
"#ifndef _ISCSI_ISCSIDSC_\n" \
"#define ISCSI_LOGIN_FLAGS ULONG\n\n" \
"#define ISCSI_LOGIN_FLAG_REQUIRE_IPSEC                0x00000001\n" \
"#define ISCSI_LOGIN_FLAG_MULTIPATH_ENABLED            0x00000002\n" \
"#define ISCSI_LOGIN_FLAG_RESERVED1                    0x00000004\n" \
"#define ISCSI_LOGIN_FLAG_ALLOW_PORTAL_HOPPING         0x00000008\n" \
"#define ISCSI_LOGIN_FLAG_USE_RADIUS_RESPONSE          0x00000010\n" \
"#define ISCSI_LOGIN_FLAG_USE_RADIUS_VERIFICATION          0x00000020\n" \
"\n" \
"#endif\n"   

#define ISCSI_LOGIN_FLAGS_QUALIFIERS \
    BitValues{"Require IPSEC", "Multipath Enabled", "Reserved1", "Allow Portal Hopping"}, \
    BitMap{ "0x00000001", "0x00000002", "0x00000004", "0x00000008" }

#define ISCSI_LOGIN_FLAGS uint32

#define ISCSI_AUTH_TYPES_QUALIFIERS \
    Values{"No Authentication", \
           "CHAP", \
           "Mutual CHAP" \
          } : amended, \
    ValueMap{"0", "1", "2"}

#define ISCSI_AUTH_TYPES_CPPQUOTE \

#define ISCSI_AUTH_TYPES uint32

//
// Login options flags
//
#define ISCSI_LOGIN_OPTIONS_INFO_SPECIFIED uint32

#define ISCSI_LOGIN_OPTIONS_HEADER_DIGEST               "0x00000001"
#define ISCSI_LOGIN_OPTIONS_DATA_DIGEST                 "0x00000002"
#define ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS         "0x00000004"
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT         "0x00000008"
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN       "0x00000010"
#define ISCSI_LOGIN_OPTIONS_USERNAME                    "0x00000020"
#define ISCSI_LOGIN_OPTIONS_PASSWORD                    "0x00000040"
#define ISCSI_LOGIN_OPTIONS_AUTH_TYPE                   "0x00000080"

#define ISCSI_LOGIN_OPTIONS_INFO_CPPQUOTE \
"//\n" \
"// Bit flags for InformationSpecifies\n" \
"//\n" \
"#define ISCSI_LOGIN_OPTIONS_HEADER_DIGEST               0x00000001\n" \
"#define ISCSI_LOGIN_OPTIONS_DATA_DIGEST                 0x00000002\n" \
"#define ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS         0x00000004\n" \
"#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT         0x00000008\n" \
"#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN       0x00000010\n" \
"#define ISCSI_LOGIN_OPTIONS_USERNAME                    0x00000020\n" \
"#define ISCSI_LOGIN_OPTIONS_PASSWORD                    0x00000040\n" \
"#define ISCSI_LOGIN_OPTIONS_AUTH_TYPE                   0x00000080\n" \
"\n"

#define ISCSI_LOGIN_OPTIONS_INFO_QUALIFIERS \
     BitMap{ ISCSI_LOGIN_OPTIONS_HEADER_DIGEST, \
             ISCSI_LOGIN_OPTIONS_DATA_DIGEST, \
             ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS, \
             ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT, \
             ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN \
           }, \
     BitValues{"HeaderDigest", "DataDigest", "MaxConnections", \
               "DefaultTime2Wait", "DefaultTime2Retain" } : amended


//
// IKE Identification payload types
//
#define       ID_IPV4_ADDR                        "1"
#define       ID_FQDN                             "2"
#define       ID_USER_FQDN                        "3"
#define       ID_IPV6_ADDR                        "5"

#define IKE_IDENTIFICATION_TYPE_QUALIFIERS \
             ValueMap{ ID_IPV4_ADDR, \
                       ID_FQDN, \
                       ID_USER_FQDN, \
                       ID_IPV6_ADDR \
                       }, \
              Values{  "ID_IPV4_ADDR", \
                       "ID_FQDN", \
                       "ID_USER_FQDN", \
                       "ID_IPV6_ADDR" \
                        }

#define IKE_AUTHENTICATION_PAYLOAD_TYPE_CPPQUOTE \
"//\n" \
"// IKE Identification payload types (from RFC 2407)\n" \
"//\n" \
"#define       ID_IPV4_ADDR                        1\n" \
"#define       ID_FQDN                             2\n" \
"#define       ID_USER_FQDN                        3\n" \
"#define       ID_IPV6_ADDR                        5\n" \
"\n"
                   
    
#else

//
// Definitions for iscsi security flags. These flags provide
// information about the security expectations of a target portal and
// are needed to insure a successful IKE/IPSEC negotiation. Note that
// the flags and values are taken directly from the iSNS spec
//
typedef ULONGLONG ISCSI_SECURITY_FLAGS;
typedef ISCSI_SECURITY_FLAGS *PISCSI_SECURITY_FLAGS;


    // 1 = Tunnel Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TUNNEL_MODE_PREFERRED    0x00000040

    // 1 = Transport Mode Preferred; 0 = No Preference
#define ISCSI_SECURITY_FLAG_TRANSPORT_MODE_PREFERRED 0x00000020
                
    // 1 = PFS Enabled; 0 = PFS Disabled
#define ISCSI_SECURITY_FLAG_PFS_ENABLED              0x00000010
                
    // 1 = Aggressive Mode Enabled; 0 = Disabled
#define ISCSI_SECURITY_FLAG_AGGRESSIVE_MODE_ENABLED  0x00000008
                
    // 1 = Main Mode Enabled; 0 = MM Disabled
#define ISCSI_SECURITY_FLAG_MAIN_MODE_ENABLED        0x00000004
                
    // 1 = IKE/IPSec Enabled; 0 = IKE/IPSec Disabled
#define ISCSI_SECURITY_FLAG_IKE_IPSEC_ENABLED        0x00000002

    // If set then all other ISCSI_SECURITY_FLAGS are valid             
#define ISCSI_SECURITY_FLAG_VALID                    0x00000001             

//
// definitions for ISCSI_LOGIN_OPTIONS. This structure is used to pass
// information that affects the login negotiation of session
//

typedef enum
{
    ISCSI_DIGEST_TYPE_NONE = 0,
    ISCSI_DIGEST_TYPE_CRC32C = 1
} ISCSI_DIGEST_TYPES, *PISCSI_DIGEST_TYPES;

//
// bit flags for ISCSI_LOGIN_FLAGS
//
typedef ULONG ISCSI_LOGIN_FLAGS, *PISCSI_LOGIN_FLAGS;

#define ISCSI_LOGIN_FLAG_REQUIRE_IPSEC                0x00000001
#define ISCSI_LOGIN_FLAG_MULTIPATH_ENABLED            0x00000002
#define ISCSI_LOGIN_FLAG_RESERVED1                    0x00000004
#define ISCSI_LOGIN_FLAG_ALLOW_PORTAL_HOPPING         0x00000008
#define ISCSI_LOGIN_FLAG_USE_RADIUS_RESPONSE          0x00000010
#define ISCSI_LOGIN_FLAG_USE_RADIUS_VERIFICATION          0x00000020


//
// Bit flags for InformationSpecifies
//

typedef ULONG ISCSI_LOGIN_OPTIONS_INFO_SPECIFIED;
typedef ISCSI_LOGIN_OPTIONS_INFO_SPECIFIED *PISCSI_LOGIN_OPTIONS_INFO_SPECIFIED;

#define ISCSI_LOGIN_OPTIONS_HEADER_DIGEST               0x00000001
#define ISCSI_LOGIN_OPTIONS_DATA_DIGEST                 0x00000002
#define ISCSI_LOGIN_OPTIONS_MAXIMUM_CONNECTIONS         0x00000004
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_WAIT         0x00000008
#define ISCSI_LOGIN_OPTIONS_DEFAULT_TIME_2_RETAIN       0x00000010
#define ISCSI_LOGIN_OPTIONS_USERNAME                    0x00000020
#define ISCSI_LOGIN_OPTIONS_PASSWORD                    0x00000040
#define ISCSI_LOGIN_OPTIONS_AUTH_TYPE                   0x00000080


#define ISCSI_LOGIN_OPTIONS_VERSION 0

typedef enum
{
    ISCSI_NO_AUTH_TYPE = 0,
    ISCSI_CHAP_AUTH_TYPE = 1,
    ISCSI_MUTUAL_CHAP_AUTH_TYPE = 2
} ISCSI_AUTH_TYPES, *PISCSI_AUTH_TYPES;

typedef struct
{
    ULONG Version;                    // ISCSI_LOGIN_OPTIONS_VERSION

                       // Bit field indicating which information is specified   
    ISCSI_LOGIN_OPTIONS_INFO_SPECIFIED InformationSpecified;

    ISCSI_LOGIN_FLAGS LoginFlags;

    ISCSI_AUTH_TYPES AuthType;
    
    ISCSI_DIGEST_TYPES HeaderDigest;
    ISCSI_DIGEST_TYPES DataDigest;
    ULONG MaximumConnections;
    ULONG DefaultTime2Wait;
    ULONG DefaultTime2Retain;

    //
    // Username and passwords are used for iscsi authentication and are
    // defined as defined as binary blobs. They have different meanings
    // based upon the different iSCSI authentication method used.
    //     For CHAP the username is the CHAP Name (CHAP_N) 
    //     and the password is the shared secret of the target. If the
    //     Username is not specified then the service will use the
    //     initiator node name as the CHAP Name
    //
    // If they are strings then they are expected
    // to be ANSI strings. 
    //
    ULONG UsernameLength;
    ULONG PasswordLength;
#ifdef MIDL_PASS
    [size_is(UsernameLength)]
#endif
    PUCHAR Username;
#ifdef MIDL_PASS
    [size_is(PasswordLength)]
#endif
    PUCHAR Password;
} ISCSI_LOGIN_OPTIONS, *PISCSI_LOGIN_OPTIONS;


//
// This defines flags that affect how a target is managed and its
// information stored
//
typedef ULONG ISCSI_TARGET_FLAGS;
typedef ISCSI_TARGET_FLAGS *PISCSI_TARGET_FLAGS;

//
// if this flag is set then the target will never be reported unless it
// is also discovered dynamically.
//
#define ISCSI_TARGET_FLAG_HIDE_STATIC_TARGET            0x00000002

//
// If this flag is set then the target information passed will be
// merged with any target information already statically configured for
// the target
//
#define ISCSI_TARGET_FLAG_MERGE_TARGET_INFORMATION       0x00000004


//
// IKE Identification payload types (from RFC 2407)
//
typedef UCHAR IKE_IDENTIFICATION_PAYLOAD_TYPE, *PIKE_IDENTIFICATION_PAYLOAD_TYPE;

#define       ID_IPV4_ADDR                        1
#define       ID_FQDN                             2
#define       ID_USER_FQDN                        3
#define       ID_IPV6_ADDR                        5



//
// Methods and data structures for those methods that can be used
// for IKE authentication in the SetIScsiIKEInfo api
//
typedef enum
{
    IKE_AUTHENTICATION_PRESHARED_KEY_METHOD = 1
} IKE_AUTHENTICATION_METHOD, *PIKE_AUTHENTICATION_METHOD;

typedef struct
{
    ISCSI_SECURITY_FLAGS SecurityFlags;
    IKE_IDENTIFICATION_PAYLOAD_TYPE IdType;
    ULONG IdLengthInBytes;
    PUCHAR Id;
    ULONG KeyLengthInBytes;
    PUCHAR Key;
} IKE_AUTHENTICATION_PRESHARED_KEY, *PIKE_AUTHENTICATION_PRESHARED_KEY;

typedef struct
{
    IKE_AUTHENTICATION_METHOD AuthMethod;
    union
    {
        IKE_AUTHENTICATION_PRESHARED_KEY PsKey;
    };
} IKE_AUTHENTICATION_INFORMATION, *PIKE_AUTHENTICATION_INFORMATION;

#endif

#ifndef MOFCOMP_PASS

#ifdef _ISDSCP_
#define ISDSC_API WINAPI
#else
#define ISDSC_API DECLSPEC_IMPORT WINAPI
#endif


//
// Each iscsi session and connection has a unique session or connection
// id that is used to reference the session. It it not related to the
// actual ISID
//
typedef struct _ISCSI_UNIQUE_SESSION_ID
{   
   ULONGLONG AdapterUnique;
   ULONGLONG AdapterSpecific;
} ISCSI_UNIQUE_SESSION_ID, *PISCSI_UNIQUE_SESSION_ID,
  ISCSI_UNIQUE_CONNECTION_ID, *PISCSI_UNIQUE_CONNECTION_ID;

//
// This specifies a mapping from a target LUN to a OS LUN
//

typedef struct
{
    ULONG OSLUN;
    ULONGLONG TargetLUN;
} SCSI_LUN_LIST, *PSCSI_LUN_LIST;

typedef struct
{
    WCHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    WCHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    WCHAR OSDeviceName[MAX_PATH]; /* \device\ScsiPort3 */
    ISCSI_UNIQUE_SESSION_ID SessionId;
    ULONG OSBusNumber;
    ULONG OSTargetNumber;
    ULONG LUNCount;
#ifdef MIDL_PASS
    [size_is(LUNCount)]
#endif
    PSCSI_LUN_LIST LUNList;
} ISCSI_TARGET_MAPPINGW, *PISCSI_TARGET_MAPPINGW;

typedef struct
{
    CHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    CHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    CHAR OSDeviceName[MAX_PATH]; /* \device\ScsiPort3 */
    ISCSI_UNIQUE_SESSION_ID SessionId;
    ULONG OSBusNumber;
    ULONG OSTargetNumber;
    ULONG LUNCount;
#ifdef MIDL_PASS
    [size_is(LUNCount)]
#endif
    PSCSI_LUN_LIST LUNList;
} ISCSI_TARGET_MAPPINGA, *PISCSI_TARGET_MAPPINGA;

#ifdef UNICODE
typedef ISCSI_TARGET_MAPPINGW  ISCSI_TARGET_MAPPING;
typedef PISCSI_TARGET_MAPPINGW  PISCSI_TARGET_MAPPING;
#else
typedef ISCSI_TARGET_MAPPINGA  ISCSI_TARGET_MAPPING;
typedef PISCSI_TARGET_MAPPINGA  PISCSI_TARGET_MAPPING;
#endif // UNICODE
                   
typedef struct
{
    WCHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    WCHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
} ISCSI_TARGET_PORTALW, *PISCSI_TARGET_PORTALW;

typedef struct
{
    CHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    CHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
} ISCSI_TARGET_PORTALA, *PISCSI_TARGET_PORTALA;

#ifdef UNICODE
typedef ISCSI_TARGET_PORTALW  ISCSI_TARGET_PORTAL;
typedef PISCSI_TARGET_PORTALW  PISCSI_TARGET_PORTAL;
#else
typedef ISCSI_TARGET_PORTALA  ISCSI_TARGET_PORTAL;
typedef PISCSI_TARGET_PORTALA  PISCSI_TARGET_PORTAL;
#endif // UNICODE

typedef struct
{
    WCHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    WCHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    WCHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
} ISCSI_TARGET_PORTAL_INFOW, *PISCSI_TARGET_PORTAL_INFOW;

typedef struct
{
    CHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    CHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    CHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
} ISCSI_TARGET_PORTAL_INFOA, *PISCSI_TARGET_PORTAL_INFOA;

#ifdef UNICODE
typedef ISCSI_TARGET_PORTAL_INFOW  ISCSI_TARGET_PORTAL_INFO;
typedef PISCSI_TARGET_PORTAL_INFOW  PISCSI_TARGET_PORTAL_INFO;
#else
typedef ISCSI_TARGET_PORTAL_INFOA  ISCSI_TARGET_PORTAL_INFO;
typedef PISCSI_TARGET_PORTAL_INFOA  PISCSI_TARGET_PORTAL_INFO;
#endif // UNICODE

typedef struct
{
    WCHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    WCHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    WCHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
    ISCSI_SECURITY_FLAGS SecurityFlags;
    ISCSI_LOGIN_OPTIONS LoginOptions;
} ISCSI_TARGET_PORTAL_INFO_EXW, *PISCSI_TARGET_PORTAL_INFO_EXW;

typedef struct
{
    CHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    CHAR SymbolicName[MAX_ISCSI_PORTAL_NAME_LEN];
    CHAR Address[MAX_ISCSI_PORTAL_ADDRESS_LEN];
    USHORT Socket;
    ISCSI_SECURITY_FLAGS SecurityFlags;
    ISCSI_LOGIN_OPTIONS LoginOptions;
} ISCSI_TARGET_PORTAL_INFO_EXA, *PISCSI_TARGET_PORTAL_INFO_EXA;

#ifdef UNICODE
typedef ISCSI_TARGET_PORTAL_INFO_EXW  ISCSI_TARGET_PORTAL_INFO_EX;
typedef PISCSI_TARGET_PORTAL_INFO_EXW  PISCSI_TARGET_PORTAL_INFO_EX;
#else
typedef ISCSI_TARGET_PORTAL_INFO_EXA  ISCSI_TARGET_PORTAL_INFO_EX;
typedef PISCSI_TARGET_PORTAL_INFO_EXA  PISCSI_TARGET_PORTAL_INFO_EX;
#endif // UNICODE

typedef struct
{
    ULONG Count;
    ISCSI_TARGET_PORTALW Portals[1];
} ISCSI_TARGET_PORTAL_GROUPW, *PISCSI_TARGET_PORTAL_GROUPW;

typedef struct
{
    ULONG Count;
    ISCSI_TARGET_PORTALA Portals[1];
} ISCSI_TARGET_PORTAL_GROUPA, *PISCSI_TARGET_PORTAL_GROUPA;

#ifdef UNICODE
typedef ISCSI_TARGET_PORTAL_GROUPW ISCSI_TARGET_PORTAL_GROUP;
typedef PISCSI_TARGET_PORTAL_GROUPW PISCSI_TARGET_PORTAL_GROUP;
#else
typedef ISCSI_TARGET_PORTAL_GROUPA ISCSI_TARGET_PORTAL_GROUP;
typedef PISCSI_TARGET_PORTAL_GROUPA PISCSI_TARGET_PORTAL_GROUP;
#endif // UNICODE


typedef struct
{
    ISCSI_UNIQUE_CONNECTION_ID ConnectionId;  // TODO: add connectionid to mof
    PWCHAR InitiatorAddress;
    PWCHAR TargetAddress;
    USHORT InitiatorSocket;
    USHORT TargetSocket;
    UCHAR CID[2];
} ISCSI_CONNECTION_INFOW, *PISCSI_CONNECTION_INFOW;

typedef struct
{
    ISCSI_UNIQUE_SESSION_ID SessionId;
    PWCHAR InitiatorName;
    PWCHAR TargetNodeName;
    PWCHAR TargetName;
    UCHAR ISID[6];
    UCHAR TSID[2];
    ULONG ConnectionCount;
    PISCSI_CONNECTION_INFOW Connections;    
} ISCSI_SESSION_INFOW, *PISCSI_SESSION_INFOW;


typedef struct
{
    ISCSI_UNIQUE_CONNECTION_ID ConnectionId;  // TODO: add connectionid to mof
    PCHAR InitiatorAddress;
    PCHAR TargetAddress;
    USHORT InitiatorSocket;
    USHORT TargetSocket;
    UCHAR CID[2];
} ISCSI_CONNECTION_INFOA, *PISCSI_CONNECTION_INFOA;

typedef struct
{
    ISCSI_UNIQUE_SESSION_ID SessionId;
    PCHAR InitiatorName;
    PCHAR TargetNodeName;
    PCHAR TargetName;
    UCHAR ISID[6];
    UCHAR TSID[2];
    ULONG ConnectionCount;
    PISCSI_CONNECTION_INFOA Connections;    
} ISCSI_SESSION_INFOA, *PISCSI_SESSION_INFOA;


#ifdef UNICODE
typedef ISCSI_SESSION_INFOW ISCSI_SESSION_INFO;
typedef PISCSI_SESSION_INFOW PISCSI_SESSION_INFO;

typedef ISCSI_CONNECTION_INFOW ISCSI_CONNECTION_INFO;
typedef PISCSI_CONNECTION_INFOW PISCSI_CONNECTION_INFO;
#else
typedef ISCSI_SESSION_INFOA ISCSI_SESSION_INFO;
typedef PISCSI_SESSION_INFOA PISCSI_SESSION_INFO;

typedef ISCSI_CONNECTION_INFOA ISCSI_CONNECTION_INFO;
typedef PISCSI_CONNECTION_INFOA PISCSI_CONNECTION_INFO;
#endif

typedef struct
{
    ISCSI_UNIQUE_CONNECTION_ID ConnectionId;
    UCHAR State;
    UCHAR Protocol;
    UCHAR HeaderDigest;
    UCHAR DataDigest;
    ULONG MaxRecvDataSegmentLength;
    ISCSI_AUTH_TYPES AuthType;
    ULONGLONG EstimatedThroughput;
    ULONG MaxDatagramSize;
} ISCSI_CONNECTION_INFO_EX, *PISCSI_CONNECTION_INFO_EX;

typedef struct
{
    ISCSI_UNIQUE_SESSION_ID SessionId;
    BOOLEAN InitialR2t;
    BOOLEAN ImmediateData;
    UCHAR Type;
    BOOLEAN DataSequenceInOrder;
    BOOLEAN DataPduInOrder;
    UCHAR ErrorRecoveryLevel;
    ULONG MaxOutstandingR2t;
    ULONG FirstBurstLength;
    ULONG MaxBurstLength;
    ULONG MaximumConnections;
    ULONG ConnectionCount;
    PISCSI_CONNECTION_INFO_EX Connections;
} ISCSI_SESSION_INFO_EX, *PISCSI_SESSION_INFO_EX;

#ifndef MIDL_PASS
typedef struct
{
    WCHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    WCHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    SCSI_ADDRESS ScsiAddress;
    GUID DeviceInterfaceType;
    WCHAR DeviceInterfaceName[MAX_PATH];
    WCHAR LegacyName[MAX_PATH];
    STORAGE_DEVICE_NUMBER StorageDeviceNumber;
    DWORD /* DEVINST */ DeviceInstance;
} ISCSI_DEVICE_ON_SESSIONW, *PISCSI_DEVICE_ON_SESSIONW;

typedef struct
{
    CHAR InitiatorName[MAX_ISCSI_HBANAME_LEN];
    CHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    SCSI_ADDRESS ScsiAddress;
    GUID DeviceInterfaceType;
    CHAR DeviceInterfaceName[MAX_PATH];
    CHAR LegacyName[MAX_PATH];
    STORAGE_DEVICE_NUMBER StorageDeviceNumber;
    DWORD /* DEVINST */ DeviceInstance;
} ISCSI_DEVICE_ON_SESSIONA, *PISCSI_DEVICE_ON_SESSIONA;

#ifdef UNICODE
typedef ISCSI_DEVICE_ON_SESSIONW ISCSI_DEVICE_ON_SESSION;
typedef PISCSI_DEVICE_ON_SESSIONW PISCSI_DEVICE_ON_SESSION;
#else
typedef ISCSI_DEVICE_ON_SESSIONA ISCSI_DEVICE_ON_SESSION;
typedef PISCSI_DEVICE_ON_SESSIONA PISCSI_DEVICE_ON_SESSION;
#endif

#endif

typedef struct
{
    WCHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    BOOLEAN IsInformationalSession;
    WCHAR InitiatorInstance[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    ISCSI_TARGET_PORTALW TargetPortal;
    ISCSI_SECURITY_FLAGS SecurityFlags;
    PISCSI_TARGET_MAPPINGW Mappings;
    ISCSI_LOGIN_OPTIONS LoginOptions;
} PERSISTENT_ISCSI_LOGIN_INFOW, *PPERSISTENT_ISCSI_LOGIN_INFOW;

typedef struct
{
    CHAR TargetName[MAX_ISCSI_NAME_LEN + 1];
    BOOLEAN IsInformationalSession;
    CHAR InitiatorInstance[MAX_ISCSI_HBANAME_LEN];
    ULONG InitiatorPortNumber;
    ISCSI_TARGET_PORTALA TargetPortal;
    ISCSI_SECURITY_FLAGS SecurityFlags;
    PISCSI_TARGET_MAPPINGA Mappings;
    ISCSI_LOGIN_OPTIONS LoginOptions;
} PERSISTENT_ISCSI_LOGIN_INFOA, *PPERSISTENT_ISCSI_LOGIN_INFOA;

#ifdef UNICODE
typedef PERSISTENT_ISCSI_LOGIN_INFOW PERSISTENT_ISCSI_LOGIN_INFO;
typedef PPERSISTENT_ISCSI_LOGIN_INFOW PPERSISTENT_ISCSI_LOGIN_INFO;
#else
typedef PERSISTENT_ISCSI_LOGIN_INFOA PERSISTENT_ISCSI_LOGIN_INFO;
typedef PPERSISTENT_ISCSI_LOGIN_INFOA PPERSISTENT_ISCSI_LOGIN_INFO;
#endif


//
// definitions of information that can be queried and set via the
// GetIScsiTargetInformation and SetIScsiTargetInformation apis
//
typedef enum
{
    ISCSI_TCP_PROTOCOL_TYPE
} TARGETPROTOCOLTYPE, *PTARGETPROTOCOLTYPE;

typedef enum
{
                        // Requires DiscoveryMechansim parameter
    ProtocolType,       // Protocol used to communicate with TARGET - TARGETPROTOCOLTYPE

                        // Requires DiscoveryMechansim parameter
    TargetAlias,        // Alias Name - WCHAR Alias[MAX_ISCSI_TARGET_ALIAS_LEN]

                        // 
    DiscoveryMechanisms, // Discovery mechanisms - strings

                        // Requires DiscoveryMechansim parameter
    PortalGroups,       // Portal Groups - array of portal groups, preceeded by a ULONG count. Each Portal Group must be aliagned on a 4 byte boundry

                        // Requires DiscoveryMechansim parameter
                        // ISCSI_TARGET_MAPPING
    PersistentTargetMappings,
    
                        // Requires DiscoveryMechansim parameter
    InitiatorName,      // Name of initiator that can connect to target
    
                        // Requires DiscoveryMechansim parameter
    TargetFlags,        // TargetFlags

    LoginOptions        // Requires DiscoveryMechansim parameter
                        // ISCSI_LOGIN_OPTIONS
               
} TARGET_INFORMATION_CLASS, *PTARGET_INFORMATION_CLASS;


typedef struct
{
    ULONG MajorVersion;
    ULONG MinorVersion;
    ULONG BuildNumber;
} ISCSI_VERSION_INFO, *PISCSI_VERSION_INFO;



#if ! (defined(MIDL_PASS))

ISDSC_STATUS ISDSC_API GetIScsiVersionInformation(
    PISCSI_VERSION_INFO VersionInfo
    );

ISDSC_STATUS ISDSC_API GetIScsiTargetInformationW(
    IN __in PWCHAR TargetName,
    IN __in_opt PWCHAR DiscoveryMechanism,
    IN TARGET_INFORMATION_CLASS InfoClass,
    IN OUT PULONG BufferSize,
    OUT PVOID Buffer
    );

ISDSC_STATUS ISDSC_API GetIScsiTargetInformationA(
    IN __in PCHAR TargetName,
    IN __in_opt PCHAR DiscoveryMechanism,
    IN TARGET_INFORMATION_CLASS InfoClass,
    IN OUT PULONG BufferSize,
    OUT PVOID Buffer
    );

#ifdef UNICODE
#define GetIScsiTargetInformation GetIScsiTargetInformationW
#else
#define GetIScsiTargetInformation GetIScsiTargetInformationA
#endif // UNICODE

ISDSC_STATUS ISDSC_API AddIScsiConnectionW(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN PVOID Reserved,
    IN ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALW TargetPortal,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ULONG KeySize,
    IN OPTIONAL __in_ecount_opt(KeySize) PCHAR Key,
    OUT OPTIONAL PISCSI_UNIQUE_CONNECTION_ID ConnectionId
    );
    
ISDSC_STATUS ISDSC_API AddIScsiConnectionA(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN PVOID Reserved,
    IN ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALA TargetPortal,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ULONG KeySize,
    IN OPTIONAL __in_ecount_opt(KeySize) PCHAR Key,
    OUT OPTIONAL PISCSI_UNIQUE_CONNECTION_ID ConnectionId
    );
    
#ifdef UNICODE
#define AddIScsiConnection AddIScsiConnectionW
#else
#define AddIScsiConnection AddIScsiConnectionA
#endif // UNICODE


ISDSC_STATUS ISDSC_API RemoveIScsiConnection(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN PISCSI_UNIQUE_CONNECTION_ID ConnectionId
    );

ISDSC_STATUS ISDSC_API ReportIScsiTargetsW(
    IN BOOLEAN ForceUpdate,
    IN OUT PULONG BufferSize,
    OUT __inout_ecount_opt(*BufferSize) PWCHAR Buffer
    );

ISDSC_STATUS ISDSC_API ReportIScsiTargetsA(
    IN BOOLEAN ForceUpdate,
    IN OUT PULONG BufferSize,
    OUT __inout_ecount_opt(*BufferSize) PCHAR Buffer
    );

#ifdef UNICODE
#define ReportIScsiTargets ReportIScsiTargetsW
#else
#define ReportIScsiTargets ReportIScsiTargetsA
#endif


ISDSC_STATUS ISDSC_API AddIScsiStaticTargetW(
    IN __in PWCHAR TargetName,
    IN OPTIONAL __in_opt PWCHAR TargetAlias,
    IN ISCSI_TARGET_FLAGS TargetFlags,
    IN BOOLEAN Persist,
    IN OPTIONAL PISCSI_TARGET_MAPPINGW Mappings,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL PISCSI_TARGET_PORTAL_GROUPW PortalGroup
    );

ISDSC_STATUS ISDSC_API AddIScsiStaticTargetA(
    IN __in PCHAR TargetName,
    IN OPTIONAL __in_opt PCHAR TargetAlias,
    IN ISCSI_TARGET_FLAGS TargetFlags,
    IN BOOLEAN Persist,
    IN OPTIONAL PISCSI_TARGET_MAPPINGA Mappings,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL PISCSI_TARGET_PORTAL_GROUPA PortalGroup
    );

#ifdef UNICODE
#define AddIScsiStaticTarget AddIScsiStaticTargetW
#else
#define AddIScsiStaticTarget AddIScsiStaticTargetA
#endif

ISDSC_STATUS ISDSC_API RemoveIScsiStaticTargetW(
    IN __in PWCHAR TargetName
    );

ISDSC_STATUS ISDSC_API RemoveIScsiStaticTargetA(
    IN __in PCHAR TargetName
    );

#ifdef UNICODE
#define RemoveIScsiStaticTarget RemoveIScsiStaticTargetW
#else
#define RemoveIScsiStaticTarget RemoveIScsiStaticTargetA
#endif

ISDSC_STATUS ISDSC_API AddIScsiSendTargetPortalW(
    IN OPTIONAL __in_opt PWCHAR InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags, 
    IN PISCSI_TARGET_PORTALW Portal
    );

ISDSC_STATUS ISDSC_API AddIScsiSendTargetPortalA(
    IN OPTIONAL __in_opt PCHAR InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags, 
    IN PISCSI_TARGET_PORTALA Portal
    );

#ifdef UNICODE
#define AddIScsiSendTargetPortal AddIScsiSendTargetPortalW
#else
#define AddIScsiSendTargetPortal AddIScsiSendTargetPortalA
#endif

ISDSC_STATUS ISDSC_API RemoveIScsiSendTargetPortalW(
    IN OPTIONAL PWCHAR __in_opt InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALW Portal
    );

ISDSC_STATUS ISDSC_API RemoveIScsiSendTargetPortalA(
    IN OPTIONAL PCHAR __in_opt InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALA Portal
    );

#ifdef UNICODE
#define RemoveIScsiSendTargetPortal RemoveIScsiSendTargetPortalW
#else
#define RemoveIScsiSendTargetPortal RemoveIScsiSendTargetPortalA
#endif

ISDSC_STATUS ISDSC_API RefreshIScsiSendTargetPortalW(
    IN OPTIONAL PWCHAR __in_opt InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALW Portal
    );

ISDSC_STATUS ISDSC_API RefreshIScsiSendTargetPortalA(
    IN OPTIONAL PCHAR __in_opt InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PISCSI_TARGET_PORTALA Portal
    );

#ifdef UNICODE
#define RefreshIScsiSendTargetPortal RefreshIScsiSendTargetPortalW
#else
#define RefreshIScsiSendTargetPortal RefreshIScsiSendTargetPortalA
#endif


ISDSC_STATUS ISDSC_API ReportIScsiSendTargetPortalsW(
    IN OUT PULONG PortalCount,
    IN OUT PISCSI_TARGET_PORTAL_INFOW PortalInfo
    );

ISDSC_STATUS ISDSC_API ReportIScsiSendTargetPortalsA(
    IN OUT PULONG PortalCount,
    IN OUT PISCSI_TARGET_PORTAL_INFOA PortalInfo
    );
#ifdef UNICODE
#define ReportIScsiSendTargetPortals ReportIScsiSendTargetPortalsW
#else
#define ReportIScsiSendTargetPortals ReportIScsiSendTargetPortalsA
#endif

ISDSC_STATUS ISDSC_API ReportIScsiSendTargetPortalsExW(
    OUT PULONG PortalCount,
    IN OUT PULONG PortalInfoSize,
    IN OUT PISCSI_TARGET_PORTAL_INFO_EXW PortalInfo
    );

ISDSC_STATUS ISDSC_API ReportIScsiSendTargetPortalsExA(
    OUT PULONG PortalCount,
    IN OUT PULONG PortalInfoSize,
    IN OUT PISCSI_TARGET_PORTAL_INFO_EXA PortalInfo
    );
#ifdef UNICODE
#define ReportIScsiSendTargetPortalsEx ReportIScsiSendTargetPortalsExW
#else
#define ReportIScsiSendTargetPortalsEx ReportIScsiSendTargetPortalsExA
#endif


ISDSC_STATUS ISDSC_API LoginIScsiTargetW(
    IN __in PWCHAR TargetName,
    IN BOOLEAN IsInformationalSession,
    IN OPTIONAL __in_opt PWCHAR InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN OPTIONAL PISCSI_TARGET_PORTALW TargetPortal,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags,
    IN OPTIONAL PISCSI_TARGET_MAPPINGW Mappings,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ULONG KeySize,
    IN OPTIONAL __in_ecount_opt(KeySize) PCHAR Key,
    IN BOOLEAN IsPersistent,
    OUT PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    OUT PISCSI_UNIQUE_CONNECTION_ID UniqueConnectionId
    );

ISDSC_STATUS ISDSC_API LoginIScsiTargetA(
    IN PCHAR __in TargetName,
    IN BOOLEAN IsInformationalSession,
    IN OPTIONAL __in_opt PCHAR InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN OPTIONAL PISCSI_TARGET_PORTALA TargetPortal,
    IN OPTIONAL ISCSI_SECURITY_FLAGS SecurityFlags,
    IN OPTIONAL PISCSI_TARGET_MAPPINGA Mappings,
    IN OPTIONAL PISCSI_LOGIN_OPTIONS LoginOptions,
    IN OPTIONAL ULONG KeySize,
    IN OPTIONAL __in_ecount_opt(KeySize) PCHAR Key,
    IN BOOLEAN IsPersistent,
    OUT PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    OUT PISCSI_UNIQUE_CONNECTION_ID UniqueConnectionId
    );

#ifdef UNICODE
#define LoginIScsiTarget LoginIScsiTargetW
#else
#define LoginIScsiTarget LoginIScsiTargetA
#endif


ISDSC_STATUS ISDSC_API ReportIScsiPersistentLoginsW(
    OUT ULONG *Count,
    IN OUT PPERSISTENT_ISCSI_LOGIN_INFOW PersistentLoginInfo,
    IN OUT PULONG BufferSizeInBytes
    );

ISDSC_STATUS ISDSC_API ReportIScsiPersistentLoginsA(
    OUT ULONG *Count,
    IN OUT PPERSISTENT_ISCSI_LOGIN_INFOA PersistentLoginInfo,
    IN OUT PULONG BufferSizeInBytes
    );

#ifdef UNICODE
#define ReportIScsiPersistentLogins ReportIScsiPersistentLoginsW
#else
#define ReportIScsiPersistentLogins ReportIScsiPersistentLoginsA
#endif


                                    
ISDSC_STATUS ISDSC_API LogoutIScsiTarget(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId
    );

ISDSC_STATUS ISDSC_API RemoveIScsiPersistentTargetW(
    IN PWCHAR __in InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PWCHAR __in TargetName,
    IN PISCSI_TARGET_PORTALW Portal
    );

ISDSC_STATUS ISDSC_API RemoveIScsiPersistentTargetA(
    IN PCHAR __in InitiatorInstance,
    IN OPTIONAL ULONG InitiatorPortNumber,
    IN PCHAR __in TargetName,
    IN PISCSI_TARGET_PORTALA Portal
    );

#ifdef UNICODE
#define RemoveIScsiPersistentTarget RemoveIScsiPersistentTargetW
#else
#define RemoveIScsiPersistentTarget RemoveIScsiPersistentTargetA
#endif

ISDSC_STATUS ISDSC_API SendScsiInquiry(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN ULONGLONG Lun,
    IN UCHAR EvpdCmddt,
    IN UCHAR PageCode,
    OUT PUCHAR ScsiStatus,
    IN OUT PULONG ResponseSize,
    OUT PUCHAR ResponseBuffer,
    IN OUT PULONG SenseSize,
    OUT PUCHAR SenseBuffer
    );

ISDSC_STATUS ISDSC_API SendScsiReadCapacity(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN ULONGLONG Lun,
    OUT PUCHAR ScsiStatus,
    IN OUT PULONG ResponseSize,
    OUT PUCHAR ResponseBuffer,
    IN OUT PULONG SenseSize,
    OUT PUCHAR SenseBuffer
    );

ISDSC_STATUS ISDSC_API SendScsiReportLuns(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    OUT PUCHAR ScsiStatus,
    IN OUT PULONG ResponseSize,
    OUT PUCHAR ResponseBuffer,
    IN OUT PULONG SenseSize,
    OUT PUCHAR SenseBuffer
    );

ISDSC_STATUS ISDSC_API ReportIScsiInitiatorListW(
    IN OUT ULONG *BufferSize,
    OUT __inout_ecount_opt(*BufferSize) PWCHAR Buffer
    );

ISDSC_STATUS ISDSC_API ReportIScsiInitiatorListA(
    IN OUT PULONG BufferSize,
    OUT __inout_ecount_opt(*BufferSize) PCHAR Buffer
    );

#ifdef UNICODE
#define ReportIScsiInitiatorList ReportIScsiInitiatorListW
#else
#define ReportIScsiInitiatorList ReportIScsiInitiatorListA
#endif


ISDSC_STATUS ISDSC_API ReportActiveIScsiTargetMappingsW(
    IN OUT PULONG BufferSize,
    OUT PULONG MappingCount,
    OUT PISCSI_TARGET_MAPPINGW Mappings
    );

ISDSC_STATUS ISDSC_API ReportActiveIScsiTargetMappingsA(
    IN OUT PULONG BufferSize,
    OUT PULONG MappingCount,
    OUT PISCSI_TARGET_MAPPINGA Mappings
    );

#ifdef UNICODE
#define ReportActiveIScsiTargetMappings ReportActiveIScsiTargetMappingsW
#else
#define ReportActiveIScsiTargetMappings ReportActiveIScsiTargetMappingsA
#endif

ISDSC_STATUS ISDSC_API SetIScsiTunnelModeOuterAddressW(
    IN OPTIONAL __in_opt PWCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PWCHAR __in_opt DestinationAddress,
    IN PWCHAR __in_opt OuterModeAddress,
    IN BOOLEAN Persist
    );
    
ISDSC_STATUS ISDSC_API SetIScsiTunnelModeOuterAddressA(
    IN OPTIONAL __in_opt PCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PCHAR __in_opt DestinationAddress,
    IN PCHAR __in_opt OuterModeAddress,
    IN BOOLEAN Persist
    );

#ifdef UNICODE
#define SetIScsiTunnelModeOuterAddress SetIScsiTunnelModeOuterAddressW
#else
#define SetIScsiTunnelModeOuterAddress SetIScsiTunnelModeOuterAddressA
#endif


ISDSC_STATUS ISDSC_API SetIScsiIKEInfoW(
    IN OPTIONAL __in_opt PWCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PIKE_AUTHENTICATION_INFORMATION AuthInfo,
    IN BOOLEAN Persist
    );

ISDSC_STATUS ISDSC_API SetIScsiIKEInfoA(
    IN OPTIONAL __in_opt PCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PIKE_AUTHENTICATION_INFORMATION AuthInfo,
    IN BOOLEAN Persist
    );

#ifdef UNICODE
#define SetIScsiIKEInfo SetIScsiIKEInfoW
#else
#define SetIScsiIKEInfo SetIScsiIKEInfoA
#endif

ISDSC_STATUS ISDSC_API GetIScsiIKEInfoW(
    IN OPTIONAL __in_opt PWCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PULONG Reserved,                                        
    IN OUT PIKE_AUTHENTICATION_INFORMATION AuthInfo
    );

ISDSC_STATUS ISDSC_API GetIScsiIKEInfoA(
    IN OPTIONAL __in_opt PCHAR InitiatorName,
    IN ULONG InitiatorPortNumber,
    IN PULONG Reserved,                                        
    IN OUT PIKE_AUTHENTICATION_INFORMATION AuthInfo
    );

#ifdef UNICODE
#define GetIScsiIKEInfo GetIScsiIKEInfoW
#else
#define GetIScsiIKEInfo GetIScsiIKEInfoA
#endif

ISDSC_STATUS ISDSC_API SetIScsiGroupPresharedKey(
    IN ULONG KeyLength,
    IN PUCHAR Key,
    BOOLEAN Persist
    );

ISDSC_STATUS ISDSC_API SetIScsiInitiatorCHAPSharedSecret(
    IN ULONG SharedSecretLength,
    IN PUCHAR SharedSecret
    );

ISDSC_STATUS ISDSC_API SetIScsiInitiatorRADIUSSharedSecret(
    IN ULONG SharedSecretLength,
    IN PUCHAR SharedSecret
    );

ISDSC_STATUS ISDSC_API SetIScsiInitiatorNodeNameW(
    IN OPTIONAL __in_opt PWCHAR InitiatorNodeName
    );

ISDSC_STATUS ISDSC_API SetIScsiInitiatorNodeNameA(
    IN OPTIONAL __in_opt PCHAR InitiatorNodeName
    );

#ifdef UNICODE
#define SetIScsiInitiatorNodeName SetIScsiInitiatorNodeNameW
#else
#define SetIScsiInitiatorNodeName SetIScsiInitiatorNodeNameA
#endif

ISDSC_STATUS ISDSC_API GetIScsiInitiatorNodeNameW(
     __out_ecount(MAX_ISCSI_NAME_LEN+1) PWCHAR  InitiatorNodeName
    );

ISDSC_STATUS ISDSC_API GetIScsiInitiatorNodeNameA(
     __out_ecount(MAX_ISCSI_NAME_LEN+1) PCHAR  InitiatorNodeName
    );

#ifdef UNICODE
#define GetIScsiInitiatorNodeName GetIScsiInitiatorNodeNameW
#else
#define GetIScsiInitiatorNodeName GetIScsiInitiatorNodeNameA
#endif

ISDSC_STATUS ISDSC_API AddISNSServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API AddISNSServerA(
    IN __in PCHAR Address
    );

#ifdef UNICODE
#define AddISNSServer AddISNSServerW
#else
#define AddISNSServer AddISNSServerA
#endif


ISDSC_STATUS ISDSC_API RemoveISNSServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API RemoveISNSServerA(
    IN __in PCHAR Address
    );
#ifdef UNICODE
#define RemoveISNSServer RemoveISNSServerW
#else
#define RemoveISNSServer RemoveISNSServerA
#endif

ISDSC_STATUS ISDSC_API RefreshISNSServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API RefreshISNSServerA(
    IN __in PCHAR Address
    );
#ifdef UNICODE
#define RefreshISNSServer RefreshISNSServerW
#else
#define RefreshISNSServer RefreshISNSServerA
#endif

ISDSC_STATUS ISDSC_API ReportISNSServerListW(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PWCHAR Buffer
    );

ISDSC_STATUS ISDSC_API ReportISNSServerListA(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PCHAR Buffer
    );
#ifdef UNICODE
#define ReportISNSServerList ReportISNSServerListW
#else
#define ReportISNSServerList ReportISNSServerListA
#endif



ISDSC_STATUS ISDSC_API GetIScsiSessionListW(
    IN OUT ULONG *BufferSize,
    OUT ULONG *SessionCount,
    OUT OPTIONAL PISCSI_SESSION_INFOW SessionInfo
    );

ISDSC_STATUS ISDSC_API GetIScsiSessionListA(
    IN OUT ULONG *BufferSize,
    OUT ULONG *SessionCount,
    OUT OPTIONAL PISCSI_SESSION_INFOA SessionInfo
    );
#ifdef UNICODE
#define GetIScsiSessionList GetIScsiSessionListW
#else
#define GetIScsiSessionList GetIScsiSessionListA
#endif

ISDSC_STATUS ISDSC_API GetIScsiSessionListEx (
    IN OUT ULONG  *BufferSize,
    OUT ULONG  *SessionCountPtr,
    OUT OPTIONAL PISCSI_SESSION_INFO_EX  SessionInfo
);

ISDSC_STATUS ISDSC_API GetDevicesForIScsiSessionW(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN OUT ULONG *DeviceCount,
    OUT PISCSI_DEVICE_ON_SESSIONW Devices
);

ISDSC_STATUS ISDSC_API GetDevicesForIScsiSessionA(
    IN PISCSI_UNIQUE_SESSION_ID UniqueSessionId,
    IN OUT ULONG *DeviceCount,
    OUT PISCSI_DEVICE_ON_SESSIONA Devices
);

#ifdef UNICODE
#define GetDevicesForIScsiSession GetDevicesForIScsiSessionW
#else
#define GetDevicesForIScsiSession GetDevicesForIScsiSessionA
#endif

ISDSC_STATUS ISDSC_API SetupPersistentIScsiVolumes(
    );

ISDSC_STATUS ISDSC_API SetupPersistentIScsiDevices(
    );

ISDSC_STATUS ISDSC_API AddPersistentIScsiDeviceW(
    IN __in PWCHAR DevicePath
);

ISDSC_STATUS ISDSC_API AddPersistentIScsiDeviceA(
    IN __in PCHAR DevicePath
);

#ifdef UNICODE
#define AddPersistentIScsiDevice AddPersistentIScsiDeviceW
#else
#define AddPersistentIScsiDevice AddPersistentIScsiDeviceA
#endif

ISDSC_STATUS ISDSC_API RemovePersistentIScsiDeviceW(
    IN __in PWCHAR DevicePath
);

ISDSC_STATUS ISDSC_API RemovePersistentIScsiDeviceA(
    IN __in PCHAR DevicePath
);

#ifdef UNICODE
#define RemovePersistentIScsiDevice RemovePersistentIScsiDeviceW
#else
#define RemovePersistentIScsiDevice RemovePersistentIScsiDeviceA
#endif

ISDSC_STATUS ISDSC_API ClearPersistentIScsiDevices(
);

ISDSC_STATUS ISDSC_API ReportPersistentIScsiDevicesW(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PWCHAR Buffer
);

ISDSC_STATUS ISDSC_API ReportPersistentIScsiDevicesA(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PCHAR Buffer
);

#ifdef UNICODE
#define ReportPersistentIScsiDevices ReportPersistentIScsiDevicesW
#else
#define ReportPersistentIScsiDevices ReportPersistentIScsiDevicesA
#endif

ISDSC_STATUS ISDSC_API ReportIScsiTargetPortalsW(
    IN OPTIONAL __in_opt PWCHAR InitiatorName,
    IN PWCHAR __in TargetName,
    IN OPTIONAL PUSHORT TargetPortalTag,
    IN OUT PULONG ElementCount,
    OUT PISCSI_TARGET_PORTALW Portals
    );

ISDSC_STATUS ISDSC_API ReportIScsiTargetPortalsA(
    IN OPTIONAL __in_opt PCHAR InitiatorName,
    IN PCHAR __in TargetName,
    IN OPTIONAL PUSHORT TargetPortalTag,
    IN OUT PULONG ElementCount,
    OUT PISCSI_TARGET_PORTALA Portals
    );

#ifdef UNICODE
#define ReportIScsiTargetPortals ReportIScsiTargetPortalsW
#else
#define ReportIScsiTargetPortals ReportIScsiTargetPortalsA
#endif

ISDSC_STATUS ISDSC_API AddRadiusServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API AddRadiusServerA(
    IN __in PCHAR Address
    );

#ifdef UNICODE
#define AddRadiusServer AddRadiusServerW
#else
#define AddRadiusServer AddRadiusServerA
#endif


ISDSC_STATUS ISDSC_API RemoveRadiusServerW(
    IN __in PWCHAR Address
    );

ISDSC_STATUS ISDSC_API RemoveRadiusServerA(
    IN __in PCHAR Address
    );
#ifdef UNICODE
#define RemoveRadiusServer RemoveRadiusServerW
#else
#define RemoveRadiusServer RemoveRadiusServerA
#endif


ISDSC_STATUS ISDSC_API ReportRadiusServerListW(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PWCHAR Buffer
    );

ISDSC_STATUS ISDSC_API ReportRadiusServerListA(
    IN OUT PULONG BufferSizeInChar,
    OUT __out_ecount_opt(*BufferSizeInChar) PCHAR Buffer
    );
#ifdef UNICODE
#define ReportRadiusServerList ReportRadiusServerListW
#else
#define ReportRadiusServerList ReportRadiusServerListA
#endif

#endif // MIDL_PASS

#endif // ! MOFCOMP_PASS

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\isolation.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <specstrings.h>

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __isolation_h__
#define __isolation_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IReferenceIdentity_FWD_DEFINED__
#define __IReferenceIdentity_FWD_DEFINED__
typedef interface IReferenceIdentity IReferenceIdentity;
#endif 	/* __IReferenceIdentity_FWD_DEFINED__ */


#ifndef __IDefinitionIdentity_FWD_DEFINED__
#define __IDefinitionIdentity_FWD_DEFINED__
typedef interface IDefinitionIdentity IDefinitionIdentity;
#endif 	/* __IDefinitionIdentity_FWD_DEFINED__ */


#ifndef __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__
#define __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__
typedef interface IEnumIDENTITY_ATTRIBUTE IEnumIDENTITY_ATTRIBUTE;
#endif 	/* __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__ */


#ifndef __IEnumDefinitionIdentity_FWD_DEFINED__
#define __IEnumDefinitionIdentity_FWD_DEFINED__
typedef interface IEnumDefinitionIdentity IEnumDefinitionIdentity;
#endif 	/* __IEnumDefinitionIdentity_FWD_DEFINED__ */


#ifndef __IEnumReferenceIdentity_FWD_DEFINED__
#define __IEnumReferenceIdentity_FWD_DEFINED__
typedef interface IEnumReferenceIdentity IEnumReferenceIdentity;
#endif 	/* __IEnumReferenceIdentity_FWD_DEFINED__ */


#ifndef __IDefinitionAppId_FWD_DEFINED__
#define __IDefinitionAppId_FWD_DEFINED__
typedef interface IDefinitionAppId IDefinitionAppId;
#endif 	/* __IDefinitionAppId_FWD_DEFINED__ */


#ifndef __IReferenceAppId_FWD_DEFINED__
#define __IReferenceAppId_FWD_DEFINED__
typedef interface IReferenceAppId IReferenceAppId;
#endif 	/* __IReferenceAppId_FWD_DEFINED__ */


#ifndef __IIdentityAuthority_FWD_DEFINED__
#define __IIdentityAuthority_FWD_DEFINED__
typedef interface IIdentityAuthority IIdentityAuthority;
#endif 	/* __IIdentityAuthority_FWD_DEFINED__ */


#ifndef __IAppIdAuthority_FWD_DEFINED__
#define __IAppIdAuthority_FWD_DEFINED__
typedef interface IAppIdAuthority IAppIdAuthority;
#endif 	/* __IAppIdAuthority_FWD_DEFINED__ */


#ifndef __IIdentityAuthority_FWD_DEFINED__
#define __IIdentityAuthority_FWD_DEFINED__
typedef interface IIdentityAuthority IIdentityAuthority;
#endif 	/* __IIdentityAuthority_FWD_DEFINED__ */


#ifndef __IAppIdAuthority_FWD_DEFINED__
#define __IAppIdAuthority_FWD_DEFINED__
typedef interface IAppIdAuthority IAppIdAuthority;
#endif 	/* __IAppIdAuthority_FWD_DEFINED__ */


#ifndef __IDefinitionIdentity_FWD_DEFINED__
#define __IDefinitionIdentity_FWD_DEFINED__
typedef interface IDefinitionIdentity IDefinitionIdentity;
#endif 	/* __IDefinitionIdentity_FWD_DEFINED__ */


#ifndef __IReferenceIdentity_FWD_DEFINED__
#define __IReferenceIdentity_FWD_DEFINED__
typedef interface IReferenceIdentity IReferenceIdentity;
#endif 	/* __IReferenceIdentity_FWD_DEFINED__ */


#ifndef __IDefinitionAppId_FWD_DEFINED__
#define __IDefinitionAppId_FWD_DEFINED__
typedef interface IDefinitionAppId IDefinitionAppId;
#endif 	/* __IDefinitionAppId_FWD_DEFINED__ */


#ifndef __IReferenceAppId_FWD_DEFINED__
#define __IReferenceAppId_FWD_DEFINED__
typedef interface IReferenceAppId IReferenceAppId;
#endif 	/* __IReferenceAppId_FWD_DEFINED__ */


#ifndef __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__
#define __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__
typedef interface IEnumIDENTITY_ATTRIBUTE IEnumIDENTITY_ATTRIBUTE;
#endif 	/* __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__ */


#ifndef __IEnumDefinitionIdentity_FWD_DEFINED__
#define __IEnumDefinitionIdentity_FWD_DEFINED__
typedef interface IEnumDefinitionIdentity IEnumDefinitionIdentity;
#endif 	/* __IEnumDefinitionIdentity_FWD_DEFINED__ */


#ifndef __IEnumReferenceIdentity_FWD_DEFINED__
#define __IEnumReferenceIdentity_FWD_DEFINED__
typedef interface IEnumReferenceIdentity IEnumReferenceIdentity;
#endif 	/* __IEnumReferenceIdentity_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "ocidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

__post __maybenull
__post __writableTo(byteCount(size))  
void * __RPC_USER MIDL_user_allocate(size_t size);
#pragma warning(suppress: 4985)		// Windows annotates with declspecs


typedef struct _IDENTITY_ATTRIBUTE
    {
    LPCWSTR pszNamespace;
    LPCWSTR pszName;
    LPCWSTR pszValue;
    } 	IDENTITY_ATTRIBUTE;

typedef struct _IDENTITY_ATTRIBUTE *PIDENTITY_ATTRIBUTE;

typedef const IDENTITY_ATTRIBUTE *PCIDENTITY_ATTRIBUTE;


#ifndef __IReferenceIdentity_INTERFACE_DEFINED__
#define __IReferenceIdentity_INTERFACE_DEFINED__

/* interface IReferenceIdentity */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eaf5ace-7917-4f3c-b129-e046a9704766")
    IReferenceIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ LPWSTR *ppszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [unique][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAttributes( 
            /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ SIZE_T cDeltas,
            /* [size_is][in] */ const IDENTITY_ATTRIBUTE rgDeltas[  ],
            /* [retval][out] */ IReferenceIdentity **ppIReferenceIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IReferenceIdentity * This,
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ LPWSTR *ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IReferenceIdentity * This,
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [unique][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAttributes )( 
            IReferenceIdentity * This,
            /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IReferenceIdentity * This,
            /* [in] */ SIZE_T cDeltas,
            /* [size_is][in] */ const IDENTITY_ATTRIBUTE rgDeltas[  ],
            /* [retval][out] */ IReferenceIdentity **ppIReferenceIdentity);
        
        END_INTERFACE
    } IReferenceIdentityVtbl;

    interface IReferenceIdentity
    {
        CONST_VTBL struct IReferenceIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReferenceIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReferenceIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReferenceIdentity_GetAttribute(This,pszNamespace,pszName,ppszValue)	\
    (This)->lpVtbl -> GetAttribute(This,pszNamespace,pszName,ppszValue)

#define IReferenceIdentity_SetAttribute(This,pszNamespace,pszName,pszValue)	\
    (This)->lpVtbl -> SetAttribute(This,pszNamespace,pszName,pszValue)

#define IReferenceIdentity_EnumAttributes(This,ppIEnumIDENTITY_ATTRIBUTE)	\
    (This)->lpVtbl -> EnumAttributes(This,ppIEnumIDENTITY_ATTRIBUTE)

#define IReferenceIdentity_Clone(This,cDeltas,rgDeltas,ppIReferenceIdentity)	\
    (This)->lpVtbl -> Clone(This,cDeltas,rgDeltas,ppIReferenceIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReferenceIdentity_GetAttribute_Proxy( 
    IReferenceIdentity * This,
    /* [unique][in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ LPWSTR *ppszValue);


void __RPC_STUB IReferenceIdentity_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceIdentity_SetAttribute_Proxy( 
    IReferenceIdentity * This,
    /* [unique][in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszName,
    /* [unique][in] */ LPCWSTR pszValue);


void __RPC_STUB IReferenceIdentity_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceIdentity_EnumAttributes_Proxy( 
    IReferenceIdentity * This,
    /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE);


void __RPC_STUB IReferenceIdentity_EnumAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceIdentity_Clone_Proxy( 
    IReferenceIdentity * This,
    /* [in] */ SIZE_T cDeltas,
    /* [size_is][in] */ const IDENTITY_ATTRIBUTE rgDeltas[  ],
    /* [retval][out] */ IReferenceIdentity **ppIReferenceIdentity);


void __RPC_STUB IReferenceIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReferenceIdentity_INTERFACE_DEFINED__ */


#ifndef __IDefinitionIdentity_INTERFACE_DEFINED__
#define __IDefinitionIdentity_INTERFACE_DEFINED__

/* interface IDefinitionIdentity */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDefinitionIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587bf538-4d90-4a3c-9ef1-58a200a8a9e7")
    IDefinitionIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ LPWSTR *ppszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [unique][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAttributes( 
            /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEAIA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ SIZE_T cDeltas,
            /* [size_is][in] */ const IDENTITY_ATTRIBUTE prgDeltas[  ],
            /* [retval][out] */ IDefinitionIdentity **ppIDefinitionIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefinitionIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDefinitionIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDefinitionIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDefinitionIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IDefinitionIdentity * This,
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ LPWSTR *ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IDefinitionIdentity * This,
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [unique][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAttributes )( 
            IDefinitionIdentity * This,
            /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEAIA);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDefinitionIdentity * This,
            /* [in] */ SIZE_T cDeltas,
            /* [size_is][in] */ const IDENTITY_ATTRIBUTE prgDeltas[  ],
            /* [retval][out] */ IDefinitionIdentity **ppIDefinitionIdentity);
        
        END_INTERFACE
    } IDefinitionIdentityVtbl;

    interface IDefinitionIdentity
    {
        CONST_VTBL struct IDefinitionIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefinitionIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDefinitionIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDefinitionIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDefinitionIdentity_GetAttribute(This,pszNamespace,pszName,ppszValue)	\
    (This)->lpVtbl -> GetAttribute(This,pszNamespace,pszName,ppszValue)

#define IDefinitionIdentity_SetAttribute(This,pszNamespace,pszName,pszValue)	\
    (This)->lpVtbl -> SetAttribute(This,pszNamespace,pszName,pszValue)

#define IDefinitionIdentity_EnumAttributes(This,ppIEAIA)	\
    (This)->lpVtbl -> EnumAttributes(This,ppIEAIA)

#define IDefinitionIdentity_Clone(This,cDeltas,prgDeltas,ppIDefinitionIdentity)	\
    (This)->lpVtbl -> Clone(This,cDeltas,prgDeltas,ppIDefinitionIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDefinitionIdentity_GetAttribute_Proxy( 
    IDefinitionIdentity * This,
    /* [unique][in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ LPWSTR *ppszValue);


void __RPC_STUB IDefinitionIdentity_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionIdentity_SetAttribute_Proxy( 
    IDefinitionIdentity * This,
    /* [unique][in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszName,
    /* [unique][in] */ LPCWSTR pszValue);


void __RPC_STUB IDefinitionIdentity_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionIdentity_EnumAttributes_Proxy( 
    IDefinitionIdentity * This,
    /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEAIA);


void __RPC_STUB IDefinitionIdentity_EnumAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionIdentity_Clone_Proxy( 
    IDefinitionIdentity * This,
    /* [in] */ SIZE_T cDeltas,
    /* [size_is][in] */ const IDENTITY_ATTRIBUTE prgDeltas[  ],
    /* [retval][out] */ IDefinitionIdentity **ppIDefinitionIdentity);


void __RPC_STUB IDefinitionIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDefinitionIdentity_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_isolation_0320 */
/* [local] */ 

typedef struct _IDENTITY_ATTRIBUTE_BLOB
    {
    DWORD ofsNamespace;
    DWORD ofsName;
    DWORD ofsValue;
    } 	IDENTITY_ATTRIBUTE_BLOB;

typedef struct _IDENTITY_ATTRIBUTE_BLOB *PIDENTITY_ATTRIBUTE_BLOB;



extern RPC_IF_HANDLE __MIDL_itf_isolation_0320_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_isolation_0320_v0_0_s_ifspec;

#ifndef __IEnumIDENTITY_ATTRIBUTE_INTERFACE_DEFINED__
#define __IEnumIDENTITY_ATTRIBUTE_INTERFACE_DEFINED__

/* interface IEnumIDENTITY_ATTRIBUTE */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumIDENTITY_ATTRIBUTE;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9cdaae75-246e-4b00-a26d-b9aec137a3eb")
    IEnumIDENTITY_ATTRIBUTE : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDENTITY_ATTRIBUTE rgAttributes[  ],
            /* [optional][out] */ ULONG *pceltWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CurrentIntoBuffer( 
            /* [in] */ SIZE_T cbAvailable,
            /* [length_is][size_is][out][in] */ BYTE pbData[  ],
            /* [out] */ SIZE_T *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumIDENTITY_ATTRIBUTEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumIDENTITY_ATTRIBUTE * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumIDENTITY_ATTRIBUTE * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDENTITY_ATTRIBUTE rgAttributes[  ],
            /* [optional][out] */ ULONG *pceltWritten);
        
        HRESULT ( STDMETHODCALLTYPE *CurrentIntoBuffer )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [in] */ SIZE_T cbAvailable,
            /* [length_is][size_is][out][in] */ BYTE pbData[  ],
            /* [out] */ SIZE_T *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumIDENTITY_ATTRIBUTE * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE);
        
        END_INTERFACE
    } IEnumIDENTITY_ATTRIBUTEVtbl;

    interface IEnumIDENTITY_ATTRIBUTE
    {
        CONST_VTBL struct IEnumIDENTITY_ATTRIBUTEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumIDENTITY_ATTRIBUTE_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumIDENTITY_ATTRIBUTE_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumIDENTITY_ATTRIBUTE_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumIDENTITY_ATTRIBUTE_Next(This,celt,rgAttributes,pceltWritten)	\
    (This)->lpVtbl -> Next(This,celt,rgAttributes,pceltWritten)

#define IEnumIDENTITY_ATTRIBUTE_CurrentIntoBuffer(This,cbAvailable,pbData,pcbUsed)	\
    (This)->lpVtbl -> CurrentIntoBuffer(This,cbAvailable,pbData,pcbUsed)

#define IEnumIDENTITY_ATTRIBUTE_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumIDENTITY_ATTRIBUTE_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumIDENTITY_ATTRIBUTE_Clone(This,ppIEnumIDENTITY_ATTRIBUTE)	\
    (This)->lpVtbl -> Clone(This,ppIEnumIDENTITY_ATTRIBUTE)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_Next_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDENTITY_ATTRIBUTE rgAttributes[  ],
    /* [optional][out] */ ULONG *pceltWritten);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_CurrentIntoBuffer_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This,
    /* [in] */ SIZE_T cbAvailable,
    /* [length_is][size_is][out][in] */ BYTE pbData[  ],
    /* [out] */ SIZE_T *pcbUsed);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_CurrentIntoBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_Skip_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_Reset_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_Clone_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This,
    /* [out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumIDENTITY_ATTRIBUTE_INTERFACE_DEFINED__ */


#ifndef __IEnumDefinitionIdentity_INTERFACE_DEFINED__
#define __IEnumDefinitionIdentity_INTERFACE_DEFINED__

/* interface IEnumDefinitionIdentity */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDefinitionIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f3549d9c-fc73-4793-9c00-1cd204254c0c")
    IEnumDefinitionIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDefinitionIdentity *rgpIDefinitionIdentity[  ],
            /* [out] */ ULONG *pceltWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDefinitionIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDefinitionIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDefinitionIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDefinitionIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDefinitionIdentity * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDefinitionIdentity *rgpIDefinitionIdentity[  ],
            /* [out] */ ULONG *pceltWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDefinitionIdentity * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDefinitionIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDefinitionIdentity * This,
            /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity);
        
        END_INTERFACE
    } IEnumDefinitionIdentityVtbl;

    interface IEnumDefinitionIdentity
    {
        CONST_VTBL struct IEnumDefinitionIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDefinitionIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDefinitionIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDefinitionIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDefinitionIdentity_Next(This,celt,rgpIDefinitionIdentity,pceltWritten)	\
    (This)->lpVtbl -> Next(This,celt,rgpIDefinitionIdentity,pceltWritten)

#define IEnumDefinitionIdentity_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDefinitionIdentity_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDefinitionIdentity_Clone(This,ppIEnumDefinitionIdentity)	\
    (This)->lpVtbl -> Clone(This,ppIEnumDefinitionIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDefinitionIdentity_Next_Proxy( 
    IEnumDefinitionIdentity * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDefinitionIdentity *rgpIDefinitionIdentity[  ],
    /* [out] */ ULONG *pceltWritten);


void __RPC_STUB IEnumDefinitionIdentity_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDefinitionIdentity_Skip_Proxy( 
    IEnumDefinitionIdentity * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDefinitionIdentity_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDefinitionIdentity_Reset_Proxy( 
    IEnumDefinitionIdentity * This);


void __RPC_STUB IEnumDefinitionIdentity_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDefinitionIdentity_Clone_Proxy( 
    IEnumDefinitionIdentity * This,
    /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity);


void __RPC_STUB IEnumDefinitionIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDefinitionIdentity_INTERFACE_DEFINED__ */


#ifndef __IEnumReferenceIdentity_INTERFACE_DEFINED__
#define __IEnumReferenceIdentity_INTERFACE_DEFINED__

/* interface IEnumReferenceIdentity */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumReferenceIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b30352cf-23da-4577-9b3f-b4e6573be53b")
    IEnumReferenceIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IReferenceIdentity **prgpIReferenceIdentity,
            /* [out] */ ULONG *pceltWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            IEnumReferenceIdentity **ppIEnumReferenceIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumReferenceIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumReferenceIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumReferenceIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumReferenceIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumReferenceIdentity * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IReferenceIdentity **prgpIReferenceIdentity,
            /* [out] */ ULONG *pceltWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumReferenceIdentity * This,
            ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumReferenceIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumReferenceIdentity * This,
            IEnumReferenceIdentity **ppIEnumReferenceIdentity);
        
        END_INTERFACE
    } IEnumReferenceIdentityVtbl;

    interface IEnumReferenceIdentity
    {
        CONST_VTBL struct IEnumReferenceIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumReferenceIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumReferenceIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumReferenceIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumReferenceIdentity_Next(This,celt,prgpIReferenceIdentity,pceltWritten)	\
    (This)->lpVtbl -> Next(This,celt,prgpIReferenceIdentity,pceltWritten)

#define IEnumReferenceIdentity_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumReferenceIdentity_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumReferenceIdentity_Clone(This,ppIEnumReferenceIdentity)	\
    (This)->lpVtbl -> Clone(This,ppIEnumReferenceIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumReferenceIdentity_Next_Proxy( 
    IEnumReferenceIdentity * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IReferenceIdentity **prgpIReferenceIdentity,
    /* [out] */ ULONG *pceltWritten);


void __RPC_STUB IEnumReferenceIdentity_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumReferenceIdentity_Skip_Proxy( 
    IEnumReferenceIdentity * This,
    ULONG celt);


void __RPC_STUB IEnumReferenceIdentity_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumReferenceIdentity_Reset_Proxy( 
    IEnumReferenceIdentity * This);


void __RPC_STUB IEnumReferenceIdentity_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumReferenceIdentity_Clone_Proxy( 
    IEnumReferenceIdentity * This,
    IEnumReferenceIdentity **ppIEnumReferenceIdentity);


void __RPC_STUB IEnumReferenceIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumReferenceIdentity_INTERFACE_DEFINED__ */


#ifndef __IDefinitionAppId_INTERFACE_DEFINED__
#define __IDefinitionAppId_INTERFACE_DEFINED__

/* interface IDefinitionAppId */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDefinitionAppId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d91e12d8-98ed-47fa-9936-39421283d59b")
    IDefinitionAppId : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SubscriptionId( 
            /* [retval][out] */ LPWSTR *ppszSubscription) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SubscriptionId( 
            /* [in] */ LPCWSTR pszSubscription) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Codebase( 
            /* [retval][out] */ LPWSTR *ppszCodebase) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Codebase( 
            /* [in] */ LPCWSTR pszCodebase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAppPath( 
            /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppPath( 
            /* [in] */ ULONG cIDefinitionIdentity,
            /* [size_is][in] */ IDefinitionIdentity *rgIDefinitionIdentity[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefinitionAppIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDefinitionAppId * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDefinitionAppId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDefinitionAppId * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubscriptionId )( 
            IDefinitionAppId * This,
            /* [retval][out] */ LPWSTR *ppszSubscription);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SubscriptionId )( 
            IDefinitionAppId * This,
            /* [in] */ LPCWSTR pszSubscription);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Codebase )( 
            IDefinitionAppId * This,
            /* [retval][out] */ LPWSTR *ppszCodebase);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Codebase )( 
            IDefinitionAppId * This,
            /* [in] */ LPCWSTR pszCodebase);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAppPath )( 
            IDefinitionAppId * This,
            /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppPath )( 
            IDefinitionAppId * This,
            /* [in] */ ULONG cIDefinitionIdentity,
            /* [size_is][in] */ IDefinitionIdentity *rgIDefinitionIdentity[  ]);
        
        END_INTERFACE
    } IDefinitionAppIdVtbl;

    interface IDefinitionAppId
    {
        CONST_VTBL struct IDefinitionAppIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefinitionAppId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDefinitionAppId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDefinitionAppId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDefinitionAppId_get_SubscriptionId(This,ppszSubscription)	\
    (This)->lpVtbl -> get_SubscriptionId(This,ppszSubscription)

#define IDefinitionAppId_put_SubscriptionId(This,pszSubscription)	\
    (This)->lpVtbl -> put_SubscriptionId(This,pszSubscription)

#define IDefinitionAppId_get_Codebase(This,ppszCodebase)	\
    (This)->lpVtbl -> get_Codebase(This,ppszCodebase)

#define IDefinitionAppId_put_Codebase(This,pszCodebase)	\
    (This)->lpVtbl -> put_Codebase(This,pszCodebase)

#define IDefinitionAppId_EnumAppPath(This,ppIEnumDefinitionIdentity)	\
    (This)->lpVtbl -> EnumAppPath(This,ppIEnumDefinitionIdentity)

#define IDefinitionAppId_SetAppPath(This,cIDefinitionIdentity,rgIDefinitionIdentity)	\
    (This)->lpVtbl -> SetAppPath(This,cIDefinitionIdentity,rgIDefinitionIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDefinitionAppId_get_SubscriptionId_Proxy( 
    IDefinitionAppId * This,
    /* [retval][out] */ LPWSTR *ppszSubscription);


void __RPC_STUB IDefinitionAppId_get_SubscriptionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDefinitionAppId_put_SubscriptionId_Proxy( 
    IDefinitionAppId * This,
    /* [in] */ LPCWSTR pszSubscription);


void __RPC_STUB IDefinitionAppId_put_SubscriptionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDefinitionAppId_get_Codebase_Proxy( 
    IDefinitionAppId * This,
    /* [retval][out] */ __deref_out_opt LPWSTR *ppszCodebase);


void __RPC_STUB IDefinitionAppId_get_Codebase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDefinitionAppId_put_Codebase_Proxy( 
    IDefinitionAppId * This,
    /* [in] */ LPCWSTR pszCodebase);


void __RPC_STUB IDefinitionAppId_put_Codebase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionAppId_EnumAppPath_Proxy( 
    IDefinitionAppId * This,
    /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity);


void __RPC_STUB IDefinitionAppId_EnumAppPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionAppId_SetAppPath_Proxy( 
    IDefinitionAppId * This,
    /* [in] */ ULONG cIDefinitionIdentity,
    /* [size_is][in] */ IDefinitionIdentity *rgIDefinitionIdentity[  ]);


void __RPC_STUB IDefinitionAppId_SetAppPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDefinitionAppId_INTERFACE_DEFINED__ */


#ifndef __IReferenceAppId_INTERFACE_DEFINED__
#define __IReferenceAppId_INTERFACE_DEFINED__

/* interface IReferenceAppId */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceAppId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("054f0bef-9e45-4363-8f5a-2f8e142d9a3b")
    IReferenceAppId : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SubscriptionId( 
            /* [retval][out] */ LPWSTR *ppszSubscription) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SubscriptionId( 
            /* [in] */ LPCWSTR pszSubscription) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Codebase( 
            /* [retval][out] */ LPWSTR *ppszCodebase) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Codebase( 
            /* [in] */ LPCWSTR pszCodebase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAppPath( 
            /* [out] */ IEnumReferenceIdentity **ppIReferenceAppId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceAppIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceAppId * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceAppId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceAppId * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubscriptionId )( 
            IReferenceAppId * This,
            /* [retval][out] */ LPWSTR *ppszSubscription);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SubscriptionId )( 
            IReferenceAppId * This,
            /* [in] */ LPCWSTR pszSubscription);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Codebase )( 
            IReferenceAppId * This,
            /* [retval][out] */ LPWSTR *ppszCodebase);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Codebase )( 
            IReferenceAppId * This,
            /* [in] */ LPCWSTR pszCodebase);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAppPath )( 
            IReferenceAppId * This,
            /* [out] */ IEnumReferenceIdentity **ppIReferenceAppId);
        
        END_INTERFACE
    } IReferenceAppIdVtbl;

    interface IReferenceAppId
    {
        CONST_VTBL struct IReferenceAppIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceAppId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReferenceAppId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReferenceAppId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReferenceAppId_get_SubscriptionId(This,ppszSubscription)	\
    (This)->lpVtbl -> get_SubscriptionId(This,ppszSubscription)

#define IReferenceAppId_put_SubscriptionId(This,pszSubscription)	\
    (This)->lpVtbl -> put_SubscriptionId(This,pszSubscription)

#define IReferenceAppId_get_Codebase(This,ppszCodebase)	\
    (This)->lpVtbl -> get_Codebase(This,ppszCodebase)

#define IReferenceAppId_put_Codebase(This,pszCodebase)	\
    (This)->lpVtbl -> put_Codebase(This,pszCodebase)

#define IReferenceAppId_EnumAppPath(This,ppIReferenceAppId)	\
    (This)->lpVtbl -> EnumAppPath(This,ppIReferenceAppId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IReferenceAppId_get_SubscriptionId_Proxy( 
    IReferenceAppId * This,
    /* [retval][out] */ LPWSTR *ppszSubscription);


void __RPC_STUB IReferenceAppId_get_SubscriptionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IReferenceAppId_put_SubscriptionId_Proxy( 
    IReferenceAppId * This,
    /* [in] */ LPCWSTR pszSubscription);


void __RPC_STUB IReferenceAppId_put_SubscriptionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IReferenceAppId_get_Codebase_Proxy( 
    IReferenceAppId * This,
    /* [retval][out] */ __deref_out_opt LPWSTR *ppszCodebase);


void __RPC_STUB IReferenceAppId_get_Codebase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IReferenceAppId_put_Codebase_Proxy( 
    IReferenceAppId * This,
    /* [in] */ LPCWSTR pszCodebase);


void __RPC_STUB IReferenceAppId_put_Codebase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceAppId_EnumAppPath_Proxy( 
    IReferenceAppId * This,
    /* [out] */ IEnumReferenceIdentity **ppIReferenceAppId);


void __RPC_STUB IReferenceAppId_EnumAppPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReferenceAppId_INTERFACE_DEFINED__ */


#ifndef __IIdentityAuthority_INTERFACE_DEFINED__
#define __IIdentityAuthority_INTERFACE_DEFINED__

/* interface IIdentityAuthority */
/* [local][unique][uuid][object] */ 

/* [v1_enum] */ 
enum _TEXT_TO_DEFINITION_IDENTITY_FLAGS
    {	TEXT_TO_DEFINITION_IDENTITY_FLAG_ALLOW_UNKNOWN_ATTRIBUTES_IN_NULL_NAMESPACE	= 0x1
    } ;
/* [v1_enum] */ 
enum _TEXT_TO_REFERENCE_IDENTITY_FLAGS
    {	TEXT_TO_REFERENCE_IDENTITY_FLAG_ALLOW_UNKNOWN_ATTRIBUTES_IN_NULL_NAMESPACE	= 0x1
    } ;
/* [v1_enum] */ 
enum _DEFINITION_IDENTITY_TO_TEXT_FLAGS
    {	DEFINITION_IDENTITY_TO_TEXT_FLAG_CANONICAL	= 0x1
    } ;
/* [v1_enum] */ 
enum _REFERENCE_IDENTITY_TO_TEXT_FLAGS
    {	REFERENCE_IDENTITY_TO_TEXT_FLAG_CANONICAL	= 0x1
    } ;
/* [v1_enum] */ 
enum _IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAGS
    {	IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAG_EXACT_MATCH_REQUIRED	= 0x1
    } ;
/* [v1_enum] */ 
enum _IIDENTITYAUTHORITY_DOES_TEXTUAL_DEFINITION_MATCH_TEXTUAL_REFERENCE_FLAGS
    {	IIDENTITYAUTHORITY_DOES_TEXTUAL_DEFINITION_MATCH_TEXTUAL_REFERENCE_FLAG_EXACT_MATCH_REQUIRED	= 0x1
    } ;

EXTERN_C const IID IID_IIdentityAuthority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("261a6983-c35d-4d0d-aa5b-7867259e77bc")
    IIdentityAuthority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TextToDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionIdentity **ppIDefinitionIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextToReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceIdentity **ppIReferenceIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinitionToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinitionToTextBuffer( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToTextBuffer( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pDefinition1,
            /* [in] */ IDefinitionIdentity *pDefinition2,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pReference1,
            /* [in] */ IReferenceIdentity *pReference2,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesDefinitionMatchReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesTextualDefinitionMatchTextualReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateDefinitionKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateReferenceKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDefinition( 
            /* [retval][out] */ IDefinitionIdentity **ppNewIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReference( 
            /* [retval][out] */ IReferenceIdentity **ppNewIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIdentityAuthorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIdentityAuthority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIdentityAuthority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIdentityAuthority * This);
        
        HRESULT ( STDMETHODCALLTYPE *TextToDefinition )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionIdentity **ppIDefinitionIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *TextToReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceIdentity **ppIReferenceIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToText )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToTextBuffer )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToText )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToTextBuffer )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired);
        
        HRESULT ( STDMETHODCALLTYPE *AreDefinitionsEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pDefinition1,
            /* [in] */ IDefinitionIdentity *pDefinition2,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreReferencesEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pReference1,
            /* [in] */ IReferenceIdentity *pReference2,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualDefinitionsEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualReferencesEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesDefinitionMatchReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *DoesTextualDefinitionMatchTextualReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *HashReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *HashDefinition )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateDefinitionKey )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateReferenceKey )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDefinition )( 
            IIdentityAuthority * This,
            /* [retval][out] */ IDefinitionIdentity **ppNewIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *CreateReference )( 
            IIdentityAuthority * This,
            /* [retval][out] */ IReferenceIdentity **ppNewIdentity);
        
        END_INTERFACE
    } IIdentityAuthorityVtbl;

    interface IIdentityAuthority
    {
        CONST_VTBL struct IIdentityAuthorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIdentityAuthority_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIdentityAuthority_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIdentityAuthority_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIdentityAuthority_TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionIdentity)	\
    (This)->lpVtbl -> TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionIdentity)

#define IIdentityAuthority_TextToReference(This,dwFlags,pszIdentity,ppIReferenceIdentity)	\
    (This)->lpVtbl -> TextToReference(This,dwFlags,pszIdentity,ppIReferenceIdentity)

#define IIdentityAuthority_DefinitionToText(This,dwFlags,pIDefinitionIdentity,ppszFormattedIdentity)	\
    (This)->lpVtbl -> DefinitionToText(This,dwFlags,pIDefinitionIdentity,ppszFormattedIdentity)

#define IIdentityAuthority_DefinitionToTextBuffer(This,dwFlags,pIDefinitionIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)	\
    (This)->lpVtbl -> DefinitionToTextBuffer(This,dwFlags,pIDefinitionIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)

#define IIdentityAuthority_ReferenceToText(This,dwFlags,pIReferenceIdentity,ppszFormattedIdentity)	\
    (This)->lpVtbl -> ReferenceToText(This,dwFlags,pIReferenceIdentity,ppszFormattedIdentity)

#define IIdentityAuthority_ReferenceToTextBuffer(This,dwFlags,pIReferenceIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)	\
    (This)->lpVtbl -> ReferenceToTextBuffer(This,dwFlags,pIReferenceIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)

#define IIdentityAuthority_AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfEqual)	\
    (This)->lpVtbl -> AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfEqual)

#define IIdentityAuthority_AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfEqual)	\
    (This)->lpVtbl -> AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfEqual)

#define IIdentityAuthority_AreTextualDefinitionsEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)	\
    (This)->lpVtbl -> AreTextualDefinitionsEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)

#define IIdentityAuthority_AreTextualReferencesEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)	\
    (This)->lpVtbl -> AreTextualReferencesEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)

#define IIdentityAuthority_DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)	\
    (This)->lpVtbl -> DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)

#define IIdentityAuthority_DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)	\
    (This)->lpVtbl -> DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)

#define IIdentityAuthority_HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)

#define IIdentityAuthority_HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)

#define IIdentityAuthority_GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)

#define IIdentityAuthority_GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)

#define IIdentityAuthority_CreateDefinition(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateDefinition(This,ppNewIdentity)

#define IIdentityAuthority_CreateReference(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateReference(This,ppNewIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIdentityAuthority_TextToDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IDefinitionIdentity **ppIDefinitionIdentity);


void __RPC_STUB IIdentityAuthority_TextToDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_TextToReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IReferenceIdentity **ppIReferenceIdentity);


void __RPC_STUB IIdentityAuthority_TextToReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DefinitionToText_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IIdentityAuthority_DefinitionToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DefinitionToTextBuffer_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [in] */ ULONG cchBufferSize,
    /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
    /* [out] */ ULONG *pcchBufferRequired);


void __RPC_STUB IIdentityAuthority_DefinitionToTextBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_ReferenceToText_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IIdentityAuthority_ReferenceToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_ReferenceToTextBuffer_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [in] */ ULONG cchBufferSize,
    /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
    /* [out] */ ULONG *pcchBufferRequired);


void __RPC_STUB IIdentityAuthority_ReferenceToTextBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreDefinitionsEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pDefinition1,
    /* [in] */ IDefinitionIdentity *pDefinition2,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreReferencesEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pReference1,
    /* [in] */ IReferenceIdentity *pReference2,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreTextualDefinitionsEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentityLeft,
    /* [in] */ LPCWSTR pszIdentityRight,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreTextualDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreTextualReferencesEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentityLeft,
    /* [in] */ LPCWSTR pszIdentityRight,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreTextualReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DoesDefinitionMatchReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IIdentityAuthority_DoesDefinitionMatchReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DoesTextualDefinitionMatchTextualReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszDefinition,
    /* [in] */ LPCWSTR pszReference,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IIdentityAuthority_DoesTextualDefinitionMatchTextualReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_HashReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IIdentityAuthority_HashReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_HashDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IIdentityAuthority_HashDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_GenerateDefinitionKey_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IIdentityAuthority_GenerateDefinitionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_GenerateReferenceKey_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IIdentityAuthority_GenerateReferenceKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_CreateDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [retval][out] */ IDefinitionIdentity **ppNewIdentity);


void __RPC_STUB IIdentityAuthority_CreateDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_CreateReference_Proxy( 
    IIdentityAuthority * This,
    /* [retval][out] */ IReferenceIdentity **ppNewIdentity);


void __RPC_STUB IIdentityAuthority_CreateReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIdentityAuthority_INTERFACE_DEFINED__ */


#ifndef __IAppIdAuthority_INTERFACE_DEFINED__
#define __IAppIdAuthority_INTERFACE_DEFINED__

/* interface IAppIdAuthority */
/* [local][unique][uuid][object] */ 

/* [v1_enum] */ 
enum IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAGS
    {	IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAG_IGNORE_VERSION	= 0x1
    } ;
/* [v1_enum] */ 
enum IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAGS
    {	IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAG_IGNORE_VERSION	= 0x1
    } ;

EXTERN_C const IID IID_IAppIdAuthority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c87810c-2541-4f75-b2d0-9af515488e23")
    IAppIdAuthority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TextToDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionAppId **ppIDefinitionAppId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextToReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceAppId **ppIReferenceAppId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinitionToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pDefinition1,
            /* [in] */ IDefinitionAppId *pDefinition2,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pReference1,
            /* [in] */ IReferenceAppId *pReference2,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesDefinitionMatchReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesTextualDefinitionMatchTextualReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateDefinitionKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateReferenceKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDefinition( 
            /* [retval][out] */ IDefinitionAppId **ppNewIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReference( 
            /* [retval][out] */ IReferenceAppId **ppNewIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppIdAuthorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppIdAuthority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppIdAuthority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppIdAuthority * This);
        
        HRESULT ( STDMETHODCALLTYPE *TextToDefinition )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionAppId **ppIDefinitionAppId);
        
        HRESULT ( STDMETHODCALLTYPE *TextToReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceAppId **ppIReferenceAppId);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToText )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToText )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *AreDefinitionsEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pDefinition1,
            /* [in] */ IDefinitionAppId *pDefinition2,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreReferencesEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pReference1,
            /* [in] */ IReferenceAppId *pReference2,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualDefinitionsEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualReferencesEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesDefinitionMatchReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *DoesTextualDefinitionMatchTextualReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *HashReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *HashDefinition )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateDefinitionKey )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateReferenceKey )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDefinition )( 
            IAppIdAuthority * This,
            /* [retval][out] */ IDefinitionAppId **ppNewIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *CreateReference )( 
            IAppIdAuthority * This,
            /* [retval][out] */ IReferenceAppId **ppNewIdentity);
        
        END_INTERFACE
    } IAppIdAuthorityVtbl;

    interface IAppIdAuthority
    {
        CONST_VTBL struct IAppIdAuthorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppIdAuthority_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppIdAuthority_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppIdAuthority_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppIdAuthority_TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionAppId)	\
    (This)->lpVtbl -> TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionAppId)

#define IAppIdAuthority_TextToReference(This,dwFlags,pszIdentity,ppIReferenceAppId)	\
    (This)->lpVtbl -> TextToReference(This,dwFlags,pszIdentity,ppIReferenceAppId)

#define IAppIdAuthority_DefinitionToText(This,dwFlags,pIDefinitionAppId,ppszFormattedIdentity)	\
    (This)->lpVtbl -> DefinitionToText(This,dwFlags,pIDefinitionAppId,ppszFormattedIdentity)

#define IAppIdAuthority_ReferenceToText(This,dwFlags,pIReferenceAppId,ppszFormattedIdentity)	\
    (This)->lpVtbl -> ReferenceToText(This,dwFlags,pIReferenceAppId,ppszFormattedIdentity)

#define IAppIdAuthority_AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfAreEqual)	\
    (This)->lpVtbl -> AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfAreEqual)

#define IAppIdAuthority_AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfAreEqual)	\
    (This)->lpVtbl -> AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfAreEqual)

#define IAppIdAuthority_AreTextualDefinitionsEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)	\
    (This)->lpVtbl -> AreTextualDefinitionsEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)

#define IAppIdAuthority_AreTextualReferencesEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)	\
    (This)->lpVtbl -> AreTextualReferencesEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)

#define IAppIdAuthority_DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)	\
    (This)->lpVtbl -> DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)

#define IAppIdAuthority_DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)	\
    (This)->lpVtbl -> DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)

#define IAppIdAuthority_HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)

#define IAppIdAuthority_HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)

#define IAppIdAuthority_GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)

#define IAppIdAuthority_GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)

#define IAppIdAuthority_CreateDefinition(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateDefinition(This,ppNewIdentity)

#define IAppIdAuthority_CreateReference(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateReference(This,ppNewIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAppIdAuthority_TextToDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IDefinitionAppId **ppIDefinitionAppId);


void __RPC_STUB IAppIdAuthority_TextToDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_TextToReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IReferenceAppId **ppIReferenceAppId);


void __RPC_STUB IAppIdAuthority_TextToReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DefinitionToText_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionAppId,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IAppIdAuthority_DefinitionToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_ReferenceToText_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceAppId,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IAppIdAuthority_ReferenceToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreDefinitionsEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pDefinition1,
    /* [in] */ IDefinitionAppId *pDefinition2,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreReferencesEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pReference1,
    /* [in] */ IReferenceAppId *pReference2,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreTextualDefinitionsEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAppIdLeft,
    /* [in] */ LPCWSTR pszAppIdRight,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreTextualDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreTextualReferencesEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAppIdLeft,
    /* [in] */ LPCWSTR pszAppIdRight,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreTextualReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DoesDefinitionMatchReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IAppIdAuthority_DoesDefinitionMatchReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DoesTextualDefinitionMatchTextualReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszDefinition,
    /* [in] */ LPCWSTR pszReference,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IAppIdAuthority_DoesTextualDefinitionMatchTextualReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_HashReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IAppIdAuthority_HashReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_HashDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IAppIdAuthority_HashDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_GenerateDefinitionKey_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IAppIdAuthority_GenerateDefinitionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_GenerateReferenceKey_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IAppIdAuthority_GenerateReferenceKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_CreateDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [retval][out] */ IDefinitionAppId **ppNewIdentity);


void __RPC_STUB IAppIdAuthority_CreateDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_CreateReference_Proxy( 
    IAppIdAuthority * This,
    /* [retval][out] */ IReferenceAppId **ppNewIdentity);


void __RPC_STUB IAppIdAuthority_CreateReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppIdAuthority_INTERFACE_DEFINED__ */


/* [local] */ HRESULT __stdcall GetAppIdAuthority( 
    /* [out] */ IAppIdAuthority **ppIAppIdAuthority);

/* [local] */ HRESULT __stdcall GetIdentityAuthority( 
    /* [out] */ IIdentityAuthority **ppIIdentityAuthority);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IsGuids.h ===
/*
 * isguids.h - Internet Shortcut GUID definitions.
 *
 * Copyright (c) Microsoft Corporation. All rights reserved.
 */


/* GUIDs
 ********/

#pragma once

#ifndef _ISGUIDS_H_
#define _ISGUIDS_H_

DEFINE_GUID(CLSID_InternetShortcut,       0xFBF23B40L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);

DEFINE_GUID(IID_IUniformResourceLocatorA, 0xFBF23B80L, 0xE3F0, 0x101B, 0x84, 0x88, 0x00, 0xAA, 0x00, 0x3E, 0x56, 0xF8);
DEFINE_GUID(IID_IUniformResourceLocatorW, 0xCABB0DA0L, 0xDA57, 0x11CF, 0x99, 0x74, 0x00, 0x20, 0xAF, 0xD7, 0x97, 0x62);

#ifdef UNICODE
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorW
#else
#define IID_IUniformResourceLocator     IID_IUniformResourceLocatorA
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ipxsap.h ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    ipxsap.h

Abstract:

    This module contains the definitions of the:

    interface management APIs structures
    sap global management APIs structures
    sap MIB management APIs structures

Author:

    Stefan Solomon  06/30/1995

Revision History:


--*/

#ifndef _IPXSAP_
#define _IPXSAP_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ipxconst.h>

typedef struct _SAP_GLOBAL_INFO {
    DWORD       EventLogMask;
} SAP_GLOBAL_INFO, *PSAP_GLOBAL_INFO;

//********************************************************************
//								     *
//		    SAP Configuration Information		     *
//								     *
//********************************************************************

//*** SAP Interface Configuration Information ***

typedef struct _SAP_IF_INFO {

    ULONG	    AdminState;  // The desired state of the interface
    ULONG	    UpdateMode;	// SAP update mechanism used on this interface
    ULONG	    PacketType;  // The SAP packet type used on this interface
    ULONG	    Supply; // Send SAP updates on this interface
    ULONG	    Listen; // Listen to SAP updates on this interface
    ULONG	    GetNearestServerReply; // Reply to GetNearestServer
    ULONG	    PeriodicUpdateInterval; // in seconds - default 60
    ULONG	    AgeIntervalMultiplier; // default 3

    } SAP_IF_INFO, *PSAP_IF_INFO;

// UpdateMode Values:
//
// This parameter controls the SAP	database update on this interface.
//
// If this is a LAN interface, use IPX_PERIODIC_UPDATE as default.
// If this is a WAN router interface with static routes, use IPX_NO_UPDATE as default.
// If you want to trigger an update on this interface and to keep the data
// as static data, use IPX_AUTO_STATIC value.
// IPX_AUTO_STATIC update can be set only on a WAN interface
//
// PacketType Default Values:
//
// If UpdateMode is set to IPX_NO_UPDATE, this field is meaningless.
// If this is a LAN interface, use IPX_STANDARD_PACKET_TYPE as default.
// If you want reliable delivery of the update data in a triggered update,
// use IPX_RELIABLE_DELIVERY_PACKET_TYPE (this can be set only in combination with
// IPX_AUTO_STATIC_UPDATE in the UpdateMode).


// IPX Service Filter Info
//

typedef struct _SAP_SERVICE_FILTER_INFO {
    union {
        USHORT	    ServiceType;
        ULONG       ServiceType_align;  // Ensures aligment
        };
    UCHAR	    ServiceName[48];
    } SAP_SERVICE_FILTER_INFO, *PSAP_SERVICE_FILTER_INFO;

// ServiceType - a wildcard (0xFFFF) means any type.

// ServiceName - (1-47)chars service name. A null byte as the first byte
// signifies ANY server of this type

//*** SAP Filters Only Information ***

typedef struct _SAP_IF_FILTERS {

    ULONG		    SupplyFilterAction;
    ULONG		    SupplyFilterCount;
    ULONG		    ListenFilterAction;
    ULONG		    ListenFilterCount;
    SAP_SERVICE_FILTER_INFO ServiceFilter[1];

    } SAP_IF_FILTERS, *PSAP_IF_FILTERS;

// FilterAction -

#define IPX_SERVICE_FILTER_PERMIT	    1
#define IPX_SERVICE_FILTER_DENY 	    2

//
//*** SAP Interface Configuration Information ***
//
// This structure is passed in AddInterface and SetInterface Entry Points
//

typedef struct _SAP_IF_CONFIG {

    SAP_IF_INFO	    SapIfInfo;
    SAP_IF_FILTERS  SapIfFilters;

    } SAP_IF_CONFIG, *PSAP_IF_CONFIG;


// ***********************************************************
// ***							   ***
// ***		SAP MIB Table Identifiers		   ***
// ***							   ***
// ***********************************************************


#define SAP_BASE_ENTRY			    0
#define SAP_INTERFACE_TABLE		    1

//************************************************************
//							     *
//		SAP MIB Basic Structures		     *
//							     *
//************************************************************

//
// SAP MIB Base Entry
//

typedef struct _SAP_MIB_BASE {

    ULONG	    SapOperState;

    } SAP_MIB_BASE, *PSAP_MIB_BASE;


//
// SAP MIB Interface Table Entry
//

typedef struct _SAP_IF_STATS {

    ULONG		    SapIfOperState;   // up, down or sleeping
    ULONG		    SapIfInputPackets;
    ULONG		    SapIfOutputPackets;

    } SAP_IF_STATS, *PSAP_IF_STATS;


typedef struct _SAP_INTERFACE {

    ULONG	    InterfaceIndex;
    SAP_IF_INFO	    SapIfInfo;
    SAP_IF_STATS    SapIfStats;

    } SAP_INTERFACE, *PSAP_INTERFACE;

//***************************************************************
//								*
//	     INPUT DATA For: Get, GetFirst, GetNext		*
//								*
//***************************************************************

typedef struct _SAP_MIB_GET_INPUT_DATA {

    ULONG		TableId;
    ULONG		InterfaceIndex;

    } SAP_MIB_GET_INPUT_DATA, *PSAP_MIB_GET_INPUT_DATA;

//***************************************************************
//								*
//	     INPUT DATA For: Create, Delete, Set		*
//								*
//***************************************************************

typedef struct _SAP_MIB_SET_INPUT_DATA {

    ULONG				TableId;
	SAP_INTERFACE		SapInterface;
    } SAP_MIB_SET_INPUT_DATA, *PSAP_MIB_SET_INPUT_DATA;

//
// ***			SAP Base Entry					***
//

// MIB Functions: Get

// INPUT DATA: SAP_MIB_GET_INPUT_DATA and Index is not used

// OUTPUT DATA: SAP_INTERFACE

//
// ***			SAP Interface Table				    ***
//

// MIB Functions: Get, GetFirst, GetNext, Set

// INPUT DATA: SAP_MIB_GET_INPUT_DATA for Get, GetFirst and GetNext
//	       SAP_MIB_SET_INPUT_DATA for Set

//
// OUTPUT DATA: SAP_INTERFACE
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IssPer16.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-1999.
//
//  File:      issperr.h
//
//  Contents:  Constant definitions for OLE HRESULT values.
//
//  History:   dd-mmm-yy Author    Comment
//
//  Notes:
//     This is a generated file. Do not modify directly.
//     The MC tool generates this file from dsyserr.mc
//
//--------------------------------------------------------------------------
#ifndef _ISSPERR_H_
#define _ISSPERR_H_
#if _MSC_VER > 1000
#pragma once
#endif

// Define the status type.

#ifdef FACILITY_SECURITY
#undef FACILITY_SECURITY
#endif

#ifdef STATUS_SEVERITY_SUCCESS
#undef STATUS_SEVERITY_SUCCESS
#endif
//#ifdef STATUS_SEVERITY_ERROR
//#undef STATUS_SEVERITY_ERROR
//#endif

// Define the severities
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SECURITY                0x9
#define FACILITY_NULL                    0


//
// Define the severity codes
//
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_COERROR          0x2


//
// MessageId: SEC_E_INSUFFICIENT_MEMORY
//
// MessageText:
//
//  Not enough memory is available to complete this request
//
#define SEC_E_INSUFFICIENT_MEMORY        ((SECURITY_STATUS)0x1300)

//
// MessageId: SEC_E_INVALID_HANDLE
//
// MessageText:
//
//  The handle specified is invalid
//
#define SEC_E_INVALID_HANDLE             ((SECURITY_STATUS)0x1301)

//
// MessageId: SEC_E_UNSUPPORTED_FUNCTION
//
// MessageText:
//
//  The function requested is not supported
//
#define SEC_E_UNSUPPORTED_FUNCTION       ((SECURITY_STATUS)0x1302)


//
// MessageId: SEC_E_TARGET_UNKNOWN
//
// MessageText:
//
//  The specified target is unknown or unreachable
//
#define SEC_E_TARGET_UNKNOWN             ((SECURITY_STATUS)0x1303)

//
// MessageId: SEC_E_INTERNAL_ERROR
//
// MessageText:
//
//  The Local Security Authority cannot be contacted
//
#define SEC_E_INTERNAL_ERROR             ((SECURITY_STATUS)0x1304)

//
// MessageId: SEC_E_SECPKG_NOT_FOUND
//
// MessageText:
//
//  The requested security package does not exist
//
#define SEC_E_SECPKG_NOT_FOUND           ((SECURITY_STATUS)0x1305)


//
// MessageId: SEC_E_NOT_OWNER
//
// MessageText:
//
//  The caller is not the owner of the desired credentials
//
#define SEC_E_NOT_OWNER                  ((SECURITY_STATUS)0x1306)

//
// MessageId: SEC_E_CANNOT_INSTALL
//
// MessageText:
//
//  The security package failed to initialize, and cannot be installed
//
#define SEC_E_CANNOT_INSTALL             ((SECURITY_STATUS)0x1307)

//
// MessageId: SEC_E_INVALID_TOKEN
//
// MessageText:
//
//  The token supplied to the function is invalid
//
#define SEC_E_INVALID_TOKEN              ((SECURITY_STATUS)0x1308)

//
// MessageId: SEC_E_CANNOT_PACK
//
// MessageText:
//
//  The security package is not able to marshall the logon buffer,
//  so the logon attempt has failed
//
#define SEC_E_CANNOT_PACK                ((SECURITY_STATUS)0x1309)

//
// MessageId: SEC_E_QOP_NOT_SUPPORTED
//
// MessageText:
//
//  The per-message Quality of Protection is not supported by the
//  security package
//
#define SEC_E_QOP_NOT_SUPPORTED          ((SECURITY_STATUS)0x130A)

//
// MessageId: SEC_E_NO_IMPERSONATION
//
// MessageText:
//
//  The security context does not allow impersonation of the client
//
#define SEC_E_NO_IMPERSONATION           ((SECURITY_STATUS)0x130B)

//
// MessageId: SEC_E_LOGON_DENIED
//
// MessageText:
//
//  The logon attempt failed
//
#define SEC_E_LOGON_DENIED               ((SECURITY_STATUS)0x130C)

//
// MessageId: SEC_E_UNKNOWN_CREDENTIALS
//
// MessageText:
//
//  The credentials supplied to the package were not
//  recognized
//
#define SEC_E_UNKNOWN_CREDENTIALS        ((SECURITY_STATUS)0x130D)

//
// MessageId: SEC_E_NO_CREDENTIALS
//
// MessageText:
//
//  No credentials are available in the security package
//
#define SEC_E_NO_CREDENTIALS             ((SECURITY_STATUS)0x130E)

//
// MessageId: SEC_E_MESSAGE_ALTERED
//
// MessageText:
//
//  The message supplied for verification has been altered
//
#define SEC_E_MESSAGE_ALTERED            ((SECURITY_STATUS)0x130F)

//
// MessageId: SEC_E_OUT_OF_SEQUENCE
//
// MessageText:
//
//  The message supplied for verification is out of sequence
//
#define SEC_E_OUT_OF_SEQUENCE            ((SECURITY_STATUS)0x1310)

//
// MessageId: SEC_E_NO_AUTHENTICATING_AUTHORITY
//
// MessageText:
//
//  No authority could be contacted for authentication.
//
#define SEC_E_NO_AUTHENTICATING_AUTHORITY ((SECURITY_STATUS)0x1311)

// MessageId: SEC_E_CONTEXT_EXPIRED
//
// MessageText:
//
//  The context has expired and can no longer be used.
//
#define SEC_E_CONTEXT_EXPIRED            ((SECURITY_STATUS)0x1312)

//
// MessageId: SEC_E_INCOMPLETE_MESSAGE
//
// MessageText:
//
//  The supplied message is incomplete.  The signature was not verified.
//
#define SEC_E_INCOMPLETE_MESSAGE         ((SECURITY_STATUS)0x1313)

//
// MessageId: SEC_I_CONTINUE_NEEDED
//
// MessageText:
//
//  The function completed successfully, but must be called
//  again to complete the context
//
#define SEC_I_CONTINUE_NEEDED            ((SECURITY_STATUS)0x1012)

//
// MessageId: SEC_I_COMPLETE_NEEDED
//
// MessageText:
//
//  The function completed successfully, but CompleteToken
//  must be called
//
#define SEC_I_COMPLETE_NEEDED            ((SECURITY_STATUS)0x1013)

//
// MessageId: SEC_I_COMPLETE_AND_CONTINUE
//
// MessageText:
//
//  The function completed successfully, but both CompleteToken
//  and this function must be called to complete the context
//
#define SEC_I_COMPLETE_AND_CONTINUE      ((SECURITY_STATUS)0x1014)

//
// MessageId: SEC_I_LOCAL_LOGON
//
// MessageText:
//
//  The logon was completed, but no network authority was
//  available.  The logon was made using locally known information
//
#define SEC_I_LOCAL_LOGON                ((SECURITY_STATUS)0x1015)

//
// MessageId: SEC_E_OK
//
// MessageText:
//
//  Call completed successfully
//
#define SEC_E_OK                         ((SECURITY_STATUS)0x0000)

//
// Older error names for backwards compatibility
//


#define SEC_E_NOT_SUPPORTED              SEC_E_UNSUPPORTED_FUNCTION
#define SEC_E_NO_SPM                     SEC_E_INTERNAL_ERROR
#define SEC_E_BAD_PKGID                  SEC_E_SECPKG_NOT_FOUND


#endif // _ISSPERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\iscsierr.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iscsierr.h

Abstract:

    Constant definitions for the IScsi discover error codes

Revision History:

--*/

#ifndef _ISCSIERR_
#define _ISCSIERR_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Error status code for ISCSI discovery apis. Error codes can be a 
// standard Windows error code as defined in Winerror.h or one of the
// iscsi discovery specific error codes defined below.
//
#ifndef MOFCOMP_PASS
typedef ULONG ISDSC_STATUS;
#endif

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: ISDSC_NON_SPECIFIC_ERROR
//
// MessageText:
//
// A non specific error occurred.
//
#define ISDSC_NON_SPECIFIC_ERROR         ((ISDSC_STATUS)0xEFFF0001L)

//
// MessageId: ISDSC_LOGIN_FAILED
//
// MessageText:
//
// Login Failed.
//
#define ISDSC_LOGIN_FAILED               ((ISDSC_STATUS)0xEFFF0002L)

//
// MessageId: ISDSC_CONNECTION_FAILED
//
// MessageText:
//
// Connection Failed.
//
#define ISDSC_CONNECTION_FAILED          ((ISDSC_STATUS)0xEFFF0003L)

//
// MessageId: ISDSC_INITIATOR_NODE_ALREADY_EXISTS
//
// MessageText:
//
// Initiator Node Already Exists.
//
#define ISDSC_INITIATOR_NODE_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0004L)

//
// MessageId: ISDSC_INITIATOR_NODE_NOT_FOUND
//
// MessageText:
//
// Initiator Node Does Not Exist.
//
#define ISDSC_INITIATOR_NODE_NOT_FOUND   ((ISDSC_STATUS)0xEFFF0005L)

//
// MessageId: ISDSC_TARGET_MOVED_TEMPORARILY
//
// MessageText:
//
// Target Moved Temporarily.
//
#define ISDSC_TARGET_MOVED_TEMPORARILY   ((ISDSC_STATUS)0xEFFF0006L)

//
// MessageId: ISDSC_TARGET_MOVED_PERMANENTLY
//
// MessageText:
//
// Target Moved Permanently.
//
#define ISDSC_TARGET_MOVED_PERMANENTLY   ((ISDSC_STATUS)0xEFFF0007L)

//
// MessageId: ISDSC_INITIATOR_ERROR
//
// MessageText:
//
// Initiator Error.
//
#define ISDSC_INITIATOR_ERROR            ((ISDSC_STATUS)0xEFFF0008L)

//
// MessageId: ISDSC_AUTHENTICATION_FAILURE
//
// MessageText:
//
// Authentication Failure.
//
#define ISDSC_AUTHENTICATION_FAILURE     ((ISDSC_STATUS)0xEFFF0009L)

//
// MessageId: ISDSC_AUTHORIZATION_FAILURE
//
// MessageText:
//
// Authorization Failure.
//
#define ISDSC_AUTHORIZATION_FAILURE      ((ISDSC_STATUS)0xEFFF000AL)

//
// MessageId: ISDSC_NOT_FOUND
//
// MessageText:
//
// Not Found.
//
#define ISDSC_NOT_FOUND                  ((ISDSC_STATUS)0xEFFF000BL)

//
// MessageId: ISDSC_TARGET_REMOVED
//
// MessageText:
//
// Target Removed.
//
#define ISDSC_TARGET_REMOVED             ((ISDSC_STATUS)0xEFFF000CL)

//
// MessageId: ISDSC_UNSUPPORTED_VERSION
//
// MessageText:
//
// Unsupported Version.
//
#define ISDSC_UNSUPPORTED_VERSION        ((ISDSC_STATUS)0xEFFF000DL)

//
// MessageId: ISDSC_TOO_MANY_CONNECTIONS
//
// MessageText:
//
// Too many Connections.
//
#define ISDSC_TOO_MANY_CONNECTIONS       ((ISDSC_STATUS)0xEFFF000EL)

//
// MessageId: ISDSC_MISSING_PARAMETER
//
// MessageText:
//
// Missing Parameter.
//
#define ISDSC_MISSING_PARAMETER          ((ISDSC_STATUS)0xEFFF000FL)

//
// MessageId: ISDSC_CANT_INCLUDE_IN_SESSION
//
// MessageText:
//
// Can not include in session.
//
#define ISDSC_CANT_INCLUDE_IN_SESSION    ((ISDSC_STATUS)0xEFFF0010L)

//
// MessageId: ISDSC_SESSION_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// Session type not supported.
//
#define ISDSC_SESSION_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0011L)

//
// MessageId: ISDSC_TARGET_ERROR
//
// MessageText:
//
// Target Error.
//
#define ISDSC_TARGET_ERROR               ((ISDSC_STATUS)0xEFFF0012L)

//
// MessageId: ISDSC_SERVICE_UNAVAILABLE
//
// MessageText:
//
// Service Unavailable.
//
#define ISDSC_SERVICE_UNAVAILABLE        ((ISDSC_STATUS)0xEFFF0013L)

//
// MessageId: ISDSC_OUT_OF_RESOURCES
//
// MessageText:
//
// Out of Resources.
//
#define ISDSC_OUT_OF_RESOURCES           ((ISDSC_STATUS)0xEFFF0014L)

//
// MessageId: ISDSC_CONNECTION_ALREADY_EXISTS
//
// MessageText:
//
// Connections already exist on initiator node.
//
#define ISDSC_CONNECTION_ALREADY_EXISTS  ((ISDSC_STATUS)0xEFFF0015L)

//
// MessageId: ISDSC_SESSION_ALREADY_EXISTS
//
// MessageText:
//
// Session Already Exists.
//
#define ISDSC_SESSION_ALREADY_EXISTS     ((ISDSC_STATUS)0xEFFF0016L)

//
// MessageId: ISDSC_INITIATOR_INSTANCE_NOT_FOUND
//
// MessageText:
//
// Initiator Instance Does Not Exist.
//
#define ISDSC_INITIATOR_INSTANCE_NOT_FOUND ((ISDSC_STATUS)0xEFFF0017L)

//
// MessageId: ISDSC_TARGET_ALREADY_EXISTS
//
// MessageText:
//
// Target Already Exists.
//
#define ISDSC_TARGET_ALREADY_EXISTS      ((ISDSC_STATUS)0xEFFF0018L)

//
// MessageId: ISDSC_DRIVER_BUG
//
// MessageText:
//
// The iscsi driver implementation did not complete an operation correctly.
//
#define ISDSC_DRIVER_BUG                 ((ISDSC_STATUS)0xEFFF0019L)

//
// MessageId: ISDSC_INVALID_TEXT_KEY
//
// MessageText:
//
// An invalid key text was encountered.
//
#define ISDSC_INVALID_TEXT_KEY           ((ISDSC_STATUS)0xEFFF001AL)

//
// MessageId: ISDSC_INVALID_SENDTARGETS_TEXT
//
// MessageText:
//
// Invalid SendTargets response text was encountered.
//
#define ISDSC_INVALID_SENDTARGETS_TEXT   ((ISDSC_STATUS)0xEFFF001BL)

//
// MessageId: ISDSC_INVALID_SESSION_ID
//
// MessageText:
//
// Invalid Session Id.
//
#define ISDSC_INVALID_SESSION_ID         ((ISDSC_STATUS)0xEFFF001CL)

//
// MessageId: ISDSC_SCSI_REQUEST_FAILED
//
// MessageText:
//
// The scsi request failed.
//
#define ISDSC_SCSI_REQUEST_FAILED        ((ISDSC_STATUS)0xEFFF001DL)

//
// MessageId: ISDSC_TOO_MANY_SESSIONS
//
// MessageText:
//
// Exceeded max sessions for this initiator.
//
#define ISDSC_TOO_MANY_SESSIONS          ((ISDSC_STATUS)0xEFFF001EL)

//
// MessageId: ISDSC_SESSION_BUSY
//
// MessageText:
//
// Session is busy since a request is already in progress.
//
#define ISDSC_SESSION_BUSY               ((ISDSC_STATUS)0xEFFF001FL)

//
// MessageId: ISDSC_TARGET_MAPPING_UNAVAILABLE
//
// MessageText:
//
// The target mapping requested is not available.
//
#define ISDSC_TARGET_MAPPING_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0020L)

//
// MessageId: ISDSC_ADDRESS_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The Target Address type given is not supported.
//
#define ISDSC_ADDRESS_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0021L)

//
// MessageId: ISDSC_LOGON_FAILED
//
// MessageText:
//
// Logon Failed.
//
#define ISDSC_LOGON_FAILED               ((ISDSC_STATUS)0xEFFF0022L)

//
// MessageId: ISDSC_SEND_FAILED
//
// MessageText:
//
// TCP Send Failed.
//
#define ISDSC_SEND_FAILED                ((ISDSC_STATUS)0xEFFF0023L)

//
// MessageId: ISDSC_TRANSPORT_ERROR
//
// MessageText:
//
// TCP Transport Error
//
#define ISDSC_TRANSPORT_ERROR            ((ISDSC_STATUS)0xEFFF0024L)

//
// MessageId: ISDSC_VERSION_MISMATCH
//
// MessageText:
//
// iSCSI Version Mismatch
//
#define ISDSC_VERSION_MISMATCH           ((ISDSC_STATUS)0xEFFF0025L)

//
// MessageId: ISDSC_TARGET_MAPPING_OUT_OF_RANGE
//
// MessageText:
//
// The Target Mapping Address passed is out of range for the adapter configuration.
//
#define ISDSC_TARGET_MAPPING_OUT_OF_RANGE ((ISDSC_STATUS)0xEFFF0026L)

//
// MessageId: ISDSC_TARGET_PRESHAREDKEY_UNAVAILABLE
//
// MessageText:
//
// The preshared key for the target or IKE identification payload is not available.
//
#define ISDSC_TARGET_PRESHAREDKEY_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0027L)

//
// MessageId: ISDSC_TARGET_AUTHINFO_UNAVAILABLE
//
// MessageText:
//
// The authentication information for the target is not available.
//
#define ISDSC_TARGET_AUTHINFO_UNAVAILABLE ((ISDSC_STATUS)0xEFFF0028L)

//
// MessageId: ISDSC_TARGET_NOT_FOUND
//
// MessageText:
//
// The target name is not found or is marked as hidden from login.
//
#define ISDSC_TARGET_NOT_FOUND           ((ISDSC_STATUS)0xEFFF0029L)

//
// MessageId: ISDSC_LOGIN_USER_INFO_BAD
//
// MessageText:
//
// One or more parameters specified in LoginTargetIN structure is invalid.
//
#define ISDSC_LOGIN_USER_INFO_BAD        ((ISDSC_STATUS)0xEFFF002AL)

//
// MessageId: ISDSC_TARGET_MAPPING_EXISTS
//
// MessageText:
//
// Given target mapping already exists.
//
#define ISDSC_TARGET_MAPPING_EXISTS      ((ISDSC_STATUS)0xEFFF002BL)

//
// MessageId: ISDSC_HBA_SECURITY_CACHE_FULL
//
// MessageText:
//
// The HBA security information cache is full.
//
#define ISDSC_HBA_SECURITY_CACHE_FULL    ((ISDSC_STATUS)0xEFFF002CL)

//
// MessageId: ISDSC_INVALID_PORT_NUMBER
//
// MessageText:
//
// The port number passed is not valid for the initiator.
//
#define ISDSC_INVALID_PORT_NUMBER        ((ISDSC_STATUS)0xEFFF002DL)

//
// MessageId: ISDSC_OPERATION_NOT_ALL_SUCCESS
//
// MessageText:
//
// The operation was not successful for all initiators or discovery methods.
//
#define ISDSC_OPERATION_NOT_ALL_SUCCESS  ((ISDSC_STATUS)0xAFFF002EL)

//
// MessageId: ISDSC_HBA_SECURITY_CACHE_NOT_SUPPORTED
//
// MessageText:
//
// The HBA security information cache is not supported by this adapter.
//
#define ISDSC_HBA_SECURITY_CACHE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF002FL)

//
// MessageId: ISDSC_IKE_ID_PAYLOAD_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The IKE id payload type specified is not supported.
//
#define ISDSC_IKE_ID_PAYLOAD_TYPE_NOT_SUPPORTED ((ISDSC_STATUS)0xEFFF0030L)

//
// MessageId: ISDSC_IKE_ID_PAYLOAD_INCORRECT_SIZE
//
// MessageText:
//
// The IKE id payload size specified is not correct.
//
#define ISDSC_IKE_ID_PAYLOAD_INCORRECT_SIZE ((ISDSC_STATUS)0xEFFF0031L)

//
// MessageId: ISDSC_TARGET_PORTAL_ALREADY_EXISTS
//
// MessageText:
//
// Target Portal Structure Already Exists.
//
#define ISDSC_TARGET_PORTAL_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0032L)

//
// MessageId: ISDSC_TARGET_ADDRESS_ALREADY_EXISTS
//
// MessageText:
//
// Target Address Structure Already Exists.
//
#define ISDSC_TARGET_ADDRESS_ALREADY_EXISTS ((ISDSC_STATUS)0xEFFF0033L)

//
// MessageId: ISDSC_NO_AUTH_INFO_AVAILABLE
//
// MessageText:
//
// There is no IKE authentication information available.
//
#define ISDSC_NO_AUTH_INFO_AVAILABLE     ((ISDSC_STATUS)0xEFFF0034L)

//
// MessageId: ISDSC_NO_TUNNEL_OUTER_MODE_ADDRESS
//
// MessageText:
//
// There is no tunnel mode outer address specified.
//
#define ISDSC_NO_TUNNEL_OUTER_MODE_ADDRESS ((ISDSC_STATUS)0xEFFF0035L)

//
// MessageId: ISDSC_CACHE_CORRUPTED
//
// MessageText:
//
// Authentication or tunnel address cache is corrupted.
//
#define ISDSC_CACHE_CORRUPTED            ((ISDSC_STATUS)0xEFFF0036L)

//
// MessageId: ISDSC_REQUEST_NOT_SUPPORTED
//
// MessageText:
//
// The request or operation is not supported.
//
#define ISDSC_REQUEST_NOT_SUPPORTED      ((ISDSC_STATUS)0xEFFF0037L)

//
// MessageId: ISDSC_TARGET_OUT_OF_RESORCES
//
// MessageText:
//
// The target does not have enough resources to process the given request.
//
#define ISDSC_TARGET_OUT_OF_RESORCES     ((ISDSC_STATUS)0xEFFF0038L)

//
// MessageId: ISDSC_SERVICE_DID_NOT_RESPOND
//
// MessageText:
//
// The initiator service did not respond to the request sent by the driver.
//
#define ISDSC_SERVICE_DID_NOT_RESPOND    ((ISDSC_STATUS)0xEFFF0039L)

//
// MessageId: ISDSC_ISNS_SERVER_NOT_FOUND
//
// MessageText:
//
// The Internet Storage Name Server (iSNS) server was not found or is unavailable.
//
#define ISDSC_ISNS_SERVER_NOT_FOUND      ((ISDSC_STATUS)0xEFFF003AL)

//
// MessageId: ISDSC_OPERATION_REQUIRES_REBOOT
//
// MessageText:
//
// The operation was successful but requires a driver reload or reboot to become effective.
//
#define ISDSC_OPERATION_REQUIRES_REBOOT  ((ISDSC_STATUS)0xAFFF003BL)

//
// MessageId: ISDSC_NO_PORTAL_SPECIFIED
//
// MessageText:
//
// There is no target portal available to complete the login.
//
#define ISDSC_NO_PORTAL_SPECIFIED        ((ISDSC_STATUS)0xEFFF003CL)

//
// MessageId: ISDSC_CANT_REMOVE_LAST_CONNECTION
//
// MessageText:
//
// Cannot remove the last connection for a session.
//
#define ISDSC_CANT_REMOVE_LAST_CONNECTION ((ISDSC_STATUS)0xEFFF003DL)

//
// MessageId: ISDSC_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The Microsoft iSCSI initiator service has not been started.
//
#define ISDSC_SERVICE_NOT_RUNNING        ((ISDSC_STATUS)0xEFFF003EL)

//
// MessageId: ISDSC_TARGET_ALREADY_LOGGED_IN
//
// MessageText:
//
// The target has already been logged in via an iSCSI session.
//
#define ISDSC_TARGET_ALREADY_LOGGED_IN   ((ISDSC_STATUS)0xEFFF003FL)

//
// MessageId: ISDSC_DEVICE_BUSY_ON_SESSION
//
// MessageText:
//
// The session cannot be logged out since a device on that session is currently being used.
//
#define ISDSC_DEVICE_BUSY_ON_SESSION     ((ISDSC_STATUS)0xEFFF0040L)

//
// MessageId: ISDSC_COULD_NOT_SAVE_PERSISTENT_LOGIN_DATA
//
// MessageText:
//
// Failed to save persistent login information.
//
#define ISDSC_COULD_NOT_SAVE_PERSISTENT_LOGIN_DATA ((ISDSC_STATUS)0xEFFF0041L)

//
// MessageId: ISDSC_COULD_NOT_REMOVE_PERSISTENT_LOGIN_DATA
//
// MessageText:
//
// Failed to remove persistent login information.
//
#define ISDSC_COULD_NOT_REMOVE_PERSISTENT_LOGIN_DATA ((ISDSC_STATUS)0xEFFF0042L)

//
// MessageId: ISDSC_PORTAL_NOT_FOUND
//
// MessageText:
//
// The specified portal was not found.
//
#define ISDSC_PORTAL_NOT_FOUND           ((ISDSC_STATUS)0xEFFF0043L)

//
// MessageId: ISDSC_INITIATOR_NOT_FOUND
//
// MessageText:
//
// The specified initiator name was not found.
//
#define ISDSC_INITIATOR_NOT_FOUND        ((ISDSC_STATUS)0xEFFF0044L)

//
// MessageId: ISDSC_DISCOVERY_MECHANISM_NOT_FOUND
//
// MessageText:
//
// The specified discovery mechanism was not found.
//
#define ISDSC_DISCOVERY_MECHANISM_NOT_FOUND ((ISDSC_STATUS)0xEFFF0045L)

//
// MessageId: ISDSC_IPSEC_NOT_SUPPORTED_ON_OS
//
// MessageText:
//
// iSCSI does not support IPSEC for this version of the OS.
//
#define ISDSC_IPSEC_NOT_SUPPORTED_ON_OS  ((ISDSC_STATUS)0xEFFF0046L)

//
// MessageId: ISDSC_PERSISTENT_LOGIN_TIMEOUT
//
// MessageText:
//
// The iSCSI service timed out waiting for all persistent logins to complete.
//
#define ISDSC_PERSISTENT_LOGIN_TIMEOUT   ((ISDSC_STATUS)0xEFFF0047L)

//
// MessageId: ISDSC_SHORT_CHAP_SECRET
//
// MessageText:
//
// The specified CHAP secret is less than 96 bits and will not be usable for authenticating over non ipsec connections.
//
#define ISDSC_SHORT_CHAP_SECRET          ((ISDSC_STATUS)0xAFFF0048L)

//
// MessageId: ISDSC_EVALUATION_PEROID_EXPIRED
//
// MessageText:
//
// The evaluation period for the iSCSI initiator service has expired.
//
#define ISDSC_EVALUATION_PEROID_EXPIRED  ((ISDSC_STATUS)0xEFFF0049L)

//
// MessageId: ISDSC_INVALID_CHAP_SECRET
//
// MessageText:
//
// CHAP secret given does not conform to the standard. Please see system event log for more information.
//
#define ISDSC_INVALID_CHAP_SECRET        ((ISDSC_STATUS)0xEFFF004AL)

//
// MessageId: ISDSC_INVALID_TARGET_CHAP_SECRET
//
// MessageText:
//
// Target CHAP secret given is invalid. Maximum size of CHAP secret is 16 bytes. Minimum size is 12 bytes if IPSec is not used.
//
#define ISDSC_INVALID_TARGET_CHAP_SECRET ((ISDSC_STATUS)0xEFFF004BL)

//
// MessageId: ISDSC_INVALID_INITIATOR_CHAP_SECRET
//
// MessageText:
//
// Initiator CHAP secret given is invalid. Maximum size of CHAP secret is 16 bytes. Minimum size is 12 bytes if IPSec is not used.
//
#define ISDSC_INVALID_INITIATOR_CHAP_SECRET ((ISDSC_STATUS)0xEFFF004CL)

//
// MessageId: ISDSC_INVALID_CHAP_USER_NAME
//
// MessageText:
//
// CHAP Username given is invalid.
//
#define ISDSC_INVALID_CHAP_USER_NAME     ((ISDSC_STATUS)0xEFFF004DL)

//
// MessageId: ISDSC_INVALID_LOGON_AUTH_TYPE
//
// MessageText:
//
// Logon Authentication type given is invalid.
//
#define ISDSC_INVALID_LOGON_AUTH_TYPE    ((ISDSC_STATUS)0xEFFF004EL)

//
// MessageId: ISDSC_INVALID_TARGET_MAPPING
//
// MessageText:
//
// Target Mapping information given is invalid.
//
#define ISDSC_INVALID_TARGET_MAPPING     ((ISDSC_STATUS)0xEFFF004FL)

//
// MessageId: ISDSC_INVALID_TARGET_ID
//
// MessageText:
//
// Target Id given in Target Mapping is invalid.
//
#define ISDSC_INVALID_TARGET_ID          ((ISDSC_STATUS)0xEFFF0050L)

//
// MessageId: ISDSC_INVALID_ISCSI_NAME
//
// MessageText:
//
// The iSCSI name specified contains invalid characters or is too long.
//
#define ISDSC_INVALID_ISCSI_NAME         ((ISDSC_STATUS)0xEFFF0051L)

//
// MessageId: ISDSC_INCOMPATIBLE_ISNS_VERSION
//
// MessageText:
//
// The version number returned from the Internet Storage Name Server (iSNS) server is not compatible with this version of the iSNS client.
//
#define ISDSC_INCOMPATIBLE_ISNS_VERSION  ((ISDSC_STATUS)0xEFFF0052L)

//
// MessageId: ISDSC_FAILED_TO_CONFIGURE_IPSEC
//
// MessageText:
//
// Initiator failed to configure IPSec for the given connection. This could be because of low resources.
//
#define ISDSC_FAILED_TO_CONFIGURE_IPSEC  ((ISDSC_STATUS)0xEFFF0053L)

//
// MessageId: ISDSC_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer given for processing the request is too small.
//
#define ISDSC_BUFFER_TOO_SMALL           ((ISDSC_STATUS)0xEFFF0054L)

//
// MessageId: ISDSC_INVALID_LOAD_BALANCE_POLICY
//
// MessageText:
//
// The given Load Balance policy is not recognized by iScsi initiator.
//
#define ISDSC_INVALID_LOAD_BALANCE_POLICY ((ISDSC_STATUS)0xEFFF0055L)

//
// MessageId: ISDSC_INVALID_PARAMETER
//
// MessageText:
//
// One or more paramaters specified is not valid.
//
#define ISDSC_INVALID_PARAMETER          ((ISDSC_STATUS)0xEFFF0056L)

//
// MessageId: ISDSC_DUPLICATE_PATH_SPECIFIED
//
// MessageText:
//
// Duplicate PathIds were specified in the call to set Load Balance Policy.
//
#define ISDSC_DUPLICATE_PATH_SPECIFIED   ((ISDSC_STATUS)0xEFFF0057L)

//
// MessageId: ISDSC_PATH_COUNT_MISMATCH
//
// MessageText:
//
// Number of paths specified in Set Load Balance Policy does not match the number of paths to the target.
//
#define ISDSC_PATH_COUNT_MISMATCH        ((ISDSC_STATUS)0xEFFF0058L)

//
// MessageId: ISDSC_INVALID_PATH_ID
//
// MessageText:
//
// Path Id specified in the call to set Load Balance Policy is not valid
//
#define ISDSC_INVALID_PATH_ID            ((ISDSC_STATUS)0xEFFF0059L)

//
// MessageId: ISDSC_MULTIPLE_PRIMARY_PATHS_SPECIFIED
//
// MessageText:
//
// Multiple primary paths specified when only one primary path is expected.
//
#define ISDSC_MULTIPLE_PRIMARY_PATHS_SPECIFIED ((ISDSC_STATUS)0xEFFF005AL)

//
// MessageId: ISDSC_NO_PRIMARY_PATH_SPECIFIED
//
// MessageText:
//
// No primary path specified when at least one is expected.
//
#define ISDSC_NO_PRIMARY_PATH_SPECIFIED  ((ISDSC_STATUS)0xEFFF005BL)

//
// MessageId: ISDSC_DEVICE_ALREADY_PERSISTENTLY_BOUND
//
// MessageText:
//
// Device is already a persistently bound device.
//
#define ISDSC_DEVICE_ALREADY_PERSISTENTLY_BOUND ((ISDSC_STATUS)0xEFFF005CL)

//
// MessageId: ISDSC_DEVICE_NOT_FOUND
//
// MessageText:
//
// Device was not found.
//
#define ISDSC_DEVICE_NOT_FOUND           ((ISDSC_STATUS)0xEFFF005DL)

//
// MessageId: ISDSC_DEVICE_NOT_ISCSI_OR_PERSISTENT
//
// MessageText:
//
// The device specified does not originate from an iSCSI disk or a persistent iSCSI login.
//
#define ISDSC_DEVICE_NOT_ISCSI_OR_PERSISTENT ((ISDSC_STATUS)0xEFFF005EL)

//
// MessageId: ISDSC_DNS_NAME_UNRESOLVED
//
// MessageText:
//
// The DNS name specified was not resolved.
//
#define ISDSC_DNS_NAME_UNRESOLVED        ((ISDSC_STATUS)0xEFFF005FL)

//
// MessageId: ISDSC_NO_CONNECTION_AVAILABLE
//
// MessageText:
//
// There is no connection available in the iSCSI session to process the request.
//
#define ISDSC_NO_CONNECTION_AVAILABLE    ((ISDSC_STATUS)0xEFFF0060L)

//
// MessageId: ISDSC_LB_POLICY_NOT_SUPPORTED
//
// MessageText:
//
// The given Load Balance policy is not supported.
//
#define ISDSC_LB_POLICY_NOT_SUPPORTED    ((ISDSC_STATUS)0xEFFF0061L)

//
// MessageId: ISDSC_REMOVE_CONNECTION_IN_PROGRESS
//
// MessageText:
//
// A remove connection request is already in progress for this session.
//
#define ISDSC_REMOVE_CONNECTION_IN_PROGRESS ((ISDSC_STATUS)0xEFFF0062L)

//
// MessageId: ISDSC_INVALID_CONNECTION_ID
//
// MessageText:
//
// Given connection was not found in the session.
//
#define ISDSC_INVALID_CONNECTION_ID      ((ISDSC_STATUS)0xEFFF0063L)

//
// MessageId: ISDSC_CANNOT_REMOVE_LEADING_CONNECTION
//
// MessageText:
//
// The leading connection in the session cannot be removed.
//
#define ISDSC_CANNOT_REMOVE_LEADING_CONNECTION ((ISDSC_STATUS)0xEFFF0064L)

//
// MessageId: ISDSC_RESTRICTED_BY_GROUP_POLICY
//
// MessageText:
//
// The operation cannot be performed since it does not conform with the group policy assigned to this computer.
//
#define ISDSC_RESTRICTED_BY_GROUP_POLICY ((ISDSC_STATUS)0xEFFF0065L)

//
// MessageId: ISDSC_ISNS_FIREWALL_BLOCKED
//
// MessageText:
//
// The operation cannot be performed since the Internet Storage Name Server (iSNS) firewall exception has not been enabled.
//
#define ISDSC_ISNS_FIREWALL_BLOCKED      ((ISDSC_STATUS)0xEFFF0066L)

//
// MessageId: ISDSC_FAILURE_TO_PERSIST_LB_POLICY
//
// MessageText:
//
// Failed to persist load balancing policy parameters.
//
#define ISDSC_FAILURE_TO_PERSIST_LB_POLICY ((ISDSC_STATUS)0xEFFF0067L)

//
// MessageId: ISDSC_INVALID_HOST
//
// MessageText:
//
// The name could not be resolved to an IP Address.
//
#define ISDSC_INVALID_HOST               ((ISDSC_STATUS)0xEFFF0068L)

#endif /* _ISCSIERR_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\IssPErr.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:      issperr.h
//
//  Contents:  Constant definitions for OLE HRESULT values.
//
//  History:   dd-mmm-yy Author    Comment
//
//--------------------------------------------------------------------------

#pragma message("WARNING: issperr.h is an obsolete header file")
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ivalidator.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for ivalidator.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ivalidator_h__
#define __ivalidator_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IValidator_FWD_DEFINED__
#define __IValidator_FWD_DEFINED__
typedef interface IValidator IValidator;
#endif 	/* __IValidator_FWD_DEFINED__ */


#ifndef __ICLRValidator_FWD_DEFINED__
#define __ICLRValidator_FWD_DEFINED__
typedef interface ICLRValidator ICLRValidator;
#endif 	/* __ICLRValidator_FWD_DEFINED__ */


/* header files for imported files */
#include "ivehandler.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ivalidator_0000_0000 */
/* [local] */ 

#pragma warning(push)
#pragma warning(disable:28718)    



enum ValidatorFlags
    {	VALIDATOR_EXTRA_VERBOSE	= 0x1,
	VALIDATOR_SHOW_SOURCE_LINES	= 0x2,
	VALIDATOR_CHECK_ILONLY	= 0x4,
	VALIDATOR_CHECK_PEFORMAT_ONLY	= 0x8,
	VALIDATOR_NOCHECK_PEFORMAT	= 0x10,
	VALIDATOR_TRANSPARENT_ONLY	= 0x20
    } ;


extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_0000_v0_0_s_ifspec;

#ifndef __IValidator_INTERFACE_DEFINED__
#define __IValidator_INTERFACE_DEFINED__

/* interface IValidator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63DF8730-DC81-4062-84A2-1FF943F59FAC")
    IValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ __RPC__in_opt IVEHandler *veh,
            /* [in] */ __RPC__in_opt IUnknown *pAppDomain,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ __RPC__in LPWSTR fileName,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pe,
            /* [in] */ unsigned long ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatEventInfo( 
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ __RPC__inout LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ __RPC__in SAFEARRAY * psa) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IValidator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            IValidator * This,
            /* [in] */ __RPC__in_opt IVEHandler *veh,
            /* [in] */ __RPC__in_opt IUnknown *pAppDomain,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ __RPC__in LPWSTR fileName,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pe,
            /* [in] */ unsigned long ulSize);
        
        HRESULT ( STDMETHODCALLTYPE *FormatEventInfo )( 
            IValidator * This,
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ __RPC__inout LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ __RPC__in SAFEARRAY * psa);
        
        END_INTERFACE
    } IValidatorVtbl;

    interface IValidator
    {
        CONST_VTBL struct IValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValidator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IValidator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IValidator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IValidator_Validate(This,veh,pAppDomain,ulFlags,ulMaxError,token,fileName,pe,ulSize)	\
    ( (This)->lpVtbl -> Validate(This,veh,pAppDomain,ulFlags,ulMaxError,token,fileName,pe,ulSize) ) 

#define IValidator_FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)	\
    ( (This)->lpVtbl -> FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IValidator_INTERFACE_DEFINED__ */


#ifndef __ICLRValidator_INTERFACE_DEFINED__
#define __ICLRValidator_INTERFACE_DEFINED__

/* interface ICLRValidator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63DF8730-DC81-4062-84A2-1FF943F59FDD")
    ICLRValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ __RPC__in_opt IVEHandler *veh,
            /* [in] */ unsigned long ulAppDomainId,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ __RPC__in LPWSTR fileName,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pe,
            /* [in] */ unsigned long ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatEventInfo( 
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ __RPC__inout LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ __RPC__in SAFEARRAY * psa) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRValidator * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            ICLRValidator * This,
            /* [in] */ __RPC__in_opt IVEHandler *veh,
            /* [in] */ unsigned long ulAppDomainId,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ __RPC__in LPWSTR fileName,
            /* [size_is][in] */ __RPC__in_ecount_full(ulSize) BYTE *pe,
            /* [in] */ unsigned long ulSize);
        
        HRESULT ( STDMETHODCALLTYPE *FormatEventInfo )( 
            ICLRValidator * This,
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ __RPC__inout LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ __RPC__in SAFEARRAY * psa);
        
        END_INTERFACE
    } ICLRValidatorVtbl;

    interface ICLRValidator
    {
        CONST_VTBL struct ICLRValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRValidator_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICLRValidator_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICLRValidator_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICLRValidator_Validate(This,veh,ulAppDomainId,ulFlags,ulMaxError,token,fileName,pe,ulSize)	\
    ( (This)->lpVtbl -> Validate(This,veh,ulAppDomainId,ulFlags,ulMaxError,token,fileName,pe,ulSize) ) 

#define ICLRValidator_FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)	\
    ( (This)->lpVtbl -> FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICLRValidator_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_ivalidator_0000_0002 */
/* [local] */ 

#pragma warning(pop)


extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_0002_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ISysmon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for sysmon.odl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __isysmon_h__
#define __isysmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICounterItem_FWD_DEFINED__
#define __ICounterItem_FWD_DEFINED__
typedef interface ICounterItem ICounterItem;
#endif 	/* __ICounterItem_FWD_DEFINED__ */


#ifndef __ICounterItem2_FWD_DEFINED__
#define __ICounterItem2_FWD_DEFINED__
typedef interface ICounterItem2 ICounterItem2;
#endif 	/* __ICounterItem2_FWD_DEFINED__ */


#ifndef ___ICounterItemUnion_FWD_DEFINED__
#define ___ICounterItemUnion_FWD_DEFINED__
typedef interface _ICounterItemUnion _ICounterItemUnion;
#endif 	/* ___ICounterItemUnion_FWD_DEFINED__ */


#ifndef __DICounterItem_FWD_DEFINED__
#define __DICounterItem_FWD_DEFINED__
typedef interface DICounterItem DICounterItem;
#endif 	/* __DICounterItem_FWD_DEFINED__ */


#ifndef __ICounters_FWD_DEFINED__
#define __ICounters_FWD_DEFINED__
typedef interface ICounters ICounters;
#endif 	/* __ICounters_FWD_DEFINED__ */


#ifndef __ILogFileItem_FWD_DEFINED__
#define __ILogFileItem_FWD_DEFINED__
typedef interface ILogFileItem ILogFileItem;
#endif 	/* __ILogFileItem_FWD_DEFINED__ */


#ifndef __DILogFileItem_FWD_DEFINED__
#define __DILogFileItem_FWD_DEFINED__
typedef interface DILogFileItem DILogFileItem;
#endif 	/* __DILogFileItem_FWD_DEFINED__ */


#ifndef __ILogFiles_FWD_DEFINED__
#define __ILogFiles_FWD_DEFINED__
typedef interface ILogFiles ILogFiles;
#endif 	/* __ILogFiles_FWD_DEFINED__ */


#ifndef __ISystemMonitor_FWD_DEFINED__
#define __ISystemMonitor_FWD_DEFINED__
typedef interface ISystemMonitor ISystemMonitor;
#endif 	/* __ISystemMonitor_FWD_DEFINED__ */


#ifndef __ISystemMonitor2_FWD_DEFINED__
#define __ISystemMonitor2_FWD_DEFINED__
typedef interface ISystemMonitor2 ISystemMonitor2;
#endif 	/* __ISystemMonitor2_FWD_DEFINED__ */


#ifndef ___ISystemMonitorUnion_FWD_DEFINED__
#define ___ISystemMonitorUnion_FWD_DEFINED__
typedef interface _ISystemMonitorUnion _ISystemMonitorUnion;
#endif 	/* ___ISystemMonitorUnion_FWD_DEFINED__ */


#ifndef __DISystemMonitor_FWD_DEFINED__
#define __DISystemMonitor_FWD_DEFINED__
typedef interface DISystemMonitor DISystemMonitor;
#endif 	/* __DISystemMonitor_FWD_DEFINED__ */


#ifndef __DISystemMonitorInternal_FWD_DEFINED__
#define __DISystemMonitorInternal_FWD_DEFINED__
typedef interface DISystemMonitorInternal DISystemMonitorInternal;
#endif 	/* __DISystemMonitorInternal_FWD_DEFINED__ */


#ifndef __ISystemMonitorEvents_FWD_DEFINED__
#define __ISystemMonitorEvents_FWD_DEFINED__
typedef interface ISystemMonitorEvents ISystemMonitorEvents;
#endif 	/* __ISystemMonitorEvents_FWD_DEFINED__ */


#ifndef __DISystemMonitorEvents_FWD_DEFINED__
#define __DISystemMonitorEvents_FWD_DEFINED__
typedef interface DISystemMonitorEvents DISystemMonitorEvents;
#endif 	/* __DISystemMonitorEvents_FWD_DEFINED__ */


#ifndef __SystemMonitor_FWD_DEFINED__
#define __SystemMonitor_FWD_DEFINED__

#ifdef __cplusplus
typedef class SystemMonitor SystemMonitor;
#else
typedef struct SystemMonitor SystemMonitor;
#endif /* __cplusplus */

#endif 	/* __SystemMonitor_FWD_DEFINED__ */


#ifndef __CounterItem_FWD_DEFINED__
#define __CounterItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterItem CounterItem;
#else
typedef struct CounterItem CounterItem;
#endif /* __cplusplus */

#endif 	/* __CounterItem_FWD_DEFINED__ */


#ifndef __Counters_FWD_DEFINED__
#define __Counters_FWD_DEFINED__

#ifdef __cplusplus
typedef class Counters Counters;
#else
typedef struct Counters Counters;
#endif /* __cplusplus */

#endif 	/* __Counters_FWD_DEFINED__ */


#ifndef __LogFileItem_FWD_DEFINED__
#define __LogFileItem_FWD_DEFINED__

#ifdef __cplusplus
typedef class LogFileItem LogFileItem;
#else
typedef struct LogFileItem LogFileItem;
#endif /* __cplusplus */

#endif 	/* __LogFileItem_FWD_DEFINED__ */


#ifndef __LogFiles_FWD_DEFINED__
#define __LogFiles_FWD_DEFINED__

#ifdef __cplusplus
typedef class LogFiles LogFiles;
#else
typedef struct LogFiles LogFiles;
#endif /* __cplusplus */

#endif 	/* __LogFiles_FWD_DEFINED__ */


#ifndef __CounterItem2_FWD_DEFINED__
#define __CounterItem2_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterItem2 CounterItem2;
#else
typedef struct CounterItem2 CounterItem2;
#endif /* __cplusplus */

#endif 	/* __CounterItem2_FWD_DEFINED__ */


#ifndef __SystemMonitor2_FWD_DEFINED__
#define __SystemMonitor2_FWD_DEFINED__

#ifdef __cplusplus
typedef class SystemMonitor2 SystemMonitor2;
#else
typedef struct SystemMonitor2 SystemMonitor2;
#endif /* __cplusplus */

#endif 	/* __SystemMonitor2_FWD_DEFINED__ */


#ifndef __AppearPropPage_FWD_DEFINED__
#define __AppearPropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class AppearPropPage AppearPropPage;
#else
typedef struct AppearPropPage AppearPropPage;
#endif /* __cplusplus */

#endif 	/* __AppearPropPage_FWD_DEFINED__ */


#ifndef __GeneralPropPage_FWD_DEFINED__
#define __GeneralPropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class GeneralPropPage GeneralPropPage;
#else
typedef struct GeneralPropPage GeneralPropPage;
#endif /* __cplusplus */

#endif 	/* __GeneralPropPage_FWD_DEFINED__ */


#ifndef __GraphPropPage_FWD_DEFINED__
#define __GraphPropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class GraphPropPage GraphPropPage;
#else
typedef struct GraphPropPage GraphPropPage;
#endif /* __cplusplus */

#endif 	/* __GraphPropPage_FWD_DEFINED__ */


#ifndef __SourcePropPage_FWD_DEFINED__
#define __SourcePropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class SourcePropPage SourcePropPage;
#else
typedef struct SourcePropPage SourcePropPage;
#endif /* __cplusplus */

#endif 	/* __SourcePropPage_FWD_DEFINED__ */


#ifndef __CounterPropPage_FWD_DEFINED__
#define __CounterPropPage_FWD_DEFINED__

#ifdef __cplusplus
typedef class CounterPropPage CounterPropPage;
#else
typedef struct CounterPropPage CounterPropPage;
#endif /* __cplusplus */

#endif 	/* __CounterPropPage_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __SystemMonitor_LIBRARY_DEFINED__
#define __SystemMonitor_LIBRARY_DEFINED__

/* library SystemMonitor */
/* [version][lcid][helpstring][uuid] */ 

typedef /* [helpstring] */ 
enum eDisplayTypeConstant
    {	sysmonLineGraph	= 1,
	sysmonHistogram	= 2,
	sysmonReport	= 3,
	sysmonChartArea	= 4,
	sysmonChartStackedArea	= 5
    } 	DisplayTypeConstants;

typedef /* [helpstring] */ 
enum eReportValueTypeConstant
    {	sysmonDefaultValue	= 0,
	sysmonCurrentValue	= 0x1,
	sysmonAverage	= 0x2,
	sysmonMinimum	= 0x3,
	sysmonMaximum	= 0x4
    } 	ReportValueTypeConstants;

typedef /* [helpstring] */ 
enum eDataSourceTypeConstant
    {	sysmonNullDataSource	= 0xffffffff,
	sysmonCurrentActivity	= 0x1,
	sysmonLogFiles	= 0x2,
	sysmonSqlLog	= 0x3
    } 	DataSourceTypeConstants;

typedef /* [helpstring] */ 
enum __MIDL___MIDL_itf_sysmon_0000_0000_0001
    {	sysmonFileHtml	= 1,
	sysmonFileReport	= 2,
	sysmonFileCsv	= 3,
	sysmonFileTsv	= 4,
	sysmonFileBlg	= 5,
	sysmonFileRetiredBlg	= 6,
	sysmonFileGif	= 7
    } 	SysmonFileType;

typedef /* [helpstring] */ 
enum __MIDL___MIDL_itf_sysmon_0000_0000_0002
    {	sysmonDataAvg	= 1,
	sysmonDataMin	= 2,
	sysmonDataMax	= 3,
	sysmonDataTime	= 4,
	sysmonDataCount	= 5
    } 	SysmonDataType;

typedef /* [helpstring] */ 
enum __MIDL___MIDL_itf_sysmon_0000_0000_0003
    {	sysmonBatchNone	= 0,
	sysmonBatchAddFiles	= 1,
	sysmonBatchAddCounters	= 2,
	sysmonBatchAddFilesAutoCounters	= 3
    } 	SysmonBatchReason;


DEFINE_GUID(LIBID_SystemMonitor,0x1B773E42,0x2509,0x11cf,0x94,0x2F,0x00,0x80,0x29,0x00,0x43,0x47);

#ifndef __ICounterItem_INTERFACE_DEFINED__
#define __ICounterItem_INTERFACE_DEFINED__

/* interface ICounterItem */
/* [object][hidden][helpstring][uuid] */ 


DEFINE_GUID(IID_ICounterItem,0x771A9520,0xEE28,0x11ce,0x94,0x1E,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("771A9520-EE28-11ce-941E-008029004347")
    ICounterItem : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out double *pdblValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ INT iWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LineStyle( 
            /* [in] */ INT iLineStyle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LineStyle( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ScaleFactor( 
            /* [in] */ INT iScale) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ScaleFactor( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICounterItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICounterItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICounterItem * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out double *pdblValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            __RPC__in ICounterItem * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            __RPC__in ICounterItem * This,
            /* [in] */ INT iWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LineStyle )( 
            __RPC__in ICounterItem * This,
            /* [in] */ INT iLineStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LineStyle )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleFactor )( 
            __RPC__in ICounterItem * This,
            /* [in] */ INT iScale);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleFactor )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in ICounterItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ICounterItem * This,
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            __RPC__in ICounterItem * This,
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status);
        
        END_INTERFACE
    } ICounterItemVtbl;

    interface ICounterItem
    {
        CONST_VTBL struct ICounterItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounterItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICounterItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICounterItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICounterItem_get_Value(This,pdblValue)	\
    ( (This)->lpVtbl -> get_Value(This,pdblValue) ) 

#define ICounterItem_put_Color(This,Color)	\
    ( (This)->lpVtbl -> put_Color(This,Color) ) 

#define ICounterItem_get_Color(This,pColor)	\
    ( (This)->lpVtbl -> get_Color(This,pColor) ) 

#define ICounterItem_put_Width(This,iWidth)	\
    ( (This)->lpVtbl -> put_Width(This,iWidth) ) 

#define ICounterItem_get_Width(This,piValue)	\
    ( (This)->lpVtbl -> get_Width(This,piValue) ) 

#define ICounterItem_put_LineStyle(This,iLineStyle)	\
    ( (This)->lpVtbl -> put_LineStyle(This,iLineStyle) ) 

#define ICounterItem_get_LineStyle(This,piValue)	\
    ( (This)->lpVtbl -> get_LineStyle(This,piValue) ) 

#define ICounterItem_put_ScaleFactor(This,iScale)	\
    ( (This)->lpVtbl -> put_ScaleFactor(This,iScale) ) 

#define ICounterItem_get_ScaleFactor(This,piValue)	\
    ( (This)->lpVtbl -> get_ScaleFactor(This,piValue) ) 

#define ICounterItem_get_Path(This,pstrValue)	\
    ( (This)->lpVtbl -> get_Path(This,pstrValue) ) 

#define ICounterItem_GetValue(This,Value,Status)	\
    ( (This)->lpVtbl -> GetValue(This,Value,Status) ) 

#define ICounterItem_GetStatistics(This,Max,Min,Avg,Status)	\
    ( (This)->lpVtbl -> GetStatistics(This,Max,Min,Avg,Status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICounterItem_INTERFACE_DEFINED__ */


#ifndef __ICounterItem2_INTERFACE_DEFINED__
#define __ICounterItem2_INTERFACE_DEFINED__

/* interface ICounterItem2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_ICounterItem2,0xeefcd4e1,0xea1c,0x4435,0xb7,0xf4,0xe3,0x41,0xba,0x03,0xb4,0xf9);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("eefcd4e1-ea1c-4435-b7f4-e341ba03b4f9")
    ICounterItem2 : public ICounterItem
    {
    public:
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Selected( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Selected( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataAt( 
            /* [in] */ INT iIndex,
            /* [in] */ SysmonDataType iWhich,
            /* [out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICounterItem2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICounterItem2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICounterItem2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out double *pdblValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ INT iWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LineStyle )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ INT iLineStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LineStyle )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleFactor )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ INT iScale);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleFactor )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ICounterItem2 * This,
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            __RPC__in ICounterItem2 * This,
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Selected )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Selected )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            __RPC__in ICounterItem2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataAt )( 
            __RPC__in ICounterItem2 * This,
            /* [in] */ INT iIndex,
            /* [in] */ SysmonDataType iWhich,
            /* [out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } ICounterItem2Vtbl;

    interface ICounterItem2
    {
        CONST_VTBL struct ICounterItem2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounterItem2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICounterItem2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICounterItem2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICounterItem2_get_Value(This,pdblValue)	\
    ( (This)->lpVtbl -> get_Value(This,pdblValue) ) 

#define ICounterItem2_put_Color(This,Color)	\
    ( (This)->lpVtbl -> put_Color(This,Color) ) 

#define ICounterItem2_get_Color(This,pColor)	\
    ( (This)->lpVtbl -> get_Color(This,pColor) ) 

#define ICounterItem2_put_Width(This,iWidth)	\
    ( (This)->lpVtbl -> put_Width(This,iWidth) ) 

#define ICounterItem2_get_Width(This,piValue)	\
    ( (This)->lpVtbl -> get_Width(This,piValue) ) 

#define ICounterItem2_put_LineStyle(This,iLineStyle)	\
    ( (This)->lpVtbl -> put_LineStyle(This,iLineStyle) ) 

#define ICounterItem2_get_LineStyle(This,piValue)	\
    ( (This)->lpVtbl -> get_LineStyle(This,piValue) ) 

#define ICounterItem2_put_ScaleFactor(This,iScale)	\
    ( (This)->lpVtbl -> put_ScaleFactor(This,iScale) ) 

#define ICounterItem2_get_ScaleFactor(This,piValue)	\
    ( (This)->lpVtbl -> get_ScaleFactor(This,piValue) ) 

#define ICounterItem2_get_Path(This,pstrValue)	\
    ( (This)->lpVtbl -> get_Path(This,pstrValue) ) 

#define ICounterItem2_GetValue(This,Value,Status)	\
    ( (This)->lpVtbl -> GetValue(This,Value,Status) ) 

#define ICounterItem2_GetStatistics(This,Max,Min,Avg,Status)	\
    ( (This)->lpVtbl -> GetStatistics(This,Max,Min,Avg,Status) ) 


#define ICounterItem2_put_Selected(This,bState)	\
    ( (This)->lpVtbl -> put_Selected(This,bState) ) 

#define ICounterItem2_get_Selected(This,pbState)	\
    ( (This)->lpVtbl -> get_Selected(This,pbState) ) 

#define ICounterItem2_put_Visible(This,bState)	\
    ( (This)->lpVtbl -> put_Visible(This,bState) ) 

#define ICounterItem2_get_Visible(This,pbState)	\
    ( (This)->lpVtbl -> get_Visible(This,pbState) ) 

#define ICounterItem2_GetDataAt(This,iIndex,iWhich,pVariant)	\
    ( (This)->lpVtbl -> GetDataAt(This,iIndex,iWhich,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICounterItem2_INTERFACE_DEFINED__ */


#ifndef ___ICounterItemUnion_INTERFACE_DEFINED__
#define ___ICounterItemUnion_INTERFACE_DEFINED__

/* interface _ICounterItemUnion */
/* [object][hidden][uuid] */ 


DEFINE_GUID(IID__ICounterItemUnion,0xde1a6b74,0x9182,0x4c41,0x8e,0x2c,0x24,0xc2,0xcd,0x30,0xee,0x83);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("de1a6b74-9182-4c41-8e2c-24c2cd30ee83")
    _ICounterItemUnion : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [retval][out] */ __RPC__out double *pdblValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Color( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Color( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Width( 
            /* [in] */ INT iWidth) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Width( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LineStyle( 
            /* [in] */ INT iLineStyle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LineStyle( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ScaleFactor( 
            /* [in] */ INT iScale) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ScaleFactor( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatistics( 
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Selected( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Selected( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_Visible( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Visible( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDataAt( 
            /* [in] */ INT iIndex,
            /* [in] */ SysmonDataType iWhich,
            /* [out] */ __RPC__out VARIANT *pVariant) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _ICounterItemUnionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _ICounterItemUnion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _ICounterItemUnion * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Value )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out double *pdblValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Color )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Color )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Width )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ INT iWidth);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Width )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LineStyle )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ INT iLineStyle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LineStyle )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ScaleFactor )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ INT iScale);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ScaleFactor )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in _ICounterItemUnion * This,
            /* [out] */ __RPC__out double *Value,
            /* [out] */ __RPC__out long *Status);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatistics )( 
            __RPC__in _ICounterItemUnion * This,
            /* [out] */ __RPC__out double *Max,
            /* [out] */ __RPC__out double *Min,
            /* [out] */ __RPC__out double *Avg,
            /* [out] */ __RPC__out long *Status);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Selected )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Selected )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Visible )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Visible )( 
            __RPC__in _ICounterItemUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDataAt )( 
            __RPC__in _ICounterItemUnion * This,
            /* [in] */ INT iIndex,
            /* [in] */ SysmonDataType iWhich,
            /* [out] */ __RPC__out VARIANT *pVariant);
        
        END_INTERFACE
    } _ICounterItemUnionVtbl;

    interface _ICounterItemUnion
    {
        CONST_VTBL struct _ICounterItemUnionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ICounterItemUnion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _ICounterItemUnion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _ICounterItemUnion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _ICounterItemUnion_get_Value(This,pdblValue)	\
    ( (This)->lpVtbl -> get_Value(This,pdblValue) ) 

#define _ICounterItemUnion_put_Color(This,Color)	\
    ( (This)->lpVtbl -> put_Color(This,Color) ) 

#define _ICounterItemUnion_get_Color(This,pColor)	\
    ( (This)->lpVtbl -> get_Color(This,pColor) ) 

#define _ICounterItemUnion_put_Width(This,iWidth)	\
    ( (This)->lpVtbl -> put_Width(This,iWidth) ) 

#define _ICounterItemUnion_get_Width(This,piValue)	\
    ( (This)->lpVtbl -> get_Width(This,piValue) ) 

#define _ICounterItemUnion_put_LineStyle(This,iLineStyle)	\
    ( (This)->lpVtbl -> put_LineStyle(This,iLineStyle) ) 

#define _ICounterItemUnion_get_LineStyle(This,piValue)	\
    ( (This)->lpVtbl -> get_LineStyle(This,piValue) ) 

#define _ICounterItemUnion_put_ScaleFactor(This,iScale)	\
    ( (This)->lpVtbl -> put_ScaleFactor(This,iScale) ) 

#define _ICounterItemUnion_get_ScaleFactor(This,piValue)	\
    ( (This)->lpVtbl -> get_ScaleFactor(This,piValue) ) 

#define _ICounterItemUnion_get_Path(This,pstrValue)	\
    ( (This)->lpVtbl -> get_Path(This,pstrValue) ) 

#define _ICounterItemUnion_GetValue(This,Value,Status)	\
    ( (This)->lpVtbl -> GetValue(This,Value,Status) ) 

#define _ICounterItemUnion_GetStatistics(This,Max,Min,Avg,Status)	\
    ( (This)->lpVtbl -> GetStatistics(This,Max,Min,Avg,Status) ) 

#define _ICounterItemUnion_put_Selected(This,bState)	\
    ( (This)->lpVtbl -> put_Selected(This,bState) ) 

#define _ICounterItemUnion_get_Selected(This,pbState)	\
    ( (This)->lpVtbl -> get_Selected(This,pbState) ) 

#define _ICounterItemUnion_put_Visible(This,bState)	\
    ( (This)->lpVtbl -> put_Visible(This,bState) ) 

#define _ICounterItemUnion_get_Visible(This,pbState)	\
    ( (This)->lpVtbl -> get_Visible(This,pbState) ) 

#define _ICounterItemUnion_GetDataAt(This,iIndex,iWhich,pVariant)	\
    ( (This)->lpVtbl -> GetDataAt(This,iIndex,iWhich,pVariant) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* ___ICounterItemUnion_INTERFACE_DEFINED__ */


#ifndef __DICounterItem_DISPINTERFACE_DEFINED__
#define __DICounterItem_DISPINTERFACE_DEFINED__

/* dispinterface DICounterItem */
/* [helpstring][hidden][uuid] */ 


DEFINE_GUID(DIID_DICounterItem,0xC08C4FF2,0x0E2E,0x11cf,0x94,0x2C,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C08C4FF2-0E2E-11cf-942C-008029004347")
    DICounterItem : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DICounterItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DICounterItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DICounterItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DICounterItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DICounterItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DICounterItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DICounterItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DICounterItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DICounterItemVtbl;

    interface DICounterItem
    {
        CONST_VTBL struct DICounterItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DICounterItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DICounterItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DICounterItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DICounterItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DICounterItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DICounterItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DICounterItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DICounterItem_DISPINTERFACE_DEFINED__ */


#ifndef __ICounters_INTERFACE_DEFINED__
#define __ICounters_INTERFACE_DEFINED__

/* interface ICounters */
/* [object][hidden][dual][helpstring][uuid] */ 


DEFINE_GUID(IID_ICounters,0x79167962,0x28FC,0x11cf,0x94,0x2F,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79167962-28FC-11cf-942F-008029004347")
    ICounters : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pLong) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIunk) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt DICounterItem	**ppI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in BSTR pathname,
            /* [retval][out] */ __RPC__deref_out_opt DICounterItem	**ppI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICountersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICounters * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICounters * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ICounters * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ICounters * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ICounters * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICounters * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in ICounters * This,
            /* [retval][out] */ __RPC__out long *pLong);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in ICounters * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIunk);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in ICounters * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt DICounterItem	**ppI);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in ICounters * This,
            /* [in] */ __RPC__in BSTR pathname,
            /* [retval][out] */ __RPC__deref_out_opt DICounterItem	**ppI);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in ICounters * This,
            /* [in] */ VARIANT index);
        
        END_INTERFACE
    } ICountersVtbl;

    interface ICounters
    {
        CONST_VTBL struct ICountersVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICounters_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICounters_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICounters_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICounters_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICounters_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICounters_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICounters_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICounters_get_Count(This,pLong)	\
    ( (This)->lpVtbl -> get_Count(This,pLong) ) 

#define ICounters_get__NewEnum(This,ppIunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppIunk) ) 

#define ICounters_get_Item(This,index,ppI)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppI) ) 

#define ICounters_Add(This,pathname,ppI)	\
    ( (This)->lpVtbl -> Add(This,pathname,ppI) ) 

#define ICounters_Remove(This,index)	\
    ( (This)->lpVtbl -> Remove(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICounters_INTERFACE_DEFINED__ */


#ifndef __ILogFileItem_INTERFACE_DEFINED__
#define __ILogFileItem_INTERFACE_DEFINED__

/* interface ILogFileItem */
/* [object][hidden][helpstring][uuid] */ 


DEFINE_GUID(IID_ILogFileItem,0xD6B518DD,0x05C7,0x418a,0x89,0xE6,0x4F,0x9C,0xE8,0xC6,0x84,0x1E);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6B518DD-05C7-418a-89E6-4F9CE8C6841E")
    ILogFileItem : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogFileItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILogFileItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILogFileItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILogFileItem * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Path )( 
            __RPC__in ILogFileItem * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pstrValue);
        
        END_INTERFACE
    } ILogFileItemVtbl;

    interface ILogFileItem
    {
        CONST_VTBL struct ILogFileItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogFileItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILogFileItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILogFileItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILogFileItem_get_Path(This,pstrValue)	\
    ( (This)->lpVtbl -> get_Path(This,pstrValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILogFileItem_INTERFACE_DEFINED__ */


#ifndef __DILogFileItem_DISPINTERFACE_DEFINED__
#define __DILogFileItem_DISPINTERFACE_DEFINED__

/* dispinterface DILogFileItem */
/* [helpstring][hidden][uuid] */ 


DEFINE_GUID(DIID_DILogFileItem,0x8D093FFC,0xF777,0x4917,0x82,0xD1,0x83,0x3F,0xBC,0x54,0xC5,0x8F);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("8D093FFC-F777-4917-82D1-833FBC54C58F")
    DILogFileItem : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DILogFileItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DILogFileItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DILogFileItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DILogFileItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DILogFileItem * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DILogFileItem * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DILogFileItem * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DILogFileItem * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DILogFileItemVtbl;

    interface DILogFileItem
    {
        CONST_VTBL struct DILogFileItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DILogFileItem_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DILogFileItem_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DILogFileItem_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DILogFileItem_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DILogFileItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DILogFileItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DILogFileItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DILogFileItem_DISPINTERFACE_DEFINED__ */


#ifndef __ILogFiles_INTERFACE_DEFINED__
#define __ILogFiles_INTERFACE_DEFINED__

/* interface ILogFiles */
/* [object][hidden][dual][helpstring][uuid] */ 


DEFINE_GUID(IID_ILogFiles,0x6A2A97E6,0x6851,0x41ea,0x87,0xAD,0x2A,0x82,0x25,0x33,0x58,0x65);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6A2A97E6-6851-41ea-87AD-2A8225335865")
    ILogFiles : public IDispatch
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *pLong) = 0;
        
        virtual /* [id][restricted][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIunk) = 0;
        
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt DILogFileItem	**ppI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in BSTR pathname,
            /* [retval][out] */ __RPC__deref_out_opt DILogFileItem	**ppI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ VARIANT index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILogFiles * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILogFiles * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILogFiles * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ILogFiles * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ILogFiles * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ILogFiles * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILogFiles * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            __RPC__in ILogFiles * This,
            /* [retval][out] */ __RPC__out long *pLong);
        
        /* [id][restricted][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            __RPC__in ILogFiles * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **ppIunk);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            __RPC__in ILogFiles * This,
            /* [in] */ VARIANT index,
            /* [retval][out] */ __RPC__deref_out_opt DILogFileItem	**ppI);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            __RPC__in ILogFiles * This,
            /* [in] */ __RPC__in BSTR pathname,
            /* [retval][out] */ __RPC__deref_out_opt DILogFileItem	**ppI);
        
        HRESULT ( STDMETHODCALLTYPE *Remove )( 
            __RPC__in ILogFiles * This,
            /* [in] */ VARIANT index);
        
        END_INTERFACE
    } ILogFilesVtbl;

    interface ILogFiles
    {
        CONST_VTBL struct ILogFilesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogFiles_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILogFiles_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILogFiles_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILogFiles_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ILogFiles_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ILogFiles_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ILogFiles_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ILogFiles_get_Count(This,pLong)	\
    ( (This)->lpVtbl -> get_Count(This,pLong) ) 

#define ILogFiles_get__NewEnum(This,ppIunk)	\
    ( (This)->lpVtbl -> get__NewEnum(This,ppIunk) ) 

#define ILogFiles_get_Item(This,index,ppI)	\
    ( (This)->lpVtbl -> get_Item(This,index,ppI) ) 

#define ILogFiles_Add(This,pathname,ppI)	\
    ( (This)->lpVtbl -> Add(This,pathname,ppI) ) 

#define ILogFiles_Remove(This,index)	\
    ( (This)->lpVtbl -> Remove(This,index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILogFiles_INTERFACE_DEFINED__ */


#ifndef __ISystemMonitor_INTERFACE_DEFINED__
#define __ISystemMonitor_INTERFACE_DEFINED__

/* interface ISystemMonitor */
/* [object][hidden][helpstring][uuid] */ 


DEFINE_GUID(IID_ISystemMonitor,0x194EB241,0xC32C,0x11cf,0x93,0x98,0x00,0xAA,0x00,0xA3,0xDD,0xEA);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("194EB241-C32C-11cf-9398-00AA00A3DDEA")
    ISystemMonitor : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ __RPC__out INT *iAppearance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ INT iAppearance) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ __RPC__out INT *iBorderStyle) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ INT iBorderStyle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ __RPC__in_opt IFontDisp *pFont) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Counters( 
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowVerticalGrid( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowVerticalGrid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowHorizontalGrid( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowHorizontalGrid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowLegend( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowLegend( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowScaleLabels( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowScaleLabels( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowValueBar( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowValueBar( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MaximumScale( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MaximumScale( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MinimumScale( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MinimumScale( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UpdateInterval( 
            /* [in] */ FLOAT fValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UpdateInterval( 
            /* [retval][out] */ __RPC__out FLOAT *pfValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayType( 
            /* [in] */ DisplayTypeConstants eDisplayType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayType( 
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ManualUpdate( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ManualUpdate( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GraphTitle( 
            /* [in] */ __RPC__in BSTR bsTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_GraphTitle( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_YAxisLabel( 
            /* [in] */ __RPC__in BSTR bsTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_YAxisLabel( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CollectSample( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateGraph( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BrowseCounters( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayProperties( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE Counter( 
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AddCounter( 
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE DeleteCounter( 
            /* [in] */ __RPC__in_opt ICounterItem *pCtr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColorCtl( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColorCtl( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogFileName( 
            /* [in] */ __RPC__in BSTR bsFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogViewStart( 
            /* [in] */ DATE StartTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogViewStart( 
            /* [retval][out] */ __RPC__out DATE *StartTime) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogViewStop( 
            /* [in] */ DATE StopTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogViewStop( 
            /* [retval][out] */ __RPC__out DATE *StopTime) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GridColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_GridColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TimeBarColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TimeBarColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Highlight( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Highlight( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowToolbar( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowToolbar( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Paste( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Copy( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReadOnly( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReportValueType( 
            /* [in] */ ReportValueTypeConstants eReportValueType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReportValueType( 
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MonitorDuplicateInstances( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MonitorDuplicateInstances( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayFilter( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayFilter( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFiles( 
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DataSourceType( 
            /* [in] */ DataSourceTypeConstants eDataSourceType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSourceType( 
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SqlDsnName( 
            /* [in] */ __RPC__in BSTR bsSqlDsnName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SqlDsnName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SqlLogSetName( 
            /* [in] */ __RPC__in BSTR bsSqlLogSetName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SqlLogSetName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemMonitorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISystemMonitor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *iAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iAppearance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *iBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iBorderStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in_opt IFontDisp *pFont);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Counters )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowVerticalGrid )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowVerticalGrid )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowHorizontalGrid )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHorizontalGrid )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowLegend )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowLegend )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowScaleLabels )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowScaleLabels )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowValueBar )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowValueBar )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MaximumScale )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumScale )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumScale )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumScale )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UpdateInterval )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ FLOAT fValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateInterval )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out FLOAT *pfValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayType )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ DisplayTypeConstants eDisplayType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayType )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ManualUpdate )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ManualUpdate )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GraphTitle )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GraphTitle )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_YAxisLabel )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_YAxisLabel )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CollectSample )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateGraph )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BrowseCounters )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisplayProperties )( 
            __RPC__in ISystemMonitor * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *Counter )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AddCounter )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteCounter )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in_opt ICounterItem *pCtr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColorCtl )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColorCtl )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogFileName )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFileName )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStart )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ DATE StartTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStart )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out DATE *StartTime);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStop )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ DATE StopTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStop )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out DATE *StopTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GridColor )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GridColor )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TimeBarColor )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TimeBarColor )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Highlight )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Highlight )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowToolbar )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowToolbar )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Paste )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Copy )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in ISystemMonitor * This);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReadOnly )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReportValueType )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ ReportValueTypeConstants eReportValueType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReportValueType )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MonitorDuplicateInstances )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MonitorDuplicateInstances )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayFilter )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayFilter )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFiles )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataSourceType )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ DataSourceTypeConstants eDataSourceType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataSourceType )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlDsnName )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsSqlDsnName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlDsnName )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlLogSetName )( 
            __RPC__in ISystemMonitor * This,
            /* [in] */ __RPC__in BSTR bsSqlLogSetName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlLogSetName )( 
            __RPC__in ISystemMonitor * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName);
        
        END_INTERFACE
    } ISystemMonitorVtbl;

    interface ISystemMonitor
    {
        CONST_VTBL struct ISystemMonitorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemMonitor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemMonitor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemMonitor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemMonitor_get_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,iAppearance) ) 

#define ISystemMonitor_put_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,iAppearance) ) 

#define ISystemMonitor_get_BackColor(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColor(This,pColor) ) 

#define ISystemMonitor_put_BackColor(This,Color)	\
    ( (This)->lpVtbl -> put_BackColor(This,Color) ) 

#define ISystemMonitor_get_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,iBorderStyle) ) 

#define ISystemMonitor_put_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,iBorderStyle) ) 

#define ISystemMonitor_get_ForeColor(This,pColor)	\
    ( (This)->lpVtbl -> get_ForeColor(This,pColor) ) 

#define ISystemMonitor_put_ForeColor(This,Color)	\
    ( (This)->lpVtbl -> put_ForeColor(This,Color) ) 

#define ISystemMonitor_get_Font(This,ppFont)	\
    ( (This)->lpVtbl -> get_Font(This,ppFont) ) 

#define ISystemMonitor_putref_Font(This,pFont)	\
    ( (This)->lpVtbl -> putref_Font(This,pFont) ) 

#define ISystemMonitor_get_Counters(This,ppICounters)	\
    ( (This)->lpVtbl -> get_Counters(This,ppICounters) ) 

#define ISystemMonitor_put_ShowVerticalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowVerticalGrid(This,bState) ) 

#define ISystemMonitor_get_ShowVerticalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowVerticalGrid(This,pbState) ) 

#define ISystemMonitor_put_ShowHorizontalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowHorizontalGrid(This,bState) ) 

#define ISystemMonitor_get_ShowHorizontalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowHorizontalGrid(This,pbState) ) 

#define ISystemMonitor_put_ShowLegend(This,bState)	\
    ( (This)->lpVtbl -> put_ShowLegend(This,bState) ) 

#define ISystemMonitor_get_ShowLegend(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowLegend(This,pbState) ) 

#define ISystemMonitor_put_ShowScaleLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowScaleLabels(This,bState) ) 

#define ISystemMonitor_get_ShowScaleLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowScaleLabels(This,pbState) ) 

#define ISystemMonitor_put_ShowValueBar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowValueBar(This,bState) ) 

#define ISystemMonitor_get_ShowValueBar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowValueBar(This,pbState) ) 

#define ISystemMonitor_put_MaximumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MaximumScale(This,iValue) ) 

#define ISystemMonitor_get_MaximumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MaximumScale(This,piValue) ) 

#define ISystemMonitor_put_MinimumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MinimumScale(This,iValue) ) 

#define ISystemMonitor_get_MinimumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MinimumScale(This,piValue) ) 

#define ISystemMonitor_put_UpdateInterval(This,fValue)	\
    ( (This)->lpVtbl -> put_UpdateInterval(This,fValue) ) 

#define ISystemMonitor_get_UpdateInterval(This,pfValue)	\
    ( (This)->lpVtbl -> get_UpdateInterval(This,pfValue) ) 

#define ISystemMonitor_put_DisplayType(This,eDisplayType)	\
    ( (This)->lpVtbl -> put_DisplayType(This,eDisplayType) ) 

#define ISystemMonitor_get_DisplayType(This,peDisplayType)	\
    ( (This)->lpVtbl -> get_DisplayType(This,peDisplayType) ) 

#define ISystemMonitor_put_ManualUpdate(This,bState)	\
    ( (This)->lpVtbl -> put_ManualUpdate(This,bState) ) 

#define ISystemMonitor_get_ManualUpdate(This,pbState)	\
    ( (This)->lpVtbl -> get_ManualUpdate(This,pbState) ) 

#define ISystemMonitor_put_GraphTitle(This,bsTitle)	\
    ( (This)->lpVtbl -> put_GraphTitle(This,bsTitle) ) 

#define ISystemMonitor_get_GraphTitle(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_GraphTitle(This,pbsTitle) ) 

#define ISystemMonitor_put_YAxisLabel(This,bsTitle)	\
    ( (This)->lpVtbl -> put_YAxisLabel(This,bsTitle) ) 

#define ISystemMonitor_get_YAxisLabel(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_YAxisLabel(This,pbsTitle) ) 

#define ISystemMonitor_CollectSample(This)	\
    ( (This)->lpVtbl -> CollectSample(This) ) 

#define ISystemMonitor_UpdateGraph(This)	\
    ( (This)->lpVtbl -> UpdateGraph(This) ) 

#define ISystemMonitor_BrowseCounters(This)	\
    ( (This)->lpVtbl -> BrowseCounters(This) ) 

#define ISystemMonitor_DisplayProperties(This)	\
    ( (This)->lpVtbl -> DisplayProperties(This) ) 

#define ISystemMonitor_Counter(This,iIndex,ppICounter)	\
    ( (This)->lpVtbl -> Counter(This,iIndex,ppICounter) ) 

#define ISystemMonitor_AddCounter(This,bsPath,ppICounter)	\
    ( (This)->lpVtbl -> AddCounter(This,bsPath,ppICounter) ) 

#define ISystemMonitor_DeleteCounter(This,pCtr)	\
    ( (This)->lpVtbl -> DeleteCounter(This,pCtr) ) 

#define ISystemMonitor_get_BackColorCtl(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColorCtl(This,pColor) ) 

#define ISystemMonitor_put_BackColorCtl(This,Color)	\
    ( (This)->lpVtbl -> put_BackColorCtl(This,Color) ) 

#define ISystemMonitor_put_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> put_LogFileName(This,bsFileName) ) 

#define ISystemMonitor_get_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> get_LogFileName(This,bsFileName) ) 

#define ISystemMonitor_put_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> put_LogViewStart(This,StartTime) ) 

#define ISystemMonitor_get_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> get_LogViewStart(This,StartTime) ) 

#define ISystemMonitor_put_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> put_LogViewStop(This,StopTime) ) 

#define ISystemMonitor_get_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> get_LogViewStop(This,StopTime) ) 

#define ISystemMonitor_get_GridColor(This,pColor)	\
    ( (This)->lpVtbl -> get_GridColor(This,pColor) ) 

#define ISystemMonitor_put_GridColor(This,Color)	\
    ( (This)->lpVtbl -> put_GridColor(This,Color) ) 

#define ISystemMonitor_get_TimeBarColor(This,pColor)	\
    ( (This)->lpVtbl -> get_TimeBarColor(This,pColor) ) 

#define ISystemMonitor_put_TimeBarColor(This,Color)	\
    ( (This)->lpVtbl -> put_TimeBarColor(This,Color) ) 

#define ISystemMonitor_get_Highlight(This,pbState)	\
    ( (This)->lpVtbl -> get_Highlight(This,pbState) ) 

#define ISystemMonitor_put_Highlight(This,bState)	\
    ( (This)->lpVtbl -> put_Highlight(This,bState) ) 

#define ISystemMonitor_get_ShowToolbar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowToolbar(This,pbState) ) 

#define ISystemMonitor_put_ShowToolbar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowToolbar(This,bState) ) 

#define ISystemMonitor_Paste(This)	\
    ( (This)->lpVtbl -> Paste(This) ) 

#define ISystemMonitor_Copy(This)	\
    ( (This)->lpVtbl -> Copy(This) ) 

#define ISystemMonitor_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ISystemMonitor_put_ReadOnly(This,bState)	\
    ( (This)->lpVtbl -> put_ReadOnly(This,bState) ) 

#define ISystemMonitor_get_ReadOnly(This,pbState)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,pbState) ) 

#define ISystemMonitor_put_ReportValueType(This,eReportValueType)	\
    ( (This)->lpVtbl -> put_ReportValueType(This,eReportValueType) ) 

#define ISystemMonitor_get_ReportValueType(This,peReportValueType)	\
    ( (This)->lpVtbl -> get_ReportValueType(This,peReportValueType) ) 

#define ISystemMonitor_put_MonitorDuplicateInstances(This,bState)	\
    ( (This)->lpVtbl -> put_MonitorDuplicateInstances(This,bState) ) 

#define ISystemMonitor_get_MonitorDuplicateInstances(This,pbState)	\
    ( (This)->lpVtbl -> get_MonitorDuplicateInstances(This,pbState) ) 

#define ISystemMonitor_put_DisplayFilter(This,iValue)	\
    ( (This)->lpVtbl -> put_DisplayFilter(This,iValue) ) 

#define ISystemMonitor_get_DisplayFilter(This,piValue)	\
    ( (This)->lpVtbl -> get_DisplayFilter(This,piValue) ) 

#define ISystemMonitor_get_LogFiles(This,ppILogFiles)	\
    ( (This)->lpVtbl -> get_LogFiles(This,ppILogFiles) ) 

#define ISystemMonitor_put_DataSourceType(This,eDataSourceType)	\
    ( (This)->lpVtbl -> put_DataSourceType(This,eDataSourceType) ) 

#define ISystemMonitor_get_DataSourceType(This,peDataSourceType)	\
    ( (This)->lpVtbl -> get_DataSourceType(This,peDataSourceType) ) 

#define ISystemMonitor_put_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> put_SqlDsnName(This,bsSqlDsnName) ) 

#define ISystemMonitor_get_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> get_SqlDsnName(This,bsSqlDsnName) ) 

#define ISystemMonitor_put_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> put_SqlLogSetName(This,bsSqlLogSetName) ) 

#define ISystemMonitor_get_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> get_SqlLogSetName(This,bsSqlLogSetName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemMonitor_INTERFACE_DEFINED__ */


#ifndef __ISystemMonitor2_INTERFACE_DEFINED__
#define __ISystemMonitor2_INTERFACE_DEFINED__

/* interface ISystemMonitor2 */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_ISystemMonitor2,0x08e3206a,0x5fd2,0x4fde,0xa8,0xa5,0x8c,0xb3,0xb6,0x3d,0x26,0x77);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08e3206a-5fd2-4fde-a8a5-8cb3b63d2677")
    ISystemMonitor2 : public ISystemMonitor
    {
    public:
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableDigitGrouping( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableDigitGrouping( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableToolTips( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableToolTips( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTimeAxisLabels( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTimeAxisLabels( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ChartScroll( 
            /* [in] */ VARIANT_BOOL bScroll) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChartScroll( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbScroll) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DataPointCount( 
            /* [in] */ INT iNewCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataPointCount( 
            /* [retval][out] */ __RPC__out INT *piDataPointCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ScaleToFit( 
            VARIANT_BOOL bSelectedCountersOnly) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveAs( 
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Relog( 
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType,
            INT iFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearData( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogSourceStartTime( 
            /* [out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogSourceStopTime( 
            /* [out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLogViewRange( 
            /* [in] */ DATE StartTime,
            /* [in] */ DATE StopTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetLogViewRange( 
            /* [out] */ __RPC__out DATE *StartTime,
            /* [out] */ __RPC__out DATE *StopTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BatchingLock( 
            /* [in] */ VARIANT_BOOL fLock,
            /* [in] */ SysmonBatchReason eBatchReason) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadSettings( 
            /* [in] */ __RPC__in BSTR bstrSettingFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemMonitor2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISystemMonitor2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *iAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iAppearance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *iBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iBorderStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in_opt IFontDisp *pFont);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Counters )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowVerticalGrid )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowVerticalGrid )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowHorizontalGrid )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHorizontalGrid )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowLegend )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowLegend )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowScaleLabels )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowScaleLabels )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowValueBar )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowValueBar )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MaximumScale )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumScale )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumScale )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumScale )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UpdateInterval )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ FLOAT fValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateInterval )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out FLOAT *pfValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DisplayTypeConstants eDisplayType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ManualUpdate )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ManualUpdate )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GraphTitle )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GraphTitle )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_YAxisLabel )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_YAxisLabel )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CollectSample )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateGraph )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BrowseCounters )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisplayProperties )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *Counter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AddCounter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteCounter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in_opt ICounterItem *pCtr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColorCtl )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColorCtl )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogFileName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFileName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStart )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DATE StartTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStart )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out DATE *StartTime);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStop )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DATE StopTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStop )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out DATE *StopTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GridColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GridColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TimeBarColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TimeBarColor )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Highlight )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Highlight )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowToolbar )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowToolbar )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Paste )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Copy )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReadOnly )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReportValueType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ ReportValueTypeConstants eReportValueType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReportValueType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MonitorDuplicateInstances )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MonitorDuplicateInstances )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayFilter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayFilter )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFiles )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataSourceType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DataSourceTypeConstants eDataSourceType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataSourceType )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlDsnName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsSqlDsnName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlDsnName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlLogSetName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bsSqlLogSetName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlLogSetName )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableDigitGrouping )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableDigitGrouping )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableToolTips )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableToolTips )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTimeAxisLabels )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTimeAxisLabels )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ChartScroll )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL bScroll);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChartScroll )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbScroll);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataPointCount )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ INT iNewCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataPointCount )( 
            __RPC__in ISystemMonitor2 * This,
            /* [retval][out] */ __RPC__out INT *piDataPointCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ScaleToFit )( 
            __RPC__in ISystemMonitor2 * This,
            VARIANT_BOOL bSelectedCountersOnly);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveAs )( 
            __RPC__in ISystemMonitor2 * This,
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Relog )( 
            __RPC__in ISystemMonitor2 * This,
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType,
            INT iFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ClearData )( 
            __RPC__in ISystemMonitor2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogSourceStartTime )( 
            __RPC__in ISystemMonitor2 * This,
            /* [out] */ __RPC__out DATE *pDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogSourceStopTime )( 
            __RPC__in ISystemMonitor2 * This,
            /* [out] */ __RPC__out DATE *pDate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLogViewRange )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ DATE StartTime,
            /* [in] */ DATE StopTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetLogViewRange )( 
            __RPC__in ISystemMonitor2 * This,
            /* [out] */ __RPC__out DATE *StartTime,
            /* [out] */ __RPC__out DATE *StopTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *BatchingLock )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ VARIANT_BOOL fLock,
            /* [in] */ SysmonBatchReason eBatchReason);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoadSettings )( 
            __RPC__in ISystemMonitor2 * This,
            /* [in] */ __RPC__in BSTR bstrSettingFileName);
        
        END_INTERFACE
    } ISystemMonitor2Vtbl;

    interface ISystemMonitor2
    {
        CONST_VTBL struct ISystemMonitor2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemMonitor2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemMonitor2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemMonitor2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemMonitor2_get_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,iAppearance) ) 

#define ISystemMonitor2_put_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,iAppearance) ) 

#define ISystemMonitor2_get_BackColor(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColor(This,pColor) ) 

#define ISystemMonitor2_put_BackColor(This,Color)	\
    ( (This)->lpVtbl -> put_BackColor(This,Color) ) 

#define ISystemMonitor2_get_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,iBorderStyle) ) 

#define ISystemMonitor2_put_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,iBorderStyle) ) 

#define ISystemMonitor2_get_ForeColor(This,pColor)	\
    ( (This)->lpVtbl -> get_ForeColor(This,pColor) ) 

#define ISystemMonitor2_put_ForeColor(This,Color)	\
    ( (This)->lpVtbl -> put_ForeColor(This,Color) ) 

#define ISystemMonitor2_get_Font(This,ppFont)	\
    ( (This)->lpVtbl -> get_Font(This,ppFont) ) 

#define ISystemMonitor2_putref_Font(This,pFont)	\
    ( (This)->lpVtbl -> putref_Font(This,pFont) ) 

#define ISystemMonitor2_get_Counters(This,ppICounters)	\
    ( (This)->lpVtbl -> get_Counters(This,ppICounters) ) 

#define ISystemMonitor2_put_ShowVerticalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowVerticalGrid(This,bState) ) 

#define ISystemMonitor2_get_ShowVerticalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowVerticalGrid(This,pbState) ) 

#define ISystemMonitor2_put_ShowHorizontalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowHorizontalGrid(This,bState) ) 

#define ISystemMonitor2_get_ShowHorizontalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowHorizontalGrid(This,pbState) ) 

#define ISystemMonitor2_put_ShowLegend(This,bState)	\
    ( (This)->lpVtbl -> put_ShowLegend(This,bState) ) 

#define ISystemMonitor2_get_ShowLegend(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowLegend(This,pbState) ) 

#define ISystemMonitor2_put_ShowScaleLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowScaleLabels(This,bState) ) 

#define ISystemMonitor2_get_ShowScaleLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowScaleLabels(This,pbState) ) 

#define ISystemMonitor2_put_ShowValueBar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowValueBar(This,bState) ) 

#define ISystemMonitor2_get_ShowValueBar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowValueBar(This,pbState) ) 

#define ISystemMonitor2_put_MaximumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MaximumScale(This,iValue) ) 

#define ISystemMonitor2_get_MaximumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MaximumScale(This,piValue) ) 

#define ISystemMonitor2_put_MinimumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MinimumScale(This,iValue) ) 

#define ISystemMonitor2_get_MinimumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MinimumScale(This,piValue) ) 

#define ISystemMonitor2_put_UpdateInterval(This,fValue)	\
    ( (This)->lpVtbl -> put_UpdateInterval(This,fValue) ) 

#define ISystemMonitor2_get_UpdateInterval(This,pfValue)	\
    ( (This)->lpVtbl -> get_UpdateInterval(This,pfValue) ) 

#define ISystemMonitor2_put_DisplayType(This,eDisplayType)	\
    ( (This)->lpVtbl -> put_DisplayType(This,eDisplayType) ) 

#define ISystemMonitor2_get_DisplayType(This,peDisplayType)	\
    ( (This)->lpVtbl -> get_DisplayType(This,peDisplayType) ) 

#define ISystemMonitor2_put_ManualUpdate(This,bState)	\
    ( (This)->lpVtbl -> put_ManualUpdate(This,bState) ) 

#define ISystemMonitor2_get_ManualUpdate(This,pbState)	\
    ( (This)->lpVtbl -> get_ManualUpdate(This,pbState) ) 

#define ISystemMonitor2_put_GraphTitle(This,bsTitle)	\
    ( (This)->lpVtbl -> put_GraphTitle(This,bsTitle) ) 

#define ISystemMonitor2_get_GraphTitle(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_GraphTitle(This,pbsTitle) ) 

#define ISystemMonitor2_put_YAxisLabel(This,bsTitle)	\
    ( (This)->lpVtbl -> put_YAxisLabel(This,bsTitle) ) 

#define ISystemMonitor2_get_YAxisLabel(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_YAxisLabel(This,pbsTitle) ) 

#define ISystemMonitor2_CollectSample(This)	\
    ( (This)->lpVtbl -> CollectSample(This) ) 

#define ISystemMonitor2_UpdateGraph(This)	\
    ( (This)->lpVtbl -> UpdateGraph(This) ) 

#define ISystemMonitor2_BrowseCounters(This)	\
    ( (This)->lpVtbl -> BrowseCounters(This) ) 

#define ISystemMonitor2_DisplayProperties(This)	\
    ( (This)->lpVtbl -> DisplayProperties(This) ) 

#define ISystemMonitor2_Counter(This,iIndex,ppICounter)	\
    ( (This)->lpVtbl -> Counter(This,iIndex,ppICounter) ) 

#define ISystemMonitor2_AddCounter(This,bsPath,ppICounter)	\
    ( (This)->lpVtbl -> AddCounter(This,bsPath,ppICounter) ) 

#define ISystemMonitor2_DeleteCounter(This,pCtr)	\
    ( (This)->lpVtbl -> DeleteCounter(This,pCtr) ) 

#define ISystemMonitor2_get_BackColorCtl(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColorCtl(This,pColor) ) 

#define ISystemMonitor2_put_BackColorCtl(This,Color)	\
    ( (This)->lpVtbl -> put_BackColorCtl(This,Color) ) 

#define ISystemMonitor2_put_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> put_LogFileName(This,bsFileName) ) 

#define ISystemMonitor2_get_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> get_LogFileName(This,bsFileName) ) 

#define ISystemMonitor2_put_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> put_LogViewStart(This,StartTime) ) 

#define ISystemMonitor2_get_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> get_LogViewStart(This,StartTime) ) 

#define ISystemMonitor2_put_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> put_LogViewStop(This,StopTime) ) 

#define ISystemMonitor2_get_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> get_LogViewStop(This,StopTime) ) 

#define ISystemMonitor2_get_GridColor(This,pColor)	\
    ( (This)->lpVtbl -> get_GridColor(This,pColor) ) 

#define ISystemMonitor2_put_GridColor(This,Color)	\
    ( (This)->lpVtbl -> put_GridColor(This,Color) ) 

#define ISystemMonitor2_get_TimeBarColor(This,pColor)	\
    ( (This)->lpVtbl -> get_TimeBarColor(This,pColor) ) 

#define ISystemMonitor2_put_TimeBarColor(This,Color)	\
    ( (This)->lpVtbl -> put_TimeBarColor(This,Color) ) 

#define ISystemMonitor2_get_Highlight(This,pbState)	\
    ( (This)->lpVtbl -> get_Highlight(This,pbState) ) 

#define ISystemMonitor2_put_Highlight(This,bState)	\
    ( (This)->lpVtbl -> put_Highlight(This,bState) ) 

#define ISystemMonitor2_get_ShowToolbar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowToolbar(This,pbState) ) 

#define ISystemMonitor2_put_ShowToolbar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowToolbar(This,bState) ) 

#define ISystemMonitor2_Paste(This)	\
    ( (This)->lpVtbl -> Paste(This) ) 

#define ISystemMonitor2_Copy(This)	\
    ( (This)->lpVtbl -> Copy(This) ) 

#define ISystemMonitor2_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define ISystemMonitor2_put_ReadOnly(This,bState)	\
    ( (This)->lpVtbl -> put_ReadOnly(This,bState) ) 

#define ISystemMonitor2_get_ReadOnly(This,pbState)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,pbState) ) 

#define ISystemMonitor2_put_ReportValueType(This,eReportValueType)	\
    ( (This)->lpVtbl -> put_ReportValueType(This,eReportValueType) ) 

#define ISystemMonitor2_get_ReportValueType(This,peReportValueType)	\
    ( (This)->lpVtbl -> get_ReportValueType(This,peReportValueType) ) 

#define ISystemMonitor2_put_MonitorDuplicateInstances(This,bState)	\
    ( (This)->lpVtbl -> put_MonitorDuplicateInstances(This,bState) ) 

#define ISystemMonitor2_get_MonitorDuplicateInstances(This,pbState)	\
    ( (This)->lpVtbl -> get_MonitorDuplicateInstances(This,pbState) ) 

#define ISystemMonitor2_put_DisplayFilter(This,iValue)	\
    ( (This)->lpVtbl -> put_DisplayFilter(This,iValue) ) 

#define ISystemMonitor2_get_DisplayFilter(This,piValue)	\
    ( (This)->lpVtbl -> get_DisplayFilter(This,piValue) ) 

#define ISystemMonitor2_get_LogFiles(This,ppILogFiles)	\
    ( (This)->lpVtbl -> get_LogFiles(This,ppILogFiles) ) 

#define ISystemMonitor2_put_DataSourceType(This,eDataSourceType)	\
    ( (This)->lpVtbl -> put_DataSourceType(This,eDataSourceType) ) 

#define ISystemMonitor2_get_DataSourceType(This,peDataSourceType)	\
    ( (This)->lpVtbl -> get_DataSourceType(This,peDataSourceType) ) 

#define ISystemMonitor2_put_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> put_SqlDsnName(This,bsSqlDsnName) ) 

#define ISystemMonitor2_get_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> get_SqlDsnName(This,bsSqlDsnName) ) 

#define ISystemMonitor2_put_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> put_SqlLogSetName(This,bsSqlLogSetName) ) 

#define ISystemMonitor2_get_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> get_SqlLogSetName(This,bsSqlLogSetName) ) 


#define ISystemMonitor2_put_EnableDigitGrouping(This,bState)	\
    ( (This)->lpVtbl -> put_EnableDigitGrouping(This,bState) ) 

#define ISystemMonitor2_get_EnableDigitGrouping(This,pbState)	\
    ( (This)->lpVtbl -> get_EnableDigitGrouping(This,pbState) ) 

#define ISystemMonitor2_put_EnableToolTips(This,bState)	\
    ( (This)->lpVtbl -> put_EnableToolTips(This,bState) ) 

#define ISystemMonitor2_get_EnableToolTips(This,pbState)	\
    ( (This)->lpVtbl -> get_EnableToolTips(This,pbState) ) 

#define ISystemMonitor2_put_ShowTimeAxisLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowTimeAxisLabels(This,bState) ) 

#define ISystemMonitor2_get_ShowTimeAxisLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowTimeAxisLabels(This,pbState) ) 

#define ISystemMonitor2_put_ChartScroll(This,bScroll)	\
    ( (This)->lpVtbl -> put_ChartScroll(This,bScroll) ) 

#define ISystemMonitor2_get_ChartScroll(This,pbScroll)	\
    ( (This)->lpVtbl -> get_ChartScroll(This,pbScroll) ) 

#define ISystemMonitor2_put_DataPointCount(This,iNewCount)	\
    ( (This)->lpVtbl -> put_DataPointCount(This,iNewCount) ) 

#define ISystemMonitor2_get_DataPointCount(This,piDataPointCount)	\
    ( (This)->lpVtbl -> get_DataPointCount(This,piDataPointCount) ) 

#define ISystemMonitor2_ScaleToFit(This,bSelectedCountersOnly)	\
    ( (This)->lpVtbl -> ScaleToFit(This,bSelectedCountersOnly) ) 

#define ISystemMonitor2_SaveAs(This,bstrFileName,eSysmonFileType)	\
    ( (This)->lpVtbl -> SaveAs(This,bstrFileName,eSysmonFileType) ) 

#define ISystemMonitor2_Relog(This,bstrFileName,eSysmonFileType,iFilter)	\
    ( (This)->lpVtbl -> Relog(This,bstrFileName,eSysmonFileType,iFilter) ) 

#define ISystemMonitor2_ClearData(This)	\
    ( (This)->lpVtbl -> ClearData(This) ) 

#define ISystemMonitor2_get_LogSourceStartTime(This,pDate)	\
    ( (This)->lpVtbl -> get_LogSourceStartTime(This,pDate) ) 

#define ISystemMonitor2_get_LogSourceStopTime(This,pDate)	\
    ( (This)->lpVtbl -> get_LogSourceStopTime(This,pDate) ) 

#define ISystemMonitor2_SetLogViewRange(This,StartTime,StopTime)	\
    ( (This)->lpVtbl -> SetLogViewRange(This,StartTime,StopTime) ) 

#define ISystemMonitor2_GetLogViewRange(This,StartTime,StopTime)	\
    ( (This)->lpVtbl -> GetLogViewRange(This,StartTime,StopTime) ) 

#define ISystemMonitor2_BatchingLock(This,fLock,eBatchReason)	\
    ( (This)->lpVtbl -> BatchingLock(This,fLock,eBatchReason) ) 

#define ISystemMonitor2_LoadSettings(This,bstrSettingFileName)	\
    ( (This)->lpVtbl -> LoadSettings(This,bstrSettingFileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemMonitor2_INTERFACE_DEFINED__ */


#ifndef ___ISystemMonitorUnion_INTERFACE_DEFINED__
#define ___ISystemMonitorUnion_INTERFACE_DEFINED__

/* interface _ISystemMonitorUnion */
/* [object][hidden][uuid] */ 


DEFINE_GUID(IID__ISystemMonitorUnion,0xc8a77338,0x265f,0x4de5,0xaa,0x25,0xc7,0xda,0x1c,0xe5,0xa8,0xf4);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c8a77338-265f-4de5-aa25-c7da1ce5a8f4")
    _ISystemMonitorUnion : public IUnknown
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Appearance( 
            /* [retval][out] */ __RPC__out INT *iAppearance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Appearance( 
            /* [in] */ INT iAppearance) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BorderStyle( 
            /* [retval][out] */ __RPC__out INT *iBorderStyle) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BorderStyle( 
            /* [in] */ INT iBorderStyle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ForeColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ForeColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Font( 
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Font( 
            /* [in] */ __RPC__in_opt IFontDisp *pFont) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Counters( 
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowVerticalGrid( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowVerticalGrid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowHorizontalGrid( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowHorizontalGrid( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowLegend( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowLegend( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowScaleLabels( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowScaleLabels( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowValueBar( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowValueBar( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MaximumScale( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MaximumScale( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MinimumScale( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MinimumScale( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_UpdateInterval( 
            /* [in] */ FLOAT fValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UpdateInterval( 
            /* [retval][out] */ __RPC__out FLOAT *pfValue) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayType( 
            /* [in] */ DisplayTypeConstants eDisplayType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayType( 
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ManualUpdate( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ManualUpdate( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_GraphTitle( 
            /* [in] */ __RPC__in BSTR bsTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_GraphTitle( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_YAxisLabel( 
            /* [in] */ __RPC__in BSTR bsTitle) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_YAxisLabel( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CollectSample( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateGraph( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE BrowseCounters( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE DisplayProperties( void) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE Counter( 
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE AddCounter( 
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter) = 0;
        
        virtual /* [hidden][id] */ HRESULT STDMETHODCALLTYPE DeleteCounter( 
            /* [in] */ __RPC__in_opt ICounterItem *pCtr) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BackColorCtl( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BackColorCtl( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogFileName( 
            /* [in] */ __RPC__in BSTR bsFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogViewStart( 
            /* [in] */ DATE StartTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogViewStart( 
            /* [retval][out] */ __RPC__out DATE *StartTime) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_LogViewStop( 
            /* [in] */ DATE StopTime) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogViewStop( 
            /* [retval][out] */ __RPC__out DATE *StopTime) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_GridColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_GridColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TimeBarColor( 
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TimeBarColor( 
            /* [in] */ OLE_COLOR Color) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Highlight( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Highlight( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowToolbar( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowToolbar( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Paste( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Copy( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReadOnly( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadOnly( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ReportValueType( 
            /* [in] */ ReportValueTypeConstants eReportValueType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ReportValueType( 
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_MonitorDuplicateInstances( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_MonitorDuplicateInstances( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayFilter( 
            /* [in] */ INT iValue) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayFilter( 
            /* [retval][out] */ __RPC__out INT *piValue) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LogFiles( 
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DataSourceType( 
            /* [in] */ DataSourceTypeConstants eDataSourceType) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataSourceType( 
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SqlDsnName( 
            /* [in] */ __RPC__in BSTR bsSqlDsnName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SqlDsnName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_SqlLogSetName( 
            /* [in] */ __RPC__in BSTR bsSqlLogSetName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_SqlLogSetName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableDigitGrouping( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableDigitGrouping( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableToolTips( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableToolTips( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTimeAxisLabels( 
            /* [in] */ VARIANT_BOOL bState) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTimeAxisLabels( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_ChartScroll( 
            /* [in] */ VARIANT_BOOL bScroll) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ChartScroll( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbScroll) = 0;
        
        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE put_DataPointCount( 
            /* [in] */ INT iNewCount) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DataPointCount( 
            /* [retval][out] */ __RPC__out INT *piDataPointCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ScaleToFit( 
            VARIANT_BOOL bSelectedCountersOnly) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SaveAs( 
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Relog( 
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType,
            INT iFilter) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ClearData( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogSourceStartTime( 
            /* [out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LogSourceStopTime( 
            /* [out] */ __RPC__out DATE *pDate) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetLogViewRange( 
            /* [in] */ DATE StartTime,
            /* [in] */ DATE StopTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetLogViewRange( 
            /* [out] */ __RPC__out DATE *StartTime,
            /* [out] */ __RPC__out DATE *StopTime) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BatchingLock( 
            /* [in] */ VARIANT_BOOL fLock,
            /* [in] */ SysmonBatchReason eBatchReason) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE LoadSettings( 
            /* [in] */ __RPC__in BSTR bstrSettingFileName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _ISystemMonitorUnionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Appearance )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *iAppearance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Appearance )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iAppearance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BorderStyle )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *iBorderStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BorderStyle )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iBorderStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ForeColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ForeColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Font )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt IFontDisp **ppFont);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE *putref_Font )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in_opt IFontDisp *pFont);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Counters )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt ICounters **ppICounters);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowVerticalGrid )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowVerticalGrid )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowHorizontalGrid )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowHorizontalGrid )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowLegend )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowLegend )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowScaleLabels )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowScaleLabels )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowValueBar )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowValueBar )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MaximumScale )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MaximumScale )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MinimumScale )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MinimumScale )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UpdateInterval )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ FLOAT fValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UpdateInterval )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out FLOAT *pfValue);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DisplayTypeConstants eDisplayType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out DisplayTypeConstants *peDisplayType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ManualUpdate )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ManualUpdate )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GraphTitle )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GraphTitle )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_YAxisLabel )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsTitle);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_YAxisLabel )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbsTitle);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CollectSample )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateGraph )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *BrowseCounters )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *DisplayProperties )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *Counter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iIndex,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *AddCounter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsPath,
            /* [out] */ __RPC__deref_out_opt ICounterItem **ppICounter);
        
        /* [hidden][id] */ HRESULT ( STDMETHODCALLTYPE *DeleteCounter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in_opt ICounterItem *pCtr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BackColorCtl )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BackColorCtl )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogFileName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFileName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsFileName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStart )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DATE StartTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStart )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out DATE *StartTime);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LogViewStop )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DATE StopTime);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogViewStop )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out DATE *StopTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GridColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_GridColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_TimeBarColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out OLE_COLOR *pColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_TimeBarColor )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ OLE_COLOR Color);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Highlight )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Highlight )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowToolbar )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowToolbar )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Paste )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Copy )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReadOnly )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReadOnly )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ReportValueType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ ReportValueTypeConstants eReportValueType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ReportValueType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out ReportValueTypeConstants *peReportValueType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_MonitorDuplicateInstances )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_MonitorDuplicateInstances )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DisplayFilter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iValue);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DisplayFilter )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *piValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogFiles )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt ILogFiles **ppILogFiles);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataSourceType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DataSourceTypeConstants eDataSourceType);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataSourceType )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out DataSourceTypeConstants *peDataSourceType);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlDsnName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsSqlDsnName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlDsnName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlDsnName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_SqlLogSetName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bsSqlLogSetName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_SqlLogSetName )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *bsSqlLogSetName);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableDigitGrouping )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableDigitGrouping )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EnableToolTips )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EnableToolTips )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ShowTimeAxisLabels )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bState);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ShowTimeAxisLabels )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbState);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ChartScroll )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL bScroll);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ChartScroll )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *pbScroll);
        
        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DataPointCount )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ INT iNewCount);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DataPointCount )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [retval][out] */ __RPC__out INT *piDataPointCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ScaleToFit )( 
            __RPC__in _ISystemMonitorUnion * This,
            VARIANT_BOOL bSelectedCountersOnly);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SaveAs )( 
            __RPC__in _ISystemMonitorUnion * This,
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Relog )( 
            __RPC__in _ISystemMonitorUnion * This,
            __RPC__in BSTR bstrFileName,
            SysmonFileType eSysmonFileType,
            INT iFilter);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ClearData )( 
            __RPC__in _ISystemMonitorUnion * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogSourceStartTime )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [out] */ __RPC__out DATE *pDate);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LogSourceStopTime )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [out] */ __RPC__out DATE *pDate);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetLogViewRange )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ DATE StartTime,
            /* [in] */ DATE StopTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetLogViewRange )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [out] */ __RPC__out DATE *StartTime,
            /* [out] */ __RPC__out DATE *StopTime);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *BatchingLock )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ VARIANT_BOOL fLock,
            /* [in] */ SysmonBatchReason eBatchReason);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *LoadSettings )( 
            __RPC__in _ISystemMonitorUnion * This,
            /* [in] */ __RPC__in BSTR bstrSettingFileName);
        
        END_INTERFACE
    } _ISystemMonitorUnionVtbl;

    interface _ISystemMonitorUnion
    {
        CONST_VTBL struct _ISystemMonitorUnionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ISystemMonitorUnion_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _ISystemMonitorUnion_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _ISystemMonitorUnion_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _ISystemMonitorUnion_get_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> get_Appearance(This,iAppearance) ) 

#define _ISystemMonitorUnion_put_Appearance(This,iAppearance)	\
    ( (This)->lpVtbl -> put_Appearance(This,iAppearance) ) 

#define _ISystemMonitorUnion_get_BackColor(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColor(This,pColor) ) 

#define _ISystemMonitorUnion_put_BackColor(This,Color)	\
    ( (This)->lpVtbl -> put_BackColor(This,Color) ) 

#define _ISystemMonitorUnion_get_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> get_BorderStyle(This,iBorderStyle) ) 

#define _ISystemMonitorUnion_put_BorderStyle(This,iBorderStyle)	\
    ( (This)->lpVtbl -> put_BorderStyle(This,iBorderStyle) ) 

#define _ISystemMonitorUnion_get_ForeColor(This,pColor)	\
    ( (This)->lpVtbl -> get_ForeColor(This,pColor) ) 

#define _ISystemMonitorUnion_put_ForeColor(This,Color)	\
    ( (This)->lpVtbl -> put_ForeColor(This,Color) ) 

#define _ISystemMonitorUnion_get_Font(This,ppFont)	\
    ( (This)->lpVtbl -> get_Font(This,ppFont) ) 

#define _ISystemMonitorUnion_putref_Font(This,pFont)	\
    ( (This)->lpVtbl -> putref_Font(This,pFont) ) 

#define _ISystemMonitorUnion_get_Counters(This,ppICounters)	\
    ( (This)->lpVtbl -> get_Counters(This,ppICounters) ) 

#define _ISystemMonitorUnion_put_ShowVerticalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowVerticalGrid(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowVerticalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowVerticalGrid(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowHorizontalGrid(This,bState)	\
    ( (This)->lpVtbl -> put_ShowHorizontalGrid(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowHorizontalGrid(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowHorizontalGrid(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowLegend(This,bState)	\
    ( (This)->lpVtbl -> put_ShowLegend(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowLegend(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowLegend(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowScaleLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowScaleLabels(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowScaleLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowScaleLabels(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowValueBar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowValueBar(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowValueBar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowValueBar(This,pbState) ) 

#define _ISystemMonitorUnion_put_MaximumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MaximumScale(This,iValue) ) 

#define _ISystemMonitorUnion_get_MaximumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MaximumScale(This,piValue) ) 

#define _ISystemMonitorUnion_put_MinimumScale(This,iValue)	\
    ( (This)->lpVtbl -> put_MinimumScale(This,iValue) ) 

#define _ISystemMonitorUnion_get_MinimumScale(This,piValue)	\
    ( (This)->lpVtbl -> get_MinimumScale(This,piValue) ) 

#define _ISystemMonitorUnion_put_UpdateInterval(This,fValue)	\
    ( (This)->lpVtbl -> put_UpdateInterval(This,fValue) ) 

#define _ISystemMonitorUnion_get_UpdateInterval(This,pfValue)	\
    ( (This)->lpVtbl -> get_UpdateInterval(This,pfValue) ) 

#define _ISystemMonitorUnion_put_DisplayType(This,eDisplayType)	\
    ( (This)->lpVtbl -> put_DisplayType(This,eDisplayType) ) 

#define _ISystemMonitorUnion_get_DisplayType(This,peDisplayType)	\
    ( (This)->lpVtbl -> get_DisplayType(This,peDisplayType) ) 

#define _ISystemMonitorUnion_put_ManualUpdate(This,bState)	\
    ( (This)->lpVtbl -> put_ManualUpdate(This,bState) ) 

#define _ISystemMonitorUnion_get_ManualUpdate(This,pbState)	\
    ( (This)->lpVtbl -> get_ManualUpdate(This,pbState) ) 

#define _ISystemMonitorUnion_put_GraphTitle(This,bsTitle)	\
    ( (This)->lpVtbl -> put_GraphTitle(This,bsTitle) ) 

#define _ISystemMonitorUnion_get_GraphTitle(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_GraphTitle(This,pbsTitle) ) 

#define _ISystemMonitorUnion_put_YAxisLabel(This,bsTitle)	\
    ( (This)->lpVtbl -> put_YAxisLabel(This,bsTitle) ) 

#define _ISystemMonitorUnion_get_YAxisLabel(This,pbsTitle)	\
    ( (This)->lpVtbl -> get_YAxisLabel(This,pbsTitle) ) 

#define _ISystemMonitorUnion_CollectSample(This)	\
    ( (This)->lpVtbl -> CollectSample(This) ) 

#define _ISystemMonitorUnion_UpdateGraph(This)	\
    ( (This)->lpVtbl -> UpdateGraph(This) ) 

#define _ISystemMonitorUnion_BrowseCounters(This)	\
    ( (This)->lpVtbl -> BrowseCounters(This) ) 

#define _ISystemMonitorUnion_DisplayProperties(This)	\
    ( (This)->lpVtbl -> DisplayProperties(This) ) 

#define _ISystemMonitorUnion_Counter(This,iIndex,ppICounter)	\
    ( (This)->lpVtbl -> Counter(This,iIndex,ppICounter) ) 

#define _ISystemMonitorUnion_AddCounter(This,bsPath,ppICounter)	\
    ( (This)->lpVtbl -> AddCounter(This,bsPath,ppICounter) ) 

#define _ISystemMonitorUnion_DeleteCounter(This,pCtr)	\
    ( (This)->lpVtbl -> DeleteCounter(This,pCtr) ) 

#define _ISystemMonitorUnion_get_BackColorCtl(This,pColor)	\
    ( (This)->lpVtbl -> get_BackColorCtl(This,pColor) ) 

#define _ISystemMonitorUnion_put_BackColorCtl(This,Color)	\
    ( (This)->lpVtbl -> put_BackColorCtl(This,Color) ) 

#define _ISystemMonitorUnion_put_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> put_LogFileName(This,bsFileName) ) 

#define _ISystemMonitorUnion_get_LogFileName(This,bsFileName)	\
    ( (This)->lpVtbl -> get_LogFileName(This,bsFileName) ) 

#define _ISystemMonitorUnion_put_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> put_LogViewStart(This,StartTime) ) 

#define _ISystemMonitorUnion_get_LogViewStart(This,StartTime)	\
    ( (This)->lpVtbl -> get_LogViewStart(This,StartTime) ) 

#define _ISystemMonitorUnion_put_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> put_LogViewStop(This,StopTime) ) 

#define _ISystemMonitorUnion_get_LogViewStop(This,StopTime)	\
    ( (This)->lpVtbl -> get_LogViewStop(This,StopTime) ) 

#define _ISystemMonitorUnion_get_GridColor(This,pColor)	\
    ( (This)->lpVtbl -> get_GridColor(This,pColor) ) 

#define _ISystemMonitorUnion_put_GridColor(This,Color)	\
    ( (This)->lpVtbl -> put_GridColor(This,Color) ) 

#define _ISystemMonitorUnion_get_TimeBarColor(This,pColor)	\
    ( (This)->lpVtbl -> get_TimeBarColor(This,pColor) ) 

#define _ISystemMonitorUnion_put_TimeBarColor(This,Color)	\
    ( (This)->lpVtbl -> put_TimeBarColor(This,Color) ) 

#define _ISystemMonitorUnion_get_Highlight(This,pbState)	\
    ( (This)->lpVtbl -> get_Highlight(This,pbState) ) 

#define _ISystemMonitorUnion_put_Highlight(This,bState)	\
    ( (This)->lpVtbl -> put_Highlight(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowToolbar(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowToolbar(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowToolbar(This,bState)	\
    ( (This)->lpVtbl -> put_ShowToolbar(This,bState) ) 

#define _ISystemMonitorUnion_Paste(This)	\
    ( (This)->lpVtbl -> Paste(This) ) 

#define _ISystemMonitorUnion_Copy(This)	\
    ( (This)->lpVtbl -> Copy(This) ) 

#define _ISystemMonitorUnion_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define _ISystemMonitorUnion_put_ReadOnly(This,bState)	\
    ( (This)->lpVtbl -> put_ReadOnly(This,bState) ) 

#define _ISystemMonitorUnion_get_ReadOnly(This,pbState)	\
    ( (This)->lpVtbl -> get_ReadOnly(This,pbState) ) 

#define _ISystemMonitorUnion_put_ReportValueType(This,eReportValueType)	\
    ( (This)->lpVtbl -> put_ReportValueType(This,eReportValueType) ) 

#define _ISystemMonitorUnion_get_ReportValueType(This,peReportValueType)	\
    ( (This)->lpVtbl -> get_ReportValueType(This,peReportValueType) ) 

#define _ISystemMonitorUnion_put_MonitorDuplicateInstances(This,bState)	\
    ( (This)->lpVtbl -> put_MonitorDuplicateInstances(This,bState) ) 

#define _ISystemMonitorUnion_get_MonitorDuplicateInstances(This,pbState)	\
    ( (This)->lpVtbl -> get_MonitorDuplicateInstances(This,pbState) ) 

#define _ISystemMonitorUnion_put_DisplayFilter(This,iValue)	\
    ( (This)->lpVtbl -> put_DisplayFilter(This,iValue) ) 

#define _ISystemMonitorUnion_get_DisplayFilter(This,piValue)	\
    ( (This)->lpVtbl -> get_DisplayFilter(This,piValue) ) 

#define _ISystemMonitorUnion_get_LogFiles(This,ppILogFiles)	\
    ( (This)->lpVtbl -> get_LogFiles(This,ppILogFiles) ) 

#define _ISystemMonitorUnion_put_DataSourceType(This,eDataSourceType)	\
    ( (This)->lpVtbl -> put_DataSourceType(This,eDataSourceType) ) 

#define _ISystemMonitorUnion_get_DataSourceType(This,peDataSourceType)	\
    ( (This)->lpVtbl -> get_DataSourceType(This,peDataSourceType) ) 

#define _ISystemMonitorUnion_put_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> put_SqlDsnName(This,bsSqlDsnName) ) 

#define _ISystemMonitorUnion_get_SqlDsnName(This,bsSqlDsnName)	\
    ( (This)->lpVtbl -> get_SqlDsnName(This,bsSqlDsnName) ) 

#define _ISystemMonitorUnion_put_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> put_SqlLogSetName(This,bsSqlLogSetName) ) 

#define _ISystemMonitorUnion_get_SqlLogSetName(This,bsSqlLogSetName)	\
    ( (This)->lpVtbl -> get_SqlLogSetName(This,bsSqlLogSetName) ) 

#define _ISystemMonitorUnion_put_EnableDigitGrouping(This,bState)	\
    ( (This)->lpVtbl -> put_EnableDigitGrouping(This,bState) ) 

#define _ISystemMonitorUnion_get_EnableDigitGrouping(This,pbState)	\
    ( (This)->lpVtbl -> get_EnableDigitGrouping(This,pbState) ) 

#define _ISystemMonitorUnion_put_EnableToolTips(This,bState)	\
    ( (This)->lpVtbl -> put_EnableToolTips(This,bState) ) 

#define _ISystemMonitorUnion_get_EnableToolTips(This,pbState)	\
    ( (This)->lpVtbl -> get_EnableToolTips(This,pbState) ) 

#define _ISystemMonitorUnion_put_ShowTimeAxisLabels(This,bState)	\
    ( (This)->lpVtbl -> put_ShowTimeAxisLabels(This,bState) ) 

#define _ISystemMonitorUnion_get_ShowTimeAxisLabels(This,pbState)	\
    ( (This)->lpVtbl -> get_ShowTimeAxisLabels(This,pbState) ) 

#define _ISystemMonitorUnion_put_ChartScroll(This,bScroll)	\
    ( (This)->lpVtbl -> put_ChartScroll(This,bScroll) ) 

#define _ISystemMonitorUnion_get_ChartScroll(This,pbScroll)	\
    ( (This)->lpVtbl -> get_ChartScroll(This,pbScroll) ) 

#define _ISystemMonitorUnion_put_DataPointCount(This,iNewCount)	\
    ( (This)->lpVtbl -> put_DataPointCount(This,iNewCount) ) 

#define _ISystemMonitorUnion_get_DataPointCount(This,piDataPointCount)	\
    ( (This)->lpVtbl -> get_DataPointCount(This,piDataPointCount) ) 

#define _ISystemMonitorUnion_ScaleToFit(This,bSelectedCountersOnly)	\
    ( (This)->lpVtbl -> ScaleToFit(This,bSelectedCountersOnly) ) 

#define _ISystemMonitorUnion_SaveAs(This,bstrFileName,eSysmonFileType)	\
    ( (This)->lpVtbl -> SaveAs(This,bstrFileName,eSysmonFileType) ) 

#define _ISystemMonitorUnion_Relog(This,bstrFileName,eSysmonFileType,iFilter)	\
    ( (This)->lpVtbl -> Relog(This,bstrFileName,eSysmonFileType,iFilter) ) 

#define _ISystemMonitorUnion_ClearData(This)	\
    ( (This)->lpVtbl -> ClearData(This) ) 

#define _ISystemMonitorUnion_get_LogSourceStartTime(This,pDate)	\
    ( (This)->lpVtbl -> get_LogSourceStartTime(This,pDate) ) 

#define _ISystemMonitorUnion_get_LogSourceStopTime(This,pDate)	\
    ( (This)->lpVtbl -> get_LogSourceStopTime(This,pDate) ) 

#define _ISystemMonitorUnion_SetLogViewRange(This,StartTime,StopTime)	\
    ( (This)->lpVtbl -> SetLogViewRange(This,StartTime,StopTime) ) 

#define _ISystemMonitorUnion_GetLogViewRange(This,StartTime,StopTime)	\
    ( (This)->lpVtbl -> GetLogViewRange(This,StartTime,StopTime) ) 

#define _ISystemMonitorUnion_BatchingLock(This,fLock,eBatchReason)	\
    ( (This)->lpVtbl -> BatchingLock(This,fLock,eBatchReason) ) 

#define _ISystemMonitorUnion_LoadSettings(This,bstrSettingFileName)	\
    ( (This)->lpVtbl -> LoadSettings(This,bstrSettingFileName) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* ___ISystemMonitorUnion_INTERFACE_DEFINED__ */


#ifndef __DISystemMonitor_DISPINTERFACE_DEFINED__
#define __DISystemMonitor_DISPINTERFACE_DEFINED__

/* dispinterface DISystemMonitor */
/* [helpstring][hidden][uuid] */ 


DEFINE_GUID(DIID_DISystemMonitor,0x13D73D81,0xC32E,0x11cf,0x93,0x98,0x00,0xAA,0x00,0xA3,0xDD,0xEA);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("13D73D81-C32E-11cf-9398-00AA00A3DDEA")
    DISystemMonitor : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DISystemMonitorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DISystemMonitor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DISystemMonitor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DISystemMonitor * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DISystemMonitor * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DISystemMonitor * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DISystemMonitor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DISystemMonitor * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DISystemMonitorVtbl;

    interface DISystemMonitor
    {
        CONST_VTBL struct DISystemMonitorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DISystemMonitor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DISystemMonitor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DISystemMonitor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DISystemMonitor_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DISystemMonitor_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DISystemMonitor_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DISystemMonitor_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DISystemMonitor_DISPINTERFACE_DEFINED__ */


#ifndef __DISystemMonitorInternal_DISPINTERFACE_DEFINED__
#define __DISystemMonitorInternal_DISPINTERFACE_DEFINED__

/* dispinterface DISystemMonitorInternal */
/* [helpstring][hidden][uuid] */ 


DEFINE_GUID(DIID_DISystemMonitorInternal,0x194EB242,0xC32C,0x11cf,0x93,0x98,0x00,0xAA,0x00,0xA3,0xDD,0xEA);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("194EB242-C32C-11cf-9398-00AA00A3DDEA")
    DISystemMonitorInternal : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DISystemMonitorInternalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DISystemMonitorInternal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DISystemMonitorInternal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DISystemMonitorInternal * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DISystemMonitorInternal * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DISystemMonitorInternal * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DISystemMonitorInternal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DISystemMonitorInternal * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DISystemMonitorInternalVtbl;

    interface DISystemMonitorInternal
    {
        CONST_VTBL struct DISystemMonitorInternalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DISystemMonitorInternal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DISystemMonitorInternal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DISystemMonitorInternal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DISystemMonitorInternal_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DISystemMonitorInternal_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DISystemMonitorInternal_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DISystemMonitorInternal_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DISystemMonitorInternal_DISPINTERFACE_DEFINED__ */


#ifndef __ISystemMonitorEvents_INTERFACE_DEFINED__
#define __ISystemMonitorEvents_INTERFACE_DEFINED__

/* interface ISystemMonitorEvents */
/* [object][helpstring][uuid] */ 


DEFINE_GUID(IID_ISystemMonitorEvents,0xEE660EA0,0x4ABD,0x11cf,0x94,0x3A,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EE660EA0-4ABD-11cf-943A-008029004347")
    ISystemMonitorEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnCounterSelected( 
            /* [in] */ INT Index) = 0;
        
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnCounterAdded( 
            /* [in] */ INT Index) = 0;
        
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnCounterDeleted( 
            /* [in] */ INT Index) = 0;
        
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnSampleCollected( void) = 0;
        
        virtual /* [helpstring][id] */ void STDMETHODCALLTYPE OnDblClick( 
            /* [in] */ INT Index) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISystemMonitorEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ISystemMonitorEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ISystemMonitorEvents * This);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnCounterSelected )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ INT Index);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnCounterAdded )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ INT Index);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnCounterDeleted )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ INT Index);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnSampleCollected )( 
            __RPC__in ISystemMonitorEvents * This);
        
        /* [helpstring][id] */ void ( STDMETHODCALLTYPE *OnDblClick )( 
            __RPC__in ISystemMonitorEvents * This,
            /* [in] */ INT Index);
        
        END_INTERFACE
    } ISystemMonitorEventsVtbl;

    interface ISystemMonitorEvents
    {
        CONST_VTBL struct ISystemMonitorEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISystemMonitorEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ISystemMonitorEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ISystemMonitorEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ISystemMonitorEvents_OnCounterSelected(This,Index)	\
    ( (This)->lpVtbl -> OnCounterSelected(This,Index) ) 

#define ISystemMonitorEvents_OnCounterAdded(This,Index)	\
    ( (This)->lpVtbl -> OnCounterAdded(This,Index) ) 

#define ISystemMonitorEvents_OnCounterDeleted(This,Index)	\
    ( (This)->lpVtbl -> OnCounterDeleted(This,Index) ) 

#define ISystemMonitorEvents_OnSampleCollected(This)	\
    ( (This)->lpVtbl -> OnSampleCollected(This) ) 

#define ISystemMonitorEvents_OnDblClick(This,Index)	\
    ( (This)->lpVtbl -> OnDblClick(This,Index) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ISystemMonitorEvents_INTERFACE_DEFINED__ */


#ifndef __DISystemMonitorEvents_DISPINTERFACE_DEFINED__
#define __DISystemMonitorEvents_DISPINTERFACE_DEFINED__

/* dispinterface DISystemMonitorEvents */
/* [helpstring][uuid] */ 


DEFINE_GUID(DIID_DISystemMonitorEvents,0x84979930,0x4AB3,0x11cf,0x94,0x3A,0x00,0x80,0x29,0x00,0x43,0x47);

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("84979930-4AB3-11cf-943A-008029004347")
    DISystemMonitorEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct DISystemMonitorEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in DISystemMonitorEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in DISystemMonitorEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in DISystemMonitorEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in DISystemMonitorEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in DISystemMonitorEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in DISystemMonitorEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            DISystemMonitorEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } DISystemMonitorEventsVtbl;

    interface DISystemMonitorEvents
    {
        CONST_VTBL struct DISystemMonitorEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define DISystemMonitorEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define DISystemMonitorEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define DISystemMonitorEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define DISystemMonitorEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define DISystemMonitorEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define DISystemMonitorEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define DISystemMonitorEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* __DISystemMonitorEvents_DISPINTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_SystemMonitor,0xC4D2D8E0,0xD1DD,0x11ce,0x94,0x0F,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("C4D2D8E0-D1DD-11ce-940F-008029004347")
SystemMonitor;
#endif

DEFINE_GUID(CLSID_CounterItem,0xC4D2D8E0,0xD1DD,0x11ce,0x94,0x0F,0x00,0x80,0x29,0x00,0x43,0x48);

#ifdef __cplusplus

class DECLSPEC_UUID("C4D2D8E0-D1DD-11ce-940F-008029004348")
CounterItem;
#endif

DEFINE_GUID(CLSID_Counters,0xB2B066D2,0x2AAC,0x11cf,0x94,0x2F,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("B2B066D2-2AAC-11cf-942F-008029004347")
Counters;
#endif

DEFINE_GUID(CLSID_LogFileItem,0x16EC5BE8,0xDF93,0x4237,0x94,0xE4,0x9E,0xE9,0x18,0x11,0x1D,0x71);

#ifdef __cplusplus

class DECLSPEC_UUID("16EC5BE8-DF93-4237-94E4-9EE918111D71")
LogFileItem;
#endif

DEFINE_GUID(CLSID_LogFiles,0x2735D9FD,0xF6B9,0x4f19,0xA5,0xD9,0xE2,0xD0,0x68,0x58,0x4B,0xC5);

#ifdef __cplusplus

class DECLSPEC_UUID("2735D9FD-F6B9-4f19-A5D9-E2D068584BC5")
LogFiles;
#endif

DEFINE_GUID(CLSID_CounterItem2,0x43196c62,0xc31f,0x4ce3,0xa0,0x2e,0x79,0xef,0xe0,0xf6,0xa5,0x25);

#ifdef __cplusplus

class DECLSPEC_UUID("43196c62-c31f-4ce3-a02e-79efe0f6a525")
CounterItem2;
#endif

DEFINE_GUID(CLSID_SystemMonitor2,0x7f30578c,0x5f38,0x4612,0xac,0xfe,0x6e,0xd0,0x4c,0x7b,0x7a,0xf8);

#ifdef __cplusplus

class DECLSPEC_UUID("7f30578c-5f38-4612-acfe-6ed04c7b7af8")
SystemMonitor2;
#endif

DEFINE_GUID(CLSID_AppearPropPage,0xe49741e9,0x93a8,0x4ab1,0x8e,0x96,0xbf,0x44,0x82,0x28,0x2e,0x9c);

#ifdef __cplusplus

class DECLSPEC_UUID("e49741e9-93a8-4ab1-8e96-bf4482282e9c")
AppearPropPage;
#endif

DEFINE_GUID(CLSID_GeneralPropPage,0xC3E5D3D2,0x1A03,0x11CF,0x94,0x2D,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("C3E5D3D2-1A03-11CF-942D-008029004347")
GeneralPropPage;
#endif

DEFINE_GUID(CLSID_GraphPropPage,0xC3E5D3D3,0x1A03,0x11CF,0x94,0x2D,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("C3E5D3D3-1A03-11CF-942D-008029004347")
GraphPropPage;
#endif

DEFINE_GUID(CLSID_SourcePropPage,0x0CF32AA1,0x7571,0x11D0,0x93,0xC4,0x00,0xAA,0x00,0xA3,0xDD,0xEA);

#ifdef __cplusplus

class DECLSPEC_UUID("0CF32AA1-7571-11D0-93C4-00AA00A3DDEA")
SourcePropPage;
#endif

DEFINE_GUID(CLSID_CounterPropPage,0xCF948561,0xEDE8,0x11CE,0x94,0x1E,0x00,0x80,0x29,0x00,0x43,0x47);

#ifdef __cplusplus

class DECLSPEC_UUID("CF948561-EDE8-11CE-941E-008029004347")
CounterPropPage;
#endif
#endif /* __SystemMonitor_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\i_cryptasn1tls.h ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2002 - 2002
//
//  File:       i_cryptasn1tls.h
//
//  Contents:   Crypt ASN.1 Thread Local Storage (TLS) functions
//--------------------------------------------------------------------------

#ifndef __I_CRYPTASN1TLS_H__
#define __I_CRYPTASN1TLS_H__

#ifdef __cplusplus
extern "C" {
#endif


// Handle to an installed Asn1 module
typedef DWORD HCRYPTASN1MODULE;

// Pointers to ASN1 data structures
typedef void *ASN1module_t;
typedef void *ASN1encoding_t;
typedef void *ASN1decoding_t;


//+-------------------------------------------------------------------------
//  Install an Asn1 module entry and return a handle for future access.
//
//  Each thread has its own copy of the decoder and encoder associated
//  with the Asn1 module. Creation is deferred until first referenced by
//  the thread.
//
//  I_CryptGetAsn1Encoder or I_CryptGetAsn1Decoder must be called with the
//  handle returned by I_CryptInstallAsn1Module to get the thread specific
//  Asn1 encoder or decoder.
//
//  Currently, dwFlags and pvReserved aren't used and must be set to 0.
//--------------------------------------------------------------------------

HCRYPTASN1MODULE
WINAPI
I_CryptInstallAsn1Module(
    IN ASN1module_t pMod,
    IN DWORD dwFlags,
    IN void *pvReserved
    );


//+-------------------------------------------------------------------------
//  Called at DLL_PROCESS_DETACH to uninstall an hAsn1Module entry. Iterates
//  through the threads and frees their created Asn1 encoders and decoders.
//--------------------------------------------------------------------------
BOOL
WINAPI
I_CryptUninstallAsn1Module(
    IN HCRYPTASN1MODULE hAsn1Module
    );


//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 encoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  encoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1encoding_t
WINAPI
I_CryptGetAsn1Encoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );


//+-------------------------------------------------------------------------
//  Get the thread specific pointer to the Asn1 decoder specified by the
//  hAsn1Module returned by CryptInstallAsn1Module. If the
//  decoder doesn't exist, then, its created using the Asn1 module
//  associated with hAsn1Module.
//--------------------------------------------------------------------------
ASN1decoding_t
WINAPI
I_CryptGetAsn1Decoder(
    IN HCRYPTASN1MODULE hAsn1Module
    );

#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\iwstdec.h ===
//------------------------------------------------------------------------------
// File: iwstdec.h
//
// Desc: WST Decoder related definitions and interfaces for ActiveMovie
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------
// 

#ifndef __IWSTDEC__
#define __IWSTDEC__

//
//  Some data types used as WST decoder parameters by the interface
//
typedef struct _AM_WST_PAGE {
	DWORD	dwPageNr ;
	DWORD	dwSubPageNr ;
	BYTE	*pucPageData;
} AM_WST_PAGE, *PAM_WST_PAGE ;

typedef enum _AM_WST_LEVEL {
	AM_WST_LEVEL_1_5 = 0
} AM_WST_LEVEL, *PAM_WST_LEVEL ;

typedef enum _AM_WST_SERVICE {
	AM_WST_SERVICE_None = 0,
	AM_WST_SERVICE_Text,
	AM_WST_SERVICE_IDS,
	AM_WST_SERVICE_Invalid
} AM_WST_SERVICE, *PAM_WST_SERVICE ;

typedef enum _AM_WST_STATE {
	AM_WST_STATE_Off = 0,
	AM_WST_STATE_On
} AM_WST_STATE, *PAM_WST_STATE ;

typedef enum _AM_WST_STYLE {
	AM_WST_STYLE_None = 0,
	AM_WST_STYLE_Invers
} AM_WST_STYLE, *PAM_WST_STYLE ;

typedef enum _AM_WST_DRAWBGMODE {
	AM_WST_DRAWBGMODE_Opaque,
	AM_WST_DRAWBGMODE_Transparent
} AM_WST_DRAWBGMODE, *PAM_WST_DRAWBGMODE ;


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
//  WST Decoder standard COM interface
//
DECLARE_INTERFACE_(IAMWstDecoder, IUnknown)
{
	public:
		//
		// Decoder options to be used by apps
		//

		// What is the decoder's level
		STDMETHOD(GetDecoderLevel)(THIS_ AM_WST_LEVEL *lpLevel) PURE ;  

//		STDMETHOD(SetDecoderLevel)(THIS_ AM_WST_LEVEL Level) PURE ;  

		// Which of the services is being currently used
		STDMETHOD(GetCurrentService)(THIS_ AM_WST_SERVICE *lpService) PURE ;  
//		STDMETHOD(SetCurrentService)(THIS_ AM_WST_SERVICE Service) PURE ;  

		// Query/Set the service state (On/Off)
		// supported state values are AM_WSTState_On and AM_WSTState_Off
		STDMETHOD(GetServiceState)(THIS_ AM_WST_STATE *lpState) PURE ;  
		STDMETHOD(SetServiceState)(THIS_ AM_WST_STATE State) PURE ;  

		//
		// Output options to be used by downstream filters
		//

		// What size, bitdepth etc should the output video be
		STDMETHOD(GetOutputFormat)(THIS_ LPBITMAPINFOHEADER lpbmih) PURE ;
		// GetOutputFormat() method, if successful, returns 
		// 1.  S_FALSE if no output format has so far been defined by downstream filters
		// 2.  S_OK if an output format has already been defined by downstream filters
		STDMETHOD(SetOutputFormat)(THIS_ LPBITMAPINFO lpbmi) PURE ;

		// Specify physical color to be used in colorkeying the background 
		// for overlay mixing
		STDMETHOD(GetBackgroundColor)(THIS_ DWORD *pdwPhysColor) PURE ;
		STDMETHOD(SetBackgroundColor)(THIS_ DWORD dwPhysColor) PURE ;

		// Specify if whole output bitmap should be redrawn for each sample
		STDMETHOD(GetRedrawAlways)(THIS_ LPBOOL lpbOption) PURE ;
		STDMETHOD(SetRedrawAlways)(THIS_ BOOL bOption) PURE ;

		// Specify if the caption text background should be opaque/transparent
		STDMETHOD(GetDrawBackgroundMode)(THIS_ AM_WST_DRAWBGMODE *lpMode) PURE ;
		STDMETHOD(SetDrawBackgroundMode)(THIS_ AM_WST_DRAWBGMODE Mode) PURE ;
		// supported mode values are AM_WST_DrawBGMode_Opaque and
		// AM_WST_DrawBGMode_Transparent

		STDMETHOD(SetAnswerMode)(THIS_ BOOL bAnswer) PURE ;
		STDMETHOD(GetAnswerMode)(THIS_ BOOL* pbAnswer) PURE ;

		STDMETHOD(SetHoldPage)(THIS_ BOOL bHoldPage) PURE ;
		STDMETHOD(GetHoldPage)(THIS_ BOOL* pbHoldPage) PURE ;

		STDMETHOD(GetCurrentPage)(THIS_ PAM_WST_PAGE pWstPage) PURE;
		STDMETHOD(SetCurrentPage)(THIS_ AM_WST_PAGE WstPage) PURE;

} ;

#ifdef __cplusplus
}
#endif // __cplusplus
#endif // __IWSTDEC__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Iwamreg.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for wamreg.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iwamreg_h__
#define __iwamreg_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWamAdmin_FWD_DEFINED__
#define __IWamAdmin_FWD_DEFINED__
typedef interface IWamAdmin IWamAdmin;
#endif 	/* __IWamAdmin_FWD_DEFINED__ */


#ifndef __IWamAdmin2_FWD_DEFINED__
#define __IWamAdmin2_FWD_DEFINED__
typedef interface IWamAdmin2 IWamAdmin2;
#endif 	/* __IWamAdmin2_FWD_DEFINED__ */


#ifndef __IIISApplicationAdmin_FWD_DEFINED__
#define __IIISApplicationAdmin_FWD_DEFINED__
typedef interface IIISApplicationAdmin IIISApplicationAdmin;
#endif 	/* __IIISApplicationAdmin_FWD_DEFINED__ */


#ifndef __WamAdmin_FWD_DEFINED__
#define __WamAdmin_FWD_DEFINED__

#ifdef __cplusplus
typedef class WamAdmin WamAdmin;
#else
typedef struct WamAdmin WamAdmin;
#endif /* __cplusplus */

#endif 	/* __WamAdmin_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_wamreg_0000_0000 */
/* [local] */ 

/*++
                                                                                
Copyright (c) 1997-2001 Microsoft Corporation
                                                                                
Module Name: iwamreg.h
                                                                                
    WAM (Web Application Manager) Interfaces
                                                                                
--*/
#ifndef __WAMREG_IADM__IID
#define __WAMREG_IADM__IID
DEFINE_GUID(IID_IWamAdmin, 0x29822AB7, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(IID_IWamAdmin2, 0x29822AB8, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(IID_IIISApplicationAdmin, 0x7C4E1804, 0xE342, 0x483D, 0xA4, 0x3E, 0xA8, 0x50, 0xCF, 0xCC, 0x8D, 0x18);
DEFINE_GUID(IID_IIISApplicationAdmin2, 0xd643717a, 0xfc87, 0x4260, 0x88, 0xac, 0x6c, 0xe3, 0x5f, 0x0e, 0xc1, 0x4e);
DEFINE_GUID(LIBID_WAMREGLib, 0x29822AA8, 0xF302, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
DEFINE_GUID(CLSID_WamAdmin, 0x61738644, 0xF196, 0x11D0, 0x99, 0x53, 0x00, 0xC0, 0x4F, 0xD9, 0x19, 0xC1);
#endif //__WAMREG_IADM__IID
#define APPSTATUS_STOPPED	0
#define APPSTATUS_RUNNING	1
#define APPSTATUS_NOTDEFINED	2
typedef /* [public] */ 
enum __MIDL___MIDL_itf_wamreg_0000_0000_0001
    {	eAppRunInProc	= 0,
	eAppRunOutProcIsolated	= ( eAppRunInProc + 1 ) ,
	eAppRunOutProcInDefaultPool	= ( eAppRunOutProcIsolated + 1 ) 
    } 	EAppMode;



extern RPC_IF_HANDLE __MIDL_itf_wamreg_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_wamreg_0000_0000_v0_0_s_ifspec;

#ifndef __IWamAdmin_INTERFACE_DEFINED__
#define __IWamAdmin_INTERFACE_DEFINED__

/* interface IWamAdmin */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IWamAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29822AB7-F302-11D0-9953-00C04FD919C1")
    IWamAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppCreate( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppDelete( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppUnLoad( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppGetStatus( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppDeleteRecoverable( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppRecover( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWamAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWamAdmin * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWamAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWamAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDelete )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppUnLoad )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppGetStatus )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDeleteRecoverable )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppRecover )( 
            IWamAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        END_INTERFACE
    } IWamAdminVtbl;

    interface IWamAdmin
    {
        CONST_VTBL struct IWamAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWamAdmin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWamAdmin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWamAdmin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWamAdmin_AppCreate(This,szMDPath,fInProc)	\
    ( (This)->lpVtbl -> AppCreate(This,szMDPath,fInProc) ) 

#define IWamAdmin_AppDelete(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppDelete(This,szMDPath,fRecursive) ) 

#define IWamAdmin_AppUnLoad(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppUnLoad(This,szMDPath,fRecursive) ) 

#define IWamAdmin_AppGetStatus(This,szMDPath,pdwAppStatus)	\
    ( (This)->lpVtbl -> AppGetStatus(This,szMDPath,pdwAppStatus) ) 

#define IWamAdmin_AppDeleteRecoverable(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppDeleteRecoverable(This,szMDPath,fRecursive) ) 

#define IWamAdmin_AppRecover(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppRecover(This,szMDPath,fRecursive) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWamAdmin_INTERFACE_DEFINED__ */


#ifndef __IWamAdmin2_INTERFACE_DEFINED__
#define __IWamAdmin2_INTERFACE_DEFINED__

/* interface IWamAdmin2 */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IWamAdmin2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("29822AB8-F302-11D0-9953-00C04FD919C1")
    IWamAdmin2 : public IWamAdmin
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppCreate2( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWamAdmin2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWamAdmin2 * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWamAdmin2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWamAdmin2 * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fInProc);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDelete )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppUnLoad )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppGetStatus )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [out] */ DWORD *pdwAppStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppDeleteRecoverable )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppRecover )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AppCreate2 )( 
            IWamAdmin2 * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode);
        
        END_INTERFACE
    } IWamAdmin2Vtbl;

    interface IWamAdmin2
    {
        CONST_VTBL struct IWamAdmin2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWamAdmin2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWamAdmin2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWamAdmin2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWamAdmin2_AppCreate(This,szMDPath,fInProc)	\
    ( (This)->lpVtbl -> AppCreate(This,szMDPath,fInProc) ) 

#define IWamAdmin2_AppDelete(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppDelete(This,szMDPath,fRecursive) ) 

#define IWamAdmin2_AppUnLoad(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppUnLoad(This,szMDPath,fRecursive) ) 

#define IWamAdmin2_AppGetStatus(This,szMDPath,pdwAppStatus)	\
    ( (This)->lpVtbl -> AppGetStatus(This,szMDPath,pdwAppStatus) ) 

#define IWamAdmin2_AppDeleteRecoverable(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppDeleteRecoverable(This,szMDPath,fRecursive) ) 

#define IWamAdmin2_AppRecover(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> AppRecover(This,szMDPath,fRecursive) ) 


#define IWamAdmin2_AppCreate2(This,szMDPath,dwAppMode)	\
    ( (This)->lpVtbl -> AppCreate2(This,szMDPath,dwAppMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWamAdmin2_INTERFACE_DEFINED__ */


#ifndef __IIISApplicationAdmin_INTERFACE_DEFINED__
#define __IIISApplicationAdmin_INTERFACE_DEFINED__

/* interface IIISApplicationAdmin */
/* [object][unique][helpstring][uuid] */ 


EXTERN_C const IID IID_IIISApplicationAdmin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7C4E1804-E342-483D-A43E-A850CFCC8D18")
    IIISApplicationAdmin : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateApplication( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode,
            /* [string][unique][in] */ LPCWSTR szAppPoolId,
            /* [in] */ BOOL fCreatePool) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteApplication( 
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateApplicationPool( 
            /* [string][unique][in] */ LPCWSTR szPool) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE DeleteApplicationPool( 
            /* [string][unique][in] */ LPCWSTR szPool) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumerateApplicationsInPool( 
            /* [string][unique][in] */ LPCWSTR szPool,
            /* [out] */ BSTR *bstrBuffer) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RecycleApplicationPool( 
            /* [string][unique][in] */ LPCWSTR szPool) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetProcessMode( 
            /* [out] */ DWORD *pdwMode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIISApplicationAdminVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIISApplicationAdmin * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIISApplicationAdmin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIISApplicationAdmin * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateApplication )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ DWORD dwAppMode,
            /* [string][unique][in] */ LPCWSTR szAppPoolId,
            /* [in] */ BOOL fCreatePool);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteApplication )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szMDPath,
            /* [in] */ BOOL fRecursive);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateApplicationPool )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szPool);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *DeleteApplicationPool )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szPool);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumerateApplicationsInPool )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szPool,
            /* [out] */ BSTR *bstrBuffer);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RecycleApplicationPool )( 
            IIISApplicationAdmin * This,
            /* [string][unique][in] */ LPCWSTR szPool);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetProcessMode )( 
            IIISApplicationAdmin * This,
            /* [out] */ DWORD *pdwMode);
        
        END_INTERFACE
    } IIISApplicationAdminVtbl;

    interface IIISApplicationAdmin
    {
        CONST_VTBL struct IIISApplicationAdminVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIISApplicationAdmin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IIISApplicationAdmin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IIISApplicationAdmin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IIISApplicationAdmin_CreateApplication(This,szMDPath,dwAppMode,szAppPoolId,fCreatePool)	\
    ( (This)->lpVtbl -> CreateApplication(This,szMDPath,dwAppMode,szAppPoolId,fCreatePool) ) 

#define IIISApplicationAdmin_DeleteApplication(This,szMDPath,fRecursive)	\
    ( (This)->lpVtbl -> DeleteApplication(This,szMDPath,fRecursive) ) 

#define IIISApplicationAdmin_CreateApplicationPool(This,szPool)	\
    ( (This)->lpVtbl -> CreateApplicationPool(This,szPool) ) 

#define IIISApplicationAdmin_DeleteApplicationPool(This,szPool)	\
    ( (This)->lpVtbl -> DeleteApplicationPool(This,szPool) ) 

#define IIISApplicationAdmin_EnumerateApplicationsInPool(This,szPool,bstrBuffer)	\
    ( (This)->lpVtbl -> EnumerateApplicationsInPool(This,szPool,bstrBuffer) ) 

#define IIISApplicationAdmin_RecycleApplicationPool(This,szPool)	\
    ( (This)->lpVtbl -> RecycleApplicationPool(This,szPool) ) 

#define IIISApplicationAdmin_GetProcessMode(This,pdwMode)	\
    ( (This)->lpVtbl -> GetProcessMode(This,pdwMode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IIISApplicationAdmin_INTERFACE_DEFINED__ */



#ifndef __WAMREGLib_LIBRARY_DEFINED__
#define __WAMREGLib_LIBRARY_DEFINED__

/* library WAMREGLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_WAMREGLib;

EXTERN_C const CLSID CLSID_WamAdmin;

#ifdef __cplusplus

class DECLSPEC_UUID("61738644-F196-11D0-9953-00C04FD919C1")
WamAdmin;
#endif
#endif /* __WAMREGLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\journal.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for journal.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __journal_h__
#define __journal_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IJournalReader_FWD_DEFINED__
#define __IJournalReader_FWD_DEFINED__
typedef interface IJournalReader IJournalReader;
#endif 	/* __IJournalReader_FWD_DEFINED__ */


#ifndef __JournalReader_FWD_DEFINED__
#define __JournalReader_FWD_DEFINED__

#ifdef __cplusplus
typedef class JournalReader JournalReader;
#else
typedef struct JournalReader JournalReader;
#endif /* __cplusplus */

#endif 	/* __JournalReader_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 



#ifndef __JournalLib_LIBRARY_DEFINED__
#define __JournalLib_LIBRARY_DEFINED__

/* library JournalLib */
/* [helpstring][version][uuid] */ 

#define GUID_STROKE_TIMESTAMP                    L"{04EA66C4-F33A-461B-B8FE-68070D9C7575}"
#define GUID_STROKE_TIMEID                       L"{050B6BC8-3B7D-4816-8C61-BC7E905B2132}"
#define GUID_HIGHLIGHTER                         L"{9B6267B8-3968-4048-AB74-F490406A2DFA}"
#define GUID_INK_STYLE_BOLD                      L"{E02FB5C1-9693-4312-A434-00DE7F3AD493}"
#define GUID_INK_STYLE_ITALICS                   L"{05253b51-49C6-4A04-8993-64DD9ABD842A}"

EXTERN_C const IID LIBID_JournalLib;

#ifndef __IJournalReader_INTERFACE_DEFINED__
#define __IJournalReader_INTERFACE_DEFINED__

/* interface IJournalReader */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IJournalReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("26213A0B-5A6C-4472-923D-9F29EFF608B2")
    IJournalReader : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ReadFromStream( 
            /* [in] */ __RPC__in_opt IStream *pJntFile,
            /* [retval][out] */ __RPC__deref_out_opt IStream **ppJntXml) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IJournalReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IJournalReader * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IJournalReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IJournalReader * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ReadFromStream )( 
            __RPC__in IJournalReader * This,
            /* [in] */ __RPC__in_opt IStream *pJntFile,
            /* [retval][out] */ __RPC__deref_out_opt IStream **ppJntXml);
        
        END_INTERFACE
    } IJournalReaderVtbl;

    interface IJournalReader
    {
        CONST_VTBL struct IJournalReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IJournalReader_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IJournalReader_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IJournalReader_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IJournalReader_ReadFromStream(This,pJntFile,ppJntXml)	\
    ( (This)->lpVtbl -> ReadFromStream(This,pJntFile,ppJntXml) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IJournalReader_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_JournalReader;

#ifdef __cplusplus

class DECLSPEC_UUID("B4124623-FC0E-47CE-BCA9-126A6104ADA1")
JournalReader;
#endif
#endif /* __JournalLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ivehandler.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for ivehandler.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ivehandler_h__
#define __ivehandler_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __VEHandlerClass_FWD_DEFINED__
#define __VEHandlerClass_FWD_DEFINED__

#ifdef __cplusplus
typedef class VEHandlerClass VEHandlerClass;
#else
typedef struct VEHandlerClass VEHandlerClass;
#endif /* __cplusplus */

#endif 	/* __VEHandlerClass_FWD_DEFINED__ */


#ifndef __IVEHandler_FWD_DEFINED__
#define __IVEHandler_FWD_DEFINED__
typedef interface IVEHandler IVEHandler;
#endif 	/* __IVEHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_ivehandler_0000_0000 */
/* [local] */ 

typedef struct tag_VerError
    {
    unsigned long flags;
    unsigned long opcode;
    unsigned long uOffset;
    unsigned long Token;
    unsigned long item1_flags;
    int *item1_data;
    unsigned long item2_flags;
    int *item2_data;
    } 	_VerError;

typedef _VerError VEContext;




extern RPC_IF_HANDLE __MIDL_itf_ivehandler_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ivehandler_0000_0000_v0_0_s_ifspec;


#ifndef __VEHandlerLib_LIBRARY_DEFINED__
#define __VEHandlerLib_LIBRARY_DEFINED__

/* library VEHandlerLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VEHandlerLib;

EXTERN_C const CLSID CLSID_VEHandlerClass;

#ifdef __cplusplus

class DECLSPEC_UUID("856CA1B1-7DAB-11d3-ACEC-00C04F86C309")
VEHandlerClass;
#endif
#endif /* __VEHandlerLib_LIBRARY_DEFINED__ */

#ifndef __IVEHandler_INTERFACE_DEFINED__
#define __IVEHandler_INTERFACE_DEFINED__

/* interface IVEHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVEHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("856CA1B2-7DAB-11d3-ACEC-00C04F86C309")
    IVEHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE VEHandler( 
            /* [in] */ HRESULT VECode,
            /* [in] */ VEContext Context,
            /* [in] */ __RPC__in SAFEARRAY * psa) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReporterFtn( 
            /* [in] */ __int64 lFnPtr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVEHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVEHandler * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVEHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVEHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *VEHandler )( 
            IVEHandler * This,
            /* [in] */ HRESULT VECode,
            /* [in] */ VEContext Context,
            /* [in] */ __RPC__in SAFEARRAY * psa);
        
        HRESULT ( STDMETHODCALLTYPE *SetReporterFtn )( 
            IVEHandler * This,
            /* [in] */ __int64 lFnPtr);
        
        END_INTERFACE
    } IVEHandlerVtbl;

    interface IVEHandler
    {
        CONST_VTBL struct IVEHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVEHandler_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IVEHandler_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IVEHandler_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IVEHandler_VEHandler(This,VECode,Context,psa)	\
    ( (This)->lpVtbl -> VEHandler(This,VECode,Context,psa) ) 

#define IVEHandler_SetReporterFtn(This,lFnPtr)	\
    ( (This)->lpVtbl -> SetReporterFtn(This,lFnPtr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IVEHandler_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\KnownFolders.h ===
#pragma once

#ifdef DEFINE_KNOWN_FOLDER
#undef DEFINE_KNOWN_FOLDER
#endif


#ifdef INITGUID
#define DEFINE_KNOWN_FOLDER(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID DECLSPEC_SELECTANY name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#else
#define DEFINE_KNOWN_FOLDER(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID name
#endif // INITGUID

// legacy CSIDL value: CSIDL_NETWORK
// display name: "Network"
// legacy display name: "My Network Places"
// default path: 
// {D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}
DEFINE_KNOWN_FOLDER(FOLDERID_NetworkFolder, 0xD20BEEC4, 0x5CA8, 0x4905, 0xAE, 0x3B, 0xBF, 0x25, 0x1E, 0xA0, 0x9B, 0x53);

// {0AC0837C-BBF8-452A-850D-79D08E667CA7}
DEFINE_KNOWN_FOLDER(FOLDERID_ComputerFolder,   0x0AC0837C, 0xBBF8, 0x452A, 0x85, 0x0D, 0x79, 0xD0, 0x8E, 0x66, 0x7C, 0xA7);

// {4D9F7874-4E0C-4904-967B-40B0D20C3E4B}
DEFINE_KNOWN_FOLDER(FOLDERID_InternetFolder,      0x4D9F7874, 0x4E0C, 0x4904, 0x96, 0x7B, 0x40, 0xB0, 0xD2, 0x0C, 0x3E, 0x4B);

// {82A74AEB-AEB4-465C-A014-D097EE346D63}
DEFINE_KNOWN_FOLDER(FOLDERID_ControlPanelFolder,  0x82A74AEB, 0xAEB4, 0x465C, 0xA0, 0x14, 0xD0, 0x97, 0xEE, 0x34, 0x6D, 0x63);

// {76FC4E2D-D6AD-4519-A663-37BD56068185}
DEFINE_KNOWN_FOLDER(FOLDERID_PrintersFolder,      0x76FC4E2D, 0xD6AD, 0x4519, 0xA6, 0x63, 0x37, 0xBD, 0x56, 0x06, 0x81, 0x85);

// {43668BF8-C14E-49B2-97C9-747784D784B7}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncManagerFolder,       0x43668BF8, 0xC14E, 0x49B2, 0x97, 0xC9, 0x74, 0x77, 0x84, 0xD7, 0x84, 0xB7);

// {0F214138-B1D3-4a90-BBA9-27CBC0C5389A}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncSetupFolder, 0xf214138, 0xb1d3, 0x4a90, 0xbb, 0xa9, 0x27, 0xcb, 0xc0, 0xc5, 0x38, 0x9a);

// {4bfefb45-347d-4006-a5be-ac0cb0567192}
DEFINE_KNOWN_FOLDER(FOLDERID_ConflictFolder,      0x4bfefb45, 0x347d, 0x4006, 0xa5, 0xbe, 0xac, 0x0c, 0xb0, 0x56, 0x71, 0x92);

// {289a9a43-be44-4057-a41b-587a76d7e7f9}
DEFINE_KNOWN_FOLDER(FOLDERID_SyncResultsFolder,     0x289a9a43, 0xbe44, 0x4057, 0xa4, 0x1b, 0x58, 0x7a, 0x76, 0xd7, 0xe7, 0xf9);

// {B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}
DEFINE_KNOWN_FOLDER(FOLDERID_RecycleBinFolder,    0xB7534046, 0x3ECB, 0x4C18, 0xBE, 0x4E, 0x64, 0xCD, 0x4C, 0xB7, 0xD6, 0xAC);

// {6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}
DEFINE_KNOWN_FOLDER(FOLDERID_ConnectionsFolder,   0x6F0CD92B, 0x2E97, 0x45D1, 0x88, 0xFF, 0xB0, 0xD1, 0x86, 0xB8, 0xDE, 0xDD);

// {FD228CB7-AE11-4AE3-864C-16F3910AB8FE}
DEFINE_KNOWN_FOLDER(FOLDERID_Fonts,               0xFD228CB7, 0xAE11, 0x4AE3, 0x86, 0x4C, 0x16, 0xF3, 0x91, 0x0A, 0xB8, 0xFE);

// display name:        "Desktop"
// default path:        "C:\Users\<UserName>\Desktop"
// legacy default path: "C:\Documents and Settings\<userName>\Desktop"
// legacy CSIDL value:  CSIDL_DESKTOP
// {B4BFCC3A-DB2C-424C-B029-7FE99A87C641}
DEFINE_KNOWN_FOLDER(FOLDERID_Desktop,             0xB4BFCC3A, 0xDB2C, 0x424C, 0xB0, 0x29, 0x7F, 0xE9, 0x9A, 0x87, 0xC6, 0x41);

// {B97D20BB-F46A-4C97-BA10-5E3608430854}
DEFINE_KNOWN_FOLDER(FOLDERID_Startup,             0xB97D20BB, 0xF46A, 0x4C97, 0xBA, 0x10, 0x5E, 0x36, 0x08, 0x43, 0x08, 0x54);

// {A77F5D77-2E2B-44C3-A6A2-ABA601054A51}
DEFINE_KNOWN_FOLDER(FOLDERID_Programs,            0xA77F5D77, 0x2E2B, 0x44C3, 0xA6, 0xA2, 0xAB, 0xA6, 0x01, 0x05, 0x4A, 0x51);

// {625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}
DEFINE_KNOWN_FOLDER(FOLDERID_StartMenu,           0x625B53C3, 0xAB48, 0x4EC1, 0xBA, 0x1F, 0xA1, 0xEF, 0x41, 0x46, 0xFC, 0x19);

// {AE50C081-EBD2-438A-8655-8A092E34987A}
DEFINE_KNOWN_FOLDER(FOLDERID_Recent,              0xAE50C081, 0xEBD2, 0x438A, 0x86, 0x55, 0x8A, 0x09, 0x2E, 0x34, 0x98, 0x7A);

// {8983036C-27C0-404B-8F08-102D10DCFD74}
DEFINE_KNOWN_FOLDER(FOLDERID_SendTo,              0x8983036C, 0x27C0, 0x404B, 0x8F, 0x08, 0x10, 0x2D, 0x10, 0xDC, 0xFD, 0x74);

// {FDD39AD0-238F-46AF-ADB4-6C85480369C7}
DEFINE_KNOWN_FOLDER(FOLDERID_Documents,           0xFDD39AD0, 0x238F, 0x46AF, 0xAD, 0xB4, 0x6C, 0x85, 0x48, 0x03, 0x69, 0xC7);

// {1777F761-68AD-4D8A-87BD-30B759FA33DD}
DEFINE_KNOWN_FOLDER(FOLDERID_Favorites,           0x1777F761, 0x68AD, 0x4D8A, 0x87, 0xBD, 0x30, 0xB7, 0x59, 0xFA, 0x33, 0xDD);

// {C5ABBF53-E17F-4121-8900-86626FC2C973}
DEFINE_KNOWN_FOLDER(FOLDERID_NetHood,             0xC5ABBF53, 0xE17F, 0x4121, 0x89, 0x00, 0x86, 0x62, 0x6F, 0xC2, 0xC9, 0x73);

// {9274BD8D-CFD1-41C3-B35E-B13F55A758F4}
DEFINE_KNOWN_FOLDER(FOLDERID_PrintHood,           0x9274BD8D, 0xCFD1, 0x41C3, 0xB3, 0x5E, 0xB1, 0x3F, 0x55, 0xA7, 0x58, 0xF4);

// {A63293E8-664E-48DB-A079-DF759E0509F7}
DEFINE_KNOWN_FOLDER(FOLDERID_Templates,           0xA63293E8, 0x664E, 0x48DB, 0xA0, 0x79, 0xDF, 0x75, 0x9E, 0x05, 0x09, 0xF7);

// {82A5EA35-D9CD-47C5-9629-E15D2F714E6E}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonStartup,       0x82A5EA35, 0xD9CD, 0x47C5, 0x96, 0x29, 0xE1, 0x5D, 0x2F, 0x71, 0x4E, 0x6E);

// {0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonPrograms,      0x0139D44E, 0x6AFE, 0x49F2, 0x86, 0x90, 0x3D, 0xAF, 0xCA, 0xE6, 0xFF, 0xB8);

// {A4115719-D62E-491D-AA7C-E74B8BE3B067}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonStartMenu,     0xA4115719, 0xD62E, 0x491D, 0xAA, 0x7C, 0xE7, 0x4B, 0x8B, 0xE3, 0xB0, 0x67);

// {C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDesktop,       0xC4AA340D, 0xF20F, 0x4863, 0xAF, 0xEF, 0xF8, 0x7E, 0xF2, 0xE6, 0xBA, 0x25);

// {62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramData,         0x62AB5D82, 0xFDC1, 0x4DC3, 0xA9, 0xDD, 0x07, 0x0D, 0x1D, 0x49, 0x5D, 0x97);

// {B94237E7-57AC-4347-9151-B08C6C32D1F7}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonTemplates,     0xB94237E7, 0x57AC, 0x4347, 0x91, 0x51, 0xB0, 0x8C, 0x6C, 0x32, 0xD1, 0xF7);

// {ED4824AF-DCE4-45A8-81E2-FC7965083634}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDocuments,     0xED4824AF, 0xDCE4, 0x45A8, 0x81, 0xE2, 0xFC, 0x79, 0x65, 0x08, 0x36, 0x34);

// {3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}
DEFINE_KNOWN_FOLDER(FOLDERID_RoamingAppData,      0x3EB685DB, 0x65F9, 0x4CF6, 0xA0, 0x3A, 0xE3, 0xEF, 0x65, 0x72, 0x9F, 0x3D);

// {F1B32785-6FBA-4FCF-9D55-7B8E7F157091}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalAppData,        0xF1B32785, 0x6FBA, 0x4FCF, 0x9D, 0x55, 0x7B, 0x8E, 0x7F, 0x15, 0x70, 0x91);

// {A520A1A4-1780-4FF6-BD18-167343C5AF16}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalAppDataLow,     0xA520A1A4, 0x1780, 0x4FF6, 0xBD, 0x18, 0x16, 0x73, 0x43, 0xC5, 0xAF, 0x16);

// {352481E8-33BE-4251-BA85-6007CAEDCF9D}
DEFINE_KNOWN_FOLDER(FOLDERID_InternetCache,       0x352481E8, 0x33BE, 0x4251, 0xBA, 0x85, 0x60, 0x07, 0xCA, 0xED, 0xCF, 0x9D);

// {2B0F765D-C0E9-4171-908E-08A611B84FF6}
DEFINE_KNOWN_FOLDER(FOLDERID_Cookies,             0x2B0F765D, 0xC0E9, 0x4171, 0x90, 0x8E, 0x08, 0xA6, 0x11, 0xB8, 0x4F, 0xF6);

// {D9DC8A3B-B784-432E-A781-5A1130A75963}
DEFINE_KNOWN_FOLDER(FOLDERID_History,             0xD9DC8A3B, 0xB784, 0x432E, 0xA7, 0x81, 0x5A, 0x11, 0x30, 0xA7, 0x59, 0x63);

// {1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}
DEFINE_KNOWN_FOLDER(FOLDERID_System,              0x1AC14E77, 0x02E7, 0x4E5D, 0xB7, 0x44, 0x2E, 0xB1, 0xAE, 0x51, 0x98, 0xB7);

// {D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}
DEFINE_KNOWN_FOLDER(FOLDERID_SystemX86,           0xD65231B0, 0xB2F1, 0x4857, 0xA4, 0xCE, 0xA8, 0xE7, 0xC6, 0xEA, 0x7D, 0x27);

// {F38BF404-1D43-42F2-9305-67DE0B28FC23}
DEFINE_KNOWN_FOLDER(FOLDERID_Windows,             0xF38BF404, 0x1D43, 0x42F2, 0x93, 0x05, 0x67, 0xDE, 0x0B, 0x28, 0xFC, 0x23);

// {5E6C858F-0E22-4760-9AFE-EA3317B67173}
DEFINE_KNOWN_FOLDER(FOLDERID_Profile,             0x5E6C858F, 0x0E22, 0x4760, 0x9A, 0xFE, 0xEA, 0x33, 0x17, 0xB6, 0x71, 0x73);

// {33E28130-4E1E-4676-835A-98395C3BC3BB}
DEFINE_KNOWN_FOLDER(FOLDERID_Pictures,            0x33E28130, 0x4E1E, 0x4676, 0x83, 0x5A, 0x98, 0x39, 0x5C, 0x3B, 0xC3, 0xBB);

// {7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesX86,     0x7C5A40EF, 0xA0FB, 0x4BFC, 0x87, 0x4A, 0xC0, 0xF2, 0xE0, 0xB9, 0xFA, 0x8E);

// {DE974D24-D9C6-4D3E-BF91-F4455120B917}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommonX86, 0xDE974D24, 0xD9C6, 0x4D3E, 0xBF, 0x91, 0xF4, 0x45, 0x51, 0x20, 0xB9, 0x17);

// {6D809377-6AF0-444b-8957-A3773F02200E}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesX64,     0x6d809377, 0x6af0, 0x444b, 0x89, 0x57, 0xa3, 0x77, 0x3f, 0x02, 0x20, 0x0e );

// {6365D5A7-0F0D-45e5-87F6-0DA56B6A4F7D}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommonX64, 0x6365d5a7, 0xf0d, 0x45e5, 0x87, 0xf6, 0xd, 0xa5, 0x6b, 0x6a, 0x4f, 0x7d );

// {905e63b6-c1bf-494e-b29c-65b732d3d21a}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFiles,        0x905e63b6, 0xc1bf, 0x494e, 0xb2, 0x9c, 0x65, 0xb7, 0x32, 0xd3, 0xd2, 0x1a);

// {F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}
DEFINE_KNOWN_FOLDER(FOLDERID_ProgramFilesCommon,  0xF7F1ED05, 0x9F6D, 0x47A2, 0xAA, 0xAE, 0x29, 0xD3, 0x17, 0xC6, 0xF0, 0x66);

// {5cd7aee2-2219-4a67-b85d-6c9ce15660cb}
DEFINE_KNOWN_FOLDER(FOLDERID_UserProgramFiles,    0x5cd7aee2, 0x2219, 0x4a67, 0xb8, 0x5d, 0x6c, 0x9c, 0xe1, 0x56, 0x60, 0xcb);

// {bcbd3057-ca5c-4622-b42d-bc56db0ae516}
DEFINE_KNOWN_FOLDER(FOLDERID_UserProgramFilesCommon, 0xbcbd3057, 0xca5c, 0x4622, 0xb4, 0x2d, 0xbc, 0x56, 0xdb, 0x0a, 0xe5, 0x16);

// {724EF170-A42D-4FEF-9F26-B60E846FBA4F}
DEFINE_KNOWN_FOLDER(FOLDERID_AdminTools,          0x724EF170, 0xA42D, 0x4FEF, 0x9F, 0x26, 0xB6, 0x0E, 0x84, 0x6F, 0xBA, 0x4F);

// {D0384E7D-BAC3-4797-8F14-CBA229B392B5}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonAdminTools,    0xD0384E7D, 0xBAC3, 0x4797, 0x8F, 0x14, 0xCB, 0xA2, 0x29, 0xB3, 0x92, 0xB5);

// {4BD8D571-6D19-48D3-BE97-422220080E43}
DEFINE_KNOWN_FOLDER(FOLDERID_Music,               0x4BD8D571, 0x6D19, 0x48D3, 0xBE, 0x97, 0x42, 0x22, 0x20, 0x08, 0x0E, 0x43);

// {18989B1D-99B5-455B-841C-AB7C74E4DDFC}
DEFINE_KNOWN_FOLDER(FOLDERID_Videos,              0x18989B1D, 0x99B5, 0x455B, 0x84, 0x1C, 0xAB, 0x7C, 0x74, 0xE4, 0xDD, 0xFC);

// {C870044B-F49E-4126-A9C3-B52A1FF411E8}
DEFINE_KNOWN_FOLDER(FOLDERID_Ringtones,           0xC870044B, 0xF49E, 0x4126, 0xA9, 0xC3, 0xB5, 0x2A, 0x1F, 0xF4, 0x11, 0xE8);

// {B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicPictures,      0xB6EBFB86, 0x6907, 0x413C, 0x9A, 0xF7, 0x4F, 0xC2, 0xAB, 0xF0, 0x7C, 0xC5);

// {3214FAB5-9757-4298-BB61-92A9DEAA44FF}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicMusic,         0x3214FAB5, 0x9757, 0x4298, 0xBB, 0x61, 0x92, 0xA9, 0xDE, 0xAA, 0x44, 0xFF);

// {2400183A-6185-49FB-A2D8-4A392A602BA3}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicVideos,        0x2400183A, 0x6185, 0x49FB, 0xA2, 0xD8, 0x4A, 0x39, 0x2A, 0x60, 0x2B, 0xA3);

// {E555AB60-153B-4D17-9F04-A5FE99FC15EC}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicRingtones,     0xE555AB60, 0x153B, 0x4D17, 0x9F, 0x04, 0xA5, 0xFE, 0x99, 0xFC, 0x15, 0xEC);

// {8AD10C31-2ADB-4296-A8F7-E4701232C972}
DEFINE_KNOWN_FOLDER(FOLDERID_ResourceDir,         0x8AD10C31, 0x2ADB, 0x4296, 0xA8, 0xF7, 0xE4, 0x70, 0x12, 0x32, 0xC9, 0x72);

// {2A00375E-224C-49DE-B8D1-440DF7EF3DDC}
DEFINE_KNOWN_FOLDER(FOLDERID_LocalizedResourcesDir, 0x2A00375E, 0x224C, 0x49DE, 0xB8, 0xD1, 0x44, 0x0D, 0xF7, 0xEF, 0x3D, 0xDC);

// {C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}
DEFINE_KNOWN_FOLDER(FOLDERID_CommonOEMLinks,      0xC1BAE2D0, 0x10DF, 0x4334, 0xBE, 0xDD, 0x7A, 0xA2, 0x0B, 0x22, 0x7A, 0x9D);

// {9E52AB10-F80D-49DF-ACB8-4330F5687855}
DEFINE_KNOWN_FOLDER(FOLDERID_CDBurning,           0x9E52AB10, 0xF80D, 0x49DF, 0xAC, 0xB8, 0x43, 0x30, 0xF5, 0x68, 0x78, 0x55);

// {0762D272-C50A-4BB0-A382-697DCD729B80}
DEFINE_KNOWN_FOLDER(FOLDERID_UserProfiles,        0x0762D272, 0xC50A, 0x4BB0, 0xA3, 0x82, 0x69, 0x7D, 0xCD, 0x72, 0x9B, 0x80);

// {DE92C1C7-837F-4F69-A3BB-86E631204A23}
DEFINE_KNOWN_FOLDER(FOLDERID_Playlists,           0xDE92C1C7, 0x837F, 0x4F69, 0xA3, 0xBB, 0x86, 0xE6, 0x31, 0x20, 0x4A, 0x23);

// {15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}
DEFINE_KNOWN_FOLDER(FOLDERID_SamplePlaylists,     0x15CA69B3, 0x30EE, 0x49C1, 0xAC, 0xE1, 0x6B, 0x5E, 0xC3, 0x72, 0xAF, 0xB5);

// {B250C668-F57D-4EE1-A63C-290EE7D1AA1F}
DEFINE_KNOWN_FOLDER(FOLDERID_SampleMusic,         0xB250C668, 0xF57D, 0x4EE1, 0xA6, 0x3C, 0x29, 0x0E, 0xE7, 0xD1, 0xAA, 0x1F);

// {C4900540-2379-4C75-844B-64E6FAF8716B}
DEFINE_KNOWN_FOLDER(FOLDERID_SamplePictures,      0xC4900540, 0x2379, 0x4C75, 0x84, 0x4B, 0x64, 0xE6, 0xFA, 0xF8, 0x71, 0x6B);

// {859EAD94-2E85-48AD-A71A-0969CB56A6CD}
DEFINE_KNOWN_FOLDER(FOLDERID_SampleVideos,        0x859EAD94, 0x2E85, 0x48AD, 0xA7, 0x1A, 0x09, 0x69, 0xCB, 0x56, 0xA6, 0xCD);

// {69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}
DEFINE_KNOWN_FOLDER(FOLDERID_PhotoAlbums,         0x69D2CF90, 0xFC33, 0x4FB7, 0x9A, 0x0C, 0xEB, 0xB0, 0xF0, 0xFC, 0xB4, 0x3C);

// {DFDF76A2-C82A-4D63-906A-5644AC457385}
DEFINE_KNOWN_FOLDER(FOLDERID_Public,              0xDFDF76A2, 0xC82A, 0x4D63, 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85);

// {df7266ac-9274-4867-8d55-3bd661de872d}
DEFINE_KNOWN_FOLDER(FOLDERID_ChangeRemovePrograms,0xdf7266ac, 0x9274, 0x4867, 0x8d, 0x55, 0x3b, 0xd6, 0x61, 0xde, 0x87, 0x2d);

// {a305ce99-f527-492b-8b1a-7e76fa98d6e4}
DEFINE_KNOWN_FOLDER(FOLDERID_AppUpdates,          0xa305ce99, 0xf527, 0x492b, 0x8b, 0x1a, 0x7e, 0x76, 0xfa, 0x98, 0xd6, 0xe4);

// {de61d971-5ebc-4f02-a3a9-6c82895e5c04}
DEFINE_KNOWN_FOLDER(FOLDERID_AddNewPrograms,      0xde61d971, 0x5ebc, 0x4f02, 0xa3, 0xa9, 0x6c, 0x82, 0x89, 0x5e, 0x5c, 0x04);

// {374DE290-123F-4565-9164-39C4925E467B}
DEFINE_KNOWN_FOLDER(FOLDERID_Downloads,           0x374de290, 0x123f, 0x4565, 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b);

// {3D644C9B-1FB8-4f30-9B45-F670235F79C0}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicDownloads,     0x3d644c9b, 0x1fb8, 0x4f30, 0x9b, 0x45, 0xf6, 0x70, 0x23, 0x5f, 0x79, 0xc0);

// {7d1d3a04-debb-4115-95cf-2f29da2920da}
DEFINE_KNOWN_FOLDER(FOLDERID_SavedSearches,       0x7d1d3a04, 0xdebb, 0x4115, 0x95, 0xcf, 0x2f, 0x29, 0xda, 0x29, 0x20, 0xda);

// {52a4f021-7b75-48a9-9f6b-4b87a210bc8f}
DEFINE_KNOWN_FOLDER(FOLDERID_QuickLaunch,         0x52a4f021, 0x7b75, 0x48a9, 0x9f, 0x6b, 0x4b, 0x87, 0xa2, 0x10, 0xbc, 0x8f);

// {56784854-C6CB-462b-8169-88E350ACB882}
DEFINE_KNOWN_FOLDER(FOLDERID_Contacts,            0x56784854, 0xc6cb, 0x462b, 0x81, 0x69, 0x88, 0xe3, 0x50, 0xac, 0xb8, 0x82);

// {A75D362E-50FC-4fb7-AC2C-A8BEAA314493}
DEFINE_GUID(FOLDERID_SidebarParts,                0xa75d362e, 0x50fc, 0x4fb7, 0xac, 0x2c, 0xa8, 0xbe, 0xaa, 0x31, 0x44, 0x93);

// {7B396E54-9EC5-4300-BE0A-2482EBAE1A26}
DEFINE_GUID(FOLDERID_SidebarDefaultParts,         0x7b396e54, 0x9ec5, 0x4300, 0xbe, 0xa, 0x24, 0x82, 0xeb, 0xae, 0x1a, 0x26);

// {DEBF2536-E1A8-4c59-B6A2-414586476AEA}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicGameTasks,     0xdebf2536, 0xe1a8, 0x4c59, 0xb6, 0xa2, 0x41, 0x45, 0x86, 0x47, 0x6a, 0xea);

// {054FAE61-4DD8-4787-80B6-090220C4B700}
DEFINE_KNOWN_FOLDER(FOLDERID_GameTasks,           0x54fae61, 0x4dd8, 0x4787, 0x80, 0xb6, 0x9, 0x2, 0x20, 0xc4, 0xb7, 0x0);

// {4C5C32FF-BB9D-43b0-B5B4-2D72E54EAAA4}
DEFINE_KNOWN_FOLDER(FOLDERID_SavedGames,          0x4c5c32ff, 0xbb9d, 0x43b0, 0xb5, 0xb4, 0x2d, 0x72, 0xe5, 0x4e, 0xaa, 0xa4);

// {CAC52C1A-B53D-4edc-92D7-6B2E8AC19434}
DEFINE_KNOWN_FOLDER(FOLDERID_Games,               0xcac52c1a, 0xb53d, 0x4edc, 0x92, 0xd7, 0x6b, 0x2e, 0x8a, 0xc1, 0x94, 0x34);

// {98ec0e18-2098-4d44-8644-66979315a281}
DEFINE_KNOWN_FOLDER(FOLDERID_SEARCH_MAPI,         0x98ec0e18, 0x2098, 0x4d44, 0x86, 0x44, 0x66, 0x97, 0x93, 0x15, 0xa2, 0x81);

// {ee32e446-31ca-4aba-814f-a5ebd2fd6d5e}
DEFINE_KNOWN_FOLDER(FOLDERID_SEARCH_CSC,          0xee32e446, 0x31ca, 0x4aba, 0x81, 0x4f, 0xa5, 0xeb, 0xd2, 0xfd, 0x6d, 0x5e);

// {bfb9d5e0-c6a9-404c-b2b2-ae6db6af4968}
DEFINE_KNOWN_FOLDER(FOLDERID_Links,               0xbfb9d5e0, 0xc6a9, 0x404c, 0xb2, 0xb2, 0xae, 0x6d, 0xb6, 0xaf, 0x49, 0x68);

// {f3ce0f7c-4901-4acc-8648-d5d44b04ef8f}
DEFINE_KNOWN_FOLDER(FOLDERID_UsersFiles,          0xf3ce0f7c, 0x4901, 0x4acc, 0x86, 0x48, 0xd5, 0xd4, 0x4b, 0x04, 0xef, 0x8f);

// {A302545D-DEFF-464b-ABE8-61C8648D939B}
DEFINE_KNOWN_FOLDER(FOLDERID_UsersLibraries,      0xa302545d, 0xdeff, 0x464b, 0xab, 0xe8, 0x61, 0xc8, 0x64, 0x8d, 0x93, 0x9b);

// {190337d1-b8ca-4121-a639-6d472d16972a}
DEFINE_KNOWN_FOLDER(FOLDERID_SearchHome,          0x190337d1, 0xb8ca, 0x4121, 0xa6, 0x39, 0x6d, 0x47, 0x2d, 0x16, 0x97, 0x2a);

// {2C36C0AA-5812-4b87-BFD0-4CD0DFB19B39}
DEFINE_KNOWN_FOLDER(FOLDERID_OriginalImages,      0x2C36C0AA, 0x5812, 0x4b87, 0xbf, 0xd0, 0x4c, 0xd0, 0xdf, 0xb1, 0x9b, 0x39);

// {7b0db17d-9cd2-4a93-9733-46cc89022e7c}
DEFINE_KNOWN_FOLDER(FOLDERID_DocumentsLibrary,    0x7b0db17d, 0x9cd2, 0x4a93, 0x97, 0x33, 0x46, 0xcc, 0x89, 0x02, 0x2e, 0x7c);

// {2112AB0A-C86A-4ffe-A368-0DE96E47012E}
DEFINE_KNOWN_FOLDER(FOLDERID_MusicLibrary,        0x2112ab0a, 0xc86a, 0x4ffe, 0xa3, 0x68, 0xd, 0xe9, 0x6e, 0x47, 0x1, 0x2e);

// {A990AE9F-A03B-4e80-94BC-9912D7504104}
DEFINE_KNOWN_FOLDER(FOLDERID_PicturesLibrary,     0xa990ae9f, 0xa03b, 0x4e80, 0x94, 0xbc, 0x99, 0x12, 0xd7, 0x50, 0x41, 0x4);

// {491E922F-5643-4af4-A7EB-4E7A138D8174}
DEFINE_KNOWN_FOLDER(FOLDERID_VideosLibrary,       0x491e922f, 0x5643, 0x4af4, 0xa7, 0xeb, 0x4e, 0x7a, 0x13, 0x8d, 0x81, 0x74);

// {1A6FDBA2-F42D-4358-A798-B74D745926C5}
DEFINE_KNOWN_FOLDER(FOLDERID_RecordedTVLibrary,   0x1a6fdba2, 0xf42d, 0x4358, 0xa7, 0x98, 0xb7, 0x4d, 0x74, 0x59, 0x26, 0xc5);

// {52528A6B-B9E3-4add-B60D-588C2DBA842D}
DEFINE_KNOWN_FOLDER(FOLDERID_HomeGroup,           0x52528a6b, 0xb9e3, 0x4add, 0xb6, 0xd, 0x58, 0x8c, 0x2d, 0xba, 0x84, 0x2d);

// {5CE4A5E9-E4EB-479D-B89F-130C02886155}
DEFINE_KNOWN_FOLDER(FOLDERID_DeviceMetadataStore, 0x5ce4a5e9, 0xe4eb, 0x479d, 0xb8, 0x9f, 0x13, 0x0c, 0x02, 0x88, 0x61, 0x55);

// {1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}
DEFINE_KNOWN_FOLDER(FOLDERID_Libraries,           0x1b3ea5dc, 0xb587, 0x4786, 0xb4, 0xef, 0xbd, 0x1d, 0xc3, 0x32, 0xae, 0xae);

// {48daf80b-e6cf-4f4e-b800-0e69d84ee384}
DEFINE_KNOWN_FOLDER(FOLDERID_PublicLibraries,     0x48daf80b, 0xe6cf, 0x4f4e, 0xb8, 0x00, 0x0e, 0x69, 0xd8, 0x4e, 0xe3, 0x84);

// {9e3995ab-1f9c-4f13-b827-48b24b6c7174}
DEFINE_KNOWN_FOLDER(FOLDERID_UserPinned,          0x9e3995ab, 0x1f9c, 0x4f13, 0xb8, 0x27, 0x48, 0xb2, 0x4b, 0x6c, 0x71, 0x74);

// {bcb5256f-79f6-4cee-b725-dc34e402fd46}
DEFINE_KNOWN_FOLDER(FOLDERID_ImplicitAppShortcuts,0xbcb5256f, 0x79f6, 0x4cee, 0xb7, 0x25, 0xdc, 0x34, 0xe4, 0x2, 0xfd, 0x46);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\journal_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for journal.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_JournalLib,0xEABAA706,0x4A6D,0x4E45,0xA2,0x55,0xA6,0xE8,0x6C,0x40,0x3A,0xDB);


MIDL_DEFINE_GUID(IID, IID_IJournalReader,0x26213A0B,0x5A6C,0x4472,0x92,0x3D,0x9F,0x29,0xEF,0xF6,0x08,0xB2);


MIDL_DEFINE_GUID(CLSID, CLSID_JournalReader,0xB4124623,0xFC0E,0x47CE,0xBC,0xA9,0x12,0x6A,0x61,0x04,0xAD,0xA1);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\KsGuid.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksguid.h

Abstract:

    Define guids for non-C++.

--*/

#define INITGUID
#include <guiddef.h>

#if defined( DEFINE_GUIDEX )
    #undef DEFINE_GUIDEX
#endif
#define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID __declspec(selectany) name = { STATICGUIDOF(name) }

#ifndef STATICGUIDOF
    #define STATICGUIDOF(guid) STATIC_##guid
#endif // !defined(STATICGUIDOF)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\kernelspecs.h ===
/*****************************************************************************\
*                                                                             *
* KernelSpecs.h - markers for documenting the semantics of driver APIs        *
*                 See DriverSpecs.h for detailed comments                     *
*                 See also <SpecStrings.h>                                    *
*                                                                             *
* Version 1.2.00                                                              *
*                                                                             *
* Copyright (c) Microsoft Corporation. All rights reserved.                   *
*                                                                             *
\*****************************************************************************/

/*****************************************************************************\
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
*   The macro bodies in this file are subject to change without notice.       *
*   Attempting to use the annotations in the macro bodies directly is not     *
*   supported.																  *
* NOTE																		  *
* NOTE																		  *
* NOTE																		  *
\*****************************************************************************/

/*****************************************************************************\
* As noted in DriverSpecs.h, this header contains "real" definitions for
* annotations that either never appear in user space, or which are meaningles
* in user space and are #defined to nothing by DriverSpecs.h.
*
* Further commentary appears in DriverSpecs.h.
\*****************************************************************************/

#include "DriverSpecs.h"

#if _MSC_VER > 1000 // [
#pragma once
#endif // ]

#ifdef  __cplusplus // [
extern "C" {
#endif  // ]

	// ---------------------------------------------------------------------
	// The symbolic IRQL values can sometimes end up undefined, so define
	// the usual ones here, for PREfast purposes only.

	#define DISPATCH_LEVEL 2
	#define APC_LEVEL 1
	#define PASSIVE_LEVEL 0

	// ---------------------------------------------------------------------
	// Maintenance of IRQL values
	//
	// __drv_setsIRQL(irql)
	// __drv_raisesIRQL(irql)
	// __drv_requiresIRQL(irql)
	// __drv_maxIRQL(irql)
	// __drv_minIRQL(irql)
	// __drv_savesIRQL
	// __drv_restoresIRQL
	// __drv_savesIRQLGlobal(kind,param)
	// __drv_restoresIRQLGlobal(kind,param)
	// __drv_minFunctionIRQL(irql)
	// __drv_maxFunctionIRQL(irql)
	// __drv_useCancelIRQL
	// __drv_sameIRQL

	// 
	// The funciton exits at IRQL irql
	//
	// ';' inside the parens to keep MIDL happy
	__ANNOTATION(SAL_IRQL(__int64);)
	#undef __drv_setsIRQL
	#define __drv_setsIRQL(irql)											\
		__post __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")")

	// 
	// The funciton exits at IRQL irql, but this may only raise the irql.
	//
	#undef __drv_raisesIRQL
	__ANNOTATION(SAL_raiseIRQL(__int64);)
	#define __drv_raisesIRQL(irql)											\
		__post __drv_declspec("SAL_raiseIRQL("SPECSTRINGIZE(irql)")")

	// 
	// The called function must be entered at IRQL level
	//
	#undef __drv_requiresIRQL
	__ANNOTATION(SAL_IRQL(__int64);)
	#define __drv_requiresIRQL(irql)										\
		__pre __drv_declspec("SAL_IRQL("SPECSTRINGIZE(irql)")")


	// 
	// The maximum IRQL at which the function may be called.
	//
	#undef __drv_maxIRQL
	__ANNOTATION(SAL_maxIRQL(__int64);)
	#define __drv_maxIRQL(irql)												\
		__pre __drv_declspec("SAL_maxIRQL("SPECSTRINGIZE(irql)")")
	// 
	// The minimum IRQL at which the function may be called.
	//
	#undef __drv_minIRQL
	__ANNOTATION(SAL_minIRQL(__int64);)
	#define __drv_minIRQL(irql)												\
		__pre __drv_declspec("SAL_minIRQL("SPECSTRINGIZE(irql)")")

	// 
	// The current IRQL is saved in the annotated parameter
	//
	#undef __drv_savesIRQL
	__ANNOTATION(SAL_saveIRQL(void);)
	#define __drv_savesIRQL __post __drv_declspec("SAL_saveIRQL")

	// 
	// The current IRQL is saved in the (otherwise anonymous) global object
	// identified by kind and further refined by param.
	//
	#undef __drv_savesIRQLGlobal
	__ANNOTATION(SAL_saveIRQLGlobal(__in char *, ...);)
	#define __drv_savesIRQLGlobal(kind,param)								\
		__post __drv_declspec("SAL_saveIRQLGlobal(\"" #kind "\","			\
										   SPECSTRINGIZE(param\t)")")

	// 
	// The current IRQL is restored from the annotated parameter
	//
	#undef __drv_restoresIRQL
	__ANNOTATION(SAL_restoreIRQL(void);)
	#define __drv_restoresIRQL __post __drv_declspec("SAL_restoreIRQL")

	// 
	// The current IRQL is restored from the (otherwise anonymous) global object
	// identified by kind and further refined by param.
	//
	#undef __drv_restoresIRQLGlobal
	__ANNOTATION(SAL_restoreIRQLGlobal(__in char *, ...);)
	#define __drv_restoresIRQLGlobal(kind,param)							\
		__post __drv_declspec("SAL_restoreIRQLGlobal(\"" #kind "\","		\
										   SPECSTRINGIZE(param\t)")")

	// The minimum IRQL to which the function can lower itself.	 The IRQL
	// at entry is assumed to be that value unless overridden.
	#undef __drv_minFunctionIRQL
	__ANNOTATION(SAL_minFunctionIrql(__int64);)
	#define __drv_minFunctionIRQL(irql)\
	    __pre __drv_declspec("SAL_minFunctionIrql(" SPECSTRINGIZE(irql) ")") 


	// The maximum IRQL to which the function can raise itself.
	#undef __drv_maxFunctionIRQL
	__ANNOTATION(SAL_maxFunctionIrql(__int64);)
	#define __drv_maxFunctionIRQL(irql)\
	    __pre __drv_declspec("SAL_maxFunctionIrql(" SPECSTRINGIZE(irql) ")") 

	// The function must exit with the same IRQL it was entered with.
	// (It may change it but it must restore it.)
	#undef __drv_sameIRQL
	__ANNOTATION(SAL_sameIRQL(void);)
	#define __drv_sameIRQL\
		__post __drv_declspec("SAL_sameIRQL")

	// The annotated parameter contains the cancelIRQL, which will be restored
	// by the called function.

	#undef __drv_useCancelIRQL
	__ANNOTATION(SAL_UseCancelIrql(void);)
	#define __drv_useCancelIRQL												\
		__post __drv_declspec("SAL_UseCancelIrql") 


#ifdef _PREFAST_ // RC workaround; already #defined to nothing if not needed
	// Passing the cancel Irql to a utility function
	#undef __drv_isCancelIRQL
	#define __drv_isCancelIRQL\
		__drv_useCancelIRQL													\
		__drv_at(return, __drv_innerMustHoldGlobal(CancelSpinLock,)			\
				 __drv_innerReleasesGlobal(CancelSpinLock,)					\
				 __drv_minFunctionIRQL(DISPATCH_LEVEL)						\
				 __drv_requiresIRQL(DISPATCH_LEVEL))
#endif

#ifdef	__cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Ks.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ks.h

Abstract:

    Windows Driver Model/Connection and Streaming Architecture (WDM-CSA)
    core definitions.

--*/

#if !defined(_KS_)
#define _KS_

#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

#if defined(__TCS__)
#define _KS_NO_ANONYMOUS_STRUCTURES_ 1
#endif

#if !defined(_NTRTL_)
    #ifndef DEFINE_GUIDEX
        #define DEFINE_GUIDEX(name) EXTERN_C const CDECL GUID name
    #endif // !defined(DEFINE_GUIDEX)

    #ifndef STATICGUIDOF
        #define STATICGUIDOF(guid) STATIC_##guid
    #endif // !defined(STATICGUIDOF)
#endif // !defined(_NTRTL_)

#ifndef SIZEOF_ARRAY
    #define SIZEOF_ARRAY(ar)        (sizeof(ar)/sizeof((ar)[0]))
#endif // !defined(SIZEOF_ARRAY)

#if defined(__cplusplus) && _MSC_VER >= 1100
#define DEFINE_GUIDSTRUCT(g, n) struct __declspec(uuid(g)) n
#define DEFINE_GUIDNAMED(n) __uuidof(struct n)
#else // !defined(__cplusplus)
#define DEFINE_GUIDSTRUCT(g, n) DEFINE_GUIDEX(n)
#define DEFINE_GUIDNAMED(n) n
#endif // !defined(__cplusplus)

//===========================================================================

#define STATIC_GUID_NULL \
    0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

DEFINE_GUIDSTRUCT("00000000-0000-0000-0000-000000000000", GUID_NULL);
#define GUID_NULL DEFINE_GUIDNAMED(GUID_NULL)

//===========================================================================

#define IOCTL_KS_PROPERTY              CTL_CODE(FILE_DEVICE_KS, 0x000, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_ENABLE_EVENT          CTL_CODE(FILE_DEVICE_KS, 0x001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_DISABLE_EVENT         CTL_CODE(FILE_DEVICE_KS, 0x002, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_METHOD                CTL_CODE(FILE_DEVICE_KS, 0x003, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_KS_WRITE_STREAM          CTL_CODE(FILE_DEVICE_KS, 0x004, METHOD_NEITHER, FILE_WRITE_ACCESS)
#define IOCTL_KS_READ_STREAM           CTL_CODE(FILE_DEVICE_KS, 0x005, METHOD_NEITHER, FILE_READ_ACCESS)
#define IOCTL_KS_RESET_STATE           CTL_CODE(FILE_DEVICE_KS, 0x006, METHOD_NEITHER, FILE_ANY_ACCESS)

//===========================================================================

typedef enum {
    KSRESET_BEGIN,
    KSRESET_END
} KSRESET;

typedef enum {
    KSSTATE_STOP,
    KSSTATE_ACQUIRE,
    KSSTATE_PAUSE,
    KSSTATE_RUN
} KSSTATE, *PKSSTATE;

#define KSPRIORITY_LOW        0x00000001
#define KSPRIORITY_NORMAL     0x40000000
#define KSPRIORITY_HIGH       0x80000000
#define KSPRIORITY_EXCLUSIVE  0xFFFFFFFF

typedef struct {
    ULONG   PriorityClass;
    ULONG   PrioritySubClass;
} KSPRIORITY, *PKSPRIORITY;

typedef struct {
    union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
        struct _IDENTIFIER {
#else        
        struct {
#endif        
            GUID    Set;
            ULONG   Id;
            ULONG   Flags;
        };
        LONGLONG    Alignment;
    };
} KSIDENTIFIER, *PKSIDENTIFIER;

typedef KSIDENTIFIER KSPROPERTY, *PKSPROPERTY, KSMETHOD, *PKSMETHOD, KSEVENT, *PKSEVENT;

#define KSMETHOD_TYPE_NONE                  0x00000000
#define KSMETHOD_TYPE_READ                  0x00000001
#define KSMETHOD_TYPE_WRITE                 0x00000002
#define KSMETHOD_TYPE_MODIFY                0x00000003
#define KSMETHOD_TYPE_SOURCE                0x00000004

#define KSMETHOD_TYPE_SEND                  0x00000001
#define KSMETHOD_TYPE_SETSUPPORT            0x00000100
#define KSMETHOD_TYPE_BASICSUPPORT          0x00000200

#define KSMETHOD_TYPE_TOPOLOGY 0x10000000

#define KSPROPERTY_TYPE_GET                 0x00000001
#define KSPROPERTY_TYPE_SET                 0x00000002
#define KSPROPERTY_TYPE_SETSUPPORT          0x00000100
#define KSPROPERTY_TYPE_BASICSUPPORT        0x00000200
#define KSPROPERTY_TYPE_RELATIONS           0x00000400
#define KSPROPERTY_TYPE_SERIALIZESET        0x00000800
#define KSPROPERTY_TYPE_UNSERIALIZESET      0x00001000
#define KSPROPERTY_TYPE_SERIALIZERAW        0x00002000
#define KSPROPERTY_TYPE_UNSERIALIZERAW      0x00004000
#define KSPROPERTY_TYPE_SERIALIZESIZE       0x00008000
#define KSPROPERTY_TYPE_DEFAULTVALUES       0x00010000

#define KSPROPERTY_TYPE_TOPOLOGY 0x10000000

typedef struct {
    KSPROPERTY      Property;
    ULONG           NodeId;
    ULONG           Reserved;
} KSP_NODE, *PKSP_NODE;

typedef struct {
    KSMETHOD        Method;
    ULONG           NodeId;
    ULONG           Reserved;
} KSM_NODE, *PKSM_NODE;

typedef struct {
    KSEVENT         Event;
    ULONG           NodeId;
    ULONG           Reserved;
} KSE_NODE, *PKSE_NODE;

#define STATIC_KSPROPTYPESETID_General \
    0x97E99BA0L, 0xBDEA, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("97E99BA0-BDEA-11CF-A5D6-28DB04C10000", KSPROPTYPESETID_General);
#define KSPROPTYPESETID_General DEFINE_GUIDNAMED(KSPROPTYPESETID_General)

#if defined(_NTDDK_) && !defined(__wtypes_h__)
enum VARENUM {
    VT_EMPTY = 0,
    VT_NULL = 1,
    VT_I2 = 2,
    VT_I4 = 3,
    VT_R4 = 4,
    VT_R8 = 5,
    VT_CY = 6,
    VT_DATE = 7,
    VT_BSTR = 8,
    VT_DISPATCH = 9,
    VT_ERROR = 10,
    VT_BOOL = 11,
    VT_VARIANT = 12,
    VT_UNKNOWN = 13,
    VT_DECIMAL = 14,
    VT_I1 = 16,
    VT_UI1 = 17,
    VT_UI2 = 18,
    VT_UI4 = 19,
    VT_I8 = 20,
    VT_UI8 = 21,
    VT_INT = 22,
    VT_UINT = 23,
    VT_VOID = 24,
    VT_HRESULT  = 25,
    VT_PTR = 26,
    VT_SAFEARRAY = 27,
    VT_CARRAY = 28,
    VT_USERDEFINED = 29,
    VT_LPSTR = 30,
    VT_LPWSTR = 31,
    VT_FILETIME = 64,
    VT_BLOB = 65,
    VT_STREAM = 66,
    VT_STORAGE = 67,
    VT_STREAMED_OBJECT = 68,
    VT_STORED_OBJECT = 69,
    VT_BLOB_OBJECT = 70,
    VT_CF = 71,
    VT_CLSID = 72,
    VT_VECTOR = 0x1000,
    VT_ARRAY = 0x2000,
    VT_BYREF = 0x4000,
    VT_RESERVED = 0x8000,
    VT_ILLEGAL = 0xffff,
    VT_ILLEGALMASKED = 0xfff,
    VT_TYPEMASK = 0xfff
};
#endif // _NTDDK_ && !__wtypes_h__

typedef struct {
    ULONG    Size;
    ULONG    Count;
} KSMULTIPLE_ITEM, *PKSMULTIPLE_ITEM;

typedef struct {
    ULONG           AccessFlags;
    ULONG           DescriptionSize;
    KSIDENTIFIER    PropTypeSet;
    ULONG           MembersListCount;
    ULONG           Reserved;
} KSPROPERTY_DESCRIPTION, *PKSPROPERTY_DESCRIPTION;

#define KSPROPERTY_MEMBER_RANGES            0x00000001
#define KSPROPERTY_MEMBER_STEPPEDRANGES     0x00000002
#define KSPROPERTY_MEMBER_VALUES            0x00000003

#define KSPROPERTY_MEMBER_FLAG_DEFAULT                      0x00000001
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_MULTICHANNEL    0x00000002
#define KSPROPERTY_MEMBER_FLAG_BASICSUPPORT_UNIFORM         0x00000004
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

typedef struct {
    ULONG   MembersFlags;
    ULONG   MembersSize;
    ULONG   MembersCount;
    ULONG   Flags;
} KSPROPERTY_MEMBERSHEADER, *PKSPROPERTY_MEMBERSHEADER;

typedef union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _SIGNED {
#else
    struct {
#endif    
        LONG    SignedMinimum;
        LONG    SignedMaximum;
    };
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _UNSIGNED {
#else
    struct {
#endif    
        ULONG   UnsignedMinimum;
        ULONG   UnsignedMaximum;
    };
} KSPROPERTY_BOUNDS_LONG, *PKSPROPERTY_BOUNDS_LONG;

typedef union {
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _SIGNED64 {
#else
    struct {
#endif    
        LONGLONG    SignedMinimum;
        LONGLONG    SignedMaximum;
    };
#if defined( _KS_NO_ANONYMOUS_STRUCTURES_ )
    struct _UNSIGNED64 {
#else
    struct {
#endif    
#if defined(_NTDDK_)
        ULONGLONG   UnsignedMinimum;
        ULONGLONG   UnsignedMaximum;
#else // !_NTDDK_
        DWORDLONG   UnsignedMinimum;
        DWORDLONG   UnsignedMaximum;
#endif // !_NTDDK_
    };
} KSPROPERTY_BOUNDS_LONGLONG, *PKSPROPERTY_BOUNDS_LONGLONG;

typedef struct {
    ULONG                       SteppingDelta;
    ULONG                       Reserved;
    KSPROPERTY_BOUNDS_LONG      Bounds;
} KSPROPERTY_STEPPING_LONG, *PKSPROPERTY_STEPPING_LONG;

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG                   SteppingDelta;
#else // !_NTDDK_
    DWORDLONG                   SteppingDelta;
#endif // !_NTDDK_
    KSPROPERTY_BOUNDS_LONGLONG  Bounds;
} KSPROPERTY_STEPPING_LONGLONG, *PKSPROPERTY_STEPPING_LONGLONG;

//===========================================================================
#if (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(_NTDDK_)
//
// Structure forward declarations.
//
typedef struct _KSDEVICE_DESCRIPTOR
KSDEVICE_DESCRIPTOR, *PKSDEVICE_DESCRIPTOR;
typedef struct _KSDEVICE_DISPATCH
KSDEVICE_DISPATCH, *PKSDEVICE_DISPATCH;
typedef struct _KSDEVICE 
KSDEVICE, *PKSDEVICE;
typedef struct _KSFILTERFACTORY 
KSFILTERFACTORY, *PKSFILTERFACTORY;
typedef struct _KSFILTER_DESCRIPTOR
KSFILTER_DESCRIPTOR, *PKSFILTER_DESCRIPTOR;
typedef struct _KSFILTER_DISPATCH
KSFILTER_DISPATCH, *PKSFILTER_DISPATCH;
typedef struct _KSFILTER 
KSFILTER, *PKSFILTER;
typedef struct _KSPIN_DESCRIPTOR_EX
KSPIN_DESCRIPTOR_EX, *PKSPIN_DESCRIPTOR_EX;
typedef struct _KSPIN_DISPATCH
KSPIN_DISPATCH, *PKSPIN_DISPATCH;
typedef struct _KSCLOCK_DISPATCH
KSCLOCK_DISPATCH, *PKSCLOCK_DISPATCH;
typedef struct _KSALLOCATOR_DISPATCH
KSALLOCATOR_DISPATCH, *PKSALLOCATOR_DISPATCH;
typedef struct _KSPIN 
KSPIN, *PKSPIN;
typedef struct _KSNODE_DESCRIPTOR
KSNODE_DESCRIPTOR, *PKSNODE_DESCRIPTOR;
typedef struct _KSSTREAM_POINTER_OFFSET
KSSTREAM_POINTER_OFFSET, *PKSSTREAM_POINTER_OFFSET;
typedef struct _KSSTREAM_POINTER
KSSTREAM_POINTER, *PKSSTREAM_POINTER;
typedef struct _KSMAPPING
KSMAPPING, *PKSMAPPING;
typedef struct _KSPROCESSPIN
KSPROCESSPIN, *PKSPROCESSPIN;
typedef struct _KSPROCESSPIN_INDEXENTRY
KSPROCESSPIN_INDEXENTRY, *PKSPROCESSPIN_INDEXENTRY;
#endif // _NTDDK_

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

typedef PVOID PKSWORKER;

typedef struct {
    ULONG       NotificationType;
    union {
        struct {
            HANDLE              Event;
            ULONG_PTR           Reserved[2];
        } EventHandle;
        struct {
            HANDLE              Semaphore;
            ULONG               Reserved;
            LONG                Adjustment;
        } SemaphoreHandle;
#if defined(_NTDDK_)
        struct {
            PVOID               Event;
            KPRIORITY           Increment;
            ULONG_PTR           Reserved;
        } EventObject;
        struct {
            PVOID               Semaphore;
            KPRIORITY           Increment;
            LONG                Adjustment;
        } SemaphoreObject;
        struct {
            PKDPC               Dpc;
            ULONG               ReferenceCount;
            ULONG_PTR           Reserved;
        } Dpc;
        struct {
            PWORK_QUEUE_ITEM    WorkQueueItem;
            WORK_QUEUE_TYPE     WorkQueueType;
            ULONG_PTR           Reserved;
        } WorkItem;
        struct {
            PWORK_QUEUE_ITEM    WorkQueueItem;
            PKSWORKER           KsWorkerObject;
            ULONG_PTR           Reserved;
        } KsWorkItem;
#endif // defined(_NTDDK_)
        struct {
            PVOID               Unused;
            LONG_PTR            Alignment[2];
        } Alignment;
    };
} KSEVENTDATA, *PKSEVENTDATA;

#define KSEVENTF_EVENT_HANDLE       0x00000001
#define KSEVENTF_SEMAPHORE_HANDLE   0x00000002
#if defined(_NTDDK_)
#define KSEVENTF_EVENT_OBJECT       0x00000004
#define KSEVENTF_SEMAPHORE_OBJECT   0x00000008
#define KSEVENTF_DPC                0x00000010
#define KSEVENTF_WORKITEM           0x00000020
#define KSEVENTF_KSWORKITEM         0x00000080
#endif // defined(_NTDDK_)

#define KSEVENT_TYPE_ENABLE         0x00000001
#define KSEVENT_TYPE_ONESHOT        0x00000002
#define KSEVENT_TYPE_ENABLEBUFFERED 0x00000004
#define KSEVENT_TYPE_SETSUPPORT     0x00000100
#define KSEVENT_TYPE_BASICSUPPORT   0x00000200
#define KSEVENT_TYPE_QUERYBUFFER    0x00000400

#define KSEVENT_TYPE_TOPOLOGY 0x10000000

typedef struct {
    KSEVENT         Event;
    PKSEVENTDATA    EventData;
    PVOID           Reserved;
} KSQUERYBUFFER, *PKSQUERYBUFFER;

typedef struct {
    ULONG Size;
    ULONG Flags;
    union {
        HANDLE ObjectHandle;
        PVOID ObjectPointer;
    };
    PVOID Reserved;
    KSEVENT Event;
    KSEVENTDATA EventData;
} KSRELATIVEEVENT;

#define KSRELATIVEEVENT_FLAG_HANDLE 0x00000001
#define KSRELATIVEEVENT_FLAG_POINTER 0x00000002

//===========================================================================

typedef struct {
    KSEVENTDATA     EventData;
    LONGLONG        MarkTime;
} KSEVENT_TIME_MARK, *PKSEVENT_TIME_MARK;

typedef struct {
    KSEVENTDATA     EventData;
    LONGLONG        TimeBase;
    LONGLONG        Interval;
} KSEVENT_TIME_INTERVAL, *PKSEVENT_TIME_INTERVAL;

typedef struct {
    LONGLONG        TimeBase;
    LONGLONG        Interval;
} KSINTERVAL, *PKSINTERVAL;

//===========================================================================

#define STATIC_KSPROPSETID_General\
    0x1464EDA5L, 0x6A8F, 0x11D1, 0x9A, 0xA7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("1464EDA5-6A8F-11D1-9AA7-00A0C9223196", KSPROPSETID_General);
#define KSPROPSETID_General DEFINE_GUIDNAMED(KSPROPSETID_General)

typedef enum {
    KSPROPERTY_GENERAL_COMPONENTID
} KSPROPERTY_GENERAL;

typedef struct {
    GUID    Manufacturer;
    GUID    Product;
    GUID    Component;
    GUID    Name;
    ULONG   Version;
    ULONG   Revision;
} KSCOMPONENTID, *PKSCOMPONENTID;

#define DEFINE_KSPROPERTY_ITEM_GENERAL_COMPONENTID(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_GENERAL_COMPONENTID,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCOMPONENTID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define STATIC_KSMETHODSETID_StreamIo\
    0x65D003CAL, 0x1523, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65D003CA-1523-11D2-B27A-00A0C9223196", KSMETHODSETID_StreamIo);
#define KSMETHODSETID_StreamIo DEFINE_GUIDNAMED(KSMETHODSETID_StreamIo)

typedef enum {
    KSMETHOD_STREAMIO_READ,
    KSMETHOD_STREAMIO_WRITE
} KSMETHOD_STREAMIO;

#define DEFINE_KSMETHOD_ITEM_STREAMIO_READ(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMIO_READ,\
        KSMETHOD_TYPE_WRITE,\
        (Handler),\
        sizeof(KSMETHOD),\
        0,\
        NULL)

#define DEFINE_KSMETHOD_ITEM_STREAMIO_WRITE(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMIO_WRITE,\
        KSMETHOD_TYPE_READ,\
        (Handler),\
        sizeof(KSMETHOD),\
        0,\
        NULL)

#define STATIC_KSPROPSETID_MediaSeeking\
    0xEE904F0CL, 0xD09B, 0x11D0, 0xAB, 0xE9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("EE904F0C-D09B-11D0-ABE9-00A0C9223196", KSPROPSETID_MediaSeeking);
#define KSPROPSETID_MediaSeeking DEFINE_GUIDNAMED(KSPROPSETID_MediaSeeking)

typedef enum {
    KSPROPERTY_MEDIASEEKING_CAPABILITIES,
    KSPROPERTY_MEDIASEEKING_FORMATS,
    KSPROPERTY_MEDIASEEKING_TIMEFORMAT,
    KSPROPERTY_MEDIASEEKING_POSITION,
    KSPROPERTY_MEDIASEEKING_STOPPOSITION,
    KSPROPERTY_MEDIASEEKING_POSITIONS,
    KSPROPERTY_MEDIASEEKING_DURATION,
    KSPROPERTY_MEDIASEEKING_AVAILABLE,
    KSPROPERTY_MEDIASEEKING_PREROLL,
    KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT
} KSPROPERTY_MEDIASEEKING;

typedef enum {
    KS_SEEKING_NoPositioning,
    KS_SEEKING_AbsolutePositioning,
    KS_SEEKING_RelativePositioning,
    KS_SEEKING_IncrementalPositioning,
    KS_SEEKING_PositioningBitsMask = 0x3,
    KS_SEEKING_SeekToKeyFrame,
    KS_SEEKING_ReturnTime = 0x8
} KS_SEEKING_FLAGS;

typedef enum {
    KS_SEEKING_CanSeekAbsolute = 0x1,
    KS_SEEKING_CanSeekForwards = 0x2,
    KS_SEEKING_CanSeekBackwards = 0x4,
    KS_SEEKING_CanGetCurrentPos = 0x8,
    KS_SEEKING_CanGetStopPos = 0x10,
    KS_SEEKING_CanGetDuration = 0x20,
    KS_SEEKING_CanPlayBackwards = 0x40
} KS_SEEKING_CAPABILITIES;

typedef struct {
    LONGLONG            Current;
    LONGLONG            Stop;
    KS_SEEKING_FLAGS    CurrentFlags;
    KS_SEEKING_FLAGS    StopFlags;
} KSPROPERTY_POSITIONS, *PKSPROPERTY_POSITIONS;

typedef struct {
    LONGLONG    Earliest;
    LONGLONG    Latest;
} KSPROPERTY_MEDIAAVAILABLE, *PKSPROPERTY_MEDIAAVAILABLE;

typedef struct {
    KSPROPERTY  Property;
    GUID        SourceFormat;
    GUID        TargetFormat;
    LONGLONG    Time;
} KSP_TIMEFORMAT, *PKSP_TIMEFORMAT;

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CAPABILITIES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_CAPABILITIES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KS_SEEKING_CAPABILITIES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_FORMATS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_FORMATS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_TIMEFORMAT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_TIMEFORMAT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_POSITION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_STOPPOSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_STOPPOSITION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_POSITIONS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_POSITIONS,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSPROPERTY_POSITIONS),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_DURATION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_DURATION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_AVAILABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_AVAILABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSPROPERTY_MEDIAAVAILABLE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_PREROLL(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_PREROLL,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_MEDIASEEKING_CONVERTTIMEFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEDIASEEKING_CONVERTTIMEFORMAT,\
        (Handler),\
        sizeof(KSP_TIMEFORMAT),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

//===========================================================================

#define STATIC_KSPROPSETID_Topology\
    0x720D4AC0L, 0x7533, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("720D4AC0-7533-11D0-A5D6-28DB04C10000", KSPROPSETID_Topology);
#define KSPROPSETID_Topology DEFINE_GUIDNAMED(KSPROPSETID_Topology)

typedef enum {
    KSPROPERTY_TOPOLOGY_CATEGORIES,
    KSPROPERTY_TOPOLOGY_NODES,
    KSPROPERTY_TOPOLOGY_CONNECTIONS,
    KSPROPERTY_TOPOLOGY_NAME
} KSPROPERTY_TOPOLOGY;

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_CATEGORIES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_NODES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_CONNECTIONS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_TOPOLOGY_NAME,\
        (Handler),\
        sizeof(KSP_NODE),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_TOPOLOGYSET(TopologySet, Handler)\
DEFINE_KSPROPERTY_TABLE(TopologySet) {\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CATEGORIES(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NODES(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_CONNECTIONS(Handler),\
    DEFINE_KSPROPERTY_ITEM_TOPOLOGY_NAME(Handler)\
}

//=============================================================================

//
// properties used by graph manager to talk to particular filters
//
#if defined(_NTDDK_)

#define STATIC_KSPROPSETID_GM \
    0xAF627536L, 0xE719, 0x11D2, 0x8A, 0x1D, 0x00, 0x60, 0x97, 0xD2, 0xDF, 0x5D    
DEFINE_GUIDSTRUCT("AF627536-E719-11D2-8A1D-006097D2DF5D", KSPROPSETID_GM);
#define KSPROPSETID_GM DEFINE_GUIDNAMED(KSPROPSETID_GM)

typedef VOID (*PFNKSGRAPHMANAGER_NOTIFY)(__in PFILE_OBJECT GraphManager,
                                         __in ULONG EventId,
                                         __in PVOID Filter,
                                         __in PVOID Pin,
                                         __in PVOID Frame,
                                         __in ULONG Duration);

typedef struct KSGRAPHMANAGER_FUNCTIONTABLE {
    PFNKSGRAPHMANAGER_NOTIFY NotifyEvent;
} KSGRAPHMANAGER_FUNCTIONTABLE, PKSGRAPHMANAGER_FUNCTIONTABLE;

typedef struct _KSPROPERTY_GRAPHMANAGER_INTERFACE {
    PFILE_OBJECT                 GraphManager;
    KSGRAPHMANAGER_FUNCTIONTABLE FunctionTable;
} KSPROPERTY_GRAPHMANAGER_INTERFACE, *PKSPROPERTY_GRAPHMANAGER_INTERFACE;


//
// Commands
//
typedef enum {
    KSPROPERTY_GM_GRAPHMANAGER,    
    KSPROPERTY_GM_TIMESTAMP_CLOCK, 
    KSPROPERTY_GM_RATEMATCH,       
    KSPROPERTY_GM_RENDER_CLOCK,    
} KSPROPERTY_GM;

#endif

//===========================================================================


#define STATIC_KSCATEGORY_BRIDGE \
    0x085AFF00L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("085AFF00-62CE-11CF-A5D6-28DB04C10000", KSCATEGORY_BRIDGE);
#define KSCATEGORY_BRIDGE DEFINE_GUIDNAMED(KSCATEGORY_BRIDGE)

#define STATIC_KSCATEGORY_CAPTURE \
    0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773D-8F56-11D0-A3B9-00A0C9223196", KSCATEGORY_CAPTURE);
#define KSCATEGORY_CAPTURE DEFINE_GUIDNAMED(KSCATEGORY_CAPTURE)

#define STATIC_KSCATEGORY_RENDER \
    0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773E-8F56-11D0-A3B9-00A0C9223196", KSCATEGORY_RENDER);
#define KSCATEGORY_RENDER DEFINE_GUIDNAMED(KSCATEGORY_RENDER)

#define STATIC_KSCATEGORY_MIXER \
    0xAD809C00L, 0x7B88, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("AD809C00-7B88-11D0-A5D6-28DB04C10000", KSCATEGORY_MIXER);
#define KSCATEGORY_MIXER DEFINE_GUIDNAMED(KSCATEGORY_MIXER)

#define STATIC_KSCATEGORY_SPLITTER \
    0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0A4252A0-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_SPLITTER);
#define KSCATEGORY_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_SPLITTER)

#define STATIC_KSCATEGORY_DATACOMPRESSOR \
    0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1E84C900-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATACOMPRESSOR);
#define KSCATEGORY_DATACOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATACOMPRESSOR)

#define STATIC_KSCATEGORY_DATADECOMPRESSOR \
    0x2721AE20L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2721AE20-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATADECOMPRESSOR);
#define KSCATEGORY_DATADECOMPRESSOR DEFINE_GUIDNAMED(KSCATEGORY_DATADECOMPRESSOR)

#define STATIC_KSCATEGORY_DATATRANSFORM \
    0x2EB07EA0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2EB07EA0-7E70-11D0-A5D6-28DB04C10000", KSCATEGORY_DATATRANSFORM);
#define KSCATEGORY_DATATRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_DATATRANSFORM)

//
// KSMFT_CATEGORY_XXX are MF Transform category guids redefined in ks.h 
// to facilitate KS Mini drivers to register KS Filters under MF Transform categories. 
//
#define STATIC_KSMFT_CATEGORY_VIDEO_DECODER \
	0xd6c02d4b, 0x6833, 0x45b4, 0x97, 0x1a, 0x05, 0xa4, 0xb0, 0x4b, 0xab, 0x91
DEFINE_GUIDSTRUCT("d6c02d4b-6833-45b4-971a-05a4b04bab91", KSMFT_CATEGORY_VIDEO_DECODER);
#define KSMFT_CATEGORY_VIDEO_DECODER DEFINE_GUIDNAMED(KSMFT_CATEGORY_VIDEO_DECODER)

#define STATIC_KSMFT_CATEGORY_VIDEO_ENCODER \
	0xf79eac7d, 0xe545, 0x4387, 0xbd, 0xee, 0xd6, 0x47, 0xd7, 0xbd, 0xe4, 0x2a
DEFINE_GUIDSTRUCT("f79eac7d-e545-4387-bdee-d647d7bde42a", KSMFT_CATEGORY_VIDEO_ENCODER);
#define KSMFT_CATEGORY_VIDEO_ENCODER DEFINE_GUIDNAMED(KSMFT_CATEGORY_VIDEO_ENCODER)

#define STATIC_KSMFT_CATEGORY_VIDEO_EFFECT \
	0x12e17c21, 0x532c, 0x4a6e, 0x8a, 0x1c, 0x40, 0x82, 0x5a, 0x73, 0x63, 0x97
DEFINE_GUIDSTRUCT("12e17c21-532c-4a6e-8a1c-40825a736397", KSMFT_CATEGORY_VIDEO_EFFECT);
#define KSMFT_CATEGORY_VIDEO_EFFECT DEFINE_GUIDNAMED(KSMFT_CATEGORY_VIDEO_EFFECT)

#define STATIC_KSMFT_CATEGORY_MULTIPLEXER \
	0x059c561e, 0x05ae, 0x4b61, 0xb6, 0x9d, 0x55, 0xb6, 0x1e, 0xe5, 0x4a, 0x7b
DEFINE_GUIDSTRUCT("059c561e-05ae-4b61-b69d-55b61ee54a7b", KSMFT_CATEGORY_MULTIPLEXER);
#define KSMFT_CATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(KSMFT_CATEGORY_MULTIPLEXER)

#define STATIC_KSMFT_CATEGORY_DEMULTIPLEXER \
	0xa8700a7a, 0x939b, 0x44c5, 0x99, 0xd7, 0x76, 0x22, 0x6b, 0x23, 0xb3, 0xf1
DEFINE_GUIDSTRUCT("a8700a7a-939b-44c5-99d7-76226b23b3f1", KSMFT_CATEGORY_DEMULTIPLEXER);
#define KSMFT_CATEGORY_DEMULTIPLEXER DEFINE_GUIDNAMED(KSMFT_CATEGORY_DEMULTIPLEXER)

#define STATIC_KSMFT_CATEGORY_AUDIO_DECODER \
	0x9ea73fb4, 0xef7a, 0x4559, 0x8d, 0x5d, 0x71, 0x9d, 0x8f, 0x04, 0x26, 0xc7
DEFINE_GUIDSTRUCT("9ea73fb4-ef7a-4559-8d5d-719d8f0426c7", KSMFT_CATEGORY_AUDIO_DECODER);
#define KSMFT_CATEGORY_AUDIO_DECODER DEFINE_GUIDNAMED(KSMFT_CATEGORY_AUDIO_DECODER)

#define STATIC_KSMFT_CATEGORY_AUDIO_ENCODER \
	0x91c64bd0, 0xf91e, 0x4d8c, 0x92, 0x76, 0xdb, 0x24, 0x82, 0x79, 0xd9, 0x75
DEFINE_GUIDSTRUCT("91c64bd0-f91e-4d8c-9276-db248279d975", KSMFT_CATEGORY_AUDIO_ENCODER);
#define KSMFT_CATEGORY_AUDIO_ENCODER DEFINE_GUIDNAMED(KSMFT_CATEGORY_AUDIO_ENCODER)

#define STATIC_KSMFT_CATEGORY_AUDIO_EFFECT \
	0x11064c48, 0x3648, 0x4ed0, 0x93, 0x2e, 0x05, 0xce, 0x8a, 0xc8, 0x11, 0xb7
DEFINE_GUIDSTRUCT("11064c48-3648-4ed0-932e-05ce8ac811b7", KSMFT_CATEGORY_AUDIO_EFFECT);
#define KSMFT_CATEGORY_AUDIO_EFFECT DEFINE_GUIDNAMED(KSMFT_CATEGORY_AUDIO_EFFECT)

#define STATIC_KSMFT_CATEGORY_VIDEO_PROCESSOR \
	0x302ea3fc, 0xaa5f, 0x47f9, 0x9f, 0x7a, 0xc2, 0x18, 0x8b, 0xb1, 0x63, 0x2
DEFINE_GUIDSTRUCT("302ea3fc-aa5f-47f9-9f7a-c2188bb16302", KSMFT_CATEGORY_VIDEO_PROCESSOR);
#define KSMFT_CATEGORY_VIDEO_PROCESSOR DEFINE_GUIDNAMED(KSMFT_CATEGORY_VIDEO_PROCESSOR)

#define STATIC_KSMFT_CATEGORY_OTHER \
	0x90175d57, 0xb7ea, 0x4901, 0xae, 0xb3, 0x93, 0x3a, 0x87, 0x47, 0x75, 0x6f
DEFINE_GUIDSTRUCT("90175d57-b7ea-4901-aeb3-933a8747756f", KSMFT_CATEGORY_OTHER);
#define KSMFT_CATEGORY_OTHER DEFINE_GUIDNAMED(KSMFT_CATEGORY_OTHER)

#define STATIC_KSCATEGORY_COMMUNICATIONSTRANSFORM \
    0xCF1DDA2CL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2C-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_COMMUNICATIONSTRANSFORM);
#define KSCATEGORY_COMMUNICATIONSTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_COMMUNICATIONSTRANSFORM)

#define STATIC_KSCATEGORY_INTERFACETRANSFORM \
    0xCF1DDA2DL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2D-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_INTERFACETRANSFORM);
#define KSCATEGORY_INTERFACETRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_INTERFACETRANSFORM)

#define STATIC_KSCATEGORY_MEDIUMTRANSFORM \
    0xCF1DDA2EL, 0x9743, 0x11D0, 0xA3, 0xEE, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("CF1DDA2E-9743-11D0-A3EE-00A0C9223196", KSCATEGORY_MEDIUMTRANSFORM);
#define KSCATEGORY_MEDIUMTRANSFORM DEFINE_GUIDNAMED(KSCATEGORY_MEDIUMTRANSFORM)

#define STATIC_KSCATEGORY_FILESYSTEM \
    0x760FED5EL, 0x9357, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("760FED5E-9357-11D0-A3CC-00A0C9223196", KSCATEGORY_FILESYSTEM);
#define KSCATEGORY_FILESYSTEM DEFINE_GUIDNAMED(KSCATEGORY_FILESYSTEM)

// KSNAME_Clock
#define STATIC_KSCATEGORY_CLOCK \
    0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", KSCATEGORY_CLOCK);
#define KSCATEGORY_CLOCK DEFINE_GUIDNAMED(KSCATEGORY_CLOCK)

#define STATIC_KSCATEGORY_PROXY \
    0x97EBAACAL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("97EBAACA-95BD-11D0-A3EA-00A0C9223196", KSCATEGORY_PROXY);
#define KSCATEGORY_PROXY DEFINE_GUIDNAMED(KSCATEGORY_PROXY)

#define STATIC_KSCATEGORY_QUALITY \
    0x97EBAACBL, 0x95BD, 0x11D0, 0xA3, 0xEA, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("97EBAACB-95BD-11D0-A3EA-00A0C9223196", KSCATEGORY_QUALITY);
#define KSCATEGORY_QUALITY DEFINE_GUIDNAMED(KSCATEGORY_QUALITY)

typedef struct {
    ULONG   FromNode;
    ULONG   FromNodePin;
    ULONG   ToNode;
    ULONG   ToNodePin;
} KSTOPOLOGY_CONNECTION, *PKSTOPOLOGY_CONNECTION;

typedef struct {
    ULONG                           CategoriesCount;
    __field_ecount(CategoriesCount)
    const GUID*                     Categories;
    ULONG                           TopologyNodesCount;
    __field_ecount(TopologyNodesCount)
    const GUID*                     TopologyNodes;
    ULONG                           TopologyConnectionsCount;
    __field_ecount(TopologyConnectionsCount)
    const KSTOPOLOGY_CONNECTION*    TopologyConnections;
    __field_ecount(TopologyNodesCount)
    const GUID*                     TopologyNodesNames;
    ULONG                           Reserved;
} KSTOPOLOGY, *PKSTOPOLOGY;

#define KSFILTER_NODE   ((ULONG)-1)
#define KSALL_NODES     ((ULONG)-1)

typedef struct {
    ULONG       CreateFlags;
    ULONG       Node;
} KSNODE_CREATE, *PKSNODE_CREATE;

//===========================================================================

// TIME_FORMAT_NONE
#define STATIC_KSTIME_FORMAT_NONE       STATIC_GUID_NULL
#define KSTIME_FORMAT_NONE              GUID_NULL

// TIME_FORMAT_FRAME
#define STATIC_KSTIME_FORMAT_FRAME\
    0x7b785570L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785570-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_FRAME);
#define KSTIME_FORMAT_FRAME DEFINE_GUIDNAMED(KSTIME_FORMAT_FRAME)

// TIME_FORMAT_BYTE             
#define STATIC_KSTIME_FORMAT_BYTE\
    0x7b785571L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785571-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_BYTE);
#define KSTIME_FORMAT_BYTE DEFINE_GUIDNAMED(KSTIME_FORMAT_BYTE)

// TIME_FORMAT_SAMPLE
#define STATIC_KSTIME_FORMAT_SAMPLE\
    0x7b785572L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785572-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_SAMPLE);
#define KSTIME_FORMAT_SAMPLE DEFINE_GUIDNAMED(KSTIME_FORMAT_SAMPLE)

// TIME_FORMAT_FIELD
#define STATIC_KSTIME_FORMAT_FIELD\
    0x7b785573L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785573-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_FIELD);
#define KSTIME_FORMAT_FIELD DEFINE_GUIDNAMED(KSTIME_FORMAT_FIELD)

// TIME_FORMAT_MEDIA_TIME
#define STATIC_KSTIME_FORMAT_MEDIA_TIME\
    0x7b785574L, 0x8c82, 0x11cf, 0xbc, 0x0c, 0x00, 0xaa, 0x00, 0xac, 0x74, 0xf6
DEFINE_GUIDSTRUCT("7b785574-8c82-11cf-bc0c-00aa00ac74f6", KSTIME_FORMAT_MEDIA_TIME);
#define KSTIME_FORMAT_MEDIA_TIME DEFINE_GUIDNAMED(KSTIME_FORMAT_MEDIA_TIME)

//===========================================================================

typedef KSIDENTIFIER KSPIN_INTERFACE, *PKSPIN_INTERFACE;

#define STATIC_KSINTERFACESETID_Standard \
    0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1A8766A0-62CE-11CF-A5D6-28DB04C10000", KSINTERFACESETID_Standard);
#define KSINTERFACESETID_Standard DEFINE_GUIDNAMED(KSINTERFACESETID_Standard)

typedef enum {
    KSINTERFACE_STANDARD_STREAMING,
    KSINTERFACE_STANDARD_LOOPED_STREAMING,
    KSINTERFACE_STANDARD_CONTROL		//Reserved for system use
} KSINTERFACE_STANDARD;

#define STATIC_KSINTERFACESETID_FileIo \
    0x8C6F932CL, 0xE771, 0x11D0, 0xB8, 0xFF, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("8C6F932C-E771-11D0-B8FF-00A0C9223196", KSINTERFACESETID_FileIo);
#define KSINTERFACESETID_FileIo DEFINE_GUIDNAMED(KSINTERFACESETID_FileIo)

typedef enum {
    KSINTERFACE_FILEIO_STREAMING
} KSINTERFACE_FILEIO;

//===========================================================================

#define KSMEDIUM_TYPE_ANYINSTANCE       0

#define STATIC_KSMEDIUMSETID_Standard \
    0x4747B320L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("4747B320-62CE-11CF-A5D6-28DB04C10000", KSMEDIUMSETID_Standard);
#define KSMEDIUMSETID_Standard DEFINE_GUIDNAMED(KSMEDIUMSETID_Standard)

//For compatibility only
#define KSMEDIUM_STANDARD_DEVIO     KSMEDIUM_TYPE_ANYINSTANCE

//===========================================================================

#define STATIC_KSPROPSETID_Pin\
    0x8C134960L, 0x51AD, 0x11CF, 0x87, 0x8A, 0x94, 0xF8, 0x01, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("8C134960-51AD-11CF-878A-94F801C10000", KSPROPSETID_Pin);
#define KSPROPSETID_Pin DEFINE_GUIDNAMED(KSPROPSETID_Pin)

typedef enum {
    KSPROPERTY_PIN_CINSTANCES,
    KSPROPERTY_PIN_CTYPES,
    KSPROPERTY_PIN_DATAFLOW,
    KSPROPERTY_PIN_DATARANGES,
    KSPROPERTY_PIN_DATAINTERSECTION,
    KSPROPERTY_PIN_INTERFACES,
    KSPROPERTY_PIN_MEDIUMS,
    KSPROPERTY_PIN_COMMUNICATION,
    KSPROPERTY_PIN_GLOBALCINSTANCES,
    KSPROPERTY_PIN_NECESSARYINSTANCES,
    KSPROPERTY_PIN_PHYSICALCONNECTION,
    KSPROPERTY_PIN_CATEGORY,
    KSPROPERTY_PIN_NAME,
    KSPROPERTY_PIN_CONSTRAINEDDATARANGES,
    KSPROPERTY_PIN_PROPOSEDATAFORMAT
} KSPROPERTY_PIN;

typedef struct {
    KSPROPERTY      Property;
    ULONG           PinId;
    ULONG           Reserved;
} KSP_PIN, *PKSP_PIN;

typedef struct {
    KSEVENT         Event;
    ULONG           PinId;
    ULONG           Reserved;
} KSE_PIN, *PKSE_PIN;

#define KSINSTANCE_INDETERMINATE    ((ULONG)-1)

typedef struct {
    ULONG  PossibleCount;
    ULONG  CurrentCount;
} KSPIN_CINSTANCES, *PKSPIN_CINSTANCES;

typedef enum {
    KSPIN_DATAFLOW_IN = 1,
    KSPIN_DATAFLOW_OUT
} KSPIN_DATAFLOW, *PKSPIN_DATAFLOW;

#define KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION   0
#define KSDATAFORMAT_TEMPORAL_COMPRESSION       (1 << KSDATAFORMAT_BIT_TEMPORAL_COMPRESSION)
#define KSDATAFORMAT_BIT_ATTRIBUTES 1
#define KSDATAFORMAT_ATTRIBUTES (1 << KSDATAFORMAT_BIT_ATTRIBUTES)

#define KSDATARANGE_BIT_ATTRIBUTES 1
#define KSDATARANGE_ATTRIBUTES (1 << KSDATARANGE_BIT_ATTRIBUTES)
#define KSDATARANGE_BIT_REQUIRED_ATTRIBUTES 2
#define KSDATARANGE_REQUIRED_ATTRIBUTES (1 << KSDATARANGE_BIT_REQUIRED_ATTRIBUTES)

#if !defined( _MSC_VER ) 
typedef struct {
    ULONG   FormatSize;
    ULONG   Flags;
    ULONG   SampleSize;
    ULONG   Reserved;
    GUID    MajorFormat;
    GUID    SubFormat;
    GUID    Specifier;
} KSDATAFORMAT, *PKSDATAFORMAT, KSDATARANGE, *PKSDATARANGE;
#else
typedef union {
    struct {
        ULONG   FormatSize;
        ULONG   Flags;
        ULONG   SampleSize;
        ULONG   Reserved;
        GUID    MajorFormat;
        GUID    SubFormat;
        GUID    Specifier;
    };
    LONGLONG    Alignment;
} KSDATAFORMAT, *PKSDATAFORMAT, KSDATARANGE, *PKSDATARANGE;
#endif

#define KSATTRIBUTE_REQUIRED 0x00000001

typedef struct {
    ULONG Size;
    ULONG Flags;
    GUID Attribute;
} KSATTRIBUTE, *PKSATTRIBUTE;

#if defined(_NTDDK_)
typedef struct {
    ULONG Count;
    __field_ecount(Count) PKSATTRIBUTE* Attributes;
} KSATTRIBUTE_LIST, *PKSATTRIBUTE_LIST;
#endif // _NTDDK_

typedef enum {
    KSPIN_COMMUNICATION_NONE,
    KSPIN_COMMUNICATION_SINK,
    KSPIN_COMMUNICATION_SOURCE,
    KSPIN_COMMUNICATION_BOTH,
    KSPIN_COMMUNICATION_BRIDGE
} KSPIN_COMMUNICATION, *PKSPIN_COMMUNICATION;

typedef KSIDENTIFIER KSPIN_MEDIUM, *PKSPIN_MEDIUM;

typedef struct {
    KSPIN_INTERFACE Interface;
    KSPIN_MEDIUM    Medium;
    ULONG           PinId;
    HANDLE          PinToHandle;
    KSPRIORITY      Priority;
} KSPIN_CONNECT, *PKSPIN_CONNECT;

typedef struct {
    ULONG   Size;
    ULONG   Pin;
    WCHAR   SymbolicLinkName[1];
} KSPIN_PHYSICALCONNECTION, *PKSPIN_PHYSICALCONNECTION;

#if defined(_NTDDK_)
__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSINTERSECTHANDLER)(
    __in PIRP Irp,
    __in PKSP_PIN Pin,
    __in PKSDATARANGE DataRange,
    __out_opt PVOID Data
    );
__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSINTERSECTHANDLEREX)(
    __in PVOID Context,
    __in PIRP Irp,
    __in PKSP_PIN Pin,
    __in PKSDATARANGE DataRange,
    __in PKSDATARANGE MatchingDataRange,
    __in ULONG DataBufferSize,
    __out_bcount_part_opt(DataBufferSize, *DataSize) PVOID Data,
    __out PULONG DataSize
    );
#endif // _NTDDK_

#define DEFINE_KSPIN_INTERFACE_TABLE(tablename)\
    const KSPIN_INTERFACE tablename[] =

#define DEFINE_KSPIN_INTERFACE_ITEM(guid, interface)\
    {\
        STATICGUIDOF(guid),\
        (interface),\
        0\
    }

#define DEFINE_KSPIN_MEDIUM_TABLE( tablename )\
    const KSPIN_MEDIUM tablename[] =

#define DEFINE_KSPIN_MEDIUM_ITEM(guid, medium)\
    DEFINE_KSPIN_INTERFACE_ITEM(guid, medium)

#define DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_CINSTANCES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CTYPES,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATAFLOW,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_DATAFLOW),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATARANGES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_DATAINTERSECTION,\
        (Handler),\
        sizeof(KSP_PIN) + sizeof(KSMULTIPLE_ITEM),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_INTERFACES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_MEDIUMS,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_COMMUNICATION,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_COMMUNICATION),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_GLOBALCINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_GLOBALCINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(KSPIN_CINSTANCES),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_NECESSARYINSTANCES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_NECESSARYINSTANCES,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_PHYSICALCONNECTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_PHYSICALCONNECTION,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CATEGORY,\
        (Handler),\
        sizeof(KSP_PIN),\
        sizeof(GUID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_NAME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_NAME,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_CONSTRAINEDDATARANGES,\
        (Handler),\
        sizeof(KSP_PIN),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_PIN_PROPOSEDATAFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PIN_PROPOSEDATAFORMAT,\
        NULL,\
        sizeof(KSP_PIN),\
        sizeof(KSDATAFORMAT),\
        (Handler), NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_PINSET(PinSet,\
    PropGeneral, PropInstances, PropIntersection)\
DEFINE_KSPROPERTY_TABLE(PinSet) {\
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),\
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),\
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral)\
}

#define DEFINE_KSPROPERTY_PINSETCONSTRAINED(PinSet,\
    PropGeneral, PropInstances, PropIntersection)\
DEFINE_KSPROPERTY_TABLE(PinSet) {\
    DEFINE_KSPROPERTY_ITEM_PIN_CINSTANCES(PropInstances),\
    DEFINE_KSPROPERTY_ITEM_PIN_CTYPES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAFLOW(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATARANGES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_DATAINTERSECTION(PropIntersection),\
    DEFINE_KSPROPERTY_ITEM_PIN_INTERFACES(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_MEDIUMS(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_COMMUNICATION(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CATEGORY(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_NAME(PropGeneral),\
    DEFINE_KSPROPERTY_ITEM_PIN_CONSTRAINEDDATARANGES(PropGeneral)\
}

#define STATIC_KSEVENTSETID_PinCapsChange \
    0xDD4F192E, 0x3B78, 0x49AD, 0xA5, 0x34, 0x2C, 0x31, 0x5b, 0x82, 0x20, 0x00
DEFINE_GUIDSTRUCT("DD4F192E-3B78-49AD-A534-2C315B822000", KSEVENTSETID_PinCapsChange);
#define KSEVENTSETID_PinCapsChange DEFINE_GUIDNAMED(KSEVENTSETID_PinCapsChange)

typedef enum {
    KSEVENT_PINCAPS_FORMATCHANGE,
    KSEVENT_PINCAPS_JACKINFOCHANGE
} KSEVENT_PINCAPS_CHANGENOTIFICATIONS;

#define STATIC_KSNAME_Filter\
    0x9b365890L, 0x165f, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("9b365890-165f-11d0-a195-0020afd156e4", KSNAME_Filter);
#define KSNAME_Filter DEFINE_GUIDNAMED(KSNAME_Filter)

#define KSSTRING_Filter L"{9B365890-165F-11D0-A195-0020AFD156E4}"

#define STATIC_KSNAME_Pin\
    0x146F1A80L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("146F1A80-4791-11D0-A5D6-28DB04C10000", KSNAME_Pin);
#define KSNAME_Pin DEFINE_GUIDNAMED(KSNAME_Pin)

#define KSSTRING_Pin L"{146F1A80-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_KSNAME_Clock\
    0x53172480L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("53172480-4791-11D0-A5D6-28DB04C10000", KSNAME_Clock);
#define KSNAME_Clock DEFINE_GUIDNAMED(KSNAME_Clock)

#define KSSTRING_Clock L"{53172480-4791-11D0-A5D6-28DB04C10000}"

#define STATIC_KSNAME_Allocator\
    0x642F5D00L, 0x4791, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("642F5D00-4791-11D0-A5D6-28DB04C10000", KSNAME_Allocator);
#define KSNAME_Allocator DEFINE_GUIDNAMED(KSNAME_Allocator)

#define KSSTRING_Allocator L"{642F5D00-4791-11D0-A5D6-28DB04C10000}"

#define KSSTRING_AllocatorEx L"{091BB63B-603F-11D1-B067-00A0C9062802}"

#define STATIC_KSNAME_TopologyNode\
    0x0621061AL, 0xEE75, 0x11D0, 0xB9, 0x15, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("0621061A-EE75-11D0-B915-00A0C9223196", KSNAME_TopologyNode);
#define KSNAME_TopologyNode DEFINE_GUIDNAMED(KSNAME_TopologyNode)

#define KSSTRING_TopologyNode L"{0621061A-EE75-11D0-B915-00A0C9223196}"

#if defined(_NTDDK_)

typedef struct {
    ULONG                   InterfacesCount;
    __field_ecount(InterfacesCount)
    const KSPIN_INTERFACE*  Interfaces;
    ULONG                   MediumsCount;
    __field_ecount(MediumsCount)
    const KSPIN_MEDIUM*     Mediums;
    ULONG                   DataRangesCount;
    __field_ecount(DataRangesCount)
    const PKSDATARANGE*     DataRanges;
    KSPIN_DATAFLOW          DataFlow;
    KSPIN_COMMUNICATION     Communication;
    const GUID*             Category;
    const GUID*             Name;
    union {
        LONGLONG            Reserved;
        struct {
            ULONG           ConstrainedDataRangesCount;
            __field_ecount(ConstrainedDataRangesCount)
            PKSDATARANGE*   ConstrainedDataRanges;
        };
    };
} KSPIN_DESCRIPTOR, *PKSPIN_DESCRIPTOR;
typedef const KSPIN_DESCRIPTOR *PCKSPIN_DESCRIPTOR;

#define DEFINE_KSPIN_DESCRIPTOR_TABLE(tablename)\
    const KSPIN_DESCRIPTOR tablename[] =

#define DEFINE_KSPIN_DESCRIPTOR_ITEM(\
    InterfacesCount, Interfaces,\
    MediumsCount, Mediums,\
    DataRangesCount, DataRanges,\
    DataFlow, Communication)\
{\
    InterfacesCount, Interfaces, MediumsCount, Mediums,\
    DataRangesCount, DataRanges, DataFlow, Communication,\
    NULL, NULL, 0\
}
#define DEFINE_KSPIN_DESCRIPTOR_ITEMEX(\
    InterfacesCount, Interfaces,\
    MediumsCount, Mediums,\
    DataRangesCount, DataRanges,\
    DataFlow, Communication,\
    Category, Name)\
{\
    InterfacesCount, Interfaces, MediumsCount, Mediums,\
    DataRangesCount, DataRanges, DataFlow, Communication,\
    Category, Name, 0\
}

#endif // defined(_NTDDK_)

//===========================================================================

// MEDIATYPE_NULL
#define STATIC_KSDATAFORMAT_TYPE_WILDCARD       STATIC_GUID_NULL
#define KSDATAFORMAT_TYPE_WILDCARD              GUID_NULL

// MEDIASUBTYPE_NULL
#define STATIC_KSDATAFORMAT_SUBTYPE_WILDCARD    STATIC_GUID_NULL
#define KSDATAFORMAT_SUBTYPE_WILDCARD           GUID_NULL

// MEDIATYPE_Stream
#define STATIC_KSDATAFORMAT_TYPE_STREAM\
    0xE436EB83L, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
DEFINE_GUIDSTRUCT("E436EB83-524F-11CE-9F53-0020AF0BA770", KSDATAFORMAT_TYPE_STREAM);
#define KSDATAFORMAT_TYPE_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STREAM)

// MEDIASUBTYPE_None
#define STATIC_KSDATAFORMAT_SUBTYPE_NONE\
    0xE436EB8EL, 0x524F, 0x11CE, 0x9F, 0x53, 0x00, 0x20, 0xAF, 0x0B, 0xA7, 0x70
DEFINE_GUIDSTRUCT("E436EB8E-524F-11CE-9F53-0020AF0BA770", KSDATAFORMAT_SUBTYPE_NONE);
#define KSDATAFORMAT_SUBTYPE_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NONE)

#define STATIC_KSDATAFORMAT_SPECIFIER_WILDCARD  STATIC_GUID_NULL
#define KSDATAFORMAT_SPECIFIER_WILDCARD         GUID_NULL

#define STATIC_KSDATAFORMAT_SPECIFIER_FILENAME\
    0xAA797B40L, 0xE974, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("AA797B40-E974-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SPECIFIER_FILENAME);
#define KSDATAFORMAT_SPECIFIER_FILENAME DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILENAME)

#define STATIC_KSDATAFORMAT_SPECIFIER_FILEHANDLE\
    0x65E8773CL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("65E8773C-8F56-11D0-A3B9-00A0C9223196", KSDATAFORMAT_SPECIFIER_FILEHANDLE);
#define KSDATAFORMAT_SPECIFIER_FILEHANDLE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_FILEHANDLE)

// FORMAT_None
#define STATIC_KSDATAFORMAT_SPECIFIER_NONE\
    0x0F6417D6L, 0xC318, 0x11D0, 0xA4, 0x3F, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("0F6417D6-C318-11D0-A43F-00A0C9223196", KSDATAFORMAT_SPECIFIER_NONE);
#define KSDATAFORMAT_SPECIFIER_NONE DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_NONE)

//===========================================================================

#define STATIC_KSPROPSETID_Quality \
    0xD16AD380L, 0xAC1A, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("D16AD380-AC1A-11CF-A5D6-28DB04C10000", KSPROPSETID_Quality);
#define KSPROPSETID_Quality DEFINE_GUIDNAMED(KSPROPSETID_Quality)

typedef enum {
    KSPROPERTY_QUALITY_REPORT,
    KSPROPERTY_QUALITY_ERROR
} KSPROPERTY_QUALITY;

#define DEFINE_KSPROPERTY_ITEM_QUALITY_REPORT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_QUALITY_REPORT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSQUALITY),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_QUALITY_ERROR(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_QUALITY_ERROR,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSERROR),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//===========================================================================

#define STATIC_KSPROPSETID_Connection \
    0x1D58C920L, 0xAC9B, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D58C920-AC9B-11CF-A5D6-28DB04C10000", KSPROPSETID_Connection);
#define KSPROPSETID_Connection DEFINE_GUIDNAMED(KSPROPSETID_Connection)

typedef enum {
    KSPROPERTY_CONNECTION_STATE,
    KSPROPERTY_CONNECTION_PRIORITY,
    KSPROPERTY_CONNECTION_DATAFORMAT,
    KSPROPERTY_CONNECTION_ALLOCATORFRAMING,
    KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,
    KSPROPERTY_CONNECTION_ACQUIREORDERING,
    KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,
    KSPROPERTY_CONNECTION_STARTAT
} KSPROPERTY_CONNECTION;

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_STATE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PRIORITY(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_PRIORITY,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSPRIORITY),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_DATAFORMAT(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_DATAFORMAT,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSALLOCATOR_FRAMING),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ALLOCATORFRAMING_EX(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ALLOCATORFRAMING_EX,\
        (Handler),\
        sizeof(KSPROPERTY),\
        0,\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_PROPOSEDATAFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_PROPOSEDATAFORMAT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSDATAFORMAT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_ACQUIREORDERING(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_ACQUIREORDERING,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(int),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CONNECTION_STARTAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CONNECTION_STARTAT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSRELATIVEEVENT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
//VRAM transport related propset
//===========================================================================

#define STATIC_KSPROPSETID_MemoryTransport \
    0xa3d1c5d, 0x5243, 0x4819, 0x9e, 0xd0, 0xae, 0xe8, 0x4, 0x4c, 0xee, 0x2b
DEFINE_GUIDSTRUCT("0A3D1C5D-5243-4819-9ED0-AEE8044CEE2B", KSPROPSETID_MemoryTransport);
#define KSPROPSETID_MemoryTransport DEFINE_GUIDNAMED(KSPROPSETID_MemoryTransport)
enum {
    // a value of zero is ignored
    KSPROPERTY_MEMORY_TRANSPORT = 1 //Sets pin's memory transport mechanism e.g. VRAM or SYSMEM
};

#define DEFINE_KSPROPERTY_ITEM_MEMORY_TRANSPORT(SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MEMORY_TRANSPORT,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(BOOL),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
//
// pins flags
//
#define KSALLOCATOR_REQUIREMENTF_INPLACE_MODIFIER   0x00000001
#define KSALLOCATOR_REQUIREMENTF_SYSTEM_MEMORY      0x00000002
#define KSALLOCATOR_REQUIREMENTF_FRAME_INTEGRITY    0x00000004
#define KSALLOCATOR_REQUIREMENTF_MUST_ALLOCATE      0x00000008
#define KSALLOCATOR_REQUIREMENTF_PREFERENCES_ONLY   0x80000000

#define KSALLOCATOR_OPTIONF_COMPATIBLE              0x00000001
#define KSALLOCATOR_OPTIONF_SYSTEM_MEMORY           0x00000002
#define KSALLOCATOR_OPTIONF_VALID                   0x00000003
// 
// pins extended framing flags
//
#define KSALLOCATOR_FLAG_PARTIAL_READ_SUPPORT       0x00000010
#define KSALLOCATOR_FLAG_DEVICE_SPECIFIC            0x00000020
#define KSALLOCATOR_FLAG_CAN_ALLOCATE               0x00000040
#define KSALLOCATOR_FLAG_INSIST_ON_FRAMESIZE_RATIO  0x00000080
//
// allocator pipes flags
//
// there is at least one data modification in a pipe
#define KSALLOCATOR_FLAG_NO_FRAME_INTEGRITY         0x00000100
#define KSALLOCATOR_FLAG_MULTIPLE_OUTPUT            0x00000200
#define KSALLOCATOR_FLAG_CYCLE                      0x00000400
#define KSALLOCATOR_FLAG_ALLOCATOR_EXISTS           0x00000800
// there is no framing dependency between neighbouring pipes.
#define KSALLOCATOR_FLAG_INDEPENDENT_RANGES         0x00001000
#define KSALLOCATOR_FLAG_ATTENTION_STEPPING         0x00002000


//
// old Framing structure
//
typedef struct {
    union {
        ULONG       OptionsFlags;       // allocator options (create)
        ULONG       RequirementsFlags;  // allocation requirements (query)
    };
#if defined(_NTDDK_)
    POOL_TYPE   PoolType;
#else // !_NTDDK_
    ULONG       PoolType;
#endif // !_NTDDK_
    ULONG       Frames;     // total number of allowable outstanding frames
    ULONG       FrameSize;  // total size of frame
    ULONG       FileAlignment;
    ULONG       Reserved;
} KSALLOCATOR_FRAMING, *PKSALLOCATOR_FRAMING;

#if defined(_NTDDK_)
typedef
PVOID
(*PFNKSDEFAULTALLOCATE)(
    __in PVOID Context
    );

typedef
VOID
(*PFNKSDEFAULTFREE)(
    __in PVOID Context,
    __in PVOID Buffer
    );

typedef
NTSTATUS
(*PFNKSINITIALIZEALLOCATOR)(
    __in PVOID InitialContext,
    __in PKSALLOCATOR_FRAMING AllocatorFraming,
    __deref_out PVOID* Context
    );

typedef
VOID
(*PFNKSDELETEALLOCATOR)(
    __in PVOID Context
    );
#endif // !_NTDDK_

//
// new Framing structure, eventually will replace KSALLOCATOR_FRAMING.
// 
typedef struct {
    ULONG   MinFrameSize;
    ULONG   MaxFrameSize;
    ULONG   Stepping;
} KS_FRAMING_RANGE, *PKS_FRAMING_RANGE;


typedef struct {
    KS_FRAMING_RANGE  Range;
    ULONG             InPlaceWeight;
    ULONG             NotInPlaceWeight;
} KS_FRAMING_RANGE_WEIGHTED, *PKS_FRAMING_RANGE_WEIGHTED;


typedef struct {
    ULONG   RatioNumerator;      // compression/expansion ratio
    ULONG   RatioDenominator; 
    ULONG   RatioConstantMargin;
} KS_COMPRESSION, *PKS_COMPRESSION;


//
// Memory Types and Buses are repeated in each entry.
// Easiest to use but takes a little more memory than the varsize layout Pin\Memories\Buses\Ranges.
//
typedef struct {
    GUID                        MemoryType;
    GUID                        BusType;
    ULONG                       MemoryFlags;
    ULONG                       BusFlags;   
    ULONG                       Flags;   
    ULONG                       Frames;              // total number of allowable outstanding frames
    ULONG                       FileAlignment;
    ULONG                       MemoryTypeWeight;    // this memory type Weight pin-wide
    KS_FRAMING_RANGE            PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED   FramingRange; 
} KS_FRAMING_ITEM, *PKS_FRAMING_ITEM;


typedef struct {
    ULONG               CountItems;         // count of FramingItem-s below.
    ULONG               PinFlags;
    KS_COMPRESSION      OutputCompression;
    ULONG               PinWeight;          // this pin framing's Weight graph-wide
    KS_FRAMING_ITEM     FramingItem[1]; 
} KSALLOCATOR_FRAMING_EX, *PKSALLOCATOR_FRAMING_EX;



//
// define memory type GUIDs
//
#define KSMEMORY_TYPE_WILDCARD          GUID_NULL
#define STATIC_KSMEMORY_TYPE_WILDCARD   STATIC_GUID_NULL

#define KSMEMORY_TYPE_DONT_CARE         GUID_NULL
#define STATIC_KSMEMORY_TYPE_DONT_CARE  STATIC_GUID_NULL

#define KS_TYPE_DONT_CARE           GUID_NULL
#define STATIC_KS_TYPE_DONT_CARE    STATIC_GUID_NULL
     
#define STATIC_KSMEMORY_TYPE_SYSTEM \
    0x091bb638L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("091bb638-603f-11d1-b067-00a0c9062802", KSMEMORY_TYPE_SYSTEM);
#define KSMEMORY_TYPE_SYSTEM  DEFINE_GUIDNAMED(KSMEMORY_TYPE_SYSTEM)

#define STATIC_KSMEMORY_TYPE_USER \
    0x8cb0fc28L, 0x7893, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("8cb0fc28-7893-11d1-b069-00a0c9062802", KSMEMORY_TYPE_USER);
#define KSMEMORY_TYPE_USER  DEFINE_GUIDNAMED(KSMEMORY_TYPE_USER)

#define STATIC_KSMEMORY_TYPE_KERNEL_PAGED \
    0xd833f8f8L, 0x7894, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("d833f8f8-7894-11d1-b069-00a0c9062802", KSMEMORY_TYPE_KERNEL_PAGED);
#define KSMEMORY_TYPE_KERNEL_PAGED  DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_PAGED)

#define STATIC_KSMEMORY_TYPE_KERNEL_NONPAGED \
    0x4a6d5fc4L, 0x7895, 0x11d1, 0xb0, 0x69, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("4a6d5fc4-7895-11d1-b069-00a0c9062802", KSMEMORY_TYPE_KERNEL_NONPAGED);
#define KSMEMORY_TYPE_KERNEL_NONPAGED  DEFINE_GUIDNAMED(KSMEMORY_TYPE_KERNEL_NONPAGED)

// old KS clients did not specify the device memory type
#define STATIC_KSMEMORY_TYPE_DEVICE_UNKNOWN \
    0x091bb639L, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
DEFINE_GUIDSTRUCT("091bb639-603f-11d1-b067-00a0c9062802", KSMEMORY_TYPE_DEVICE_UNKNOWN);
#define KSMEMORY_TYPE_DEVICE_UNKNOWN DEFINE_GUIDNAMED(KSMEMORY_TYPE_DEVICE_UNKNOWN)

//
// Helper framing macros.
//
#define DECLARE_SIMPLE_FRAMING_EX(FramingExName, MemoryType, Flags, Frames, Alignment, MinFrameSize, MaxFrameSize) \
    const KSALLOCATOR_FRAMING_EX FramingExName = \
    {\
        1, \
        0, \
        {\
            1, \
            1, \
            0 \
        }, \
        0, \
        {\
            {\
                MemoryType, \
                STATIC_KS_TYPE_DONT_CARE, \
                0, \
                0, \
                Flags, \
                Frames, \
                Alignment, \
                0, \
                {\
                    0, \
                    (ULONG)-1, \
                    1 \
                }, \
                {\
                    {\
                        MinFrameSize, \
                        MaxFrameSize, \
                        1 \
                    }, \
                    0, \
                    0  \
                }\
            }\
        }\
    }

#define SetDefaultKsCompression(KsCompressionPointer) \
{\
    KsCompressionPointer->RatioNumerator = 1;\
    KsCompressionPointer->RatioDenominator = 1;\
    KsCompressionPointer->RatioConstantMargin = 0;\
}

#define SetDontCareKsFramingRange(KsFramingRangePointer) \
{\
    KsFramingRangePointer->MinFrameSize = 0;\
    KsFramingRangePointer->MaxFrameSize = (ULONG) -1;\
    KsFramingRangePointer->Stepping = 1;\
}

#define SetKsFramingRange(KsFramingRangePointer, P_MinFrameSize, P_MaxFrameSize) \
{\
    KsFramingRangePointer->MinFrameSize = P_MinFrameSize;\
    KsFramingRangePointer->MaxFrameSize = P_MaxFrameSize;\
    KsFramingRangePointer->Stepping = 1;\
}

#define SetKsFramingRangeWeighted(KsFramingRangeWeightedPointer, P_MinFrameSize, P_MaxFrameSize) \
{\
    KS_FRAMING_RANGE *KsFramingRange = &KsFramingRangeWeightedPointer->Range;\
    SetKsFramingRange(KsFramingRange, P_MinFrameSize, P_MaxFrameSize);\
    KsFramingRangeWeightedPointer->InPlaceWeight = 0;\
    KsFramingRangeWeightedPointer->NotInPlaceWeight = 0;\
}

#define INITIALIZE_SIMPLE_FRAMING_EX(FramingExPointer, P_MemoryType, P_Flags, P_Frames, P_Alignment, P_MinFrameSize, P_MaxFrameSize) \
{\
    KS_COMPRESSION *KsCompression = &FramingExPointer->OutputCompression;\
    KS_FRAMING_RANGE *KsFramingRange = &FramingExPointer->FramingItem[0].PhysicalRange;\
    KS_FRAMING_RANGE_WEIGHTED *KsFramingRangeWeighted = &FramingExPointer->FramingItem[0].FramingRange;\
    FramingExPointer->CountItems = 1;\
    FramingExPointer->PinFlags = 0;\
    SetDefaultKsCompression(KsCompression);\
    FramingExPointer->PinWeight = 0;\
    FramingExPointer->FramingItem[0].MemoryType = P_MemoryType;\
    FramingExPointer->FramingItem[0].BusType = KS_TYPE_DONT_CARE;\
    FramingExPointer->FramingItem[0].MemoryFlags = 0;\
    FramingExPointer->FramingItem[0].BusFlags = 0;\
    FramingExPointer->FramingItem[0].Flags = P_Flags;\
    FramingExPointer->FramingItem[0].Frames = P_Frames;\
    FramingExPointer->FramingItem[0].FileAlignment = P_Alignment;\
    FramingExPointer->FramingItem[0].MemoryTypeWeight = 0;\
    SetDontCareKsFramingRange(KsFramingRange);\
    SetKsFramingRangeWeighted(KsFramingRangeWeighted, P_MinFrameSize, P_MaxFrameSize);\
}



// KSEVENTSETID_StreamAllocator: {75D95571-073C-11d0-A161-0020AFD156E4}

#define STATIC_KSEVENTSETID_StreamAllocator\
    0x75d95571L, 0x073c, 0x11d0, 0xa1, 0x61, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("75d95571-073c-11d0-a161-0020afd156e4", KSEVENTSETID_StreamAllocator);
#define KSEVENTSETID_StreamAllocator DEFINE_GUIDNAMED(KSEVENTSETID_StreamAllocator)

typedef enum {
    KSEVENT_STREAMALLOCATOR_INTERNAL_FREEFRAME,
    KSEVENT_STREAMALLOCATOR_FREEFRAME
} KSEVENT_STREAMALLOCATOR;

#define STATIC_KSMETHODSETID_StreamAllocator\
    0xcf6e4341L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("cf6e4341-ec87-11cf-a130-0020afd156e4", KSMETHODSETID_StreamAllocator);
#define KSMETHODSETID_StreamAllocator DEFINE_GUIDNAMED(KSMETHODSETID_StreamAllocator)

typedef enum {
    KSMETHOD_STREAMALLOCATOR_ALLOC,
    KSMETHOD_STREAMALLOCATOR_FREE
} KSMETHOD_STREAMALLOCATOR;

#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMALLOCATOR_ALLOC,\
        KSMETHOD_TYPE_WRITE,\
        (Handler),\
        sizeof(KSMETHOD),\
        sizeof(PVOID),\
        NULL)

#define DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(Handler)\
    DEFINE_KSMETHOD_ITEM(\
        KSMETHOD_STREAMALLOCATOR_FREE,\
        KSMETHOD_TYPE_READ,\
        (Handler),\
        sizeof(KSMETHOD),\
        sizeof(PVOID),\
        NULL)

#define DEFINE_KSMETHOD_ALLOCATORSET(AllocatorSet, MethodAlloc, MethodFree)\
DEFINE_KSMETHOD_TABLE(AllocatorSet) {\
    DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_ALLOC(MethodAlloc),\
    DEFINE_KSMETHOD_ITEM_STREAMALLOCATOR_FREE(MethodFree)\
}

#define STATIC_KSPROPSETID_StreamAllocator\
    0xcf6e4342L, 0xec87, 0x11cf, 0xa1, 0x30, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("cf6e4342-ec87-11cf-a130-0020afd156e4", KSPROPSETID_StreamAllocator);
#define KSPROPSETID_StreamAllocator DEFINE_GUIDNAMED(KSPROPSETID_StreamAllocator)

#if defined(_NTDDK_)
typedef enum {
    KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,
    KSPROPERTY_STREAMALLOCATOR_STATUS
} KSPROPERTY_STREAMALLOCATOR;

#define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMALLOCATOR_FUNCTIONTABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTREAMALLOCATOR_FUNCTIONTABLE),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMALLOCATOR_STATUS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTREAMALLOCATOR_STATUS),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ALLOCATORSET(AllocatorSet, PropFunctionTable, PropStatus)\
DEFINE_KSPROPERTY_TABLE(AllocatorSet) {\
    DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_STATUS(PropStatus),\
    DEFINE_KSPROPERTY_ITEM_STREAMALLOCATOR_FUNCTIONTABLE(PropFunctionTable)\
}

typedef
NTSTATUS
(*PFNALLOCATOR_ALLOCATEFRAME)(
    __in PFILE_OBJECT FileObject,
    __deref_out PVOID *Frame
    );

typedef
VOID
(*PFNALLOCATOR_FREEFRAME)(
    __in PFILE_OBJECT FileObject,
    __in PVOID Frame
    );

typedef struct {
    PFNALLOCATOR_ALLOCATEFRAME  AllocateFrame;
    PFNALLOCATOR_FREEFRAME      FreeFrame;
} KSSTREAMALLOCATOR_FUNCTIONTABLE, *PKSSTREAMALLOCATOR_FUNCTIONTABLE;
#endif // defined(_NTDDK_)

typedef struct {
    KSALLOCATOR_FRAMING Framing;
    ULONG               AllocatedFrames;
    ULONG               Reserved;
} KSSTREAMALLOCATOR_STATUS, *PKSSTREAMALLOCATOR_STATUS;

typedef struct {
    KSALLOCATOR_FRAMING_EX Framing;
    ULONG                  AllocatedFrames;
    ULONG                  Reserved;
} KSSTREAMALLOCATOR_STATUS_EX, *PKSSTREAMALLOCATOR_STATUS_EX;


#define KSSTREAM_HEADER_OPTIONSF_SPLICEPOINT        0x00000001
#define KSSTREAM_HEADER_OPTIONSF_PREROLL            0x00000002
#define KSSTREAM_HEADER_OPTIONSF_DATADISCONTINUITY  0x00000004
#define KSSTREAM_HEADER_OPTIONSF_TYPECHANGED        0x00000008
#define KSSTREAM_HEADER_OPTIONSF_TIMEVALID          0x00000010
#define KSSTREAM_HEADER_OPTIONSF_TIMEDISCONTINUITY  0x00000040
#define KSSTREAM_HEADER_OPTIONSF_FLUSHONPAUSE       0x00000080
#define KSSTREAM_HEADER_OPTIONSF_DURATIONVALID      0x00000100
#define KSSTREAM_HEADER_OPTIONSF_ENDOFSTREAM        0x00000200
#define KSSTREAM_HEADER_OPTIONSF_BUFFEREDTRANSFER   0x00000400
#define KSSTREAM_HEADER_OPTIONSF_VRAM_DATA_TRANSFER 0x00000800
#define KSSTREAM_HEADER_OPTIONSF_LOOPEDDATA         0x80000000

typedef struct {
    LONGLONG    Time;
    ULONG       Numerator;
    ULONG       Denominator;
} KSTIME, *PKSTIME;

typedef struct {
    ULONG       Size;
    ULONG       TypeSpecificFlags;
    KSTIME      PresentationTime;
    LONGLONG    Duration;
    ULONG       FrameExtent;
    ULONG       DataUsed;
    __field_bcount(FrameExtent)
    PVOID       Data;
    ULONG       OptionsFlags;
#if _WIN64
    ULONG       Reserved;
#endif
} KSSTREAM_HEADER, *PKSSTREAM_HEADER;

#define STATIC_KSPROPSETID_StreamInterface\
    0x1fdd8ee1L, 0x9cd3, 0x11d0, 0x82, 0xaa, 0x00, 0x00, 0xf8, 0x22, 0xfe, 0x8a
DEFINE_GUIDSTRUCT("1fdd8ee1-9cd3-11d0-82aa-0000f822fe8a", KSPROPSETID_StreamInterface);
#define KSPROPSETID_StreamInterface DEFINE_GUIDNAMED(KSPROPSETID_StreamInterface)

typedef enum {
    KSPROPERTY_STREAMINTERFACE_HEADERSIZE
} KSPROPERTY_STREAMINTERFACE;

#define DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE( GetHandler )\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAMINTERFACE_HEADERSIZE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)
        
#define DEFINE_KSPROPERTY_STREAMINTERFACESET(StreamInterfaceSet,\
    HeaderSizeHandler)\
DEFINE_KSPROPERTY_TABLE(StreamInterfaceSet) {\
    DEFINE_KSPROPERTY_ITEM_STREAMINTERFACE_HEADERSIZE( HeaderSizeHandler )\
}

#define STATIC_KSPROPSETID_Stream\
    0x65aaba60L, 0x98ae, 0x11cf, 0xa1, 0x0d, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("65aaba60-98ae-11cf-a10d-0020afd156e4", KSPROPSETID_Stream);
#define KSPROPSETID_Stream DEFINE_GUIDNAMED(KSPROPSETID_Stream)

typedef enum {
    KSPROPERTY_STREAM_ALLOCATOR,
    KSPROPERTY_STREAM_QUALITY,
    KSPROPERTY_STREAM_DEGRADATION,
    KSPROPERTY_STREAM_MASTERCLOCK,
    KSPROPERTY_STREAM_TIMEFORMAT,
    KSPROPERTY_STREAM_PRESENTATIONTIME,
    KSPROPERTY_STREAM_PRESENTATIONEXTENT,
    KSPROPERTY_STREAM_FRAMETIME,
    KSPROPERTY_STREAM_RATECAPABILITY,
    KSPROPERTY_STREAM_RATE,
    KSPROPERTY_STREAM_PIPE_ID
} KSPROPERTY_STREAM;

#define DEFINE_KSPROPERTY_ITEM_STREAM_ALLOCATOR(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_ALLOCATOR,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_QUALITY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_QUALITY,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSQUALITY_MANAGER),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_DEGRADATION(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_DEGRADATION,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        0,\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_MASTERCLOCK(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_MASTERCLOCK,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_TIMEFORMAT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_TIMEFORMAT,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONTIME(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PRESENTATIONTIME,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSTIME),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PRESENTATIONEXTENT(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PRESENTATIONEXTENT,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_FRAMETIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_FRAMETIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSFRAMETIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_RATECAPABILITY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_RATECAPABILITY,\
        (Handler),\
        sizeof(KSRATE_CAPABILITY),\
        sizeof(KSRATE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_RATE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_RATE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(KSRATE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_STREAM_PIPE_ID(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_STREAM_PIPE_ID,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(HANDLE),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)

typedef struct {
    HANDLE      QualityManager;
    PVOID       Context;
} KSQUALITY_MANAGER, *PKSQUALITY_MANAGER;

typedef struct {
    LONGLONG    Duration;
    ULONG       FrameFlags;
    ULONG       Reserved;
} KSFRAMETIME, *PKSFRAMETIME;

#define KSFRAMETIME_VARIABLESIZE    0x00000001

typedef struct {
    LONGLONG        PresentationStart;
    LONGLONG        Duration;
    KSPIN_INTERFACE Interface;
    LONG            Rate;
    ULONG           Flags;
} KSRATE, *PKSRATE;

#define KSRATE_NOPRESENTATIONSTART      0x00000001
#define KSRATE_NOPRESENTATIONDURATION   0x00000002

typedef struct {
    KSPROPERTY      Property;
    KSRATE          Rate;
} KSRATE_CAPABILITY, *PKSRATE_CAPABILITY;

#define STATIC_KSPROPSETID_Clock \
    0xDF12A4C0L, 0xAC17, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DF12A4C0-AC17-11CF-A5D6-28DB04C10000", KSPROPSETID_Clock);
#define KSPROPSETID_Clock DEFINE_GUIDNAMED(KSPROPSETID_Clock)

//
// Performs a x*y/z operation on 64 bit quantities by splitting the operation. The equation
// is simplified with respect to adding in the remainder for the upper 32 bits.
//
// (xh * 10000000 / Frequency) * 2^32 + ((((xh * 10000000) % Frequency) * 2^32 + (xl * 10000000)) / Frequency)
//
#define NANOSECONDS 10000000
#define KSCONVERT_PERFORMANCE_TIME(Frequency, PerformanceTime) \
    ((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS / (Frequency)) << 32) + \
    ((((((ULONGLONG)(ULONG)(PerformanceTime).HighPart * NANOSECONDS) % (Frequency)) << 32) + \
    ((ULONGLONG)(PerformanceTime).LowPart * NANOSECONDS)) / (Frequency)))

typedef struct {
    ULONG       CreateFlags;
} KSCLOCK_CREATE, *PKSCLOCK_CREATE;

typedef struct {
    LONGLONG    Time;
    LONGLONG    SystemTime;
} KSCORRELATED_TIME, *PKSCORRELATED_TIME;

typedef struct {
    LONGLONG    Granularity;
    LONGLONG    Error;
} KSRESOLUTION, *PKSRESOLUTION;

typedef enum {
    KSPROPERTY_CLOCK_TIME,
    KSPROPERTY_CLOCK_PHYSICALTIME,
    KSPROPERTY_CLOCK_CORRELATEDTIME,
    KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,
    KSPROPERTY_CLOCK_RESOLUTION,
    KSPROPERTY_CLOCK_STATE,
#if defined(_NTDDK_)
    KSPROPERTY_CLOCK_FUNCTIONTABLE
#endif // defined(_NTDDK_)
} KSPROPERTY_CLOCK;

#if defined(_NTDDK_)

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
LONGLONG
(FASTCALL *PFNKSCLOCK_GETTIME)(
    __in PFILE_OBJECT FileObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
LONGLONG
(FASTCALL *PFNKSCLOCK_CORRELATEDTIME)(
    __in PFILE_OBJECT FileObject,
    __out PLONGLONG SystemTime);

typedef struct {
    PFNKSCLOCK_GETTIME GetTime;
    PFNKSCLOCK_GETTIME GetPhysicalTime;
    PFNKSCLOCK_CORRELATEDTIME GetCorrelatedTime;
    PFNKSCLOCK_CORRELATEDTIME GetCorrelatedPhysicalTime;
} KSCLOCK_FUNCTIONTABLE, *PKSCLOCK_FUNCTIONTABLE;

#if (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSSETTIMER)(
    __in PVOID Context,
    __in PKTIMER Timer,
    __in LARGE_INTEGER DueTime,
    __in PKDPC Dpc
    );

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSCANCELTIMER)(
    __in PVOID Context,
    __in PKTIMER Timer
    );

typedef
LONGLONG
(FASTCALL *PFNKSCORRELATEDTIME)(
    __in PVOID Context,
    __out  PLONGLONG SystemTime);

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

typedef PVOID   PKSDEFAULTCLOCK;

#define DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_TIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_PHYSICALTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(LONGLONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_CORRELATEDTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCORRELATED_TIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_CORRELATEDPHYSICALTIME,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCORRELATED_TIME),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_RESOLUTION,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSRESOLUTION),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_STATE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSSTATE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CLOCK_FUNCTIONTABLE,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(KSCLOCK_FUNCTIONTABLE),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_CLOCKSET(ClockSet,\
    PropTime, PropPhysicalTime,\
    PropCorrelatedTime, PropCorrelatedPhysicalTime,\
    PropResolution, PropState, PropFunctionTable)\
DEFINE_KSPROPERTY_TABLE(ClockSet) {\
    DEFINE_KSPROPERTY_ITEM_CLOCK_TIME(PropTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_PHYSICALTIME(PropPhysicalTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDTIME(PropCorrelatedTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_CORRELATEDPHYSICALTIME(PropCorrelatedPhysicalTime),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_RESOLUTION(PropResolution),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_STATE(PropState),\
    DEFINE_KSPROPERTY_ITEM_CLOCK_FUNCTIONTABLE(PropFunctionTable)\
}

#endif // defined(_NTDDK_)

#define STATIC_KSEVENTSETID_Clock \
    0x364D8E20L, 0x62C7, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("364D8E20-62C7-11CF-A5D6-28DB04C10000", KSEVENTSETID_Clock);
#define KSEVENTSETID_Clock DEFINE_GUIDNAMED(KSEVENTSETID_Clock)

typedef enum {
    KSEVENT_CLOCK_INTERVAL_MARK,
    KSEVENT_CLOCK_POSITION_MARK
} KSEVENT_CLOCK_POSITION;

#define STATIC_KSEVENTSETID_Connection\
    0x7f4bcbe0L, 0x9ea5, 0x11cf, 0xa5, 0xd6, 0x28, 0xdb, 0x04, 0xc1, 0x00, 0x00
DEFINE_GUIDSTRUCT("7f4bcbe0-9ea5-11cf-a5d6-28db04c10000", KSEVENTSETID_Connection);
#define KSEVENTSETID_Connection DEFINE_GUIDNAMED(KSEVENTSETID_Connection)

typedef enum {
    KSEVENT_CONNECTION_POSITIONUPDATE,
    KSEVENT_CONNECTION_DATADISCONTINUITY,
    KSEVENT_CONNECTION_TIMEDISCONTINUITY,
    KSEVENT_CONNECTION_PRIORITY,
    KSEVENT_CONNECTION_ENDOFSTREAM
} KSEVENT_CONNECTION;

typedef struct {
    PVOID       Context;
    ULONG       Proportion;
    LONGLONG    DeltaTime;
} KSQUALITY, *PKSQUALITY;

typedef struct {
    PVOID       Context;
    ULONG       Status;
} KSERROR, *PKSERROR;

typedef KSIDENTIFIER KSDEGRADE, *PKSDEGRADE;

#define STATIC_KSDEGRADESETID_Standard\
    0x9F564180L, 0x704C, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("9F564180-704C-11D0-A5D6-28DB04C10000", KSDEGRADESETID_Standard);
#define KSDEGRADESETID_Standard DEFINE_GUIDNAMED(KSDEGRADESETID_Standard)

typedef enum {
    KSDEGRADE_STANDARD_SAMPLE,
    KSDEGRADE_STANDARD_QUALITY,
    KSDEGRADE_STANDARD_COMPUTATION,
    KSDEGRADE_STANDARD_SKIP
} KSDEGRADE_STANDARD;

#if defined(_NTDDK_)

#define KSPROBE_STREAMREAD      0x00000000
#define KSPROBE_STREAMWRITE     0x00000001
#define KSPROBE_ALLOCATEMDL     0x00000010
#define KSPROBE_PROBEANDLOCK    0x00000020
#define KSPROBE_SYSTEMADDRESS   0x00000040
#define KSPROBE_MODIFY          0x00000200
#define KSPROBE_STREAMWRITEMODIFY (KSPROBE_MODIFY | KSPROBE_STREAMWRITE)
#define KSPROBE_ALLOWFORMATCHANGE   0x00000080

#define KSSTREAM_READ           KSPROBE_STREAMREAD
#define KSSTREAM_WRITE          KSPROBE_STREAMWRITE
#define KSSTREAM_PAGED_DATA     0x00000000
#define KSSTREAM_NONPAGED_DATA  0x00000100
#define KSSTREAM_SYNCHRONOUS    0x00001000
#define KSSTREAM_FAILUREEXCEPTION 0x00002000

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSCONTEXT_DISPATCH)(
    __in PVOID Context,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSHANDLER)(
    __in PIRP Irp,
    __in PKSIDENTIFIER Request,
    __inout PVOID Data
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
BOOLEAN
(*PFNKSFASTHANDLER)(
    __in PFILE_OBJECT FileObject,
    __in_bcount(RequestLength) PKSIDENTIFIER Request,
    __in ULONG RequestLength,
    __inout_bcount(DataLength) PVOID Data,
    __in ULONG DataLength,
    __out PIO_STATUS_BLOCK IoStatus
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSALLOCATOR)(
    __in PIRP Irp,
    __in ULONG BufferSize,
    __in BOOLEAN InputOperation
    );

typedef struct {
    KSPROPERTY_MEMBERSHEADER    MembersHeader;
    const VOID*                 Members;
} KSPROPERTY_MEMBERSLIST, *PKSPROPERTY_MEMBERSLIST;

typedef struct {
    KSIDENTIFIER                    PropTypeSet;
    ULONG                           MembersListCount;
    __field_ecount(MembersListCount)
    const KSPROPERTY_MEMBERSLIST*   MembersList;
} KSPROPERTY_VALUES, *PKSPROPERTY_VALUES;

#define DEFINE_KSPROPERTY_TABLE(tablename)\
    const KSPROPERTY_ITEM tablename[] =

#define DEFINE_KSPROPERTY_ITEM(PropertyId, GetHandler,\
                               MinProperty,\
                               MinData,\
                               SetHandler,\
                               Values, RelationsCount, Relations, SupportHandler,\
                               SerializedSize)\
{\
    PropertyId, (PFNKSHANDLER)GetHandler, MinProperty, MinData,\
    (PFNKSHANDLER)SetHandler,\
    (PKSPROPERTY_VALUES)Values, RelationsCount, (PKSPROPERTY)Relations,\
    (PFNKSHANDLER)SupportHandler, (ULONG)SerializedSize\
}

typedef struct {
    ULONG                   PropertyId;
    union {
        PFNKSHANDLER            GetPropertyHandler;
        BOOLEAN                 GetSupported;
    };
    ULONG                   MinProperty;
    ULONG                   MinData;
    union {
        PFNKSHANDLER            SetPropertyHandler;
        BOOLEAN                 SetSupported;
    };
    const KSPROPERTY_VALUES*Values;
    ULONG                   RelationsCount;
    __field_ecount(RelationsCount)
    const KSPROPERTY*       Relations;
    PFNKSHANDLER            SupportHandler;
    ULONG                   SerializedSize;
} KSPROPERTY_ITEM, *PKSPROPERTY_ITEM;

#define DEFINE_KSFASTPROPERTY_ITEM(PropertyId, GetHandler, SetHandler)\
{\
    PropertyId, (PFNKSFASTHANDLER)GetHandler, (PFNKSFASTHANDLER)SetHandler, 0\
}

typedef struct {
    ULONG                       PropertyId;
    union {
        PFNKSFASTHANDLER            GetPropertyHandler;
        BOOLEAN                     GetSupported;
    };
    union {
        PFNKSFASTHANDLER            SetPropertyHandler;
        BOOLEAN                     SetSupported;
    };
    ULONG                       Reserved;
} KSFASTPROPERTY_ITEM, *PKSFASTPROPERTY_ITEM;

#define DEFINE_KSPROPERTY_SET(Set,\
                              PropertiesCount,\
                              PropertyItem,\
                              FastIoCount,\
                              FastIoTable)\
{\
    Set,\
    PropertiesCount,\
    PropertyItem,\
    FastIoCount,\
    FastIoTable\
}

#define DEFINE_KSPROPERTY_SET_TABLE(tablename)\
    const KSPROPERTY_SET tablename[] =

typedef struct {
    const GUID*                 Set;
    ULONG                       PropertiesCount;
    __field_ecount(PropertiesCount)
    const KSPROPERTY_ITEM*      PropertyItem;
    ULONG                       FastIoCount;
    const KSFASTPROPERTY_ITEM*  FastIoTable;
} KSPROPERTY_SET, *PKSPROPERTY_SET;

#define DEFINE_KSMETHOD_TABLE(tablename)\
    const KSMETHOD_ITEM tablename[] =

#define DEFINE_KSMETHOD_ITEM(MethodId, Flags,\
                             MethodHandler,\
                             MinMethod, MinData, SupportHandler)\
{\
    MethodId, (PFNKSHANDLER)MethodHandler, MinMethod, MinData,\
    SupportHandler, Flags\
}

typedef struct {
    ULONG                   MethodId;
    union {
        PFNKSHANDLER            MethodHandler;
        BOOLEAN                 MethodSupported;
    };
    ULONG                   MinMethod;
    ULONG                   MinData;
    PFNKSHANDLER            SupportHandler;
    ULONG                   Flags;
} KSMETHOD_ITEM, *PKSMETHOD_ITEM;

#define DEFINE_KSFASTMETHOD_ITEM(MethodId, MethodHandler)\
{\
    MethodId, (PFNKSFASTHANDLER)MethodHandler\
}

typedef struct {
    ULONG                   MethodId;
    union {
        PFNKSFASTHANDLER        MethodHandler;
        BOOLEAN                 MethodSupported;
    };
} KSFASTMETHOD_ITEM, *PKSFASTMETHOD_ITEM;

#define DEFINE_KSMETHOD_SET(Set,\
                            MethodsCount,\
                            MethodItem,\
                            FastIoCount,\
                            FastIoTable)\
{\
    Set,\
    MethodsCount,\
    MethodItem,\
    FastIoCount,\
    FastIoTable\
}

#define DEFINE_KSMETHOD_SET_TABLE(tablename)\
    const KSMETHOD_SET tablename[] =

typedef struct {
    const GUID*             Set;
    ULONG                   MethodsCount;
    __field_ecount(MethodsCount)
    const KSMETHOD_ITEM*    MethodItem;
    ULONG                   FastIoCount;
    __field_ecount(FastIoCount) const KSFASTMETHOD_ITEM*FastIoTable;
} KSMETHOD_SET, *PKSMETHOD_SET;

typedef struct _KSEVENT_ENTRY
KSEVENT_ENTRY, *PKSEVENT_ENTRY;

typedef
NTSTATUS
(*PFNKSADDEVENT)(
    __in PIRP Irp,
    __in PKSEVENTDATA EventData,
    __in struct _KSEVENT_ENTRY* EventEntry
    );

typedef
VOID
(*PFNKSREMOVEEVENT)(
    __in PFILE_OBJECT FileObject,
    __in struct _KSEVENT_ENTRY* EventEntry
    );
    
#define DEFINE_KSEVENT_TABLE(tablename)\
    const KSEVENT_ITEM tablename[] =

#define DEFINE_KSEVENT_ITEM(EventId, DataInput, ExtraEntryData,\
                            AddHandler, RemoveHandler, SupportHandler)\
{\
    EventId,\
    DataInput,\
    ExtraEntryData,\
    AddHandler,\
    RemoveHandler,\
    SupportHandler\
}

typedef struct {
    ULONG               EventId;
    ULONG               DataInput;
    ULONG               ExtraEntryData;
    PFNKSADDEVENT       AddHandler;
    PFNKSREMOVEEVENT    RemoveHandler;
    PFNKSHANDLER        SupportHandler;
} KSEVENT_ITEM, *PKSEVENT_ITEM;

#define DEFINE_KSEVENT_SET(Set,\
                           EventsCount,\
                           EventItem)\
{\
    Set, EventsCount, EventItem\
}

#define DEFINE_KSEVENT_SET_TABLE(tablename)\
    const KSEVENT_SET tablename[] =

typedef struct {
    const GUID*         Set;
    ULONG               EventsCount;
    __field_ecount(EventsCount) const KSEVENT_ITEM* EventItem;
} KSEVENT_SET, *PKSEVENT_SET;

typedef struct {
    KDPC            Dpc;
    ULONG           ReferenceCount;
    KSPIN_LOCK      AccessLock;
} KSDPC_ITEM, *PKSDPC_ITEM;

typedef struct {
    KSDPC_ITEM          DpcItem;
    LIST_ENTRY          BufferList;
} KSBUFFER_ITEM, *PKSBUFFER_ITEM;

#define KSEVENT_ENTRY_DELETED   1
#define KSEVENT_ENTRY_ONESHOT   2
#define KSEVENT_ENTRY_BUFFERED  4

struct _KSEVENT_ENTRY {
    LIST_ENTRY      ListEntry;
    PVOID           Object;
    union {
        PKSDPC_ITEM         DpcItem;
        PKSBUFFER_ITEM      BufferItem;
    };
    PKSEVENTDATA        EventData;
    ULONG               NotificationType;
    const KSEVENT_SET*  EventSet;
    const KSEVENT_ITEM* EventItem;
    PFILE_OBJECT        FileObject;
    ULONG               SemaphoreAdjustment;
    ULONG               Reserved;
    ULONG               Flags;
};

typedef enum {
    KSEVENTS_NONE,
    KSEVENTS_SPINLOCK,
    KSEVENTS_MUTEX,
    KSEVENTS_FMUTEX,
    KSEVENTS_FMUTEXUNSAFE,
    KSEVENTS_INTERRUPT,
    KSEVENTS_ERESOURCE
} KSEVENTS_LOCKTYPE;

#define KSDISPATCH_FASTIO       0x80000000

typedef struct {
    PDRIVER_DISPATCH        Create;
    PVOID                   Context;
    UNICODE_STRING          ObjectClass;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
    ULONG                   Flags;
} KSOBJECT_CREATE_ITEM, *PKSOBJECT_CREATE_ITEM;

typedef
VOID
(*PFNKSITEMFREECALLBACK)(
    __in PKSOBJECT_CREATE_ITEM CreateItem
    );

#define KSCREATE_ITEM_SECURITYCHANGED       0x00000001
#define KSCREATE_ITEM_WILDCARD              0x00000002
#define KSCREATE_ITEM_NOPARAMETERS          0x00000004
#define KSCREATE_ITEM_FREEONSTOP            0x00000008

#define DEFINE_KSCREATE_DISPATCH_TABLE( tablename )\
    KSOBJECT_CREATE_ITEM tablename[] =

#define DEFINE_KSCREATE_ITEM(DispatchCreate, TypeName, Context)\
{\
    (DispatchCreate),\
    (PVOID)(Context),\
    {\
        sizeof(TypeName) - sizeof(UNICODE_NULL),\
        sizeof(TypeName),\
        (PWCHAR)(TypeName)\
    },\
    NULL, 0\
}

#define DEFINE_KSCREATE_ITEMEX(DispatchCreate, TypeName, Context, Flags)\
{\
    (DispatchCreate),\
    (PVOID)(Context),\
    {\
        sizeof(TypeName) - sizeof(UNICODE_NULL),\
        sizeof(TypeName),\
        (PWCHAR)(TypeName)\
    },\
    NULL, (Flags)\
}

#define DEFINE_KSCREATE_ITEMNULL( DispatchCreate, Context )\
{\
    DispatchCreate,\
    Context,\
    {\
        0,\
        0,\
        NULL,\
    },\
    NULL, 0\
}

typedef struct {
    ULONG                    CreateItemsCount;
    __field_ecount(CreateItemsCount) PKSOBJECT_CREATE_ITEM    CreateItemsList;
} KSOBJECT_CREATE, *PKSOBJECT_CREATE;

typedef struct {
    PDRIVER_DISPATCH        DeviceIoControl;
    PDRIVER_DISPATCH        Read;
    PDRIVER_DISPATCH        Write;
    PDRIVER_DISPATCH        Flush;
    PDRIVER_DISPATCH        Close;
    PDRIVER_DISPATCH        QuerySecurity;
    PDRIVER_DISPATCH        SetSecurity;
    PFAST_IO_DEVICE_CONTROL FastDeviceIoControl;
    PFAST_IO_READ           FastRead;
    PFAST_IO_WRITE          FastWrite;
} KSDISPATCH_TABLE, *PKSDISPATCH_TABLE;

#define DEFINE_KSDISPATCH_TABLE( tablename, DeviceIoControl, Read, Write,\
                                 Flush, Close, QuerySecurity, SetSecurity,\
                                 FastDeviceIoControl, FastRead, FastWrite  )\
    const KSDISPATCH_TABLE tablename = \
    {\
        DeviceIoControl,        \
        Read,                   \
        Write,                  \
        Flush,                  \
        Close,                  \
        QuerySecurity,          \
        SetSecurity,            \
        FastDeviceIoControl,    \
        FastRead,               \
        FastWrite,              \
    }

#define KSCREATE_ITEM_IRP_STORAGE(Irp)      (*(PKSOBJECT_CREATE_ITEM*)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSEVENT_SET_IRP_STORAGE(Irp)        (*(const KSEVENT_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSEVENT_ITEM_IRP_STORAGE(Irp)       (*(const KSEVENT_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSEVENT_ENTRY_IRP_STORAGE(Irp)      (*(PKSEVENT_ENTRY*)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSMETHOD_SET_IRP_STORAGE(Irp)       (*(const KSMETHOD_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSMETHOD_ITEM_IRP_STORAGE(Irp)      (*(const KSMETHOD_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSMETHOD_TYPE_IRP_STORAGE(Irp)      (*(ULONG_PTR*)(&(Irp)->Tail.Overlay.DriverContext[2]))
#define KSQUEUE_SPINLOCK_IRP_STORAGE(Irp)   (*(PKSPIN_LOCK*)&(Irp)->Tail.Overlay.DriverContext[1])
#define KSPROPERTY_SET_IRP_STORAGE(Irp)     (*(const KSPROPERTY_SET**)&(Irp)->Tail.Overlay.DriverContext[0])
#define KSPROPERTY_ITEM_IRP_STORAGE(Irp)    (*(const KSPROPERTY_ITEM**)&(Irp)->Tail.Overlay.DriverContext[3])
#define KSPROPERTY_ATTRIBUTES_IRP_STORAGE(Irp) (*(PKSATTRIBUTE_LIST*)&(Irp)->Tail.Overlay.DriverContext[2])

typedef PVOID   KSDEVICE_HEADER, KSOBJECT_HEADER;

typedef enum {
    KsInvokeOnSuccess = 1,
    KsInvokeOnError = 2,
    KsInvokeOnCancel = 4
} KSCOMPLETION_INVOCATION;

typedef enum {
    KsListEntryTail,
    KsListEntryHead
} KSLIST_ENTRY_LOCATION;

typedef enum {
    KsAcquireOnly,
    KsAcquireAndRemove,
    KsAcquireOnlySingleItem,
    KsAcquireAndRemoveOnlySingleItem
} KSIRP_REMOVAL_OPERATION;

typedef enum {
    KsStackCopyToNewLocation,
    KsStackReuseCurrentLocation,
    KsStackUseNewLocation
} KSSTACK_USE;

typedef enum {
    KSTARGET_STATE_DISABLED,
    KSTARGET_STATE_ENABLED
} KSTARGET_STATE;

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
NTSTATUS
(*PFNKSIRPLISTCALLBACK)(
    __in PIRP Irp,
    __in PVOID Context
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef 
VOID 
(*PFNREFERENCEDEVICEOBJECT)( 
    __in PVOID Context
    );
    
__drv_maxIRQL(PASSIVE_LEVEL)
typedef 
VOID 
(*PFNDEREFERENCEDEVICEOBJECT)( 
    __in PVOID Context
    );
    
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNQUERYREFERENCESTRING)( 
    __in PVOID Context,
    __inout PWCHAR *String
    );

#define BUS_INTERFACE_REFERENCE_VERSION    0x100
    
typedef struct {
    //
    // Standard interface header
    //
    
    INTERFACE                   Interface;
    
    //
    // Standard bus interfaces
    //
    
    PFNREFERENCEDEVICEOBJECT    ReferenceDeviceObject;
    PFNDEREFERENCEDEVICEOBJECT  DereferenceDeviceObject;
    PFNQUERYREFERENCESTRING     QueryReferenceString;
    
} BUS_INTERFACE_REFERENCE, *PBUS_INTERFACE_REFERENCE;

#define STATIC_REFERENCE_BUS_INTERFACE STATIC_KSMEDIUMSETID_Standard
#define REFERENCE_BUS_INTERFACE KSMEDIUMSETID_Standard

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNQUERYMEDIUMSLIST)( 
    __in PVOID Context,
    __out ULONG* MediumsCount,
    __out_ecount(MediumsCount) PKSPIN_MEDIUM* MediumList
    );

typedef struct {
    //
    // Standard interface header
    //
    
    INTERFACE                   Interface;
    
    //
    // Interface definition
    //
    
    PFNQUERYMEDIUMSLIST         QueryMediumsList;
    
} BUS_INTERFACE_MEDIUMS, *PBUS_INTERFACE_MEDIUMS;

#define STATIC_GUID_BUS_INTERFACE_MEDIUMS \
    0x4EC35C3EL, 0x201B, 0x11D2, 0x87, 0x45, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4EC35C3E-201B-11D2-8745-00A0C9223196", GUID_BUS_INTERFACE_MEDIUMS);
#define GUID_BUS_INTERFACE_MEDIUMS DEFINE_GUIDNAMED(GUID_BUS_INTERFACE_MEDIUMS)

#endif // defined(_NTDDK_)

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif

typedef struct {
    GUID            PropertySet;
    ULONG           Count;
} KSPROPERTY_SERIALHDR, *PKSPROPERTY_SERIALHDR;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

typedef struct {
    KSIDENTIFIER    PropTypeSet;
    ULONG           Id;
    ULONG           PropertyLength;
} KSPROPERTY_SERIAL, *PKSPROPERTY_SERIAL;

#if (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(_NTDDK_)

#define IOCTL_KS_HANDSHAKE             CTL_CODE(FILE_DEVICE_KS, 0x007, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct {
    GUID ProtocolId;
    PVOID Argument1;
    PVOID Argument2;
} KSHANDSHAKE, *PKSHANDSHAKE;

typedef struct _KSGATE
KSGATE, *PKSGATE;

struct _KSGATE {
    LONG Count;
    PKSGATE NextGate;
};

#ifndef _NTOS_

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateTurnInputOn(
    __in_opt PKSGATE Gate
    )
{
    while (Gate && (InterlockedIncrement(&Gate->Count) == 1)) {
        Gate = Gate->NextGate;
    }
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateTurnInputOff(
    __in_opt PKSGATE Gate
    )
{
    while (Gate && (InterlockedDecrement(&Gate->Count) == 0)) {
        Gate = Gate->NextGate;
    }
}

__drv_maxIRQL(HIGH_LEVEL)
BOOLEAN __inline
KsGateGetStateUnsafe(
    __in PKSGATE Gate
    )
{
    ASSERT(Gate);
    return((BOOLEAN)(Gate->Count > 0));
}

__drv_maxIRQL(HIGH_LEVEL)
BOOLEAN __inline
KsGateCaptureThreshold(
    __in PKSGATE Gate
    )
{
    BOOLEAN captured;

    ASSERT(Gate);

    captured = (BOOLEAN)(InterlockedCompareExchange(&Gate->Count,0,1) == 1);
    
    //
    // If we made a transition, it must be propagated.
    //
    if (captured) {
        KsGateTurnInputOff(Gate->NextGate);
    }

    //
    // We return whatever the state was prior to the compare/exchange.  If
    // the state was on, the state is now off.
    //
    return captured;
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateInitialize(
    __in PKSGATE Gate,
    __in LONG InitialCount,
    __in_opt PKSGATE NextGate,
    __in BOOLEAN StateToPropagate // __in BOOLEAN NextGateIsAnOrGate
    )
{
    ASSERT(Gate);
    Gate->Count = InitialCount;
    Gate->NextGate = NextGate;

    if (NextGate) {
        if (InitialCount > 0) {
            if (StateToPropagate) {
                KsGateTurnInputOn(NextGate);
            }
        } else {
            if (! StateToPropagate) {
                KsGateTurnInputOff(NextGate);
            }
        }
    }
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateInitializeAnd(
    __in PKSGATE AndGate,
    __in_opt PKSGATE NextOrGate
    )
{
    KsGateInitialize(AndGate,1,NextOrGate,TRUE);
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateInitializeOr(
    __in PKSGATE OrGate,
    __in_opt PKSGATE NextAndGate
    )
{
    KsGateInitialize(OrGate,0,NextAndGate,FALSE);
}

__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateAddOnInputToAnd(__in PKSGATE AndGate) { UNREFERENCED_PARAMETER (AndGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateAddOffInputToAnd(__in PKSGATE AndGate) { KsGateTurnInputOff(AndGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateRemoveOnInputFromAnd(__in PKSGATE AndGate) { UNREFERENCED_PARAMETER (AndGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateRemoveOffInputFromAnd(__in PKSGATE AndGate) { KsGateTurnInputOn(AndGate); }

__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateAddOnInputToOr(__in PKSGATE OrGate) { KsGateTurnInputOn(OrGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateAddOffInputToOr(__in PKSGATE OrGate) { UNREFERENCED_PARAMETER (OrGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateRemoveOnInputFromOr(__in PKSGATE OrGate) { KsGateTurnInputOff(OrGate); }
__drv_maxIRQL(HIGH_LEVEL) void __inline KsGateRemoveOffInputFromOr(__in PKSGATE OrGate) { UNREFERENCED_PARAMETER (OrGate); }

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateTerminateAnd(
    __in PKSGATE AndGate
    )
{
    ASSERT(AndGate);
    if (KsGateGetStateUnsafe(AndGate)) {
        KsGateRemoveOnInputFromOr(AndGate->NextGate);
    } else {
        KsGateRemoveOffInputFromOr(AndGate->NextGate);
    }
}

__drv_maxIRQL(HIGH_LEVEL)
void __inline
KsGateTerminateOr(
    __in PKSGATE OrGate
    )
{
    ASSERT(OrGate);
    if (KsGateGetStateUnsafe(OrGate)) {
        KsGateRemoveOnInputFromAnd(OrGate->NextGate);
    } else {
        KsGateRemoveOffInputFromAnd(OrGate->NextGate);
    }
}

#endif // !_NTOS_

typedef PVOID KSOBJECT_BAG;

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSGENERATEEVENTCALLBACK)(
    __in PVOID Context,
    __in PKSEVENT_ENTRY EventEntry
    );

__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICECREATE)(
    __in PKSDEVICE Device
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICEPNPSTART)(
    __in PKSDEVICE Device,
    __in PIRP Irp,
    __in_opt PCM_RESOURCE_LIST TranslatedResourceList,
    __in_opt PCM_RESOURCE_LIST UntranslatedResourceList
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICE)(
    __in PKSDEVICE Device
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICEIRP)(
    __in PKSDEVICE Device,
    __in PIRP Irp
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSDEVICEIRPVOID)(
    __in PKSDEVICE Device,
    __in PIRP Irp
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICEQUERYCAPABILITIES)(
    __in PKSDEVICE Device,
    __in PIRP Irp,
    __inout PDEVICE_CAPABILITIES Capabilities
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSDEVICEQUERYPOWER)(
    __in PKSDEVICE Device,
    __in PIRP Irp,
    __in DEVICE_POWER_STATE DeviceTo,
    __in DEVICE_POWER_STATE DeviceFrom,
    __in SYSTEM_POWER_STATE SystemTo,
    __in SYSTEM_POWER_STATE SystemFrom,
    __in POWER_ACTION Action
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSDEVICESETPOWER)(
    __in PKSDEVICE Device,
    __in PIRP Irp,
    __in DEVICE_POWER_STATE To,
    __in DEVICE_POWER_STATE From
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSFILTERFACTORYVOID)(
    __in PKSFILTERFACTORY FilterFactory
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSFILTERFACTORYPOWER)(
    __in PKSFILTERFACTORY FilterFactory,
    __in DEVICE_POWER_STATE State
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSFILTERIRP)(
    __in PKSFILTER Filter,
    __in PIRP Irp
    );
typedef
NTSTATUS
(*PFNKSFILTERPROCESS)(
    __in PKSFILTER Filter,
    __in PKSPROCESSPIN_INDEXENTRY Index
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSFILTERVOID)(
    __in PKSFILTER Filter
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSFILTERPOWER)(
    __in PKSFILTER Filter,
    __in DEVICE_POWER_STATE State
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPINIRP)(
    __in PKSPIN Pin,
    __in PIRP Irp
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPINSETDEVICESTATE)(
    __in PKSPIN Pin,
    __in KSSTATE ToState,
    __in KSSTATE FromState
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPINSETDATAFORMAT)(
    __in PKSPIN Pin,
    __in_opt PKSDATAFORMAT OldFormat,
    __in_opt PKSMULTIPLE_ITEM OldAttributeList,
    __in const KSDATARANGE* DataRange,
    __in_opt const KSATTRIBUTE_LIST* AttributeRange
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPINHANDSHAKE)(
    __in PKSPIN Pin,
    __in PKSHANDSHAKE In,
    __in PKSHANDSHAKE Out
    );
typedef
NTSTATUS
(*PFNKSPIN)(
    __in PKSPIN Pin
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSPINVOID)(
    __in PKSPIN Pin
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
void
(*PFNKSPINPOWER)(
    __in PKSPIN Pin,
    __in DEVICE_POWER_STATE State
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSPINSETTIMER)(
    __in PKSPIN Pin,
    __in PKTIMER Timer,
    __in LARGE_INTEGER DueTime,
    __in PKDPC Dpc
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
BOOLEAN
(*PFNKSPINCANCELTIMER)(
    __in PKSPIN Pin,
    __in PKTIMER Timer
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
LONGLONG
(FASTCALL *PFNKSPINCORRELATEDTIME)(
    __in PKSPIN Pin,
    __out PLONGLONG SystemTime
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
void
(*PFNKSPINRESOLUTION)(
    __in PKSPIN Pin,
    __out PKSRESOLUTION Resolution
    );
__drv_maxIRQL(PASSIVE_LEVEL)
typedef
NTSTATUS
(*PFNKSPININITIALIZEALLOCATOR)(
    __in PKSPIN Pin,
    __in PKSALLOCATOR_FRAMING AllocatorFraming,
    __out PVOID* Context
    );
__drv_maxIRQL(DISPATCH_LEVEL)
typedef
void
(*PFNKSSTREAMPOINTER)(
    __in PKSSTREAM_POINTER StreamPointer
    );

typedef struct KSAUTOMATION_TABLE_ 
KSAUTOMATION_TABLE, *PKSAUTOMATION_TABLE;
struct KSAUTOMATION_TABLE_ {
    ULONG PropertySetsCount;
    ULONG PropertyItemSize;
    __field_bcount(PropertySetsCount * PropertyItemSize) const KSPROPERTY_SET* PropertySets;
    ULONG MethodSetsCount;
    ULONG MethodItemSize;
    __field_bcount(MethodSetsCount * MethodItemSize) const KSMETHOD_SET* MethodSets;
    ULONG EventSetsCount;
    ULONG EventItemSize;
    __field_bcount(EventSetsCount * EventItemSize) const KSEVENT_SET* EventSets;
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
};

#define DEFINE_KSAUTOMATION_TABLE(table)\
    const KSAUTOMATION_TABLE table =

#define DEFINE_KSAUTOMATION_PROPERTIES(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSPROPERTY_ITEM),\
    table

#define DEFINE_KSAUTOMATION_METHODS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSMETHOD_ITEM),\
    table

#define DEFINE_KSAUTOMATION_EVENTS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(KSEVENT_ITEM),\
    table

#define DEFINE_KSAUTOMATION_PROPERTIES_NULL\
    0,\
    sizeof(KSPROPERTY_ITEM),\
    NULL

#define DEFINE_KSAUTOMATION_METHODS_NULL\
    0,\
    sizeof(KSMETHOD_ITEM),\
    NULL

#define DEFINE_KSAUTOMATION_EVENTS_NULL\
    0,\
    sizeof(KSEVENT_ITEM),\
    NULL

#define MIN_DEV_VER_FOR_QI (0x100)

struct _KSDEVICE_DISPATCH {
    PFNKSDEVICECREATE Add;
    PFNKSDEVICEPNPSTART Start;
    PFNKSDEVICE PostStart;
    PFNKSDEVICEIRP QueryStop;
    PFNKSDEVICEIRPVOID CancelStop;
    PFNKSDEVICEIRPVOID Stop;
    PFNKSDEVICEIRP QueryRemove;
    PFNKSDEVICEIRPVOID CancelRemove;
    PFNKSDEVICEIRPVOID Remove;
    PFNKSDEVICEQUERYCAPABILITIES QueryCapabilities;
    PFNKSDEVICEIRPVOID SurpriseRemoval;
    PFNKSDEVICEQUERYPOWER QueryPower;
    PFNKSDEVICESETPOWER SetPower;
    PFNKSDEVICEIRP QueryInterface;  // added in version 0x100
};

struct _KSFILTER_DISPATCH {
    PFNKSFILTERIRP Create;
    PFNKSFILTERIRP Close;
    PFNKSFILTERPROCESS Process;
    PFNKSFILTERVOID Reset;
};

struct _KSPIN_DISPATCH {
    PFNKSPINIRP Create;
    PFNKSPINIRP Close;
    PFNKSPIN Process;
    PFNKSPINVOID Reset;
    PFNKSPINSETDATAFORMAT SetDataFormat;
    PFNKSPINSETDEVICESTATE SetDeviceState;
    PFNKSPIN Connect;
    PFNKSPINVOID Disconnect;
    const KSCLOCK_DISPATCH* Clock;
    const KSALLOCATOR_DISPATCH* Allocator;
};

struct _KSCLOCK_DISPATCH {
    PFNKSPINSETTIMER SetTimer;
    PFNKSPINCANCELTIMER CancelTimer;
    PFNKSPINCORRELATEDTIME CorrelatedTime;
    PFNKSPINRESOLUTION Resolution;
};

struct _KSALLOCATOR_DISPATCH {
    PFNKSPININITIALIZEALLOCATOR InitializeAllocator;
    PFNKSDELETEALLOCATOR DeleteAllocator;
    PFNKSDEFAULTALLOCATE Allocate;
    PFNKSDEFAULTFREE Free;
};

//
// VERSION indicates support of the following:
//
//     - QueryInterface dispatch of KSDEVICE_DISPATCH
//
#define KSDEVICE_DESCRIPTOR_VERSION (0x100)

#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// VERSION_2 indicates support of the following:
//
//     - Flags field of KSDEVICE_DESCRIPTOR
//           - Loading a VERSION_2 descriptor on earlier versions of AVStream
//             will work; however, all flags will be considered to be zero.
//           - Using an earlier version descriptor on later versions of
//             AVStream causes no flags to be specificed.
//
#define KSDEVICE_DESCRIPTOR_VERSION_2 (0x110)

#define MIN_DEV_VER_FOR_FLAGS (0x110)

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

struct _KSDEVICE_DESCRIPTOR {
    const KSDEVICE_DISPATCH* Dispatch;
    ULONG FilterDescriptorsCount;
    __field_ecount(FilterDescriptorsCount) const KSFILTER_DESCRIPTOR*const* FilterDescriptors;
    ULONG Version; // this is 0 for pre-version 100 driver

#if (NTDDI_VERSION >= NTDDI_VISTA)

    ULONG Flags; 
#define KSDEVICE_FLAG_ENABLE_REMOTE_WAKEUP	0x00000001
#define KSDEVICE_FLAG_LOWPOWER_PASSTHROUGH 	0x00000002

#if !defined(_WIN64)
    PVOID Alignment;
#endif //!defined(_WIN64)

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

};

struct _KSFILTER_DESCRIPTOR {
    const KSFILTER_DISPATCH* Dispatch;
    const KSAUTOMATION_TABLE* AutomationTable;
    ULONG Version;
#define KSFILTER_DESCRIPTOR_VERSION ((ULONG)-1)
    ULONG Flags;
#define KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING 0x00000001
#define KSFILTER_FLAG_CRITICAL_PROCESSING 0x00000002
#define KSFILTER_FLAG_HYPERCRITICAL_PROCESSING 0x00000004
#define KSFILTER_FLAG_RECEIVE_ZERO_LENGTH_SAMPLES 0x00000008
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
#define KSFILTER_FLAG_DENY_USERMODE_ACCESS 0x80000000
#endif // (NTDDI_VERSION >= NTDDI_WINXPSP2)
    const GUID* ReferenceGuid;
    ULONG PinDescriptorsCount;
    ULONG PinDescriptorSize;
    __field_bcount(PinDescriptorsCount * PinDescriptorSize) const KSPIN_DESCRIPTOR_EX* PinDescriptors;
    ULONG CategoriesCount;
    __field_ecount(CategoriesCount)
    const GUID* Categories;
    ULONG NodeDescriptorsCount;
    ULONG NodeDescriptorSize;
    __field_bcount(NodeDescriptorsCount * NodeDescriptorSize) const KSNODE_DESCRIPTOR* NodeDescriptors;
    ULONG ConnectionsCount;
    __field_ecount(ConnectionsCount) const KSTOPOLOGY_CONNECTION* Connections;
    const KSCOMPONENTID* ComponentId;
};

#define DEFINE_KSFILTER_DESCRIPTOR(descriptor)\
    const KSFILTER_DESCRIPTOR descriptor =

#define DEFINE_KSFILTER_PIN_DESCRIPTORS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(table[0]),\
    table

#define DEFINE_KSFILTER_CATEGORIES(table)\
    SIZEOF_ARRAY(table),\
    table

#define DEFINE_KSFILTER_CATEGORY(category)\
    1,\
    &(category)

#define DEFINE_KSFILTER_CATEGORIES_NULL\
    0,\
    NULL

#define DEFINE_KSFILTER_NODE_DESCRIPTORS(table)\
    SIZEOF_ARRAY(table),\
    sizeof(table[0]),\
    table

#define DEFINE_KSFILTER_NODE_DESCRIPTORS_NULL\
    0,\
    sizeof(KSNODE_DESCRIPTOR),\
    NULL

#define DEFINE_KSFILTER_CONNECTIONS(table)\
    SIZEOF_ARRAY(table),\
    table

#define DEFINE_KSFILTER_DEFAULT_CONNECTIONS\
    0,\
    NULL

#define DEFINE_KSFILTER_DESCRIPTOR_TABLE(table)\
    const KSFILTER_DESCRIPTOR*const table[] =

struct _KSPIN_DESCRIPTOR_EX {
    const KSPIN_DISPATCH* Dispatch;
    const KSAUTOMATION_TABLE* AutomationTable;
    KSPIN_DESCRIPTOR PinDescriptor;
    ULONG Flags;
#define KSPIN_FLAG_DISPATCH_LEVEL_PROCESSING KSFILTER_FLAG_DISPATCH_LEVEL_PROCESSING
#define KSPIN_FLAG_CRITICAL_PROCESSING KSFILTER_FLAG_CRITICAL_PROCESSING
#define KSPIN_FLAG_HYPERCRITICAL_PROCESSING KSFILTER_FLAG_HYPERCRITICAL_PROCESSING
#define KSPIN_FLAG_ASYNCHRONOUS_PROCESSING 0x00000008
#define KSPIN_FLAG_DO_NOT_INITIATE_PROCESSING 0x00000010
#define KSPIN_FLAG_INITIATE_PROCESSING_ON_EVERY_ARRIVAL 0x00000020
#define KSPIN_FLAG_FRAMES_NOT_REQUIRED_FOR_PROCESSING 0x00000040
#define KSPIN_FLAG_ENFORCE_FIFO 0x00000080

#define KSPIN_FLAG_GENERATE_MAPPINGS 0x00000100
#define KSPIN_FLAG_DISTINCT_TRAILING_EDGE 0x00000200

#define KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY 0x00010000
#define KSPIN_FLAG_SPLITTER 0x00020000
#define KSPIN_FLAG_USE_STANDARD_TRANSPORT 0x00040000
#define KSPIN_FLAG_DO_NOT_USE_STANDARD_TRANSPORT 0x00080000
#define KSPIN_FLAG_FIXED_FORMAT 0x00100000
#define KSPIN_FLAG_GENERATE_EOS_EVENTS 0x00200000
#define KSPIN_FLAG_RENDERER (KSPIN_FLAG_PROCESS_IN_RUN_STATE_ONLY|KSPIN_FLAG_GENERATE_EOS_EVENTS)
#define KSPIN_FLAG_IMPLEMENT_CLOCK 0x00400000
#define KSPIN_FLAG_SOME_FRAMES_REQUIRED_FOR_PROCESSING 0x00800000
#define KSPIN_FLAG_PROCESS_IF_ANY_IN_RUN_STATE 0x01000000
#if (NTDDI_VERSION >= NTDDI_WINXPSP2)
#define KSPIN_FLAG_DENY_USERMODE_ACCESS 0x80000000
#endif // (NTDDI_VERSION >= NTDDI_WINXPSP2)
    ULONG InstancesPossible;
    ULONG InstancesNecessary;
    const KSALLOCATOR_FRAMING_EX* AllocatorFraming;
    PFNKSINTERSECTHANDLEREX IntersectHandler;
};

#define DEFINE_KSPIN_DEFAULT_INTERFACES\
    0,\
    NULL

#define DEFINE_KSPIN_DEFAULT_MEDIUMS\
    0,\
    NULL

struct _KSNODE_DESCRIPTOR {
    const KSAUTOMATION_TABLE* AutomationTable;
    const GUID* Type;
    const GUID* Name;
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
};

#if !defined(_WIN64)
#define DEFINE_NODE_DESCRIPTOR(automation,type,name) \
    { (automation), (type), (name), NULL }
#else // !defined(_WIN64)
#define DEFINE_NODE_DESCRIPTOR(automation,type,name) \
    { (automation), (type), (name) }
#endif // !defined(_WIN64)

struct _KSDEVICE {
    const KSDEVICE_DESCRIPTOR* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT PhysicalDeviceObject;
    PDEVICE_OBJECT NextDeviceObject;
    BOOLEAN Started;
    SYSTEM_POWER_STATE SystemPowerState;
    DEVICE_POWER_STATE DevicePowerState;
};

struct _KSFILTERFACTORY {
    const KSFILTER_DESCRIPTOR* FilterDescriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
};

struct _KSFILTER {
    const KSFILTER_DESCRIPTOR* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
};

struct _KSPIN {
    const KSPIN_DESCRIPTOR_EX* Descriptor;
    KSOBJECT_BAG Bag;
    PVOID Context;
    ULONG Id;
    KSPIN_COMMUNICATION Communication;
    BOOLEAN ConnectionIsExternal;
    KSPIN_INTERFACE ConnectionInterface;
    KSPIN_MEDIUM ConnectionMedium;
    KSPRIORITY ConnectionPriority;
    PKSDATAFORMAT ConnectionFormat;
    PKSMULTIPLE_ITEM AttributeList;
    ULONG StreamHeaderSize;
    KSPIN_DATAFLOW DataFlow;
    KSSTATE DeviceState;
    KSRESET ResetState;
    KSSTATE ClientState;
};

struct _KSMAPPING {
    PHYSICAL_ADDRESS PhysicalAddress;
    ULONG ByteCount;
    ULONG Alignment;
};

struct _KSSTREAM_POINTER_OFFSET
{
#if defined(_NTDDK_)
    union {
        PUCHAR Data;
        PKSMAPPING Mappings;
    };
#else // !defined(_NTDDK_)
    PUCHAR Data;
#endif // !defined(_NTDDK_)
#if !defined(_WIN64)
    PVOID Alignment;
#endif // !defined(_WIN64)
    ULONG Count;
    ULONG Remaining;
};

struct _KSSTREAM_POINTER
{
    PVOID Context;
    PKSPIN Pin;
    PKSSTREAM_HEADER StreamHeader;
    PKSSTREAM_POINTER_OFFSET Offset;
    KSSTREAM_POINTER_OFFSET OffsetIn;
    KSSTREAM_POINTER_OFFSET OffsetOut;
};

struct _KSPROCESSPIN {
    PKSPIN Pin;
    PKSSTREAM_POINTER StreamPointer;
    PKSPROCESSPIN InPlaceCounterpart;
    PKSPROCESSPIN DelegateBranch;
    PKSPROCESSPIN CopySource;
    __field_bcount(BytesAvailable) PVOID Data;
    ULONG BytesAvailable;
    ULONG BytesUsed;
    ULONG Flags;
    BOOLEAN Terminate;
};

struct _KSPROCESSPIN_INDEXENTRY {
    __field_ecount(Count) PKSPROCESSPIN *Pins;
    ULONG Count;
};

typedef enum {
    KsObjectTypeDevice,
    KsObjectTypeFilterFactory,
    KsObjectTypeFilter,
    KsObjectTypePin
} KSOBJECTTYPE;

typedef
void
(*PFNKSFREE)(
    __in PVOID Data
    );

typedef
void
(*PFNKSPINFRAMERETURN)(
    __in PKSPIN Pin,
    __in_bcount_opt(Size) PVOID Data,
    __in ULONG Size OPTIONAL,
    __in_opt PMDL Mdl,
    __in_opt PVOID Context,
    __in NTSTATUS Status
    );

__drv_maxIRQL(DISPATCH_LEVEL)
typedef
void
(*PFNKSPINIRPCOMPLETION)(
    __in PKSPIN Pin,
    __in PIRP Irp
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)
#if !defined(_IKsControl_)
#define _IKsControl_

typedef interface IKsControl* PIKSCONTROL;

#if !defined(DEFINE_ABSTRACT_UNKNOWN)

#define DEFINE_ABSTRACT_UNKNOWN()                               \
    STDMETHOD_(NTSTATUS, QueryInterface)(THIS_                   \
        __in REFIID InterfaceId,                                     \
        __deref_out PVOID* Interface                                        \
        ) PURE;                                                 \
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;                        \
    STDMETHOD_(ULONG,Release)(THIS) PURE;

#endif //!defined(DEFINE_ABSTRACT_UNKNOWN)

#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN() // For C

    STDMETHOD_(NTSTATUS, KsProperty)(THIS_
        __in_bcount(PropertyLength) PKSPROPERTY Property,
        __in ULONG PropertyLength,
        __inout_bcount(DataLength) PVOID PropertyData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
        ) PURE;
    STDMETHOD_(NTSTATUS, KsMethod)(THIS_
        __in_bcount(MethodLength) PKSMETHOD Method,
        __in ULONG MethodLength,
        __inout_bcount(DataLength) PVOID MethodData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
        ) PURE;
    STDMETHOD_(NTSTATUS, KsEvent)(THIS_
        __in_bcount_opt(EventLength) PKSEVENT Event,
        __in ULONG EventLength,
        __inout_bcount(DataLength) PVOID EventData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
        ) PURE;
};

typedef interface IKsReferenceClock* PIKSREFERENCECLOCK;

#undef INTERFACE
#define INTERFACE IKsReferenceClock
DECLARE_INTERFACE_(IKsReferenceClock,IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN() // For C

    STDMETHOD_(LONGLONG,GetTime)(THIS
        ) PURE;
    STDMETHOD_(LONGLONG,GetPhysicalTime)(THIS
        ) PURE;
    STDMETHOD_(LONGLONG,GetCorrelatedTime)(THIS_
        __out PLONGLONG SystemTime
        ) PURE;
    STDMETHOD_(LONGLONG,GetCorrelatedPhysicalTime)(THIS_
        __out PLONGLONG SystemTime
        ) PURE;
    STDMETHOD_(NTSTATUS, GetResolution)(THIS_
        __out PKSRESOLUTION Resolution
        ) PURE;
    STDMETHOD_(NTSTATUS, GetState)(THIS_
        __out PKSSTATE State
        ) PURE;
};
#undef INTERFACE

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

#define INTERFACE IKsDeviceFunctions
DECLARE_INTERFACE_(IKsDeviceFunctions, IUnknown)
{
    DEFINE_ABSTRACT_UNKNOWN() // For C
    
    STDMETHOD_(NTSTATUS, RegisterAdapterObjectEx)(THIS_
        __in PADAPTER_OBJECT AdapterObject,
        __in PDEVICE_DESCRIPTION DeviceDescription,
        __in ULONG NumberOfMapRegisters,
        __in ULONG MaxMappingsByteCount,
        __in ULONG MappingTableStride
        ) PURE;
};

#undef INTERFACE

#endif // (NTDDI_VERSION >= NTDDI_WS03SP1)

#define STATIC_IID_IKsControl \
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUID(IID_IKsControl,
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("28F54685-06FD-11D2-B27A-00A0C9223196")) IKsControl;
#endif

#define STATIC_IID_IKsFastClock \
0xc9902485, 0xc180, 0x11d2, 0x84, 0x73, 0xd4, 0x23, 0x94, 0x45, 0x9e, 0x5e
DEFINE_GUID(IID_IKsFastClock,
0xc9902485, 0xc180, 0x11d2, 0x84, 0x73, 0xd4, 0x23, 0x94, 0x45, 0x9e, 0x5e);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("C9902485-C180-11d2-8473-D42394459E5E")) IKsFastClock;
#endif

#if (NTDDI_VERSION >= NTDDI_WS03SP1)

#define STATIC_IID_IKsDeviceFunctions \
0xe234f2e2, 0xbd69, 0x4f8c, 0xb3, 0xf2, 0x7c, 0xd7, 0x9e, 0xd4, 0x66, 0xbd
DEFINE_GUID(IID_IKsDeviceFunctions,
0xe234f2e2, 0xbd69, 0x4f8c, 0xb3, 0xf2, 0x7c, 0xd7, 0x9e, 0xd4, 0x66, 0xbd);
#if defined(__cplusplus) && _MSC_VER >= 1100
struct __declspec(uuid("E234F2E2-BD69-4F8C-B3F2-7CD79ED466BD")) IKsDeviceFunctions;
#endif

#endif // (NTDDI_VERSION >= NTDDI_WS03SP1)

#endif // !defined(_IKsControl_)
#endif // defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

#endif // defined(_NTDDK_)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//===========================================================================

#if defined(__cplusplus)
extern "C" {
#endif // defined(__cplusplus)

//
// exported prototypes
//

#ifdef _KSDDK_
#define KSDDKAPI
#else // !_KSDDK_
#define KSDDKAPI DECLSPEC_IMPORT
#endif // _KSDDK_

#if defined(_NTDDK_)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsEnableEvent(
    __in PIRP Irp,
    __in ULONG EventSetsCount,
    __in_ecount(EventSetsCount) const KSEVENT_SET* EventSet,
    __inout_opt PLIST_ENTRY EventsList,
    __in_opt KSEVENTS_LOCKTYPE EventsFlags,
    __in_opt PVOID EventsLock
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsEnableEventWithAllocator(
    __in PIRP Irp,
    __in ULONG EventSetsCount,
    __in_ecount(EventSetsCount) const KSEVENT_SET* EventSet,
    __inout_opt PLIST_ENTRY EventsList,
    __in KSEVENTS_LOCKTYPE EventsFlags OPTIONAL,
    __in_opt PVOID EventsLock,
    __in_opt PFNKSALLOCATOR Allocator,
    __in_opt ULONG EventItemSize
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDisableEvent(
    __in PIRP Irp,
    __inout PLIST_ENTRY EventsList,
    __in KSEVENTS_LOCKTYPE EventsFlags,
    __in PVOID EventsLock
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsDiscardEvent(
    __in PKSEVENT_ENTRY EventEntry
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsFreeEventList(
    __in PFILE_OBJECT FileObject,
    __inout PLIST_ENTRY EventsList,
    __in KSEVENTS_LOCKTYPE EventsFlags,
    __in PVOID EventsLock
    );

KSDDKAPI
NTSTATUS
NTAPI
KsGenerateEvent(
    __in PKSEVENT_ENTRY EventEntry
    );

KSDDKAPI
NTSTATUS
NTAPI
KsGenerateDataEvent(
    __in PKSEVENT_ENTRY EventEntry,
    __in ULONG DataSize,
    __in_bcount(DataSize) PVOID Data
    );

KSDDKAPI
VOID
NTAPI
KsGenerateEventList(
    __in_opt GUID* Set,
    __in ULONG EventId,
    __in PLIST_ENTRY EventsList,
    __in KSEVENTS_LOCKTYPE EventsFlags,
    __in PVOID EventsLock
    );

// property.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPropertyHandler(
    __in PIRP Irp,
    __in ULONG PropertySetsCount,
    __in_ecount(PropertySetsCount) const KSPROPERTY_SET* PropertySet
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPropertyHandlerWithAllocator(
    __in PIRP Irp,
    __in ULONG PropertySetsCount,
    __in_ecount(PropertySetsCount) const KSPROPERTY_SET* PropertySet,
    __in_opt PFNKSALLOCATOR Allocator,
    __in ULONG PropertyItemSize OPTIONAL
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsFastPropertyHandler(
    __in PFILE_OBJECT FileObject,
    __in_bcount(PropertyLength) PKSPROPERTY Property,
    __in ULONG PropertyLength,
    __in_bcount(DataLength)PVOID Data,
    __in ULONG DataLength,
    __out PIO_STATUS_BLOCK IoStatus,
    __in ULONG PropertySetsCount,
    __in_ecount(PropertySetsCount) const KSPROPERTY_SET* PropertySet
    );

// method.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMethodHandler(
    __in PIRP Irp,
    __in ULONG MethodSetsCount,
    __in_ecount(MethodSetsCount) const KSMETHOD_SET* MethodSet
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMethodHandlerWithAllocator(
    __in PIRP Irp,
    __in ULONG MethodSetsCount,
    __in_ecount(MethodSetsCount) const KSMETHOD_SET* MethodSet,
    __in_opt PFNKSALLOCATOR Allocator,
    __in ULONG MethodItemSize OPTIONAL
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsFastMethodHandler(
    __in PFILE_OBJECT FileObject,
    __in_bcount(MethodLength) PKSMETHOD Method,
    __in ULONG MethodLength,
    __inout_bcount(DataLength) PVOID Data,
    __in ULONG DataLength,
    __out PIO_STATUS_BLOCK IoStatus,
    __in ULONG MethodSetsCount,
    __in_ecount(MethodSetsCount) const KSMETHOD_SET* MethodSet
    );

// alloc.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultAllocator(
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultAllocatorEx(
    __in PIRP Irp,
    __in_opt PVOID InitializeContext,
    __in_opt PFNKSDEFAULTALLOCATE DefaultAllocate,
    __in_opt PFNKSDEFAULTFREE DefaultFree,
    __in_opt PFNKSINITIALIZEALLOCATOR InitializeAllocator,
    __in_opt PFNKSDELETEALLOCATOR DeleteAllocator
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateAllocator(
    __in HANDLE ConnectionHandle,
    __in PKSALLOCATOR_FRAMING AllocatorFraming,
    __out PHANDLE AllocatorHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateAllocatorCreateRequest(
    __in PIRP Irp,
    __out PKSALLOCATOR_FRAMING* AllocatorFraming
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateAllocatorFramingEx(
    __in PKSALLOCATOR_FRAMING_EX Framing,
    __in ULONG BufferSize,
    __in const KSALLOCATOR_FRAMING_EX *PinFraming
    );

// clock.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDefaultClock(
    __out PKSDEFAULTCLOCK* DefaultClock
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDefaultClockEx(
    __out PKSDEFAULTCLOCK* DefaultClock,
    __in_opt PVOID Context,
    __in_opt PFNKSSETTIMER SetTimer,
    __in_opt PFNKSCANCELTIMER CancelTimer,
    __in_opt PFNKSCORRELATEDTIME CorrelatedTime,
    __in_opt const KSRESOLUTION* Resolution,
    __in ULONG Flags
    );

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsFreeDefaultClock(
    __in PKSDEFAULTCLOCK DefaultClock
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultClock(
    __in PIRP Irp,
    __in PKSDEFAULTCLOCK DefaultClock
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateClock(
    __in HANDLE ConnectionHandle,
    __in PKSCLOCK_CREATE ClockCreate,
    __out PHANDLE ClockHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateClockCreateRequest(
    __in PIRP Irp,
    __deref_out PKSCLOCK_CREATE* ClockCreate
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
KSSTATE
NTAPI
KsGetDefaultClockState(
    __in PKSDEFAULTCLOCK DefaultClock
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetDefaultClockState(
    __in PKSDEFAULTCLOCK DefaultClock,
    __in KSSTATE State
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
LONGLONG
NTAPI
KsGetDefaultClockTime(
    __in PKSDEFAULTCLOCK DefaultClock
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetDefaultClockTime(
    __in PKSDEFAULTCLOCK DefaultClock,
    __in LONGLONG Time
    );

// connect.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreatePin(
    __in HANDLE FilterHandle,
    __in PKSPIN_CONNECT Connect,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE ConnectionHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateConnectRequest(
    __in PIRP Irp,
    __in ULONG DescriptorsCount,
    __in_ecount(DescriptorsCount) const KSPIN_DESCRIPTOR* Descriptor,
    __out PKSPIN_CONNECT* Connect
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinPropertyHandler(
    __in PIRP Irp,
    __in PKSPROPERTY Property,
    __inout PVOID Data,
    __in ULONG DescriptorsCount,
    __in_ecount(DescriptorsCount) const KSPIN_DESCRIPTOR* Descriptor
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinDataIntersection(
    __in PIRP Irp,
    __in PKSP_PIN Pin,
    __out_opt PVOID Data,
    __in ULONG DescriptorsCount,
    __in_ecount(DescriptorsCount) const KSPIN_DESCRIPTOR* Descriptor,
    __in PFNKSINTERSECTHANDLER IntersectHandler
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinDataIntersectionEx(
    __in PIRP Irp,
    __in PKSP_PIN Pin,
    __out PVOID Data,
    __in ULONG DescriptorsCount,
    __in_bcount(DescriptorsCount * DescriptorSize) const KSPIN_DESCRIPTOR* Descriptor,
    __in ULONG DescriptorSize,
    __in_opt PFNKSINTERSECTHANDLEREX IntersectHandler,
    __in_opt PVOID HandlerContext
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsHandleSizedListQuery(
    __in PIRP Irp,
    __in ULONG DataItemsCount,
    __in ULONG DataItemSize,
    __in_bcount(DataItemsCount * DataItemSize) const VOID* DataItems
    );

// image.c:

#if (!defined( MAKEINTRESOURCE )) 
#define MAKEINTRESOURCE( res ) ((ULONG_PTR) (USHORT) res)
#endif

#if (!defined( RT_STRING ))
#define RT_STRING           MAKEINTRESOURCE( 6 )
#define RT_RCDATA           MAKEINTRESOURCE( 10 ) 
#endif

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsLoadResource(
    __in PVOID ImageBase,
    __in POOL_TYPE PoolType,
    __in ULONG_PTR ResourceName,
    __in ULONG ResourceType,
    __deref_out_bcount(ResourceSize) PVOID *Resource,
    __out_opt PULONG ResourceSize            
    );
    
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsGetImageNameAndResourceId(
    __in HANDLE RegKey,
    __out PUNICODE_STRING ImageName,                
    __out PULONG_PTR ResourceId,
    __out PULONG ValueType
);

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMapModuleName(
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in PUNICODE_STRING ModuleName,
    __out PUNICODE_STRING ImageName,                
    __out PULONG_PTR ResourceId,
    __out PULONG ValueType
    );
    
// irp.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsReferenceBusObject(
    __in KSDEVICE_HEADER  Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsDereferenceBusObject(
    __in KSDEVICE_HEADER  Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchQuerySecurity(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSetSecurity(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSpecificProperty(
    __in PIRP Irp,
    __in PFNKSHANDLER Handler
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchSpecificMethod(
    __in PIRP Irp,
    __in PFNKSHANDLER Handler
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsReadFile(
    __in PFILE_OBJECT FileObject,
    __in_opt PKEVENT Event,
    __in_opt PVOID PortContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __out_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in ULONG Key OPTIONAL,
    __in KPROCESSOR_MODE RequestorMode
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsWriteFile(
    __in PFILE_OBJECT FileObject,
    __in_opt PKEVENT Event,
    __in_opt PVOID PortContext,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Length,
    __in ULONG Key OPTIONAL,
    __in KPROCESSOR_MODE RequestorMode
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsQueryInformationFile(
    __in PFILE_OBJECT FileObject,
    __out_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsSetInformationFile(
    __in PFILE_OBJECT FileObject,
    __in_bcount(Length) PVOID FileInformation,
    __in ULONG Length,
    __in FILE_INFORMATION_CLASS FileInformationClass
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamIo(
    __in PFILE_OBJECT FileObject,
    __in_opt PKEVENT Event,
    __in_opt PVOID PortContext,
    __in_opt PIO_COMPLETION_ROUTINE CompletionRoutine,
    __in_opt PVOID CompletionContext,
    __in KSCOMPLETION_INVOCATION CompletionInvocationFlags OPTIONAL,
    __out PIO_STATUS_BLOCK IoStatusBlock,
    __inout_bcount(Length) PVOID StreamHeaders,
    __in ULONG Length,
    __in ULONG Flags,
    __in KPROCESSOR_MODE RequestorMode
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsProbeStreamIrp(
    __inout PIRP Irp,
    __in ULONG ProbeFlags,
    __in ULONG HeaderSize OPTIONAL
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateExtraData(
    __inout PIRP Irp,
    __in ULONG ExtraSize,
    __out PVOID* ExtraBuffer
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsNullDriverUnload(
    __in PDRIVER_OBJECT DriverObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsSetMajorFunctionHandler(
    __in PDRIVER_OBJECT DriverObject,
    __in ULONG MajorFunction
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchInvalidDeviceRequest(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDefaultDeviceIoCompletion(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsDispatchIrp(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsDispatchFastIoDeviceControlFailure(
    __in PFILE_OBJECT FileObject,
    __in BOOLEAN Wait,
    __in_bcount_opt(InputBufferLength) PVOID InputBuffer,
    __in ULONG InputBufferLength,
    __out_bcount_opt(OutputBufferLength) PVOID OutputBuffer,
    __in ULONG OutputBufferLength,
    __in ULONG IoControlCode,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsDispatchFastReadFailure(
    __in PFILE_OBJECT FileObject,
    __in PLARGE_INTEGER FileOffset,
    __in ULONG Length,
    __in BOOLEAN Wait,
    __in ULONG LockKey,
    __out PVOID Buffer,
    __out PIO_STATUS_BLOCK IoStatus,
    __in PDEVICE_OBJECT DeviceObject
    );

#define KsDispatchFastWriteFailure KsDispatchFastReadFailure

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
DRIVER_CANCEL KsCancelRoutine;

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsCancelIo(   
    __inout PLIST_ENTRY  QueueHead,
    __in PKSPIN_LOCK SpinLock
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsReleaseIrpOnCancelableQueue(
    __in PIRP Irp,
    __in_opt PDRIVER_CANCEL DriverCancel
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PIRP
NTAPI
KsRemoveIrpFromCancelableQueue(
    __inout PLIST_ENTRY QueueHead,
    __in PKSPIN_LOCK SpinLock,
    __in KSLIST_ENTRY_LOCATION ListLocation,
    __in KSIRP_REMOVAL_OPERATION RemovalOperation
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMoveIrpsOnCancelableQueue(
    __inout PLIST_ENTRY SourceList,
    __in PKSPIN_LOCK SourceLock,
    __inout PLIST_ENTRY DestinationList,
    __in_opt PKSPIN_LOCK DestinationLock,
    __in KSLIST_ENTRY_LOCATION ListLocation,
    __in PFNKSIRPLISTCALLBACK ListCallback,
    __in PVOID Context
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsRemoveSpecificIrpFromCancelableQueue(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsAddIrpToCancelableQueue(
    __inout PLIST_ENTRY QueueHead,
    __in PKSPIN_LOCK SpinLock,
    __in PIRP Irp,
    __in KSLIST_ENTRY_LOCATION ListLocation,
    __in_opt PDRIVER_CANCEL DriverCancel
    );

// api.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAcquireResetValue(
    __in PIRP Irp,
    __out KSRESET* ResetValue
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsTopologyPropertyHandler(
    __in PIRP Irp,
    __in PKSPROPERTY Property,
    __inout PVOID Data,
    __in const KSTOPOLOGY* Topology
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
VOID
NTAPI
KsAcquireDeviceSecurityLock(
    __in KSDEVICE_HEADER Header,
    __in BOOLEAN Exclusive
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
VOID
NTAPI
KsReleaseDeviceSecurityLock(
    __in KSDEVICE_HEADER Header
    );
    
KSDDKAPI
__drv_dispatchType(IRP_MJ_PNP) DRIVER_DISPATCH KsDefaultDispatchPnp;

KSDDKAPI
__drv_dispatchType(IRP_MJ_POWER) DRIVER_DISPATCH KsDefaultDispatchPower;
    
KSDDKAPI
__drv_dispatchType(IRP_MJ_SYSTEM_CONTROL) 
__drv_dispatchType(IRP_MJ_DEVICE_CONTROL)
DRIVER_DISPATCH KsDefaultForwardIrp;

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetDevicePnpAndBaseObject(
    __in KSDEVICE_HEADER Header,
    __in PDEVICE_OBJECT PnpDeviceObject,
    __in PDEVICE_OBJECT BaseObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PDEVICE_OBJECT
NTAPI
KsQueryDevicePnpObject(
    __in KSDEVICE_HEADER Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ACCESS_MASK
NTAPI
KsQueryObjectAccessMask(
    __in KSOBJECT_HEADER Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsRecalculateStackDepth(
    __in KSDEVICE_HEADER Header,
    __in BOOLEAN ReuseStackLocation
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetTargetState(
    __in KSOBJECT_HEADER Header,
    __in KSTARGET_STATE TargetState
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetTargetDeviceObject(
    __in KSOBJECT_HEADER Header,
    __in_opt PDEVICE_OBJECT TargetDevice
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsSetPowerDispatch(
    __in KSOBJECT_HEADER Header,
    __in_opt PFNKSCONTEXT_DISPATCH PowerDispatch,
    __in_opt PVOID PowerContext
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSOBJECT_CREATE_ITEM
NTAPI
KsQueryObjectCreateItem(
    __in KSOBJECT_HEADER Header
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateDeviceHeader(
    __out KSDEVICE_HEADER* Header,
    __in ULONG ItemsCount,
    __in_ecount_opt(ItemsCount) PKSOBJECT_CREATE_ITEM ItemsList
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
VOID
NTAPI
KsFreeDeviceHeader(
    __in KSDEVICE_HEADER Header
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectHeader(
    __out KSOBJECT_HEADER* Header,
    __in ULONG ItemsCount,
    __in_ecount_opt(ItemsCount) PKSOBJECT_CREATE_ITEM ItemsList,
    __in PIRP Irp,
    __in const KSDISPATCH_TABLE* Table
    );

__drv_maxIRQL(APC_LEVEL)
KSDDKAPI
VOID
NTAPI
KsFreeObjectHeader(
    __in KSOBJECT_HEADER Header
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAddObjectCreateItemToDeviceHeader(
    __in KSDEVICE_HEADER Header,
    __in PDRIVER_DISPATCH Create,
    __in PVOID Context,
    __in PWSTR ObjectClass,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAddObjectCreateItemToObjectHeader(
    __in KSOBJECT_HEADER Header,
    __in PDRIVER_DISPATCH Create,
    __in PVOID Context,
    __in PWSTR ObjectClass,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectCreateItem(
    __in KSDEVICE_HEADER Header,
    __in PKSOBJECT_CREATE_ITEM CreateItem,
    __in BOOLEAN AllocateEntry,
    __in_opt PFNKSITEMFREECALLBACK ItemFreeCallback
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFreeObjectCreateItem(
    __in KSDEVICE_HEADER Header,
    __in PUNICODE_STRING CreateItem
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFreeObjectCreateItemsByContext(
    __in KSDEVICE_HEADER Header,
    __in PVOID Context
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDefaultSecurity(
    __in_opt PSECURITY_DESCRIPTOR ParentSecurity,
    __out PSECURITY_DESCRIPTOR* DefaultSecurity
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsForwardIrp(
    __in PIRP Irp,
    __in PFILE_OBJECT FileObject,
    __in BOOLEAN ReuseStackLocation
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsForwardAndCatchIrp(
    __in PDEVICE_OBJECT DeviceObject,
    __in PIRP Irp,
    __in PFILE_OBJECT FileObject,
    __in KSSTACK_USE StackUse
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsSynchronousIoControlDevice(
    __in PFILE_OBJECT FileObject,
    __in KPROCESSOR_MODE RequestorMode,
    __in ULONG IoControl,
    __in_bcount(InSize) PVOID InBuffer,
    __in ULONG InSize,
    __out_bcount_part(OutSize, *BytesReturned) PVOID OutBuffer,
    __in ULONG OutSize,
    __out PULONG BytesReturned
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsUnserializeObjectPropertiesFromRegistry(
    __in PFILE_OBJECT FileObject,
    __in_opt HANDLE ParentKey,
    __in_opt PUNICODE_STRING RegistryPath
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCacheMedium(
    __in PUNICODE_STRING SymbolicLink,
    __in PKSPIN_MEDIUM Medium,
    __in ULONG PinDirection
    );

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// thread.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsRegisterWorker(
    __in WORK_QUEUE_TYPE WorkQueueType,
    __out PKSWORKER* Worker
    );
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsRegisterCountedWorker(
    __in WORK_QUEUE_TYPE WorkQueueType,
    __in PWORK_QUEUE_ITEM CountedWorkItem,
    __out PKSWORKER* Worker
    );
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
VOID
NTAPI
KsUnregisterWorker(
    __in PKSWORKER Worker
    );
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsQueueWorkItem(
    __in PKSWORKER Worker,
    __in PWORK_QUEUE_ITEM WorkItem
    );
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsIncrementCountedWorker(
    __in PKSWORKER Worker
    );
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsDecrementCountedWorker(
    __in PKSWORKER Worker
    );

// topology.c:

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateTopologyNode(
    __in HANDLE ParentHandle,
    __in PKSNODE_CREATE NodeCreate,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE NodeHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsValidateTopologyNodeCreateRequest(
    __in PIRP Irp,
    __in PKSTOPOLOGY Topology,
    __out PKSNODE_CREATE* NodeCreate
    );

#if (NTDDI_VERSION >= NTDDI_WINXP)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsMergeAutomationTables(
    __out PKSAUTOMATION_TABLE* AutomationTableAB,
    __in_opt PKSAUTOMATION_TABLE AutomationTableA,
    __in_opt PKSAUTOMATION_TABLE AutomationTableB,
    __in_opt KSOBJECT_BAG Bag
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsInitializeDriver(
    __in PDRIVER_OBJECT DriverObject,
    __in PUNICODE_STRING RegistryPathName,
    __in_opt const KSDEVICE_DESCRIPTOR* Descriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAddDevice(
    __in PDRIVER_OBJECT DriverObject,
    __in PDEVICE_OBJECT PhysicalDeviceObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateDevice(
    __in PDRIVER_OBJECT DriverObject,
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in_opt const KSDEVICE_DESCRIPTOR* Descriptor,
    __in ULONG ExtensionSize,
    __out_opt PKSDEVICE* Device
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsInitializeDevice(
    __in PDEVICE_OBJECT FunctionalDeviceObject,
    __in PDEVICE_OBJECT PhysicalDeviceObject,
    __in PDEVICE_OBJECT NextDeviceObject,
    __in_opt const KSDEVICE_DESCRIPTOR* Descriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsTerminateDevice(
    __in PDEVICE_OBJECT DeviceObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSDEVICE
NTAPI
KsGetDeviceForDeviceObject(
    __in PDEVICE_OBJECT FunctionalDeviceObject
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsAcquireDevice(
    __in PKSDEVICE Device
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsReleaseDevice(
    __in PKSDEVICE Device
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsDeviceRegisterAdapterObject(
    __in PKSDEVICE Device,
    __in PADAPTER_OBJECT AdapterObject,
    __in ULONG MaxMappingsByteCount,
    __in ULONG MappingTableStride
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsDeviceGetBusData(
    __in PKSDEVICE Device,
    __in ULONG DataType,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsDeviceSetBusData(
    __in PKSDEVICE Device,
    __in ULONG DataType,
    __in_bcount(Length) PVOID Buffer,
    __in ULONG Offset,
    __in ULONG Length
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCreateFilterFactory(
    __in PDEVICE_OBJECT DeviceObject,
    __in const KSFILTER_DESCRIPTOR *Descriptor,
    __in_opt PWSTR RefString,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG CreateItemFlags,
    __in_opt PFNKSFILTERFACTORYPOWER SleepCallback,
    __in_opt PFNKSFILTERFACTORYPOWER WakeCallback,
    __out_opt PKSFILTERFACTORY *FilterFactory
    );

#define KsDeleteFilterFactory(FilterFactory) \
    KsFreeObjectCreateItemsByContext(\
        *(KSDEVICE_HEADER *)(\
            KsFilterFactoryGetParentDevice(FilterFactory)->FunctionalDeviceObject->\
                DeviceExtension),\
        FilterFactory)

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactoryUpdateCacheData(
    __in PKSFILTERFACTORY FilterFactory,
    __in_opt const KSFILTER_DESCRIPTOR *FilterDescriptor
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactoryAddCreateItem(
    __in PKSFILTERFACTORY FilterFactory,
    __in PWSTR RefString,
    __in_opt PSECURITY_DESCRIPTOR SecurityDescriptor,
    __in ULONG CreateItemFlags
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterFactorySetDeviceClassesState(
    __in PKSFILTERFACTORY FilterFactory,
    __in BOOLEAN NewState
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PUNICODE_STRING
NTAPI
KsFilterFactoryGetSymbolicLink(
    __in PKSFILTERFACTORY FilterFactory
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsAddEvent(
    __in PVOID Object,
    __in PKSEVENT_ENTRY EventEntry
    );

__drv_maxIRQL(PASSIVE_LEVEL)
void _inline
KsFilterAddEvent(
    __in PKSFILTER Filter,
    __in PKSEVENT_ENTRY EventEntry
    )
{
    KsAddEvent(Filter,EventEntry);
}

__drv_maxIRQL(PASSIVE_LEVEL)
void _inline
KsPinAddEvent(
    __in PKSPIN Pin,
    __in PKSEVENT_ENTRY EventEntry
    )
{
    KsAddEvent(Pin,EventEntry);
}

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS    
NTAPI
KsDefaultAddEventHandler(
    __in PIRP Irp,
    __in PKSEVENTDATA EventData,
    __inout PKSEVENT_ENTRY EventEntry
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsGenerateEvents(
    __in PVOID Object,
    __in_opt const GUID* EventSet,
    __in ULONG EventId,
    __in ULONG DataSize,
    __in_bcount_opt(DataSize) PVOID Data,
    __in_opt PFNKSGENERATEEVENTCALLBACK CallBack,
    __in_opt PVOID CallBackContext
    );

__drv_maxIRQL(DISPATCH_LEVEL)
void _inline
KsFilterGenerateEvents(
    __in PKSFILTER Filter,
    __in_opt const GUID* EventSet,
    __in ULONG EventId,
    __in ULONG DataSize,
    __in_bcount(DataSize) PVOID Data,
    __in_opt PFNKSGENERATEEVENTCALLBACK CallBack,
    __in_opt PVOID CallBackContext
    )
{
    KsGenerateEvents(
        Filter,
        EventSet,
        EventId,
        DataSize,
        Data,
        CallBack,
        CallBackContext);
}

__drv_maxIRQL(DISPATCH_LEVEL)
void _inline
KsPinGenerateEvents(
    __in PKSPIN Pin,
    __in_opt const GUID* EventSet,
    __in ULONG EventId,
    __in ULONG DataSize,
    __in_bcount_opt(DataSize) PVOID Data,
    __in_opt PFNKSGENERATEEVENTCALLBACK CallBack,
    __in_opt PVOID CallBackContext
    )
{
    KsGenerateEvents(
        Pin,
        EventSet,
        EventId,
        DataSize,
        Data,
        CallBack,
        CallBackContext);
}

typedef enum {
    KSSTREAM_POINTER_STATE_UNLOCKED = 0,
    KSSTREAM_POINTER_STATE_LOCKED
} KSSTREAM_POINTER_STATE;

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinGetAvailableByteCount(
    __in PKSPIN Pin,
    __out_opt PLONG InputDataBytes,
    __out_opt PLONG OutputBufferBytes
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetLeadingEdgeStreamPointer(
    __in PKSPIN Pin,
    __in KSSTREAM_POINTER_STATE State
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetTrailingEdgeStreamPointer(
    __in PKSPIN Pin,
    __in KSSTREAM_POINTER_STATE State
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerSetStatusCode(
    __in PKSSTREAM_POINTER StreamPointer,
    __in NTSTATUS Status
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerLock(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerUnlock(
    __in PKSSTREAM_POINTER StreamPointer,
    __in BOOLEAN Eject
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerAdvanceOffsetsAndUnlock(
    __in PKSSTREAM_POINTER StreamPointer,
    __in ULONG InUsed,
    __in ULONG OutUsed,
    __in BOOLEAN Eject
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerDelete(
    __in PKSSTREAM_POINTER StreamPointer
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerClone(
    __in PKSSTREAM_POINTER StreamPointer,
    __in_opt PFNKSSTREAMPOINTER CancelCallback,
    __in ULONG ContextSize,
    __out PKSSTREAM_POINTER* CloneStreamPointer
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerAdvanceOffsets(
    __in PKSSTREAM_POINTER StreamPointer,
    __in ULONG InUsed,
    __in ULONG OutUsed,
    __in BOOLEAN Eject
    );

__checkReturn
__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsStreamPointerAdvance(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PMDL
NTAPI
KsStreamPointerGetMdl(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PIRP
NTAPI
KsStreamPointerGetIrp(
    __in PKSSTREAM_POINTER StreamPointer,
    __out_opt PBOOLEAN FirstFrameInIrp,
    __out_opt PBOOLEAN LastFrameInIrp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerScheduleTimeout(
    __in PKSSTREAM_POINTER StreamPointer,
    __in PFNKSSTREAMPOINTER Callback,
    __in ULONGLONG Interval
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsStreamPointerCancelTimeout(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsPinGetFirstCloneStreamPointer(
    __in PKSPIN Pin
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSSTREAM_POINTER
NTAPI
KsStreamPointerGetNextClone(
    __in PKSSTREAM_POINTER StreamPointer
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinHandshake(
    __in PKSPIN Pin,
    __in PKSHANDSHAKE In,
    __out PKSHANDSHAKE Out
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsCompletePendingRequest(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
KSOBJECTTYPE
NTAPI
KsGetObjectTypeFromIrp(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PVOID
NTAPI
KsGetObjectFromFileObject(
    __in PFILE_OBJECT FileObject
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
KSOBJECTTYPE
NTAPI
KsGetObjectTypeFromFileObject(
    __in PFILE_OBJECT FileObject
    );

__drv_maxIRQL(DISPATCH_LEVEL)
PKSFILTER __inline
KsGetFilterFromFileObject(
    __in PFILE_OBJECT FileObject
    )
{
    return (PKSFILTER) KsGetObjectFromFileObject(FileObject);
}

__drv_maxIRQL(DISPATCH_LEVEL)
PKSPIN __inline
KsGetPinFromFileObject(
    __in PFILE_OBJECT FileObject
    )
{
    return (PKSPIN) KsGetObjectFromFileObject(FileObject);
}    

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSGATE
NTAPI
KsFilterGetAndGate(
    __in PKSFILTER Filter
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsFilterAcquireProcessingMutex(
    __in PKSFILTER Filter
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsFilterReleaseProcessingMutex(
    __in PKSFILTER Filter
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsFilterAttemptProcessing(
    __in PKSFILTER Filter,
    __in BOOLEAN Asynchronous
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSGATE
NTAPI
KsPinGetAndGate(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinAttachAndGate(
    __in PKSPIN Pin,
    __in_opt PKSGATE AndGate
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinAttachOrGate(
    __in PKSPIN Pin,
    __in_opt PKSGATE OrGate
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinAcquireProcessingMutex(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinReleaseProcessingMutex(
    __in PKSPIN Pin
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
BOOLEAN
NTAPI
KsProcessPinUpdate(
    __in PKSPROCESSPIN ProcessPin
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsPinGetCopyRelationships(
    __in PKSPIN Pin,
    __out PKSPIN* CopySource,
    __out PKSPIN* DelegateBranch
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
void
NTAPI
KsPinAttemptProcessing(
    __in PKSPIN Pin,
    __in BOOLEAN Asynchronous
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PVOID
NTAPI
KsGetParent(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PKSDEVICE __inline
KsFilterFactoryGetParentDevice(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSDEVICE) KsGetParent((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTERFACTORY __inline
KsFilterGetParentFilterFactory(
    __in PKSFILTER Filter
    )
{
    return (PKSFILTERFACTORY) KsGetParent((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSFILTER 
NTAPI
KsPinGetParentFilter(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PVOID
NTAPI
KsGetFirstChild(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTERFACTORY __inline
KsDeviceGetFirstChildFilterFactory(
    __in PKSDEVICE Device
    )
{
    return (PKSFILTERFACTORY) KsGetFirstChild((PVOID) Device);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTER __inline
KsFilterFactoryGetFirstChildFilter(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSFILTER) KsGetFirstChild((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsFilterGetChildPinCount(
    __in PKSFILTER Filter,
    __in ULONG PinId
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSPIN
NTAPI
KsFilterGetFirstChildPin(
    __in PKSFILTER Filter,
    __in ULONG PinId
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PVOID
NTAPI
KsGetNextSibling(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSPIN 
NTAPI
KsPinGetNextSiblingPin(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTERFACTORY __inline
KsFilterFactoryGetNextSiblingFilterFactory(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return (PKSFILTERFACTORY) KsGetNextSibling((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSFILTER __inline
KsFilterGetNextSiblingFilter(
    __in PKSFILTER Filter
    )
{
    return (PKSFILTER) KsGetNextSibling((PVOID) Filter);
}


__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PKSDEVICE
NTAPI
KsGetDevice(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PKSDEVICE __inline
KsFilterFactoryGetDevice(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return KsGetDevice((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSDEVICE __inline
KsFilterGetDevice(
    __in PKSFILTER Filter
    )
{
    return KsGetDevice((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PKSDEVICE __inline
KsPinGetDevice(
    __in PKSPIN Pin
    )
{
    return KsGetDevice((PVOID) Pin);
}

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSFILTER
NTAPI
KsGetFilterFromIrp(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
PKSPIN
NTAPI
KsGetPinFromIrp(
    __in PIRP Irp
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsGetNodeIdFromIrp(
    __in PIRP Irp
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsAcquireControl(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsReleaseControl(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL) 
void __inline
KsFilterAcquireControl(
    __in PKSFILTER Filter
    )
{
    KsAcquireControl((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
void __inline
KsFilterReleaseControl(
    __in PKSFILTER Filter
    )
{
    KsReleaseControl((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
void __inline
KsPinAcquireControl(
    __in PKSPIN Pin
    )
{
    KsAcquireControl((PVOID) Pin);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
void __inline
KsPinReleaseControl(
    __in PKSPIN Pin
    )
{
    KsReleaseControl((PVOID) Pin);
}

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAddItemToObjectBag(
    __in KSOBJECT_BAG ObjectBag,
    __in __drv_aliasesMem PVOID Item,
    __in_opt PFNKSFREE Free
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
ULONG
NTAPI
KsRemoveItemFromObjectBag(
    __in KSOBJECT_BAG ObjectBag,
    __in PVOID Item,
    __in BOOLEAN Free
    );

#define KsDiscard(Object,Pointer)\
    KsRemoveItemFromObjectBag(\
        (Object)->Bag,\
        (PVOID)(Pointer),\
        TRUE)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsAllocateObjectBag(
    __in PKSDEVICE Device,
    __out KSOBJECT_BAG* ObjectBag
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsFreeObjectBag(
    __in KSOBJECT_BAG ObjectBag
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsCopyObjectBagItems(
    __in KSOBJECT_BAG ObjectBagDestination,
    __in KSOBJECT_BAG ObjectBagSource
    );

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
_KsEdit(
    __in KSOBJECT_BAG ObjectBag,
    __inout PVOID* PointerToPointerToItem,
    __in ULONG NewSize,
    __in ULONG OldSize,
    __in ULONG Tag
    );

#define KsEdit(Object,PointerToPointer,Tag)\
    _KsEdit(\
        (Object)->Bag,\
        (PVOID*)(PointerToPointer),\
        sizeof(**(PointerToPointer)),\
        sizeof(**(PointerToPointer)),\
        (Tag))
#define KsEditSized(Object,PointerToPointer,NewSize,OldSize,Tag)\
    _KsEdit((Object)->Bag,(PVOID*)(PointerToPointer),(NewSize),(OldSize),(Tag))

__checkReturn
__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsRegisterFilterWithNoKSPins(
                                      __in PDEVICE_OBJECT DeviceObject,
                                      __in const GUID * InterfaceClassGUID,
                                      __in ULONG PinCount,
                                      __in_ecount(PinCount) BOOL * PinDirection,
                                      __in_ecount(PinCount) KSPIN_MEDIUM * MediumList,
                                      __in_ecount_opt(PinCount) GUID * CategoryList
);

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterCreatePinFactory (
    __in PKSFILTER Filter,
    __in const KSPIN_DESCRIPTOR_EX *const PinDescriptor,
    __out PULONG PinID
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterCreateNode (
    __in PKSFILTER Filter,
    __in const KSNODE_DESCRIPTOR *const NodeDescriptor,
    __out PULONG NodeID
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsFilterAddTopologyConnections (
    __in PKSFILTER Filter,
    __in ULONG NewConnectionsCount,
    __in_ecount(NewConnectionsCount) const KSTOPOLOGY_CONNECTION *const NewTopologyConnections
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinGetConnectedPinInterface(
    __in PKSPIN Pin,
    __in const GUID* InterfaceId,
    __out PVOID* Interface
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PFILE_OBJECT
NTAPI
KsPinGetConnectedPinFileObject(
    __in PKSPIN Pin
    );

KSDDKAPI
PDEVICE_OBJECT
NTAPI
KsPinGetConnectedPinDeviceObject(
    __in PKSPIN Pin
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinGetConnectedFilterInterface(
    __in PKSPIN Pin,
    __in const GUID* InterfaceId,
    __out PVOID* Interface
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinGetReferenceClockInterface(
    __in PKSPIN Pin,
    __out PIKSREFERENCECLOCK* Interface
    );

#endif //defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
VOID
NTAPI
KsPinSetPinClockTime(
    __in PKSPIN Pin,
    __in LONGLONG Time
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinSubmitFrame(
    __in PKSPIN Pin,
    __in_bcount_opt(Size) PVOID Data,
    __in ULONG Size OPTIONAL,
    __in_opt PKSSTREAM_HEADER StreamHeader,
    __in_opt PVOID Context
    );

__drv_maxIRQL(DISPATCH_LEVEL)
KSDDKAPI
NTSTATUS
NTAPI
KsPinSubmitFrameMdl(
    __in PKSPIN Pin,
    __in_opt PMDL Mdl,
    __in_opt PKSSTREAM_HEADER StreamHeader,
    __in_opt PVOID Context
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinRegisterFrameReturnCallback(
    __in PKSPIN Pin,
    __in PFNKSPINFRAMERETURN FrameReturn
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinRegisterIrpCompletionCallback(
    __in PKSPIN Pin,
    __in PFNKSPINIRPCOMPLETION IrpCompletion
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinRegisterHandshakeCallback(
    __in PKSPIN Pin,
    __in PFNKSPINHANDSHAKE Handshake
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsFilterRegisterPowerCallbacks(
    __in PKSFILTER Filter,
    __in_opt PFNKSFILTERPOWER Sleep,
    __in_opt PFNKSFILTERPOWER Wake
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
void
NTAPI
KsPinRegisterPowerCallbacks(
    __in PKSPIN Pin,
    __in_opt PFNKSPINPOWER Sleep,
    __in_opt PFNKSPINPOWER Wake
    );

#if defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PUNKNOWN
NTAPI
KsRegisterAggregatedClientUnknown(
    __in PVOID Object,
    __in PUNKNOWN ClientUnknown 
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
PUNKNOWN
NTAPI
KsGetOuterUnknown(
    __in PVOID Object
    );

__drv_maxIRQL(PASSIVE_LEVEL)
PUNKNOWN __inline
KsDeviceRegisterAggregatedClientUnknown(
    __in PKSDEVICE Device,
    __in PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Device,ClientUnknown);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
PUNKNOWN __inline
KsDeviceGetOuterUnknown(
    __in PKSDEVICE Device
    )
{
    return KsGetOuterUnknown((PVOID) Device);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PUNKNOWN __inline
KsFilterFactoryRegisterAggregatedClientUnknown(
    __in PKSFILTERFACTORY FilterFactory,
    __in PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) FilterFactory,ClientUnknown);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
PUNKNOWN __inline
KsFilterFactoryGetOuterUnknown(
    __in PKSFILTERFACTORY FilterFactory
    )
{
    return KsGetOuterUnknown((PVOID) FilterFactory);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PUNKNOWN __inline
KsFilterRegisterAggregatedClientUnknown(
    __in PKSFILTER Filter,
    __in PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Filter,ClientUnknown);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
PUNKNOWN __inline
KsFilterGetOuterUnknown(
    __in PKSFILTER Filter
    )
{
    return KsGetOuterUnknown((PVOID) Filter);
}

__drv_maxIRQL(PASSIVE_LEVEL)
PUNKNOWN __inline
KsPinRegisterAggregatedClientUnknown(
    __in PKSPIN Pin,
    __in PUNKNOWN ClientUnknown 
    )
{
    return KsRegisterAggregatedClientUnknown((PVOID) Pin,ClientUnknown);
}

__drv_maxIRQL(PASSIVE_LEVEL) 
PUNKNOWN __inline
KsPinGetOuterUnknown(
    __in PKSPIN Pin
    )
{
    return KsGetOuterUnknown((PVOID) Pin);
}

#endif // defined(_UNKNOWN_H_) || defined(__IUnknown_INTERFACE_DEFINED__)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#else // !defined(_NTDDK_)

#if !defined( KS_NO_CREATE_FUNCTIONS )

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
DWORD
WINAPI
KsCreateAllocator(
    __in HANDLE ConnectionHandle,
    __in PKSALLOCATOR_FRAMING AllocatorFraming,
    __out PHANDLE AllocatorHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
DWORD
NTAPI
KsCreateClock(
    __in HANDLE ConnectionHandle,
    __in PKSCLOCK_CREATE ClockCreate,
    __out PHANDLE ClockHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
DWORD
WINAPI
KsCreatePin(
    __in HANDLE FilterHandle,
    __in PKSPIN_CONNECT Connect,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE ConnectionHandle
    );

__drv_maxIRQL(PASSIVE_LEVEL)
KSDDKAPI
DWORD
WINAPI
KsCreateTopologyNode(
    __in HANDLE ParentHandle,
    __in PKSNODE_CREATE NodeCreate,
    __in ACCESS_MASK DesiredAccess,
    __out PHANDLE NodeHandle
    );
    
#endif

#endif // !defined(_NTDDK_)

#if defined(__cplusplus)
}
#endif // defined(__cplusplus)


#define DENY_USERMODE_ACCESS( pIrp, CompleteRequest ) \
if ( pIrp->RequestorMode != KernelMode ) { \
    pIrp->IoStatus.Information = 0; \
    pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST; \
    if ( CompleteRequest ) IoCompleteRequest ( pIrp, IO_NO_INCREMENT ); \
    return STATUS_INVALID_DEVICE_REQUEST; \
}


#endif // !_KS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ksopmapi.h ===
//*@@@+++@@@@******************************************************************
//
// Microsoft Windows Media Foundation
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// ksopmapi.h - definitions for kernel mode code OPM communication
//
//*@@@---@@@@******************************************************************

#ifndef _KSOPMAPI_
#define _KSOPMAPI_

#if defined (_MSC_VER) && (_MSC_VER >= 1020) && !defined(__midl)
#pragma once
#endif


#if (WINVER >= _WIN32_WINNT_WIN7)

//=============================================================================
// Description:
//
//  Ks Property set to use with AVStram drivers
// KSPROPSETID_OPMVideoOutput {06F414BB-F43A-4fe2-A566-774B4C81F0DB}
#ifdef DEFINE_GUIDSTRUCT
#define STATIC_KSPROPSETID_OPMVideoOutput \
0x6f414bb, 0xf43a, 0x4fe2, 0xa5, 0x66, 0x77, 0x4b, 0x4c, 0x81, 0xf0, 0xdb                         
DEFINE_GUIDSTRUCT("06F414BB-F43A-4fe2-A566-774B4C81F0DB", KSPROPSETID_OPMVideoOutput);          
#define KSPROPSETID_OPMVideoOutput DEFINE_GUIDNAMED(KSPROPSETID_OPMVideoOutput)                   
#endif
                                                                                                  
typedef enum
{                                                                                    
    //  Output is OPM_RANDOM_NUMBER followed by certifiate                                        
    KSMETHOD_OPMVIDEOOUTPUT_STARTINITIALIZATION = 0,                                              
                                                                                                  
    //  Input OPM_ENCRYPTED_INITIALIZATION_PARAMETERS                                             
    //  Output OPM_STANDARD_INFORMATION                                                           
    KSMETHOD_OPMVIDEOOUTPUT_FINISHINITIALIZATION = 1,                                             
                                                                                                  
    //  Input is OPM_GET_INFO_PARAMETERS, output is OPM_REQUESTED_INFORMATION                     
    //  Use KsMethod - both input and output in the buffer (not after the KSMETHOD structure)     
    KSMETHOD_OPMVIDEOOUTPUT_GETINFORMATION = 2                                                    
} KSMETHOD_OPMVIDEOOUTPUT;              

//  Currently on this GetInformation call is supported
DEFINE_GUID( OPM_GET_CODEC_INFO, 0x4f374491, 0x8f5f, 0x4445, 0x9d, 0xba, 0x95, 0x58, 0x8f, 0x6b, 0x58, 0xb4);

typedef struct _OPM_RANDOM_NUMBER
{
    BYTE abRandomNumber[ 16 ];
}OPM_RANDOM_NUMBER, *POPM_RANDOM_NUMBER;

enum
{
    OPM_OMAC_SIZE                                  = 16,
    OPM_128_BIT_RANDOM_NUMBER_SIZE                 = 16,
    OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE   = 256,
    OPM_CONFIGURE_SETTING_DATA_SIZE                = 4056,
    OPM_GET_INFORMATION_PARAMETERS_SIZE            = 4056,
    OPM_REQUESTED_INFORMATION_SIZE                 = 4076,
    OPM_HDCP_KEY_SELECTION_VECTOR_SIZE             = 5,
    OPM_PROTECTION_TYPE_SIZE                       = 4,
    OPM_BUS_TYPE_MASK                              = 0xFFFF,
    OPM_BUS_IMPLEMENTATION_MODIFIER_MASK           = 0x7FFF,
};

typedef struct _OPM_OMAC
{
    BYTE abOMAC[OPM_OMAC_SIZE];  

} OPM_OMAC;

typedef struct _OPM_GET_INFO_PARAMETERS
{
    OPM_OMAC omac;  
    OPM_RANDOM_NUMBER rnRandomNumber;
    GUID guidInformation;
    ULONG ulSequenceNumber;
    ULONG cbParametersSize;
    BYTE abParameters[OPM_GET_INFORMATION_PARAMETERS_SIZE];

} OPM_GET_INFO_PARAMETERS;

typedef struct _OPM_REQUESTED_INFORMATION
{
    OPM_OMAC omac;  
    ULONG cbRequestedInformationSize;
    BYTE abRequestedInformation[OPM_REQUESTED_INFORMATION_SIZE];

} OPM_REQUESTED_INFORMATION;

typedef struct _OPM_ENCRYPTED_INITIALIZATION_PARAMETERS
{
    BYTE abEncryptedInitializationParameters[OPM_ENCRYPTED_INITIALIZATION_PARAMETERS_SIZE];

} OPM_ENCRYPTED_INITIALIZATION_PARAMETERS;

typedef struct _OPM_STANDARD_INFORMATION
{
    OPM_RANDOM_NUMBER rnRandomNumber;
    ULONG ulStatusFlags;
    ULONG ulInformation;
    ULONG ulReserved;
    ULONG ulReserved2;

} OPM_STANDARD_INFORMATION;

typedef struct _OPM_GET_CODEC_INFO_PARAMETERS
{
    DWORD  cbVerifier;
    BYTE   Verifier[OPM_GET_INFORMATION_PARAMETERS_SIZE - 4];  // Class ID of MFT or symbolic link for AVStream 
                          // drivers
} OPM_GET_CODEC_INFO_PARAMETERS;

typedef struct _OPM_GET_CODEC_INFO_INFORMATION
{
    OPM_RANDOM_NUMBER rnRandomNumber;
    DWORD Merit;   // Merit assigned to the codec
} OPM_GET_CODEC_INFO_INFORMATION;

#endif // (WINVER >= _WIN32_WINNT_WIN7)

#endif//_KSOPMAPI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\KsMedia.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksmedia.h

Abstract:

    WDM-CSA Multimedia Definitions.

--*/

#if !defined(_KS_)
#error KS.H must be included before KSMEDIA.H
#endif // !defined(_KS_)

#if !defined(_KSMEDIA_)
#define _KSMEDIA_

#pragma warning(disable:4201) // nameless struct/union
#pragma warning(disable:4214) // bit field types other than int

typedef struct {
    KSPROPERTY      Property;
    KSMULTIPLE_ITEM MultipleItem;
} KSMULTIPLE_DATA_PROP, *PKSMULTIPLE_DATA_PROP;

#define STATIC_KSMEDIUMSETID_MidiBus \
    0x05908040L, 0x3246, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("05908040-3246-11D0-A5D6-28DB04C10000", KSMEDIUMSETID_MidiBus);
#define KSMEDIUMSETID_MidiBus DEFINE_GUIDNAMED(KSMEDIUMSETID_MidiBus)

#define STATIC_KSMEDIUMSETID_VPBus \
    0xA18C15ECL, 0xCE43, 0x11D0, 0xAB, 0xE7, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("A18C15EC-CE43-11D0-ABE7-00A0C9223196", KSMEDIUMSETID_VPBus);
#define KSMEDIUMSETID_VPBus DEFINE_GUIDNAMED(KSMEDIUMSETID_VPBus)

#define STATIC_KSINTERFACESETID_Media \
    0x3A13EB40L, 0x30A7, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3A13EB40-30A7-11D0-A5D6-28DB04C10000", KSINTERFACESETID_Media);
#define KSINTERFACESETID_Media DEFINE_GUIDNAMED(KSINTERFACESETID_Media)

typedef enum {
    KSINTERFACE_MEDIA_MUSIC,                    //Reserved for system use
    KSINTERFACE_MEDIA_WAVE_BUFFERED,            //Reserved for system use
    KSINTERFACE_MEDIA_WAVE_QUEUED
} KSINTERFACE_MEDIA;


#if (NTDDI_VERSION >= NTDDI_WINXP)

#if !defined(INIT_USBAUDIO_MID)
// {4e1cecd2-1679-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_MID(guid, id)\
{\
    (guid)->Data1 = 0x4e1cecd2 + (USHORT)(id);\
    (guid)->Data2 = 0x1679;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}
#define EXTRACT_USBAUDIO_MID(guid)\
    (USHORT)((guid)->Data1 - 0x4e1cecd2)
#define DEFINE_USBAUDIO_MID_GUID(id)\
    0x4e1cecd2+(USHORT)(id), 0x1679, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define INIT_EXBUS_MANUFACTURER_ID INIT_USBAUDIO_MID

#define IS_COMPATIBLE_USBAUDIO_MID(guid)\
    (((guid)->Data1 >= 0x4e1cecd2) &&\
    ((guid)->Data1 < 0x4e1cecd2 + 0xffff) &&\
    ((guid)->Data2 == 0x1679) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_MID)

#if !defined(INIT_USBAUDIO_PID)
// {abcc5a5e-c263-463b-a72f-a5bf64c86eba}
#define INIT_USBAUDIO_PID(guid, id)\
{\
    (guid)->Data1 = 0xabcc5a5e + (USHORT)(id);\
    (guid)->Data2 = 0xc263;\
    (guid)->Data3 = 0x463b;\
    (guid)->Data4[0] = 0xa7;\
    (guid)->Data4[1] = 0x2f;\
    (guid)->Data4[2] = 0xa5;\
    (guid)->Data4[3] = 0xbf;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xc8;\
    (guid)->Data4[6] = 0x6e;\
    (guid)->Data4[7] = 0xba;\
}
#define EXTRACT_USBAUDIO_PID(guid)\
    (USHORT)((guid)->Data1 - 0xabcc5a5e)
#define DEFINE_USBAUDIO_PID_GUID(id)\
    0xabcc5a5e+(USHORT)(id), 0xc263, 0x463b, 0xa7, 0x2f, 0xa5, 0xbf, 0x64, 0xc8, 0x6e, 0xba

#define INIT_EXBUS_PRODUCT_ID INIT_USBAUDIO_PID

#define IS_COMPATIBLE_USBAUDIO_PID(guid)\
    (((guid)->Data1 >= 0xabcc5a5e) &&\
    ((guid)->Data1 < 0xabcc5a5e + 0xffff) &&\
    ((guid)->Data2 == 0xc263) &&\
    ((guid)->Data3 == 0x463b) &&\
    ((guid)->Data4[0] == 0xa7) &&\
    ((guid)->Data4[1] == 0x2f) &&\
    ((guid)->Data4[2] == 0xa5) &&\
    ((guid)->Data4[3] == 0xbf) &&\
    ((guid)->Data4[4] == 0x64) &&\
    ((guid)->Data4[5] == 0xc8) &&\
    ((guid)->Data4[6] == 0x6e) &&\
    ((guid)->Data4[7] == 0xba))
#endif // !defined(INIT_USBAUDIO_PID)

#if !defined(INIT_USBAUDIO_PRODUCT_NAME)
// {FC575048-2E08-463B-A72F-A5BF64C86EBA}
#define INIT_USBAUDIO_PRODUCT_NAME(guid, vid, pid, strIndex)\
{\
    (guid)->Data1 = 0XFC575048 + (USHORT)(vid);\
    (guid)->Data2 = 0x2E08     + (USHORT)(pid);\
    (guid)->Data3 = 0x463B     + (USHORT)(strIndex);\
    (guid)->Data4[0] = 0xA7;\
    (guid)->Data4[1] = 0x2F;\
    (guid)->Data4[2] = 0xA5;\
    (guid)->Data4[3] = 0xBF;\
    (guid)->Data4[4] = 0x64;\
    (guid)->Data4[5] = 0xC8;\
    (guid)->Data4[6] = 0x6E;\
    (guid)->Data4[7] = 0xBA;\
}
#define DEFINE_USBAUDIO_PRODUCT_NAME(vid, pid, strIndex)\
    0xFC575048+(USHORT)(vid), 0x2E08+(USHORT)(pid), 0x463B+(USHORT)(strIndex), 0xA7, 0x2F, 0xA5, 0xBF, 0x64, 0xC8, 0x6E, 0xBA
#endif // !defined(INIT_USBAUDIO_PRODUCT_NAME)

#define INIT_EXBUS_PRODUCT_NAME INIT_USBAUDIO_PRODUCT_NAME

// USB Component ID
#define STATIC_KSCOMPONENTID_USBAUDIO \
    0x8F1275F0, 0x26E9, 0x4264, 0xBA, 0x4D, 0x39, 0xFF, 0xF0, 0x1D, 0x94, 0xAA
DEFINE_GUIDSTRUCT("8F1275F0-26E9-4264-BA4D-39FFF01D94AA", KSCOMPONENTID_USBAUDIO);
#define KSCOMPONENTID_USBAUDIO DEFINE_GUIDNAMED(KSCOMPONENTID_USBAUDIO)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// USB Terminals
#define INIT_USB_TERMINAL(guid, id)\
{\
    (guid)->Data1 = 0xDFF219E0 + (USHORT)(id);\
    (guid)->Data2 = 0xF70F;\
    (guid)->Data3 = 0x11D0;\
    (guid)->Data4[0] = 0xb9;\
    (guid)->Data4[1] = 0x17;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_USB_TERMINAL(guid)\
    (USHORT)((guid)->Data1 - 0xDFF219E0)
#define DEFINE_USB_TERMINAL_GUID(id)\
    0xDFF219E0+(USHORT)(id), 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_KSNODETYPE_INPUT_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0200)
DEFINE_GUIDSTRUCT("DFF21BE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_INPUT_UNDEFINED);
#define KSNODETYPE_INPUT_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_INPUT_UNDEFINED)

#define STATIC_KSNODETYPE_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0201)
DEFINE_GUIDSTRUCT("DFF21BE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE);
#define KSNODETYPE_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE)

#define STATIC_KSNODETYPE_DESKTOP_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0202)
DEFINE_GUIDSTRUCT("DFF21BE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_MICROPHONE);
#define KSNODETYPE_DESKTOP_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_MICROPHONE)

#define STATIC_KSNODETYPE_PERSONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0203)
DEFINE_GUIDSTRUCT("DFF21BE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PERSONAL_MICROPHONE);
#define KSNODETYPE_PERSONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_PERSONAL_MICROPHONE)

#define STATIC_KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0204)
DEFINE_GUIDSTRUCT("DFF21BE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE);
#define KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE DEFINE_GUIDNAMED(KSNODETYPE_OMNI_DIRECTIONAL_MICROPHONE)

#define STATIC_KSNODETYPE_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0205)
DEFINE_GUIDSTRUCT("DFF21BE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MICROPHONE_ARRAY);
#define KSNODETYPE_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_MICROPHONE_ARRAY)

#define STATIC_KSNODETYPE_PROCESSING_MICROPHONE_ARRAY\
    DEFINE_USB_TERMINAL_GUID(0x0206)
DEFINE_GUIDSTRUCT("DFF21BE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PROCESSING_MICROPHONE_ARRAY);
#define KSNODETYPE_PROCESSING_MICROPHONE_ARRAY DEFINE_GUIDNAMED(KSNODETYPE_PROCESSING_MICROPHONE_ARRAY)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR \
    0x830a44f2, 0xa32d, 0x476b,  0xbe, 0x97, 0x42, 0x84, 0x56, 0x73, 0xb3, 0x5a
DEFINE_GUIDSTRUCT("830a44f2-a32d-476b-be97-42845673b35a", KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR);
#define KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_OUTPUT_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0300)
DEFINE_GUIDSTRUCT("DFF21CE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_OUTPUT_UNDEFINED);
#define KSNODETYPE_OUTPUT_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_OUTPUT_UNDEFINED)

#define STATIC_KSNODETYPE_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0301)
DEFINE_GUIDSTRUCT("DFF21CE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKER);
#define KSNODETYPE_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_SPEAKER)

#define STATIC_KSNODETYPE_HEADPHONES\
    DEFINE_USB_TERMINAL_GUID(0x0302)
DEFINE_GUIDSTRUCT("DFF21CE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADPHONES);
#define KSNODETYPE_HEADPHONES DEFINE_GUIDNAMED(KSNODETYPE_HEADPHONES)

#define STATIC_KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0303)
DEFINE_GUIDSTRUCT("DFF21CE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO);
#define KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_HEAD_MOUNTED_DISPLAY_AUDIO)

#define STATIC_KSNODETYPE_DESKTOP_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0304)
DEFINE_GUIDSTRUCT("DFF21CE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DESKTOP_SPEAKER);
#define KSNODETYPE_DESKTOP_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_DESKTOP_SPEAKER)

#define STATIC_KSNODETYPE_ROOM_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0305)
DEFINE_GUIDSTRUCT("DFF21CE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ROOM_SPEAKER);
#define KSNODETYPE_ROOM_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_ROOM_SPEAKER)

#define STATIC_KSNODETYPE_COMMUNICATION_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0306)
DEFINE_GUIDSTRUCT("DFF21CE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_COMMUNICATION_SPEAKER);
#define KSNODETYPE_COMMUNICATION_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_COMMUNICATION_SPEAKER)

#define STATIC_KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER\
    DEFINE_USB_TERMINAL_GUID(0x0307)
DEFINE_GUIDSTRUCT("DFF21CE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER);
#define KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER DEFINE_GUIDNAMED(KSNODETYPE_LOW_FREQUENCY_EFFECTS_SPEAKER)

#define STATIC_KSNODETYPE_BIDIRECTIONAL_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0400)
DEFINE_GUIDSTRUCT("DFF21DE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_BIDIRECTIONAL_UNDEFINED);
#define KSNODETYPE_BIDIRECTIONAL_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_BIDIRECTIONAL_UNDEFINED)

#define STATIC_KSNODETYPE_HANDSET\
    DEFINE_USB_TERMINAL_GUID(0x0401)
DEFINE_GUIDSTRUCT("DFF21DE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HANDSET);
#define KSNODETYPE_HANDSET DEFINE_GUIDNAMED(KSNODETYPE_HANDSET)

#define KSNODETYPE_HEADSET_MICROPHONE   KSNODETYPE_PERSONAL_MICROPHONE
#define KSNODETYPE_HEADSET_SPEAKERS     KSNODETYPE_COMMUNICATION_SPEAKER

#define STATIC_KSNODETYPE_HEADSET\
    DEFINE_USB_TERMINAL_GUID(0x0402)
DEFINE_GUIDSTRUCT("DFF21DE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_HEADSET);
#define KSNODETYPE_HEADSET DEFINE_GUIDNAMED(KSNODETYPE_HEADSET)

#define STATIC_KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION\
    DEFINE_USB_TERMINAL_GUID(0x0403)
DEFINE_GUIDSTRUCT("DFF21DE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION);
#define KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION DEFINE_GUIDNAMED(KSNODETYPE_SPEAKERPHONE_NO_ECHO_REDUCTION)

#define STATIC_KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0404)
DEFINE_GUIDSTRUCT("DFF21DE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_SUPPRESSING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0405)
DEFINE_GUIDSTRUCT("DFF21DE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE);
#define KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE DEFINE_GUIDNAMED(KSNODETYPE_ECHO_CANCELING_SPEAKERPHONE)

#define STATIC_KSNODETYPE_TELEPHONY_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0500)
DEFINE_GUIDSTRUCT("DFF21EE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TELEPHONY_UNDEFINED);
#define KSNODETYPE_TELEPHONY_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_TELEPHONY_UNDEFINED)

#define STATIC_KSNODETYPE_PHONE_LINE\
    DEFINE_USB_TERMINAL_GUID(0x0501)
DEFINE_GUIDSTRUCT("DFF21EE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONE_LINE);
#define KSNODETYPE_PHONE_LINE DEFINE_GUIDNAMED(KSNODETYPE_PHONE_LINE)

#define STATIC_KSNODETYPE_TELEPHONE\
    DEFINE_USB_TERMINAL_GUID(0x0502)
DEFINE_GUIDSTRUCT("DFF21EE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TELEPHONE);
#define KSNODETYPE_TELEPHONE DEFINE_GUIDNAMED(KSNODETYPE_TELEPHONE)

#define STATIC_KSNODETYPE_DOWN_LINE_PHONE\
    DEFINE_USB_TERMINAL_GUID(0x0503)
DEFINE_GUIDSTRUCT("DFF21EE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DOWN_LINE_PHONE);
#define KSNODETYPE_DOWN_LINE_PHONE DEFINE_GUIDNAMED(KSNODETYPE_DOWN_LINE_PHONE)

#define STATIC_KSNODETYPE_EXTERNAL_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0600)
DEFINE_GUIDSTRUCT("DFF21FE0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EXTERNAL_UNDEFINED);
#define KSNODETYPE_EXTERNAL_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_EXTERNAL_UNDEFINED)

#define STATIC_KSNODETYPE_ANALOG_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x601)
DEFINE_GUIDSTRUCT("DFF21FE1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_CONNECTOR);
#define KSNODETYPE_ANALOG_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_CONNECTOR)

#define STATIC_KSNODETYPE_DIGITAL_AUDIO_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0602)
DEFINE_GUIDSTRUCT("DFF21FE2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DIGITAL_AUDIO_INTERFACE);
#define KSNODETYPE_DIGITAL_AUDIO_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_DIGITAL_AUDIO_INTERFACE)

#define STATIC_KSNODETYPE_LINE_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0603)
DEFINE_GUIDSTRUCT("DFF21FE3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LINE_CONNECTOR);
#define KSNODETYPE_LINE_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LINE_CONNECTOR)

#define STATIC_KSNODETYPE_LEGACY_AUDIO_CONNECTOR\
    DEFINE_USB_TERMINAL_GUID(0x0604)
DEFINE_GUIDSTRUCT("DFF21FE4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEGACY_AUDIO_CONNECTOR);
#define KSNODETYPE_LEGACY_AUDIO_CONNECTOR DEFINE_GUIDNAMED(KSNODETYPE_LEGACY_AUDIO_CONNECTOR)

#define STATIC_KSNODETYPE_SPDIF_INTERFACE\
    DEFINE_USB_TERMINAL_GUID(0x0605)
DEFINE_GUIDSTRUCT("DFF21FE5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SPDIF_INTERFACE);
#define KSNODETYPE_SPDIF_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_SPDIF_INTERFACE)

#define STATIC_KSNODETYPE_1394_DA_STREAM\
    DEFINE_USB_TERMINAL_GUID(0x0606)
DEFINE_GUIDSTRUCT("DFF21FE6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DA_STREAM);
#define KSNODETYPE_1394_DA_STREAM DEFINE_GUIDNAMED(KSNODETYPE_1394_DA_STREAM)

#define STATIC_KSNODETYPE_1394_DV_STREAM_SOUNDTRACK\
    DEFINE_USB_TERMINAL_GUID(0x0607)
DEFINE_GUIDSTRUCT("DFF21FE7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_1394_DV_STREAM_SOUNDTRACK);
#define KSNODETYPE_1394_DV_STREAM_SOUNDTRACK DEFINE_GUIDNAMED(KSNODETYPE_1394_DV_STREAM_SOUNDTRACK)

#define STATIC_KSNODETYPE_EMBEDDED_UNDEFINED\
    DEFINE_USB_TERMINAL_GUID(0x0700)
DEFINE_GUIDSTRUCT("DFF220E0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EMBEDDED_UNDEFINED);
#define KSNODETYPE_EMBEDDED_UNDEFINED DEFINE_GUIDNAMED(KSNODETYPE_EMBEDDED_UNDEFINED)

#define STATIC_KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE\
    DEFINE_USB_TERMINAL_GUID(0x0701)
DEFINE_GUIDSTRUCT("DFF220E1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE);
#define KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE DEFINE_GUIDNAMED(KSNODETYPE_LEVEL_CALIBRATION_NOISE_SOURCE)

#define STATIC_KSNODETYPE_EQUALIZATION_NOISE\
    DEFINE_USB_TERMINAL_GUID(0x0702)
DEFINE_GUIDSTRUCT("DFF220E2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_EQUALIZATION_NOISE);
#define KSNODETYPE_EQUALIZATION_NOISE DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZATION_NOISE)

#define STATIC_KSNODETYPE_CD_PLAYER\
    DEFINE_USB_TERMINAL_GUID(0x0703)
DEFINE_GUIDSTRUCT("DFF220E3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CD_PLAYER);
#define KSNODETYPE_CD_PLAYER DEFINE_GUIDNAMED(KSNODETYPE_CD_PLAYER)

#define STATIC_KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0704)
DEFINE_GUIDSTRUCT("DFF220E4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE);
#define KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE DEFINE_GUIDNAMED(KSNODETYPE_DAT_IO_DIGITAL_AUDIO_TAPE)

#define STATIC_KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE\
    DEFINE_USB_TERMINAL_GUID(0x0705)
DEFINE_GUIDSTRUCT("DFF220E5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE);
#define KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE DEFINE_GUIDNAMED(KSNODETYPE_DCC_IO_DIGITAL_COMPACT_CASSETTE)

#define STATIC_KSNODETYPE_MINIDISK\
    DEFINE_USB_TERMINAL_GUID(0x0706)
DEFINE_GUIDSTRUCT("DFF220E6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MINIDISK);
#define KSNODETYPE_MINIDISK DEFINE_GUIDNAMED(KSNODETYPE_MINIDISK)

#define STATIC_KSNODETYPE_ANALOG_TAPE\
    DEFINE_USB_TERMINAL_GUID(0x0707)
DEFINE_GUIDSTRUCT("DFF220E7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_ANALOG_TAPE);
#define KSNODETYPE_ANALOG_TAPE DEFINE_GUIDNAMED(KSNODETYPE_ANALOG_TAPE)

#define STATIC_KSNODETYPE_PHONOGRAPH\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E8-F70F-11D0-B917-00A0C9223196", KSNODETYPE_PHONOGRAPH);
#define KSNODETYPE_PHONOGRAPH DEFINE_GUIDNAMED(KSNODETYPE_PHONOGRAPH)

#define STATIC_KSNODETYPE_VCR_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x0708)
DEFINE_GUIDSTRUCT("DFF220E9-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VCR_AUDIO);
#define KSNODETYPE_VCR_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VCR_AUDIO)

#define STATIC_KSNODETYPE_VIDEO_DISC_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070A)
DEFINE_GUIDSTRUCT("DFF220EA-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_DISC_AUDIO);
#define KSNODETYPE_VIDEO_DISC_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_DISC_AUDIO)

#define STATIC_KSNODETYPE_DVD_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070B)
DEFINE_GUIDSTRUCT("DFF220EB-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DVD_AUDIO);
#define KSNODETYPE_DVD_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DVD_AUDIO)

#define STATIC_KSNODETYPE_TV_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070C)
DEFINE_GUIDSTRUCT("DFF220EC-F70F-11D0-B917-00A0C9223196", KSNODETYPE_TV_TUNER_AUDIO);
#define KSNODETYPE_TV_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_TV_TUNER_AUDIO)

#define STATIC_KSNODETYPE_SATELLITE_RECEIVER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070D)
DEFINE_GUIDSTRUCT("DFF220ED-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SATELLITE_RECEIVER_AUDIO);
#define KSNODETYPE_SATELLITE_RECEIVER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_SATELLITE_RECEIVER_AUDIO)

#define STATIC_KSNODETYPE_CABLE_TUNER_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070E)
DEFINE_GUIDSTRUCT("DFF220EE-F70F-11D0-B917-00A0C9223196", KSNODETYPE_CABLE_TUNER_AUDIO);
#define KSNODETYPE_CABLE_TUNER_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_CABLE_TUNER_AUDIO)

#define STATIC_KSNODETYPE_DSS_AUDIO\
    DEFINE_USB_TERMINAL_GUID(0x070F)
DEFINE_GUIDSTRUCT("DFF220EF-F70F-11D0-B917-00A0C9223196", KSNODETYPE_DSS_AUDIO);
#define KSNODETYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSNODETYPE_DSS_AUDIO)

#define STATIC_KSNODETYPE_RADIO_RECEIVER\
    DEFINE_USB_TERMINAL_GUID(0x0710)
DEFINE_GUIDSTRUCT("DFF220F0-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_RECEIVER);
#define KSNODETYPE_RADIO_RECEIVER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_RECEIVER)

#define STATIC_KSNODETYPE_RADIO_TRANSMITTER\
    DEFINE_USB_TERMINAL_GUID(0x0711)
DEFINE_GUIDSTRUCT("DFF220F1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_RADIO_TRANSMITTER);
#define KSNODETYPE_RADIO_TRANSMITTER DEFINE_GUIDNAMED(KSNODETYPE_RADIO_TRANSMITTER)

#define STATIC_KSNODETYPE_MULTITRACK_RECORDER\
    DEFINE_USB_TERMINAL_GUID(0x0712)
DEFINE_GUIDSTRUCT("DFF220F2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_MULTITRACK_RECORDER);
#define KSNODETYPE_MULTITRACK_RECORDER DEFINE_GUIDNAMED(KSNODETYPE_MULTITRACK_RECORDER)

#define STATIC_KSNODETYPE_SYNTHESIZER\
    DEFINE_USB_TERMINAL_GUID(0x0713)
DEFINE_GUIDSTRUCT("DFF220F3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_SYNTHESIZER);
#define KSNODETYPE_SYNTHESIZER DEFINE_GUIDNAMED(KSNODETYPE_SYNTHESIZER)

#define STATIC_KSNODETYPE_HDMI_INTERFACE\
    0xd1b9cc2a, 0xf519, 0x417f, 0x91, 0xc9, 0x55, 0xfa, 0x65, 0x48, 0x10, 0x01
DEFINE_GUIDSTRUCT("D1B9CC2A-F519-417f-91C9-55FA65481001", KSNODETYPE_HDMI_INTERFACE);
#define KSNODETYPE_HDMI_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_HDMI_INTERFACE)

#define STATIC_KSNODETYPE_DISPLAYPORT_INTERFACE\
    0xe47e4031, 0x3ea6, 0x418d, 0x8f, 0x9b, 0xb7, 0x38, 0x43, 0xcc, 0xba, 0x97
DEFINE_GUIDSTRUCT("E47E4031-3EA6-418d-8F9B-B73843CCBA97", KSNODETYPE_DISPLAYPORT_INTERFACE);
#define KSNODETYPE_DISPLAYPORT_INTERFACE DEFINE_GUIDNAMED(KSNODETYPE_DISPLAYPORT_INTERFACE)

// USB MIDI Nodes
#define STATIC_KSNODETYPE_MIDI_JACK\
    0x265e0c3f, 0xfa39, 0x4df3, 0xab, 0x04, 0xbe, 0x01, 0xb9, 0x1e, 0x29, 0x9a
DEFINE_GUIDSTRUCT("265E0C3F-FA39-4df3-AB04-BE01B91E299A", KSNODETYPE_MIDI_JACK);
#define KSNODETYPE_MIDI_JACK DEFINE_GUIDNAMED(KSNODETYPE_MIDI_JACK)

#define STATIC_KSNODETYPE_MIDI_ELEMENT\
    0x01c6fe66, 0x6e48, 0x4c65, 0xac, 0x9b, 0x52, 0xdb, 0x5d, 0x65, 0x6c, 0x7e
DEFINE_GUIDSTRUCT("01C6FE66-6E48-4c65-AC9B-52DB5D656C7E", KSNODETYPE_MIDI_ELEMENT);
#define KSNODETYPE_MIDI_ELEMENT DEFINE_GUIDNAMED(KSNODETYPE_MIDI_ELEMENT)


// GUID for Spdif Out pin name
#define STATIC_PINNAME_SPDIF_OUT\
    0x3a264481, 0xe52c, 0x4b82, 0x8e, 0x7a, 0xc8, 0xe2, 0xf9, 0x1d, 0xc3, 0x80
DEFINE_GUIDSTRUCT("3A264481-E52C-4b82-8E7A-C8E2F91DC380", PINNAME_SPDIF_OUT);
#define PINNAME_SPDIF_OUT DEFINE_GUIDNAMED(PINNAME_SPDIF_OUT)

// GUID for Spdif In pin name
#define STATIC_PINNAME_SPDIF_IN\
    0x15dc9025, 0x22ad, 0x41b3, 0x88, 0x75, 0xf4, 0xce, 0xb0, 0x29, 0x9e, 0x20
DEFINE_GUIDSTRUCT("15DC9025-22AD-41b3-8875-F4CEB0299E20", PINNAME_SPDIF_IN);
#define PINNAME_SPDIF_IN DEFINE_GUIDNAMED(PINNAME_SPDIF_IN)

// GUID for HDMI Out pin name
#define STATIC_PINNAME_HDMI_OUT\
    0x387bfc03, 0xe7ef, 0x4901, 0x86, 0xe0, 0x35, 0xb7, 0xc3, 0x2b, 0x0, 0xef
DEFINE_GUIDSTRUCT("387BFC03-E7EF-4901-86E0-35B7C32B00EF", PINNAME_HDMI_OUT);
#define PINNAME_HDMI_OUT DEFINE_GUIDNAMED(PINNAME_HDMI_OUT)

// GUID for Display Port Out pin name
#define STATIC_PINNAME_DISPLAYPORT_OUT\
    0x21fbb329, 0x1a4a, 0x48da, 0xa0, 0x76, 0x23, 0x18, 0xa3, 0xc5, 0x9b, 0x26
DEFINE_GUIDSTRUCT("21FBB329-1A4A-48da-A076-2318A3C59B26", PINNAME_DISPLAYPORT_OUT);
#define PINNAME_DISPLAYPORT_OUT DEFINE_GUIDNAMED(PINNAME_DISPLAYPORT_OUT)

#if (NTDDI_VERSION < NTDDI_VISTA)

// Microsoft's WDMAUD virtual swsynth pin name guid

#define STATIC_KSNODETYPE_SWSYNTH\
    0x423274A0L, 0x8B81, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("423274A0-8B81-11D1-A050-0000F8004788", KSNODETYPE_SWSYNTH);
#define KSNODETYPE_SWSYNTH DEFINE_GUIDNAMED(KSNODETYPE_SWSYNTH)

// Microsoft's SWMIDI midi pin and node name guid

#define STATIC_KSNODETYPE_SWMIDI\
    0xCB9BEFA0L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("CB9BEFA0-A251-11D1-A050-0000F8004788", KSNODETYPE_SWMIDI);
#define KSNODETYPE_SWMIDI DEFINE_GUIDNAMED(KSNODETYPE_SWMIDI)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_DRM_DESCRAMBLE\
    0xFFBB6E3FL, 0xCCFE, 0x4D84, 0x90, 0xD9, 0x42, 0x14, 0x18, 0xB0, 0x3A, 0x8E
DEFINE_GUIDSTRUCT("FFBB6E3F-CCFE-4D84-90D9-421418B03A8E", KSNODETYPE_DRM_DESCRAMBLE);
#define KSNODETYPE_DRM_DESCRAMBLE DEFINE_GUIDNAMED(KSNODETYPE_DRM_DESCRAMBLE)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// General categories
#define STATIC_KSCATEGORY_AUDIO \
    0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD04-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_AUDIO);
#define KSCATEGORY_AUDIO DEFINE_GUIDNAMED(KSCATEGORY_AUDIO)

#define STATIC_KSCATEGORY_VIDEO \
    0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD05-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_VIDEO);
#define KSCATEGORY_VIDEO DEFINE_GUIDNAMED(KSCATEGORY_VIDEO)

#if (NTDDI_VERSION >= NTDDI_VISTA)
#define STATIC_KSCATEGORY_REALTIME \
    0xEB115FFCL, 0x10C8, 0x4964, 0x83, 0x1D, 0x6D, 0xCB, 0x02, 0xE6, 0xF2, 0x3F
DEFINE_GUIDSTRUCT("EB115FFC-10C8-4964-831D-6DCB02E6F23F", KSCATEGORY_REALTIME);
#define KSCATEGORY_REALTIME DEFINE_GUIDNAMED(KSCATEGORY_REALTIME)
#endif

#define STATIC_KSCATEGORY_TEXT \
    0x6994AD06L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("6994AD06-93EF-11D0-A3CC-00A0C9223196", KSCATEGORY_TEXT);
#define KSCATEGORY_TEXT DEFINE_GUIDNAMED(KSCATEGORY_TEXT)

#define STATIC_KSCATEGORY_NETWORK \
    0x67C9CC3CL, 0x69C4, 0x11D2, 0x87, 0x59, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("67C9CC3C-69C4-11D2-8759-00A0C9223196", KSCATEGORY_NETWORK);
#define KSCATEGORY_NETWORK DEFINE_GUIDNAMED(KSCATEGORY_NETWORK)

#define STATIC_KSCATEGORY_TOPOLOGY \
    0xDDA54A40L, 0x1E4C, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("DDA54A40-1E4C-11D1-A050-405705C10000", KSCATEGORY_TOPOLOGY);
#define KSCATEGORY_TOPOLOGY DEFINE_GUIDNAMED(KSCATEGORY_TOPOLOGY)

#define STATIC_KSCATEGORY_VIRTUAL \
    0x3503EAC4L, 0x1F26, 0x11D1, 0x8A, 0xB0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("3503EAC4-1F26-11D1-8AB0-00A0C9223196", KSCATEGORY_VIRTUAL);
#define KSCATEGORY_VIRTUAL DEFINE_GUIDNAMED(KSCATEGORY_VIRTUAL)

#define STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL \
    0xBF963D80L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("BF963D80-C559-11D0-8A2B-00A0C9255AC1", KSCATEGORY_ACOUSTIC_ECHO_CANCEL);
#define KSCATEGORY_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSCATEGORY_ACOUSTIC_ECHO_CANCEL)

#if (NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_SYSAUDIO \
    0xA7C7A5B1L, 0x5AF3, 0x11D1, 0x9C, 0xED, 0x00, 0xA0, 0x24, 0xBF, 0x04, 0x07
DEFINE_GUIDSTRUCT("A7C7A5B1-5AF3-11D1-9CED-00A024BF0407", KSCATEGORY_SYSAUDIO);
#define KSCATEGORY_SYSAUDIO DEFINE_GUIDNAMED(KSCATEGORY_SYSAUDIO)

#define STATIC_KSCATEGORY_WDMAUD \
    0x3E227E76L, 0x690D, 0x11D2, 0x81, 0x61, 0x00, 0x00, 0xF8, 0x77, 0x5B, 0xF1
DEFINE_GUIDSTRUCT("3E227E76-690D-11D2-8161-0000F8775BF1", KSCATEGORY_WDMAUD);
#define KSCATEGORY_WDMAUD DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_AUDIO_GFX \
    0x9BAF9572L, 0x340C, 0x11D3, 0xAB, 0xDC, 0x00, 0xA0, 0xC9, 0x0A, 0xB1, 0x6F
DEFINE_GUIDSTRUCT("9BAF9572-340C-11D3-ABDC-00A0C90AB16F", KSCATEGORY_AUDIO_GFX);
#define KSCATEGORY_AUDIO_GFX DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_GFX)

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_AUDIO_SPLITTER \
    0x9EA331FAL, 0xB91B, 0x45F8, 0x92, 0x85, 0xBD, 0x2B, 0xC7, 0x7A, 0xFC, 0xDE
DEFINE_GUIDSTRUCT("9EA331FA-B91B-45F8-9285-BD2BC77AFCDE", KSCATEGORY_AUDIO_SPLITTER);
#define KSCATEGORY_AUDIO_SPLITTER DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_SPLITTER)

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_SYNTHESIZER STATIC_KSNODETYPE_SYNTHESIZER
#define KSCATEGORY_SYNTHESIZER KSNODETYPE_SYNTHESIZER

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSCATEGORY_DRM_DESCRAMBLE STATIC_KSNODETYPE_DRM_DESCRAMBLE
#define KSCATEGORY_DRM_DESCRAMBLE KSNODETYPE_DRM_DESCRAMBLE

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_VISTA)

#define STATIC_KSCATEGORY_AUDIO_DEVICE \
    0xFBF6F530L, 0x07B9, 0x11D2, 0xA7, 0x1E, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("FBF6F530-07B9-11D2-A71E-0000F8004788", KSCATEGORY_AUDIO_DEVICE);
#define KSCATEGORY_AUDIO_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_AUDIO_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEOUT_DEVICE \
    0xD6C5066EL, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C5066E-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEOUT_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEOUT_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_WAVEIN_DEVICE \
    0xD6C50671L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50671-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_WAVEIN_DEVICE);
#define KSCATEGORY_PREFERRED_WAVEIN_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_WAVEIN_DEVICE)

#define STATIC_KSCATEGORY_PREFERRED_MIDIOUT_DEVICE \
    0xD6C50674L, 0x72C1, 0x11D2, 0x97, 0x55, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("D6C50674-72C1-11D2-9755-0000F8004788", KSCATEGORY_PREFERRED_MIDIOUT_DEVICE);
#define KSCATEGORY_PREFERRED_MIDIOUT_DEVICE DEFINE_GUIDNAMED(KSCATEGORY_PREFERRED_MIDIOUT_DEVICE)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

// Special pin category for wdmaud

#define STATIC_KSCATEGORY_WDMAUD_USE_PIN_NAME \
    0x47A4FA20L, 0xA251, 0x11D1, 0xA0, 0x50, 0x00, 0x00, 0xF8, 0x00, 0x47, 0x88
DEFINE_GUIDSTRUCT("47A4FA20-A251-11D1-A050-0000F8004788", KSCATEGORY_WDMAUD_USE_PIN_NAME);
#define KSCATEGORY_WDMAUD_USE_PIN_NAME DEFINE_GUIDNAMED(KSCATEGORY_WDMAUD_USE_PIN_NAME)

// Escalante Platform Interface

#define STATIC_KSCATEGORY_ESCALANTE_PLATFORM_DRIVER \
    0x74f3aea8L, 0x9768, 0x11d1, 0x8e, 0x07, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e
DEFINE_GUIDSTRUCT("74f3aea8-9768-11d1-8e07-00a0c95ec22e", KSCATEGORY_ESCALANTE_PLATFORM_DRIVER);
#define KSCATEGORY_ESCALANTE_PLATFORM_DRIVER DEFINE_GUIDNAMED(KSCATEGORY_ESCALANTE_PLATFORM_DRIVER)

// -- major types ---

// 'vids' == MEDIATYPE_Video,
#define STATIC_KSDATAFORMAT_TYPE_VIDEO\
    0x73646976L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73646976-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_VIDEO);
#define KSDATAFORMAT_TYPE_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VIDEO)

// 'auds' == MEDIATYPE_Audio
#define STATIC_KSDATAFORMAT_TYPE_AUDIO\
    0x73647561L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73647561-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_AUDIO);
#define KSDATAFORMAT_TYPE_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUDIO)

// 'txts' == MEDIATYPE_Text
#define STATIC_KSDATAFORMAT_TYPE_TEXT\
    0x73747874L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("73747874-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_TEXT);
#define KSDATAFORMAT_TYPE_TEXT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_TEXT)

#if !defined( DEFINE_WAVEFORMATEX_GUID )
#define DEFINE_WAVEFORMATEX_GUID(x) (USHORT)(x), 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
#endif

#if !defined( STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX )
#define STATIC_KSDATAFORMAT_SUBTYPE_WAVEFORMATEX\
    0x00000000L, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000000-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_WAVEFORMATEX);
#define KSDATAFORMAT_SUBTYPE_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_WAVEFORMATEX)
#endif

#if !defined( INIT_WAVEFORMATEX_GUID )
#define INIT_WAVEFORMATEX_GUID(Guid, x)\
{\
    *(Guid) = KSDATAFORMAT_SUBTYPE_WAVEFORMATEX;\
    (Guid)->Data1 = (USHORT)(x);\
}
#endif

#if !defined( EXTRACT_WAVEFORMATEX_ID )
#define EXTRACT_WAVEFORMATEX_ID(Guid)\
    (USHORT)((Guid)->Data1)
#endif

#if !defined( IS_VALID_WAVEFORMATEX_GUID )
#define IS_VALID_WAVEFORMATEX_GUID(Guid)\
    (!memcmp(((PUSHORT)&KSDATAFORMAT_SUBTYPE_WAVEFORMATEX) + 1, ((PUSHORT)(Guid)) + 1, sizeof(GUID) - sizeof(USHORT)))
#endif

#if !defined(INIT_MMREG_MID)
//{d5a47fa7-6d98-11d1-a21a-00a0c9223196}
#define INIT_MMREG_MID(guid, id)\
{\
    (guid)->Data1 = 0xd5a47fa7 + (USHORT)(id);\
    (guid)->Data2 = 0x6d98;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_MID(guid)\
    (USHORT)((guid)->Data1 - 0xd5a47fa7)
#define DEFINE_MMREG_MID_GUID(id)\
    0xd5a47fa7+(USHORT)(id), 0x6d98, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_MID(guid)\
    (((guid)->Data1 >= 0xd5a47fa7) &&\
    ((guid)->Data1 < 0xd5a47fa7 + 0xffff) &&\
    ((guid)->Data2 == 0x6d98) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_MID)

#if !defined(INIT_MMREG_PID)
//{e36dc2ac-6d9a-11d1-a21a-00a0c9223196}
#define INIT_MMREG_PID(guid, id)\
{\
    (guid)->Data1 = 0xe36dc2ac + (USHORT)(id);\
    (guid)->Data2 = 0x6d9a;\
    (guid)->Data3 = 0x11d1;\
    (guid)->Data4[0] = 0xa2;\
    (guid)->Data4[1] = 0x1a;\
    (guid)->Data4[2] = 0x00;\
    (guid)->Data4[3] = 0xa0;\
    (guid)->Data4[4] = 0xc9;\
    (guid)->Data4[5] = 0x22;\
    (guid)->Data4[6] = 0x31;\
    (guid)->Data4[7] = 0x96;\
}
#define EXTRACT_MMREG_PID(guid)\
    (USHORT)((guid)->Data1 - 0xe36dc2ac)
#define DEFINE_MMREG_PID_GUID(id)\
    0xe36dc2ac+(USHORT)(id), 0x6d9a, 0x11d1, 0xa2, 0x1a, 0x00, 0xa0, 0xc9, 0x22, 0x31, 0x96

#define IS_COMPATIBLE_MMREG_PID(guid)\
    (((guid)->Data1 >= 0xe36dc2ac) &&\
    ((guid)->Data1 < 0xe36dc2ac + 0xffff) &&\
    ((guid)->Data2 == 0x6d9a) &&\
    ((guid)->Data3 == 0x11d1) &&\
    ((guid)->Data4[0] == 0xa2) &&\
    ((guid)->Data4[1] == 0x1a) &&\
    ((guid)->Data4[2] == 0x00) &&\
    ((guid)->Data4[3] == 0xa0) &&\
    ((guid)->Data4[4] == 0xc9) &&\
    ((guid)->Data4[5] == 0x22) &&\
    ((guid)->Data4[6] == 0x31) &&\
    ((guid)->Data4[7] == 0x96))
#endif // !defined(INIT_MMREG_PID)

#define STATIC_KSDATAFORMAT_SUBTYPE_ANALOG\
    0x6dba3190L, 0x67bd, 0x11cf, 0xa0, 0xf7, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("6dba3190-67bd-11cf-a0f7-0020afd156e4", KSDATAFORMAT_SUBTYPE_ANALOG);
#define KSDATAFORMAT_SUBTYPE_ANALOG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ANALOG)

#if !defined( STATIC_KSDATAFORMAT_SUBTYPE_PCM )
#define STATIC_KSDATAFORMAT_SUBTYPE_PCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_PCM)
DEFINE_GUIDSTRUCT("00000001-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_PCM);
#define KSDATAFORMAT_SUBTYPE_PCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_PCM)
#endif

#if defined(_INC_MMREG)
#if !defined( STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT )
#define STATIC_KSDATAFORMAT_SUBTYPE_IEEE_FLOAT\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_IEEE_FLOAT)
DEFINE_GUIDSTRUCT("00000003-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEEE_FLOAT);
#define KSDATAFORMAT_SUBTYPE_IEEE_FLOAT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSDATAFORMAT_SUBTYPE_DRM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DRM)
DEFINE_GUIDSTRUCT("00000009-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_DRM);
#define KSDATAFORMAT_SUBTYPE_DRM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DRM)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSDATAFORMAT_SUBTYPE_ALAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ALAW)
DEFINE_GUIDSTRUCT("00000006-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ALAW);
#define KSDATAFORMAT_SUBTYPE_ALAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ALAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_MULAW\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MULAW)
DEFINE_GUIDSTRUCT("00000007-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MULAW);
#define KSDATAFORMAT_SUBTYPE_MULAW DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MULAW)

#define STATIC_KSDATAFORMAT_SUBTYPE_ADPCM\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_ADPCM)
DEFINE_GUIDSTRUCT("00000002-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_ADPCM);
#define KSDATAFORMAT_SUBTYPE_ADPCM DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_ADPCM)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_MPEG)
DEFINE_GUIDSTRUCT("00000050-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_MPEG);
#define KSDATAFORMAT_SUBTYPE_MPEG DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG)
#endif // defined(_INC_MMREG)

#define STATIC_KSDATAFORMAT_SPECIFIER_VC_ID\
    0xAD98D184L, 0xAAC3, 0x11D0, 0xA4, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("AD98D184-AAC3-11D0-A41C-00A0C9223196", KSDATAFORMAT_SPECIFIER_VC_ID);
#define KSDATAFORMAT_SPECIFIER_VC_ID DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VC_ID)

#define STATIC_KSDATAFORMAT_SPECIFIER_WAVEFORMATEX\
    0x05589f81L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f81-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_WAVEFORMATEX);
#define KSDATAFORMAT_SPECIFIER_WAVEFORMATEX DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_WAVEFORMATEX)

#define STATIC_KSDATAFORMAT_SPECIFIER_DSOUND\
    0x518590a2L, 0xa184, 0x11d0, 0x85, 0x22, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("518590a2-a184-11d0-8522-00c04fd9baf3", KSDATAFORMAT_SPECIFIER_DSOUND);
#define KSDATAFORMAT_SPECIFIER_DSOUND DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DSOUND)

#if defined(_INC_MMSYSTEM) || defined(_INC_MMREG)
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct {
    KSDATAFORMAT    DataFormat;
    WAVEFORMATEX    WaveFormatEx;
} KSDATAFORMAT_WAVEFORMATEX, *PKSDATAFORMAT_WAVEFORMATEX;

#ifndef _WAVEFORMATEXTENSIBLE_
#define _WAVEFORMATEXTENSIBLE_
typedef struct {
    WAVEFORMATEX    Format;
    union {
        WORD wValidBitsPerSample;       /* bits of precision  */
        WORD wSamplesPerBlock;          /* valid if wBitsPerSample==0 */
        WORD wReserved;                 /* If neither applies, set to zero. */
    } Samples;
    DWORD           dwChannelMask;      /* which channels are */
                                        /* present in stream  */
    GUID            SubFormat;
} WAVEFORMATEXTENSIBLE, *PWAVEFORMATEXTENSIBLE;
#endif // !_WAVEFORMATEXTENSIBLE_

#ifndef _WAVEFORMATEXTENSIBLE_IEC61937_
#define _WAVEFORMATEXTENSIBLE_IEC61937_
typedef struct {
    WAVEFORMATEXTENSIBLE  FormatExt;    /* Format of encoded data as it is */
                                        /* intended to be streamed over the link */
    DWORD   dwEncodedSamplesPerSec;     /* Sampling rate of the post-decode audio. */
    DWORD   dwEncodedChannelCount;      /* Channel count of the post-decode audio. */
    DWORD   dwAverageBytesPerSec;       /* Byte rate of the content, can be 0. */
} WAVEFORMATEXTENSIBLE_IEC61937, *PWAVEFORMATEXTENSIBLE_IEC61937;
#endif // !_WAVEFORMATEXTENSIBLE_IEC61937_

#if !defined(WAVE_FORMAT_EXTENSIBLE)
#define  WAVE_FORMAT_EXTENSIBLE                 0xFFFE
#endif // !defined(WAVE_FORMAT_EXTENSIBLE)

// DirectSound buffer description
typedef struct {
    ULONG               Flags;
    ULONG               Control;
    WAVEFORMATEX        WaveFormatEx;
} KSDSOUND_BUFFERDESC, *PKSDSOUND_BUFFERDESC;

// DirectSound format
typedef struct {
    KSDATAFORMAT        DataFormat;
    KSDSOUND_BUFFERDESC BufferDesc;
} KSDATAFORMAT_DSOUND, *PKSDATAFORMAT_DSOUND;

#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif
#endif // defined(_INC_MMSYSTEM) || defined(_INC_MMREG)



// DirectSound buffer flags
#define KSDSOUND_BUFFER_PRIMARY             0x00000001
#define KSDSOUND_BUFFER_STATIC              0x00000002
#define KSDSOUND_BUFFER_LOCHARDWARE         0x00000004
#define KSDSOUND_BUFFER_LOCSOFTWARE         0x00000008

// DirectSound buffer control flags
#define KSDSOUND_BUFFER_CTRL_3D             0x00000001
#define KSDSOUND_BUFFER_CTRL_FREQUENCY      0x00000002
#define KSDSOUND_BUFFER_CTRL_PAN            0x00000004
#define KSDSOUND_BUFFER_CTRL_VOLUME         0x00000008
#define KSDSOUND_BUFFER_CTRL_POSITIONNOTIFY 0x00000010

typedef struct {
#if defined(_NTDDK_)
    ULONGLONG        PlayOffset;
    ULONGLONG        WriteOffset;
#else // !_NTDDK_
    DWORDLONG        PlayOffset;
    DWORDLONG        WriteOffset;
#endif // !_NTDDK_
} KSAUDIO_POSITION, *PKSAUDIO_POSITION;

//===========================================================================
// Microphone array pin descriptor

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef enum {
    KSMICARRAY_MICTYPE_OMNIDIRECTIONAL,
    KSMICARRAY_MICTYPE_SUBCARDIOID,
    KSMICARRAY_MICTYPE_CARDIOID,
    KSMICARRAY_MICTYPE_SUPERCARDIOID,
    KSMICARRAY_MICTYPE_HYPERCARDIOID,
    KSMICARRAY_MICTYPE_8SHAPED,
    KSMICARRAY_MICTYPE_VENDORDEFINED = 0x0F
} KSMICARRAY_MICTYPE;

typedef struct {
        USHORT usType;           // Type of Microphone
        SHORT  wXCoord;          // X Coordinate of Mic
        SHORT  wYCoord;          // Y Coordinate of Mic
        SHORT  wZCoord;          // Z Coordinate of Mic
        SHORT  wVerticalAngle;   // MRA Vertical Angle
        SHORT  wHorizontalAngle; // MRA Horizontal Angle
} KSAUDIO_MICROPHONE_COORDINATES, *PKSAUDIO_MICROPHONE_COORDINATES;

typedef enum {
    KSMICARRAY_MICARRAYTYPE_LINEAR,
    KSMICARRAY_MICARRAYTYPE_PLANAR,
    KSMICARRAY_MICARRAYTYPE_3D
} KSMICARRAY_MICARRAYTYPE;

typedef struct {
        USHORT usVersion;             // Version of Mic array specification (0x0100)
        USHORT usMicArrayType;        // Type of Mic Array
        SHORT  wVerticalAngleBegin;   // Work Volume Vertical Angle Begin
        SHORT  wVerticalAngleEnd;     // Work Volume Vertical Angle End
        SHORT  wHorizontalAngleBegin; // Work Volume HorizontalAngle Begin
        SHORT  wHorizontalAngleEnd;   // Work Volume HorizontalAngle End
        USHORT usFrequencyBandLo;     // Low end of Freq Range
        USHORT usFrequencyBandHi;     // High end of Freq Range
        
        USHORT usNumberOfMicrophones;  // Count of microphone 
                                   // coordinate structures 
                                   // to follow.

        KSAUDIO_MICROPHONE_COORDINATES KsMicCoord[1]; // Array of Microphone 
                                                  // Coordinate structures
} KSAUDIO_MIC_ARRAY_GEOMETRY, *PKSAUDIO_MIC_ARRAY_GEOMETRY;

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//===========================================================================
// DirectSound3D HAL


typedef struct _DS3DVECTOR {
    union {
        FLOAT x;
        FLOAT dvX;
    };
    union {
        FLOAT y;
        FLOAT dvY;
    };
    union {
        FLOAT z;
        FLOAT dvZ;
    };
} DS3DVECTOR, *PDS3DVECTOR;


//===========================================================================
//===========================================================================

// KSPROPSETID_DirectSound3DListener : {437B3414-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_KSPROPSETID_DirectSound3DListener\
    0x437b3414L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3414-d060-11d0-8583-00c04fd9baf3",KSPROPSETID_DirectSound3DListener);
#define KSPROPSETID_DirectSound3DListener DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DListener)

typedef enum {
    KSPROPERTY_DIRECTSOUND3DLISTENER_ALL,
    KSPROPERTY_DIRECTSOUND3DLISTENER_POSITION,
    KSPROPERTY_DIRECTSOUND3DLISTENER_VELOCITY,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ORIENTATION,
    KSPROPERTY_DIRECTSOUND3DLISTENER_DISTANCEFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ROLLOFFFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_DOPPLERFACTOR,
    KSPROPERTY_DIRECTSOUND3DLISTENER_BATCH,
    KSPROPERTY_DIRECTSOUND3DLISTENER_ALLOCATION
} KSPROPERTY_DIRECTSOUND3DLISTENER;

typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    DS3DVECTOR  OrientFront;
    DS3DVECTOR  OrientTop;
    FLOAT       DistanceFactor;
    FLOAT       RolloffFactor;
    FLOAT       DopplerFactor;
} KSDS3D_LISTENER_ALL, *PKSDS3D_LISTENER_ALL;

typedef struct {
    DS3DVECTOR  Front;
    DS3DVECTOR  Top;
} KSDS3D_LISTENER_ORIENTATION, *PKSDS3D_LISTENER_ORIENTATION;


//===========================================================================
//===========================================================================
// KSPROPSETID_DirectSound3DBuffer : {437B3411-D060-11d0-8583-00C04FD9BAF3}

#define STATIC_KSPROPSETID_DirectSound3DBuffer\
    0x437b3411L, 0xd060, 0x11d0, 0x85, 0x83, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("437b3411-d060-11d0-8583-00c04fd9baf3", KSPROPSETID_DirectSound3DBuffer);
#define KSPROPSETID_DirectSound3DBuffer DEFINE_GUIDNAMED(KSPROPSETID_DirectSound3DBuffer)


typedef enum {
    KSPROPERTY_DIRECTSOUND3DBUFFER_ALL,
    KSPROPERTY_DIRECTSOUND3DBUFFER_POSITION,
    KSPROPERTY_DIRECTSOUND3DBUFFER_VELOCITY,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEANGLES,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEORIENTATION,
    KSPROPERTY_DIRECTSOUND3DBUFFER_CONEOUTSIDEVOLUME,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MINDISTANCE,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MAXDISTANCE,
    KSPROPERTY_DIRECTSOUND3DBUFFER_MODE
} KSPROPERTY_DIRECTSOUND3DBUFFER;


typedef struct {
    DS3DVECTOR  Position;
    DS3DVECTOR  Velocity;
    ULONG       InsideConeAngle;
    ULONG       OutsideConeAngle;
    DS3DVECTOR  ConeOrientation;
    LONG        ConeOutsideVolume;
    FLOAT       MinDistance;
    FLOAT       MaxDistance;
    ULONG       Mode;
} KSDS3D_BUFFER_ALL, *PKSDS3D_BUFFER_ALL;

typedef struct {
    ULONG  InsideConeAngle;
    ULONG  OutsideConeAngle;
} KSDS3D_BUFFER_CONE_ANGLES, *PKSDS3D_BUFFER_CONE_ANGLES;

#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_HEADPHONE   (-1)
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MIN         5
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_NARROW      10
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_WIDE        20
#define KSAUDIO_STEREO_SPEAKER_GEOMETRY_MAX         180

#define KSDSOUND_3D_MODE_NORMAL          0x00000000
#define KSDSOUND_3D_MODE_HEADRELATIVE    0x00000001
#define KSDSOUND_3D_MODE_DISABLE         0x00000002

//===========================================================================
// Definitions intended for hardware acceleration of the HRTF 3D algorithm
//===========================================================================

#define KSDSOUND_BUFFER_CTRL_HRTF_3D        0x40000000

typedef struct {
    ULONG                   Size;           // This is the size of the struct in bytes
    ULONG                   Enabled;
    BOOL                    SwapChannels;
    BOOL                    ZeroAzimuth;
    BOOL                    CrossFadeOutput;
    ULONG                   FilterSize;     // This is the additional size of the filter coeff in bytes
} KSDS3D_HRTF_PARAMS_MSG, *PKSDS3D_HRTF_PARAMS_MSG;

// HRTF filter quality levels
typedef enum {
    FULL_FILTER,
    LIGHT_FILTER,
    KSDS3D_FILTER_QUALITY_COUNT
} KSDS3D_HRTF_FILTER_QUALITY;

typedef struct {
    ULONG                       Size;       // This is the size of the struct in bytes
    KSDS3D_HRTF_FILTER_QUALITY  Quality;
    FLOAT                       SampleRate;
    ULONG                       MaxFilterSize;
    ULONG                       FilterTransientMuteLength;
    ULONG                       FilterOverlapBufferLength;
    ULONG                       OutputOverlapBufferLength;
    ULONG                       Reserved;
} KSDS3D_HRTF_INIT_MSG, *PKSDS3D_HRTF_INIT_MSG;

// Coefficient formats
typedef enum {
    FLOAT_COEFF,
    SHORT_COEFF,
    KSDS3D_COEFF_COUNT
} KSDS3D_HRTF_COEFF_FORMAT;

// Filter methods
typedef enum {
    DIRECT_FORM,
    CASCADE_FORM,
    KSDS3D_FILTER_METHOD_COUNT
} KSDS3D_HRTF_FILTER_METHOD;

// Filter methods
typedef enum {
    DS3D_HRTF_VERSION_1
} KSDS3D_HRTF_FILTER_VERSION;

typedef struct {
    KSDS3D_HRTF_FILTER_METHOD    FilterMethod;
    KSDS3D_HRTF_COEFF_FORMAT     CoeffFormat;
    KSDS3D_HRTF_FILTER_VERSION   Version;
    ULONG                        Reserved;
} KSDS3D_HRTF_FILTER_FORMAT_MSG, *PKSDS3D_HRTF_FILTER_FORMAT_MSG;

#define STATIC_KSPROPSETID_Hrtf3d\
    0xb66decb0L, 0xa083, 0x11d0, 0x85, 0x1e, 0x00, 0xc0, 0x4f, 0xd9, 0xba, 0xf3
DEFINE_GUIDSTRUCT("b66decb0-a083-11d0-851e-00c04fd9baf3", KSPROPSETID_Hrtf3d);
#define KSPROPSETID_Hrtf3d DEFINE_GUIDNAMED(KSPROPSETID_Hrtf3d)

typedef enum {
    KSPROPERTY_HRTF3D_PARAMS = 0,
    KSPROPERTY_HRTF3D_INITIALIZE,
    KSPROPERTY_HRTF3D_FILTER_FORMAT
} KSPROPERTY_HRTF3D;


//===========================================================================
// Definitions related to the obsolete Interaural Time Delay 3D algorithm
//===========================================================================

// DirectSound3D FIR context
typedef struct {
    LONG                Channel;
    FLOAT               VolSmoothScale;
    FLOAT               TotalDryAttenuation;
    FLOAT               TotalWetAttenuation;
    LONG                SmoothFrequency;
    LONG                Delay;
} KSDS3D_ITD_PARAMS, *PKSDS3D_ITD_PARAMS;

typedef struct {
    ULONG                 Enabled;
    KSDS3D_ITD_PARAMS     LeftParams;
    KSDS3D_ITD_PARAMS     RightParams;
    ULONG                 Reserved;
} KSDS3D_ITD_PARAMS_MSG, *PKSDS3D_ITD_PARAMS_MSG;

#define STATIC_KSPROPSETID_Itd3d\
    0x6429f090L, 0x9fd9, 0x11d0, 0xa7, 0x5b, 0x00, 0xa0, 0xc9, 0x03, 0x65, 0xe3
DEFINE_GUIDSTRUCT("6429f090-9fd9-11d0-a75b-00a0c90365e3", KSPROPSETID_Itd3d);
#define KSPROPSETID_Itd3d DEFINE_GUIDNAMED(KSPROPSETID_Itd3d)

typedef enum {
    KSPROPERTY_ITD3D_PARAMS = 0
} KSPROPERTY_ITD3D;


typedef struct {
   KSDATARANGE              DataRange;
   ULONG                    MaximumChannels;
   ULONG                    MinimumBitsPerSample;
   ULONG                    MaximumBitsPerSample;
   ULONG                    MinimumSampleFrequency;
   ULONG                    MaximumSampleFrequency;
} KSDATARANGE_AUDIO, *PKSDATARANGE_AUDIO;

//---------------------------------------------------------------------------

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFF\
    0x4995DAEEL, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAEE-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFF);
#define KSDATAFORMAT_SUBTYPE_RIFF DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFF)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFWAVE\
    0xe436eb8bL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb8b-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_RIFFWAVE);
#define KSDATAFORMAT_SUBTYPE_RIFFWAVE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFWAVE)

//===========================================================================
//===========================================================================

#define STATIC_KSPROPSETID_Bibliographic \
    0x07BA150EL, 0xE2B1, 0x11D0, 0xAC, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("07BA150E-E2B1-11D0-AC17-00A0C9223196", KSPROPSETID_Bibliographic);
#define KSPROPSETID_Bibliographic DEFINE_GUIDNAMED(KSPROPSETID_Bibliographic)

//Repeatable tags contain all entries within the property, each preceeded by length
typedef enum {
    KSPROPERTY_BIBLIOGRAPHIC_LEADER = 'RDL ',
    KSPROPERTY_BIBLIOGRAPHIC_LCCN = '010 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISBN = '020 ',
    KSPROPERTY_BIBLIOGRAPHIC_ISSN = '220 ',
    KSPROPERTY_BIBLIOGRAPHIC_CATALOGINGSOURCE = '040 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINPERSONALNAME = '001 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINCORPORATEBODY = '011 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINMEETINGNAME = '111 ',
    KSPROPERTY_BIBLIOGRAPHIC_MAINUNIFORMTITLE = '031 ',
    KSPROPERTY_BIBLIOGRAPHIC_UNIFORMTITLE = '042 ',
    KSPROPERTY_BIBLIOGRAPHIC_TITLESTATEMENT = '542 ',
    KSPROPERTY_BIBLIOGRAPHIC_VARYINGFORMTITLE = '642 ',
    KSPROPERTY_BIBLIOGRAPHIC_PUBLICATION = '062 ',
    KSPROPERTY_BIBLIOGRAPHIC_PHYSICALDESCRIPTION = '003 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTITLE = '044 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENT = '094 ',
    KSPROPERTY_BIBLIOGRAPHIC_GENERALNOTE = '005 ',
    KSPROPERTY_BIBLIOGRAPHIC_BIBLIOGRAPHYNOTE = '405 ',
    KSPROPERTY_BIBLIOGRAPHIC_CONTENTSNOTE = '505 ',
    KSPROPERTY_BIBLIOGRAPHIC_CREATIONCREDIT = '805 ',
    KSPROPERTY_BIBLIOGRAPHIC_CITATION = '015 ',
    KSPROPERTY_BIBLIOGRAPHIC_PARTICIPANT = '115 ',
    KSPROPERTY_BIBLIOGRAPHIC_SUMMARY = '025 ',
    KSPROPERTY_BIBLIOGRAPHIC_TARGETAUDIENCE = '125 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDFORMAVAILABLE = '035 ',
    KSPROPERTY_BIBLIOGRAPHIC_SYSTEMDETAILS = '835 ',
    KSPROPERTY_BIBLIOGRAPHIC_AWARDS = '685 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYPERSONALNAME = '006 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYTOPICALTERM = '056 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYGEOGRAPHIC = '156 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMGENRE = '556 ',
    KSPROPERTY_BIBLIOGRAPHIC_INDEXTERMCURRICULUM = '856 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYUNIFORMTITLE = '037 ',
    KSPROPERTY_BIBLIOGRAPHIC_ADDEDENTRYRELATED = '047 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTPERSONALNAME = '008 ',
    KSPROPERTY_BIBLIOGRAPHIC_SERIESSTATEMENTUNIFORMTITLE = '038 '
} KSPROPERTY_BIBLIOGRAPHIC;

#define STATIC_KSPROPSETID_TopologyNode\
    0x45FFAAA1L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA1-6E1B-11D0-BCF2-444553540000", KSPROPSETID_TopologyNode);
#define KSPROPSETID_TopologyNode DEFINE_GUIDNAMED(KSPROPSETID_TopologyNode)

typedef enum {
    KSPROPERTY_TOPOLOGYNODE_ENABLE = 1
#if (NTDDI_VERSION >= NTDDI_WINXP)
    , KSPROPERTY_TOPOLOGYNODE_RESET
#endif // (NTDDI_VERSION >= NTDDI_WINXP)
} KSPROPERTY_TOPOLOGYNODE;

//===========================================================================

#if (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(_NTDDK_)
typedef NTSTATUS (CALLBACK *PRTAUDIOGETPOSITION)(__in PFILE_OBJECT PinFileObject,
                                                 __out PUCHAR *ppPlayPosition,
                                                 __out PLONG plOffset);
#endif // defined(_NTDDK_)

#define STATIC_KSPROPSETID_RtAudio\
    0xa855a48c, 0x2f78, 0x4729, 0x90, 0x51, 0x19, 0x68, 0x74, 0x6b, 0x9e, 0xef
DEFINE_GUIDSTRUCT("A855A48C-2F78-4729-9051-1968746B9EEF", KSPROPSETID_RtAudio);
#define KSPROPSETID_RtAudio DEFINE_GUIDNAMED(KSPROPSETID_RtAudio)

typedef enum {
    KSPROPERTY_RTAUDIO_GETPOSITIONFUNCTION,
#if (NTDDI_VERSION >= NTDDI_VISTA)
    KSPROPERTY_RTAUDIO_BUFFER,
    KSPROPERTY_RTAUDIO_HWLATENCY,
    KSPROPERTY_RTAUDIO_POSITIONREGISTER,
    KSPROPERTY_RTAUDIO_CLOCKREGISTER,
    KSPROPERTY_RTAUDIO_BUFFER_WITH_NOTIFICATION,
    KSPROPERTY_RTAUDIO_REGISTER_NOTIFICATION_EVENT,
    KSPROPERTY_RTAUDIO_UNREGISTER_NOTIFICATION_EVENT,
#endif
#if (NTDDI_VERSION >= NTDDI_WIN7)
    KSPROPERTY_RTAUDIO_QUERY_NOTIFICATION_SUPPORT
#endif    
} KSPROPERTY_RTAUDIO;

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
    ULONG       RequestedBufferSize;
} KSRTAUDIO_BUFFER_PROPERTY, *PKSRTAUDIO_BUFFER_PROPERTY;

typedef struct {
    KSPROPERTY  Property;
    ULONG       BaseAddress;
    ULONG       RequestedBufferSize;
} KSRTAUDIO_BUFFER_PROPERTY32, *PKSRTAUDIO_BUFFER_PROPERTY32;

typedef struct {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
    ULONG       RequestedBufferSize;
    ULONG       NotificationCount;
} KSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION, *PKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION;

typedef struct {
    KSPROPERTY  Property;
    ULONG       BaseAddress;
    ULONG       RequestedBufferSize;
    ULONG       NotificationCount;
} KSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION32, *PKSRTAUDIO_BUFFER_PROPERTY_WITH_NOTIFICATION32;

typedef struct {
    PVOID   BufferAddress;
    ULONG   ActualBufferSize;
    BOOL    CallMemoryBarrier;
} KSRTAUDIO_BUFFER, *PKSRTAUDIO_BUFFER;

typedef struct {
    ULONG   BufferAddress;
    ULONG   ActualBufferSize;
    BOOL    CallMemoryBarrier;
} KSRTAUDIO_BUFFER32, *PKSRTAUDIO_BUFFER32;

typedef struct {
    ULONG   FifoSize;
    ULONG   ChipsetDelay;
    ULONG   CodecDelay;
} KSRTAUDIO_HWLATENCY, *PKSRTAUDIO_HWLATENCY;

typedef struct {
    KSPROPERTY  Property;
    PVOID       BaseAddress;
} KSRTAUDIO_HWREGISTER_PROPERTY, *PKSRTAUDIO_HWREGISTER_PROPERTY;

typedef struct {
    KSPROPERTY  Property;
    ULONG       BaseAddress;
} KSRTAUDIO_HWREGISTER_PROPERTY32, *PKSRTAUDIO_HWREGISTER_PROPERTY32;

typedef struct {
    PVOID       Register;
    ULONG       Width;
    ULONGLONG   Numerator;
    ULONGLONG   Denominator;
    ULONG       Accuracy;
} KSRTAUDIO_HWREGISTER, *PKSRTAUDIO_HWREGISTER;

typedef struct {
    ULONG       Register;
    ULONG       Width;
    ULONGLONG   Numerator;
    ULONGLONG   Denominator;
    ULONG       Accuracy;
} KSRTAUDIO_HWREGISTER32, *PKSRTAUDIO_HWREGISTER32;

typedef struct {
    KSPROPERTY  Property;
    HANDLE      NotificationEvent;
} KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY, *PKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY;

typedef struct {
    KSPROPERTY  Property;
    ULONG       NotificationEvent;
} KSRTAUDIO_NOTIFICATION_EVENT_PROPERTY32, *PKSRTAUDIO_NOTIFICATION_EVENT_PROPERTY32;
#endif

#if (NTDDI_VERSION >= NTDDI_WIN7)
//===========================================================================
#define STATIC_KSPROPSETID_BtAudio\
    0x7FA06C40, 0xB8F6, 0x4C7E, 0x85, 0x56, 0xE8, 0xC3, 0x3A, 0x12, 0xE5, 0x4D
DEFINE_GUIDSTRUCT("7FA06C40-B8F6-4C7E-8556-E8C33A12E54D", KSPROPSETID_BtAudio);
#define KSPROPSETID_BtAudio DEFINE_GUIDNAMED(KSPROPSETID_BtAudio)

typedef enum {
    KSPROPERTY_ONESHOT_RECONNECT
};
#endif

//===========================================================================
#define STATIC_KSPROPSETID_DrmAudioStream\
    0x2f2c8ddd, 0x4198, 0x4fac, 0xba, 0x29, 0x61, 0xbb, 0x5, 0xb7, 0xde, 0x6
DEFINE_GUIDSTRUCT("2F2C8DDD-4198-4fac-BA29-61BB05B7DE06", KSPROPSETID_DrmAudioStream);
#define KSPROPSETID_DrmAudioStream DEFINE_GUIDNAMED(KSPROPSETID_DrmAudioStream)

typedef enum {
    KSPROPERTY_DRMAUDIOSTREAM_CONTENTID
} KSPROPERTY_DRMAUDIOSTREAM;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//===========================================================================
#define STATIC_KSPROPSETID_Audio\
    0x45FFAAA0L, 0x6E1B, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("45FFAAA0-6E1B-11D0-BCF2-444553540000", KSPROPSETID_Audio);
#define KSPROPSETID_Audio DEFINE_GUIDNAMED(KSPROPSETID_Audio)

typedef enum {
    KSPROPERTY_AUDIO_LATENCY = 1,
    KSPROPERTY_AUDIO_COPY_PROTECTION,
    KSPROPERTY_AUDIO_CHANNEL_CONFIG,
    KSPROPERTY_AUDIO_VOLUMELEVEL,
    KSPROPERTY_AUDIO_POSITION,
    KSPROPERTY_AUDIO_DYNAMIC_RANGE,
    KSPROPERTY_AUDIO_QUALITY,
    KSPROPERTY_AUDIO_SAMPLING_RATE,
    KSPROPERTY_AUDIO_DYNAMIC_SAMPLING_RATE,
    KSPROPERTY_AUDIO_MIX_LEVEL_TABLE,
    KSPROPERTY_AUDIO_MIX_LEVEL_CAPS,
    KSPROPERTY_AUDIO_MUX_SOURCE,
    KSPROPERTY_AUDIO_MUTE,
    KSPROPERTY_AUDIO_BASS,
    KSPROPERTY_AUDIO_MID,
    KSPROPERTY_AUDIO_TREBLE,
    KSPROPERTY_AUDIO_BASS_BOOST,
    KSPROPERTY_AUDIO_EQ_LEVEL,
    KSPROPERTY_AUDIO_NUM_EQ_BANDS,
    KSPROPERTY_AUDIO_EQ_BANDS,
    KSPROPERTY_AUDIO_AGC,
    KSPROPERTY_AUDIO_DELAY,
    KSPROPERTY_AUDIO_LOUDNESS,
    KSPROPERTY_AUDIO_WIDE_MODE,                 //Reserved for system use
    KSPROPERTY_AUDIO_WIDENESS,
    KSPROPERTY_AUDIO_REVERB_LEVEL,
    KSPROPERTY_AUDIO_CHORUS_LEVEL,
    KSPROPERTY_AUDIO_DEV_SPECIFIC,
    KSPROPERTY_AUDIO_DEMUX_DEST,
    KSPROPERTY_AUDIO_STEREO_ENHANCE,            //Reserved for system use
    KSPROPERTY_AUDIO_MANUFACTURE_GUID,          //Reserved for system use
    KSPROPERTY_AUDIO_PRODUCT_GUID,              //Reserved for system use
    KSPROPERTY_AUDIO_CPU_RESOURCES,
    KSPROPERTY_AUDIO_STEREO_SPEAKER_GEOMETRY,
    KSPROPERTY_AUDIO_SURROUND_ENCODE,
    KSPROPERTY_AUDIO_3D_INTERFACE

#if (NTDDI_VERSION >= NTDDI_WINXP)
    , KSPROPERTY_AUDIO_PEAKMETER
    , KSPROPERTY_AUDIO_ALGORITHM_INSTANCE
    , KSPROPERTY_AUDIO_FILTER_STATE
    , KSPROPERTY_AUDIO_PREFERRED_STATUS
    
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION >= NTDDI_VISTA)
    , KSPROPERTY_AUDIO_PEQ_MAX_BANDS
    , KSPROPERTY_AUDIO_PEQ_NUM_BANDS
    , KSPROPERTY_AUDIO_PEQ_BAND_CENTER_FREQ
    , KSPROPERTY_AUDIO_PEQ_BAND_Q_FACTOR
    , KSPROPERTY_AUDIO_PEQ_BAND_LEVEL
    , KSPROPERTY_AUDIO_CHORUS_MODULATION_RATE
    , KSPROPERTY_AUDIO_CHORUS_MODULATION_DEPTH
    , KSPROPERTY_AUDIO_REVERB_TIME
    , KSPROPERTY_AUDIO_REVERB_DELAY_FEEDBACK
    , KSPROPERTY_AUDIO_POSITIONEX
    , KSPROPERTY_AUDIO_MIC_ARRAY_GEOMETRY
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

} KSPROPERTY_AUDIO;

// Audio quality constants
#define KSAUDIO_QUALITY_WORST               0x0
#define KSAUDIO_QUALITY_PC                  0x1
#define KSAUDIO_QUALITY_BASIC               0x2
#define KSAUDIO_QUALITY_ADVANCED            0x3

// Audio CPU resource constants
#define KSAUDIO_CPU_RESOURCES_NOT_HOST_CPU  0x00000000
#define KSAUDIO_CPU_RESOURCES_HOST_CPU      0x7FFFFFFF

typedef struct {
    BOOL    fCopyrighted;
    BOOL    fOriginal;
} KSAUDIO_COPY_PROTECTION, *PKSAUDIO_COPY_PROTECTION;

typedef struct {
    LONG    ActiveSpeakerPositions;
} KSAUDIO_CHANNEL_CONFIG, *PKSAUDIO_CHANNEL_CONFIG;

// Speaker Positions:
#define SPEAKER_FRONT_LEFT              0x1
#define SPEAKER_FRONT_RIGHT             0x2
#define SPEAKER_FRONT_CENTER            0x4
#define SPEAKER_LOW_FREQUENCY           0x8
#define SPEAKER_BACK_LEFT               0x10
#define SPEAKER_BACK_RIGHT              0x20
#define SPEAKER_FRONT_LEFT_OF_CENTER    0x40
#define SPEAKER_FRONT_RIGHT_OF_CENTER   0x80
#define SPEAKER_BACK_CENTER             0x100
#define SPEAKER_SIDE_LEFT               0x200
#define SPEAKER_SIDE_RIGHT              0x400
#define SPEAKER_TOP_CENTER              0x800
#define SPEAKER_TOP_FRONT_LEFT          0x1000
#define SPEAKER_TOP_FRONT_CENTER        0x2000
#define SPEAKER_TOP_FRONT_RIGHT         0x4000
#define SPEAKER_TOP_BACK_LEFT           0x8000
#define SPEAKER_TOP_BACK_CENTER         0x10000
#define SPEAKER_TOP_BACK_RIGHT          0x20000

// Bit mask locations reserved for future use
#define SPEAKER_RESERVED                0x7FFC0000

// Used to specify that any possible permutation of speaker configurations
#define SPEAKER_ALL                     0x80000000

// DirectSound Speaker Config
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define KSAUDIO_SPEAKER_DIRECTOUT       0
#endif
#define KSAUDIO_SPEAKER_MONO            (SPEAKER_FRONT_CENTER)
#define KSAUDIO_SPEAKER_STEREO          (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT)
#define KSAUDIO_SPEAKER_QUAD            (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_SURROUND        (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_BACK_CENTER)
#define KSAUDIO_SPEAKER_5POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT  | SPEAKER_BACK_RIGHT)
#define KSAUDIO_SPEAKER_7POINT1         (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | \
                                         SPEAKER_FRONT_LEFT_OF_CENTER | SPEAKER_FRONT_RIGHT_OF_CENTER)

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

#define KSAUDIO_SPEAKER_5POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_SIDE_LEFT  | SPEAKER_SIDE_RIGHT)
#define KSAUDIO_SPEAKER_7POINT1_SURROUND (SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT | \
                                         SPEAKER_FRONT_CENTER | SPEAKER_LOW_FREQUENCY | \
                                         SPEAKER_BACK_LEFT | SPEAKER_BACK_RIGHT | \
                                         SPEAKER_SIDE_LEFT | SPEAKER_SIDE_RIGHT)
// The following are obsolete 5.1 and 7.1 settings (they lack side speakers).  Note this means
// that the default 5.1 and 7.1 settings (KSAUDIO_SPEAKER_5POINT1 and KSAUDIO_SPEAKER_7POINT1 are
// similarly obsolete but are unchanged for compatibility reasons).
#define KSAUDIO_SPEAKER_5POINT1_BACK     KSAUDIO_SPEAKER_5POINT1
#define KSAUDIO_SPEAKER_7POINT1_WIDE     KSAUDIO_SPEAKER_7POINT1

#endif // XP SP2 and later (chronologically)

// DVD Speaker Positions
#define KSAUDIO_SPEAKER_GROUND_FRONT_LEFT   SPEAKER_FRONT_LEFT
#define KSAUDIO_SPEAKER_GROUND_FRONT_CENTER SPEAKER_FRONT_CENTER
#define KSAUDIO_SPEAKER_GROUND_FRONT_RIGHT  SPEAKER_FRONT_RIGHT
#define KSAUDIO_SPEAKER_GROUND_REAR_LEFT    SPEAKER_BACK_LEFT
#define KSAUDIO_SPEAKER_GROUND_REAR_RIGHT   SPEAKER_BACK_RIGHT
#define KSAUDIO_SPEAKER_TOP_MIDDLE          SPEAKER_TOP_CENTER
#define KSAUDIO_SPEAKER_SUPER_WOOFER        SPEAKER_LOW_FREQUENCY

typedef struct {
    ULONG   QuietCompression;
    ULONG   LoudCompression;
} KSAUDIO_DYNAMIC_RANGE, *PKSAUDIO_DYNAMIC_RANGE;

typedef struct {
    BOOL    Mute;
    LONG    Level;
} KSAUDIO_MIXLEVEL, *PKSAUDIO_MIXLEVEL;

typedef struct {
    BOOL    Mute;
    LONG    Minimum;
    LONG    Maximum;
    union {
        LONG    Reset;
        LONG    Resolution;
    };
} KSAUDIO_MIX_CAPS, *PKSAUDIO_MIX_CAPS;

typedef struct {
    ULONG               InputChannels;
    ULONG               OutputChannels;
    KSAUDIO_MIX_CAPS    Capabilities[1];
} KSAUDIO_MIXCAP_TABLE, *PKSAUDIO_MIXCAP_TABLE;

#if (NTDDI_VERSION < NTDDI_VISTA)

typedef enum {              // preferred device index
    KSPROPERTY_SYSAUDIO_NORMAL_DEFAULT = 0,
    KSPROPERTY_SYSAUDIO_PLAYBACK_DEFAULT,
    KSPROPERTY_SYSAUDIO_RECORD_DEFAULT,
    KSPROPERTY_SYSAUDIO_MIDI_DEFAULT,
    KSPROPERTY_SYSAUDIO_MIXER_DEFAULT
} KSPROPERTY_SYSAUDIO_DEFAULT_TYPE;

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

typedef struct {
    BOOL                             Enable;
    KSPROPERTY_SYSAUDIO_DEFAULT_TYPE DeviceType;
    ULONG                            Flags;
    ULONG                            Reserved;
} KSAUDIO_PREFERRED_STATUS, *PKSAUDIO_PREFERRED_STATUS;

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_VISTA)
typedef struct {
    LARGE_INTEGER       TimerFrequency;
    LARGE_INTEGER       TimeStamp1;
    KSAUDIO_POSITION    Position;
    LARGE_INTEGER       TimeStamp2;
} KSAUDIO_POSITIONEX, *PKSAUDIO_POSITIONEX;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//===========================================================================
// Topology Node Type GUIDs

#define STATIC_KSNODETYPE_DAC\
    0x507AE360L, 0xC554, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("507AE360-C554-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DAC);
#define KSNODETYPE_DAC DEFINE_GUIDNAMED(KSNODETYPE_DAC)

#define STATIC_KSNODETYPE_ADC\
    0x4D837FE0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("4D837FE0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_ADC);
#define KSNODETYPE_ADC DEFINE_GUIDNAMED(KSNODETYPE_ADC)

#define STATIC_KSNODETYPE_SRC\
    0x9DB7B9E0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9DB7B9E0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SRC);
#define KSNODETYPE_SRC DEFINE_GUIDNAMED(KSNODETYPE_SRC)

#define STATIC_KSNODETYPE_SUPERMIX\
    0xE573ADC0L, 0xC555, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E573ADC0-C555-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUPERMIX);
#define KSNODETYPE_SUPERMIX DEFINE_GUIDNAMED(KSNODETYPE_SUPERMIX)

#define STATIC_KSNODETYPE_MUX\
    0x2CEAF780L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("2CEAF780-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUX);
#define KSNODETYPE_MUX DEFINE_GUIDNAMED(KSNODETYPE_MUX)

#define STATIC_KSNODETYPE_DEMUX\
    0xC0EB67D4L, 0xE807, 0x11D0, 0x95, 0x8A, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("C0EB67D4-E807-11D0-958A-00C04FB925D3", KSNODETYPE_DEMUX);
#define KSNODETYPE_DEMUX DEFINE_GUIDNAMED(KSNODETYPE_DEMUX)

#define STATIC_KSNODETYPE_SUM\
    0xDA441A60L, 0xC556, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("DA441A60-C556-11D0-8A2B-00A0C9255AC1", KSNODETYPE_SUM);
#define KSNODETYPE_SUM DEFINE_GUIDNAMED(KSNODETYPE_SUM)

#define STATIC_KSNODETYPE_MUTE\
    0x02B223C0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("02B223C0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_MUTE);
#define KSNODETYPE_MUTE DEFINE_GUIDNAMED(KSNODETYPE_MUTE)

#define STATIC_KSNODETYPE_VOLUME\
    0x3A5ACC00L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("3A5ACC00-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_VOLUME);
#define KSNODETYPE_VOLUME DEFINE_GUIDNAMED(KSNODETYPE_VOLUME)

#define STATIC_KSNODETYPE_TONE\
    0x7607E580L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("7607E580-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_TONE);
#define KSNODETYPE_TONE DEFINE_GUIDNAMED(KSNODETYPE_TONE)

#define STATIC_KSNODETYPE_EQUALIZER\
    0x9D41B4A0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("9D41B4A0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_EQUALIZER);
#define KSNODETYPE_EQUALIZER DEFINE_GUIDNAMED(KSNODETYPE_EQUALIZER)

#define STATIC_KSNODETYPE_AGC\
    0xE88C9BA0L, 0xC557, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("E88C9BA0-C557-11D0-8A2B-00A0C9255AC1", KSNODETYPE_AGC);
#define KSNODETYPE_AGC DEFINE_GUIDNAMED(KSNODETYPE_AGC)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_NOISE_SUPPRESS\
    0xe07f903f, 0x62fd, 0x4e60, 0x8c, 0xdd, 0xde, 0xa7, 0x23, 0x66, 0x65, 0xb5
DEFINE_GUIDSTRUCT("E07F903F-62FD-4e60-8CDD-DEA7236665B5", KSNODETYPE_NOISE_SUPPRESS);
#define KSNODETYPE_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSNODETYPE_NOISE_SUPPRESS)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_DELAY\
    0x144981E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("144981E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DELAY);
#define KSNODETYPE_DELAY DEFINE_GUIDNAMED(KSNODETYPE_DELAY)

#define STATIC_KSNODETYPE_LOUDNESS\
    0x41887440L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("41887440-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_LOUDNESS);
#define KSNODETYPE_LOUDNESS DEFINE_GUIDNAMED(KSNODETYPE_LOUDNESS)

#define STATIC_KSNODETYPE_PROLOGIC_DECODER\
    0x831C2C80L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("831C2C80-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_PROLOGIC_DECODER);
#define KSNODETYPE_PROLOGIC_DECODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_DECODER)

#define STATIC_KSNODETYPE_STEREO_WIDE\
    0xA9E69800L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("A9E69800-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_STEREO_WIDE);
#define KSNODETYPE_STEREO_WIDE DEFINE_GUIDNAMED(KSNODETYPE_STEREO_WIDE)

#define STATIC_KSNODETYPE_REVERB\
    0xEF0328E0L, 0xC558, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("EF0328E0-C558-11D0-8A2B-00A0C9255AC1", KSNODETYPE_REVERB);
#define KSNODETYPE_REVERB DEFINE_GUIDNAMED(KSNODETYPE_REVERB)

#define STATIC_KSNODETYPE_CHORUS\
    0x20173F20L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("20173F20-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_CHORUS);
#define KSNODETYPE_CHORUS DEFINE_GUIDNAMED(KSNODETYPE_CHORUS)

#define STATIC_KSNODETYPE_3D_EFFECTS\
    0x55515860L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("55515860-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_3D_EFFECTS);
#define KSNODETYPE_3D_EFFECTS DEFINE_GUIDNAMED(KSNODETYPE_3D_EFFECTS)

#define STATIC_KSNODETYPE_PARAMETRIC_EQUALIZER\
    0x19bb3a6a, 0xce2b, 0x4442, 0x87, 0xec, 0x67, 0x27, 0xc3, 0xca, 0xb4, 0x77
DEFINE_GUIDSTRUCT("19BB3A6A-CE2B-4442-87EC-6727C3CAB477", KSNODETYPE_PARAMETRIC_EQUALIZER);
#define KSNODETYPE_PARAMETRIC_EQUALIZER DEFINE_GUIDNAMED(KSNODETYPE_PARAMETRIC_EQUALIZER)

#define STATIC_KSNODETYPE_UPDOWN_MIX\
    0xb7edc5cf, 0x7b63, 0x4ee2, 0xa1, 0x0, 0x29, 0xee, 0x2c, 0xb6, 0xb2, 0xde
DEFINE_GUIDSTRUCT("B7EDC5CF-7B63-4ee2-A100-29EE2CB6B2DE", KSNODETYPE_UPDOWN_MIX);
#define KSNODETYPE_UPDOWN_MIX DEFINE_GUIDNAMED(KSNODETYPE_UPDOWN_MIX)

#define STATIC_KSNODETYPE_DYN_RANGE_COMPRESSOR\
    0x8c8a6a8, 0x601f, 0x4af8, 0x87, 0x93, 0xd9, 0x5, 0xff, 0x4c, 0xa9, 0x7d
DEFINE_GUIDSTRUCT("08C8A6A8-601F-4af8-8793-D905FF4CA97D", KSNODETYPE_DYN_RANGE_COMPRESSOR);
#define KSNODETYPE_DYN_RANGE_COMPRESSOR DEFINE_GUIDNAMED(KSNODETYPE_DYN_RANGE_COMPRESSOR)

#define STATIC_KSNODETYPE_ACOUSTIC_ECHO_CANCEL STATIC_KSCATEGORY_ACOUSTIC_ECHO_CANCEL
#define KSNODETYPE_ACOUSTIC_ECHO_CANCEL KSCATEGORY_ACOUSTIC_ECHO_CANCEL

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL\
    0x1c22c56dL, 0x9879, 0x4f5b, 0xa3, 0x89, 0x27, 0x99, 0x6d, 0xdc, 0x28, 0x10
DEFINE_GUIDSTRUCT("1C22C56D-9879-4f5b-A389-27996DDC2810", KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL);
#define KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_ACOUSTIC_ECHO_CANCEL)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS\
    0x5ab0882eL, 0x7274, 0x4516, 0x87, 0x7d, 0x4e, 0xee, 0x99, 0xba, 0x4f, 0xd0
DEFINE_GUIDSTRUCT("5AB0882E-7274-4516-877D-4EEE99BA4FD0", KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS);
#define KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_NOISE_SUPPRESS)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_AGC\
    0x950e55b9L, 0x877c, 0x4c67, 0xbe, 0x8, 0xe4, 0x7b, 0x56, 0x11, 0x13, 0xa
DEFINE_GUIDSTRUCT("950E55B9-877C-4c67-BE08-E47B5611130A", KSALGORITHMINSTANCE_SYSTEM_AGC);
#define KSALGORITHMINSTANCE_SYSTEM_AGC DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_AGC)

#define STATIC_KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR\
    0xB6F5A0A0L, 0x9E61, 0x4F8C, 0x91, 0xE3, 0x76, 0xCF, 0xF, 0x3C, 0x47, 0x1F
DEFINE_GUIDSTRUCT("B6F5A0A0-9E61-4f8c-91E3-76CF0F3C471F", KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR);
#define KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR DEFINE_GUIDNAMED(KSALGORITHMINSTANCE_SYSTEM_MICROPHONE_ARRAY_PROCESSOR)

#define STATIC_KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR STATIC_KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR
#define KSNODETYPE_MICROPHONE_ARRAY_PROCESSOR KSCATEGORY_MICROPHONE_ARRAY_PROCESSOR

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_DEV_SPECIFIC\
    0x941C7AC0L, 0xC559, 0x11D0, 0x8A, 0x2B, 0x00, 0xA0, 0xC9, 0x25, 0x5A, 0xC1
DEFINE_GUIDSTRUCT("941C7AC0-C559-11D0-8A2B-00A0C9255AC1", KSNODETYPE_DEV_SPECIFIC);
#define KSNODETYPE_DEV_SPECIFIC DEFINE_GUIDNAMED(KSNODETYPE_DEV_SPECIFIC)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSNODETYPE_PROLOGIC_ENCODER\
    0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", KSNODETYPE_PROLOGIC_ENCODER);
#define KSNODETYPE_PROLOGIC_ENCODER DEFINE_GUIDNAMED(KSNODETYPE_PROLOGIC_ENCODER)
#define KSNODETYPE_SURROUND_ENCODER KSNODETYPE_PROLOGIC_ENCODER

#define STATIC_KSNODETYPE_PEAKMETER\
    0xa085651eL, 0x5f0d, 0x4b36, 0xa8, 0x69, 0xd1, 0x95, 0xd6, 0xab, 0x4b, 0x9e
DEFINE_GUIDSTRUCT("A085651E-5F0D-4b36-A869-D195D6AB4B9E", KSNODETYPE_PEAKMETER);
#define KSNODETYPE_PEAKMETER DEFINE_GUIDNAMED(KSNODETYPE_PEAKMETER)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_WINXP)

#define STATIC_KSNODETYPE_SURROUND_ENCODER\
    0x8074C5B2L, 0x3C66, 0x11D2, 0xB4, 0x5A, 0x30, 0x78, 0x30, 0x2C, 0x20, 0x30
DEFINE_GUIDSTRUCT("8074C5B2-3C66-11D2-B45A-3078302C2030", KSNODETYPE_SURROUND_ENCODER);
#define KSNODETYPE_SURROUND_ENCODER DEFINE_GUIDNAMED(KSNODETYPE_SURROUND_ENCODER)

#endif // (NTDDI_VERSION < NTDDI_WINXP)

//===========================================================================
// Topology Node Name GUIDs for common audio nodes
#define STATIC_KSAUDFNAME_BASS\
    0x185FEDE0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_BASS);
#define KSAUDFNAME_BASS DEFINE_GUIDNAMED(KSAUDFNAME_BASS)

#define STATIC_KSAUDFNAME_TREBLE\
    0x185FEDE1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_TREBLE);
#define KSAUDFNAME_TREBLE DEFINE_GUIDNAMED(KSAUDFNAME_TREBLE)

#define STATIC_KSAUDFNAME_MIDRANGE\
    0xA2CBE478, 0xAE84, 0x49A1, 0x8B, 0x72, 0x4A, 0xD0, 0x9B, 0x78, 0xED, 0x34
DEFINE_GUIDSTRUCT("A2CBE478-AE84-49A1-8B72-4AD09B78ED34", KSAUDFNAME_MIDRANGE);
#define KSAUDFNAME_MIDRANGE DEFINE_GUIDNAMED(KSAUDFNAME_MIDRANGE)

#define STATIC_KSAUDFNAME_3D_STEREO\
    0x185FEDE2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_3D_STEREO);
#define KSAUDFNAME_3D_STEREO DEFINE_GUIDNAMED(KSAUDFNAME_3D_STEREO)

#define STATIC_KSAUDFNAME_MASTER_VOLUME\
    0x185FEDE3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_VOLUME);
#define KSAUDFNAME_MASTER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_VOLUME)

#define STATIC_KSAUDFNAME_MASTER_MUTE\
    0x185FEDE4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MASTER_MUTE);
#define KSAUDFNAME_MASTER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MASTER_MUTE)

#define STATIC_KSAUDFNAME_WAVE_VOLUME\
    0x185FEDE5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_VOLUME);
#define KSAUDFNAME_WAVE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_MUTE\
    0x185FEDE6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_MUTE);
#define KSAUDFNAME_WAVE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_MUTE)

#define STATIC_KSAUDFNAME_MIDI_VOLUME\
    0x185FEDE7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_VOLUME);
#define KSAUDFNAME_MIDI_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_VOLUME)

#define STATIC_KSAUDFNAME_MIDI_MUTE\
    0x185FEDE8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_MUTE);
#define KSAUDFNAME_MIDI_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_MUTE)

#define STATIC_KSAUDFNAME_CD_VOLUME\
    0x185FEDE9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDE9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_VOLUME);
#define KSAUDFNAME_CD_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_VOLUME)

#define STATIC_KSAUDFNAME_CD_MUTE\
    0x185FEDEAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_MUTE);
#define KSAUDFNAME_CD_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_CD_MUTE)

#define STATIC_KSAUDFNAME_LINE_VOLUME\
    0x185FEDEBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_VOLUME);
#define KSAUDFNAME_LINE_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_VOLUME)

#define STATIC_KSAUDFNAME_LINE_MUTE\
    0x185FEDECL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_MUTE);
#define KSAUDFNAME_LINE_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_LINE_MUTE)

#define STATIC_KSAUDFNAME_MIC_VOLUME\
    0x185FEDEDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDED-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_VOLUME);
#define KSAUDFNAME_MIC_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_VOLUME)

#define STATIC_KSAUDFNAME_MIC_MUTE\
    0x185FEDEEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_MUTE);
#define KSAUDFNAME_MIC_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MIC_MUTE)

#define STATIC_KSAUDFNAME_RECORDING_SOURCE\
    0x185FEDEFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDEF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_SOURCE);
#define KSAUDFNAME_RECORDING_SOURCE DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_SOURCE)

#define STATIC_KSAUDFNAME_PC_SPEAKER_VOLUME\
    0x185FEDF0L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF0-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_VOLUME);
#define KSAUDFNAME_PC_SPEAKER_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_VOLUME)

#define STATIC_KSAUDFNAME_PC_SPEAKER_MUTE\
    0x185FEDF1L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF1-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER_MUTE);
#define KSAUDFNAME_PC_SPEAKER_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER_MUTE)

#define STATIC_KSAUDFNAME_MIDI_IN_VOLUME\
    0x185FEDF2L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF2-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI_IN_VOLUME);
#define KSAUDFNAME_MIDI_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIDI_IN_VOLUME)

#define STATIC_KSAUDFNAME_CD_IN_VOLUME\
    0x185FEDF3L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF3-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_IN_VOLUME);
#define KSAUDFNAME_CD_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_CD_IN_VOLUME)

#define STATIC_KSAUDFNAME_LINE_IN_VOLUME\
    0x185FEDF4L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF4-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN_VOLUME);
#define KSAUDFNAME_LINE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN_VOLUME)

#define STATIC_KSAUDFNAME_MIC_IN_VOLUME\
    0x185FEDF5L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF5-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIC_IN_VOLUME);
#define KSAUDFNAME_MIC_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MIC_IN_VOLUME)

#define STATIC_KSAUDFNAME_WAVE_IN_VOLUME\
    0x185FEDF6L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF6-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_IN_VOLUME);
#define KSAUDFNAME_WAVE_IN_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_IN_VOLUME)

#define STATIC_KSAUDFNAME_VOLUME_CONTROL\
    0x185FEDF7L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF7-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_VOLUME_CONTROL);
#define KSAUDFNAME_VOLUME_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_VOLUME_CONTROL)

#define STATIC_KSAUDFNAME_MIDI\
    0x185FEDF8L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF8-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_MIDI);
#define KSAUDFNAME_MIDI DEFINE_GUIDNAMED(KSAUDFNAME_MIDI)

#define STATIC_KSAUDFNAME_LINE_IN\
    0x185FEDF9L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDF9-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_LINE_IN);
#define KSAUDFNAME_LINE_IN DEFINE_GUIDNAMED(KSAUDFNAME_LINE_IN)

#define STATIC_KSAUDFNAME_RECORDING_CONTROL\
    0x185FEDFAL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFA-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_RECORDING_CONTROL);
#define KSAUDFNAME_RECORDING_CONTROL DEFINE_GUIDNAMED(KSAUDFNAME_RECORDING_CONTROL)

#define STATIC_KSAUDFNAME_CD_AUDIO\
    0x185FEDFBL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFB-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_CD_AUDIO);
#define KSAUDFNAME_CD_AUDIO DEFINE_GUIDNAMED(KSAUDFNAME_CD_AUDIO)

#define STATIC_KSAUDFNAME_AUX_VOLUME\
    0x185FEDFCL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFC-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_VOLUME);
#define KSAUDFNAME_AUX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_AUX_VOLUME)

#define STATIC_KSAUDFNAME_AUX_MUTE\
    0x185FEDFDL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFD-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX_MUTE);
#define KSAUDFNAME_AUX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_AUX_MUTE)

#define STATIC_KSAUDFNAME_AUX\
    0x185FEDFEL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFE-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_AUX);
#define KSAUDFNAME_AUX DEFINE_GUIDNAMED(KSAUDFNAME_AUX)

#define STATIC_KSAUDFNAME_PC_SPEAKER\
    0x185FEDFFL, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEDFF-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_PC_SPEAKER);
#define KSAUDFNAME_PC_SPEAKER DEFINE_GUIDNAMED(KSAUDFNAME_PC_SPEAKER)

#define STATIC_KSAUDFNAME_WAVE_OUT_MIX\
    0x185FEE00L, 0x9905, 0x11D1, 0x95, 0xA9, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("185FEE00-9905-11D1-95A9-00C04FB925D3", KSAUDFNAME_WAVE_OUT_MIX);
#define KSAUDFNAME_WAVE_OUT_MIX DEFINE_GUIDNAMED(KSAUDFNAME_WAVE_OUT_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT\
    0xf9b41dc3L, 0x96e2, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("F9B41DC3-96E2-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT);
#define KSAUDFNAME_MONO_OUT DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT)

#define STATIC_KSAUDFNAME_STEREO_MIX\
    0xdff077L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF077-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX);
#define KSAUDFNAME_STEREO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX)

#define STATIC_KSAUDFNAME_MONO_MIX\
    0xdff078L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("00DFF078-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX);
#define KSAUDFNAME_MONO_MIX DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX)

#define STATIC_KSAUDFNAME_MONO_OUT_VOLUME\
    0x1ad247ebL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EB-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_VOLUME);
#define KSAUDFNAME_MONO_OUT_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_VOLUME)

#define STATIC_KSAUDFNAME_MONO_OUT_MUTE\
    0x1ad247ecL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247EC-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_OUT_MUTE);
#define KSAUDFNAME_MONO_OUT_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_OUT_MUTE)

#define STATIC_KSAUDFNAME_STEREO_MIX_VOLUME\
    0x1ad247edL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("1AD247ED-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_VOLUME);
#define KSAUDFNAME_STEREO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_STEREO_MIX_MUTE\
    0x22b0eafdL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFD-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_STEREO_MIX_MUTE);
#define KSAUDFNAME_STEREO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_STEREO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MONO_MIX_VOLUME\
    0x22b0eafeL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("22B0EAFE-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_VOLUME);
#define KSAUDFNAME_MONO_MIX_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_VOLUME)

#define STATIC_KSAUDFNAME_MONO_MIX_MUTE\
    0x2bc31d69L, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D69-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MONO_MIX_MUTE);
#define KSAUDFNAME_MONO_MIX_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_MONO_MIX_MUTE)

#define STATIC_KSAUDFNAME_MICROPHONE_BOOST\
    0x2bc31d6aL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6A-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_MICROPHONE_BOOST);
#define KSAUDFNAME_MICROPHONE_BOOST DEFINE_GUIDNAMED(KSAUDFNAME_MICROPHONE_BOOST)

#define STATIC_KSAUDFNAME_ALTERNATE_MICROPHONE\
    0x2bc31d6bL, 0x96e3, 0x11d2, 0xac, 0x4c, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("2BC31D6B-96E3-11d2-AC4C-00C04F8EFB68", KSAUDFNAME_ALTERNATE_MICROPHONE);
#define KSAUDFNAME_ALTERNATE_MICROPHONE DEFINE_GUIDNAMED(KSAUDFNAME_ALTERNATE_MICROPHONE)

#define STATIC_KSAUDFNAME_3D_DEPTH\
    0x63ff5747L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("63FF5747-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_DEPTH);
#define KSAUDFNAME_3D_DEPTH DEFINE_GUIDNAMED(KSAUDFNAME_3D_DEPTH)

#define STATIC_KSAUDFNAME_3D_CENTER\
    0x9f0670b4L, 0x991f, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9F0670B4-991F-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_3D_CENTER);
#define KSAUDFNAME_3D_CENTER DEFINE_GUIDNAMED(KSAUDFNAME_3D_CENTER)

#define STATIC_KSAUDFNAME_VIDEO_VOLUME\
    0x9b46e708L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E708-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_VOLUME);
#define KSAUDFNAME_VIDEO_VOLUME DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_VOLUME)

#define STATIC_KSAUDFNAME_VIDEO_MUTE\
    0x9b46e709L, 0x992a, 0x11d2, 0xac, 0x4d, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("9B46E709-992A-11d2-AC4D-00C04F8EFB68", KSAUDFNAME_VIDEO_MUTE);
#define KSAUDFNAME_VIDEO_MUTE DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO_MUTE)

#define STATIC_KSAUDFNAME_VIDEO\
    0x915daec4L, 0xa434, 0x11d2, 0xac, 0x52, 0x0, 0xc0, 0x4f, 0x8e, 0xfb, 0x68
DEFINE_GUIDSTRUCT("915DAEC4-A434-11d2-AC52-00C04F8EFB68", KSAUDFNAME_VIDEO);
#define KSAUDFNAME_VIDEO DEFINE_GUIDNAMED(KSAUDFNAME_VIDEO)

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_KSAUDFNAME_PEAKMETER\
    0x57e24340L, 0xfc5b, 0x4612, 0xa5, 0x62, 0x72, 0xb1, 0x1a, 0x29, 0xdf, 0xae
DEFINE_GUIDSTRUCT("57E24340-FC5B-4612-A562-72B11A29DFAE", KSAUDFNAME_PEAKMETER);
#define KSAUDFNAME_PEAKMETER DEFINE_GUIDNAMED(KSAUDFNAME_PEAKMETER)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)


// Internal topology node pin definitions

#define KSNODEPIN_STANDARD_IN       1
#define KSNODEPIN_STANDARD_OUT      0

#define KSNODEPIN_SUM_MUX_IN        1   // can be >= 1
#define KSNODEPIN_SUM_MUX_OUT       0

#define KSNODEPIN_DEMUX_IN          0
#define KSNODEPIN_DEMUX_OUT         1   // can be >= 1

#if (NTDDI_VERSION < NTDDI_VISTA)

#define KSNODEPIN_AEC_RENDER_IN     1
#define KSNODEPIN_AEC_RENDER_OUT    0
#define KSNODEPIN_AEC_CAPTURE_IN    2
#define KSNODEPIN_AEC_CAPTURE_OUT   3

#endif // (NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
//===========================================================================

#define STATIC_KSMETHODSETID_Wavetable\
    0xDCEF31EBL, 0xD907, 0x11D0, 0x95, 0x83, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("DCEF31EB-D907-11D0-9583-00C04FB925D3", KSMETHODSETID_Wavetable);
#define KSMETHODSETID_Wavetable DEFINE_GUIDNAMED(KSMETHODSETID_Wavetable)

typedef enum {
    KSMETHOD_WAVETABLE_WAVE_ALLOC,
    KSMETHOD_WAVETABLE_WAVE_FREE,
    KSMETHOD_WAVETABLE_WAVE_FIND,
    KSMETHOD_WAVETABLE_WAVE_WRITE
} KSMETHOD_WAVETABLE;

typedef struct {
    KSIDENTIFIER        Identifier;                     // wave identifier
    ULONG               Size;                           // wave size
    BOOL                Looped;                         // wave looped flag
    ULONG               LoopPoint;                      // wave loop point
    BOOL                InROM;                          // wave InROM flag
    KSDATAFORMAT        Format;                         // wave format
} KSWAVETABLE_WAVE_DESC, *PKSWAVETABLE_WAVE_DESC;


//===========================================================================
//===========================================================================

/*
    Property sets and items
*/

//===========================================================================
//===========================================================================

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)
#define STATIC_KSPROPSETID_Acoustic_Echo_Cancel\
    0xd7a4af8bL, 0x3dc1, 0x4902, 0x91, 0xea, 0x8a, 0x15, 0xc9, 0x0e, 0x05, 0xb2
DEFINE_GUIDSTRUCT("D7A4AF8B-3DC1-4902-91EA-8A15C90E05B2", KSPROPSETID_Acoustic_Echo_Cancel);
#define KSPROPSETID_Acoustic_Echo_Cancel DEFINE_GUIDNAMED(KSPROPSETID_Acoustic_Echo_Cancel)

typedef enum {
    KSPROPERTY_AEC_NOISE_FILL_ENABLE = 0,
    KSPROPERTY_AEC_STATUS,
    KSPROPERTY_AEC_MODE
} KSPROPERTY_AEC;

#define AEC_STATUS_FD_HISTORY_UNINITIALIZED             0x0
#define AEC_STATUS_FD_HISTORY_CONTINUOUSLY_CONVERGED    0x1
#define AEC_STATUS_FD_HISTORY_PREVIOUSLY_DIVERGED       0x2
#define AEC_STATUS_FD_CURRENTLY_CONVERGED               0x8

#define AEC_MODE_PASS_THROUGH           0x0
#define AEC_MODE_HALF_DUPLEX            0x1
#define AEC_MODE_FULL_DUPLEX            0x2

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
//===========================================================================
#if (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSPROPSETID_Wave_Queued\
    0x16a15b10L, 0x16f0, 0x11d0, 0xa1, 0x95, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("16a15b10-16f0-11d0-a195-0020afd156e4", KSPROPSETID_Wave_Queued);
#define KSPROPSETID_Wave_Queued DEFINE_GUIDNAMED(KSPROPSETID_Wave_Queued)

#define KSPROPERTY_WAVE_QUEUED_POSITION                 0x00000001

#define STATIC_KSMETHODSETID_Wave_Queued\
    0x7432c160L, 0x8827, 0x11cf, 0xa1, 0x02, 0x00, 0x20, 0xaf, 0xd1, 0x56, 0xe4
DEFINE_GUIDSTRUCT("7432c160-8827-11cf-a102-0020afd156e4", KSMETHODSETID_Wave_Queued);
#define KSMETHODSETID_Wave_Queued DEFINE_GUIDNAMED(KSMETHODSETID_Wave_Queued)

#define KSMETHOD_WAVE_QUEUED_BREAKLOOP                  0x00000001

#endif // (NTDDI_VERSION < NTDDI_WS03)


#define STATIC_KSPROPSETID_Wave\
    0x924e54b0L, 0x630f, 0x11cf, 0xad, 0xa7, 0x08, 0x00, 0x3e, 0x30, 0x49, 0x4a
DEFINE_GUIDSTRUCT("924e54b0-630f-11cf-ada7-08003e30494a", KSPROPSETID_Wave);
#define KSPROPSETID_Wave DEFINE_GUIDNAMED(KSPROPSETID_Wave)

typedef enum {
    KSPROPERTY_WAVE_COMPATIBLE_CAPABILITIES,
    KSPROPERTY_WAVE_INPUT_CAPABILITIES,
    KSPROPERTY_WAVE_OUTPUT_CAPABILITIES,
    KSPROPERTY_WAVE_BUFFER,
    KSPROPERTY_WAVE_FREQUENCY,
    KSPROPERTY_WAVE_VOLUME,
    KSPROPERTY_WAVE_PAN
} KSPROPERTY_WAVE;

typedef struct {
    ULONG        ulDeviceType;
} KSWAVE_COMPATCAPS, *PKSWAVE_COMPATCAPS;

#define KSWAVE_COMPATCAPS_INPUT                 0x00000000
#define KSWAVE_COMPATCAPS_OUTPUT                0x00000001

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  ActiveConnections;
} KSWAVE_INPUT_CAPABILITIES, *PKSWAVE_INPUT_CAPABILITIES;

typedef struct {
    ULONG  MaximumChannelsPerConnection;
    ULONG  MinimumBitsPerSample;
    ULONG  MaximumBitsPerSample;
    ULONG  MinimumSampleFrequency;
    ULONG  MaximumSampleFrequency;
    ULONG  TotalConnections;
    ULONG  StaticConnections;
    ULONG  StreamingConnections;
    ULONG  ActiveConnections;
    ULONG  ActiveStaticConnections;
    ULONG  ActiveStreamingConnections;
    ULONG  Total3DConnections;
    ULONG  Static3DConnections;
    ULONG  Streaming3DConnections;
    ULONG  Active3DConnections;
    ULONG  ActiveStatic3DConnections;
    ULONG  ActiveStreaming3DConnections;
    ULONG  TotalSampleMemory;
    ULONG  FreeSampleMemory;
    ULONG  LargestFreeContiguousSampleMemory;
} KSWAVE_OUTPUT_CAPABILITIES, *PKSWAVE_OUTPUT_CAPABILITIES;

typedef struct {
    LONG  LeftAttenuation;
    LONG  RightAttenuation;
} KSWAVE_VOLUME, *PKSWAVE_VOLUME;

#define KSWAVE_BUFFER_ATTRIBUTEF_LOOPING   0x00000001
#define KSWAVE_BUFFER_ATTRIBUTEF_STATIC    0x00000002

typedef struct {
    ULONG   Attributes;
    ULONG   BufferSize;
    PVOID   BufferAddress;
} KSWAVE_BUFFER, *PKSWAVE_BUFFER;

//===========================================================================
//===========================================================================

#define STATIC_KSMUSIC_TECHNOLOGY_PORT\
    0x86C92E60L, 0x62E8, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("86C92E60-62E8-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_PORT);
#define KSMUSIC_TECHNOLOGY_PORT DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_PORT)

#define STATIC_KSMUSIC_TECHNOLOGY_SQSYNTH\
    0x0ECF4380L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("0ECF4380-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_SQSYNTH);
#define KSMUSIC_TECHNOLOGY_SQSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SQSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_FMSYNTH\
    0x252C5C80L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("252C5C80-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_FMSYNTH);
#define KSMUSIC_TECHNOLOGY_FMSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_FMSYNTH)

#define STATIC_KSMUSIC_TECHNOLOGY_WAVETABLE\
    0x394EC7C0L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("394EC7C0-62E9-11CF-A5D6-28DB04C10000", KSMUSIC_TECHNOLOGY_WAVETABLE);
#define KSMUSIC_TECHNOLOGY_WAVETABLE DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_WAVETABLE)

#define STATIC_KSMUSIC_TECHNOLOGY_SWSYNTH\
    0x37407736L, 0x3620, 0x11D1, 0x85, 0xD3, 0x00, 0x00, 0xF8, 0x75, 0x43, 0x80
DEFINE_GUIDSTRUCT("37407736-3620-11D1-85D3-0000F8754380", KSMUSIC_TECHNOLOGY_SWSYNTH);
#define KSMUSIC_TECHNOLOGY_SWSYNTH DEFINE_GUIDNAMED(KSMUSIC_TECHNOLOGY_SWSYNTH)

#if (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSPROPSETID_WaveTable\
    0x8539E660L, 0x62E9, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("8539E660-62E9-11CF-A5D6-28DB04C10000", KSPROPSETID_WaveTable);
#define KSPROPSETID_WaveTable DEFINE_GUIDNAMED(KSPROPSETID_WaveTable)

typedef enum {
    KSPROPERTY_WAVETABLE_LOAD_SAMPLE,
    KSPROPERTY_WAVETABLE_UNLOAD_SAMPLE,
    KSPROPERTY_WAVETABLE_MEMORY,
    KSPROPERTY_WAVETABLE_VERSION
} KSPROPERTY_WAVETABLE;

#endif // (NTDDI_VERSION < NTDDI_WS03)

typedef struct {
   KSDATARANGE              DataRange;
   GUID                     Technology;
   ULONG                    Channels;
   ULONG                    Notes;
   ULONG                    ChannelMask;
} KSDATARANGE_MUSIC, *PKSDATARANGE_MUSIC;

//===========================================================================

#if (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSEVENTSETID_Cyclic\
    0x142C1AC0L, 0x072A, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("142C1AC0-072A-11D0-A5D6-28DB04C10000", KSEVENTSETID_Cyclic);
#define KSEVENTSETID_Cyclic DEFINE_GUIDNAMED(KSEVENTSETID_Cyclic)

typedef enum {
    KSEVENT_CYCLIC_TIME_INTERVAL,
} KSEVENT_CYCLIC_TIME;

#endif // (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSPROPSETID_Cyclic\
    0x3FFEAEA0L, 0x2BEE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("3FFEAEA0-2BEE-11CF-A5D6-28DB04C10000", KSPROPSETID_Cyclic);
#define KSPROPSETID_Cyclic DEFINE_GUIDNAMED(KSPROPSETID_Cyclic)

typedef enum {
    KSPROPERTY_CYCLIC_POSITION,
} KSPROPERTY_CYCLIC;

//===========================================================================
#define STATIC_KSEVENTSETID_AudioControlChange\
    0xE85E9698L, 0xFA2F, 0x11D1, 0x95, 0xBD, 0x00, 0xC0, 0x4F, 0xB9, 0x25, 0xD3
DEFINE_GUIDSTRUCT("E85E9698-FA2F-11D1-95BD-00C04FB925D3", KSEVENTSETID_AudioControlChange);
#define KSEVENTSETID_AudioControlChange DEFINE_GUIDNAMED(KSEVENTSETID_AudioControlChange)

typedef enum {
    KSEVENT_CONTROL_CHANGE,
} KSEVENT_AUDIO_CONTROL_CHANGE;

//===========================================================================

#define STATIC_KSEVENTSETID_LoopedStreaming\
    0x4682B940L, 0xC6EF, 0x11D0, 0x96, 0xD8, 0x00, 0xAA, 0x00, 0x51, 0xE5, 0x1D
DEFINE_GUIDSTRUCT("4682B940-C6EF-11D0-96D8-00AA0051E51D", KSEVENTSETID_LoopedStreaming);
#define KSEVENTSETID_LoopedStreaming DEFINE_GUIDNAMED(KSEVENTSETID_LoopedStreaming)

typedef enum {
    KSEVENT_LOOPEDSTREAMING_POSITION,
} KSEVENT_LOOPEDSTREAMING;

typedef struct {
    KSEVENTDATA KsEventData;
#if defined(_NTDDK_)
    ULONGLONG   Position;
#else // !_NTDDK_
    DWORDLONG   Position;
#endif // !_NTDDK_
} LOOPEDSTREAMING_POSITION_EVENT_DATA, *PLOOPEDSTREAMING_POSITION_EVENT_DATA ;

#if (NTDDI_VERSION <= NTDDI_WINXP)

#define STATIC_KSEVENTSETID_Sysaudio \
    0x04800320L, 0x4491, 0x11D1, 0xA0, 0x50, 0x40, 0x57, 0x05, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("04800320-4491-11D1-A050-405705C10000", KSEVENTSETID_Sysaudio);
#define KSEVENTSETID_Sysaudio DEFINE_GUIDNAMED(KSEVENTSETID_Sysaudio)

typedef enum {
    KSEVENT_SYSAUDIO_ADDREMOVE_DEVICE
#if (NTDDI_VERSION == NTDDI_WINXP)
    , KSEVENT_SYSAUDIO_CHANGE_DEVICE
#endif
} KSEVENT_SYSAUDIO;

#endif // (NTDDI_VERSION <= NTDDI_WINXP)


#if (NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
#define STATIC_KSPROPSETID_Sysaudio\
    0xCBE3FAA0L, 0xCC75, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("CBE3FAA0-CC75-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio);
#define KSPROPSETID_Sysaudio DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

typedef enum {
    KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
    KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME = 2,
    KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE = 3,
    KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME = 4,
    KSPROPERTY_SYSAUDIO_SELECT_GRAPH = 5,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE = 6,
    KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT = 7,
    KSPROPERTY_SYSAUDIO_INSTANCE_INFO = 14,
    KSPROPERTY_SYSAUDIO_COMPONENT_ID = 16,
} KSPROPERTY_SYSAUDIO;

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION < NTDDI_WINXP)

typedef enum {
    KSPROPERTY_SYSAUDIO_DEVICE_COUNT = 1,
    KSPROPERTY_SYSAUDIO_DEVICE_FRIENDLY_NAME,
    KSPROPERTY_SYSAUDIO_DEVICE_INSTANCE,
    KSPROPERTY_SYSAUDIO_DEVICE_INTERFACE_NAME,
    KSPROPERTY_SYSAUDIO_SELECT_GRAPH,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_DEVICE_DEFAULT,
    KSPROPERTY_SYSAUDIO_ALWAYS_CREATE_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_ADDREMOVE_LOCK,
    KSPROPERTY_SYSAUDIO_ADDREMOVE_UNLOCK,
    KSPROPERTY_SYSAUDIO_RENDER_PIN_INSTANCES,
    KSPROPERTY_SYSAUDIO_RENDER_CONNECTION_INDEX,
    KSPROPERTY_SYSAUDIO_CREATE_VIRTUAL_SOURCE_ONLY,
    KSPROPERTY_SYSAUDIO_INSTANCE_INFO,
    KSPROPERTY_SYSAUDIO_PREFERRED_DEVICE
} KSPROPERTY_SYSAUDIO;

#endif // (NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_VISTA)

typedef struct {
    KSPROPERTY Property;
    GUID PinCategory;
    GUID PinName;
} SYSAUDIO_CREATE_VIRTUAL_SOURCE, *PSYSAUDIO_CREATE_VIRTUAL_SOURCE;

#endif // (NTDDI_VERSION < NTDDI_VISTA)


#if (NTDDI_VERSION < NTDDI_VISTA)

typedef struct {
    KSPROPERTY Property;
    ULONG PinId;
    ULONG NodeId;
    ULONG Flags;
    ULONG Reserved;
} SYSAUDIO_SELECT_GRAPH, *PSYSAUDIO_SELECT_GRAPH;

typedef struct {
    KSPROPERTY Property;
    ULONG Flags;
    ULONG DeviceNumber;
} SYSAUDIO_INSTANCE_INFO, *PSYSAUDIO_INSTANCE_INFO;

#define SYSAUDIO_FLAGS_DONT_COMBINE_PINS        0x00000001

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION < NTDDI_WINXP)
typedef struct {
    KSPROPERTY Property;
    ULONG Flags;
    ULONG Index;            // KSPROPERTY_SYSAUDIO_DEFAULT_TYPE
} SYSAUDIO_PREFERRED_DEVICE, *PSYSAUDIO_PREFERRED_DEVICE;

#define SYSAUDIO_FLAGS_CLEAR_PREFERRED          0x00000002
#endif // (NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_VISTA)


#define STATIC_KSPROPSETID_Sysaudio_Pin \
    0xA3A53220L, 0xC6E4, 0x11D0, 0xB4, 0x65, 0x00, 0x00, 0x1A, 0x18, 0x18, 0xE6
DEFINE_GUIDSTRUCT("A3A53220-C6E4-11D0-B465-00001A1818E6", KSPROPSETID_Sysaudio_Pin);
#define KSPROPSETID_Sysaudio_Pin DEFINE_GUIDNAMED(KSPROPSETID_Sysaudio_Pin)

#endif // (NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

typedef enum {
    KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE = 1,
} KSPROPERTY_SYSAUDIO_PIN;

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

#if (NTDDI_VERSION < NTDDI_WINXP)

typedef enum {
    KSPROPERTY_SYSAUDIO_TOPOLOGY_CONNECTION_INDEX,
    KSPROPERTY_SYSAUDIO_ATTACH_VIRTUAL_SOURCE,
    KSPROPERTY_SYSAUDIO_PIN_VOLUME_NODE
} KSPROPERTY_SYSAUDIO_PIN;

#endif // (NTDDI_VERSION < NTDDI_WINXP)

#if (NTDDI_VERSION < NTDDI_VISTA)

typedef struct {
    KSPROPERTY  Property;
    ULONG       MixerPinId;
    ULONG       Reserved;
} SYSAUDIO_ATTACH_VIRTUAL_SOURCE, *PSYSAUDIO_ATTACH_VIRTUAL_SOURCE;

#endif // (NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
typedef struct {
    KSPROPERTY  Property;
    ULONG       NodeId;
    ULONG       Reserved;
} KSNODEPROPERTY, *PKSNODEPROPERTY;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    LONG           Channel;                   // value to get or set
    ULONG          Reserved;
} KSNODEPROPERTY_AUDIO_CHANNEL, *PKSNODEPROPERTY_AUDIO_CHANNEL;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    ULONG   DevSpecificId;
    ULONG   DeviceInfo;
    ULONG   Length;
} KSNODEPROPERTY_AUDIO_DEV_SPECIFIC, *PKSNODEPROPERTY_AUDIO_DEV_SPECIFIC;

typedef struct {
    KSNODEPROPERTY   NodeProperty;
    PVOID            ListenerId;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} KSNODEPROPERTY_AUDIO_3D_LISTENER, *PKSNODEPROPERTY_AUDIO_3D_LISTENER;

typedef struct {
    KSNODEPROPERTY   NodeProperty;
    PVOID            AppContext;
    ULONG            Length;
#ifndef _WIN64
    ULONG            Reserved;
#endif // _WIN64
} KSNODEPROPERTY_AUDIO_PROPERTY, *PKSNODEPROPERTY_AUDIO_PROPERTY;

#if (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================
// {79A9312E-59AE-43b0-A350-8B05284CAB24}
#define STATIC_KSPROPSETID_AudioGfx\
    0x79a9312eL, 0x59ae, 0x43b0, 0xa3, 0x50, 0x8b, 0x5, 0x28, 0x4c, 0xab, 0x24
DEFINE_GUIDSTRUCT("79A9312E-59AE-43b0-A350-8B05284CAB24", KSPROPSETID_AudioGfx);
#define KSPROPSETID_AudioGfx DEFINE_GUIDNAMED(KSPROPSETID_AudioGfx)

typedef enum {
    KSPROPERTY_AUDIOGFX_RENDERTARGETDEVICEID,
    KSPROPERTY_AUDIOGFX_CAPTURETARGETDEVICEID
} KSPROPERTY_AUDIOGFX;

#endif // (NTDDI_VERSION >= NTDDI_WINXP && NTDDI_VERSION < NTDDI_VISTA)

//===========================================================================

#if (NTDDI_VERSION < NTDDI_WS03)

#define STATIC_KSPROPSETID_Linear\
    0x5A2FFE80L, 0x16B9, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("5A2FFE80-16B9-11D0-A5D6-28DB04C10000", KSPROPSETID_Linear);
#define KSPROPSETID_Linear DEFINE_GUIDNAMED(KSPROPSETID_Linear)

typedef enum {
    KSPROPERTY_LINEAR_POSITION,
} KSPROPERTY_LINEAR;

#endif // (NTDDI_VERSION < NTDDI_WS03)

//===========================================================================


//
// Midi definitions
//

/*
    Formats
*/

#define STATIC_KSDATAFORMAT_TYPE_MUSIC\
    0xE725D360L, 0x62CC, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("E725D360-62CC-11CF-A5D6-28DB04C10000", KSDATAFORMAT_TYPE_MUSIC);
#define KSDATAFORMAT_TYPE_MUSIC DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MUSIC)

// 'mids' == MEDIATYPE_Midi
#define STATIC_KSDATAFORMAT_TYPE_MIDI\
    0x7364696DL, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("7364696D-0000-0010-8000-00aa00389b71", KSDATAFORMAT_TYPE_MIDI);
#define KSDATAFORMAT_TYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI\
    0x1D262760L, 0xE957, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("1D262760-E957-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI);
#define KSDATAFORMAT_SUBTYPE_MIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI)

#define STATIC_KSDATAFORMAT_SUBTYPE_MIDI_BUS\
    0x2CA15FA0L, 0x6CFE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00
DEFINE_GUIDSTRUCT("2CA15FA0-6CFE-11CF-A5D6-28DB04C10000", KSDATAFORMAT_SUBTYPE_MIDI_BUS);
#define KSDATAFORMAT_SUBTYPE_MIDI_BUS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MIDI_BUS)

#define STATIC_KSDATAFORMAT_SUBTYPE_RIFFMIDI\
    0x4995DAF0L, 0x9EE6, 0x11D0, 0xA4, 0x0E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("4995DAF0-9EE6-11D0-A40E-00A0C9223196", KSDATAFORMAT_SUBTYPE_RIFFMIDI);
#define KSDATAFORMAT_SUBTYPE_RIFFMIDI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RIFFMIDI)

/*
    KSDATAFORMAT_SUBTYPE_DIRECTMUSIC
    see DMusicKS.h
*/

// WARNING! This structure MUST be dword aligned
// regardless of the number of data bytes.

typedef struct {
    ULONG   TimeDeltaMs;        // Delta Milliseconds from the previous midiformat
                                // in the packet. The first midiformat in the packet
                                // is a delta from the PTS in the KSSTREAM_HEADER.
    ULONG   ByteCount;          // Number of bytes of data that follow this struct.
} KSMUSICFORMAT, *PKSMUSICFORMAT;

//
// This entire set of MPEG Standard/Dialect Guids are obsolete. Do not use them.
//
//====================================================================================================
//====================================================================================================
// The following official MPEG Formats, Subtypes and Specifiers are listed as required or optional
// These official MPEG GUIDs are the preferred method of supporting MPEG/AC-3 media types in new code.
// Older MPEG GUIDs should also be supported for compatibilty, but these new modes are still required.
//====================================================================================================
//====================================================================================================

/*
This is a summary of what media types/specifiers will be required for all DVD+DSS+DVB+DTV MPEG decoders.
These media types are what the decoder driver must accept, hardware support for all of these media types
may or may not actually be provided by the decoder natively.  These media types are intended to define
the "officially" supported MPEG/AC-3 media types that all WHQL certified decoders must implement.  This
specifically includes driver and/or hardware support for all the required standards and dialects.

All MPEG video decoders must support all of the MPEG video modes shown as [required] below.
All MPEG audio decoders must support all of the MPEG audio modes shown as [required] below.
All AC-3 audio decoders must support all of the AC-3 audio modes shown as [required] below.
The line items shown as [optional] need not be implemented, but are possible formats that might be implemented.

Note that the input/output pin formats are defined by 2 or 3 GUIDs: TYPE, SUBTYPE, and maybe SPECIFIER.
The specifiers are included if the data format is a "dialect" that needs to be differentiated during decoding.
The decoder MUST be prepared to deal with ALL requests for _required_ "Standard" formats OR _required_ "Dialects".

STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM         [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET                [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO            [optional]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]
STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER               [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO           [required]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO            [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO           [optional]
    STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO              [required]
        STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO             [optional]

Note that the SPECIFIER GUIDs normally identify particular versions of MPEG such as DSS and DVD.
This approach was taken to minimize the number of DSS/DVB/DVD/DTV etc. media SUBTYPES.
These specifiers are currently required to disambiguate MPEG syntax _parsing_ by the decoder
using alternate parsing routines or downloadable firmware or hardware decode settings.

In the future these specifiers will be extended to cover new KS MPEG flavors such as DVB and DTV.
Thus, the optional specifiers will be subject to clarification and/or definition as they are needed.

Important note: Per the ITU MPEG specs, MPEG 2 media may contain pure MPEG 1 syntax and
any "MPEG 2" PES packets may actually contain MPEG 1 payloads and MPEG 1 syntax.  Some MPEG
broadcasts can revert from MPEG2 to MPEG1 format data at their discretion, without warning.

CAUTION: Decoders MUST attempt to process MPEG data AS SOON AS POSSIBLE after reception.
In particular, elementary MPEG or MPEG PES packet streams should not be aggregated into DVD
"pack headers" internally before submission to the codec hardware if AT ALL POSSIBLE.  The
reason is that mpeg data may need to be processed immediately but there may be no additional
MPEG data forthcoming to fill up the PES packet OR DVD "pack" in a timely fashion.  This is
particularly true of MPEG dialects that utilize "repeat field signally" to reuse the last
decoded MPEG video field.

*/

/////////////////////////////////////////////////////////////////////////
// The major data type GUIDs that define the data packet encapsulation //
/////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM \
    0x36523b11L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B11-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM );
#define KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_ELEMENTARY_STREAM)

// STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PES_PACKET \
    0x36523b12L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B12-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PES_PACKET );
#define KSDATAFORMAT_TYPE_STANDARD_PES_PACKET DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PES_PACKET)

// STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER
#define STATIC_KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER \
    0x36523b13L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B13-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER );
#define KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_STANDARD_PACK_HEADER)

///////////////////////////////////////////////////////////////////////////////
// The minor data subtype GUIDs that define the exact class of the data type.//
///////////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO \
    0x36523b21L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B21-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_VIDEO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO \
    0x36523b22L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B22-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG1_AUDIO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO \
    0x36523b23L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B23-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_VIDEO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO \
    0x36523b24L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B24-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_MPEG2_AUDIO)

// STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO
#define STATIC_KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO \
    0x36523b25L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B25-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO );
#define KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_STANDARD_AC3_AUDIO)

///////////////////////////////////////////////////////////////////////////////
// The low-level specifier GUIDs that define the flavor of the data subtype. //
// Some SUBTYPES, notably MPEG2_VIDEO, MPEG2_AUDIO have different dialects.  //
// These specifiers are intended to be accompanied by a specifier structure. //
///////////////////////////////////////////////////////////////////////////////

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO \
    0x36523b31L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B31-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_VIDEO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO \
    0x36523b32L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B32-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG1_AUDIO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO    Associated with KS_MPEGVIDEOINFO2 defined later
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO \
    0x36523b33L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B33-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_VIDEO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO    Associated with KS_MPEGAUDIOINFO defined later
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO \
    0x36523b34L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B34-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_MPEG2_AUDIO)

// STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO
#define STATIC_KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO \
    0x36523b35L, 0x8ee5, 0x11d1, 0x8c, 0xa3, 0x00, 0x60, 0xb0, 0x57, 0x66, 0x4a
DEFINE_GUIDSTRUCT("36523B35-8EE5-11d1-8CA3-0060B057664A", KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO );
#define KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_DIALECT_AC3_AUDIO)

//====================================================================================================
//====================================================================================================
//                              *** COMPATIBILITY WARNING ***
// The *following* older DSS, MPEG, DVD & AC-3 GUID definitions are retained for backward compability.
// These MPEG GUIDs should also be supported for compatibilty, but the above newer modes are still required.
//====================================================================================================
//====================================================================================================

//
// DSS definitions
//

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_VIDEO\
    0xa0af4f81L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f81-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_VIDEO);
#define KSDATAFORMAT_SUBTYPE_DSS_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_VIDEO)

#define STATIC_KSDATAFORMAT_SUBTYPE_DSS_AUDIO\
    0xa0af4f82L, 0xe163, 0x11d0, 0xba, 0xd9, 0x00, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("a0af4f82-e163-11d0-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_DSS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DSS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DSS_AUDIO)

//
// End of obsolete MPEG definitions.
//

//
// mpeg 1 definitions
//
#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Packet\
    0xe436eb80, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb80-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Packet);
#define KSDATAFORMAT_SUBTYPE_MPEG1Packet DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Packet)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Payload\
    0xe436eb81, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb81-524f-11ce-9F53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Payload);
#define KSDATAFORMAT_SUBTYPE_MPEG1Payload DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Payload)

// MEDIASUBTYPE_MPEG1Video
#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG1Video\
    0xe436eb86, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb86-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_MPEG1Video);
#define KSDATAFORMAT_SUBTYPE_MPEG1Video DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG1Video)

//FORMAT_MPEGVideo
#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO\
    0x05589f82L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f82-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG1_VIDEO)

//
// mpeg 2 definitions
//
#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PES\
    0xe06d8020L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8020-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PES);
#define KSDATAFORMAT_TYPE_MPEG2_PES DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PES)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_PROGRAM\
    0xe06d8022L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8022-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_PROGRAM);
#define KSDATAFORMAT_TYPE_MPEG2_PROGRAM DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_PROGRAM)

#define STATIC_KSDATAFORMAT_TYPE_MPEG2_TRANSPORT\
    0xe06d8023L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8023-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_TYPE_MPEG2_TRANSPORT);
#define KSDATAFORMAT_TYPE_MPEG2_TRANSPORT DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_MPEG2_TRANSPORT)

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO\
    0xe06d8026L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8026-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_VIDEO)

// use MPEGVIDEOINFO2 (defined below) with KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO
#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO\
    0xe06d80e3L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e3-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_VIDEO)


//
// Mpeg2 video properties
//


#define STATIC_KSPROPSETID_Mpeg2Vid\
    0xC8E11B60L, 0x0CC9, 0x11D0, 0xBD, 0x69, 0x00, 0x35, 0x05, 0xC1, 0x03, 0xA9
DEFINE_GUIDSTRUCT("C8E11B60-0CC9-11D0-BD69-003505C103A9", KSPROPSETID_Mpeg2Vid);
#define  KSPROPSETID_Mpeg2Vid DEFINE_GUIDNAMED( KSPROPSETID_Mpeg2Vid )


typedef enum {
    KSPROPERTY_MPEG2VID_MODES,          // available output modes of decoder
    KSPROPERTY_MPEG2VID_CUR_MODE,       // current mode of the decoder
    KSPROPERTY_MPEG2VID_4_3_RECT,       // output coordinates for 4:3 source
    KSPROPERTY_MPEG2VID_16_9_RECT,      // output coordinates for 16:9 source
    KSPROPERTY_MPEG2VID_16_9_PANSCAN,   // pan and scan vectors
} KSPROPERTY_MPEG2VID;

//
// bit field definitions for MPEG2 VIDEO mode
//

#define KSMPEGVIDMODE_PANSCAN   0x0001
#define KSMPEGVIDMODE_LTRBOX    0x0002
#define KSMPEGVIDMODE_SCALE     0x0004

//
// rectangle definitions for the 4/3 and 16/9 cropping properties of
// the MPEG2Video decoder
//

typedef struct _KSMPEGVID_RECT {
    ULONG StartX;
    ULONG StartY;
    ULONG EndX;
    ULONG EndY;
} KSMPEGVID_RECT, *PKSMPEGVID_RECT;

//
// Params for pan / scan
//


//
// MPEG2 Audio definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO\
    0xe06d802bL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802b-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO);
#define KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_MPEG2_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO\
    0xe06d80e5L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e5-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO);
#define KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_MPEG2_AUDIO)

//
// DVD LPCM Audio definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_LPCM_AUDIO\
    0xe06d8032L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8032-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_LPCM_AUDIO);
#define KSDATAFORMAT_SUBTYPE_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_LPCM_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_LPCM_AUDIO\
    0xe06d80e6L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e6-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_LPCM_AUDIO);
#define KSDATAFORMAT_SPECIFIER_LPCM_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_LPCM_AUDIO)

//
// AC-3 definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_AC3_AUDIO\
    0xe06d802cL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802c-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_AC3_AUDIO);
#define KSDATAFORMAT_SUBTYPE_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_AC3_AUDIO)

#define STATIC_KSDATAFORMAT_SPECIFIER_AC3_AUDIO\
    0xe06d80e4L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d80e4-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SPECIFIER_AC3_AUDIO);
#define KSDATAFORMAT_SPECIFIER_AC3_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_AC3_AUDIO)

#define STATIC_KSPROPSETID_AC3\
    0xBFABE720L, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00
DEFINE_GUIDSTRUCT("BFABE720-6E1F-11D0-BCF2-444553540000", KSPROPSETID_AC3);
#define KSPROPSETID_AC3 DEFINE_GUIDNAMED(KSPROPSETID_AC3)

typedef enum {
    KSPROPERTY_AC3_ERROR_CONCEALMENT = 1,
    KSPROPERTY_AC3_ALTERNATE_AUDIO,
    KSPROPERTY_AC3_DOWNMIX,
    KSPROPERTY_AC3_BIT_STREAM_MODE,
    KSPROPERTY_AC3_DIALOGUE_LEVEL,
    KSPROPERTY_AC3_LANGUAGE_CODE,
    KSPROPERTY_AC3_ROOM_TYPE
} KSPROPERTY_AC3;

typedef struct  {
    BOOL        fRepeatPreviousBlock;
    BOOL        fErrorInCurrentBlock;
} KSAC3_ERROR_CONCEALMENT, *PKSAC3_ERROR_CONCEALMENT;

typedef struct {
    BOOL    fStereo;
    ULONG   DualMode;
} KSAC3_ALTERNATE_AUDIO, *PKSAC3_ALTERNATE_AUDIO;

#define KSAC3_ALTERNATE_AUDIO_1     1
#define KSAC3_ALTERNATE_AUDIO_2     2
#define KSAC3_ALTERNATE_AUDIO_BOTH  3

typedef struct {
    BOOL        fDownMix;
    BOOL        fDolbySurround;
} KSAC3_DOWNMIX, *PKSAC3_DOWNMIX;

typedef struct {
    LONG        BitStreamMode;
} KSAC3_BIT_STREAM_MODE, *PKSAC3_BIT_STREAM_MODE;

#define KSAC3_SERVICE_MAIN_AUDIO            0
#define KSAC3_SERVICE_NO_DIALOG             1
#define KSAC3_SERVICE_VISUALLY_IMPAIRED     2
#define KSAC3_SERVICE_HEARING_IMPAIRED      3
#define KSAC3_SERVICE_DIALOG_ONLY           4
#define KSAC3_SERVICE_COMMENTARY            5
#define KSAC3_SERVICE_EMERGENCY_FLASH       6
#define KSAC3_SERVICE_VOICE_OVER            7

typedef struct {
    ULONG   DialogueLevel;
} KSAC3_DIALOGUE_LEVEL, *PKSAC3_DIALOGUE_LEVEL;

typedef struct {
    BOOL    fLargeRoom;
} KSAC3_ROOM_TYPE, *PKSAC3_ROOM_TYPE;

// New formats enabled by CEA 861 specifciation
#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DOLBY_AC3_SPDIF)
DEFINE_GUIDSTRUCT("00000092-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_WMASPDIF)
DEFINE_GUIDSTRUCT("00000164-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO);
#define KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_WMA_PRO)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DTS\
    DEFINE_WAVEFORMATEX_GUID(WAVE_FORMAT_DTS)
DEFINE_GUIDSTRUCT("00000008-0000-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DTS);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DTS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DTS)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1 \
    0x00000003L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000003-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1);
#define KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_MPEG1)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2 \
    0x00000004L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000004-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2);
#define KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_MPEG2)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3 \
    0x00000005L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000005-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3);
#define KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_MPEG3)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_AAC \
    0x00000006L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000006-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_AAC);
#define KSDATAFORMAT_SUBTYPE_IEC61937_AAC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_AAC)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC \
    0x00000008L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000008-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC);
#define KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_ATRAC)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO \
    0x00000009L, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("00000009-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO);
#define KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_ONE_BIT_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS \
    0x0000000aL, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("0000000a-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_DIGITAL_PLUS)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD \
    0x0000000bL, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("0000000b-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DTS_HD)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP \
    0x0000000cL, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("0000000c-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DOLBY_MLP)

#define STATIC_KSDATAFORMAT_SUBTYPE_IEC61937_DST \
    0x0000000dL, 0x0cea, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71
DEFINE_GUIDSTRUCT("0000000d-0cea-0010-8000-00aa00389b71", KSDATAFORMAT_SUBTYPE_IEC61937_DST);
#define KSDATAFORMAT_SUBTYPE_IEC61937_DST DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_IEC61937_DST)


#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// DTS and SDDS definitions (media subtype GUIDs)
//
#define STATIC_KSDATAFORMAT_SUBTYPE_DTS_AUDIO\
    0xe06d8033L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8033-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_DTS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_DTS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_DTS_AUDIO)

#define STATIC_KSDATAFORMAT_SUBTYPE_SDDS_AUDIO\
    0xe06d8034L, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d8034-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SDDS_AUDIO);
#define KSDATAFORMAT_SUBTYPE_SDDS_AUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SDDS_AUDIO)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//
// audio decoder output properties
//

#define STATIC_KSPROPSETID_AudioDecoderOut\
    0x6ca6e020L, 0x43bd, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("6ca6e020-43bd-11d0-bd6a-003505c103a9", KSPROPSETID_AudioDecoderOut);
#define KSPROPSETID_AudioDecoderOut DEFINE_GUIDNAMED(KSPROPSETID_AudioDecoderOut)

typedef enum {
    KSPROPERTY_AUDDECOUT_MODES,         // available output modes of decoder
    KSPROPERTY_AUDDECOUT_CUR_MODE,      // current mode of the decoder
} KSPROPERTY_AUDDECOUT;

#define KSAUDDECOUTMODE_STEREO_ANALOG   0x0001
#define KSAUDDECOUTMODE_PCM_51          0x0002
#define KSAUDDECOUTMODE_SPDIFF          0x0004



//
// subpicture definition
//

#define STATIC_KSDATAFORMAT_SUBTYPE_SUBPICTURE\
    0xe06d802dL, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea
DEFINE_GUIDSTRUCT("e06d802d-db46-11cf-b4d1-00805f6cbbea", KSDATAFORMAT_SUBTYPE_SUBPICTURE);
#define KSDATAFORMAT_SUBTYPE_SUBPICTURE DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_SUBPICTURE)


#define STATIC_KSPROPSETID_DvdSubPic\
    0xac390460L, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9
DEFINE_GUIDSTRUCT("ac390460-43af-11d0-bd6a-003505c103a9", KSPROPSETID_DvdSubPic);
#define KSPROPSETID_DvdSubPic DEFINE_GUIDNAMED(KSPROPSETID_DvdSubPic)

typedef enum {
    KSPROPERTY_DVDSUBPIC_PALETTE,
    KSPROPERTY_DVDSUBPIC_HLI,
    KSPROPERTY_DVDSUBPIC_COMPOSIT_ON,  // TRUE for subpicture is displayed
} KSPROPERTY_DVDSUBPIC;

typedef struct _KS_DVD_YCrCb {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   Cr;
    UCHAR   Cb;
} KS_DVD_YCrCb, *PKS_DVD_YCrCb;

/* The KS_DVD_YUV structure is now superseded by KS_DVD_YCrCb above and is
   here for backward compatibility only */

typedef struct _KS_DVD_YUV {
    UCHAR   Reserved;
    UCHAR   Y;
    UCHAR   V;
    UCHAR   U;
} KS_DVD_YUV, *PKS_DVD_YUV;

typedef struct _KSPROPERTY_SPPAL {
    KS_DVD_YUV sppal[16];
} KSPROPERTY_SPPAL, *PKSPROPERTY_SPPAL;

typedef struct _KS_COLCON {
    UCHAR emph1col:4;
    UCHAR emph2col:4;
    UCHAR backcol:4;
    UCHAR patcol:4;
    UCHAR emph1con:4;
    UCHAR emph2con:4;
    UCHAR backcon:4;
    UCHAR patcon:4;

} KS_COLCON, *PKS_COLCON;

typedef struct _KSPROPERTY_SPHLI {
    USHORT      HLISS;
    USHORT      Reserved;
    ULONG       StartPTM;   // start presentation time in x/90000
    ULONG       EndPTM;     // end PTM in x/90000
    USHORT      StartX;
    USHORT      StartY;
    USHORT      StopX;
    USHORT      StopY;
    KS_COLCON   ColCon;     // color contrast description (4 bytes as given in HLI)
} KSPROPERTY_SPHLI, *PKSPROPERTY_SPHLI;

typedef BOOL KSPROPERTY_COMPOSIT_ON, *PKSPROPERTY_COMPOSIT_ON;

#define STATIC_KSPROPSETID_CopyProt \
    0x0E8A0A40L, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3
DEFINE_GUIDSTRUCT("0E8A0A40-6AEF-11D0-9ED0-00A024CA19B3", KSPROPSETID_CopyProt);
#define KSPROPSETID_CopyProt DEFINE_GUIDNAMED(KSPROPSETID_CopyProt)

typedef enum {

    KSPROPERTY_DVDCOPY_CHLG_KEY = 0x01,
    KSPROPERTY_DVDCOPY_DVD_KEY1,
    KSPROPERTY_DVDCOPY_DEC_KEY2,
    KSPROPERTY_DVDCOPY_TITLE_KEY,
    KSPROPERTY_COPY_MACROVISION,
    KSPROPERTY_DVDCOPY_REGION,
    KSPROPERTY_DVDCOPY_SET_COPY_STATE,
    KSPROPERTY_DVDCOPY_DISC_KEY = 0x80

} KSPROPERTY_COPYPROT;

typedef struct _KS_DVDCOPY_CHLGKEY {
    BYTE ChlgKey[10];
    BYTE Reserved[2];
} KS_DVDCOPY_CHLGKEY, *PKS_DVDCOPY_CHLGKEY;

typedef struct _KS_DVDCOPY_BUSKEY {
    BYTE BusKey[5];
    BYTE Reserved[1];
} KS_DVDCOPY_BUSKEY, *PKS_DVDCOPY_BUSKEY;


typedef struct _KS_DVDCOPY_DISCKEY {
    BYTE DiscKey[2048];
} KS_DVDCOPY_DISCKEY, *PKS_DVDCOPY_DISCKEY;

typedef struct _KS_DVDCOPY_REGION {
    UCHAR   Reserved;
    UCHAR   RegionData;
    UCHAR   Reserved2[2];
} KS_DVDCOPY_REGION, *PKS_DVDCOPY_REGION;

typedef struct _KS_DVDCOPY_TITLEKEY {
    ULONG KeyFlags;
    ULONG ReservedNT[2];
    UCHAR TitleKey[6];
    UCHAR Reserved[2];
} KS_DVDCOPY_TITLEKEY, *PKS_DVDCOPY_TITLEKEY;

typedef struct _KS_COPY_MACROVISION {
    ULONG MACROVISIONLevel;
} KS_COPY_MACROVISION, *PKS_COPY_MACROVISION;

typedef struct _KS_DVDCOPY_SET_COPY_STATE {
    ULONG DVDCopyState;
} KS_DVDCOPY_SET_COPY_STATE, *PKS_DVDCOPY_SET_COPY_STATE;

typedef enum {
    KS_DVDCOPYSTATE_INITIALIZE,         // indicates we are starting a full
                                        // copy protection sequence.
    KS_DVDCOPYSTATE_INITIALIZE_TITLE,   // indicates we are starting a title
                                        // key copy protection sequence
    KS_DVDCOPYSTATE_AUTHENTICATION_NOT_REQUIRED,
    KS_DVDCOPYSTATE_AUTHENTICATION_REQUIRED,
    KS_DVDCOPYSTATE_DONE,
} KS_DVDCOPYSTATE;

typedef enum {
    KS_MACROVISION_DISABLED,
    KS_MACROVISION_LEVEL1,
    KS_MACROVISION_LEVEL2,
    KS_MACROVISION_LEVEL3
} KS_COPY_MACROVISION_LEVEL, *PKS_COPY_MACROVISION_LEVEL;

//
// CGMS Copy Protection Flags
//

#define KS_DVD_CGMS_RESERVED_MASK      0x00000078

#define KS_DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define KS_DVD_CGMS_COPY_PERMITTED     0x00000000
#define KS_DVD_CGMS_COPY_ONCE          0x00000010
#define KS_DVD_CGMS_NO_COPY            0x00000018

#define KS_DVD_COPYRIGHT_MASK          0x00000040
#define KS_DVD_NOT_COPYRIGHTED         0x00000000
#define KS_DVD_COPYRIGHTED             0x00000040

#define KS_DVD_SECTOR_PROTECT_MASK     0x00000020
#define KS_DVD_SECTOR_NOT_PROTECTED    0x00000000
#define KS_DVD_SECTOR_PROTECTED        0x00000020


//===========================================================================
// The following MUST match the structures in WinGDI.h and AMVideo.h
//===========================================================================

#define STATIC_KSCATEGORY_TVTUNER \
    0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a800-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVTUNER);
#define KSCATEGORY_TVTUNER DEFINE_GUIDNAMED(KSCATEGORY_TVTUNER)

#define STATIC_KSCATEGORY_CROSSBAR \
    0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a801-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_CROSSBAR);
#define KSCATEGORY_CROSSBAR DEFINE_GUIDNAMED(KSCATEGORY_CROSSBAR)

#define STATIC_KSCATEGORY_TVAUDIO \
    0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a802-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_TVAUDIO);
#define KSCATEGORY_TVAUDIO DEFINE_GUIDNAMED(KSCATEGORY_TVAUDIO)

#define STATIC_KSCATEGORY_VPMUX \
    0xa799a803L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4
DEFINE_GUIDSTRUCT("a799a803-a46d-11d0-a18c-00a02401dcd4", KSCATEGORY_VPMUX);
#define KSCATEGORY_VPMUX DEFINE_GUIDNAMED(KSCATEGORY_VPMUX)

#define STATIC_KSCATEGORY_VBICODEC \
    0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("07dad660-22f1-11d1-a9f4-00c04fbbde8f", KSCATEGORY_VBICODEC);
#define KSCATEGORY_VBICODEC DEFINE_GUIDNAMED(KSCATEGORY_VBICODEC)

// SUBTYPE_VPVideo
#define STATIC_KSDATAFORMAT_SUBTYPE_VPVideo\
    0x5a9b6a40L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a40-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVideo);
#define KSDATAFORMAT_SUBTYPE_VPVideo DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVideo)

// SUBTYPE_VPVBI
#define STATIC_KSDATAFORMAT_SUBTYPE_VPVBI\
    0x5a9b6a41L, 0x1a22, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("5a9b6a41-1a22-11d1-bad9-00609744111a", KSDATAFORMAT_SUBTYPE_VPVBI);
#define KSDATAFORMAT_SUBTYPE_VPVBI DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_VPVBI)


// FORMAT_VideoInfo
#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO\
    0x05589f80L, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a
DEFINE_GUIDSTRUCT("05589f80-c356-11ce-bf01-00aa0055595a", KSDATAFORMAT_SPECIFIER_VIDEOINFO);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO)

// FORMAT_VideoInfo2
#define STATIC_KSDATAFORMAT_SPECIFIER_VIDEOINFO2\
    0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76A0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VIDEOINFO2);
#define KSDATAFORMAT_SPECIFIER_VIDEOINFO2 DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VIDEOINFO2)

// MEDIATYPE_AnalogVideo
#define STATIC_KSDATAFORMAT_TYPE_ANALOGVIDEO\
    0x0482dde1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde1-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_TYPE_ANALOGVIDEO);
#define KSDATAFORMAT_TYPE_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGVIDEO)

// FORMAT_AnalogVideo
#define STATIC_KSDATAFORMAT_SPECIFIER_ANALOGVIDEO\
    0x0482dde0L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482dde0-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_SPECIFIER_ANALOGVIDEO);
#define KSDATAFORMAT_SPECIFIER_ANALOGVIDEO DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_ANALOGVIDEO)

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

// MEDIATYPE_AnalogAudio
#define STATIC_KSDATAFORMAT_TYPE_ANALOGAUDIO \
    0x0482dee1L, 0x7817, 0x11cf, 0x8a, 0x03, 0x00, 0xaa, 0x00, 0x6e, 0xcb, 0x65
DEFINE_GUIDSTRUCT("0482DEE1-7817-11cf-8a03-00aa006ecb65", KSDATAFORMAT_TYPE_ANALOGAUDIO);
#define KSDATAFORMAT_TYPE_ANALOGAUDIO DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_ANALOGAUDIO)

#endif // XP SP2 and later (chronologically)

// FORMAT_VBI
#define STATIC_KSDATAFORMAT_SPECIFIER_VBI\
    0xf72a76e0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e0-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SPECIFIER_VBI);
#define KSDATAFORMAT_SPECIFIER_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_SPECIFIER_VBI)

// MEDIATYPE_VBI
#define STATIC_KSDATAFORMAT_TYPE_VBI\
    0xf72a76e1L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e1-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_TYPE_VBI);
#define KSDATAFORMAT_TYPE_VBI DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_VBI)

// SUBTYPE_RAW8
#define STATIC_KSDATAFORMAT_SUBTYPE_RAW8\
    0xca20d9a0, 0x3e3e, 0x11d1, 0x9b, 0xf9, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0xbf
DEFINE_GUIDSTRUCT("ca20d9a0-3e3e-11d1-9bf9-00c04fbbdebf", KSDATAFORMAT_SUBTYPE_RAW8);
#define KSDATAFORMAT_SUBTYPE_RAW8 DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_RAW8)

#if (NTDDI_VERSION >= NTDDI_WINXP)

// MEDIASUBTYPE_CC
#define STATIC_KSDATAFORMAT_SUBTYPE_CC\
    0x33214cc1, 0x11f, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
DEFINE_GUIDSTRUCT("33214CC1-011F-11D2-B4B1-00A0D102CFBE", KSDATAFORMAT_SUBTYPE_CC);
#define KSDATAFORMAT_SUBTYPE_CC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_CC)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// MEDIASUBTYPE_NABTS
#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS\
    0xf72a76e2L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e2-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_NABTS);
#define KSDATAFORMAT_SUBTYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS)

// MEDIASUBTYPE_TELETEXT
#define STATIC_KSDATAFORMAT_SUBTYPE_TELETEXT\
    0xf72a76e3L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x00, 0x00, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("f72a76e3-eb0a-11d0-ace4-0000c0cc16ba", KSDATAFORMAT_SUBTYPE_TELETEXT);
#define KSDATAFORMAT_SUBTYPE_TELETEXT DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_TELETEXT)



/* constants for the biCompression field */
#define KS_BI_RGB        0L
#define KS_BI_RLE8       1L
#define KS_BI_RLE4       2L
#define KS_BI_BITFIELDS  3L

typedef struct tagKS_RGBQUAD { // rgbq
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} KS_RGBQUAD, *PKS_RGBQUAD;

/* constants for palettes */
#define KS_iPALETTE_COLORS 256     // Maximum colours in palette
#define KS_iEGA_COLORS 16          // Number colours in EGA palette
#define KS_iMASK_COLORS 3          // Maximum three components
#define KS_iTRUECOLOR 16           // Minimum true colour device
#define KS_iRED 0                  // Index position for RED mask
#define KS_iGREEN 1                // Index position for GREEN mask
#define KS_iBLUE 2                 // Index position for BLUE mask
#define KS_iPALETTE 8              // Maximum colour depth using a palette
#define KS_iMAXBITS 8              // Maximum bits per colour component
#define KS_SIZE_EGA_PALETTE (KS_iEGA_COLORS * sizeof(KS_RGBQUAD))
#define KS_SIZE_PALETTE (KS_iPALETTE_COLORS * sizeof(KS_RGBQUAD))

typedef struct tagKS_BITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} KS_BITMAPINFOHEADER, *PKS_BITMAPINFOHEADER;

// Used for true colour images that also have a palette

typedef struct tag_KS_TRUECOLORINFO {
    DWORD   dwBitMasks[KS_iMASK_COLORS];
    KS_RGBQUAD bmiColors[KS_iPALETTE_COLORS];
} KS_TRUECOLORINFO, *PKS_TRUECOLORINFO;


#define KS_WIDTHBYTES(bits) ((DWORD)(((bits)+31) & (~31)) / 8)
#define KS_DIBWIDTHBYTES(bi) (DWORD)KS_WIDTHBYTES((DWORD)(bi).biWidth * (DWORD)(bi).biBitCount)
#define KS__DIBSIZE(bi) (KS_DIBWIDTHBYTES(bi) * (DWORD)(bi).biHeight)
#define KS_DIBSIZE(bi) ((bi).biHeight < 0 ? (-1)*(KS__DIBSIZE(bi)) : KS__DIBSIZE(bi))

typedef LONGLONG REFERENCE_TIME;

// The BITMAPINFOHEADER contains all the details about the video stream such
// as the actual image dimensions and their pixel depth. A source filter may
// also request that the sink take only a section of the video by providing a
// clipping rectangle in rcSource. In the worst case where the sink filter
// forgets to check this on connection it will simply render the whole thing
// which isn't a disaster. Ideally a sink filter will check the rcSource and
// if it doesn't support image extraction and the rectangle is not empty then
// it will reject the connection. A filter should use SetRectEmpty to reset a
// rectangle to all zeroes (and IsRectEmpty to later check the rectangle).
// The rcTarget specifies the destination rectangle for the video, for most
// source filters they will set this to all zeroes, a downstream filter may
// request that the video be placed in a particular area of the buffers it
// supplies in which case it will call QueryAccept with a non empty target

typedef struct tagKS_VIDEOINFOHEADER {

    RECT                rcSource;          // The bit we really want to use
    RECT                rcTarget;          // Where the video should go
    DWORD               dwBitRate;         // Approximate bit data rate
    DWORD               dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME      AvgTimePerFrame;   // Average time per frame (100ns units)

    KS_BITMAPINFOHEADER bmiHeader;

} KS_VIDEOINFOHEADER, *PKS_VIDEOINFOHEADER;

// !!! WARNING !!!
// DO NOT use the following structure unless you are sure that the BITMAPINFOHEADER
// has a normal biSize == sizeof(BITMAPINFOHEADER) !
// !!! WARNING !!!

typedef struct tagKS_VIDEOINFO {

    RECT            rcSource;          // The bit we really want to use
    RECT            rcTarget;          // Where the video should go
    DWORD           dwBitRate;         // Approximate bit data rate
    DWORD           dwBitErrorRate;    // Bit error rate for this stream
    REFERENCE_TIME  AvgTimePerFrame;   // Average time per frame (100ns units)

    KS_BITMAPINFOHEADER bmiHeader;

    union {
        KS_RGBQUAD          bmiColors[KS_iPALETTE_COLORS];     // Colour palette
        DWORD               dwBitMasks[KS_iMASK_COLORS];       // True colour masks
        KS_TRUECOLORINFO    TrueColorInfo;                     // Both of the above
    };

} KS_VIDEOINFO, *PKS_VIDEOINFO;


#define KS_SIZE_MASKS (KS_iMASK_COLORS * sizeof(DWORD))
#define KS_SIZE_PREHEADER (FIELD_OFFSET(KS_VIDEOINFOHEADER,bmiHeader))

// For normal size
// #define KS_SIZE_VIDEOHEADER (sizeof(KS_BITMAPINFOHEADER) + KS_SIZE_PREHEADER)
// !!! for abnormal biSizes
#define KS_SIZE_VIDEOHEADER(pbmi) ((pbmi)->bmiHeader.biSize + KS_SIZE_PREHEADER)

// VBI
// Used for NABTS, CC, Intercast, WST
typedef struct tagKS_VBIINFOHEADER {
    ULONG       StartLine;              // inclusive
    ULONG       EndLine;                // inclusive
    ULONG       SamplingFrequency;      // Hz.
    ULONG       MinLineStartTime;       // microSec * 100 from HSync LE
    ULONG       MaxLineStartTime;       // microSec * 100 from HSync LE
    ULONG       ActualLineStartTime;    // microSec * 100 from HSync LE
    ULONG       ActualLineEndTime;      // microSec * 100 from HSync LE
    ULONG       VideoStandard;          // KS_AnalogVideoStandard*
    ULONG       SamplesPerLine;
    ULONG       StrideInBytes;          // May be > SamplesPerLine
    ULONG       BufferSize;             // Bytes
} KS_VBIINFOHEADER, *PKS_VBIINFOHEADER;

#if (NTDDI_VERSION >= NTDDI_WINXP)

// VBI Sampling Rates
#define KS_VBIDATARATE_NABTS            (5727272L)
#define KS_VBIDATARATE_CC               ( 503493L)    // ~= 1/1.986125e-6
#define KS_VBISAMPLINGRATE_4X_NABTS     ((long)(4*KS_VBIDATARATE_NABTS))
#define KS_VBISAMPLINGRATE_47X_NABTS    ((long)(27000000))
#define KS_VBISAMPLINGRATE_5X_NABTS     ((long)(5*KS_VBIDATARATE_NABTS))

#define KS_47NABTS_SCALER (KS_VBISAMPLINGRATE_47X_NABTS/(double)KS_VBIDATARATE_NABTS)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

// Analog video variant - Use this when the format is FORMAT_AnalogVideo
//
// rcSource defines the portion of the active video signal to use
// rcTarget defines the destination rectangle
//    both of the above are relative to the dwActiveWidth and dwActiveHeight fields
// dwActiveWidth is currently set to 720 for all formats (but could change for HDTV)
// dwActiveHeight is 483 for NTSC and 575 for PAL/SECAM  (but could change for HDTV)

typedef struct tagKS_AnalogVideoInfo {
    RECT            rcSource;           // Width max is 720, height varies w/ TransmissionStd
    RECT            rcTarget;           // Where the video should go
    DWORD           dwActiveWidth;      // Always 720 (CCIR-601 active samples per line)
    DWORD           dwActiveHeight;     // 483 for NTSC, 575 for PAL/SECAM
    REFERENCE_TIME  AvgTimePerFrame;    // Normal ActiveMovie units (100 nS)
} KS_ANALOGVIDEOINFO, *PKS_ANALOGVIDEOINFO;

//===========================================================================
// Data packet passed on Analog video stream channel change
//===========================================================================

#define KS_TVTUNER_CHANGE_BEGIN_TUNE    0x0001L  // Starting a tuning operation
#define KS_TVTUNER_CHANGE_END_TUNE      0x0002L  // Ending a tuning operation

typedef struct tagKS_TVTUNER_CHANGE_INFO {
   DWORD                    dwFlags;                // KS_TVTUNER_CHANGE_*
   DWORD                    dwCountryCode;
   DWORD                    dwAnalogVideoStandard;  // KS_AnalogVideoStandard
   DWORD                    dwChannel;
} KS_TVTUNER_CHANGE_INFO, *PKS_TVTUNER_CHANGE_INFO;

//===========================================================================
// Video format blocks
//===========================================================================

typedef enum {
    KS_MPEG2Level_Low,
    KS_MPEG2Level_Main,
    KS_MPEG2Level_High1440,
    KS_MPEG2Level_High
} KS_MPEG2Level;

typedef enum {
    KS_MPEG2Profile_Simple,
    KS_MPEG2Profile_Main,
    KS_MPEG2Profile_SNRScalable,
    KS_MPEG2Profile_SpatiallyScalable,
    KS_MPEG2Profile_High
} KS_MPEG2Profile;

#define KS_INTERLACE_IsInterlaced            0x00000001  // if 0, other interlace bits are irrelevent
#define KS_INTERLACE_1FieldPerSample         0x00000002  // else 2 fields per media sample
#define KS_INTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
#define KS_INTERLACE_UNUSED                  0x00000008  //
#define KS_INTERLACE_FieldPatternMask        0x00000030  // use this mask with AMINTERLACE_FieldPat*
#define KS_INTERLACE_FieldPatField1Only      0x00000000  // Data never contains a Field2
#define KS_INTERLACE_FieldPatField2Only      0x00000010  // Data never contains a Field1
#define KS_INTERLACE_FieldPatBothRegular     0x00000020  // There will be a Field2 for every Field1 (required for Weave?)
#define KS_INTERLACE_FieldPatBothIrregular   0x00000030  // Random pattern of Field1s and Field2s
#define KS_INTERLACE_DisplayModeMask         0x000000c0
#define KS_INTERLACE_DisplayModeBobOnly      0x00000000
#define KS_INTERLACE_DisplayModeWeaveOnly    0x00000040
#define KS_INTERLACE_DisplayModeBobOrWeave   0x00000080

#define KS_COPYPROTECT_RestrictDuplication   0x00000001  // duplication of this stream should be restricted

#define KS_MPEG2_DoPanScan           0x00000001  //if set, the MPEG-2 video decoder should crop output image
                                                //  based on pan-scan vectors in picture_display_extension
                                                //  and change the picture aspect ratio accordingly.
#define KS_MPEG2_DVDLine21Field1     0x00000002  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 1
#define KS_MPEG2_DVDLine21Field2     0x00000004  //if set, the MPEG-2 decoder must be able to produce an output
                                                //  pin for DVD style closed caption data found in GOP layer of field 2
#define KS_MPEG2_SourceIsLetterboxed 0x00000008  //if set, indicates that black bars have been encoded in the top
                                                //  and bottom of the video.
#define KS_MPEG2_FilmCameraMode      0x00000010  //if set, indicates "film mode" used for 625/50 content.  If cleared,
                                                //  indicates that "camera mode" was used.
#define KS_MPEG2_LetterboxAnalogOut  0x00000020  //if set and this stream is sent to an analog output, it should
                        //  be letterboxed.  Streams sent to VGA should be letterboxed only by renderers.
#define KS_MPEG2_DSS_UserData        0x00000040  //if set, the MPEG-2 decoder must process DSS style user data
#define KS_MPEG2_DVB_UserData        0x00000080  //if set, the MPEG-2 decoder must process DVB style user data
#define KS_MPEG2_27MhzTimebase       0x00000100  //if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define KS_MPEG2_WidescreenAnalogOut 0x00000200  //if set and this stream is sent to an analog output, it should
                        //  be in widescreen format (4x3 content should be centered on a 16x9 output).
                        //  Streams sent to VGA should be widescreened only by renderers.

#define KS_AMCONTROL_USED              0x00000001 // Used to test if these flags are supported.  Set and test for AcceptMediaType.
                                                // If rejected, then you cannot use the AMCONTROL flags (send 0 for dwReserved1)
#define KS_AMCONTROL_PAD_TO_4x3        0x00000002 // if set means display the image in a 4x3 area
#define KS_AMCONTROL_PAD_TO_16x9       0x00000004 // if set means display the image in a 16x9 area
#define KS_AMCONTROL_COLORINFO_PRESENT 0x00000080 // if set, indicates DXVA color info is present in the upper (24) bits of the dwControlFlags

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

typedef struct tagKS_VIDEOINFOHEADER2 {
    RECT                rcSource;
    RECT                rcTarget;
    DWORD               dwBitRate;
    DWORD               dwBitErrorRate;
    REFERENCE_TIME      AvgTimePerFrame;
    DWORD               dwInterlaceFlags;   // use AMINTERLACE_* defines. Reject connection if undefined bits are not 0
    DWORD               dwCopyProtectFlags; // use KS_COPYPROTECT_* defines. Reject connection if undefined bits are not 0
    DWORD               dwPictAspectRatioX; // X dimension of picture aspect ratio, e.g. 16 for 16x9 display
    DWORD               dwPictAspectRatioY; // Y dimension of picture aspect ratio, e.g.  9 for 16x9 display
    union {
        DWORD dwControlFlags;               // use KS_AMCONTROL_* defines, use this from now on
        DWORD dwReserved1;                  // for backward compatiblity (was "must be 0";  connection rejected otherwise)
    };
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    KS_BITMAPINFOHEADER bmiHeader;
} KS_VIDEOINFOHEADER2, *PKS_VIDEOINFOHEADER2;

typedef struct tagKS_MPEG1VIDEOINFO {
    KS_VIDEOINFOHEADER hdr; // Compatible with VIDEOINFO
    DWORD dwStartTimeCode; // 25-bit Group of pictures time code at start of data
    DWORD cbSequenceHeader; // Length in bytes of bSequenceHeader
    BYTE bSequenceHeader[1]; // Sequence header including quantization matrices if any
} KS_MPEG1VIDEOINFO, *PKS_MPEG1VIDEOINFO;

#define KS_MAX_SIZE_MPEG1_SEQUENCE_INFO 140
#define KS_SIZE_MPEG1VIDEOINFO(pv) (FIELD_OFFSET(KS_MPEG1VIDEOINFO, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

typedef struct tagKS_MPEGVIDEOINFO2 {
    KS_VIDEOINFOHEADER2 hdr;
    DWORD               dwStartTimeCode;        //  ?? not used for DVD ??
    DWORD               cbSequenceHeader;       // is 0 for DVD (no sequence header)
    DWORD               dwProfile;              // use enum MPEG2Profile
    DWORD               dwLevel;                // use enum MPEG2Level
    DWORD               dwFlags;                // use AMMPEG2_* defines.  Reject connection if undefined bits are not 0
    DWORD               bSequenceHeader[1];     // DWORD instead of Byte for alignment purposes
                                                //   For MPEG-2, if a sequence_header is included, the sequence_extension
                                                //   should also be included
} KS_MPEGVIDEOINFO2, *PKS_MPEGVIDEOINFO2;


#define KS_SIZE_MPEGVIDEOINFO2(pv) (FIELD_OFFSET(KS_MPEGVIDEOINFO2, bSequenceHeader[0]) + (pv)->cbSequenceHeader)
#define KS_MPEG1_SEQUENCE_INFO(pv) ((const BYTE *)(pv)->bSequenceHeader)

//===========================================================================
// Audio format blocks
//===========================================================================

//if set, the PTS,DTS timestamps advance at 27MHz rather than 90KHz
#define KS_MPEGAUDIOINFO_27MhzTimebase      0x00000001

typedef struct tagKS_MPEAUDIOINFO {
    DWORD               dwFlags;            // use KS_MPEGAUDIOINFO_* defines.  Reject connection if undefined bits are not 0
    DWORD               dwReserved1;        // must be 0; reject connection otherwise
    DWORD               dwReserved2;        // must be 0; reject connection otherwise
    DWORD               dwReserved3;        // must be 0; reject connection otherwise
} KS_MPEGAUDIOINFO, *PKS_MPEGAUDIOINFO;

//===========================================================================
// Video DATAFORMATs
//===========================================================================

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFOHEADER      VideoInfoHeader;
} KS_DATAFORMAT_VIDEOINFOHEADER, *PKS_DATAFORMAT_VIDEOINFOHEADER;

typedef struct tagKS_DATAFORMAT_VIDEOINFOHEADER2 {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFOHEADER2     VideoInfoHeader2;
} KS_DATAFORMAT_VIDEOINFOHEADER2, *PKS_DATAFORMAT_VIDEOINFOHEADER2;

typedef struct tagKS_DATAFORMAT_MPEGVIDEOINFO2 {
    KSDATAFORMAT            DataFormat;
    KS_MPEGVIDEOINFO2       MpegVideoInfoHeader2;
} KS_DATAFORMAT_MPEGVIDEOINFO2, *PKS_DATAFORMAT_MPEGVIDEOINFO2;

typedef struct tagKS_DATAFORMAT_VIDEOINFO_PALETTE {
    KSDATAFORMAT            DataFormat;
    KS_VIDEOINFO            VideoInfo;
} KS_DATAFORMAT_VIDEOINFO_PALETTE, *PKS_DATAFORMAT_VIDEOINFO_PALETTE;

typedef struct tagKS_DATAFORMAT_VBIINFOHEADER {
    KSDATAFORMAT            DataFormat;
    KS_VBIINFOHEADER        VBIInfoHeader;
} KS_DATAFORMAT_VBIINFOHEADER, *PKS_DATAFORMAT_VBIINFOHEADER;

typedef struct  _KS_VIDEO_STREAM_CONFIG_CAPS  {
    GUID guid;                  // will be MEDIATYPE_Video
    ULONG VideoStandard;        // logical OR of all AnalogVideoStandards
                                // supported
    SIZE InputSize;             // the inherent size of the incoming signal
                                // (every pixel unique)
    SIZE MinCroppingSize;       // smallest rcSrc cropping rect allowed
    SIZE MaxCroppingSize;       // largest rcSrc cropping rect allowed
    int CropGranularityX;       // granularity of cropping size
    int CropGranularityY;
    int CropAlignX;             // alignment of cropping rect
    int CropAlignY;
    SIZE MinOutputSize;         // smallest bitmap stream can produce
    SIZE MaxOutputSize;         // largest  bitmap stream can produce
    int OutputGranularityX;     // granularity of output bitmap size
    int OutputGranularityY;
    int StretchTapsX;           // 0, no stretch, 1 pix dup, 2 interp, ...
    int StretchTapsY;           //    Describes quality of hardware scaler
    int ShrinkTapsX;            //
    int ShrinkTapsY;            //
    LONGLONG MinFrameInterval;  // 100 nS units
    LONGLONG MaxFrameInterval;
    LONG MinBitsPerSecond;
    LONG MaxBitsPerSecond;
} KS_VIDEO_STREAM_CONFIG_CAPS, *PKS_VIDEO_STREAM_CONFIG_CAPS;

//===========================================================================
// Video DATARANGEs
//===========================================================================

typedef struct tagKS_DATARANGE_VIDEO {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFOHEADER           VideoInfoHeader;        // default format
} KS_DATARANGE_VIDEO, *PKS_DATARANGE_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO2 {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFOHEADER2          VideoInfoHeader;        // default format
} KS_DATARANGE_VIDEO2, *PKS_DATARANGE_VIDEO2;

typedef struct tagKS_DATARANGE_MPEG1_VIDEO {
    KSDATARANGE DataRange;
    BOOL bFixedSizeSamples; // all samples same size?
    BOOL bTemporalCompression; // all I frames?
    DWORD StreamDescriptionFlags; // KS_VIDEO_DESC_*
    DWORD MemoryAllocationFlags; // KS_VIDEO_ALLOC_*
    KS_VIDEO_STREAM_CONFIG_CAPS ConfigCaps;
    KS_MPEG1VIDEOINFO VideoInfoHeader; // default format
} KS_DATARANGE_MPEG1_VIDEO, *PKS_DATARANGE_MPEG1_VIDEO;

typedef struct tagKS_DATARANGE_MPEG2_VIDEO {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_MPEGVIDEOINFO2            VideoInfoHeader;        // default format
} KS_DATARANGE_MPEG2_VIDEO, *PKS_DATARANGE_MPEG2_VIDEO;

typedef struct tagKS_DATARANGE_VIDEO_PALETTE {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VIDEOINFO                 VideoInfo;              // default format
} KS_DATARANGE_VIDEO_PALETTE, *PKS_DATARANGE_VIDEO_PALETTE;

typedef struct tagKS_DATARANGE_VIDEO_VBI {
   KSDATARANGE                  DataRange;
   BOOL                         bFixedSizeSamples;      // all samples same size?
   BOOL                         bTemporalCompression;   // all I frames?
   DWORD                        StreamDescriptionFlags; // KS_VIDEO_DESC_*
   DWORD                        MemoryAllocationFlags;  // KS_VIDEO_ALLOC_*
   KS_VIDEO_STREAM_CONFIG_CAPS  ConfigCaps;
   KS_VBIINFOHEADER             VBIInfoHeader;          // default format
} KS_DATARANGE_VIDEO_VBI, *PKS_DATARANGE_VIDEO_VBI;

typedef struct tagKS_DATARANGE_ANALOGVIDEO {
   KSDATARANGE                  DataRange;
   KS_ANALOGVIDEOINFO           AnalogVideoInfo;
} KS_DATARANGE_ANALOGVIDEO, *PKS_DATARANGE_ANALOGVIDEO;

//===========================================================================
// StreamDescriptionFlags
//
// These define the "purpose" of each video stream
//===========================================================================

#define KS_VIDEOSTREAM_PREVIEW          0x0001  // Preview stream
#define KS_VIDEOSTREAM_CAPTURE          0x0002  // Capture stream
#define KS_VIDEOSTREAM_VBI              0x0010  // Field1 VBI
#define KS_VIDEOSTREAM_NABTS            0x0020  // Field1 NABTS
#define KS_VIDEOSTREAM_CC               0x0100  // Closed Captioning
#define KS_VIDEOSTREAM_EDS              0x0200  // Extended Data Services
#define KS_VIDEOSTREAM_TELETEXT         0x0400  // Field1 Teletext only
#define KS_VIDEOSTREAM_STILL            0x1000  // Still image input
#define KS_VIDEOSTREAM_IS_VPE           0x8000  // Is a VPE based stream?

// MemoryAllocationFlags
#define KS_VIDEO_ALLOC_VPE_SYSTEM       0x0001  // VPE surface in system memory
#define KS_VIDEO_ALLOC_VPE_DISPLAY      0x0002  // VPE surface in display memory
#define KS_VIDEO_ALLOC_VPE_AGP          0x0004  // VPE surface in AGP memory

#if (NTDDI_VERSION >= NTDDI_WINXP)

//////////////////////////////////////////////////////////////
// Capture driver VBI property sets
//////////////////////////////////////////////////////////////

// {F162C607-7B35-496f-AD7F-2DCA3B46B718}
#define STATIC_KSPROPSETID_VBICAP_PROPERTIES\
    0xf162c607, 0x7b35, 0x496f, 0xad, 0x7f, 0x2d, 0xca, 0x3b, 0x46, 0xb7, 0x18
DEFINE_GUIDSTRUCT("F162C607-7B35-496f-AD7F-2DCA3B46B718", KSPROPSETID_VBICAP_PROPERTIES);
#define KSPROPSETID_VBICAP_PROPERTIES DEFINE_GUIDNAMED(KSPROPSETID_VBICAP_PROPERTIES)

typedef enum {
    KSPROPERTY_VBICAP_PROPERTIES_PROTECTION = 0x01,
} KSPROPERTY_VBICAP;

typedef struct _VBICAP_PROPERTIES_PROTECTION_S {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      Status;
} VBICAP_PROPERTIES_PROTECTION_S, *PVBICAP_PROPERTIES_PROTECTION_S;
#define KS_VBICAP_PROTECTION_MV_PRESENT     0x0001L
#define KS_VBICAP_PROTECTION_MV_HARDWARE    0x0002L
#define KS_VBICAP_PROTECTION_MV_DETECTED    0x0004L

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

/***************************************************************************/
/* VBI Related GUIDs, structs and properties for codecs(generic, cc, nabts)*/
/***************************************************************************/

///////////////////////////////////////////////////////////////////////////////////////
// IP/NABTS Protocol Reserved Group IDs - Overall Range 0x800-0x8FF [Decimal 2048-2079]
// Intervening values(0-F) are used if there are multiple providers at a particular tier
///////////////////////////////////////////////////////////////////////////////////////

// Used by individual content creators in show footage/data
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_BASE                 0x800
#define KS_NABTS_GROUPID_ORIGINAL_CONTENT_ADVERTISER_BASE      0x810

// Used by production company in finished show data
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_CONTENT_BASE       0x820
#define KS_NABTS_GROUPID_PRODUCTION_COMPANY_ADVERTISER_BASE    0x830

// Used by broadcast syndicates in syndicated show data
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_CONTENT_BASE          0x840
#define KS_NABTS_GROUPID_SYNDICATED_SHOW_ADVERTISER_BASE       0x850

// Used by tv networks in network television data
#define KS_NABTS_GROUPID_NETWORK_WIDE_CONTENT_BASE             0x860
#define KS_NABTS_GROUPID_NETWORK_WIDE_ADVERTISER_BASE          0x870

// Used by telvision stations in local programming data
#define KS_NABTS_GROUPID_TELEVISION_STATION_CONTENT_BASE       0x880
#define KS_NABTS_GROUPID_TELEVISION_STATION_ADVERTISER_BASE    0x890

// Used by cable system in cable head-end originated data
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_CONTENT_BASE       0x8A0
#define KS_NABTS_GROUPID_LOCAL_CABLE_SYSTEM_ADVERTISER_BASE    0x8B0

// The values between 0x8C0 - 0x8EF are reserved for future expansion

// Used by Microsoft for Testing purposes (0x8F0 - 0x8FF)
#define KS_NABTS_GROUPID_MICROSOFT_RESERVED_TEST_DATA_BASE     0x8F0

//////////////////////////////////////////////////////////////
// Stream Format FEC-corrected NABTS bundles
//////////////////////////////////////////////////////////////

#define STATIC_KSDATAFORMAT_TYPE_NABTS \
 0xe757bca0, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA0-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_TYPE_NABTS);
#define KSDATAFORMAT_TYPE_NABTS DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_NABTS)

#define STATIC_KSDATAFORMAT_SUBTYPE_NABTS_FEC \
 0xe757bca1, 0x39ac, 0x11d1, 0xa9, 0xf5, 0x0, 0xc0, 0x4f, 0xbb, 0xde, 0x8f
DEFINE_GUIDSTRUCT("E757BCA1-39AC-11d1-A9F5-00C04FBBDE8F", KSDATAFORMAT_SUBTYPE_NABTS_FEC);
#define KSDATAFORMAT_SUBTYPE_NABTS_FEC DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_NABTS_FEC)


//////////////////////////////////////////////////////////////
// NABTS Bundle data structure definition
//////////////////////////////////////////////////////////////

#define MAX_NABTS_VBI_LINES_PER_FIELD   11
#define NABTS_LINES_PER_BUNDLE          16
#define NABTS_PAYLOAD_PER_LINE          28
#define NABTS_BYTES_PER_LINE            36

typedef struct _NABTSFEC_BUFFER {
    ULONG       dataSize;
    USHORT      groupID;
    USHORT      Reserved;
    UCHAR       data[NABTS_LINES_PER_BUNDLE * NABTS_PAYLOAD_PER_LINE];
} NABTSFEC_BUFFER, *PNABTSFEC_BUFFER;

//////////////////////////////////////////////////////////////
// vbi codec filtering pin properties
//////////////////////////////////////////////////////////////

#define STATIC_KSPROPSETID_VBICodecFiltering \
    0xcafeb0caL, 0x8715, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0xc0, 0xed, 0xba, 0xbe
DEFINE_GUIDSTRUCT("cafeb0ca-8715-11d0-bd6a-0035c0edbabe", KSPROPSETID_VBICodecFiltering);
#define KSPROPSETID_VBICodecFiltering DEFINE_GUIDNAMED(KSPROPSETID_VBICodecFiltering)

typedef enum {
    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY = 0x01,
    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
    KSPROPERTY_VBICODECFILTERING_STATISTICS,
} KSPROPERTY_VBICODECFILTERING;

typedef struct _VBICODECFILTERING_SCANLINES {
    DWORD   DwordBitArray[32];      // An array of scanline bits 0..1024(32*32)
} VBICODECFILTERING_SCANLINES, *PVBICODECFILTERING_SCANLINES;

typedef struct _VBICODECFILTERING_NABTS_SUBSTREAMS {
    DWORD   SubstreamMask[128];   // An array of 4096 bits (one for each NABTS GroupID)
} VBICODECFILTERING_NABTS_SUBSTREAMS, *PVBICODECFILTERING_NABTS_SUBSTREAMS;

typedef struct _VBICODECFILTERING_CC_SUBSTREAMS {
    DWORD   SubstreamMask;        // An array of 32 bits (see KS_CC_SUBSTREAM *)
} VBICODECFILTERING_CC_SUBSTREAMS, *PVBICODECFILTERING_CC_SUBSTREAMS;

// These KS_CC_SUBSTREAM_* bitmasks are used with VBICODECFILTERING_CC_SUBSTREAMS
#define KS_CC_SUBSTREAM_ODD               0x0001L // Unfiltered Field 1 Data
#define KS_CC_SUBSTREAM_EVEN              0x0002L // Unfiltered Field 2 Data

#if (NTDDI_VERSION >= NTDDI_WINXP)

// The following flags describe CC field 1 substreams: CC1,CC2,TT1,TT2
#define KS_CC_SUBSTREAM_FIELD1_MASK       0x00F0L
#define KS_CC_SUBSTREAM_SERVICE_CC1       0x0010L
#define KS_CC_SUBSTREAM_SERVICE_CC2       0x0020L
#define KS_CC_SUBSTREAM_SERVICE_T1        0x0040L
#define KS_CC_SUBSTREAM_SERVICE_T2        0x0080L

// The following flags describe CC field 2 substreams: CC3,CC4,TT3,TT4,XDS
#define KS_CC_SUBSTREAM_FIELD2_MASK       0x1F00L
#define KS_CC_SUBSTREAM_SERVICE_CC3       0x0100L
#define KS_CC_SUBSTREAM_SERVICE_CC4       0x0200L
#define KS_CC_SUBSTREAM_SERVICE_T3        0x0400L
#define KS_CC_SUBSTREAM_SERVICE_T4        0x0800L
#define KS_CC_SUBSTREAM_SERVICE_XDS       0x1000L

// Special Note: field 1 or 2 substreams are usually on found on field 1 and 2 respectively
// If the VBI odd/even polarity is reversed, the correct filtered data will still be found.

///////////////////////////////////////////////////////////////////
// Hardware decoded CC stream format
///////////////////////////////////////////////////////////////////

#define CC_MAX_HW_DECODE_LINES 12
typedef struct _CC_BYTE_PAIR {
    BYTE        Decoded[2];
    USHORT      Reserved;
} CC_BYTE_PAIR, *PCC_BYTE_PAIR;

typedef struct _CC_HW_FIELD {
    VBICODECFILTERING_SCANLINES  ScanlinesRequested;
    ULONG                        fieldFlags;    // KS_VBI_FLAG_FIELD1,2
    LONGLONG                     PictureNumber;
    CC_BYTE_PAIR                 Lines[CC_MAX_HW_DECODE_LINES];
} CC_HW_FIELD, *PCC_HW_FIELD;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

///////////////////////////////////////////////////////////////////
// Raw NABTS stream format (TYPE_NABTS, SUBTYPE_NABTS)
///////////////////////////////////////////////////////////////////

// These low-level structures are byte packed( -Zp1 )
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <pshpack1.h>
#endif
typedef struct _NABTS_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[NABTS_BYTES_PER_LINE];
} NABTS_BUFFER_LINE, *PNABTS_BUFFER_LINE;

#define NABTS_BUFFER_PICTURENUMBER_SUPPORT 1
typedef struct _NABTS_BUFFER {
    VBICODECFILTERING_SCANLINES     ScanlinesRequested;
    LONGLONG                        PictureNumber;
    NABTS_BUFFER_LINE               NabtsLines[MAX_NABTS_VBI_LINES_PER_FIELD];
} NABTS_BUFFER, *PNABTS_BUFFER;
#if !defined( PACK_PRAGMAS_NOT_SUPPORTED )
#include <poppack.h>
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)

//////////////////////////////////////////////////////////////
// WST Codec Teletext Media Sample Format
//////////////////////////////////////////////////////////////

#define WST_TVTUNER_CHANGE_BEGIN_TUNE    0x1000L  // Starting a tuning operation
#define WST_TVTUNER_CHANGE_END_TUNE      0x2000L  // Ending a tuning operation

#define MAX_WST_VBI_LINES_PER_FIELD   17
#define WST_BYTES_PER_LINE            42

typedef struct _WST_BUFFER_LINE {
    BYTE                            Confidence;
    BYTE                            Bytes[WST_BYTES_PER_LINE];
} WST_BUFFER_LINE, *PWST_BUFFER_LINE;

typedef struct _WST_BUFFER {
    VBICODECFILTERING_SCANLINES        ScanlinesRequested;
    WST_BUFFER_LINE                    WstLines[MAX_WST_VBI_LINES_PER_FIELD];
} WST_BUFFER, *PWST_BUFFER;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//
// Common codec statistics
//

typedef struct _VBICODECFILTERING_STATISTICS_COMMON {
    DWORD   InputSRBsProcessed;         // upstream SRBs received
    DWORD   OutputSRBsProcessed;        // downstream SRBs sent
    DWORD   SRBsIgnored;                // SRBs ignored due to no requests
    DWORD   InputSRBsMissing;           // SRBs dropped upstream
    DWORD   OutputSRBsMissing;          // Output dropped because no SRB pending
    DWORD   OutputFailures;             // dropped because of other failure
    DWORD   InternalErrors;             // could not process due to int. failure
    DWORD   ExternalErrors;             // could not process due to ext. failure
    DWORD   InputDiscontinuities;       // discontinuities received
    DWORD   DSPFailures;                // DSP confidence failure
    DWORD   TvTunerChanges;             // number of received KS_TVTUNER_CHANGE_BEGIN_TUNE and KS_TVTUNER_CHANGE_END_TUNE pairs.
    DWORD   VBIHeaderChanges;           // number of received KS_VBI_FLAG_VBIINFOHEADER_CHANGE
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON, *PVBICODECFILTERING_STATISTICS_COMMON;

typedef struct _VBICODECFILTERING_STATISTICS_COMMON_PIN {
    DWORD   SRBsProcessed;              // SRBs sent/received
    DWORD   SRBsIgnored;                // SRBs ignored due to filtering
    DWORD   SRBsMissing;                // SRBs not sent/received
    DWORD   InternalErrors;             // could not send/receive due to int. failure
    DWORD   ExternalErrors;             // could not send/receive due to ext. failure
    DWORD   Discontinuities;            // discontinuities received/sent
    DWORD   LineConfidenceAvg;          // Average of all DSP confidence results for this pin
    DWORD   BytesOutput;                // Bytes sent downstream
} VBICODECFILTERING_STATISTICS_COMMON_PIN, *PVBICODECFILTERING_STATISTICS_COMMON_PIN;

//
// Codec-specific statistics - NABTS
//

typedef struct _VBICODECFILTERING_STATISTICS_NABTS {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
    DWORD   FECBundleBadLines;          // Un-FEC-correctable lines
    DWORD   FECQueueOverflows;          // Number of times FEC queue overflowed
    DWORD   FECCorrectedLines;          // Lines CSUM corrected by FEC
    DWORD   FECUncorrectableLines;      // FEC input lines not CSUM correctable
    DWORD   BundlesProcessed;           // Bundles received from FEC
    DWORD   BundlesSent2IP;             // Bundles sent to IP driver
    DWORD   FilteredLines;              // Lines processed and then dropped
                                        // because no one was interested
} VBICODECFILTERING_STATISTICS_NABTS, *PVBICODECFILTERING_STATISTICS_NABTS;

typedef struct _VBICODECFILTERING_STATISTICS_NABTS_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_NABTS_PIN, *PVBICODECFILTERING_STATISTICS_NABTS_PIN;

//
// Codec-specific statistics - Closed Caption
//

typedef struct _VBICODECFILTERING_STATISTICS_CC {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_CC, *PVBICODECFILTERING_STATISTICS_CC;


typedef struct _VBICODECFILTERING_STATISTICS_CC_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_CC_PIN, *PVBICODECFILTERING_STATISTICS_CC_PIN;

#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// Codec-specific statistics - Teletext
//

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT {
    VBICODECFILTERING_STATISTICS_COMMON Common; // Generic VBI statistics
} VBICODECFILTERING_STATISTICS_TELETEXT, *PVBICODECFILTERING_STATISTICS_TELETEXT;

typedef struct _VBICODECFILTERING_STATISTICS_TELETEXT_PIN {
    VBICODECFILTERING_STATISTICS_COMMON_PIN Common;// Generic VBI pin statistics
} VBICODECFILTERING_STATISTICS_TELETEXT_PIN, *PVBICODECFILTERING_STATISTICS_TELETEXT_PIN;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

////////////////////////////////////////////////////////////////////////////
// VBI codec property structures(based on KSPROPERTY_VBICODECFILTERING enum)
////////////////////////////////////////////////////////////////////////////

// *** Most codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SCANLINES_REQUESTED_BIT_ARRAY
//    KSPROPERTY_VBICODECFILTERING_SCANLINES_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                          Property;
    VBICODECFILTERING_SCANLINES         Scanlines;
} KSPROPERTY_VBICODECFILTERING_SCANLINES_S, *PKSPROPERTY_VBICODECFILTERING_SCANLINES_S;

// *** NABTS codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                          Property;
    VBICODECFILTERING_NABTS_SUBSTREAMS  Substreams;
} KSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_NABTS_SUBSTREAMS_S;

// *** Closed captioning codecs support this property
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_REQUESTED_BIT_ARRAY,
//    KSPROPERTY_VBICODECFILTERING_SUBSTREAMS_DISCOVERED_BIT_ARRAY,
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_CC_SUBSTREAMS         Substreams;
} KSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S, *PKSPROPERTY_VBICODECFILTERING_CC_SUBSTREAMS_S;

// *** Most codecs support these versions of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_COMMON_PIN Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_COMMON_PIN_S;

// *** NABTS codecs support this version of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS
typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS      Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_NABTS_PIN  Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_NABTS_PIN_S;

// *** Closed captioning codecs support this version of the global and pin properties
//    KSPROPERTY_VBICODECFILTERING_STATISTICS

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC         Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_S;

typedef struct {
    KSPROPERTY                              Property;
    VBICODECFILTERING_STATISTICS_CC_PIN     Statistics;
} KSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S, *PKSPROPERTY_VBICODECFILTERING_STATISTICS_CC_PIN_S;

// Standard Pin Names for the video capture filter
//===========================================================================

#define STATIC_PINNAME_VIDEO_CAPTURE \
    0xfb6c4281, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_CAPTURE STATIC_PINNAME_VIDEO_CAPTURE
DEFINE_GUIDSTRUCT("FB6C4281-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CAPTURE);
#define PINNAME_VIDEO_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CAPTURE)
#define PINNAME_CAPTURE PINNAME_VIDEO_CAPTURE

#if (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_PINNAME_VIDEO_CC_CAPTURE \
    0x1aad8061, 0x12d, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_CC_CAPTURE STATIC_PINNAME_VIDEO_CC_CAPTURE
DEFINE_GUIDSTRUCT("1AAD8061-012D-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_CC_CAPTURE);
#define PINNAME_VIDEO_CC_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_CC_CAPTURE)

#define STATIC_PINNAME_VIDEO_NABTS_CAPTURE \
    0x29703660, 0x498a, 0x11d2, 0xb4, 0xb1, 0x0, 0xa0, 0xd1, 0x2, 0xcf, 0xbe
#define STATIC_PINNAME_NABTS_CAPTURE STATIC_PINNAME_VIDEO_NABTS_CAPTURE
DEFINE_GUIDSTRUCT("29703660-498A-11d2-B4B1-00A0D102CFBE", PINNAME_VIDEO_NABTS_CAPTURE);
#define PINNAME_VIDEO_NABTS_CAPTURE DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS_CAPTURE)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define STATIC_PINNAME_VIDEO_PREVIEW \
    0xfb6c4282, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
#define STATIC_PINNAME_PREVIEW STATIC_PINNAME_VIDEO_PREVIEW
DEFINE_GUIDSTRUCT("FB6C4282-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_PREVIEW);
#define PINNAME_VIDEO_PREVIEW DEFINE_GUIDNAMED(PINNAME_VIDEO_PREVIEW)
#define PINNAME_PREVIEW PINNAME_VIDEO_PREVIEW

#define STATIC_PINNAME_VIDEO_ANALOGVIDEOIN \
    0xfb6c4283, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4283-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_ANALOGVIDEOIN);
#define PINNAME_VIDEO_ANALOGVIDEOIN DEFINE_GUIDNAMED(PINNAME_VIDEO_ANALOGVIDEOIN)

#define STATIC_PINNAME_VIDEO_VBI \
    0xfb6c4284, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4284-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VBI);
#define PINNAME_VIDEO_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VBI)

#define STATIC_PINNAME_VIDEO_VIDEOPORT \
    0xfb6c4285, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4285-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT);
#define PINNAME_VIDEO_VIDEOPORT DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT)

#define STATIC_PINNAME_VIDEO_NABTS \
    0xfb6c4286, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4286-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_NABTS);
#define PINNAME_VIDEO_NABTS DEFINE_GUIDNAMED(PINNAME_VIDEO_NABTS)

#define STATIC_PINNAME_VIDEO_EDS \
    0xfb6c4287, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4287-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_EDS);
#define PINNAME_VIDEO_EDS DEFINE_GUIDNAMED(PINNAME_VIDEO_EDS)

#define STATIC_PINNAME_VIDEO_TELETEXT \
    0xfb6c4288, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4288-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TELETEXT);
#define PINNAME_VIDEO_TELETEXT DEFINE_GUIDNAMED(PINNAME_VIDEO_TELETEXT)

#define STATIC_PINNAME_VIDEO_CC \
    0xfb6c4289, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C4289-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_CC);
#define PINNAME_VIDEO_CC DEFINE_GUIDNAMED(PINNAME_VIDEO_CC)

#define STATIC_PINNAME_VIDEO_STILL \
    0xfb6c428A, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428A-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_STILL);
#define PINNAME_VIDEO_STILL DEFINE_GUIDNAMED(PINNAME_VIDEO_STILL)

#define STATIC_PINNAME_VIDEO_TIMECODE \
    0xfb6c428B, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428B-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_TIMECODE);
#define PINNAME_VIDEO_TIMECODE DEFINE_GUIDNAMED(PINNAME_VIDEO_TIMECODE)

#define STATIC_PINNAME_VIDEO_VIDEOPORT_VBI \
    0xfb6c428C, 0x353, 0x11d1, 0x90, 0x5f, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("FB6C428C-0353-11d1-905F-0000C0CC16BA", PINNAME_VIDEO_VIDEOPORT_VBI);
#define PINNAME_VIDEO_VIDEOPORT_VBI DEFINE_GUIDNAMED(PINNAME_VIDEO_VIDEOPORT_VBI)

// KSPROPSETID_VIDMEM_TRANSPORT related guids, structs and enums
//===========================================================================

//
// Capture MemoryAllocationFlags
//
typedef enum {
        KS_CAPTURE_ALLOC_INVALID                = 0,
        KS_CAPTURE_ALLOC_SYSTEM                 = 0x0001,  // surface in system memory
        KS_CAPTURE_ALLOC_VRAM                   = 0x0002,  // surface in display memory
        KS_CAPTURE_ALLOC_SYSTEM_AGP             = 0x0004,  // surface in system memory tagged as AGP accessible
        KS_CAPTURE_ALLOC_VRAM_MAPPED    = 0x0008   // surface in system memory mapped into VRAM address space
}CAPTURE_MEMORY_ALLOCATION_FLAGS, *PCAPTURE_MEMORY_ALLOCATION_FLAGS;

//
//Video memory capture KSPROPSETID
//
#define STATIC_KSPROPSETID_VramCapture\
    0xe73face3, 0x2880, 0x4902, 0xb7, 0x99, 0x88, 0xd0, 0xcd, 0x63, 0x4e, 0xf
DEFINE_GUIDSTRUCT("E73FACE3-2880-4902-B799-88D0CD634E0F", KSPROPSETID_VramCapture);
#define KSPROPSETID_VramCapture DEFINE_GUIDNAMED(KSPROPSETID_VramCapture)

typedef enum { 
    //
    // enum value '0' means an invalid KSPROPERTY request. 
    // Drivers should return an error.
    //
    KSPRO